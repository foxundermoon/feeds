<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>编程杂谈</title>
<link>https://henix.github.io/feeds/zhuanlan.c_131397850/</link>
<description>记录编程的日常 &amp; 学习的过程 &amp; 奇技淫巧</description>
<language>zh-cn</language>
<lastBuildDate>Fri, 04 May 2018 03:23:31 +0800</lastBuildDate>
<item>
<title>[珂学の暴力]ODT / Chtholly Tree</title>
<link>https://henix.github.io/feeds/zhuanlan.c_131397850/2018-04-29-36258811.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36258811&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-488b148addb4c012ebc3855217f99463_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;0x00 Prologue&lt;/h2&gt;&lt;p&gt;最近闲下来了...刷CF的时候奇奇怪怪地刷到了珂朵莉round(&lt;a href=&quot;http://codeforces.com/contest/896&quot;&gt;Codeforces Round #449 (Div. 1)&lt;/a&gt;)。里面的题可以说是非(shí)常(fēn)奈(dú)斯(liú)了。其中有一道题很有趣——&lt;a href=&quot;https://www.luogu.org/problemnew/show/CF896C&quot;&gt;CF896C&lt;/a&gt;(洛谷)。写一个数据结构，支持以下4个操作&lt;/p&gt;&lt;ul&gt;&lt;li&gt;将区间 &lt;equation&gt;[L,R]&lt;/equation&gt; 中的所有数加上 &lt;equation&gt;v&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;将区间 &lt;equation&gt;[L,R]&lt;/equation&gt; 中的所有数改成 &lt;equation&gt;v&lt;/equation&gt; （这个是ODT优势体现的操作）&lt;/li&gt;&lt;li&gt;输出区间 &lt;equation&gt;[L,R]&lt;/equation&gt; 中第 &lt;equation&gt;k&lt;/equation&gt; 大的数&lt;/li&gt;&lt;li&gt;输出 &lt;equation&gt;\sum_{i=L}^{R}a_i^k&lt;/equation&gt; ，即 &lt;equation&gt;[L,R]&lt;/equation&gt; 区间内元素的 &lt;equation&gt;k&lt;/equation&gt; 次幂和&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;数据随机！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对于这类有&lt;b&gt;区间推平&lt;/b&gt;操作数据又随机的题，ODT就十分适用了&lt;/p&gt;&lt;p&gt;UPD @ 04 / 29 / 18 04:33 p.m.&lt;/p&gt;&lt;p&gt;（julao &lt;a href=&quot;https://www.zhihu.com/people/37eef0f3735cc109b9164465cc7b5422&quot; data-hash=&quot;37eef0f3735cc109b9164465cc7b5422&quot; class=&quot;member_mention&quot; data-hovercard=&quot;p$b$37eef0f3735cc109b9164465cc7b5422&quot;&gt;@Guanghao Ye&lt;/a&gt;来批判了：老司机树原版是lxl搞的！老司机树原版是lxl搞的！老司机树原版是lxl搞的！）。&lt;/p&gt;&lt;p&gt;~~老司机擅长推车，珂朵莉擅长推平区间！~~&lt;/p&gt;&lt;p&gt;本文将以这道题作为例子讲解Old Driver Tree / 珂朵莉树的智慧 / 暴力美学。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-341a3f688cc7576707c68ca258d56566_r.jpg&quot; data-size=&quot;normal&quot; data-watermark=&quot;watermark&quot; data-rawwidth=&quot;486&quot; data-watermark-src=&quot;v2-51c54d40eb87200d7e46ed5e2f9757f1&quot;&gt;&lt;hr&gt;&lt;h2&gt;0x01 如何维护？&lt;/h2&gt;&lt;p&gt;珂朵莉树将区间信息以三元组的形式存储，即用 &lt;equation&gt;(L,R,v)&lt;/equation&gt; 表示 &lt;equation&gt;[L,R]&lt;/equation&gt; 中的元素为 &lt;equation&gt;v&lt;/equation&gt; 。从这里就能看出为什么珂朵莉树对于区间推平较为高效了。我们用&lt;code class=&quot;inline&quot;&gt;set&lt;/code&gt;存储这些三元组，内部维护这些区间，以左端点 &lt;equation&gt;L&lt;/equation&gt; 作为关键字进行升序排列，这样方便我们进行一些操作的时候方便查找到我们想要修改的区间。区间节点结构如下：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;struct Node {
    int l, r;
    mutable ll v; // 在用迭代器访问时能够修改值
    Node(){}
    Node(int L, int R=-1, LL V=0l): l(L), r(R), v(V){}
    bool operator &amp;lt; (const Node&amp;amp; b) const {
        return l &amp;lt; b.l;
    }
};
&lt;/code&gt;&lt;p&gt;&lt;b&gt;一些操作？不不不，其实核心操作只有一个：&lt;/b&gt;&lt;code class=&quot;inline&quot;&gt;split(p)&lt;/code&gt;——将 &lt;equation&gt;p&lt;/equation&gt; 所在区间拆分为 &lt;equation&gt;[L,p-1]&lt;/equation&gt; 和 &lt;equation&gt;[p, R]&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;由于在&lt;code class=&quot;inline&quot;&gt;set&lt;/code&gt;中的所有节点是有序的，我们可以用&lt;code class=&quot;inline&quot;&gt;lower_bound(x)&lt;/code&gt;定位我们要操作的区间。（注: &lt;code class=&quot;inline&quot;&gt;lower_bound(x)&lt;/code&gt;可以在$logn$时间内在一个有序序列中找到最小的 &lt;equation&gt;y&lt;/equation&gt; 使得 &lt;equation&gt;y\geq x&lt;/equation&gt; 并返回 &lt;equation&gt;y&lt;/equation&gt; 的位置 / 迭代器，一个二分查找的过程）&lt;/p&gt;&lt;p&gt;这时我们要分以下两种情况处理通过 &lt;equation&gt;p&lt;/equation&gt; 找到的区间：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果 &lt;equation&gt;p&lt;/equation&gt; 已经是某个区间的左端点，那么我们直接返回查找到的迭代器;&lt;/li&gt;&lt;li&gt;如果 &lt;equation&gt;p&lt;/equation&gt; 不是某个区间的左端点，那么当前返回的迭代器所指向的区间是 &lt;equation&gt;p&lt;/equation&gt; 所在区间右边第一个区间。这时将迭代器后移一位。如果在后移之后， &lt;equation&gt;p&lt;/equation&gt; 比当前区间的右端点还大，那么直接返回尾迭代器(因为不需要进行操作)；否则 &lt;equation&gt;p\in [L&#39;,R&#39;]&lt;/equation&gt; ，那么记录一下当前区间的信息，然后直接删除当前区间再插入拆分好的区间 &lt;equation&gt;[L,p-1]&lt;/equation&gt; 和 &lt;equation&gt;[p,R]&lt;/equation&gt; ，最后返回 &lt;equation&gt;p&lt;/equation&gt; 所在区间的迭代器(操作只会影响包含 &lt;equation&gt;p&lt;/equation&gt; 的区间)。&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;cpp&quot;&gt;inline set&amp;lt;Node&amp;gt;::iterator split(int p) {
    auto it = s.lower_bound(Node(p));
    if(it != s.end() &amp;amp;&amp;amp; it-&amp;gt;l == p) return it; // 情况一
    --it;                                      // 找到p所在区间
    if(it-&amp;gt;r &amp;lt; p) return s.end();              // 不需要拆分
    int L = it-&amp;gt;l, R=it-&amp;gt;r;                    // 记录信息
    LL v = it-&amp;gt;v;
    s.erase(it);
    s.insert(Node(L, p - 1, v));               // 插入新区间
    return s.insert(Node(p, R, v)).first;
}
&lt;/code&gt;&lt;hr&gt;&lt;h2&gt;0x02 实现操作&lt;/h2&gt;&lt;p&gt;&lt;b&gt;1. 区间赋值&lt;/b&gt;&lt;/p&gt;&lt;p&gt;有了split之后，我们就能利用split做各种神(bao)奇(li)的操作了。先来看一个区间赋值的操作。&lt;/p&gt;&lt;p&gt;现在给定了我们 &lt;equation&gt;L&lt;/equation&gt; , &lt;equation&gt;r&lt;/equation&gt; 和 &lt;equation&gt;v&lt;/equation&gt; 。首先为了能够暴力，我们先把 &lt;equation&gt;r+1&lt;/equation&gt; 和 &lt;equation&gt;L&lt;/equation&gt; 所在区间各自拆分出来。既然我们是区间赋值(推平)，我们可以直接将 &lt;equation&gt;[L,R)&lt;/equation&gt; 从&lt;code class=&quot;inline&quot;&gt;set&lt;/code&gt;中移除再添加一个新的 &lt;equation&gt;[L&#39;,R&#39;]&lt;/equation&gt; 区间，其中的值为 &lt;equation&gt;v&lt;/equation&gt; :&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;inline void modify(int l,int r,int v) {
    auto R=split(r+1), L = split(l);
    s.erase(L, R);
    s.insert(Node(l, r, v));
    return;
}
&lt;/code&gt;&lt;p&gt;在这个操作的过程中会有许多小区间被合并到 &lt;equation&gt;[L,R]&lt;/equation&gt; ，因此空间复杂度会大大减小。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. 区间加&lt;/b&gt;&lt;/p&gt;&lt;p&gt;第一步与区间赋值一样，首先拆分 &lt;equation&gt;L&lt;/equation&gt; 和 &lt;equation&gt;r+1&lt;/equation&gt; 。之后，我们直接暴力修改 &lt;equation&gt;[L&#39;,R&#39;)&lt;/equation&gt; 中的值，由于数据随机，所以复杂度并不会爆时间。&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;inline void add(int l, int r, int v) {
    auto R = split(r+1), L=split(l);
    while(L != R) {
       L-&amp;gt;v += v;
       ++L;
    }
    return;
}
&lt;/code&gt;&lt;p&gt;区间$k$次幂和与区间加操作十分类似，大家可以尝试写一个。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;3. 区间第&lt;/b&gt; &lt;equation&gt;k&lt;/equation&gt; &lt;b&gt;大&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这才是真正的暴力。第一步依旧是拆分 &lt;equation&gt;r+1&lt;/equation&gt; 与 &lt;equation&gt;L&lt;/equation&gt; 。然后我们将 &lt;equation&gt;[L&#39;, R&#39;)&lt;/equation&gt; 中所有区间拿出来，将区间长度和区间值存到pair，放到vector里，然后对其中所有区间按照 &lt;equation&gt;v&lt;/equation&gt; 升序排列。然后遍历vector，每次将 &lt;equation&gt;k&lt;/equation&gt; 减去当前区间长度，直到 &lt;equation&gt;k\leq 0&lt;/equation&gt; 。十分的暴力，但是由于数据随机和区间合并时导致区间数量减少，我们依旧能过题。&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;inline ll kth(int l, int r,int k) {
    auto R = split(r+1), L = split(l);
    vector&amp;lt;pii&amp;gt; vec;
    while(L != R) {
        vec.push_back(make_pair(L-&amp;gt;v, L-&amp;gt;r - L-&amp;gt;l + 1));
        ++L;
    }
    sort(vec.begin(), vec.end(), [=](pii a, pii b) -&amp;gt; bool {
        return a.first &amp;lt; b.first;
    });
    for(auto i: vec) {
        k -= i.second;
        if(k &amp;lt;= 0) return i.first;
    }
    return -1;
}
&lt;/code&gt;&lt;hr&gt;&lt;h2&gt;0x03 注意事项&lt;/h2&gt;&lt;p&gt;虽然ODT / 珂朵莉树写起来十分容易，并且十分暴力，但是这个数据结构有一些使用上的限制：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;适用于有区间推平 / 覆盖操作的&lt;/li&gt;&lt;li&gt;&lt;b&gt;数据是随机的&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;数据随机很重要，因为如果推平区间操作很少 / 很多单点，珂朵莉会被卡掉呀QwQ&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;0x04 Epilogue&lt;/h2&gt;&lt;p&gt;在知乎写了一半不知道为什么草稿没有保存，打开之后是空的…是空的！！！心态崩了呀，于是我重新写了大半篇TuT。继续刷CF准备10月校赛….&lt;/p&gt;</description>
<author>Mike He</author>
<guid isPermaLink="false">2018-04-29-36258811</guid>
<pubDate>Sun, 29 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>写程序得女友——日本OJ Paiza Online Hackathon小游戏&quot;恋爱SLG&quot;题解</title>
<link>https://henix.github.io/feeds/zhuanlan.c_131397850/2018-02-20-33889772.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33889772&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f7b6e81a0612b80136a168c0a2165e24_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;Progue——&quot;Get a girlfriend in Programming&quot;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;本文图片较多，请谨慎食用~&lt;/b&gt;&lt;/p&gt;&lt;p&gt;今天早上某群友聊着聊着就说：“找什么女朋友，和自己写的代码谈恋爱多好”&lt;/p&gt;&lt;p&gt;群主( &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/cfdff5f2b3a6269a153d8e6727c46ee4&quot; data-hash=&quot;cfdff5f2b3a6269a153d8e6727c46ee4&quot; data-hovercard=&quot;p$b$cfdff5f2b3a6269a153d8e6727c46ee4&quot;&gt;@KAAAsS&lt;/a&gt; )：“哎？有个网站真的可以！”&lt;/p&gt;&lt;p&gt;这个网站叫&lt;a href=&quot;https://paiza.jp/&quot;&gt;Paiza(拍砸) Online Hackathon&lt;/a&gt;，日本的一个在线测评网站，有点类似LeetCode。同时这个OJ也支持好多语言。这个网站(为了吸引人气)做了个小游戏叫&quot;恋爱SLG&quot;，说是SLG其实是个换装游戏...有很多衣服和饰品都是没有解锁的，想要解锁很简单：不需要氪金，不需要肝，做几道算法题就通关！(蜜汁押韵)。题目都不难，但是由于题目描述全是日语的，而我...只能靠看动(li)漫(fan)和玩游(huang)戏(you)的经验搭配Google Translate食用...在贴题解的同时我把题意也附上吧！&lt;/p&gt;&lt;p&gt;附上可以使用的语言列表：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a840c687e23955a0a6bbdf685577b6d1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;282&quot; data-rawheight=&quot;634&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-dfcb38c8cff7ebd4baa02e221761457d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;288&quot; data-rawheight=&quot;270&quot;&gt;&lt;p&gt;话不多说，老婆我来啦！！！！&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e11bb17515443c7fc62b32d7823a6f92_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;255&quot; data-rawheight=&quot;255&quot;&gt;&lt;hr&gt;&lt;h2&gt;Trial&lt;/h2&gt;&lt;p&gt;这里可以体验一下这个游戏的玩法：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f56d93493d5cdd1e12ee0cad0e1a7618_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1882&quot; data-rawheight=&quot;1236&quot;&gt;&lt;p&gt;右边四栏是可以选择换掉的衣服 / 饰品 / 面部表情之类的东西，比如我们可以把瞳色换成红色:&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d66b0d482c307cd1c4417be05f5d5c31_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;580&quot; data-rawheight=&quot;380&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-11d8b7bad235904af84bf4c3881aa13b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;802&quot; data-rawheight=&quot;740&quot;&gt;&lt;p&gt;“哇，我**社保！”。按捺住激动的心情，开始解锁所有姿势...啊不，服饰吧！&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;第一层——面部 &amp;amp; 肩部饰品&lt;/h2&gt;&lt;p&gt;&lt;b&gt;1. つり目セット(这是啥...好像是眼角的外观？)&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;ある正の整数 n が入力されます。n 回「Ann」と繋げて「AnnAnnAnnAnn......」と出力して下さい。&lt;/blockquote&gt;&lt;p&gt;输入：&lt;/p&gt;&lt;blockquote&gt;3&lt;/blockquote&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;blockquote&gt;AnnAnnAnn&lt;/blockquote&gt;&lt;p&gt;看样例就能猜出来...输入一个正整数 &lt;equation&gt;N&lt;/equation&gt; ，输出 &lt;equation&gt;N&lt;/equation&gt; 次 &#39;Ann&#39;&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;n = int(input())
print(&#39;Ann&#39; * n)&lt;/code&gt;&lt;p&gt;第一道题就解决了...非常simple！于是&lt;/p&gt;&lt;p&gt;&lt;b&gt;つり目セット Get!&lt;/b&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;b&gt;2. 眼帯(中二病必备的那个眼罩)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;题目描述: &lt;/p&gt;&lt;blockquote&gt;あなたは、巻数が全 N 巻の古い本を集めています。古本屋に訪れたあなたは売られている各巻のうち買うべきなのは何巻かを知りたいです。&lt;br&gt;あなたの持っている巻のリストと、中古本屋で売られている巻のリストを入力として与えられたとき、&lt;br&gt;あなたの買うべき巻のリストを出力してください。&lt;/blockquote&gt;&lt;p&gt;题意: 给定两个正整数集 &lt;equation&gt;S_1&lt;/equation&gt; , &lt;equation&gt;S_2&lt;/equation&gt; ，将在 &lt;equation&gt;S_2&lt;/equation&gt;中，但不在 &lt;equation&gt;S_1&lt;/equation&gt; 中的整数升序输出，如果答案为空，输出None。&lt;/p&gt;&lt;p&gt;输入: &lt;/p&gt;&lt;p&gt;第一行一个正整数 &lt;equation&gt;N&lt;/equation&gt; 表示两个集合中最大的数不大于 &lt;equation&gt;N&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;第二行一个正整数 &lt;equation&gt;M&lt;/equation&gt; ，接下来一行有 &lt;equation&gt;M&lt;/equation&gt; 个数，表示 &lt;equation&gt;S_1&lt;/equation&gt; 中包含的元素&lt;/p&gt;&lt;p&gt;第四行一个正整数 &lt;equation&gt;K&lt;/equation&gt; ，接下来一行有 &lt;equation&gt;K&lt;/equation&gt; 个数，表示 &lt;equation&gt;S_2&lt;/equation&gt; 中包含的元素&lt;/p&gt;&lt;p&gt;样例输入:&lt;/p&gt;&lt;blockquote&gt;5&lt;br&gt;3&lt;br&gt;1 3 4&lt;br&gt;3&lt;br&gt;2 3 5&lt;/blockquote&gt;&lt;p&gt;样例输出:&lt;/p&gt;&lt;blockquote&gt;2 5&lt;/blockquote&gt;&lt;p&gt;题解:&lt;/p&gt;&lt;p&gt;这也能算题么....用Python的话，&lt;code class=&quot;inline&quot;&gt;set&lt;/code&gt;有一个函数&lt;code class=&quot;inline&quot;&gt;difference()&lt;/code&gt;，可以直接解决问题....&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;_ = int(input())
M = int(input())
S1 = set([int(x) for x in input().split()])
K = int(input())
S2 = set([int(x) for x in input().split()])
ans = sorted(S2.difference(S1))
if ans:
    print(*ans)
else:
    print(&#39;None&#39;)&lt;/code&gt;&lt;hr&gt;&lt;p&gt;&lt;b&gt;3. 猫耳(四斋福利)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;我！社保！！！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这个必须有！必须有啊！！！&lt;/p&gt;&lt;p&gt;-----咳咳咳，正经的分割线-----&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9badfb2bee22449219a4032ab1d4d4f1_r.jpg&quot; data-caption=&quot;题目描述&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1842&quot; data-rawheight=&quot;764&quot;&gt;&lt;p&gt;题意：输入一个由字符&#39;c&#39;, &#39;a&#39;, &#39;t&#39;构成的字符串，求字符串&#39;cat&#39;作为子串出现的次数。&lt;/p&gt;&lt;p&gt;(某同学：KMP!KMP!!&lt;/p&gt;&lt;p&gt;(另外一个同学: Sunday!Sunday!&lt;/p&gt;&lt;p&gt;数据规模： &lt;equation&gt;1 \leq len(S) \leq 100&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&amp;lt;del&amp;gt;(呵，OIer(大大大雾&amp;lt;/del&amp;gt;&lt;/p&gt;&lt;p&gt;直接上代码吧...没什么好说的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;print(input().count(&#39;cat&#39;))&lt;/code&gt;&lt;p&gt;&lt;b&gt;猫耳 Get!! (我知道你们已经按捺不住了(x:&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-174f80280549103e6c0e7b738c065753_r.jpg&quot; data-caption=&quot;字幕: 带上啦！诶嘿嘿....、稍微有点害羞喵~&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;906&quot; data-rawheight=&quot;1154&quot;&gt;&lt;p&gt;&lt;b&gt;我！社保！！！&lt;/b&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;b&gt;4. 猫(Glavo(雾))&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-427db2cb5a63288965130429a1027c18_r.jpg&quot; data-caption=&quot;题目描述&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1882&quot; data-rawheight=&quot;1090&quot;&gt;&lt;p&gt;题意：输入一个由&#39;c&#39;, &#39;a&#39;, &#39;t&#39;组成的字符串，输出出现次数最少的，出现次数最多的次数减去&#39;c&#39;出现的次数 | 减去&#39;a&#39;出现的次数 | 减去&#39;t&#39;出现的次数&lt;/p&gt;&lt;p&gt;样例见上图，这题也就是个无脑模拟...做完事了：&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;ans = [0] * 3
S = input()
for i in S:
    if i == &#39;c&#39;:
        ans[0] += 1
    elif i == &#39;a&#39;:
        ans[1] += 1
    elif i == &#39;t&#39;:
        ans[2] += 1
p = max(ans)
q = min(ans)
print(q)
for i in ans:
    print(p - i)&lt;/code&gt;&lt;p&gt;&lt;b&gt;Glavo, Get! 这个是趴在肩上的小猫咪OvO:&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ef30d10bc056313ef9a6a177e3a8a99c_r.jpg&quot; data-caption=&quot;字幕(大意): 你净看可爱的小猫猫了！也看看人家嘛，嘤嘤嘤QuQ~&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;822&quot; data-rawheight=&quot;1102&quot;&gt;&lt;p&gt;老夫的少女心啊....！！&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;第二层——发型&lt;/h2&gt;&lt;p&gt;&lt;b&gt;1. ショートヘアセット(短发?)&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f7c82eeb9edf8ae230cd16a03c128f9d_r.jpg&quot; data-caption=&quot;题目描述&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1844&quot; data-rawheight=&quot;712&quot;&gt;&lt;p&gt;A....A+B Problem！！&lt;/p&gt;&lt;p&gt;&lt;b&gt;ショートヘアセット, Get:&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3169bcc0ae8e6227233c7a176143e744_r.jpg&quot; data-caption=&quot;字幕：今天能在一起...我好开心呀！&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;832&quot; data-rawheight=&quot;1114&quot;&gt;&lt;hr&gt;&lt;p&gt;&lt;b&gt;2. ロングヘアセット(长发?)&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7b9ba8d31ff7b87a121b6f8d1ac10853_r.jpg&quot; data-caption=&quot;题目描述&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1840&quot; data-rawheight=&quot;1264&quot;&gt;&lt;p&gt;题意：有5个投票，每票是yes或no，输出数量多的一方&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;a = {&#39;yes&#39;: 0, &#39;no&#39;: 0}
for i in range(5):
    p = input()
    a[p] += 1
print(&#39;yes&#39; if a[&#39;yes&#39;]&amp;gt;a[&#39;no&#39;] else &#39;no&#39;)&lt;/code&gt;&lt;p&gt;&lt;b&gt;ロングヘアセット, Get:&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2a3610436c51e1fea7aa3d45add3a1bf_r.jpg&quot; data-caption=&quot;字幕: 诶嘿嘿...、稍微有点害羞呢，偶尔这样(打扮)一下也挺好的吧？&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;830&quot; data-rawheight=&quot;1114&quot;&gt;&lt;p&gt;&amp;lt;del&amp;gt;怎么有点像LL里的俄罗斯老流氓&amp;lt;/del&amp;gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;b&gt;3. ポニーテールセット(单马尾)&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-03a9042c20e2a11420cbd75f7afe9272_r.jpg&quot; data-caption=&quot;题目描述&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1844&quot; data-rawheight=&quot;642&quot;&gt;&lt;p&gt;题意：Count down...没啥好说的:D&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;n = int(input())
while n&amp;gt;=0:
    if n:
        print(n)
    else:
        print(&#39;{}!!&#39;.format(n))
    n -= 1&lt;/code&gt;&lt;p&gt;&lt;b&gt;ポニーテールセット, Get:&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1967549f0f3c1907958948223ddfa685_r.jpg&quot; data-caption=&quot;字幕: 重了&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;842&quot; data-rawheight=&quot;1118&quot;&gt;&lt;hr&gt;&lt;p&gt;&lt;b&gt;4. ツインテールセット(传说中的双！马！尾！)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;我！社保！！！&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9ab3759d2af61fe7e36477d35567d9b5_r.jpg&quot; data-caption=&quot;题目描述&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1840&quot; data-rawheight=&quot;832&quot;&gt;&lt;p&gt;题意：给定两组药剂(?)编号为1, 2，每组标有净含量和价格，输出单位质量更贵的一组的编号。&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;a1, a2 = map(int, input().split())
b1, b2 = map(int, input().split())
if a1 / a2 &amp;gt; b1 / b2:
    print(1)
else:
    print(2)&lt;/code&gt;&lt;p&gt;&lt;b&gt;ツインテールセット, Get! :&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f2d0716a2e1ec1199154490a27e8e273_r.jpg&quot; data-caption=&quot;字幕: 还是重的&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;840&quot; data-rawheight=&quot;1124&quot;&gt;&lt;p&gt;（有种爱抖露既视感....???&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;服装(划重点!)&lt;/h2&gt;&lt;p&gt;&lt;b&gt;1. セーラー服セット(水...水水....水手服！！！！)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;我！社保！！！* 10086&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-69ec13a890b9c75cf7900d7a0ab333fd_r.jpg&quot; data-caption=&quot;题目描述&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1838&quot; data-rawheight=&quot;788&quot;&gt;&lt;p&gt;题意: 看例子...嗯，就是用下划线把所有词连成一个字符串&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;n = int(input())
a = []
for i in range(n):
    a.append(input())
print(&#39;_&#39;.join(a))&lt;/code&gt;&lt;p&gt;&lt;b&gt;セーラー服セット， Get!:&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-72dfb90f4c438e09c66257c9863d7c75_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;896&quot; data-rawheight=&quot;1160&quot;&gt;&lt;p&gt;prprprprprprprprprprprprpr，字幕都不打了，我就prpr！&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;b&gt;2. カーディガンセット(棉服—应该也是制服！)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;我！你懂吧！！&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-18739e3d7871ffdf751b3d4da7ac6200_r.jpg&quot; data-caption=&quot;题目描述&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1856&quot; data-rawheight=&quot;1080&quot;&gt;&lt;p&gt;题意：阶乘&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;from functools import reduce
n = int(input()) + 1
print(reduce(lambda x, y: x * y, range(1, n)))&lt;/code&gt;&lt;p&gt;&lt;b&gt;カーディガンセット, Get! :&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-69c5c9037d0dfb5f0dfaec1b29ee6a10_r.jpg&quot; data-caption=&quot;字幕: 换号啦！诶嘿嘿~对呀对呀~Paiza里面有我的壁纸哦~&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;840&quot; data-rawheight=&quot;1120&quot;&gt;&lt;p&gt;呜呜呜！！小姐姐真好看！！！美哭啦！&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;b&gt;3. 縞ニーソセット(袜子)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;(为了不暴露特殊癖好，我保持冷静与沉默)&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7b23b09d1dc2450b4470c3fcbec624fc_r.jpg&quot; data-caption=&quot;题目描述&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1844&quot; data-rawheight=&quot;968&quot;&gt;&lt;p&gt;题意：输入两个正整数n和m，输出长度为m的字符串，其中n次&#39;R&#39;与n次&#39;W&#39;交替出现。具体看题目的例子。&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;a = [&#39;R&#39;, &#39;W&#39;]
i = 0
n = int(input())
m = int(input())
while m:
    for j in range(n):
        if m:
            print(a[i], end=&#39;&#39;)
            m -= 1
    i ^= 1&lt;/code&gt;&lt;p&gt;&lt;b&gt;縞ニーソセット, Get:&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-94ffc7b57cd803677cdc16976ffb5526_r.jpg&quot; data-caption=&quot;没有字幕啦哈哈哈哈&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;750&quot; data-rawheight=&quot;1090&quot;&gt;&lt;p&gt;我**舔....咳咳咳，没什么&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;b&gt;4. メイド服セット(是的！你没看错！妹抖服！！！！)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;我！社保！* 65536&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-79ab9b8889c4c49ba31797ac91d54b3c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1856&quot; data-rawheight=&quot;1278&quot;&gt;&lt;p&gt;题意：小A每天睡6个小时，每天早上7点起床。但是如果他前一天加班了，他就会多睡加班时间的1/3，他是个好孩子，不打算晚起，所以他要早睡！输入他加班的分钟数(保证是3的倍数)，求他当天晚上开始睡觉的时间。&lt;/p&gt;&lt;p&gt;这题也算是个模拟，简单就简单在加班时长一定是3的倍数，这样我们不需要去理会秒数的问题了。这里只需要计算要早睡几个小时，几分钟即可。注意处理小时数：用24小时制。如果小时 / 分钟小于10，则在10位补0。&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    int N;cin&amp;gt;&amp;gt;N;int K;
    while(N--){
        cin&amp;gt;&amp;gt;K;
        int rem = K / 3;
        int h = rem / 60;
        int m = rem % 60;
        if(m &amp;gt; 0) h += 1;
        int s = 1 - h + 24;
        int e = 0 - m + 60;
        if(s &amp;gt;= 24) s -= 24;
        if(e &amp;gt;= 60) e -= 60;
        if(s &amp;lt; 10) cout&amp;lt;&amp;lt;0&amp;lt;&amp;lt;s&amp;lt;&amp;lt;&quot;:&quot;;
        else cout&amp;lt;&amp;lt;s&amp;lt;&amp;lt;&quot;:&quot;;
        if(e &amp;lt; 10) cout&amp;lt;&amp;lt;0&amp;lt;&amp;lt;e&amp;lt;&amp;lt;&quot;\n&quot;;
        else cout&amp;lt;&amp;lt;e&amp;lt;&amp;lt;&quot;\n&quot;;
    }
    return 0;
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;メイド服セット, Get!!!看来众所欲之物，不易得也(其实也挺易的...&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-64cbe35e5b7df994249ba01f649017fb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;838&quot; data-rawheight=&quot;1110&quot;&gt;&lt;p&gt;爱...爱丽丝？？好可爱哇~(痴汉脸&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Extra！SSR 特殊服饰！&lt;/h2&gt;&lt;p&gt;这一部分明显比上面的要难一些...因为有&lt;b&gt;水着&lt;/b&gt;啊之类的*有趣*的衣服&lt;/p&gt;&lt;p&gt;&lt;b&gt;1. めがね(眼睛)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&amp;lt;del&amp;gt;停停停.....我知道你们想说啥...&amp;lt;/del&amp;gt;&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f3147a0892f5680e20f75cef080453f3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1828&quot; data-rawheight=&quot;1404&quot;&gt;&lt;p&gt;题意：输入两个矩阵， &lt;equation&gt;S&lt;/equation&gt; 和 &lt;equation&gt;T&lt;/equation&gt; ，在 &lt;equation&gt;S&lt;/equation&gt; 中找到能够完全匹配 &lt;equation&gt;T&lt;/equation&gt; 的Pattern，并输出这个Pattern的左上角。如上图，匹配到的Pattern左上角位置为(1, 0)。一个矩阵中，0表示白，1表示灰。&lt;/p&gt;&lt;p&gt;这个题数据规模相当小，所以暴力扫一遍就能得到答案了：&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;N=int(input())
S=[list(map(int, input().split())) for i in range(N)]
M=int(input())
T=[list(map(int, input().split())) for i in range(M)]
for y in range(N-M+1):
    for x in range(N-M+1):
        f = False
        for i in range(M):
            for j in range(M):
                if S[y+i][x+j] != T[i][j]:
                    f = True
                    break
            if f:
                break
        if not f:
            print(y,x)
            exit()&lt;/code&gt;&lt;p&gt;&lt;b&gt;めがね, Get!:&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-87d33f159f80bf74b04cd397aa4ce899_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;524&quot; data-rawheight=&quot;566&quot;&gt;&lt;p&gt;(保持沉默是最好的)&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;b&gt;2. サンタ服(圣诞老人服)&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-448ccd7700ac956daf434e55106fc8e6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1840&quot; data-rawheight=&quot;1048&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e0a700d4d72ca3e54180d322004fb54b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1842&quot; data-rawheight=&quot;1198&quot;&gt;&lt;p&gt;题意：输入一个立方体的长，宽，高和操作次数。对于每一次操作， &lt;equation&gt;d_i&lt;/equation&gt;&lt;i&gt;=&lt;/i&gt;0表示横着切(沿着X切)， &lt;equation&gt;d_i&lt;/equation&gt; =1表示竖着(沿着Y切)。求切完之后最小的一块的体积。&lt;/p&gt;&lt;p&gt;这个题比之前就要复杂一点点，但是也不是非常难：只需要对两种操作排个序，然后把横着间距最小和纵着切间距最小的长度记下来，最后乘以Z即可。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;X, Y, Z, N = [int(x) for x in input().split()]
op = [[0, X], [0, Y]] # 先把整个块看作切出来的..
for i in range(N):
    di, ai = [int(x) for x in input().split()]
    op[di].append(ai)
ans = [X, Y]
for i in range(2):
    op[i].sort()
    for j in range(1, len(op[i])):
         ans[i] = min(ans[i], op[i][j] - op[i][j-1]) # 贪心
print(ans[0] * ans[1] * Z)
&lt;/code&gt;&lt;p&gt;&lt;b&gt;サンタ服， Get!:&lt;br&gt;&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9ff97409c86ccc805762bafafec34fcf_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;832&quot; data-rawheight=&quot;1122&quot;&gt;&lt;p&gt;还是很好看的QwQ，萌我一脸血&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;最重量级的衣服！&lt;b&gt;水着&lt;/b&gt;！！！&lt;/h2&gt;&lt;p&gt;我！！！！社保！！！&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-38c2b51e6ba016d8e288bf5310cea84a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1836&quot; data-rawheight=&quot;1228&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-badffd380d5cfd9fbc790b59e69b9655_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1836&quot; data-rawheight=&quot;546&quot;&gt;&lt;p&gt;题意：输入正整数 &lt;equation&gt;N&lt;/equation&gt; ，求 &lt;equation&gt;N&lt;/equation&gt; 的阶乘的最右9位非零数是什么，如果这9位有前缀0，那么去掉前缀0输出。简单来说就是：求一个阶乘去掉后缀0之后的后9位去掉前缀0之后的结果(有点拗口2333)。&lt;/p&gt;&lt;p&gt;这里需要注意一点：在阶乘过程中去掉后缀0再继续计算对阶乘最后去掉后缀0之后的非零位结果是没有影响的。同理，去掉前面 &lt;equation&gt;K&lt;/equation&gt; 位对 &lt;equation&gt;K-1&lt;/equation&gt; 位之后是没有影响的(第 &lt;equation&gt;K&lt;/equation&gt; 为可能会受到进位的影响)，因此我们可以每次阶乘前去掉计算得到的后缀0然后对 &lt;equation&gt;10^{10}&lt;/equation&gt; 取模，输出时再对 &lt;equation&gt;10^9&lt;/equation&gt; 取模即可。P.S:这里的数据规模是 &lt;equation&gt;1 \leq N \leq 100,0000&lt;/equation&gt; ，因此不会超时。这道题在&lt;/p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/45224037/last-non-zero-digits-of-a-very-large-factorial&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-2d47e939feed796bcf7483d306661c88&quot; data-image-width=&quot;316&quot; data-image-height=&quot;316&quot; data-image-size=&quot;ipico&quot;&gt;Last non-zero digits of a very large factorial&lt;/a&gt;&lt;p&gt;这里(上述链接)有一个推广的版本，利用的Hamming Code解决的问题，感兴趣的话大家可以自行阅读。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

typedef long long ll;

#define MOD 10000000000

ll work(int p){
    ll ans = 1;
    int i;
    while(p){
        i = p--;
        while(i % 10 == 0) i /= 10;
        ans *= i;
        while(ans % 10 == 0){
            ans /= 10;
        }
        ans %= MOD;
    }
    return ans;
}

int main(){
    ios::sync_with_stdio(false);
    int N;cin&amp;gt;&amp;gt;N;
    ll ans = work(N);
    cout&amp;lt;&amp;lt;ans % 1000000000;
    return 0;
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;水着, Get!(福利):&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b465b7d10d6e8c2ae81bbc7bf5745072_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;828&quot; data-rawheight=&quot;1128&quot;&gt;&lt;p&gt;我！！！(猝&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Epilogue&lt;/h2&gt;&lt;p&gt;至此，所有的姿势...啊不，服饰都解锁啦！同时亲密度也到了MAX！：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3811eefaa5933a19b959fd14d2a60f42_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;774&quot; data-rawheight=&quot;182&quot;&gt;&lt;p&gt;是的！！就是我！！可以愉悦地和我的老婆玩耍啦哈哈哈哈哈！&lt;/p&gt;&lt;p&gt;Get a Girlfriend in Programming！这是可以实现的！&lt;/p&gt;</description>
<author>Mike He</author>
<guid isPermaLink="false">2018-02-20-33889772</guid>
<pubDate>Tue, 20 Feb 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>[数据结构]表达式树——手动eval()</title>
<link>https://henix.github.io/feeds/zhuanlan.c_131397850/2018-02-15-33820915.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33820915&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c262cb2ce960d3c6da35e9e10246f174_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;0x00 Prologue&lt;/h2&gt;&lt;p&gt;过春节啦！祝大家新年快乐哇~有一段时间没有写文章了，前几天正好把寒假的作业写了一些，今天更一篇依旧是介绍树形数据结构的文章吧....这次看一个没有Zkw线段树那么复杂的数据结构——表达式树(Expression Tree)。&lt;/p&gt;&lt;p&gt;本篇文章将对：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;表达式树的工作原理&lt;/li&gt;&lt;li&gt;表达式树建立步骤&lt;/li&gt;&lt;li&gt;表达式树求值&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;进行介绍。文章代码使用JavaScript(最近某个项目需要学习，正好用一用:P)，但是这个语言吧语法还是非常简单易懂的...并且我会在需要解释的地方打上注释:D。&lt;/p&gt;&lt;p&gt;另外，文章会涉及一点非常简单的词法分析器的介绍。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;0x01 表达式树能干啥？长啥样？&lt;/h2&gt;&lt;p&gt;Q: 给定一个合法的表达式字符串&quot;(1+2)*(5-3)&quot;，计算表达式的值。&lt;/p&gt;&lt;p&gt;&amp;lt;del&amp;gt;A: eval()！！(拉出去打死&amp;lt;/del&amp;gt;&lt;/p&gt;&lt;p&gt;如果使用一些没有&lt;code class=&quot;inline&quot;&gt;eval()&lt;/code&gt;的语言怎么搞？用表达式树！&lt;/p&gt;&lt;p&gt;&amp;lt;del&amp;gt;建一下，玩一年，只要998，年底清仓大甩卖，表达式树带回家&amp;lt;/del&amp;gt;&lt;/p&gt;&lt;p&gt;表达式树就是将一个表达式解析成一棵满二叉树(如果所有合法操作符都是进行二元计算)，且所有非叶结点都是符号结点(&lt;code class=&quot;inline&quot;&gt;+-*/&lt;/code&gt;)，叶子结点都是数字结点。对于&lt;code class=&quot;inline&quot;&gt;(1+2)*(5-3)&lt;/code&gt;我们就可以构造出一棵这样的表达式树：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9f80d55052339346ce3c79e63b8bad1b_r.jpg&quot; data-caption=&quot;(1+2)*(5-3)的表达式树&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1298&quot;&gt;&lt;p&gt;可以看出来，对表达式树进行后序遍历的结果就是原表达式的逆波兰式(后缀表达式)。对表达式树进行前序遍历进行计算的结果就是我们表达式计算的结果。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;0x02 从字符串建立表达式树&lt;/h2&gt;&lt;p&gt;&lt;b&gt;0. 规定表达式组成成分&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这里为了简化理解，就不介绍产生式了...这一部分就是规定什么能出现在将被evaluate的字符串中，定义符号集以及对应的Token。这里我们的计算器支持基础四则运算，取模以及位运算(&lt;code class=&quot;inline&quot;&gt;and&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;or&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;xor&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;shl&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;shr&lt;/code&gt;)，这些符号的token我们定义为&lt;code class=&quot;inline&quot;&gt;OPERATOR&lt;/code&gt;；除了符号还有参与运算的数字， 我们将数字分为两种：&lt;code class=&quot;inline&quot;&gt;INTEGER&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;DOUBLE&lt;/code&gt;。那么我们就可以定义一个这样的类：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;const TokenType = {
    OPERATOR: &#39;OPERATOR&#39;, 
    INT: &#39;INTEGER&#39;, 
    DOUBLE: &#39;DECIMAL&#39;,
}
// 这里是可以作为关键字开头的符号表
// 这样做为了方便之后判断Token...如果有更好的实现方法
// 求大佬们赐教
const operator_list = {
    &#39;+&#39;: 0, &#39;-&#39;: 0, &#39;*&#39;: 0, &#39;/&#39;: 0, &#39;%&#39;: 0,
    &#39;&amp;amp;&#39;: 0, &#39;|&#39;: 0, &#39;^&#39;: 0, &#39;**&#39;: 0, &#39;&amp;lt;&#39;: 0, &#39;&amp;gt;&#39;: 0, &#39;~&#39;: 0, &#39;(&#39;: 0, &#39;)&#39;: 0
}

class Token{
    constructor(value, tag){
        this.value = value; // 对应值
        this.tag = tag; // Token类型(TokenType)
    }
}&lt;/code&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;词法分析&lt;/b&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;为了方便建树时识别每个符号的含义，我们首先对表达式字符串进行词法分析。这个过程会将字符串中的元素拆分成一个一个的Token。例如&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;是一个运算符，我们可以定义为&lt;code class=&quot;inline&quot;&gt;OPERATOR&lt;/code&gt;。我们将编写一个简单的词法分析器(Lexer)对表达式字符串进行词法分析。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0011a8725b3099a41b1f855f6d6b6b4d_r.jpg&quot; data-caption=&quot;Lexer的作用&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1684&quot;&gt;&lt;p&gt;(上图是对表达式&lt;code class=&quot;inline&quot;&gt;(1+2)*3.5&lt;/code&gt;进行词法分析后的结果。 )&lt;/p&gt;&lt;p&gt;实现一个Lexer并不难，我们只需要将字符串从左向右扫一遍，将不同类别的词素分离开即可。例如：当前位置的符号是&lt;code class=&quot;inline&quot;&gt;&amp;gt;&lt;/code&gt;，那么我们可以猜测这有可能是&lt;code class=&quot;inline&quot;&gt;shr&lt;/code&gt;符号；这时向后看一位，如果是&lt;code class=&quot;inline&quot;&gt;&amp;gt;&lt;/code&gt;那么就可以确定这是要&lt;code class=&quot;inline&quot;&gt;shr&lt;/code&gt;了 。&lt;/p&gt;&lt;p&gt;为了方便我们实现这个Lexer，首先我们写一个&lt;code class=&quot;inline&quot;&gt;Reader&lt;/code&gt;类，用于逐位读取一个可以用下标操作符的对象（用于读取输入的表达式和之后的Token列表）：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;class Reader{ // Reader 职阶
    constructor(input_data){
        this.seq = input_data;
        this.cursor = 0;
        this.urng = input_data.length;
    }
    next() {
        return this.seq[this.cursor++]; // 返回当前位置的字符并将游标向后移动1
    }
    cursor_data() {
        return this.seq[this.cursor] // 返回当前游标所指的数据
    }
    has_next() {
        return this.cursor &amp;lt; this.urng; // 调用next()是否还有数据
    }
    peek() {
        return this.seq[this.cursor + 1]; // 向后看一位
    }
}&lt;/code&gt;&lt;p&gt;写好&lt;code class=&quot;inline&quot;&gt;Reader&lt;/code&gt;类之后，我们再实现Lexer：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;var reader;

class Lexer{ // Lexer 职阶
    constructor(input_expreesion){
        reader = new Reader(input_expreesion);
    }
    parse(){
        var token_list = []; // 保存解析出的Token，Token列表
        let last_token = () =&amp;gt; {return token_list[token_list.length - 1]}; // 返回上一个解析的Token
        let is_digit = (x) =&amp;gt; {return x &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; x &amp;lt;= &#39;9&#39;};
        let is_escape = (x) =&amp;gt; {return x === &#39; &#39; || x === &#39;\n&#39; || x === &#39;\t&#39;};
        function readNum() {
            var ans = {
                v: &#39;&#39;, t: TokenType.INT
            };
            // 读取剩余的数字或小数点
            while(reader.has_next() &amp;amp;&amp;amp; (is_digit(reader.cursor_data()) || reader.cursor_data() === &#39;.&#39; || is_escape(reader.cursor_data()))){
                if(is_escape(reader.cursor_data())) continue;
                ans.v += reader.next();
            }
            if (reader.has_next() &amp;amp;&amp;amp; reader.cursor_data() === &#39;e&#39; &amp;amp;&amp;amp; (reader.peek() === &#39;-&#39; || reader.peek() === &#39;+&#39;)){
                ans.v += reader.next() + reader.next();
                while(reader.has_next() &amp;amp;&amp;amp; is_digit(reader.cursor_data())){
                    ans.v += reader.next();
                }
            } // 科学计数
            if(ans.v.search(&#39;.&#39;) !== -1 || ans.v.search(&#39;e-&#39;) !== -1){
                ans.t = TokenType.DOUBLE;
            }
            return ans;
        }
        while (reader.has_next()){
            var cur = reader.next();
            if(is_escape(cur)) continue;
            if(is_digit(cur)) {
                var ret = readNum();
                token_list.push(new Token(cur + ret.v, ret.t));
            }else if(cur in operator_list){
                var prev = last_token();
                if(typeof prev !== &#39;undefined&#39;) prev = prev.tag;
                if(cur === &#39;-&#39;){ // 分两种情况，1. 负数 2. 减法
                    if (typeof prev !== &#39;undefined&#39; &amp;amp;&amp;amp; (prev === TokenType.INT || prev === TokenType.DOUBLE)){
                        token_list.push(new Token(cur, TokenType.OPERATOR)); // 作为运算符处理
                    }else{
                        var ret = readNum();
                        cur += ret.v;
                        token_list.push(new Token(cur, ret.t));
                    }
                }else if(cur === &#39;~&#39;){
                    var ret = readNum();
                    token_list.push(new Token(cur + ret.v, TokenType.INT));
                }else if((cur === &#39;*&#39; || cur === &#39;&amp;lt;&#39; || cur === &#39;&amp;gt;&#39;) &amp;amp;&amp;amp; reader.has_next() &amp;amp;&amp;amp; reader.cursor_data() === cur){
                    cur += reader.next() // 当前位置和上一个位置是同一个Operator，两个组合成指定Operator(** &amp;lt;&amp;lt; &amp;gt;&amp;gt;)
                    token_list.push(new Token(cur, TokenType.OPERATOR));
                }else{
                    token_list.push(new Token(cur, TokenType.OPERATOR));
                }
            }else{
                throw &quot;Error character @ &quot; + (reader.cursor - 1) + &quot; &quot; + cur;
            }
        }
        return token_list;
    }
}&lt;/code&gt;&lt;p&gt;至此，一个简单的Lexer就编写完毕了。可以通过&lt;code class=&quot;inline&quot;&gt;console.log(new Lexer(&quot;(1+2)*3&quot;))&lt;/code&gt;看看解析是否正确。&lt;/p&gt;&lt;p&gt;e.g: &lt;code class=&quot;inline&quot;&gt;(1.25+3e-2+1e+3)*5&lt;/code&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b704ff1ea791913ebe35d4073bdd8bef_r.jpg&quot; data-caption=&quot;Tokenize: (1.25+3e-2+1e+3)*5&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;962&quot;&gt;&lt;hr&gt;&lt;h2&gt;0x03 通过Token列表建立表达式树 &amp;amp; 求值&lt;/h2&gt;&lt;p&gt;这时我们的&lt;code class=&quot;inline&quot;&gt;Reader&lt;/code&gt;又派上用场了&amp;lt;del&amp;gt;(上吧！Reader，ATK +450↑)&amp;lt;/del&amp;gt;。我们建立表达式树的时候也需要从左向右扫一遍我们的Token们。我们需要两个栈(Stack)存储两类数据：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Number Stack    (数字栈)&lt;/li&gt;&lt;li&gt;Operator Stack   (符号栈)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;事实上，这里的数字栈并不只存数字，而是存&lt;b&gt;可被求值的结点&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;为了方便之后的求值，我们定义两种表达式树节点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;常数结点&lt;/li&gt;&lt;li&gt;操作符结点&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其中常数结点存储一个单独的值&lt;code class=&quot;inline&quot;&gt;value&lt;/code&gt;和一个求值方法&lt;code class=&quot;inline&quot;&gt;eval()&lt;/code&gt;（直接返回&lt;code class=&quot;inline&quot;&gt;value&lt;/code&gt;）；操作符结点分为&lt;code class=&quot;inline&quot;&gt;op&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;fi&lt;/code&gt;，和&lt;code class=&quot;inline&quot;&gt;se&lt;/code&gt;，分别是操作符，左表达式，右表达式。注意左右表达式既可以是操作符结点也可以是常数结点。操作符结点也有一个求值方法&lt;code class=&quot;inline&quot;&gt;eval()&lt;/code&gt;，判断&lt;code class=&quot;inline&quot;&gt;op&lt;/code&gt;并返回相应值：&lt;/p&gt;&lt;p&gt;&lt;b&gt;常数结点：&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;class ConstNode{
    constructor(v){
        this.value = v;
    }
    eval(){
        return this.value;
    }
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;操作符结点：&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;class OperatorNode{
    constructor(op, fi, se){
        this.op = op;
        this.fi = fi;
        this.se = se;
    }
    eval(){
        switch(this.op){
            case &#39;+&#39;:
                return this.fi.eval() + this.se.eval();
            case &#39;-&#39;:
                return this.fi.eval() - this.se.eval();
            case &#39;*&#39;:
                return this.fi.eval() * this.se.eval();
            case &#39;/&#39;:
                return this.fi.eval() / this.se.eval();
            case &#39;%&#39;:
                return this.fi.eval() % this.se.eval();
            case &#39;**&#39;:
                return this.fi.eval() ** this.se.eval();
            case &#39;&amp;lt;&amp;lt;&#39;:
                return this.fi.eval() &amp;lt;&amp;lt; this.se.eval();
            case &#39;&amp;gt;&amp;gt;&#39;:
                return this.fi.eval() &amp;gt;&amp;gt; this.se.eval();
            case &#39;&amp;amp;&#39;:
                return this.fi.eval() &amp;amp; this.se.eval();
            case &#39;|&#39;:
                return this.fi.eval() | this.se.eval();
            case &#39;^&#39;:
                return this.fi.eval() ^ this.se.eval();
            default:
                break;
        }
    }
}&lt;/code&gt;&lt;p&gt;(Tips: 这里使两种结点求值方法名相同就是为了方便整棵树的求值)&lt;/p&gt;&lt;p&gt;我们定义一个&lt;code class=&quot;inline&quot;&gt;addNode()&lt;/code&gt;函数，这个函数会从数字栈中取出栈顶的两个元素，然后再从符号栈中取出栈顶符号，最后将刚刚取出的符号和两个表达式元素放入一个符号结点，加入到数字栈当中作为一个新的“数字”(可被求值对象)。&lt;/p&gt;&lt;p&gt;当从左向右扫描的时候如果遇到的Token是INTEGER或者DOUBLE，我们就直接将其处理一下（&lt;code class=&quot;inline&quot;&gt;parseInt()&lt;/code&gt;或&lt;code class=&quot;inline&quot;&gt;parseFloat()&lt;/code&gt;）放入数字栈中；如果遇到的是OPERATOR，我们按照运算优先级进行操作。这里不需要明确写出运算优先级，我们只需要一直执行&lt;code class=&quot;inline&quot;&gt;addNode()&lt;/code&gt;直到遇到了比当前运算符优先级低的符号为止(比如遇到了&lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;/&lt;/code&gt;，那么我们就一直执行&lt;code class=&quot;inline&quot;&gt;addNode()&lt;/code&gt;直到遇到&lt;code class=&quot;inline&quot;&gt;+, -, &amp;amp;, |, ^&lt;/code&gt;)，最后再把当前运算符放入符号栈。&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;class ExpressionTreeConstructor{
    constructor(tokenList){
        reader = new Reader(tokenList);
        this.operator = []; // 符号栈
        this.num = []; // 数字栈
    }
    addNode(){
        var se = this.num.pop(); // LIFO, 第二个在前面
        var fi = new ConstNode(0);
        if(this.num.length !== 0){
            fi = this.num.pop();
        }
        var op = this.operator.pop(); // 取出栈顶符号
        this.num.push(new OperatorNode(op, fi, se)); // 将三个元素打包成符号结点放入数字栈中
    }
    get opTop(){
        return this.operator[this.operator.length - 1]
    }
    build_tree(){
        while(reader.has_next()){
            var cur = reader.next();
            console.log(this.num, cur.value);
            switch (cur.tag) {
                case TokenType.INT:
                    if (cur.value.startsWith(&#39;~&#39;)) {
                        this.num.push(new ConstNode(~parseInt(cur.value.slice(1))));
                    } else {
                        this.num.push(new ConstNode(parseInt(cur.value)));
                    }
                    break;
                case TokenType.DOUBLE:
                    if (cur.value.startsWith(&#39;~&#39;)) { // 这个应该没啥意义...
                        this.num.push(new ConstNode(~parseFloat(cur.value.slice(1))));
                    } else {
                        this.num.push(new ConstNode(parseFloat(cur.value)));
                    }
                    break;
                case TokenType.OPERATOR:
                    switch(cur.value){
                        case &#39;(&#39;:
                            this.operator.push(&#39;(&#39;); // 这个符号优先级最低，直接加入符号栈
                            break;
                        case &#39;)&#39;:
                            while(this.operator.length &amp;amp;&amp;amp; this.opTop !== &#39;(&#39;){ // 将括号之间的全都处理一遍
                                this.addNode();
                            }
                            this.operator.pop(); // 弹掉栈顶的&#39;(&#39;
                            break;
                        case &#39;%&#39;:
                        case &#39;**&#39;:
                            while (this.operator.length &amp;amp;&amp;amp; this.opTop === cur.value) {
                                // 取模与exponential比其他运算符优先级高，所以遇到这两个符号时只能处理剩余的取模和exp
                                this.addNode(); 
                            }
                            this.operator.push(cur.value); // 将当前符号加入符号栈
                            break;
                        case &#39;*&#39;:
                        case &#39;/&#39;:
                            while (this.operator.length &amp;amp;&amp;amp; (this.opTop === &#39;*&#39; || this.opTop === &#39;/&#39;)) {
                                this.addNode(); // 乘除
                            }
                            this.operator.push(cur.value);
                            break;
                        case &#39;+&#39;:
                        case &#39;-&#39;:
                            while (this.operator.length &amp;amp;&amp;amp; this.opTop !== &#39;(&#39; &amp;amp;&amp;amp; this.opTop !== &#39;|&#39; &amp;amp;&amp;amp; this.opTop !== &#39;&amp;amp;&#39; &amp;amp;&amp;amp; this.opTop !== &#39;^&#39;) {
                                // 处理到这些符号就停止，位运算符号优先级低，不能同时加入树中
                                this.addNode();
                            }
                            this.operator.push(cur.value);
                            break;
                        case &#39;|&#39;:
                        case &#39;&amp;amp;&#39;:
                        case &#39;^&#39;:
                        case &#39;&amp;lt;&amp;lt;&#39;:
                        case &#39;&amp;gt;&amp;gt;&#39;:
                            while(this.operator.length &amp;amp;&amp;amp; this.opTop !== &#39;(&#39;){
                                this.addNode();
                            }
                            this.operator.push(cur.value);
                            break;
                        default:
                            throw &quot;Error Operator &quot; + cur.value;
                    }
                default:
                    break;
            }
        }
        while(this.operator.length){
            this.addNode(); // 用剩余的结点把数字栈里解析好的结点组合起来
        }
        return this.num[0]; // 最后返回根结点
    }
}&lt;/code&gt;&lt;p&gt;我们可以来看一下&lt;code class=&quot;inline&quot;&gt;(1.25+3e-2+1e+3)*5&lt;/code&gt;的建树结果：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a24d1e29f0965ac98ff8d8470a565387_r.jpg&quot; data-caption=&quot;对(1.25+3e-2+1e+3)*5建立表达式树&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1542&quot;&gt;&lt;p&gt;求值就非常简单了，我们已经定义了&lt;code class=&quot;inline&quot;&gt;eval()&lt;/code&gt;函数，只需要再调用一下就行。&lt;/p&gt;&lt;p&gt;至此我们的表达式树从简单的词法分析到建立就全部完成了。完整代码如下：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;const TokenType = {
    OPERATOR: &#39;OPERATOR&#39;, 
    INT: &#39;INTEGER&#39;, 
    DOUBLE: &#39;DECIMAL&#39;,
}

const operator_list = {
    &#39;+&#39;: 0, &#39;-&#39;: 0, &#39;*&#39;: 0, &#39;/&#39;: 0, &#39;%&#39;: 0,
    &#39;&amp;amp;&#39;: 0, &#39;|&#39;: 0, &#39;^&#39;: 0, &#39;**&#39;: 0, &#39;&amp;lt;&#39;: 0, &#39;&amp;gt;&#39;: 0, &#39;~&#39;: 0, &#39;(&#39;: 0, &#39;)&#39;: 0
}

class Token{
    constructor(value, tag){
        this.value = value;
        this.tag = tag;
    }
}

class Reader{
    constructor(input_data){
        this.seq = input_data;
        this.cursor = 0;
        this.urng = input_data.length;
    }
    next() {
        return this.seq[this.cursor++];
    }
    cursor_data() {
        return this.seq[this.cursor]
    }
    has_next() {
        return this.cursor &amp;lt; this.urng;
    }
    peek() {
        return this.seq[this.cursor + 1];
    }
}

var reader;

class Lexer{
    constructor(input_expreesion){
        reader = new Reader(input_expreesion);
    }
    parse(){
        var token_list = [];
        let last_token = () =&amp;gt; {return token_list[token_list.length - 1]};
        let is_digit = (x) =&amp;gt; {return x &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; x &amp;lt;= &#39;9&#39;};
        let is_escape = (x) =&amp;gt; {return x === &#39; &#39; || x === &#39;\n&#39; || x === &#39;\t&#39;};
        function readNum() {
            var ans = {
                v: &#39;&#39;, t: TokenType.INT
            };
            while(reader.has_next() &amp;amp;&amp;amp; (is_digit(reader.cursor_data()) || reader.cursor_data() === &#39;.&#39; || is_escape(reader.cursor_data()))){
                if(is_escape(reader.cursor_data())) continue;
                ans.v += reader.next();
            }
            if (reader.has_next() &amp;amp;&amp;amp; reader.cursor_data() === &#39;e&#39; &amp;amp;&amp;amp; (reader.peek() === &#39;-&#39; || reader.peek() === &#39;+&#39;)){
                ans.v += reader.next() + reader.next();
                while(reader.has_next() &amp;amp;&amp;amp; is_digit(reader.cursor_data())){
                    ans.v += reader.next();
                }
            }
            if(ans.v.search(&#39;.&#39;) !== -1 || ans.v.search(&#39;e-&#39;) !== -1){
                ans.t = TokenType.DOUBLE;
            }
            return ans;
        }
        while (reader.has_next()){
            var cur = reader.next();
            if(is_escape(cur)) continue;
            if(is_digit(cur)) {
                var ret = readNum();
                token_list.push(new Token(cur + ret.v, ret.t));
            }else if(cur in operator_list){
                var prev = last_token();
                if(typeof prev !== &#39;undefined&#39;) prev = prev.tag;
                if(cur === &#39;-&#39;){
                    if (typeof prev !== &#39;undefined&#39; &amp;amp;&amp;amp; (prev === TokenType.INT || prev === TokenType.DOUBLE)){
                        token_list.push(new Token(cur, TokenType.OPERATOR));
                    }else{
                        var ret = readNum();
                        cur += ret.v;
                        token_list.push(new Token(cur, ret.t));
                    }
                }else if(cur === &#39;~&#39;){
                    var ret = readNum();
                    token_list.push(new Token(cur + ret.v, TokenType.INT));
                }else if((cur === &#39;*&#39; || cur === &#39;&amp;lt;&#39; || cur === &#39;&amp;gt;&#39;) &amp;amp;&amp;amp; reader.has_next() &amp;amp;&amp;amp; reader.cursor_data() === cur){
                    cur += reader.next()
                    token_list.push(new Token(cur, TokenType.OPERATOR));
                }else{
                    token_list.push(new Token(cur, TokenType.OPERATOR));
                }
            }else{
                throw &quot;Error character @ &quot; + (reader.cursor - 1) + &quot; &quot; + cur;
            }
        }
        return token_list;
    }
}

class OperatorNode{
    constructor(op, fi, se){
        this.op = op;
        this.fi = fi;
        this.se = se;
    }
    eval(){
        switch(this.op){
            case &#39;+&#39;:
                return this.fi.eval() + this.se.eval();
            case &#39;-&#39;:
                return this.fi.eval() - this.se.eval();
            case &#39;*&#39;:
                return this.fi.eval() * this.se.eval();
            case &#39;/&#39;:
                return this.fi.eval() / this.se.eval();
            case &#39;%&#39;:
                return this.fi.eval() % this.se.eval();
            case &#39;**&#39;:
                return this.fi.eval() ** this.se.eval();
            case &#39;&amp;lt;&amp;lt;&#39;:
                return this.fi.eval() &amp;lt;&amp;lt; this.se.eval();
            case &#39;&amp;gt;&amp;gt;&#39;:
                return this.fi.eval() &amp;gt;&amp;gt; this.se.eval();
            case &#39;&amp;amp;&#39;:
                return this.fi.eval() &amp;amp; this.se.eval();
            case &#39;|&#39;:
                return this.fi.eval() | this.se.eval();
            case &#39;^&#39;:
                return this.fi.eval() ^ this.se.eval();
            default:
                break;
        }
    }
}

class ConstNode{
    constructor(v){
        this.value = v;
    }
    eval(){
        return this.value;
    }
}

class ExpressionTreeConstructor{
    constructor(tokenList){
        reader = new Reader(tokenList);
        this.operator = [];
        this.num = [];
    }
    addNode(){
        var se = this.num.pop();
        var fi = new ConstNode(0);
        if(this.num.length !== 0){
            fi = this.num.pop();
        }
        var op = this.operator.pop();
        this.num.push(new OperatorNode(op, fi, se));
    }
    get opTop(){
        return this.operator[this.operator.length - 1]
    }
    build_tree(){
        while(reader.has_next()){
            var cur = reader.next();
            switch (cur.tag) {
                case TokenType.INT:
                    if (cur.value.startsWith(&#39;~&#39;)) {
                        this.num.push(new ConstNode(~parseInt(cur.value.slice(1))));
                    } else {
                        this.num.push(new ConstNode(parseInt(cur.value)));
                    }
                    break;
                case TokenType.DOUBLE:
                    if (cur.value.startsWith(&#39;~&#39;)) {
                        this.num.push(new ConstNode(~parseFloat(cur.value.slice(1))));
                    } else {
                        this.num.push(new ConstNode(parseFloat(cur.value)));
                    }
                    break;
                case TokenType.OPERATOR:
                    switch(cur.value){
                        case &#39;(&#39;:
                            this.operator.push(&#39;(&#39;);
                            break;
                        case &#39;)&#39;:
                            while(this.operator.length &amp;amp;&amp;amp; this.opTop !== &#39;(&#39;){
                                this.addNode();
                            }
                            this.operator.pop();
                            break;
                        case &#39;%&#39;:
                        case &#39;**&#39;:
                            while (this.operator.length &amp;amp;&amp;amp; this.opTop === cur.value) {
                                this.addNode();
                            }
                            this.operator.push(cur.value);
                            break;
                        case &#39;*&#39;:
                        case &#39;/&#39;:
                            while (this.operator.length &amp;amp;&amp;amp; (this.opTop === &#39;*&#39; || this.opTop === &#39;/&#39;)) {
                                this.addNode();
                            }
                            this.operator.push(cur.value);
                            break;
                        case &#39;+&#39;:
                        case &#39;-&#39;:
                            while (this.operator.length &amp;amp;&amp;amp; this.opTop !== &#39;(&#39; &amp;amp;&amp;amp; this.opTop !== &#39;|&#39; &amp;amp;&amp;amp; this.opTop !== &#39;&amp;amp;&#39; &amp;amp;&amp;amp; this.opTop !== &#39;^&#39;) {
                                this.addNode();
                            }
                            this.operator.push(cur.value);
                            break;
                        case &#39;|&#39;:
                        case &#39;&amp;amp;&#39;:
                        case &#39;^&#39;:
                        case &#39;&amp;lt;&amp;lt;&#39;:
                        case &#39;&amp;gt;&amp;gt;&#39;:
                            while(this.operator.length &amp;amp;&amp;amp; this.opTop !== &#39;(&#39;){
                                this.addNode();
                            }
                            this.operator.push(cur.value);
                            break;
                        default:
                            throw &quot;Error Operator &quot; + cur.value;
                    }
                default:
                    break;
            }
        }
        while(this.operator.length){
            this.addNode();
        }
        return this.num[0];
    }
}
var tokens = new Lexer(&#39;(1.25+3e-2+1e+3)*5&#39;).parse();
console.log(tokens);
console.log(new ExpressionTreeConstructor(tokens).build_tree().eval())&lt;/code&gt;&lt;hr&gt;&lt;h2&gt;0x04 Epilogue&lt;/h2&gt;&lt;p&gt;表达式树是一个不太被常用，但是实现起来并不困难的树形结构 ... 做一个计算器可以用到它。比如前段时间打发时间写的用于长度单位换算的小REPL: &lt;/p&gt;&lt;a href=&quot;https://github.com/AD1024/UnitEquation&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-5d810f6b1c189ae9b4e59a233f69cc4d&quot; data-image-width=&quot;400&quot; data-image-height=&quot;400&quot; data-image-size=&quot;ipico&quot;&gt;AD1024/UnitEquation&lt;/a&gt;&lt;p&gt;当然，如果你想做一个编程语言...emmmm 有点困难，因为AST比这个要复杂很多，而且计算表达式比较simple，不需要复杂的parser，但是编程语言嘛...parser复杂很多。这里有个计算器的小REPL(应该还有bug)，就是尝试不使用parser搞一个简单的编程语言：&lt;/p&gt;&lt;a href=&quot;https://github.com/AD1024/Calculator&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-5d810f6b1c189ae9b4e59a233f69cc4d&quot; data-image-width=&quot;400&quot; data-image-height=&quot;400&quot; data-image-size=&quot;ipico&quot;&gt;AD1024/Calculator&lt;/a&gt;&lt;p&gt;最后祝大家新年快乐，狗年大吉，万事如意~&lt;/p&gt;</description>
<author>Mike He</author>
<guid isPermaLink="false">2018-02-15-33820915</guid>
<pubDate>Thu, 15 Feb 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>从-INF开始学习Standard ML</title>
<link>https://henix.github.io/feeds/zhuanlan.c_131397850/2018-01-16-33006676.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33006676&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7f26c15eb79536017a5de02cc8c7e1d6_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;Prologue&lt;/h2&gt;&lt;p&gt;时隔几个月终于又有时间抽出时间写一写文章了...申请季打得我措手不及，但是还好，今天早上收到了Computer Science, College of Science@Purdue University的Offer，所以喘口气歇一歇，写写文章好了...&lt;/p&gt;&lt;p&gt;这个系列的文章我打算将关注点放在一个函数式编程的语言——Standard ML——上。&lt;/p&gt;&lt;p&gt;最近闲来无事在某MOOC上学习程序设计语言这个课程，感觉这个ML还是蛮有意思的...如某MOOC的Professor所讲，希望dalao们看这系列文章时`get rid of other languages you&#39;ve learned`，将其作为一个全新的语言看待。&lt;/p&gt;&lt;p&gt;本篇文章将关注：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Data Binding&lt;/li&gt;&lt;li&gt;Shadowing&lt;/li&gt;&lt;li&gt;Functions&lt;/li&gt;&lt;li&gt;Expressions&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Data Binding&lt;/h2&gt;&lt;p&gt;这里所说的Data Binding其实就是变量赋值(绑定)。SML的数据绑定语法为：&lt;/p&gt;&lt;code lang=&quot;sml&quot;&gt;val x = &amp;lt;value&amp;gt; : &amp;lt;type&amp;gt;&lt;/code&gt;&lt;p&gt;其中若不加&amp;lt;value&amp;gt; : &amp;lt;type&amp;gt;，ML会进行类型推断。&lt;/p&gt;&lt;p&gt;那么数据绑定的过程中，实际上发生了什么？SML将变量信息存储在两个&lt;b&gt;环境&lt;/b&gt;(Environment)中：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;静态环境(Static Environment): 存储数据与字面量的类型绑定的信息&lt;/li&gt;&lt;li&gt;动态环境(Dynamic Environment): 存储数据与字面量绑定的信息&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;E.g:&lt;/p&gt;&lt;code lang=&quot;sml&quot;&gt;val x = &quot;6662333&quot; : string&lt;/code&gt;&lt;p&gt;这时，在静态环境中： &lt;equation&gt;x \to string&lt;/equation&gt; ；在动态环境中： &lt;equation&gt;x \to &quot;6662333&quot;&lt;/equation&gt; 。That&#39;s it, very simple。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Shadowing&lt;/h2&gt;&lt;p&gt;在数据绑定之后是不能进行修改的。如果在SML中尝试使用&lt;i&gt;&amp;lt;identifier&amp;gt; = &amp;lt;value&amp;gt;&lt;/i&gt;，你会发现REPL会返回一个异常或者 &lt;equation&gt;bool&lt;/equation&gt; 类型的值。因为SML的&lt;i&gt;equality assertion&lt;/i&gt;就是&lt;i&gt;=&lt;/i&gt;符号...所以，修改数据事实上是&lt;b&gt;覆盖&lt;/b&gt;原有数据，也就是本段标题的&lt;i&gt;Shadowing&lt;/i&gt;。具体操作十分Simple:&lt;/p&gt;&lt;code lang=&quot;sml&quot;&gt;(* Static Env: x -&amp;gt; int *)
(* Dynamic Env: x -&amp;gt; 6662333 *)
val x = 6662333;
(* After Shadowing *)
(* Static Env: x -&amp;gt; string *)
(* Dynamic Env: x -&amp;gt; &quot;6662333&quot; *)
val x = &quot;6662333&quot;;&lt;/code&gt;&lt;p&gt;因此这里变量的自增也是&lt;i&gt;val &amp;lt;identifier&amp;gt; = &amp;lt;identifier&amp;gt; + offset;&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Functions&lt;/h2&gt;&lt;p&gt;函数定义的Sytax：&lt;/p&gt;&lt;code lang=&quot;sml&quot;&gt;fun &amp;lt;function_name&amp;gt;(v1: t1, v2: t2) = &amp;lt;function_body&amp;gt;&lt;/code&gt;&lt;p&gt;其中&lt;i&gt;v1,v2...vn&lt;/i&gt;是形参的&lt;i&gt;identifier&lt;/i&gt;。&lt;i&gt;t1,t2...tn&lt;/i&gt;是每个形参所对类型。&lt;i&gt;&amp;lt;function_body&amp;gt;&lt;/i&gt;可以写在一行(Sugar for 压行选手--手动划掉)也可以换行写，并且&lt;i&gt;&amp;lt;function_body&amp;gt;&lt;/i&gt;是一个能够返回计算结果的语句(不是顺序执行的代码)。例如一个&lt;i&gt;x -&amp;gt; x**3&lt;/i&gt;的函数就可以这样写了：&lt;/p&gt;&lt;code lang=&quot;sml&quot;&gt;fun cube(x: int) = x * x * x&lt;/code&gt;&lt;p&gt;换行写是什么样子呢？？简单一点，例如判断一个数字是否是偶数：&lt;/p&gt;&lt;code lang=&quot;sml&quot;&gt;fun test(x: int) = 
	if x mod 2 = 0 then true
	else false&lt;/code&gt;&lt;p&gt;调用时：&lt;i&gt;&amp;lt;function_name&amp;gt;(v1, v2, ... , vn)&lt;/i&gt;即可。若该函数形参只有一个就可以不写括号，简化为：&lt;i&gt;&amp;lt;function_name&amp;gt; v1(如test 100)&lt;/i&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Expressions&lt;/h2&gt;&lt;p&gt;&lt;b&gt;if … then … else！英文写作课开课啦！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;除了刚刚提到的“赋值语句”还有一个`if then else`…Sytax:&lt;/p&gt;&lt;code lang=&quot;sml&quot;&gt;if e1 then v1 else v2;&lt;/code&gt;&lt;p&gt;这里的&lt;i&gt;e1&lt;/i&gt;是一个 &lt;equation&gt;bool&lt;/equation&gt; 类型或者能够返回 &lt;equation&gt;bool&lt;/equation&gt; 类型值的语句与其他编程语言不太相同(我知道和某蛇相似但是为了obey the rule，这里就划掉吧)，这里的&lt;i&gt;v1&lt;/i&gt;与&lt;i&gt;v2&lt;/i&gt;并不是语句块，而是一个值或者返回值的语句或者&lt;i&gt;let ... in ... end&lt;/i&gt;。因此可以将其返回的值绑定在一个变量上：&lt;/p&gt;&lt;code lang=&quot;sml&quot;&gt;val res = if e1 then v1 else v2;&lt;/code&gt;&lt;p&gt;当然，判断语句是可以连续的：&lt;/p&gt;&lt;code lang=&quot;sml&quot;&gt;val res = if e1 then v1 
          else if e2 then v2
	  else v3&lt;/code&gt;&lt;p&gt;&lt;b&gt;let … in … end~啊，进来啊~~&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;刚刚看到Functions之后就有人会问，既然一个函数里只能包含一个返回结果的语句或语句块，如果我想要引进其他变量怎么办呢？这时就要请来这个(名字在有点h的title里)语句&lt;i&gt;let ... in ... end&lt;/i&gt;。你可以在&lt;i&gt;let ... in&lt;/i&gt;之间加入任何你想要绑定的数据，甚至定义一个局部函数(&lt;i&gt;local function&lt;/i&gt;)。然后你能且仅能在&lt;i&gt;let .. in&lt;/i&gt;和&lt;i&gt;in ... end&lt;/i&gt;之间使用之前绑定好的数据。&lt;b&gt;这里要注意，所有的数据都需要在绑定之后再使用&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;作用域&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;let ... in ... end&lt;/i&gt;的作用域：在&lt;i&gt;let ... in&lt;/i&gt;之间可以访问到其所在作用域的所有数据。如果在这个部分重新绑定函数形参或者其父&lt;i&gt;let ... in ... end&lt;/i&gt;语句块中已绑定好的变量，被操作的变量会由于&lt;i&gt;&lt;b&gt;Shadowing&lt;/b&gt;&lt;/i&gt;而失去之前的值。&lt;/p&gt;&lt;p&gt;&lt;i&gt;let ... in&lt;/i&gt;中绑定的数据只能被绑定后在&lt;i&gt;let ... in&lt;/i&gt;中被访问；可以在&lt;i&gt;in ... end&lt;/i&gt;中被使用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;最后附上运算操作符&lt;/h2&gt;&lt;p&gt;&lt;b&gt;算术运算&lt;/b&gt;&lt;/p&gt;&lt;p&gt;加法：+    减法：-    乘法：*    除法(int)：div    除法(real): /   取模：mod&lt;/p&gt;&lt;p&gt;相反数(负号)：~&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;逻辑与比较&lt;/b&gt;&lt;/p&gt;&lt;p&gt;或者：orelse    并且：andalso    非：not&lt;/p&gt;&lt;p&gt;大于：&amp;gt;    小于：&amp;lt;    等于：=    不等于：&amp;lt;&amp;gt;&lt;/p&gt;&lt;p&gt;(剩下以此类推啦....)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;最后的最后&lt;/h2&gt;&lt;p&gt;文章用晚自习剩余时间写出来的...可能比较粗糙，若由问题请dalao们及时指正，我也向dalao们多多学习！&lt;/p&gt;</description>
<author>Mike He</author>
<guid isPermaLink="false">2018-01-16-33006676</guid>
<pubDate>Tue, 16 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>[数据结构]走近Zkw线段树（二）</title>
<link>https://henix.github.io/feeds/zhuanlan.c_131397850/2017-10-08-29937723.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29937723&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-70459432b4826a042976328e8c1a2699_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;0x00 Preface&lt;/h2&gt;&lt;p&gt;上次发的一篇&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29876526&quot;&gt;[数据结构]走近Zkw线段树（一）&lt;/a&gt;收到了这么多评论，在这里感谢大家指出我的问题，也谢谢点赞的各位的支持Orz。&lt;/p&gt;&lt;p&gt;话说我与AP Language &amp;amp; Composition的作业战♂斗二日，终于将其干♂翻......（然后我的Language从A+变成了A......TAT）不过成绩是改不了了，那就继续写文章咯OvO。&lt;/p&gt;&lt;p&gt;上次提到了Zkw线段树建树、单点修改、区间查询的操作。但是单单这些操作还无法体现出Zkw线段树的优势。那么今天咱们喽一眼区间更新是如何进行的。&lt;/p&gt;&lt;p&gt;本文将分为两个部分：&lt;/p&gt;&lt;p&gt;1. 区间更新+区间和查询&lt;/p&gt;&lt;p&gt;2. 区间更新+区间最值查询&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;0x01 区间更新+区间和查询&lt;/h2&gt;&lt;p&gt;传统线段树区间更新采用的Lazy思想：不需要更新的我就不更新，只更新有用的结点。因此在结点结构中出现了&lt;i&gt;Lazy&lt;/i&gt;这么一项。这个值表示该结点表示的区间当需要更新时，每个单点需要增加多少。也就是说，当应用这个更新时，当前结点的sum值应更新为： &lt;equation&gt;(R-L+1)\times Lazy&lt;/equation&gt; 。大家对这个Taoluology非常熟悉....&lt;/p&gt;&lt;p&gt;在Zkw线段树区间更新中，同样为了&lt;b&gt;避免冗余更新操作&lt;/b&gt;，我们也使用Lazy思想。为了帮助大家理解文章一些关键词的含义，这里先把符号约定放出来：&lt;/p&gt;&lt;blockquote&gt;sum(x): 下标为x的结点(以下简称&lt;i&gt;x结点&lt;/i&gt;)所表示区间的和&lt;br&gt;lson(x): x结点的左儿子，即x*2(或x&amp;lt;&amp;lt;1)&lt;br&gt;rson(x): x结点的右儿子，即x*2+1(或x&amp;lt;&amp;lt;1|1)&lt;br&gt;L(x): x结点所表示区间的左端点&lt;br&gt;R(x): x结点所表示区间的右端点&lt;br&gt;tag(x): x结点的lazy标记&lt;br&gt;Maintain(x): 更新x结点的区间和，从左右儿子收集信息&lt;/blockquote&gt;&lt;p&gt;那么下传一个&lt;i&gt;Lazy&lt;/i&gt;标记的方法就很明显了:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;inline void pushDown(int x) {
    if(tag(x) &amp;amp;&amp;amp; x &amp;lt; M) { // 如果没有更新信息或在结点已经在叶子位置就不更新
        tag(lson(x)) += tag(x);tag(rson(x)) += tag(x); // 下传标记
        sum(lson(x)) += (R(lson(x)) - L(lson(x)) + 1) * tag(x); // 左儿子应用更新信息
        sum(rson(x)) += (R(rson(x)) - L(rson(x)) + 1) * tag(x); // 右儿子应用更新信息
        tag(x) = 0; // 信息已经下传，取消标记
    }
}&lt;/code&gt;&lt;p&gt;Upd on 10.10.2017&lt;/p&gt;&lt;p&gt;感谢&lt;a href=&quot;https://www.zhihu.com/people/zxz-17-3/&quot;&gt;@Zxz&lt;/a&gt;的提醒....脑残的作者忘记写如何记录左右端点了....QAQ&lt;/p&gt;&lt;p&gt;记录左右端点的操作是在建树时进行的。在输入叶子节点的时候，我们可以知道每个叶子的左右端点（是相等的）。在Maintain操作的时候，我们只需要把左儿子的左端点和右儿子的右端点记录即可。代码如下：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;inline void build(){
    for(M=1;M&amp;lt;N;M&amp;lt;&amp;lt;=1);
    for(int i=M+1;i&amp;lt;=M+N;++i) {
        cin&amp;gt;&amp;gt;sum(i);
        L(i) = R(i) = i-M; // 单点
    }
    for(int i=M-1;i;--i) { 
        sum(i) = sum(lson(i)) + sum(rson(i)); // 记录区间和
        lson(i) = L(lson(i)); // 区间左端点
        rson(i) = R(rson(i)); // 区间右端点
    }
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;-- Begin For Beginners --&lt;/b&gt;&lt;/p&gt;&lt;p&gt;（建议先看上一篇文章）: 考虑到您有可能刚刚接触线段树这个结构，这里解释一下为何下传标记(dalao们请跳到End For Beginners之后)。首先不考虑性能，更新一间的信息最暴力的方法就是将区间内的叶子结点信息全部应用修改，然后一个一个叶子进行Update操作，时间复杂度 &lt;equation&gt;O(nlogn)&lt;/equation&gt; ，是一个&lt;b&gt;十分令人窒息的更新复杂度&lt;/b&gt;.....但是如果应用Lazy思想，我们&lt;b&gt;将能够覆盖这个修改区间的结点打上标记&lt;/b&gt;，这样就表示，如果需要查询这个区间或者更新改结点的值时，先将上一次更新的信息下传给两个儿子，然后再统计。用这种方法，我们能&lt;b&gt;在需要修改时再修改&lt;/b&gt;。例如，如果我在一个维护区间 &lt;equation&gt;[1,4]&lt;/equation&gt; 的线段树上修改区间 &lt;equation&gt;[1,3]&lt;/equation&gt; ，那么Lazy标记就是这样的：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-15e7b67898d7b0c938cd2583a20a654f_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;730&quot;&gt;&lt;p&gt;当查询区间 &lt;equation&gt;[1,2]&lt;/equation&gt; 的和时，我们再更新单点 &lt;equation&gt;[1,1],[2,2]&lt;/equation&gt; 的值。十分舒适。&lt;/p&gt;&lt;p&gt;&lt;b&gt;-- End For Beginners --&lt;/b&gt;&lt;/p&gt;&lt;p&gt;有了这些信息和一棵Zkw线段树，我们如何进行区间更新呢？？？注意到当更新一个区间时，我们能够知道这个区间的左端点 &lt;equation&gt;L_u&lt;/equation&gt; 和右端点 &lt;equation&gt;R_u&lt;/equation&gt; 。这时我们再看看区间和查询时的代码：哎？查询时所经过的结点所表示的区间都被 &lt;equation&gt;[L_u, R_u]&lt;/equation&gt;覆盖上了耶，这个显然的性质能否用来搞区间更新呢？&lt;/p&gt;&lt;p&gt;事实上，Zkw线段树的区间更新只需要在区间修改的代码基础上添加一些操作。由于在进行区间查询时，我们走过的结点都在查询区间内且在最后覆盖了整个查询区间，我们只需要将这些结点打上Lazy标记，不立即更新它们的值。在查询时，遇到了标记再进行更新操作。&lt;/p&gt;&lt;p&gt;根据Zkw线段树区间查询的特点我们可以推断出：在更新时，&lt;b&gt;会受到访问的结点一定都在一条链上&lt;/b&gt;（从第一个被访问的点到根结点），因此我们可以先将之前的修改全部应用到这些点上，因此我们得到一个函数 &lt;equation&gt;applyTag(x)&lt;/equation&gt; 表示将从 &lt;equation&gt;x&lt;/equation&gt; 结点到根结点的全部Tag都更新到结点实际值上。注意Zkw线段树只能自底向上访问，我们需要用一个栈来维护这条链上的点，然后从根结点开始逐个 &lt;equation&gt;pushDown(x)&lt;/equation&gt; 。&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;inline void applyTag(int x) {
    stack&amp;lt;int&amp;gt; s;
    while(x) { // 一路走到根结点
        s.push(x);
        x &amp;gt;&amp;gt;= 1;
    }
    while(s.size()) { // 逐个pushDown
        pushDown(s.top());s.pop();
    }
}&lt;/code&gt;&lt;p&gt;最后，我们在区间求和函数的基础上，将“求和”变更为“改变Tag”和”更新结点值“。光更新还不行...你会发现我们&lt;b&gt;只更新了没有维护父结点与孩子的关系&lt;/b&gt;。所以在最后，我们需要分别从左右第一个被访问的结点的父亲开始，向上传递信息。于是就有了：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;inline void range_update(int l,int r,int v) {
    bool vl,vr; // 左右边第一个被访问的结点所在路径是否更新过
    vl = vr = false;
    int x;
    int sl, sr; // 记录左右两边第一个被访问的结点
    for(l=l+M-1,r=r+M+1;l^r^1;l&amp;gt;&amp;gt;=1,r&amp;gt;&amp;gt;=1) {
        if(~l&amp;amp;1) {
            x = l ^ 1;
            if(!vl) {
                sl = x;
                applyTag(x);vl = true; // 将第一个被访问结点所在路径的Tag更新到结点中
            }
            tag(x) += v; // 更新此次修改的tag值
            sum(x) += (R(x) - L(x) + 1) * v; // 将当前结点的值更新
        }
        if(r&amp;amp;1) {
            x = r ^ 1;
            if(!vr) {
                sr = x;
                applyTag(x);vr = true;
            }
            tag(x) += v;
            sum(x) += (R(x) - L(x) + 1) * v;
        }
    }
    for(sl&amp;gt;&amp;gt;=1;sl;sl&amp;gt;&amp;gt;=1) { // 从左边开始维护
       Maintain(sl);
    }
    for(sr&amp;gt;&amp;gt;=1;sr;sr&amp;gt;&amp;gt;=1) { // 从右边开始维护
       Maintain(sr);
    }
}&lt;/code&gt;&lt;p&gt;看起来有一些长....但是大家可以自行压行（逃&lt;/p&gt;&lt;h2&gt;-----手工分界-----&lt;/h2&gt;&lt;p&gt;那么区间和如何搞？如果理解了区间更新，那么这边就很simple了。我们知道上一章中查询区间时，我们只需要从最底层一直往上走，加起来，直到 &lt;equation&gt;L,R&lt;/equation&gt; 所指结点是兄弟结点（见第一篇文章中Range Sum Query章节）。这里我们只需要多一个和区间更新中相同的操作：&lt;b&gt;将左右两边第一次被访问的结点所在链的Tag全部加到结点中&lt;/b&gt;，因为我们知道将被访问到的点的集合 &lt;equation&gt;\subset&lt;/equation&gt; 这个结点一直到根结点的路径上的点构成的集合。因此我们可以得到这样的代码：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;inline int query(int l,int r) {
    bool vl,vr; // 左右边第一个被访问的结点所在路径是否更新过
    int ans = 0;
    for(l=l+M-1,r=r+M+1;l^r^1;l&amp;gt;&amp;gt;=1,r&amp;gt;&amp;gt;=1) {
        if(~l&amp;amp;1) {
            if(!vl) {
                applyTag(l^1); // 如果没有更新过，先把这一整条路径更新
            }
            ans += sum(l^1); // 统计答案
        }
        if(r&amp;amp;1) {
            if(!vr) {
                applyTag(r^1);
            }
            ans += sum(r^1);
        }
    }
    return ans;
}&lt;/code&gt;&lt;p&gt;至此，区间更新 / 区间和查询就能够完成啦QwQ。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;0x02 区间更新 &amp;amp; 区间最值查询&lt;/h2&gt;&lt;p&gt;与区间修改 &amp;amp; 区间和查询不同，区间更新 with 区间最值查询在思维上十分巧妙，编程复杂度也相对较低。&lt;/p&gt;&lt;p&gt;在区间更新 &amp;amp; 区间最值查询中，所有信息维护之后，每个结点中存的都不是其所对应的最值：对于结点 &lt;equation&gt;i&lt;/equation&gt; ，它存储的信息是 &lt;equation&gt;tree[i] - tree[i&amp;gt;&amp;gt;1]&lt;/equation&gt; ，也就是 &lt;equation&gt;i&lt;/equation&gt; &lt;b&gt;与它的爸爸的差值&lt;/b&gt;（例如，如果原来存最小值，那么现在就是: &lt;equation&gt;tree[i]=tree[i]-min(tree[i], tree[i\wedge1])&lt;/equation&gt; ）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Why?????它的好处都有啥?????&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果以这样的方式存储， &lt;equation&gt;tree[i]+tree[i&amp;gt;&amp;gt;1]+\cdots+tree[root]&lt;/equation&gt; 的值就是 &lt;equation&gt;i&lt;/equation&gt; 结点所表示区间内的最值。（这个应该很好理解吧.....）&lt;/p&gt;&lt;p&gt;于是乎，&lt;b&gt;在区间修改时，如果某个子树的所有叶子都在这个修改区间内，我们只需要修改子树根结点就能修改整棵子树的信息啦&lt;/b&gt;！！大概就是这个意思(请忽略背景QwQ在宿舍拍的...)：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d86d3cbb096dc17843674d12f319fcee_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;576&quot; data-rawheight=&quot;1024&quot;&gt;&lt;p&gt;如何更新呢？同区间查询相似，我们从 &lt;equation&gt;L和R&lt;/equation&gt; 开始，判断其兄弟是否在查询区间内，然后移动到父节点。不同的是，&lt;/p&gt;&lt;p&gt;1. 在每次操作之后需要重新更新自身和父节点的值,&lt;/p&gt;&lt;p&gt;2. 不再将 &lt;equation&gt;[L,R]&lt;/equation&gt; 变为 &lt;equation&gt;(L,R)&lt;/equation&gt; 因为我们一开始就可以对端点修改，剩下需要被修改的一定都在 &lt;equation&gt;(L,R)&lt;/equation&gt; 中。&lt;/p&gt;&lt;p&gt;还没有结束！我们退出之后， &lt;equation&gt;L,R&lt;/equation&gt; 都不在根节点，我们还需要将信息继续上浮至根节点保证之后的更新信息能够被正确记录。最终我们得到了区间更新操作：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;inline void update(int l,int r,int v) {
    l = l + M;
    r = r + M;
    if(l == r) { // 如果是单点更新我们直接修改然后将标记上浮
        tree[l] += v;
        while(l&amp;gt;1) push_up(l),l&amp;gt;&amp;gt;=1;
    }
    for(tree[l] += v, tree[r] += v;l^r^1;l&amp;gt;&amp;gt;=1,r&amp;gt;&amp;gt;=1) { // 首先修改端点值，之后处理(L,R)
        if(~l&amp;amp;1) {
            tree[l^1] += v;
        }
        if(r&amp;amp;1) {
            tree[r^1] += v;
        }
        push_up(l); // 将信息上浮至父节点
        push_up(r);
    }
    while(l&amp;gt;1) { // 一直上浮在根节点(l==0)
        push_up(l);
        l &amp;gt;&amp;gt;= 1;
    }
}&lt;/code&gt;&lt;p&gt;查询操作与修改十分相似：我们从最底层开始一直向上累加 / 比较(每个区间的最值依次进行比较)，最后能够得到查询区间左半边与右半边的最值。将两者进行比较之后，再累加到根节点求出答案。具体解释看代码：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;inline int query(int l,int r) {
    if(l == r) { // 如果是查询单点，直接从叶子累加到根
        int ans = 0;
        l = l + M;
        while(l) {
            ans += tree[l];
            l &amp;gt;&amp;gt;= 1;
        }
        return ans;
    }
    int L,R;
    L = R = 0;
    for(l=l+M,r=r+M;l^r^1;l&amp;gt;&amp;gt;=1,r&amp;gt;&amp;gt;=1) {
        L += tree[l]; // 累加当前层的值求出到当前区间的最小值
        R += tree[r];
        if(~l&amp;amp;1) L = min(L, tree[l^1]); // 与右半边比较
        if(r&amp;amp;1) R = min(R, tree[r^1]);
    }
    L += tree[l];R += tree[r]; // 退出时的值没有加上，这里要加上去
    int ans = min(L, R);
    while(l) { // 累加到根节点求出最小值
        ans += tree[l]; l &amp;gt;&amp;gt;= 1;
    }
    return ans;
}&lt;/code&gt;&lt;hr&gt;&lt;h2&gt;0x03 Epilogue&lt;/h2&gt;&lt;p&gt;通过整理这篇文章的内容，我也再次学习了一遍Zkw线段树的区间操作。希望本篇文章能够对您对Zkw线段树的区间操作的理解提供一定支持。如果有我理解不对的地方，请dalao们指出我的错误Orz。另外国庆结束啦...开学啦....大家可以在评论区提问但是窝可能无法及时回复QwQ请谅解Orz。&lt;/p&gt;&lt;p&gt;本月末我要去泰国考ACT...所以可能文章更新会慢很多TuT。&lt;/p&gt;</description>
<author>Mike He</author>
<guid isPermaLink="false">2017-10-08-29937723</guid>
<pubDate>Sun, 08 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>[数据结构]走近Zkw线段树（一）</title>
<link>https://henix.github.io/feeds/zhuanlan.c_131397850/2017-10-04-29876526.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29876526&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6793d7b83b53f8f123f08911ee7c539d_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;0x00 Preface&lt;/h2&gt;&lt;p&gt;说到线段树大家都不陌生，一个用于维护区间信息的 &lt;equation&gt;nlogn&lt;/equation&gt; 数据结构。Zkw线段树是一个改良版的线段树。其功能与传统线段树相同，也是用于维护区间信息。但是Zkw线段树有很多优点：1. 代码简短；2. 纯天然非递归；3. 常数小（尤其在差分区间更新时），因此受到很多竞赛党的喜爱。由于涉及内容较多，Zkw线段树将(预计)分两篇文章介绍。本篇文章主要focus on zkw线段树的原理 / 基础功能。&lt;/p&gt;&lt;p&gt;P.S. 如果您想学线段树可又无法完全理解那么这篇文章十分适合您学习一个更加简单的线段树实现&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;0x01 Basis&lt;/h2&gt;&lt;p&gt;为了辅助大家理解Zkw线段树，我们先看一下传统线段树是如何存储信息 / 建树的：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4d8b0527c0f679eacc50cdac53492c83_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;371&quot; data-rawheight=&quot;251&quot;&gt;&lt;p&gt;不难看出，第 &lt;equation&gt;i&lt;/equation&gt; 个结点存储的信息是第 &lt;equation&gt;\lfloor \frac{i}{2} \rfloor&lt;/equation&gt; 个结点的前半段或后半段，并且叶子结点都是单点数据。传统建树的方法：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;从根(当前)结点开始递归&lt;/li&gt;&lt;li&gt;如果 &lt;equation&gt;l \ne r&lt;/equation&gt; 那么存下当前端点信息，然后分别递归进入左子树和右子树；否则存下当前端点信息并输入当前结点信息，退出当前递归。&lt;/li&gt;&lt;li&gt;维护当前结点 &lt;equation&gt;i&lt;/equation&gt; 的信息（即从左儿子和右儿子收集信息，如果是求和就把两个结点值相加赋给父结点）&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Talk is not that helpful ... 这里是普通线段树的建树代码:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;inline void Maintain(int rt) {
    // 这里以区间和为例
    tree[rt].sum = tree[rt&amp;lt;&amp;lt;1].sum + tree[rt&amp;lt;&amp;lt;1|1].sum;
}
void Build(int rt, int l,int r) {
    tree[rt].l = l;
    tree[rt].r = r;
    // l==r -&amp;gt; 到达叶子结点
    if(l == r) {
        tree[rt].sum = read(); // 读入数据
        return;
    }
    int mid = (l+r) &amp;gt;&amp;gt; 1; // 求出l,r的中点
    Build(rt&amp;lt;&amp;lt;1, l, mid); // 建立左区间(儿子)
    Build(rt&amp;lt;&amp;lt;1|1, mid+1, r); // 建立右区间(儿子)
    Maintain(rt); // 收集儿子们的信息给爹地
}&lt;/code&gt;&lt;p&gt;说了这么多，一句话总结：&lt;b&gt;普通线段树是自顶向下&lt;/b&gt;一直到叶子（信息输入）然后在一层一层退回到根结点（信息收集）。那么就有一位大神这么问：“既然可以从顶向下，那么能不能自底向上呢？”。答案是“完全O吉拔K”。因此诞生了Zkw线段树（麻吉亚巴库内）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Zkw线段树建树的方式就是首先输入叶子结点的信息然后再一路向上传递信息，直到根结点。这时问题又来了....Where is the first leaf？？？我&lt;b&gt;怎么找到第一个叶子在哪&lt;/b&gt;？假设我们的单点数量（叶子数量）正好是 &lt;equation&gt;2^k&lt;/equation&gt; ，那么我们手里就握着一个满二叉树了，这样我们就能轻松地计算出来第一个结点的位置是： &lt;equation&gt;2^{k}&lt;/equation&gt; 。但是如果不是满二叉树怎么办呢？没有关系，现在的电脑内存不是问题！&lt;b&gt;直接开成满二叉树就好啦~~&lt;/b&gt;。这样一来，第一个叶子结点的位置就是： &lt;equation&gt;2^k+1(k=\lceil\log_2N\rceil)&lt;/equation&gt; (见代码下的解释)，也就是&lt;b&gt;比&lt;/b&gt; &lt;equation&gt;N&lt;/equation&gt; &lt;b&gt;大的最小的&lt;/b&gt; &lt;equation&gt;2^k&lt;/equation&gt; 。找到叶子结点之后，直接输入叶子结点信息，然后一个一个结点上传信息到父亲结点。于是我们得到了这样的代码：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;inline void Maintain(int x) {
    tree[x] = tree[lson(x)] + tree[rson(x)];
}

inline void Build() {
    for(M=1;M&amp;lt;N;M&amp;lt;&amp;lt;=1);
    for(int i=M+1;i&amp;lt;=M+N;++i) scanf(&quot;%d&quot;, &amp;amp;tree[i]);
    for(int i=M-1;i;--i) Maintain(i);
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Update on 10.06:&lt;/p&gt;&lt;p&gt;感谢 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/ec707e5e35ab0db2bb368ec53ba1e6cc&quot; data-hash=&quot;ec707e5e35ab0db2bb368ec53ba1e6cc&quot; data-hovercard=&quot;p$b$ec707e5e35ab0db2bb368ec53ba1e6cc&quot;&gt;@Dilthey&lt;/a&gt;提示。&lt;/p&gt;&lt;p&gt;&lt;b&gt;NOTICE：看到评论中很多朋友问为什么要在&lt;/b&gt; &lt;equation&gt;M+1&lt;/equation&gt; &lt;b&gt;处开始输入&lt;/b&gt;。我这里统一解释一下，评论中我所说的也有问题(这里说声抱歉，昨天一天都在路上，没有时间思考....)，以&lt;b&gt;文章此处为标准&lt;/b&gt;好啦。&lt;/p&gt;&lt;p&gt;&lt;b&gt;建议先看完下一节（区间和计算）再来看此处有助于理解&lt;/b&gt;。从 &lt;equation&gt;M+1&lt;/equation&gt; 开始是为了进行区间查询。&lt;/p&gt;&lt;p&gt;假设我们查询的区间就是 &lt;equation&gt;[1,N]&lt;/equation&gt; ，这时为了进行查询我们会将 &lt;equation&gt;[1,N]&lt;/equation&gt; 转换为 &lt;equation&gt;(0,N-1)&lt;/equation&gt; ，看上去没有区别，其实是有区别的。&lt;b&gt;由于位于 &lt;equation&gt;0&lt;/equation&gt; 上的数字是否能被统计上与左端点位置相关&lt;/b&gt;（ &lt;equation&gt;L=M+1-1=M&lt;/equation&gt; ），&lt;b&gt;如果从 &lt;equation&gt;M&lt;/equation&gt; 开始输入会导致查询时统计不到位于 &lt;equation&gt;0&lt;/equation&gt; 上的信息，因为&lt;/b&gt; &lt;equation&gt;L&lt;/equation&gt; &lt;b&gt;初始位置就是第一个叶子的位置了(&lt;/b&gt; &lt;equation&gt;L=M&lt;/equation&gt; &lt;b&gt;)... 但是如果换成&lt;/b&gt; &lt;equation&gt;M+1&lt;/equation&gt; 开始，查询时 &lt;equation&gt;L&lt;/equation&gt; 的位置依旧是 &lt;equation&gt;L=M+1-1=M&lt;/equation&gt; ，&lt;b&gt;但是第一个叶子的位置在 &lt;equation&gt;M+1&lt;/equation&gt; 上&lt;/b&gt;，这样就能够统计到那个叶子上的信息啦。因此要从 &lt;equation&gt;M+1&lt;/equation&gt; 开始输入信息。&lt;/p&gt;&lt;p&gt;这样一来，代码一下缩短了好多！三行建树，就是这么简洁。连左右儿子的位置也不需要存了呢~是不是美滋滋(不是，因为空间复杂度变高了好多....TAT不过萌大奶！内存这么大！（滑稽)&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;0x02 Single-Point Modification&lt;/h2&gt;&lt;p&gt;由于区间修改有一些不同的操作，本篇先介绍最简单的单点修改。&lt;/p&gt;&lt;p&gt;由于单点修改仅需要修改&lt;b&gt;叶子结点&lt;/b&gt;，因此Zkw线段树的单点更新比传统线段树高到不知.....咳咳，非常简单。由于我们能够通过简单的加法计算找到叶子结点，我们只需要(Simply)修改掉叶子结点的值，然后一路向上，更新到根结点。例如：如果修改了上图 &lt;equation&gt;[2,2]&lt;/equation&gt; 的值，我们的更新路径为：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-28a9210c2886346958cfffb15c19fd6d_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;587&quot;&gt;&lt;p&gt;（Graphviz用得不好不会画这样的....手绘了2333）&lt;/p&gt;&lt;p&gt;是不是很森破？代码酱在这里哟：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;inline void Update(int pos,int v) {
    pos += M;
    tree[pos] = v;
    for(pos&amp;gt;&amp;gt;=1;pos;pos&amp;gt;&amp;gt;=1) Maintain(pos);
}&lt;/code&gt;&lt;p&gt;短，真短，真鸡鹅短！非常轻松愉快地完成了Update操作。并且Zkw线段树在Update上的效率要比普通线段树优秀，因为Zkw线段树寻找叶子的复杂度是 &lt;equation&gt;O(1)&lt;/equation&gt; ，&lt;b&gt;Removed(&lt;/b&gt;而传统线段树是 &lt;equation&gt;O(logN)&lt;/equation&gt; 。所以如果某个题有频繁的单点修改，Zkw线段树会是一个非常好的选择。&lt;b&gt;)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;感谢&lt;/b&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6d5e20938a12aa51da703a72d78a272a&quot; data-hash=&quot;6d5e20938a12aa51da703a72d78a272a&quot; data-hovercard=&quot;p$b$6d5e20938a12aa51da703a72d78a272a&quot;&gt;@Schureed&lt;/a&gt; &lt;b&gt;提供的信息&lt;/b&gt;：事实上传统线段树在建树时可以记录下叶子结点位置，因此也可以做到 &lt;equation&gt;O(1)&lt;/equation&gt; 的叶子查找。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;0x03 Range Sum Query&lt;/h2&gt;&lt;p&gt;在仅存在单点更新的情况下，RMQ和区间和查询方法一样，因此这里依旧以区间和查询为例介绍区间操作。&lt;/p&gt;&lt;p&gt;当遇到区间和查询时，问题双来了....传统线段树通过递归查询需要加和的区间最后统计所有的和，但是Zkw线段树....没法从顶上找到需要加和的区间啊QwQ....怎么办呢？但是换个方向思考...从底向上，查询区间为 &lt;equation&gt;[L,R]&lt;/equation&gt; ，&lt;b&gt;我们只能知道当前区间是否在查询区间内&lt;/b&gt;，即：如果当前查询区间&lt;b&gt;左端点 &lt;equation&gt;L&lt;/equation&gt; 所指向结点是线段树某个结点的左儿子&lt;/b&gt;且 &lt;equation&gt;R-1 \ne L&lt;/equation&gt; (即右端点指向结点&lt;b&gt;不是&lt;/b&gt;左端点指向结点的兄弟)，那么它的兄弟结点 &lt;equation&gt;L+1&lt;/equation&gt; 必然在查询区间内。同理，如果 &lt;equation&gt;R&lt;/equation&gt; 所指向结点的兄弟结点不是 &lt;equation&gt;L&lt;/equation&gt; ，那么它的兄弟结点必然包含在查询区间内。如图：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f959454828463c460423545330d7d7e4_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;881&quot;&gt;&lt;p&gt;因此我们实际能够查询到的是 &lt;equation&gt;(L,R)&lt;/equation&gt; 。没有关系，我们只需要查询 &lt;equation&gt;(L-1, R+1)&lt;/equation&gt;那么就相当于查询 &lt;equation&gt;[L, R]&lt;/equation&gt; 啦~~多么智慧。&lt;/p&gt;&lt;p&gt;为了避免重复查询，当 &lt;equation&gt;L&lt;/equation&gt; 和 &lt;equation&gt;R&lt;/equation&gt; 是兄弟结点时，我们就需要停止统计啦。代码如下。那么区间和查询的代码如下：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;inline int Sum(int l,int r) {
    int ans = 0;
    // l=l+M-1-&amp;gt;将查询区间改为L-1，r=r+M+1-&amp;gt;将查询区间改为R+1
    // l^r^1 -&amp;gt; 相当于判断l与r是否是兄弟节点
    for(l=l+M-1,r=r+M+1;l^r^1;l&amp;gt;&amp;gt;=1,r&amp;gt;&amp;gt;=1) {
        if(~l&amp;amp;1) // l % 2 == 0 即l是l/2的左儿子
            ans += tree[l^1];
        if(r&amp;amp;1) // r % 2 == 1 即r是r/2的右儿子
            ans += tree[r^1];
    }
    return ans;
}&lt;/code&gt;&lt;p&gt;Very Very森破，容易理解对不对？QwQ。人类的智慧！！Zkw大神的智慧！！Orz&lt;/p&gt;&lt;p&gt;这样我们就能在非常短的篇幅内写出一个优秀的线段树啦~Zkw线段树（一）至此结束啦。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;0x04 后记&lt;/h2&gt;&lt;p&gt;由于AP作业有点多，第二部分可能过一段时间才能更新...希望这篇文章能够帮助您further理解线段树的工作方法以及Zkw线段树的工作原理。另外，Fedora的中文输入法并不非常好使，如果粗线措自请告素沃亚~(这条除外2333)&lt;/p&gt;</description>
<author>Mike He</author>
<guid isPermaLink="false">2017-10-04-29876526</guid>
<pubDate>Wed, 04 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>用Python编写JSON解析器的概述</title>
<link>https://henix.github.io/feeds/zhuanlan.c_131397850/2017-10-01-29815903.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29815903&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7bee5fa626a3d128d685173ea22ca043_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;0x00 序言&lt;/h2&gt;&lt;p&gt;蒟蒻作者对Parser，Tokenizer这些东西并不很了解，或者说了解程度仅足以支撑我写一个JSON的解析器.....还望各路大佬多多指点，批评。另外这是我第一次在zhihu上写文章...并不太会用这个编辑器（感觉不太好用...?）所以排版有可能略难堪请各位多多包容（笑&lt;/p&gt;&lt;p&gt;虽然Python已经有自带的json模块，但手动实现一个还是能在一定程度上提升对JsonParser的了解....吧。&lt;/p&gt;&lt;p&gt;本文是对整个Parser编写JSON解析器的简要概述。&lt;/p&gt;&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/AD1024/JsonParser&quot;&gt;JsonParser&lt;/a&gt;&lt;/p&gt;&lt;p&gt;由于该项目用于练手+休闲，所以代码并不赏心悦目。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;0x01 解析器架构&lt;/h2&gt;&lt;p&gt;效仿大佬们的方法，我们先看一下这个解析器是怎样工作的：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5a690265e1b155442c70f53ba78f9f66_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;803&quot; data-rawheight=&quot;59&quot;&gt;&lt;p&gt;如图，首先我们要有原始数据。JSON的原始数据就是一个字符串；然后将字符串传到Reader中，Reader的功能有：1. 返回当前游标位置的字符;2. 向后移动游标;3. 向前移动游标。这样做是为了能够逐个字符读入原始数据并且通过上下文判断关键词作用。Tokenizer是将关键字身份和关键字所对应值存入到一个对象中提供给Parser进行进一步解析。Parser可以通过Tokenizer提供的Tokens判断语法正确性同时根据tokens的含义将数据存入Python的数据对象中。说起来比较简单，写起来难度不大但有一些复杂。这里直接用Python实现一波了...&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;0x02 定义JSONArray和JSONObject&lt;/h2&gt;&lt;p&gt;这应该是写这个Parser最容易的一步了。JSONArray是个list，JSONObject是个dict。&lt;/p&gt;&lt;p&gt;对于JSONArray, 我们需要以下这些功能：&lt;/p&gt;&lt;p&gt;1. append()&lt;/p&gt;&lt;p&gt;2. size()&lt;/p&gt;&lt;p&gt;3. __getitem__() #重载list的函数&lt;/p&gt;&lt;p&gt;4. __str__() # 格式化输出&lt;/p&gt;&lt;p&gt;对于JSONObject:&lt;/p&gt;&lt;p&gt;1. __getitem__(key)&lt;/p&gt;&lt;p&gt;2. __setitem__(key, value)&lt;/p&gt;&lt;p&gt;3. __str__() # 格式化输出&lt;/p&gt;&lt;p&gt;由于比较Simple，这里就不粘贴实现了。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;0x03 Reader&lt;/h2&gt;&lt;p&gt;Reader用于接收一个字符串然后使用一个cursor逐个字符进行读取。通过nextPos()获取当前位置字符并将游标向后移动一位：&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;class Reader(object) :
    def __init__(self, data) :
        self.data = data
        self.cursor = 0
    def nextPos(self) :
        self.cursor += 1
        return self.data[self.cursor-1]&lt;/code&gt;&lt;p&gt;同时我们需要检查是否有下一位：&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;def hasNext(self) :
    return self.cursor &amp;lt; len(self.data)&lt;/code&gt;&lt;p&gt;对于移动到上一位，我们需要作越界判断：&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;def prevPos(self) :
    self.cursor = max(self.cursor-1, 0)&lt;/code&gt;&lt;p&gt;至此我们Reader的基础功能就算完成了。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;0x04 Token &amp;amp; Tokenizer&lt;/h2&gt;&lt;p&gt;Token用于标注一个词素的意义以及对应值。例如：&#39;[&#39;是JSONArray开始(BEGIN_ARRAY)的信号词，对应值为&#39;[&#39;。由于JSON中的Token比较少，所以为了方便编写Parser，我们每一个Token所对应的意义用 &lt;equation&gt;2^k&lt;/equation&gt; 来表示。&lt;/p&gt;&lt;p&gt;Tokenizer是将原始数据转化为一个Token列表让，Parser能看懂的数据。&lt;/p&gt;&lt;p&gt;对数据进行Tokenize时，我们需要将字符逐个取出传入Tokenizer并判断当前字符是否属于关键字(Signal)，如果是关键字，我们对这个字符(或连带之后的值)一并进行处理。例如，如果当前处理的字符为&#39;{&#39;，我们就返回一个Token(BEGIN_OBJECT, &#39;{&#39;)。遇到双引号时，后面所对应数据为字符串;遇到数字或减号时，后面对应的时数字etc. 这时学习OI时接触的&lt;b&gt;读入优化&lt;/b&gt;就派上用场啦！事实上，在这个Project中，Tokenizer就是实现各种数据的读入优化然后将他们的意义和值存入一个列表中....由于代码较长，具体实现可以看这里:&lt;a href=&quot;https://github.com/AD1024/JsonParser/blob/master/tokenizer/Tokenizer.py&quot;&gt;Tokenizer&lt;/a&gt;。当然这里的Tokenizer并不完美...还需优化（也许有更加优美的实现方法呀）。放一个readInt()占位好了。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f0322fb4b8d9c5ef921da04b14a9dcf1_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;796&quot; data-rawheight=&quot;401&quot;&gt;&lt;hr&gt;&lt;h2&gt;0x05 Parser&lt;/h2&gt;&lt;p&gt;整个项目的核心，也是比较难调试的地方...作者的电脑没有PyCharm只好中间输出调试+瞪眼法调试了2333。当Parser拿到了她的好朋友Tokenizer辛勤劳动的成果——Tokenlist时，首先她会看一下，我是要解析一个JSONArray呢？还是要解析一个JSONObject呢？于是她就去看了第一个Token，如果这个Token的意义三BEGIN_ARRAY，那么她就先执行parseArray()，否则去执行parseObject()。在进行解析时，我们首先要规定我们下一个期望出现的Token时什么。例如，如果当前读到了BEGIN_ARRAY，那么下一个Token我们期待是BEGIN_STRING, BEGIN_BOOL, BEGIN_NUM, BEGIN_NULL和END_ARRAY。但如果当前是BEGIN_OBJECT，那么下一个期待的Token只能是BEGIN_STRING或者END_OBJECT了(JSONObject只能以str作为key)。这时我们规定Token含义为 &lt;equation&gt;2^k&lt;/equation&gt; 的好处就体现出来了。事实上，这样规定就相当于&lt;b&gt;状态压缩&lt;/b&gt;：将一个Token的含义定义为在一个整数的二进制下第 &lt;equation&gt;k&lt;/equation&gt; 位为1。这样，如果我们期望下一次是BEGIN_STRING或者END_OBJECT时，我们期望得到下一个Token的值( &lt;equation&gt;exp&lt;/equation&gt;  )和实际接收到的Token的值( &lt;equation&gt;actual&lt;/equation&gt; )进行按位与运算，如果得到的数字不是0，那么二进制下的 &lt;equation&gt;exp&lt;/equation&gt; 和 &lt;equation&gt;actual&lt;/equation&gt; 有至少一位都是1，这就说明当前Token是我们期望得到的：&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;# 设定期望Token
expected = END_OBJECT | BEGIN_STRING
# 判定actual是否属于END_OBJECT或者BEGIN_STRING
if expected &amp;amp; actual == 0 :
    return False
return True&lt;/code&gt;&lt;p&gt;由于STRING在JSONObject中既可以作KEY又可以作VALUE，因此我们需要对其前一个Token进行判断，如果前一个Token是COLON(冒号)，那么当前就是VALUE，否则是一个KEY。&lt;/p&gt;&lt;p&gt;另外，中间可能存在递归处理，注意一些特殊数据可能会爆栈(滑稽&lt;/p&gt;&lt;p&gt;当然可以用Python方便的tuple来搞啦～反正都可以实现(滑稽&lt;/p&gt;&lt;p&gt;由于Parser实现代码较长，大家可以去&lt;a href=&quot;https://github.com/AD1024/JsonParser/blob/master/parser/Parser.py&quot;&gt;Parser&lt;/a&gt;查看代码。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;0x06 后记&lt;/h2&gt;&lt;p&gt;写这个Parser+调试大概花了我一下午吧...第一次写，不是太清楚。这篇文章也许并不如正在阅读的您期待的那样好，只是大概地讲述了Json解析的步骤和大致的原理...不过还有代码可以看嘛233333.......&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;参考文章&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/absfree/p/5502705.html&quot;&gt;一起写一个JSON解析器&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhangfei/p/5035209.html&quot;&gt;JAVA自已设计JSON解析器&lt;/a&gt;&lt;/p&gt;&lt;p&gt;感谢这两位作者的文章&lt;/p&gt;</description>
<author>Mike He</author>
<guid isPermaLink="false">2017-10-01-29815903</guid>
<pubDate>Sun, 01 Oct 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
