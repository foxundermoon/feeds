<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Thu, 27 Dec 2018 11:20:13 +0800</lastBuildDate>
<item>
<title>rust，substructural type 与嵌入式开发</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-12-24-48721806.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/48721806&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为什么要用Rust开发嵌入式？目前随着深度学习走入实用，比如自动驾驶等，嵌入式部分需要协调，控制和调度各种外设和神经网络加速芯片等，复杂度急速上升，而C的弱类型系统可能会带来的巨量Bug，消耗大量开发时间。这时足够强大的类型系统能够帮助在编译期发现Bug。&lt;/p&gt;&lt;p&gt;很大一部分Bug是由于语言的限制，我们无法静态地保证某个资源在某时刻只被使用一次。而&lt;a href=&quot;https://en.wikipedia.org/wiki/Substructural_type_system&quot;&gt;Substructural type system&lt;/a&gt; 能够在代码中强迫你指定资源的使用方式：&lt;/p&gt;&lt;p&gt;1.borrow checker (affine type) 可以实现编译期静态检查某寄存器（外设）同一时间只被写入一次，而读取无限制，避免加锁。&lt;/p&gt;&lt;p&gt;2.避免空指针问题（同样是affine type)&lt;/p&gt;&lt;p&gt;下面是一些嵌入式领域的实际操作&lt;/p&gt;&lt;a data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; href=&quot;https://rust-embedded.github.io/discovery/index.html&quot;&gt;Introduction -&lt;/a&gt;&lt;a data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; href=&quot;https://news.ycombinator.com/item?id=16488227&quot;&gt;Should you Rust in embedded yet?&lt;/a&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;a data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; href=&quot;https://theburningmonk.com/2015/05/rust-memory-safety-without-gc/&quot; data-image=&quot;v2-757373e33df68436f413b52ebda14738&quot; data-image-width=&quot;500&quot; data-image-height=&quot;384&quot; data-image-size=&quot;180x120&quot;&gt;Rust – memory safety without garbage collector | theburningmonk.com&lt;/a&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;a data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; href=&quot;https://rust-embedded.github.io/bookshelf/book/peripherals/peripherals.html&quot;&gt;The Embedded Rust Book&lt;/a&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;a data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; href=&quot;https://medium.com/coinmonks/coding-the-stm32-blue-pill-with-rust-and-visual-studio-code-b21615d8a20&quot;&gt;https://medium.com/coinmonks/coding-the-stm32-blue-pill-with-rust-and-visual-studio-code-b21615d8a20&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Martin awodey</author>
<guid isPermaLink="false">2018-12-24-48721806</guid>
<pubDate>Mon, 24 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>愿你走出半生，归来仍是Java Parser</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-12-15-51811022.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51811022&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;几天前，我的一个朋友给了我一个Haskell问题&lt;/p&gt;&lt;blockquote&gt;Hey, MK，假设我有个BNF，并且我在Haskell中有个这个BNF的parser。&lt;br&gt;现在，我想给这个BNF改一行，有没有办法不用动这个BNF parser的代码（因为是其他人写的），而是对这parser进行扩展呢？&lt;/blockquote&gt;&lt;p&gt;这问题挺有趣的，也不算难。&lt;/p&gt;&lt;p&gt;这问题说是extensibility problem，其实有两个地方需要扩展。&lt;/p&gt;&lt;p&gt;0：Parser需要用open recursion之类的方法扩展&lt;/p&gt;&lt;p&gt;1：Parse出来的ADT也需要可扩展性&lt;/p&gt;&lt;p&gt;后半个需求见多了，Final Tagless，DTALC，Tree that grow，Recursion scheme style fix。。。于是放下不表，我们来处理前一个。&lt;/p&gt;&lt;p&gt;前半个。。Haskell&#39;s Overlooked Object System就搞过，当然他们有点heavy weight，打算随手弄一个&lt;b&gt;超级轻量级的&lt;/b&gt;：5行就够了，多一行是小莎莎。&lt;/p&gt;&lt;p&gt;Ready？&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Object x = MkObject (x -&amp;gt; x)&lt;/code&gt;&lt;p&gt;1。Inheritance is not subtyping式的Object=recursive type。为了简易性（反正也不需要多高的扩展性）就不model真。recursive type，而只有recursive dependency。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;use :: Object x -&amp;gt; x
use (MkObject x) = let res = x res in res&lt;/code&gt;&lt;p&gt;2。3。最典型的tying the knot。其实就是fix了。&lt;/p&gt;&lt;p&gt;我们想想，这个x是什么variant的呢？covariant还是contravariant？&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;inherit :: (a -&amp;gt; b) -&amp;gt; (b -&amp;gt; a) -&amp;gt; Object a -&amp;gt; Object b
inherit ab ba (MkObject aa) = MkObject (ab . aa . ba)&lt;/code&gt;&lt;p&gt;既然是invariant，那fmap contramap都用不上，但invariant依然能有map：两边一起传进来就行了。4。5。&lt;/p&gt;&lt;p&gt;这就是一个prototype based oo system了。&lt;/p&gt;&lt;p&gt;接下来讲怎么用哈：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;test :: Object (Int, Int)
test = MkObject $ \self -&amp;gt; (2, fst self + fst self)&lt;/code&gt;&lt;p&gt;这弄了个两个field的object，第零个field初始值为2（可能因为继承被override），第一个field为第零个field的值*2（不一定是3，如果任何field被override这个值都能改）。use test应该是(2, 4)。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;inheritTest :: Object ((Int, Int), Int)
inheritTest = inherit (\(l, r) -&amp;gt; ((l + 1, r + 2), r + 1)) fst test&lt;/code&gt;&lt;p&gt;这里继承了上面的Object，override了l(l + 1是super + 1），r被override到super + 2，加了个新的field，值是r+1。use inheritTest应该是((3, 8), 7)。记着传进来的参数不是self而是super就很好理解了。&lt;/p&gt;&lt;p&gt;好，open recursion搞好了，剩下的就是标准的final tagless了，体力活，没啥意思&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class AST repr where
  lit :: Int -&amp;gt; repr
  plus :: repr -&amp;gt; repr -&amp;gt; repr

class Var repr where
  var :: String -&amp;gt; repr

type WholeParser repr = Parser repr
type LitParser repr = Parser repr
type PlusParser repr = Parser repr

intP :: Parser Int
intP = read &amp;lt;$&amp;gt; many1 digit

stringP :: Parser String
stringP = many1 letter

type OriginalParser repr = ((LitParser repr, PlusParser repr), WholeParser repr)
originalParser :: AST repr =&amp;gt; Object (OriginalParser repr)
originalParser = MkObject $ \(~(_, p)) -&amp;gt; let
  litP = lit &amp;lt;$&amp;gt; intP
  plusP = between (char &#39;(&#39;) (char &#39;)&#39;) (do {l &amp;lt;- p; spaces; char &#39;+&#39;; spaces; r &amp;lt;- p; return $ plus l r})
  wholeP = litP &amp;lt;|&amp;gt; plusP in
  ((litP, plusP), wholeP)

type VarParser repr = Parser repr
extendedParser :: (AST repr, Var repr) =&amp;gt; Object (VarParser repr, OriginalParser repr)
extendedParser = inherit extend snd originalParser
  where
    extend ~((litP, plusP), wholeP) = let
      varP = var &amp;lt;$&amp;gt; stringP in
      (varP, ((litP, plusP), varP &amp;lt;|&amp;gt; wholeP))

instance AST String where
  lit = show
  plus x y = &quot;(&quot; ++ x ++ &quot; &quot; ++ &quot;+&quot; ++ &quot; &quot; ++ y ++ &quot;)&quot;

instance Var String where
  var x = x&lt;/code&gt;&lt;p&gt;大功告成。&lt;/p&gt;&lt;p&gt;代码在&lt;a href=&quot;https://github.com/MarisaKirisame/extensible-parser/blob/master/src/Lib.hs&quot;&gt;https://github.com/MarisaKirisame/extensible-parser/blob/master/src/Lib.hs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Q：封装呢？&lt;/p&gt;&lt;p&gt;A：Abstract Type is Existential Type&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Q：这是prototype based的，class怎么办？&lt;/p&gt;&lt;p&gt;A：A Theory Of Object里面讲过怎么用prototype来做class&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Q：多继承呢？&lt;/p&gt;&lt;p&gt;A：给定Object a，Object b，可以组合出Object (a, b)，要菱形继承自己手动再inherit一下就好&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Q：Subtyping?&lt;/p&gt;&lt;p&gt;A：Typeclass。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果大家感兴趣，请评论下，我可以再写个blog把这些功能补完。&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2018-12-15-51811022</guid>
<pubDate>Sat, 15 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust 阴阳谜题，及纯基于代码的分析与化简</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-12-13-52249705.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52249705&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;听 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/c3a3b37f42ed38a9783c00cea5156e55&quot; data-hash=&quot;c3a3b37f42ed38a9783c00cea5156e55&quot; data-hovercard=&quot;p$b$c3a3b37f42ed38a9783c00cea5156e55&quot;&gt;@头顶青天红美铃&lt;/a&gt; 说&lt;/p&gt;&lt;blockquote&gt;看了一圈，大家都说的是怎么拿一个动态语言跑yin yang。无论是编译，解释，最底的层次基本是某个动态语言。&lt;/blockquote&gt;&lt;a href=&quot;https://www.zhihu.com/question/27683900/answer/541141000&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;如何实现 Call / CC 或者阴阳谜题（Yin Yang Puzzle）？&lt;/a&gt;&lt;h2&gt;0. 前（请务必跳过）&lt;/h2&gt;&lt;p&gt;之前用 Haskell 通过 Cont Monad 模拟过 &lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt; （实际上在阴阳谜题中用作 get-current-continuation，这里我们只讨论 &lt;code class=&quot;inline&quot;&gt;get/cc&lt;/code&gt;），但似乎确实是搞个 DSL 再模拟。&lt;/p&gt;&lt;p&gt;但我是觉得这&lt;b&gt;和动态类型其实关系不大&lt;/b&gt;，只是通常语言是栈机模型，而 call/cc 的“栈”是一棵树，还可能到处跳。唯一和类型有关的是 &lt;code class=&quot;inline&quot;&gt;get/cc&lt;/code&gt; 类型是递归类型 &lt;code class=&quot;inline&quot;&gt;a where a ~ (a -&amp;gt; _|_)&lt;/code&gt;，但我们可以用类似 &lt;code class=&quot;inline&quot;&gt;data Out a = In (Out a) (Out a)&lt;/code&gt; 的实现，在需要的时候把&lt;code class=&quot;inline&quot;&gt;Cont&lt;/code&gt;翻成&lt;code class=&quot;inline&quot;&gt;Cont -&amp;gt; Cont&lt;/code&gt;，或者反过来即可。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;1. Rust 代码实现&lt;/h2&gt;&lt;p&gt;因为&lt;b&gt;不想搞得那么学术派&lt;/b&gt;，我们不用 Haskell 那种数学语言，用&lt;b&gt;很工程很靠谱的 Rust &lt;/b&gt;实现以下这个 阴阳谜题/YinYang Puzzle。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先，我们直译一下 ：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;yin = getcc();
print!(&quot;@&quot;);
yin = getcc();
print!(&quot;*&quot;);
yin(yang);&lt;/code&gt;&lt;p&gt;但这当然是搞不了的。&lt;/p&gt;&lt;p&gt;我们 &lt;code class=&quot;inline&quot;&gt;getcc&lt;/code&gt; 拿来的 &lt;code class=&quot;inline&quot;&gt;yin&lt;/code&gt;不可能在全局都能用（主程序还是栈机啊喂，超级 goto 过分了），我们限定它在一个闭包里面才能用（这里我们要手动 CPS 一下），具体多大范围按需即可。&lt;/p&gt;&lt;p&gt;此外，由于函数调用的重载还没 stable，用了怕一下有 stable 癖的人觉得这不 Rust，所以这里用成员函数实现。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;所以我们的代码应该是这样，然后一跑发现&lt;b&gt;已经是预期行为了&lt;/b&gt;：(&lt;a href=&quot;https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=e1885dbdd463f9015072178981e3d5db&quot;&gt;Rust Playground&lt;/a&gt;)&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;/// Continuation.
/// Cont ~ (Cont -&amp;gt; !)    We use `()` instead of `!` here since `!` not stable
struct Cont&amp;lt;&#39;a&amp;gt;(&amp;amp;&#39;a dyn Fn(&amp;amp;Cont));

impl Cont&amp;lt;&#39;_&amp;gt; {
    fn call(&amp;amp;self, value: &amp;amp;Cont) {
        (self.0)(value); // Simple proxy. Note that it is dynamic dispatch.
    }
}

/// Equal to `{ let cc_ = getcc(); cc(cc_); }`
/// Apparently, `cc_` and `cc` is the same continuation.
fn with_cc(cc: impl Fn(&amp;amp;Cont)) {
    cc(&amp;amp;Cont(&amp;amp;cc)); // Call `cc` with `cc` itself (current continuation)
}

fn puzzle() {
    with_cc(|yin| {
        print!(&quot;@&quot;);
        with_cc(|yang| {
            print!(&quot;*&quot;);
            yin.call(yang);
        });
    });
}&lt;/code&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;@*@**@***@****@*****@******@*******@********@**** .....stack overflow&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;PS：惊奇地发现这份代码在 Release 下跑可以避免栈溢出，一直输出下去，看来是 TCO 了，果然优化还是很强劲的。当然记得本地编译跑，在线会被杀掉而看不到输出。&lt;/p&gt;&lt;p&gt;PSS：因为这里闭包引用结构的嵌套无法消去（我觉得 Rust 应该做不了 Idris 的 &lt;code class=&quot;inline&quot;&gt;Nat &amp;lt;=&amp;gt; Int&lt;/code&gt; 优化），所以内存应该还是会缓慢（ &lt;equation&gt;O(\sqrt {\text{Len}})&lt;/equation&gt; ）增长的。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;2. 分析与化简&lt;/h2&gt;&lt;p&gt;现在我们试着&lt;b&gt;只从代码上分析，尽量避免数学推导，证明为何是这样的输出&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;（才不是因为看不懂 pi-calculus / 不会分析平行宇宙呢）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先，我们这里有两个闭包，&lt;code class=&quot;inline&quot;&gt;|yin| { .. }&lt;/code&gt;没有捕获东西，&lt;code class=&quot;inline&quot;&gt;|yang| { .. }&lt;/code&gt;捕获了上一层的&lt;code class=&quot;inline&quot;&gt;yin&lt;/code&gt; 的引用，我们要手动展开闭包语法糖。&lt;/p&gt;&lt;p&gt;然后考虑到&lt;code class=&quot;inline&quot;&gt;&amp;amp;dyn Fn(&amp;amp;Cont)&lt;/code&gt; 是动态分发，但只可能是两个闭包之一，直接用 &lt;code class=&quot;inline&quot;&gt;enum&lt;/code&gt;实现这个 Trait Object 引用，也是展开语法糖。&lt;/p&gt;&lt;p&gt;因为闭包代码都很少，这里我们直接把函数体代码 inline 进动态分发的&lt;code class=&quot;inline&quot;&gt;call&lt;/code&gt;里去了。 &lt;/p&gt;&lt;p&gt;(&lt;a href=&quot;https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=1574dc2f845671fda44ae124b06be4e8&quot;&gt;Rust Playground&lt;/a&gt;)&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;enum Cont&amp;lt;&#39;a&amp;gt; { // Desugar of `&amp;amp;dyn Fn(&amp;amp;Cont)`
    ClosureA,
    ClosureB { yin: &amp;amp;&#39;a Cont&amp;lt;&#39;a&amp;gt; },
}

impl Cont&amp;lt;&#39;_&amp;gt; {
    fn call(&amp;amp;self, value: &amp;amp;Cont) {
        match self { // Manually dynamic dispatch
            Cont::ClosureA =&amp;gt; {
                let yin = value;
                print!(&quot;@&quot;);
                with_cc(Cont::ClosureB { yin });
            }
            Cont::ClosureB { yin } =&amp;gt; {
                let yang = value;
                print!(&quot;*&quot;);
                yin.call(yang);
            }
        }
    }
}

fn with_cc(cc: Cont) {
    cc.call(&amp;amp;cc);
}

fn puzzle() {
    with_cc(Cont::ClosureA);
}&lt;/code&gt;&lt;p&gt;可能还看不出来调用顺序如何，但&lt;code class=&quot;inline&quot;&gt;call&lt;/code&gt;经过或不经过&lt;code class=&quot;inline&quot;&gt;with_cc&lt;/code&gt;，最终递归调用自己，至少可以知道它是个死循环，而且似乎还是尾递归的。&lt;/p&gt;&lt;p&gt;然后我们可以发现，这个 &lt;code class=&quot;inline&quot;&gt;enum Cont&lt;/code&gt;实际上就是一个&lt;b&gt;不带值的链表结构&lt;/b&gt;（ &lt;code class=&quot;inline&quot;&gt;Cont::ClosureA&lt;/code&gt; &amp;lt;=&amp;gt; Null，&lt;code class=&quot;inline&quot;&gt;Cont::ClosureB&lt;/code&gt; &amp;lt;=&amp;gt; Next），它&lt;b&gt;只包含长度信息。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;所以我们&lt;b&gt;只用一个自然数即可和它一一对应。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;（对，这就是皮亚诺自然数定义的 Nat，但因为不要学术，不展开）&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;0 &amp;lt;=&amp;gt; Cont::ClosureA
1 &amp;lt;=&amp;gt; Cont::ClosureB { yin: &amp;amp;Cont::ClosureA }
2 &amp;lt;=&amp;gt; Cont::ClosureB { yin: &amp;amp;Cont::ClosureB { yin: &amp;amp;Cont::ClosureA }  }
...&lt;/code&gt;&lt;p&gt;我们直接定义 &lt;code class=&quot;inline&quot;&gt;type Cont = usize&lt;/code&gt;来重写简化一下&lt;code class=&quot;inline&quot;&gt;call&lt;/code&gt;函数。&lt;/p&gt;&lt;p&gt;多套一层就是加一，模式匹配就是判零/减一。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;type Cont = usize;

fn call(this: Cont, value: Cont) {
    if this == 0 {
        let yin = value;
        print!(&quot;@&quot;);
        let cc = yin + 1;
        call(cc, cc);
    } else {
        let yin = this - 1;
        let yang = value;
        print!(&quot;*&quot;);
        call(yin, yang);
    }
}

fn puzzle() {
    call(0, 0);
}&lt;/code&gt;&lt;p&gt;哇，尾递归！就是循环！&lt;/p&gt;&lt;p&gt;然后我们把两个函数 inline 到一起：&lt;/p&gt;&lt;p&gt;（&lt;a href=&quot;https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=9d0d28a2a7ea56fa65b54d790212568c&quot;&gt;Rust Playground&lt;/a&gt; 上把死循环改成 &lt;code class=&quot;inline&quot;&gt;for&lt;/code&gt;了，不然卡死看不到输出）&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn puzzle() {
    let (mut this, mut value) = (0, 0);
    loop {
    // for _ in 0..1024 { // For test running online
        if this == 0 {
            print!(&quot;@&quot;);
            this = value + 1;
            value = value + 1;
        } else {
            print!(&quot;*&quot;);
            this = this - 1;
            // value = value; // Unchanged
        }
    }
}&lt;/code&gt;&lt;p&gt;这下可以清楚看到这个&lt;b&gt;拍扁的二重循环&lt;/b&gt;结构了：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;this == 0&lt;/code&gt; 时，&lt;code class=&quot;inline&quot;&gt;value&lt;/code&gt;自增 1，并设&lt;code class=&quot;inline&quot;&gt;this = value&lt;/code&gt;， 输出一个&lt;code class=&quot;inline&quot;&gt;@&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;否则一次&lt;code class=&quot;inline&quot;&gt;this&lt;/code&gt;自减 1，输出一个&lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt;；&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;最后重写成更语义化的二重循环就好啦：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;3. 最终化简代码&lt;/h2&gt;&lt;p&gt;(&lt;a href=&quot;https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=a3c2e5b8845ec62ddcf669f22043f161&quot;&gt;Rust Playground&lt;/a&gt; 限制了第一个&lt;code class=&quot;inline&quot;&gt;for&lt;/code&gt;范围以防止死循环)&lt;/p&gt;&lt;p&gt;子循环是&lt;code class=&quot;inline&quot;&gt;this&lt;/code&gt;从&lt;code class=&quot;inline&quot;&gt;value&lt;/code&gt;自减到 1,（0 不输出了 &lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt;，直接返回上一层了） 。当然显然这个循环顺序其实没啥关系，为了和上面对应还是反过来了。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn puzzle() {
    for value in 1.. { // The value after `print`, starting from 1
    // for value in 1..64 { // For test running online
        print!(&quot;@&quot;);
        for _this in (1..=value).rev() {
            print!(&quot;*&quot;);
        }
    }
}&lt;/code&gt;&lt;p&gt;大循环一次一个&lt;code class=&quot;inline&quot;&gt;@&lt;/code&gt;，然后小循环输出 &lt;code class=&quot;inline&quot;&gt;value&lt;/code&gt;个&lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt;，自增&lt;code class=&quot;inline&quot;&gt;value&lt;/code&gt;，重复。&lt;/p&gt;&lt;p&gt;输出结果当然就是 &lt;code class=&quot;inline&quot;&gt;@*@**@***@****@*****@******@*******@********@....&lt;/code&gt;啦 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;4. 以上&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>HOOCCOOH</author>
<guid isPermaLink="false">2018-12-13-52249705</guid>
<pubDate>Thu, 13 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Recursion Schemes（六）基本函子革命</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-11-30-51286145.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51286145&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e5a2a9858bfa0c0e317c6943a84edb5b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;为了能够不拖更，我决定讨论一些小一点的话题，本章中我们将讨论基本函子（base functor）这一概念，以及 &lt;a href=&quot;https://hackage.haskell.org/package/recursion-schemes&quot;&gt;recursion-schemes&lt;/a&gt; 库函数中如何使用基本函子来使 recursion scheme 在实践中更为优雅高效。&lt;/p&gt;&lt;h2&gt;前情回顾&lt;/h2&gt;&lt;p&gt;在之前数篇文章中，我们已经看到了某种定义参数化数据类型的模式，我们从这样的数据类型定义：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Expr
  = Index Expr Expr
  | Call Expr [Expr]
  | Unary String Expr
  | Binary Expr String Expr
  | Paren Expr
  | Literal Int
  deriving (Show, Eq)&lt;/code&gt;&lt;p&gt;变为了这样：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data ExprF a
  = Index a a
  | Call a [a]
  | Unary String a
  | Binary a String a
  | Paren a
  | Literal Int
  deriving (Show, Eq, Functor)&lt;/code&gt;&lt;p&gt;一样的数据类型，但是 kind [1] 变为了 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; *&lt;/code&gt;，所有的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 都用 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 做了替换。接着我们使用了 Y-组合子的技巧来定义 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt;，这样的定义与之前的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 等价，但是可以使用 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;，以及 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Term f = In { out :: f (Term f) }

type Expr = ExprF (Term ExprF)&lt;/code&gt;&lt;p&gt;类似地，在第四章中，我们定义了自然数，它的 kind 也是 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; *&lt;/code&gt; 的：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Nat a
    = Zero
    | Next a
    deriving Functor&lt;/code&gt;&lt;p&gt;我们也定义了 &lt;code class=&quot;inline&quot;&gt;Plant&lt;/code&gt;，也是类似的定义：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Plant a
  = Root a
  | Stalk a
  | Fork a a a
  | Bloom&lt;/code&gt;&lt;p&gt;这个表达数据的办法确实清晰明了，但是也有相应的问题。&lt;/p&gt;&lt;p&gt;假设我们考虑一个最简单地链表类型：&lt;code class=&quot;inline&quot;&gt;a:[a]&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;infixr 5 :
data [] a = a : [a]
          | []&lt;/code&gt;&lt;p&gt;显然 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt;，我们最基本的右折叠操作，应该可以支持这一结构。毕竟它的 kind 也是 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; *&lt;/code&gt;。但如果我在这一结构上使用 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt;，我们马上就遇到了麻烦：我们无法在了链表里存储元素了。 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 只能表示嵌套的 &lt;code class=&quot;inline&quot;&gt;Term a&lt;/code&gt; 这一结构。没有地方来存储链表本身的元素。可以想见，这样的链表并不十分有用。&lt;/p&gt;&lt;p&gt;当然我们也可以将 &lt;code class=&quot;inline&quot;&gt;[a]&lt;/code&gt; 转换为之前我们常见的那种模式，新加入一个参数来表达递归的部分。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data ListF a b
  = Cons a b
  | Nil
    deriving (Show, Eq, Functor)&lt;/code&gt;&lt;p&gt;在这样的结构上我们就可以完成递归了：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;listSum :: Num a =&amp;gt; Algebra (ListF a) a
listSum (Cons a b) = a + b
listSum Nil = 0&lt;/code&gt;&lt;p&gt;但是这一办法非常丑陋，如果对于 &lt;code class=&quot;inline&quot;&gt;[]&lt;/code&gt;，这样的类型全部进行手动替换的话，我们完全丧失了使用 recursion scheme 的初衷。幸好并不是我一个人这么觉得，实际上有非常多种做法来绕开这个问题，我们会着重描述 &lt;a href=&quot;https://hackage.haskell.org/package/recursion-schemes&quot;&gt;recursion-schemes&lt;/a&gt; 中解决该问题的办法。&lt;/p&gt;&lt;h2&gt;救星基本函子&lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 库文档中有如下定义：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type family Base t :: * -&amp;gt; *&lt;/code&gt;&lt;p&gt;这个定义明显会吓到不少人，但实际上并没有那么难以理解，而正是这一定义使得 &lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 在易用性上远远超越了它的竞争对手们。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Base&lt;/code&gt; 类型类的目的就是将 Haskell 中的原生类型定义，或者我们自己的类型定义与相对应的参数化类型定义绑定起来。对 type family 的详尽用法进行介绍显然超出了本文的范畴（感兴趣的读者可参阅 &lt;a href=&quot;https://wiki.haskell.org/GHC/Type_families&quot;&gt;GHC wiki&lt;/a&gt;），我们可以简单认为 type family 是一个在类型上定义函数的方式。如果我们定义了一个 type family，以及一个它的实例（这与 typeclass 以及它的实例实际上是类似的）：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type family Something t

type instance Something Foo = Bar&lt;/code&gt;&lt;p&gt;那么之后我们无论在哪里遇到调用 &lt;code class=&quot;inline&quot;&gt;Something Foo&lt;/code&gt;，GHC 类型系统都会将它代换为 &lt;code class=&quot;inline&quot;&gt;Bar&lt;/code&gt;，为什么不直接写 &lt;code class=&quot;inline&quot;&gt;Bar&lt;/code&gt; 呢？—— 这初看起来无关紧要，但这为我们建立两种类型间的联系提供了便利。&lt;/p&gt;&lt;p&gt;我们观察一下 &lt;code class=&quot;inline&quot;&gt;Base&lt;/code&gt; 的定义，当你传入 &lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt; 时，你得到了一个 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; *&lt;/code&gt; 的类型，回想一下不难发现，我们也把 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 变成 &lt;code class=&quot;inline&quot;&gt;ExprF&lt;/code&gt; 的过程也是一个 &lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt; 到 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; *&lt;/code&gt; 的过程。同理，&lt;code class=&quot;inline&quot;&gt;list&lt;/code&gt; 就是一个 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; *&lt;/code&gt; 到 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt; 的过程。&lt;/p&gt;&lt;p&gt;一个 &lt;code class=&quot;inline&quot;&gt;Base&lt;/code&gt; 类型的实例或许更能说明问题：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type instance Base [a] = ListF a&lt;/code&gt;&lt;p&gt;简单来说，这样的写法使得 &lt;code class=&quot;inline&quot;&gt;ListF a&lt;/code&gt; 可以用 &lt;code class=&quot;inline&quot;&gt;Base [a]&lt;/code&gt; 来表达。对应于每种类型，它的参数化递归类型（&lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt; 变换为 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; *&lt;/code&gt;）只有一种合法实现，对应来看，对于任意 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;Base a&lt;/code&gt; 也只有一种合法实现。&lt;/p&gt;&lt;p&gt;当我们把这一定义与 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 类型类相结合以后，事情变得有趣起来。（为了阐述方便，这里的定义进行了适当简化）。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class (Functor (Base t)) =&amp;gt; Recursive t where
  project :: t -&amp;gt; Base t t
  cata    :: (Base t a -&amp;gt; a) -&amp;gt; t -&amp;gt; a&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 类型类与 &lt;code class=&quot;inline&quot;&gt;Foldable&lt;/code&gt; 类型类实际上是同构的[2]。无论我们定义了怎样的 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 实例，&lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 或是 &lt;code class=&quot;inline&quot;&gt;[a]&lt;/code&gt;，我们都可以在上面做折叠操作。实际上这里我们定义了两种方法，&lt;code class=&quot;inline&quot;&gt;project&lt;/code&gt; 参数为一个 &lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt; 类型变量，得到变化后的 &lt;code class=&quot;inline&quot;&gt;Base&lt;/code&gt; 形式。以及 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 函数，给定一个 &lt;code class=&quot;inline&quot;&gt;Base t a -&amp;gt; a&lt;/code&gt; 函数，一个初始化的 &lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;，最后得到一个 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这里的 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 和我们之前的定义初看上去似乎有所不同。我们定义的 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 只有 &lt;code class=&quot;inline&quot;&gt;Founctor&lt;/code&gt; 的约束：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;cata :: (Functor f) =&amp;gt; Algebra f a -&amp;gt; Term f -&amp;gt; a
cata f = out &amp;gt;&amp;gt;&amp;gt; fmap (cata f) &amp;gt;&amp;gt;&amp;gt; f&lt;/code&gt;&lt;p&gt;但我们的 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 必须使用 &lt;code class=&quot;inline&quot;&gt;Term List&lt;/code&gt; 而不是简单的 &lt;code class=&quot;inline&quot;&gt;[a]&lt;/code&gt;，而使用 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 类型类允许我们向 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 传入一般的数据类型 &lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt; 而不是 &lt;code class=&quot;inline&quot;&gt;Term t&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 的实例使用 &lt;code class=&quot;inline&quot;&gt;project&lt;/code&gt; 函数来将提供的类型转换为带参数的类型，并将它传递给 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 函数，省去了我们包装 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 和拼接 &lt;code class=&quot;inline&quot;&gt;Cons&lt;/code&gt; 的工作。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;sumList :: Num a =&amp;gt; [a] -&amp;gt; a
sumList = cata go where
  go Nil = 0
  go (Cons a acc) = a + acc&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 的魔法不止于此，根据它的最小编译指示，我们实现 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 类时，最低限度只需要实现 &lt;code class=&quot;inline&quot;&gt;project&lt;/code&gt; 函数即可。&lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 等函数可以沿用默认定义。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class Functor (Base t) =&amp;gt; Recursive t where
  project :: t -&amp;gt; Base t t

  cata :: (Base t a -&amp;gt; a) -- ^ a (Base t)-algebra
       -&amp;gt; t               -- ^ fixed point
       -&amp;gt; a               -- ^ result
  cata f = c where c = f . fmap c . project&lt;/code&gt;&lt;p&gt;这只是 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 的默认实现而已，如果在你特定的数据结构上，&lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 存在更好的实现，当然你可以重写这一定&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 类型类中还定义了其他方法，例如我们曾在之前的文章中讨论过的 &lt;code class=&quot;inline&quot;&gt;para&lt;/code&gt;，还包括一些我们没涉及的比如泛化的 paramorphism &lt;code class=&quot;inline&quot;&gt;gpara&lt;/code&gt;，以及 Fokkinga 提出的 prepromorphism &lt;code class=&quot;inline&quot;&gt;prepro&lt;/code&gt;，或许我们会在之后的文章中讨论它们（译者注：作者在之后的文章中并未讨论它们，或许我会在之后的文章中讨论它们？）。&lt;/p&gt;&lt;p&gt;注意 Base 类型受限于 Recursive 实例：&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt; 必须有一个 &lt;code class=&quot;inline&quot;&gt;Base&lt;/code&gt; 的实例，而且 &lt;code class=&quot;inline&quot;&gt;Base t&lt;/code&gt; 必须是一个 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt; 类型，这是因为 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 依赖于使用 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt; 在进行递归操作。&lt;/p&gt;&lt;p&gt;正是因为有了 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 类型类，我们可以操作 &lt;code class=&quot;inline&quot;&gt;[a]&lt;/code&gt; 而非 &lt;code class=&quot;inline&quot;&gt;ListF&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 而非 &lt;code class=&quot;inline&quot;&gt;ExprF&lt;/code&gt;，我们可以在简单数据类型上使用 Recursion Scheme。这一技巧在其它的库中也有采用，比如 José Pedro Magalhães 的 &lt;a href=&quot;https://hackage.haskell.org/package/regular/docs/Generics-Regular-Base.html#t:PF&quot;&gt;regular&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;下面我们看一下定义 &lt;code class=&quot;inline&quot;&gt;[a]&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 的实例。&lt;code class=&quot;inline&quot;&gt;[]&lt;/code&gt; 变为了 &lt;code class=&quot;inline&quot;&gt;Nil&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;:&lt;/code&gt; 变为了 &lt;code class=&quot;inline&quot;&gt;Cons&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;instance Recursive [a] where
  project (x:xs) = Cons x xs
  project [] = Nil&lt;/code&gt;&lt;p&gt;另外一个重要的例子是 &lt;code class=&quot;inline&quot;&gt;Natural&lt;/code&gt; —— 我们在之前也讨论过。我们自己定义了自然数类型 &lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt;，这一类型与 &lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt; 等同的。所以在 &lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 中就使用了 &lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt; 来实现 &lt;code class=&quot;inline&quot;&gt;Natural&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Base&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type instance Base Natural = Maybe

instance Recursive Natural where
  project 0 = Nothing
  project n = Just (n - 1)&lt;/code&gt;&lt;h2&gt;更进一步&lt;/h2&gt;&lt;p&gt;正如我们之前所看到的，给定一个 &lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;，构造 &lt;code class=&quot;inline&quot;&gt;Base&lt;/code&gt; 的示例是非常直观的：为原来的类型定义加入一个新的类型变量，接着改造每一个构造函数使其可以加入递归的新的类型变量。而借助 Haskell 的模板能力，&lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 可以生成如下的代码：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;import Data.Functor.Foldable.TH

data Expr
  = Index Expr Expr
  | Call Expr [Expr]
  | Unary String Expr
  | Binary Expr String Expr
  | Paren Expr
  | Literal Lit
  deriving (Show, Eq)

makeBaseFunctor &#39;&#39;Expr&lt;/code&gt;&lt;p&gt;其中 &lt;code class=&quot;inline&quot;&gt;makeBaseFunctor&lt;/code&gt; 生成的代码实际上等价于：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data ExprF a
  = IndexF a a
  | CallF a [a]
  | UnaryF String a
  | BinaryF a String a
  | ParenF a
  | LiteralF Lit
  deriving (Show, Eq, Functor)

type instance Base Expr = ExprF

instance Recursive Expr where
  project (Index a b) = IndexF a b
  project (Call a b)  = CallF a b
  -- and so on and so forth&lt;/code&gt;&lt;p&gt;这实际上就是讲上述描述应用而生成的代码，为了避免命名冲突，新的类型构造函数带一个后缀 ‘F’（中缀表达式后缀为‘$’）。&lt;/p&gt;&lt;p&gt;应用了 Haskell 模板以后，意味着对于我们这些库使用者，使用 &lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 的代价非常之小。而这些处理嵌套结构的能力，在我编写 Haskell 生产级别代码时带来了非常大的益处。你可以非常优雅地处理嵌套结构，不需要引入任何额外代码。&lt;/p&gt;&lt;h2&gt;再次翻转箭头&lt;/h2&gt;&lt;p&gt;在之前的文章中，我们多次使用翻转箭头的操作来生成展开操作。所以想必读者们对于我们要进行的操作也不会陌生，我们会同样对 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 进行类似操作。从而得到 &lt;code class=&quot;inline&quot;&gt;Corecursive&lt;/code&gt; 类型类，对应相应的展开操作。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class Functor (Base t) =&amp;gt; Corecursive t where
  embed :: Base t t -&amp;gt; t
  ana :: (a -&amp;gt; Base t a) -&amp;gt; a -&amp;gt; t&lt;/code&gt;&lt;p&gt;我们已经展示过，从 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 生成 &lt;code class=&quot;inline&quot;&gt;ana&lt;/code&gt; 的过程，所以只剩下通过翻转箭头从 &lt;code class=&quot;inline&quot;&gt;project&lt;/code&gt; 生成 &lt;code class=&quot;inline&quot;&gt;embed&lt;/code&gt; 的过程，我们从 &lt;code class=&quot;inline&quot;&gt;Base&lt;/code&gt; 函子生成 &lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;也对应于 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;ana&lt;/code&gt; 使用 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;embed&lt;/code&gt; 生成：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class Functor (Base t) =&amp;gt; Corecursive t where
  embed :: Base t t -&amp;gt; t
  ana
    :: (a -&amp;gt; Base t a) -- ^ a (Base t)-coalgebra
    -&amp;gt; a               -- ^ seed
    -&amp;gt; t               -- ^ resulting fixed point
  ana g = a where a = embed . fmap a . g&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;embed&lt;/code&gt; 实例的定义也是非常直观的对称：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;instance Corecursive [a] where
  embed (Cons x xs) = x:xs
  embed Nil = []&lt;/code&gt;&lt;p&gt;更棒的是，实际上你不必真的自己写 &lt;code class=&quot;inline&quot;&gt;Corecursive&lt;/code&gt; 的实例，&lt;code class=&quot;inline&quot;&gt;makeBaseFunctor&lt;/code&gt; 会同时自动生成 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Corecursive&lt;/code&gt; 的实例。&lt;/p&gt;&lt;h2&gt;餐后甜点&lt;/h2&gt;&lt;p&gt;敏锐的读者可能已经注意到了，&lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 库中的 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 实现与我们之前的形式有一些微妙的不同。我们的定义中，包括 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 的柯里化—— &lt;code class=&quot;inline&quot;&gt;cata f&lt;/code&gt;，将它传给了 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;cata :: (Functor f) =&amp;gt; Algebra f a -&amp;gt; Term f -&amp;gt; a
cata f = out &amp;gt;&amp;gt;&amp;gt; fmap (cata f) &amp;gt;&amp;gt;&amp;gt; f&lt;/code&gt;&lt;p&gt;而 &lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 则实现了 where 语句定义了变量 &lt;code class=&quot;inline&quot;&gt;c&lt;/code&gt; 来代换 &lt;code class=&quot;inline&quot;&gt;cata f&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;两种 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 定义都是 point-free 的，但是 &lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 的实现曾令笔者十分困惑，&lt;code class=&quot;inline&quot;&gt;c&lt;/code&gt; 的出现似乎毫无意义。直到若干年以后，我才大致理解了其中的含义。如果你避免了这样的柯里化，GHC 会生成更加高效的代码。柯里化函数必须携带它们的参数，在调用过程中必须追溯这些参数。而对于一个裸函数，调用的过程会简单得多（你可以访问 GHC 的 wiki 页面 &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects&quot;&gt;heap objects&lt;/a&gt; 来获得更多恶心的细节）。&lt;/p&gt;&lt;p&gt;当得知这一知识以后，我们就可以发现 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 的实现十分优雅，通过 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 的命名，我们可以像一个普通函数一样对待它，从而生成更加高效的代码。一般来说这样的优化，效果是微乎其微的，但是由于 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 在每层折叠操作中都会被调用，累积导致的效率损失对于一个库函数来说也是不可忽视的。&lt;/p&gt;&lt;h2&gt;结语&lt;/h2&gt;&lt;p&gt;我必须向 Edward Kmett 表示感谢，他的 &lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 库优雅且富有启发性。同时我还要感谢 Austin Seipp，帮我检查了文章关于 GHC 代码生成部分的描述。&lt;/p&gt;&lt;p&gt;我希望能在下一篇文章中介绍 hylomorphisms and chronomorphisms，从而可以结束这一系列文章。感谢大家的耐心阅读！&lt;/p&gt;&lt;p&gt;[1]: 如果你对 kind 这一定义并不熟悉，你可以大致地认为，kind 描述了数据类型需要的参数个数，&lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 中不需要参数，所以 kind 为 &lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt;，需要一个参数的则为 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; *&lt;/code&gt;。需要更多参数的比如 &lt;code class=&quot;inline&quot;&gt;Either&lt;/code&gt;，kind 为 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;，对于 kind 更精准的描述是类型的类型，但是我们可以简单地将其理解为参数的个数表示。对于任意类型，在 GHCi 中可以使用 &lt;code class=&quot;inline&quot;&gt;:k&lt;/code&gt; 来查看它所属的类型。&lt;/p&gt;&lt;p&gt;[2]: 你可以从它所属的模块名 &lt;code class=&quot;inline&quot;&gt;Data.Functor.Foldable&lt;/code&gt; 中看到这样的暗示。这个类原本就叫 &lt;code class=&quot;inline&quot;&gt;Foldable&lt;/code&gt;，由于与标准库中的 &lt;code class=&quot;inline&quot;&gt;Foldable&lt;/code&gt; 重名，才改为 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt;。&lt;/p&gt;</description>
<author>禾木旁</author>
<guid isPermaLink="false">2018-11-30-51286145</guid>
<pubDate>Fri, 30 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>随机游走法解 Possion 方程！</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-11-28-51047940.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51047940&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-160d55f74cacc560575f32f2f18b17bd_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;Possion 方程是指形如 &lt;equation&gt;\Delta \varphi = f&lt;/equation&gt; 的方程，在三维欧几里得空间中 &lt;equation&gt;\Delta=\nabla^2=\frac{\partial^2}{\partial x^2}+\frac{\partial^2}{\partial y^2}+\frac{\partial^2}{\partial z^2}&lt;/equation&gt; ，这类方程在物理上有很多应用，如在静电学中给定电荷分布求解电势的方程 &lt;equation&gt;\nabla^2\Phi=-\rho/\epsilon_0&lt;/equation&gt; ，牛顿力学中的引力场方程 &lt;equation&gt;\nabla^2\phi=4\pi G\rho&lt;/equation&gt;，达到定态时的热传导方程 &lt;equation&gt;k\nabla^2u=0&lt;/equation&gt; 。本文介绍一种解 Possion 方程的数值方法，随机游走法。&lt;/p&gt;&lt;p&gt;作为一种数值解法，我们首先考虑将 Possion 方程离散化，只求解离散的格点上的函数值。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\varphi(x,y) \mapsto \varphi_{ij},f(x,y) \mapsto f_{ij}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;然后是 &lt;equation&gt;\nabla^2&lt;/equation&gt; 的离散化：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\frac{\partial \varphi}{\partial x}\mapsto \frac{\varphi(x+h/2,y)-\varphi(x-h/2,y)}{h}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;考虑格点间距 &lt;equation&gt;h=1&lt;/equation&gt; ，有&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\frac{\partial^2 \varphi}{\partial x^2}\mapsto\varphi(x+1,y)+\varphi(x-1,y)-2\varphi(x,y)&lt;/equation&gt; &lt;equation&gt;\nabla^2 \varphi=\frac{\partial^2 \varphi}{\partial x^2}+\frac{\partial^2 \varphi}{\partial y^2}=f\mapsto \varphi_{i,j+1}+\varphi_{i,j-1}+\varphi_{i+1,j}+\varphi_{i-1,j}-4\varphi_{ij}=f_{ij}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;上式即为 Possion 方程的离散形式，可以看到，这是一个极其稀疏的线性方程组 &lt;equation&gt;A\varphi=f&lt;/equation&gt; ，如果我们求解的区间内有 &lt;equation&gt;100\times100&lt;/equation&gt; 个格点， &lt;equation&gt;A&lt;/equation&gt; 即为一个 &lt;equation&gt;100\times100&lt;/equation&gt; 的矩阵，而其每一行只有 5 个系数不为 0。我们可以通过直接求解这个线性方程组来解出 Possion 方程，但本文要介绍另外一种算法：随机游走法。&lt;/p&gt;&lt;p&gt;将离散化的 Possion 方程稍微改变一下形式：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\varphi_{ij}=\frac{1}{4}(\varphi_{i,j+1}+\varphi_{i,j-1}+\varphi_{i+1,j}+\varphi_{i-1,j})+f&#39;_{ij}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;等式右边的第一项可以看作是一次对 &lt;equation&gt;\varphi_{i,j+1},\varphi_{i,j-1},\varphi_{i+1,j},\varphi_{i-1,j}&lt;/equation&gt; 这四个值的等概率随机抽样的均值，记单次抽样结果为 &lt;equation&gt;\varphi_{\{\varphi_{i,j+1},\varphi_{i,j-1},\varphi_{i+1,j},\varphi_{i-1,j}\}}&lt;/equation&gt; 。将单次随机抽样计算得到的 &lt;equation&gt;\varphi_{ij}&lt;/equation&gt; 记为 &lt;equation&gt;\phi_{ij}&lt;/equation&gt; ，上式可以改写为&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\varphi_{ij}=E(\phi_{ij})=E(\varphi_{\{\varphi_{i,j+1},\varphi_{i,j-1},\varphi_{i+1,j},\varphi_{i-1,j}\}}+f&#39;_{ij})=E(\varphi_{\{\phi_{i,j+1},\phi_{i,j-1},\phi_{i+1,j},\phi_{i-1,j}\}}+f&#39;_{ij})&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这个式子就是随机游走法的原理。&lt;/p&gt;&lt;p&gt;我们将 &lt;equation&gt;E&lt;/equation&gt; 移到最外层，即将求均值的计算放到最后一步，这样计算单个格点的值的抽样就变成了单次抽样，这等价于一个朝上下左右四个方向的随机游走。&lt;/p&gt;&lt;p&gt;我们从区间中的任意一个格点出发随机游走到区间的边界，该格点的抽样值即为边界条件所确定的边界值加上路径上的 &lt;equation&gt;f&#39;_{ij}&lt;/equation&gt; 的求和，最后多次抽样取平均即可得到 Possion 方程的近似解。&lt;/p&gt;&lt;p&gt;我用 Julia 实现了这个算法，求解了几个方程并画出了函数图像：&lt;/p&gt;&lt;p&gt;边界为正弦函数的 Laplace 方程：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f0dbe5f0a05873e353418f6c23bf49f5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;400&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bbad1c1cf759e161b40a6b854f38028a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;400&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;边界为阶跃函数的 Laplace 方程：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-83023a109ee1cfd13587c5715606a84f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;400&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9730f508f7846f2d83b2f98496253509_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;400&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;边界为 0 但非其次项在中心不为 0 的 Possion 方程：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-524aa8ef5f2b3c0e66ccd2a564bcdaba_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;400&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c8320d0981f9fc0230e97fee028fabd0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;400&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;附上代码：&lt;/p&gt;&lt;code lang=&quot;julia&quot;&gt;isEdge(x::Int, y::Int) =  x == 1 || y == 1 || x == 50 || y == 50

function walk(x::Int, y::Int, m::Array{Float64, 2}, c::Array{Float64, 2},
              getEdgeVal::Function,f::Function)::Float64
    randv = rand()
    res = f(x, y) + if isEdge(x, y)
        getEdgeVal(x, y)
    elseif randv &amp;lt; 1/4
        walk(x-1, y, m, c, getEdgeVal, f)
    elseif randv &amp;lt; 1/2
        walk(x+1, y, m, c, getEdgeVal, f)
    elseif randv &amp;lt; 3/4
        walk(x, y+1, m, c, getEdgeVal, f)
    else
        walk(x, y-1, m, c, getEdgeVal, f)
    end
    m[x, y] += res
    c[x, y] += 1
    res
end

function solve(n::Int, getEdgeVal::Function, f::Function)
    accum = zeros(50, 50)
    counter = zeros(50,50)
    for _ in 1:n
        for i in 1:50
            for j in 1:50
                walk(i, j, accum, counter, getEdgeVal, f)
            end
        end
    end
    accum ./ counter
end&lt;/code&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Narc</author>
<guid isPermaLink="false">2018-11-28-51047940</guid>
<pubDate>Wed, 28 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>形式验证、依赖类型与动态类型</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-11-25-50792280.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50792280&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-22a53ae89319b99e314a4886dc6f882b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;aka 依赖类型传教文&lt;/p&gt;&lt;p&gt;推荐阅读&lt;a href=&quot;https://ice1000.org/lagda/DependentFunctionsVersusDynamicTyping.html&quot;&gt;我的博客的版本&lt;/a&gt;，你可以点击网页的代码块里面的变量名，可以跳转到定义。&lt;/p&gt;&lt;p&gt;前排提醒：你或许&lt;b&gt;不&lt;/b&gt;需要一个&lt;a href=&quot;https://baike.baidu.com/item/%E6%B8%B8%E6%A0%87%E5%8D%A1%E5%B0%BA&quot;&gt;游标卡尺&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;本文面向一切有任何形式编程经验的读者，将会使用 Agda 和极少量其他语言展示代码例子。 读不懂的代码可以借助附近的文字描述理解它的含义，所以不用担心语言问题。&lt;/p&gt;&lt;p&gt;一切规矩照旧，这篇文章是一个 Agda 模块，我们导入一些基本库：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;{-# OPTIONS --no-unicode #-}
{-# OPTIONS --without-K  #-}
{-# OPTIONS --safe       #-}
module DependentFunctionsVersusDynamicTyping where

open import lib.Basics
&lt;/code&gt;&lt;p&gt;这次，我们需要使用 &lt;a href=&quot;https://github.com/HoTT/HoTT-Agda/tree/master/core/lib&quot;&gt;HoTT-Agda&lt;/a&gt; 中的自然数类型的相关定义：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;open import lib.types.Nat
&lt;/code&gt;&lt;p&gt;泛化阶：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;variable i : ULevel
&lt;/code&gt;&lt;p&gt;本人承诺不会在这种面向非 Agda 专业人士的文章里使用 Unicode 。&lt;/p&gt;&lt;p&gt;在这个没有 &lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt; 的语言里，我们有时还是需要使用 &lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt; 的：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;data Nullable {i} (A : Type i) : Type i where
  nullptr : Nullable A
  new_    : A -&amp;gt; Nullable A
&lt;/code&gt;&lt;p&gt;这样， &lt;code class=&quot;inline&quot;&gt;nullptr&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;new 1&lt;/code&gt; 都是 &lt;code class=&quot;inline&quot;&gt;Nullable Nat&lt;/code&gt; 类型的实例了（这些符号马上就介绍）：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = nullptr :&amp;gt; Nullable Nat
_ = (new 1) :&amp;gt; Nullable Nat
&lt;/code&gt;&lt;h2&gt;依赖类型的数组&lt;/h2&gt;&lt;p&gt;定义一个数组类型，数组长度是类型的一部分：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;infixr 5 _cat_
data Vec {i} (A : Type i) : Nat -&amp;gt; Type i where
  []    : Vec A O
  _cat_ : forall {n} -&amp;gt; A -&amp;gt; Vec A n -&amp;gt; Vec A (S n)
&lt;/code&gt;&lt;p&gt;这样，我们可以有空数组，以自然数类型为例：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = [] :&amp;gt; Vec Nat 0
&lt;/code&gt;&lt;p&gt;其中， &lt;code class=&quot;inline&quot;&gt;:&amp;gt;&lt;/code&gt; 左边是一个表达式（在这里是 &lt;code class=&quot;inline&quot;&gt;[]&lt;/code&gt;），右边是它的类型。&lt;code class=&quot;inline&quot;&gt;_ =&lt;/code&gt; 表示把这个表达式赋值给一个无法被使用的变量，也就是丢掉这个表达式。 以这种形式写出来，我就可以在编译我的博客的时候让 Agda 编译器检查我的这些代码片段是否在类型上是正确的。&lt;/p&gt;&lt;p&gt;把代码编译成网页是 Agda 编译器的一个功能，我目前正在着手改善它的这个功能。 也就是说，如果我给我的博客写一个 &lt;code class=&quot;inline&quot;&gt;main&lt;/code&gt; 函数，我就可以运行我的博客了……&lt;/p&gt;&lt;p&gt;先不说这个，一个元素的数组，也就是一个元素和一个空数组连接的结果：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = (233 cat []) :&amp;gt; Vec Nat 1
&lt;/code&gt;&lt;p&gt;两个元素：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = (666 cat 233 cat []) :&amp;gt; Vec Nat 2
&lt;/code&gt;&lt;p&gt;观察发现，数组的类型 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 有两个参数，第一个参数是元素的类型 &lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt; ，也就是自然数，第二个是长度，这两个参数都是编译期已知的。 这个数组的定义常常被 Idris 语言的粉丝用于布道——因为它很安全，可以在编译的时候防止越界的情况发生，就像 C++ 程序员会推荐 &lt;code class=&quot;inline&quot;&gt;std::array&lt;/code&gt; 一样。 而由于 Agda 语言人气不足，别人布道的时间 Agda 程序员都写论文去了。&lt;/p&gt;&lt;p&gt;我们来尝试一下 Agda 的『小于』类型。小于关系是一个类型，如果我们有一个类型为 &lt;code class=&quot;inline&quot;&gt;a &amp;lt; b&lt;/code&gt; 的变量，那么我们就『证明』了 &lt;code class=&quot;inline&quot;&gt;a &amp;lt; b&lt;/code&gt;。 也就是说，我们可以弄出一个类型为 &lt;code class=&quot;inline&quot;&gt;3 &amp;lt; 4&lt;/code&gt; 的变量：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = ltS :&amp;gt; (3 &amp;lt; 4)
&lt;/code&gt;&lt;p&gt;也可以有 &lt;code class=&quot;inline&quot;&gt;114514 &amp;lt; 114516&lt;/code&gt; 类型的变量：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = ltSR ltS :&amp;gt; (114514 &amp;lt; 114516)
&lt;/code&gt;&lt;p&gt;但是我们无论如何也弄不出 &lt;code class=&quot;inline&quot;&gt;1 &amp;lt; 1&lt;/code&gt; 类型的对象——这是由 &lt;code class=&quot;inline&quot;&gt;&amp;lt;&lt;/code&gt; 的定义决定的，这里就不展开说了（涉及的东西有点多）。&lt;/p&gt;&lt;p&gt;因此，我们可以写出这样一个函数：它『从长度为 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 数组中获取第 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 个元素』，并要求调用这个函数的人额外传入一个 类型为 &lt;code class=&quot;inline&quot;&gt;n &amp;lt; m&lt;/code&gt; 的变量。&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;module GetAtIndex where
  _!!_&amp;lt;[_]&amp;gt; : {A : Type i} -&amp;gt; forall {l} -&amp;gt; Vec A l
          -&amp;gt; (n : Nat) -&amp;gt; n &amp;lt; l -&amp;gt; A
  (x cat _) !! O &amp;lt;[ _ ]&amp;gt; = x
  (_ cat a) !! S n &amp;lt;[ p ]&amp;gt; = a !! n &amp;lt;[ &amp;lt;-cancel-S p ]&amp;gt;
&lt;/code&gt;&lt;p&gt;这样，有了 &lt;code class=&quot;inline&quot;&gt;n &amp;lt; m&lt;/code&gt; 的证明，我们无论如何都能安全地从数组里拿出一个元素了。 举一个简单的调用的例子。这是一个测试用的数组：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;sampleList : Vec Nat 4
  sampleList = 0 cat 1 cat 2 cat 3 cat []
&lt;/code&gt;&lt;p&gt;我们试图取它的第 2 项，没有问题（下面的代码是让编译器试图验证『从刚才那个数组中取第 2 项得到的是 2』）：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = idp :&amp;gt; ((sampleList !! 2 &amp;lt;[ ltSR ltS ]&amp;gt;) == 2)
&lt;/code&gt;&lt;p&gt;试试第一项？&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = idp :&amp;gt; ((sampleList !! 1 &amp;lt;[ ltSR (ltSR ltS) ]&amp;gt;) == 1)
&lt;/code&gt;&lt;h2&gt;运行时错误&lt;/h2&gt;&lt;code lang=&quot;agda&quot;&gt;module RuntimeErrors where
  open GetAtIndex
&lt;/code&gt;&lt;p&gt;一个老生常谈（我在两个群里被问过了）的问题：如果下标和数组都是运行时获取的，编译器的验证不就凉了吗？&lt;/p&gt;&lt;p&gt;解决方法：在运行时进行判断——如果下标小于数组长度，那么在这样的条件下可以得到一个小于关系的证明， 就可以安全地进行函数调用。否则，你将不能调用这个函数，请自行处理非法输入。&lt;/p&gt;&lt;p&gt;给出一个简单的实现（库里面其实有一个 &lt;code class=&quot;inline&quot;&gt;Decidable&lt;/code&gt; 的版本，但是它里面用了 Unicode ，我不想用，所以就自己写了一个）。 首先，我们需要判断两个自然数的大小，并在小于的时候返回小于的证明，其他时候返回 &lt;code class=&quot;inline&quot;&gt;nullptr&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;lessThan : forall a b -&amp;gt; Nullable (a &amp;lt; b)
  lessThan O O = nullptr
  lessThan O (S b) = new O&amp;lt;S b 
  lessThan (S a) O = nullptr
  lessThan (S a) (S b) with lessThan a b
  ... | nullptr = nullptr
  ... | new x   = new &amp;lt;-ap-S x
&lt;/code&gt;&lt;p&gt;然后，我们就可以在不模式匹配、直接把参数拿来用的情况下，对 &lt;code class=&quot;inline&quot;&gt;_!!_&amp;lt;[_]&amp;gt;&lt;/code&gt; 进行调用了。 这个函数通过接收任意的自然数和任意的数组来模拟运行时无法保证的输入，并返回可能不存在的输出：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;runtimeInput : forall {m} -&amp;gt; Vec Nat m -&amp;gt; Nat -&amp;gt; Nullable Nat
  runtimeInput [] _ = nullptr
  runtimeInput{m}vn with lessThan n m
  ... | nullptr = nullptr
  ... | new x   = new (v !! n &amp;lt;[ x ]&amp;gt;)
&lt;/code&gt;&lt;p&gt;这个函数和 Java、JavaScript 函数就没什么可见的区别了，这也体现出了形式验证的一个小小的局限性。&lt;/p&gt;&lt;p&gt;但在运行时的情况下，我们还是能看出形式验证的好处的——类型签名里函数对参数需要满足的关系以非常清晰的形式呈现了（比如， &lt;code class=&quot;inline&quot;&gt;a &amp;gt; b&lt;/code&gt; 这种表达式），表达的也很简洁， 函数的调用者无需阅读文档即可安全地进行 API 调用，运行时不需要任何错误处理——编译的时候就能保证所有的错误得到处理，运行时当然是把这些东西全部都擦除掉了。&lt;/p&gt;&lt;h2&gt;稍微弱一点的类型系统&lt;/h2&gt;&lt;p&gt;看到这里，我们会想起，像 Java 和 JavaScript 里类似的函数都会在参数不合法的时候抛出一个异常。 因此，如果我们的程序要足够健壮，我们会选择：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;处理这个异常&lt;/li&gt;&lt;li&gt;判断下标是否小于长度，提前避免错误&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;具有证明命题能力的编程语言一般会强制程序员进行后者的操作，具有责任心的程序员会主动进行后者的操作， 绝大多数时间我们是忽略了这件事的——编译器、程序员、用户都没有去证明输入数据对程序来说一定合法。 当输入不合法时（尽管这很少发生），我们的程序会崩溃掉（&lt;b&gt;运行时错误&lt;/b&gt;），否则将正常运行。&lt;/p&gt;&lt;p&gt;运行时错误，从动态类型到静态类型的过程中已经大幅减少了。但这里可以看出，它还是存在的。&lt;/p&gt;&lt;p&gt;不知道 C++ 程序员有没有想到 SFINAE 呢？（笑）&lt;/p&gt;&lt;p&gt;但总而言之，把证明传来传去是一件很麻烦的事情，光是阅读命题本来就是额外工作，证明就更麻烦了。 像 C++ 的 SFINAE，在参数不合法的时候，如果不手动让编译器抛出一些可读的异常，编译器会产生大量的错误信息， 印在厕纸上都能用一年。&lt;/p&gt;&lt;p&gt;但是呢，会把程序写成这样的形式验证研究员都是垃圾（凭空制造复杂度），他们的思维都被限制了。&lt;/p&gt;&lt;p&gt;我们首先来看看大家觉得虽然邪恶但是写起来爽的『动态类型』。&lt;/p&gt;&lt;h2&gt;更浅显的话题&lt;/h2&gt;&lt;p&gt;程序员们常常对『动态类型和静态类型哪个更好』这一话题产生激烈的讨论。 这其实是一个完全没有意义的讨论，因为这首先是一个罗卜白菜的问题——两者都有能称得上是『优点』的地方； 其次不同的人对程序有不同的追求，有人想写出健壮可扩展的程序，有人只是想快速交付收钱； 再其次同一个人也有不同的需求，有时只是想批量处理一些文件，有时需要构建长期维护的大型项目。&lt;/p&gt;&lt;p&gt;对于简单的批处理需求，我们甚至会完全不考虑任何的可读性、可维护性、可扩展性、安全性、鲁棒性， 写出类似这样的代码（已经整理过了，再看不懂就是语言的问题）：&lt;/p&gt;&lt;code lang=&quot;perl&quot;&gt;while (my $line = &amp;lt;$imguiHeader&amp;gt;) {
  chomp $line;
  $_ = $line;
  if (m!^// dear imgui, (.*)$!) {
    my $commandPrefix = &#39;cd ../imgui &amp;amp;&amp;amp; git rev-parse&#39;;
    print &quot;--- Generating for dear-imgui version $1\n&quot;, &quot;--- Revision &quot;, `$commandPrefix --verify HEAD`;
    print &quot;--- Branch &quot;, `$commandPrefix --abbrev-ref HEAD`, &quot;---\n\n&quot;, &quot;local $moduleName = { _version = &#39;@{[ $1 =~ s/[^∙↓]//gr ]}&#39; }\n&quot;;
  }
  elsif (/^\s*enum\s(\w+)_/) {
    $currentEnum = $1;
    $currentEnumMangled = $currentEnum =~ s/^Im(Gui)?(.)([^\s]*)$/@{[ lc $2 ]}$3/r =~ s/Flags$//gr;
    # =~ s/([a-z])([A-Z])/$1.@{[ lc $2 ]}/gr;
    print &quot;\n&quot;, &#39;--{&#39;, &#39;{&#39;, &quot;{ $currentEnumMangled\n&quot;, &quot;---\@type _$currentEnumMangled\n&quot;, &quot;local $currentEnumMangled = {}\n&quot;
  }
  elsif (length $currentEnum) {
    if (/\}/) {
      print &quot;$moduleName.$currentEnumMangled = $currentEnumMangled\n&quot;;
      print &quot;$currentEnumMangled = nil\n&quot;, &#39;--}&#39;, &#39;}&#39; &quot;} $currentEnumMangled\n&quot;;
      $currentEnum = &#39;&#39;; $previousDefault = 0;
    }
    elsif (m!^\s*${currentEnum}_(\w+)((\s*=\s*([^,/]+))?),?\s*(//\s*(.*))?!) {
      print &quot;\n--- $6\n&quot; if $5 and length $6;
      $mangledName = length $1 == 1 ? &quot;_$1&quot; : $1;
      $value = $2 ? calculate $4 : $previousDefault++;
      print &quot;$currentEnumMangled.$mangledName = &quot;, $value, &quot;\n&quot;;
    }
    elsif (m!^\s*//(.*)!) { print &quot;---$1\n&quot; }
  }
}&lt;/code&gt;&lt;p&gt;这样的代码完全是一个精雕细琢的艺术品——它的每一个字符都是我（没错这是我写的……用来提取一段 C++ 代码中的一部分定义并翻译成 Lua） 小心翼翼写出来的，稍微改一点就会出错，输入数据有一点点变化也可能出错，静态分析工具对这个代码的正确性完全没有保障（Perl 的解释器在运行你的代码的时候也不知道你的程序的目的，只是一行一行地运行而已）。&lt;/p&gt;&lt;p&gt;动态类型往往因为其灵活性被一些程序员（不是我）喜欢。比如我们可以写出这样的 JavaScript 程序：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;const Error = {}
const getAtIndex = (a, n) =&amp;gt; n &amp;lt; a.length ? a[n] : Error;&lt;/code&gt;&lt;p&gt;简单地运行：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;gt; getAtIndex([1, 2, 3], 2)
&amp;lt; 3
&amp;gt; GetAtIndex([], 1)
&amp;lt; {}&lt;/code&gt;&lt;p&gt;这个 &lt;code class=&quot;inline&quot;&gt;getAtIndex&lt;/code&gt; 接收一个数组和一个整数，返回『有时是一个数组元素，有时是 &lt;code class=&quot;inline&quot;&gt;Error&lt;/code&gt;』。 用 TypeScript 描述一下它的类型，就是：&lt;/p&gt;&lt;code lang=&quot;ts&quot;&gt;&amp;lt;a&amp;gt;(a[], number): a|Error&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;而我们调用这个函数，它到底会返回什么类型，我们也必须看它的实现才能知道。 返回 &lt;code class=&quot;inline&quot;&gt;Error&lt;/code&gt; 只是方便起见，我们大可使用异常来代替返回一个表达异常的对象。 但它做到了一点——在我们不想处理错误的时候，我们可以不处理错误，让运行时炸。 在我们想处理错误的时候，我们可以处理错误。&lt;/p&gt;&lt;p&gt;但这给了我们一个启发。或许我们可以实现这样的函数：在很明显没有错误的时候，我们可以不处理错误。 在有可能错误的时候，我们需要处理错误。&lt;/p&gt;&lt;p&gt;或许有人会说，我们不还有异常吗？但首先异常这一概念首先本身就足够『运行时』， 我们对什么样的函数会抛出什么样的异常都一无所知。Java 的 Checked Exception 作为一个例外，是静态的异常， &lt;b&gt;但是这种语法结构和返回带有错误信息的类型&lt;/b&gt; （可以理解为 Haskell 的 &lt;code class=&quot;inline&quot;&gt;Either&lt;/code&gt;， Rust 的 &lt;code class=&quot;inline&quot;&gt;Result&lt;/code&gt;） &lt;b&gt;是&lt;a href=&quot;http://www.yinwang.org/blog-cn/2017/05/23/kotlin&quot;&gt;同构&lt;/a&gt;的&lt;/b&gt;（这篇文章本身说的很有道理，但请不要看它所引用的《给 Java 说句公道话》）。&lt;/p&gt;&lt;blockquote&gt;首先，写 C# 代码时最让我头痛的事情之一，就是 C# 没有 CE。每调用一个函数（不管是标准库函数，第三方库函数，还是队友写的函数，甚至我自己写的函数），我都会疑惑这个函数是否会抛出异常。由于 C# 的函数类型上不需要标记它可能抛出的异常，为了确保一个函数不会抛出异常，你就需要检查这个函数的源代码，以及它调用的那些函数的源代码……&lt;br&gt;也就是说，你必须检查这个函数的整个“调用树”的代码，才能确信这个函数不会抛出异常。这样的调用树可以是非常大的。说白了，这就是在用人工对代码进行“全局静态分析”，遍历整个调用树。这不但费时费力，看得你眼花缭乱，还容易漏掉出错。显然让人做这种事情是不现实的，所以绝大部分时候，程序员都不能确信这个函数调用不会出现异常。&lt;/blockquote&gt;&lt;p&gt;在静态类型中，我们要么使用静态的带错误信息的返回类型（强制检查错误，即使很明显的正确的代码也必须处理错误）、要么使用异常（静态变动态，你干啥不去用 Python）。&lt;/p&gt;&lt;p&gt;而且，刚才那段 JavaScript 根本不可能在静态类型语言里实现（当然，这里没有考虑支持和类型的语言。但是要考虑到 支持和类型的编程语言大部分都是渐进类型或者以动态类型编程语言为目标语言的编程语言）——我们写不出一个同时有两种可能的返回类型的语言。&lt;/p&gt;&lt;p&gt;也就是说，动态类型能做（即使做的不完美，比如那个 &lt;code class=&quot;inline&quot;&gt;getAtIndex&lt;/code&gt; 并不会强制你处理异常，即使可能异常）的事静态类型做不到； 静态类型能做动态类型做不到的事就多了去了，在绝大多数情况下使用静态类型还是能带来远高于动态类型的编程体验的（ 包括 IDE 补全重构跳转、尽可能减少了类型错误等），这里就略过不提了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;难道鱼和熊掌真的不可兼得吗？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;不，小孩才做选择。&lt;/p&gt;&lt;h2&gt;我全都要&lt;/h2&gt;&lt;code lang=&quot;agda&quot;&gt;module IQuanDouWant where
  open RuntimeErrors&lt;/code&gt;&lt;p&gt;这时我们就需要用到依赖类型了。&lt;/p&gt;&lt;p&gt;我们除了传入证明作为参数之外，还可以使用依赖函数！&lt;/p&gt;&lt;p&gt;我们的 &lt;code class=&quot;inline&quot;&gt;getAtIndex&lt;/code&gt; 函数，在下标越界的时候返回 &lt;code class=&quot;inline&quot;&gt;Error&lt;/code&gt;，其他时候返回正常的值。 我们先定义一个表达错误的类型：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;data ???? : Type0 where ??? : ????
&lt;/code&gt;&lt;p&gt;我们的函数 &lt;code class=&quot;inline&quot;&gt;getAtIndex&lt;/code&gt;，返回的类型，是根据两个参数决定的。 所以，我们需要先写一个函数，接收两个自然数，返回『我们的 &lt;code class=&quot;inline&quot;&gt;getAtIndex&lt;/code&gt; 的返回类型』， 也就是说如果左边大于右边，就返回『自然数』这个类型，否则返回表达错误的类型。 请注意，只有带有较好的依赖类型支持的类型系统才能做到这种事。如果一个语言声称自己支持依赖类型， 你可以问问他能不能写出这样的代码。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;returnType : (_ _ : Nat) -&amp;gt; Type0
  returnType O _ = ????
  returnType (S _) O = Nat
  returnType (S n) (S m) = returnType n m
&lt;/code&gt;&lt;p&gt;然后，我们的 &lt;code class=&quot;inline&quot;&gt;getAtIndex&lt;/code&gt; 需要返回的，就是这个类型。&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;getAtIndex : forall {m} -&amp;gt; (v : Vec Nat m) -&amp;gt; (n : Nat) -&amp;gt; returnType m n
  getAtIndex [] _ = ???
  getAtIndex (x cat _) O = x
  getAtIndex (_ cat v) (S n) = getAtIndex v n
&lt;/code&gt;&lt;p&gt;看看看！这个函数的实现真的好简单啊！&lt;/p&gt;&lt;p&gt;我们试试证明它的性质？我们先传入合法的参数，看看是不是就直接返回了数组的元素：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;open GetAtIndex using (sampleList)
  _ = idp :&amp;gt; (getAtIndex sampleList 2 == 2)
  _ = idp :&amp;gt; (getAtIndex sampleList 1 == 1)
&lt;/code&gt;&lt;p&gt;真的耶！那如果是超过长度上限的下标，是不是就会返回那个错误类型呢？&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = idp :&amp;gt; (getAtIndex sampleList 233 == ???)
&lt;/code&gt;&lt;p&gt;是的！&lt;/p&gt;&lt;p&gt;这个函数的返回类型真的在变耶！而且这是非常非常纯正的静态类型编程哦！&lt;/p&gt;&lt;p&gt;你看，静态类型做不到的事，依赖类型做到了。动态类型没法编译期进行类型检查，依赖类型可以。&lt;/p&gt;&lt;h2&gt;实际应用&lt;/h2&gt;&lt;code lang=&quot;text&quot;&gt;module FSharpLang where

  -- ...
&lt;/code&gt;&lt;p&gt;就懒得写了，毕竟本来就是我的另一篇博客。这是一个依赖函数的经典应用—— &lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://ice1000.org/2018/08/04/TypeSafePrintf/&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;。 它的类型是：&lt;code class=&quot;inline&quot;&gt;String -&amp;gt; ??&lt;/code&gt;，其中 &lt;code class=&quot;inline&quot;&gt;??&lt;/code&gt; 具体的值，取决于 &lt;code class=&quot;inline&quot;&gt;String&lt;/code&gt; 参数中有多少个 &lt;code class=&quot;inline&quot;&gt;%d&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;%c&lt;/code&gt; 等。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;啊，今泉影狼真可爱啊。&lt;/p&gt;</description>
<author>兴趣使然千里冰封</author>
<guid isPermaLink="false">2018-11-25-50792280</guid>
<pubDate>Sun, 25 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>我的 Linux 再也滚不挂了—— NixOS 桌面试用</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-11-22-50623869.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50623869&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-152bfce18c290103b65114d7e273ce1e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;之前在虚拟机里用了一段时间的 NixOS。昨天终于在笔记本上抛弃了“正常”发行版的带镜像下载速度，安装了 NixOS。那个 Fastly 的 CDN 稍微 slowly 点就 slowly 点吧……&lt;/p&gt;&lt;h2&gt;安装&lt;/h2&gt;&lt;p&gt;（本文不是 NixOS 安装和配置教程。安装教程请参考文档。）&lt;/p&gt;&lt;p&gt;NixOS 没有像 Ubuntu 或者 Fedora 那样的完全一站式的安装程序，所以一开始和 Arch 有点像，需要自己分区然后 mount 上。这一步参照 manual 就可以了。&lt;/p&gt;&lt;p&gt;之后 nixos-generate-config 命令会从当前挂载的分区和存在的硬件生成一个 /etc/nixos/hardware-configuration.nix 和一个基础系统的 /etc/nixos/configuration.nix。&lt;/p&gt;&lt;p&gt;默认的 configuration.nix 里面注释写的是举例形式的，比较简洁但是不难懂。先把网络和图形界面配置上：&lt;/p&gt;&lt;code lang=&quot;nixos&quot;&gt;networking.hostName = &quot;&amp;lt;It&#39;s important to pick a good name&amp;gt;&quot;; # https://www.xkcd.com/910/
networking.networkmanager.enable = true;
services.xserver.displayManager.sddm.enable = true;
services.xserver.desktopManager.plasma5.enable = true;&lt;/code&gt;&lt;p&gt;（Bootloader 默认是 systemd-boot，保留即可，换 GRUB 也行。）（题图是我的 Bootloader 和内核相关配置）&lt;/p&gt;&lt;p&gt;然后 nixos-install 就可以了，各种乱七八糟的自动按照 configuration.nix 配置好，最后让你设一个 root 密码，之后重启进系统就可以了。这一步比 Arch 简单多了。&lt;/p&gt;&lt;p&gt;在这里我们已经在体验 NixOS 系统配置的“一条龙服务”。在写下一行配置的时候，里面就包括了软件依赖、配置文件、Systemd 的 unit 文件等内容。&lt;/p&gt;&lt;p&gt;像这种声明式的系统配置，一大好处就是更加紧凑，更容易复现。日常使用上最明显的一点就是，我们再也不用担心忘了系统配置都改了什么了。&lt;/p&gt;&lt;h2&gt;使用&lt;/h2&gt;&lt;p&gt;和预料中的没有太大的差别。用户账户用什么东西直接 nix-env 安装就好，使用上和一般的包管理器比较接近，只是不需要 sudo 就可以装东西。实现上是在系统全局安装好后 symlink 到 ~/.nix-profile 下，成为一个“prefix”的样子，还是比较科学的。&lt;/p&gt;&lt;p&gt;我加了个 alias：&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;alias nixpkgs=&quot;nix-env -f &#39;&amp;lt;nixpkgs&amp;gt;&#39;&quot;&lt;/code&gt;&lt;p&gt;系统配置的话，用 /etc/nixos/configuration.nix 真是简直不能再爽。我的笔记本是 SSD 的，所以配置了一个 fstrim。&lt;/p&gt;&lt;code lang=&quot;nixos&quot;&gt;services.fstrim = {
  enable = true;
  interval = &quot;tuesday&quot;;  
};&lt;/code&gt;&lt;p&gt;SDDM 的 HiDPI 支持默认确实是打开的，不过貌似没有检测出我的机器需要 1.5x，所以加点配置：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;services.xserver.displayManager.sddm.extraConfig = &#39;&#39;
  [X11]
  ServerArguments=-dpi 144
&#39;&#39;;&lt;/code&gt;&lt;p&gt;（KDE 里面 Scale Display 到 1.5x，然后底栏高度拉高点就好了，不需要系统配置）&lt;/p&gt;&lt;p&gt;文本编辑器 Vim Emacs Nano 啥的默认统统没有，随手开个默认 EDITOR。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;programs.vim.defaultEditor = true;&lt;/code&gt;&lt;p&gt;ucode 啥的，我才不记得什么 initrd 呢，直接：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;hardware.cpu.intel.updateMicrocode = true;&lt;/code&gt;&lt;h2&gt;发行版&lt;/h2&gt;&lt;p&gt;Nixpkgs 里面的包少……吗？&lt;/p&gt;&lt;p&gt;有一些标记为非自由软件的包默认不会显示，安装也会失败。（nix-env 直接什么都不做……这应该是个 bug）如果需要用的话必须手动允许：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;nixpkgs.config.allowUnfree = true;&lt;/code&gt;&lt;p&gt;Nixpkgs 包总体来说应该还算可以吧……除了有大量常见自由软件以外（KDE 算不算……），许多小众的包和非自由软件 patched binary 的包在 Nixpkgs 里都能找到：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先就是整个 Haskell 的 Hackage 都在 Nixpkgs 里面，贡献了很大的包的总数……&lt;/li&gt;&lt;li&gt;Sarasa Gothic 字体都有&lt;a href=&quot;https://github.com/NixOS/nixpkgs/blob/master/pkgs/data/fonts/sarasa-gothic/default.nix&quot;&gt;打包&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;连 Mathematica 都有&lt;a href=&quot;https://github.com/NixOS/nixpkgs/blob/master/pkgs/applications/science/math/mathematica/default.nix&quot;&gt;打包&lt;/a&gt;。从 binary 开始 PatchELF……&lt;/li&gt;&lt;li&gt;VSCode 确实有，但是只有 binary 的没有 OSS 的。&lt;/li&gt;&lt;li&gt;Chrome 和 Chromium 倒是都有。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为什么 binary 要 PatchELF 呢？如果尝试运行一下就会发现有很多 so 找不到。&lt;/p&gt;&lt;p&gt;容易发现，NixOS 是缺少很多 FHS 目录的。比如 /bin 下只有一个 /bin/sh，/usr 下只有一个 /usr/bin/env，其余真正的软件都分开存放在不同的目录下，然后系统配置是 symlink 出来的，放在 /run/current-system。既然 /usr/lib 啥的都没有，能找到库就怪了。&lt;/p&gt;&lt;p&gt;这种隔离式的设计事实上帮助实现了原子更新和快速回滚。从启动界面上列出的不同版本的系统 profile 就可以看出，NixOS 是一个可以字面意义上“恢复上一次正确的配置”的发行版（趴）。而且配置 profile 之间的切换不需要复制好多文件之类的，所以非常迅速。&lt;/p&gt;&lt;p&gt;所以是不是左传可以在此立下 NixOS 滚不挂 Flag 一枚 23333&lt;/p&gt;&lt;p&gt;（实在不行，进启动盘重新 nixos-install 一遍，反正也是按照 configuration.nix 安装的）&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;所以你们可能关心的问题是：到底要不要用 NixOS。&lt;/p&gt;&lt;p&gt;如果你不需要 Ubuntu 那种的开箱即用的，觉得 Arch 那样的自己动手可以接受，喜欢 Gentoo 的可配置性，又不想自己完全编译整个世界，并且觉得所有系统配置全都由统一格式写出来的可复现性确实很棒，并且觉得那帮人为了 portable 和轻量级，自己做了个 Nix 语言可以接受的话，NixOS 可能就是专门为你设计的。&lt;/p&gt;&lt;p&gt;哦对，如果你特别想用 Lisp 或者特别想坚持用自由软件的话出门左转 GuixSD……&lt;/p&gt;&lt;h2&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://nixos.org/nixos/manual&quot;&gt;NixOS manual&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;我的 /etc/nixos/configuration.nix&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/dramforever/config/blob/master/nixos/configuration.nix&quot;&gt;https://github.com/dramforever/config/blob/master/nixos/configuration.nix&lt;/a&gt;&lt;/p&gt;</description>
<author>dram</author>
<guid isPermaLink="false">2018-11-22-50623869</guid>
<pubDate>Thu, 22 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Recursion Schemes（五）自未来而来</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-11-14-49814311.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49814311&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e5a2a9858bfa0c0e317c6943a84edb5b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;控制未来的 Futumorphism&lt;/h2&gt;&lt;p&gt;通过翻转箭头的技巧，我们可以获得 fold 的对偶形式 unfold，同理我们可以翻转箭头来获得 histomorphism 的对偶形式。不过首先为了获得 &lt;code class=&quot;inline&quot;&gt;histo&lt;/code&gt; 的对偶形式，我们要先得到 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt; 的对偶形式。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt; 结构中我们保存了 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;f (Attr f a)&lt;/code&gt; 两部分，而对偶的 &lt;code class=&quot;inline&quot;&gt;CoAttr&lt;/code&gt; 保存一个 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; &lt;i&gt;或者&lt;/i&gt; 一个 &lt;code class=&quot;inline&quot;&gt;f (CoAttr f a)&lt;/code&gt;，它的定义如下：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data CoAttr f a
  = Automatic a
  | Manual (f (CoAttr f a))&lt;/code&gt;&lt;p&gt;所以 CV-algebra 的对偶形式 CV-coalgebra 为：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type CVCoalgebra f a = a -&amp;gt; f (CoAttr f a)&lt;/code&gt;&lt;p&gt;注意 &lt;code class=&quot;inline&quot;&gt;CoAttr&lt;/code&gt; 的构造子，为什么命名是 &lt;code class=&quot;inline&quot;&gt;Automatic&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Manual&lt;/code&gt; 呢？因为对于 &lt;code class=&quot;inline&quot;&gt;Manual&lt;/code&gt; 我们需要手动指定在这一层级的 unfold 操作该如何进行。与之相反的是，&lt;code class=&quot;inline&quot;&gt;Automatic&lt;/code&gt; 则自动对该层级进行 unfold。这也是 Futumorphism 命名的由来，CV-coalgebra 可以决定，未来如何进行 unfold。（futumorphism 实际上词源是混杂的，futu 是拉丁语中的前缀，而 morpho 则是希腊语中的后缀，我们实际上有很多词都是词源混杂的，比如 television，automobile 等）&lt;/p&gt;&lt;p&gt;与前面我们介绍的 &lt;code class=&quot;inline&quot;&gt;ana&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;apo&lt;/code&gt; 类似，futumorphism 接受一个 coalgebra，一个种子值 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，并返回一个表达式 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;futu :: Functor f =&amp;gt; CVCoalgebra f a -&amp;gt; a -&amp;gt; Term f&lt;/code&gt;&lt;p&gt;我们使用翻转箭头推导了 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;para&lt;/code&gt; 的对偶形式，我们继续沿用当时的技巧，将 &lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 变为 &lt;code class=&quot;inline&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt; 变为 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;futu :: Functor f =&amp;gt; CVCoalgebra f a -&amp;gt; a -&amp;gt; Term f
futu f = In &amp;lt;&amp;lt;&amp;lt; fmap _worker &amp;lt;&amp;lt;&amp;lt; f

/Users/patrick/src/morphisms/src/Main.hs:28:32: error:
    • Found hole: ‘_worker’ with type :: CoAttr f a -&amp;gt; Term f&lt;/code&gt;&lt;p&gt;这也与 &lt;code class=&quot;inline&quot;&gt;histo&lt;/code&gt; 中 worker 函数的类型 &lt;code class=&quot;inline&quot;&gt;Term f -&amp;gt; Attr f a&lt;/code&gt; 照应了起来。所以 futu 的定义非常符合直觉：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;futu :: Functor f =&amp;gt; CVCoalgebra f a -&amp;gt; a -&amp;gt; Term f
futu f = In &amp;lt;&amp;lt;&amp;lt; fmap worker &amp;lt;&amp;lt;&amp;lt; f where
    worker (Automatic a) = futu f a        -- 继续本层级的递归
    worker (Manual g) = In (fmap worker g) -- 忽略本层的，直接进入更深层&lt;/code&gt;&lt;p&gt;当我们遇到 &lt;code class=&quot;inline&quot;&gt;Automatic&lt;/code&gt; 时，我们继续进行递归。而当遇到 &lt;code class=&quot;inline&quot;&gt;Manual&lt;/code&gt; 时，我们直接生成 &lt;code class=&quot;inline&quot;&gt;Term f&lt;/code&gt;，以作为 &lt;code class=&quot;inline&quot;&gt;futu&lt;/code&gt; 的返回值。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;futu&lt;/code&gt; 相比于 &lt;code class=&quot;inline&quot;&gt;apo&lt;/code&gt;，有着更强的表达能力，&lt;code class=&quot;inline&quot;&gt;apo&lt;/code&gt; 允许我们在不同的位置决定是否要继续进行 unfold，对于每个函子 f，我们都可决定是否要进行 unfold，&lt;code class=&quot;inline&quot;&gt;apo&lt;/code&gt; 提供了一个二元选择，&lt;code class=&quot;inline&quot;&gt;Left&lt;/code&gt; 为停止递归，而 &lt;code class=&quot;inline&quot;&gt;Right&lt;/code&gt; 则继续递归。而 &lt;code class=&quot;inline&quot;&gt;futu&lt;/code&gt;，则允许我们自己构造任意多层，使得我们可以自己指定它的形状，或委托给下一层的 unfold 执行。&lt;/p&gt;&lt;p&gt;这是一种十分有趣的 unfold 模式，一个只返回 &lt;code class=&quot;inline&quot;&gt;Automatic&lt;/code&gt; 的 CV-coalgebra 会进入死循环，例如一个生产所有自然数的 unfold。所以我们可以直接了当地判定我们的 unfold 操作是否会终止。&lt;/p&gt;&lt;p&gt;可能有的读者会发现这一切有点像元胞自动机，这种感觉是对的，CV-coalgebras 描述了树型自动机，coalgebras 描述了有限状态自动机，而 R-coalgebras 描述了流式自动机，我们会运用这一点定义一个 CV-coalgebra 的例子，一个随机植物生命[1]。&lt;/p&gt;&lt;h2&gt;Futumorphism 园艺学&lt;/h2&gt;&lt;p&gt;首先我们定义一棵植物。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Plant a
  = Root a     -- 植物的根
  | Stalk a    -- 植物的枝干
  | Fork a a a -- 枝干可以分叉
  | Bloom      -- 最后植物会在顶端开花
    deriving (Show, Functor)&lt;/code&gt;&lt;p&gt;下面我们定义一下植物生长的规则（你看，与树型自动机多么相似）：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;1. 植物从地面开始生长
2. 植物的高度不超过10。
3. 植物随机的选择分叉，继续生长，或者开花。
4. 每次植物的分叉后必须其中一支为花，另外两支为枝干。&lt;/code&gt;&lt;p&gt;根据上述规则我们定义一下植物的行为：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Action
  = Flower  -- 停止生长
  | Upwards -- 生长为枝干
  | Branch  -- 生长为分叉&lt;/code&gt;&lt;p&gt;因为我们需要跟踪高度并进行随机生成，我们的 unfold 操作会在一个包含高度和随机数生成器的结构上完成：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Seed = Seed
    { height :: Int
    , rng    :: Random.StdGen
    }&lt;/code&gt;&lt;p&gt;下面我们需要定义生长函数 &lt;code class=&quot;inline&quot;&gt;grow&lt;/code&gt;，它随机生成 1 到 5 之间的整数，1 为开花，2 为分支，其余则继续生长，并使用 &lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt; 值来记录高度。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;grow :: Seed -&amp;gt; (Action, Seed, Seed)
grow seed@(Seed h rand) = (choose choice, left { height = h + 1}, right { height = h + 1})
  where (choice, _) = Random.randomR (1 :: Int, 5) rand
        (leftR, rightR) = Random.split rand
        left = Seed h leftR
        right = Seed h rightR
        choose 1 = Flower
        choose 2 = Branch
        choose _ = Upwards&lt;/code&gt;&lt;p&gt;下面我们要定义 CV-coalgebra，它接受一个 &lt;code class=&quot;inline&quot;&gt;Seed&lt;/code&gt; 并返回一个包含 &lt;code class=&quot;inline&quot;&gt;CoAttr&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;Plant&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;sow seed =
  let (action, left, right) = grow seed
  in case (action, height seed) of
    (_, 0)       -&amp;gt; Root (Automatic left)
    (_, 10)      -&amp;gt; Bloom
    (Flower, _)  -&amp;gt; Bloom
    (Upwards, _) -&amp;gt; Stalk (Automatic right)
    (Branch, _)  -&amp;gt; Fork (Manual (Stalk (Automatic left)))
                         (Manual Bloom)
                         (Manual (Stalk (Automatic right)))&lt;/code&gt;&lt;p&gt;注意这里对于 Fork 的处理，我们使用了 &lt;code class=&quot;inline&quot;&gt;Manual&lt;/code&gt; 来保证分支时的生成枝干是符合规则的，我们使用 futumorphism 在 11 行代码里就干净清晰地解决了这个问题。&lt;/p&gt;&lt;p&gt;最后是我们的 &lt;code class=&quot;inline&quot;&gt;main&lt;/code&gt; 函数，我们获取一个随机数生成器，通过 &lt;code class=&quot;inline&quot;&gt;futu&lt;/code&gt; 函数生成一个 &lt;code class=&quot;inline&quot;&gt;Term Plant&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;main :: IO ()
main = do
  rnd &amp;lt;- newStdGen
  let ourPlant :: Term Plant
      ourPlant = futu sow (Seed 0 rnd)&lt;/code&gt;&lt;p&gt;最后我们使用一个打印函数来对结果进行可视化（这里省略了实现，读者可以使用 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 来自己尝试一下，这里的渲染似乎受是否为等宽字体的影响，如果排版不太正常请见谅）：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;⚘
| ⚘    ⚘          ⚘
|⚘|    |          |
└─┘    |          |
 |     |          |      ⚘
 |  ⚘  |          |      |
 └─────┘          |   ⚘  |
    |             └──────┘
    |        ⚘      |
    └───────────────┘
             |
             _&lt;/code&gt;&lt;p&gt;最后的一点细节：正如 anamorphism 可以被 apomorphism 所表示，futumorphism 也可以表示 anamorphisms 和 apomorphism：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;ana :: (Functor f) =&amp;gt; Coalgebra f a -&amp;gt; a -&amp;gt; Term f
ana f = futu (fmap Automatic &amp;lt;&amp;lt;&amp;lt; f)

apo :: Functor f =&amp;gt; RCoalgebra f a -&amp;gt; a -&amp;gt; Term f
apo f = futu (fmap (either termToCoattr Automatic) &amp;lt;&amp;lt;&amp;lt; f)
  where termToCoattr = Manual &amp;lt;&amp;lt;&amp;lt; fmap termToCoattr &amp;lt;&amp;lt;&amp;lt; out&lt;/code&gt;&lt;h2&gt;Comonad 隆重登场&lt;/h2&gt;&lt;p&gt;上文我们介绍了 histomorphism 和 futumorphism。histomorphism 允许我们查询我们之前计算的结果，而 futumorphism 允许我们决定未来某些展开位置的形状。类似的定义不仅仅是 recursion scheme 的一种，它蕴含着某些更加基础和深远的性质。&lt;/p&gt;&lt;p&gt;实际上，我们之前 &lt;code class=&quot;inline&quot;&gt;CoAttr&lt;/code&gt; 的定义与 &lt;code class=&quot;inline&quot;&gt;Free&lt;/code&gt; monad 是等价的。而 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt; 的定义则和 &lt;code class=&quot;inline&quot;&gt;Cofree&lt;/code&gt; comonad 等价。&lt;/p&gt;&lt;p&gt;一般我们将 &lt;code class=&quot;inline&quot;&gt;Free&lt;/code&gt; （即 &lt;code class=&quot;inline&quot;&gt;CoAttr&lt;/code&gt;）表达为两个构造子：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Free f a
    = Pure a
    | Impure (f (Free f a))&lt;/code&gt;&lt;p&gt;而 &lt;code class=&quot;inline&quot;&gt;Cofree&lt;/code&gt; comonad，则被表达为一个中缀的构造函数：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Cofree f a = a :&amp;lt; (f (Cofree f a))&lt;/code&gt;&lt;p&gt;在数个 Haskell 生态系统中，&lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;para&lt;/code&gt; 就实现的方法非常类似。而 &lt;code class=&quot;inline&quot;&gt;histo&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;futu&lt;/code&gt; 则并非如此，Edward Kmett 在 &lt;a href=&quot;https://hackage.haskell.org/package/recursion-schemes&quot;&gt;recursion-schemes&lt;/a&gt; 包中使用 &lt;code class=&quot;inline&quot;&gt;Free&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Cofree&lt;/code&gt; 来协助实现（来源于 &lt;a href=&quot;https://hackage.haskell.org/package/free&quot;&gt;free&lt;/a&gt;），&lt;code class=&quot;inline&quot;&gt;fixplate&lt;/code&gt; 则使用了与 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt; 不同的定义，不是将递归部分与值类型打包在一起，而是让 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 接受一个更泛化的 &lt;code class=&quot;inline&quot;&gt;Ann&lt;/code&gt; 类型。&lt;code class=&quot;inline&quot;&gt;compdata&lt;/code&gt; 则更加复杂一点，它使用另外的 typeclass &lt;code class=&quot;inline&quot;&gt;compdata&lt;/code&gt; 来提供节点的属性，但它们的本质是一致的，每一种都是等价的。&lt;/p&gt;&lt;p&gt;free monad 和 cofree comonad 这组对偶形式，代表着函数式编程中的一组有趣的结构。宥于笔者的能力与精力，这里无法对它们进行详细的介绍。这里推荐 &lt;a href=&quot;https://twitter.com/GabrielG439&quot;&gt;Gabriel Gonzales&lt;/a&gt; 的博客 &lt;a href=&quot;http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html&quot;&gt;free monads&lt;/a&gt;，以及 &lt;a href=&quot;https://twitter.com/sigfpe&quot;&gt;Dan Piponi&lt;/a&gt; 的文章 &lt;a href=&quot;http://blog.sigfpe.com/2014/05/cofree-meets-free.html&quot;&gt;cofree comonad&lt;/a&gt;，当然还有 Oleg Kiselyov 在 free 和 freer monad 上 的&lt;a href=&quot;http://okmij.org/ftp/Computation/free-monad.html&quot;&gt;工作&lt;/a&gt;。在我们探寻递归的本质构造时，与 free monad 这一组不同来源的深刻的概念产生了联系。这正是范畴论为函数式编程中提供统一优美的框架的又一有效例证，而这本身就足够激荡人心。&lt;/p&gt;&lt;p&gt;我要感谢 Rob Rix，他是我完成文章的关键助力。 Colin Barrett，在我困扰的时候一直为我提供各种资料。以及 Manuel Chakaravarty，为我进行校对。Jeanine Adkisson，对 futumorphism 的叙述进行校对。 Greg Pfiel，Scott Vokes 和 Josh Bohde 也对草稿提出了许多有价值的建议。Mark Needham，Ian Griffiths，How Si Wei 和 Bryan Grounds，在初版的文章中找到了一些重要的缺陷。这里对他们表示深深的感谢。&lt;/p&gt;&lt;p&gt;下一章中，我们将讨论 recursion scheme 最激动人心的部分，它们服从的规律，以及 unfold 与 fold 的组合：hylomorphism 和 chronomorphism。&lt;/p&gt;&lt;h2&gt;译者的话&lt;/h2&gt;&lt;p&gt;实际上，作者在下篇文章中并未讨论 hylomorphism 和 chronomorphism，下一篇文章主要讨论了 recursion-schemes 库实践上与之前的理论的联系与区别。hylomorphism 和 chronomorphism 会在下下一篇文章中介绍。&lt;/p&gt;&lt;p&gt;抱歉从上一篇更新到现在中间拖了如此久的时间，中间读者如果有哪些知识遗忘了可以看一下之前文章回顾一下。拖更一方面是工作比较忙，另一方面也是在考虑之后专栏的坑要怎么挖，目前终于找到了一些头绪，目前考虑除了一些纯概念上的介绍，也穿插一些偏工程上的文章，毕竟这还是一个方向编程领域的专栏。&lt;/p&gt;&lt;p&gt;如果有什么意见和建议欢迎跟我交流，感谢大家的耐心阅读！&lt;/p&gt;&lt;p&gt;[1]: 一个随机植物需要一个随机“种子”。&lt;/p&gt;</description>
<author>禾木旁</author>
<guid isPermaLink="false">2018-11-14-49814311</guid>
<pubDate>Wed, 14 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>CPython 源码分析 - 0</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-11-12-49451546.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49451546&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-37fb5c99681f9c8f08d017ab823a0f5d_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;之前和几个 py 在做一个的 Python 编译器的前端项目 —— &lt;a href=&quot;https://github.com/Xython/YAPyPy&quot;&gt;XPython/YAPyPy&lt;/a&gt;（目前还在施工之中，但是 codegen 都做好了，上次跑了一个 sklearn 的测试脚本也都能跑通了），在做的期间了解了很多和 py、cpy 相关实现方式的知识。感觉 CPython 作为一个大型 C 项目结构和功能还是非常清晰的，所以说打算索性就把 CPython 的代码都看一遍好了。&lt;br&gt;&lt;br&gt;相关的资料中 《Python源码剖析》据说不错，但是书中的 py 版本有点老，不过读者也可以互为参考。还有就是这个系列里面的文字基本都是看的时候随手写的，可能写的也不像是系统的分析更像是阅读笔记，诸位聊为一笑。&lt;/blockquote&gt;&lt;h2&gt;C-Level PyObject&lt;/h2&gt;&lt;h2&gt;PyObject_*&lt;/h2&gt;&lt;p&gt;阅读 CPython 的源码可以先从 Python 其中相较重要的对象机制上进行分析，首先从 &lt;code class=&quot;inline&quot;&gt;Include&lt;/code&gt; 部分的源码进行看起，其中 PyObject 的对象的 c-level 层的定义都在这个文件夹之中，先从 &lt;code class=&quot;inline&quot;&gt;object.h&lt;/code&gt; 的源代码进行分析：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/* Nothing is actually declared to be a PyObject, but every pointer to
 * a Python object can be cast to a PyObject*.  This is inheritance built
 * by hand.  Similarly every pointer to a variable-size Python object can,
 * in addition, be cast to PyVarObject*.
 */
typedef struct _object {
    _PyObject_HEAD_EXTRA
    Py_ssize_t ob_refcnt;
    struct _typeobject *ob_type;
} PyObject;
​
typedef struct {
    PyObject ob_base;
    Py_ssize_t ob_size; /* Number of items in variable part */
} PyVarObject;&lt;/code&gt;&lt;p&gt;先来看上述的两个结构体的定义，CPython 在 C 源码之中实现了一套多态系统，PyObject 不存储 Py 对象之中的实际的数据，但是所有的 Object 在 C-Level 都能被转换为一个 PyObject。从这个结构体中可以看出其中主要包含两个 &lt;code class=&quot;inline&quot;&gt;field&lt;/code&gt; ，&lt;code class=&quot;inline&quot;&gt;ob_refcnt&lt;/code&gt; 保存着对象的引用计数，&lt;code class=&quot;inline&quot;&gt;ob_type&lt;/code&gt;  存储着 PyObject 的类型对象，类型对象之中提供了更多的信息。&lt;/p&gt;&lt;p&gt;其中还包含一个 Marco &lt;code class=&quot;inline&quot;&gt;_PyObject_HEAD_EXTRA&lt;/code&gt; 这个宏主要是在 Debug 模式会被用到，其中将所有 heap 中对象都连接到了一个链上，用于调试方便：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define _PyObject_HEAD_EXTRA            \
    struct _object *_ob_next;           \
    struct _object *_ob_prev;
​
#define _PyObject_EXTRA_INIT 0, 0,&lt;/code&gt;&lt;p&gt;而在正常运行的模式之下，这两个宏全都是空的。除了 PyObject 之外，PyVarObject 代表了一类 Py 之中的变长对象的实现方式，其中除了包含一个 PyObject 作为 header 之外还包含了一个 ob_size 代表实际的存储空间大小。通过同样的 Header 能够让所有的 PyObject 的子类型有相似的内存布局，在获取一些公有的参数能获取很多便利，并且在 cast 的时候也很方便。&lt;/p&gt;&lt;p&gt;在看过这些类型的基类（说基类并不严谨，或者说泛化对象？）的实现之后，可以来看 py 支持的具体类型的实现方式了，2.x 和 3.x 在这方面有一部分区别，2.x 之中包含独立的 &lt;code class=&quot;inline&quot;&gt;intobject.h&lt;/code&gt; 实现，在 3.x 之中全部是用来 &lt;code class=&quot;inline&quot;&gt;longobject.h&lt;/code&gt; 来实现了。具体 integer 的数据范围则是由 sys.maxsize 来控制的。这里可以看 &lt;code class=&quot;inline&quot;&gt;longintrepr.h&lt;/code&gt; 的具体实现：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/* Long integer representation.
   The absolute value of a number is equal to
        SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)
   Negative numbers are represented with ob_size &amp;lt; 0;
   zero is represented by ob_size == 0.
   In a normalized number, ob_digit[abs(ob_size)-1] (the most significant
   digit) is never zero.  Also, in all cases, for all valid i,
        0 &amp;lt;= ob_digit[i] &amp;lt;= MASK.
   The allocation function takes care of allocating extra memory
   so that ob_digit[0] ... ob_digit[abs(ob_size)-1] are actually available.
​
   CAUTION:  Generic code manipulating subtypes of PyVarObject has to
   aware that ints abuse  ob_size&#39;s sign bit.
*/
struct _longobject {
    PyObject_VAR_HEAD
    digit ob_digit[1];
};&lt;/code&gt;&lt;p&gt;longobject 使用了 ob_digit[] 作为实际的数据的数组，用 ob_size 来表示数据的正负关系，这个实现得非常简单其中还包含一个 PyObject_VAR_HEAD 的宏，其实就是一个 PyVarObject 来作为 header 。&lt;code class=&quot;inline&quot;&gt;longobject.h&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;longinterpr.h&lt;/code&gt; 的很多方法都是通过宏包装的，这样可以直接通过很多对 PyObject 的方法来提供子类型的分析。&lt;/p&gt;&lt;blockquote&gt;这里要感叹一下自己写大型 C 代码项目的功力之浅。一直没什么机会编写大型的 C 项目，看着 CPython 构建的类型系统和 redis 构建的很多精巧的数据结构有种望洋兴叹的构建。&lt;/blockquote&gt;&lt;p&gt;可以再来分析一个简单的 bool 实现在 &lt;code class=&quot;inline&quot;&gt;boolobject.h&lt;/code&gt; 之中：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;PyAPI_DATA(PyTypeObject) PyBool_Type;
​
#define PyBool_Check(x) (Py_TYPE(x) == &amp;amp;PyBool_Type)
​
/* Py_False and Py_True are the only two bools in existence.
Don&#39;t forget to apply Py_INCREF() when returning either!!! */
​
/* Don&#39;t use these directly */
PyAPI_DATA(struct _longobject) _Py_FalseStruct, _Py_TrueStruct;
​
/* Use these macros */
#define Py_False ((PyObject *) &amp;amp;_Py_FalseStruct)
#define Py_True ((PyObject *) &amp;amp;_Py_TrueStruct)
/* Macros for returning Py_True or Py_False, respectively */
#define Py_RETURN_TRUE return Py_INCREF(Py_True), Py_True
#define Py_RETURN_FALSE return Py_INCREF(Py_False), Py_False&lt;/code&gt;&lt;p&gt;这里直接使用了两个 longobject 来代表 True of False，每次返回的对象之前都要增加引用计数。&lt;/p&gt;&lt;h2&gt;PyTypeObject 类型对象&lt;/h2&gt;&lt;p&gt;在 Python 的 Doc 之中的 C-api 部分提到了其中的 api 有两种层次的支持：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Abstract Objects Layer&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/object.html&quot;&gt;Object Protocol&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/number.html&quot;&gt;Number Protocol&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/sequence.html&quot;&gt;Sequence Protocol&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/mapping.html&quot;&gt;Mapping Protocol&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/iter.html&quot;&gt;Iterator Protocol&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/objbuffer.html&quot;&gt;Old Buffer Protocol&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Concrete Objects Layer&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/concrete.html#fundamental-objects&quot;&gt;Fundamental Objects&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/concrete.html#numeric-objects&quot;&gt;Numeric Objects&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/concrete.html#sequence-objects&quot;&gt;Sequence Objects&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/concrete.html#mapping-objects&quot;&gt;Mapping Objects&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/concrete.html#other-objects&quot;&gt;Other Objects&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以看出 AOL 支持的层次是可以对某种具体特性的接口提供了一套 API ，具有这种特性的 Object 都口以使用这类方法。而 Concrete Objects Layer 所提供的方法就会更为细化，会细化到某个具体的内建类型上，要先 check type  才能使用。&lt;/p&gt;&lt;p&gt;而这些 PyObject 类型的实现都依赖于结构体中的 &lt;code class=&quot;inline&quot;&gt;_typeobject&lt;/code&gt; PyTypeObject 对象的实现，在 &lt;code class=&quot;inline&quot;&gt;object.h&lt;/code&gt; 下可以看到这样的定义：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#ifdef Py_LIMITED_API
typedef struct _typeobject PyTypeObject; /* opaque */
#else
typedef struct _typeobject {
    PyObject_VAR_HEAD
    const char *tp_name; /* For printing, in format &quot;&amp;lt;module&amp;gt;.&amp;lt;name&amp;gt;&quot; */
    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */
​
    /* Methods to implement standard operations */
​
    destructor tp_dealloc;
    printfunc tp_print;
    getattrfunc tp_getattr;
    setattrfunc tp_setattr;
    ...&lt;/code&gt;&lt;p&gt;这里节选了部分的代码，可以看到其实 PyTypeObject 本身也是一个 PyVarObject 对象。其中 &lt;code class=&quot;inline&quot;&gt;tp_name&lt;/code&gt; 保存 format 格式的定义，&lt;code class=&quot;inline&quot;&gt;tp_basicsize, tp_itemsize&lt;/code&gt; 记录这个对象应该要使用多少的内存空间，在 &lt;code class=&quot;inline&quot;&gt;tp_new&lt;/code&gt; 的流程之中会被用到，而下面的这几个函数指针则为 PyObject 提供了一些标准操作符的支持。值得留意的方法还有下面这些：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;    /* Method suites for standard classes */
    PyNumberMethods *tp_as_number;
    PySequenceMethods *tp_as_sequence;
    PyMappingMethods *tp_as_mapping;
    ...
    initproc tp_init;
    allocfunc tp_alloc;
    newfunc tp_new;
    ...&lt;/code&gt;&lt;p&gt;这其中的 init alloc new 方法都和 PyObject 实际的创建有关系，而上面的 tp_as_number，&lt;code class=&quot;inline&quot;&gt;tp_as_squence&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;tp_as_mapping&lt;/code&gt; 则代表了三种主要的方法族，这三个主要的方法族提供了一系列的方法，能够让一个 object 支持作为一个数字、序列和字典的功能。PyTypeObject 的基本实现对象都在 &lt;code class=&quot;inline&quot;&gt;typeobject.h&lt;/code&gt; 文件之中：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;PyTypeObject PyType_Type = {
    PyVarObject_HEAD_INIT(&amp;amp;PyType_Type, 0)
    &quot;type&quot;,                                     /* tp_name */
    sizeof(PyHeapTypeObject),                   /* tp_basicsize */
    sizeof(PyMemberDef),                        /* tp_itemsize */
    (destructor)type_dealloc,                   /* tp_dealloc */
    0,                                          /* tp_print */
    0,                                          /* tp_getattr */
    0,                                          /* tp_setattr */
    0,                                          /* tp_reserved */
    ...
}
​
...
​
PyTypeObject PyBaseObject_Type = {
    PyVarObject_HEAD_INIT(&amp;amp;PyType_Type, 0)
    &quot;object&quot;,                                   /* tp_name */
    sizeof(PyObject),                           /* tp_basicsize */
    0,                                          /* tp_itemsize */
    object_dealloc,                             /* tp_dealloc */
    0,                                          /* tp_print */
    0,                                          /* tp_getattr */
    0,                                          /* tp_setattr */
    0,                                          /* tp_reserved */
    object_repr,                                /* tp_repr */
    0,                                          /* tp_as_number */
    0,                                          /* tp_as_sequence */
    0,              
    ...
}&lt;/code&gt;&lt;p&gt;这里还是可以看到两个这样的定义，其中一个是 &lt;code class=&quot;inline&quot;&gt;PyType_Type&lt;/code&gt; 另一个是 &lt;code class=&quot;inline&quot;&gt;PyBaseObject_Type&lt;/code&gt; 仔细观察两者传入的第一个参数，可以看到两者都传入了 PyType_Type 作为 Header，其实这两者的关系比较类似 PyObject 和 PyVarObject 之间的关系。一个是作为 Header 的基类实现，另一个再次之上构建了一套对构建对象的实现。PyType_Type 本身就像 PyObject 一样作为了一层的 Header 来标识了此 PyObject 对象为一个类型对象。&lt;/p&gt;&lt;p&gt;在据此我们可以来看一下子类型的实现，在 &lt;code class=&quot;inline&quot;&gt;bool_object.c&lt;/code&gt; 的文件之中包含 bool 类型的类型信息：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/* The type object for bool.  Note that this cannot be subclassed! */
PyTypeObject PyBool_Type = {
    PyVarObject_HEAD_INIT(&amp;amp;PyType_Type, 0)
    &quot;bool&quot;,
    sizeof(struct _longobject),
    ...
    bool_repr,                                  /* tp_repr */
    &amp;amp;bool_as_number,                            /* tp_as_number */
    0,                                          /* tp_as_sequence */
    0,                                          /* tp_as_mapping */
    bool_repr,                                  /* tp_str */
    Py_TPFLAGS_DEFAULT,                         /* tp_flags */
    bool_doc,                                   /* tp_doc */
    ...
    &amp;amp;PyLong_Type,                               /* tp_base */
    ...
    bool_new,                                   /* tp_new */
};&lt;/code&gt;&lt;p&gt;可以看出具体的初始化 bool 类型的函数指针、bool 类型的标识字串，通过的 as_number 函数指针都在这种子类型之中进行了提供。&lt;/p&gt;&lt;p&gt;这里注意到很多 c 代码的之中都有类似如下的注释开头：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/*[clinic input]
class bytearray &quot;PyByteArrayObject *&quot; &quot;&amp;amp;PyByteArray_Type&quot;
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=5535b77c37a119e0]*/
​
char _PyByteArray_empty_string[] = &quot;&quot;;&lt;/code&gt;&lt;p&gt;这里去了解了一下，这是一个叫 Clinic 的 DSL 语言工具，写在 C 的注释里用来生成和管理 C 与 Python 的接口函数的类型、签名、文档等信息。&lt;/p&gt;&lt;blockquote&gt;Clinic 的相关信息：&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/3/howto/clinic.html#argument-clinic-how-to&quot;&gt;Argument Clinic How-To&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-0436/#abstract&quot;&gt;PEP 436 -- The Argument Clinic DSL&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;PyLongObject&lt;/h2&gt;&lt;p&gt;实际到某种 PyObject 的具体实现方式之中还都有一些独特的优化手段。老版本有单独的 PyIntObject 的时候，是有独立的小整数缓存池和大整数链共享内存的，不过 3.x 把 int 归到了 PyLongObject 之中大整数的共享内存机制似乎已经被删除掉了，这里还能看得到小整数对象的共享逻辑：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define NSMALLPOSINTS           257
#endif
#ifndef NSMALLNEGINTS
#define NSMALLNEGINTS           5
#endif
​
_Py_IDENTIFIER(little);
_Py_IDENTIFIER(big);
​
/* convert a PyLong of size 1, 0 or -1 to an sdigit */
#define MEDIUM_VALUE(x) (assert(-1 &amp;lt;= Py_SIZE(x) &amp;amp;&amp;amp; Py_SIZE(x) &amp;lt;= 1),   \
         Py_SIZE(x) &amp;lt; 0 ? -(sdigit)(x)-&amp;gt;ob_digit[0] :   \
             (Py_SIZE(x) == 0 ? (sdigit)0 :                             \
              (sdigit)(x)-&amp;gt;ob_digit[0]))
​
PyObject *_PyLong_Zero = NULL;
PyObject *_PyLong_One = NULL;
​
#if NSMALLNEGINTS + NSMALLPOSINTS &amp;gt; 0
/* Small integers are preallocated in this array so that they
   can be shared.
   The integers that are preallocated are those in the range
   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).
*/
static PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];
#ifdef COUNT_ALLOCS
Py_ssize_t _Py_quick_int_allocs, _Py_quick_neg_int_allocs;
#endif
​
static PyObject *
get_small_int(sdigit ival)
{
    PyObject *v;
    assert(-NSMALLNEGINTS &amp;lt;= ival &amp;amp;&amp;amp; ival &amp;lt; NSMALLPOSINTS);
    v = (PyObject *)&amp;amp;small_ints[ival + NSMALLNEGINTS];
    Py_INCREF(v);
#ifdef COUNT_ALLOCS
    if (ival &amp;gt;= 0)
        _Py_quick_int_allocs++;
    else
        _Py_quick_neg_int_allocs++;
#endif
    return v;&lt;/code&gt;&lt;p&gt;默认保存了 -5 ~ 257 之中的小整数，在模块 init 的时候初始化整个整数池，当数据范围在这个范围之内的时候就直接使用缓存池中的 PyObject 并增加引用计数就好了。大部分这种 PyObject 的内建类型都提供了多重方法去创建一个 obj，比如 PyLongObject 就包括 FromLong、FromString 等几种创建方法。还有就是 Long （包含 Int）类型的 PyObject 本质上是一种不可变的对象，可以注意到其他的加减乘除的方法返回的都是一个新的对象而不是之前的对象。&lt;/p&gt;&lt;h2&gt;PyBytesObject、PyUnicodeObject&lt;/h2&gt;&lt;p&gt;接着可以来分析 &lt;code class=&quot;inline&quot;&gt;PyStringObject&lt;/code&gt; 的具体实现方式，在 &lt;code class=&quot;inline&quot;&gt;bytesobject.h&lt;/code&gt; 文件之中：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/*
Type PyBytesObject represents a character string.  An extra zero byte is
reserved at the end to ensure it is zero-terminated, but a size is
present so strings with null bytes in them can be represented.  This
is an immutable object type.
​
There are functions to create new string objects, to test
an object for string-ness, and to get the
string value.  The latter function returns a null pointer
if the object is not of the proper type.
There is a variant that takes an explicit size as well as a
variant that assumes a zero-terminated string.  Note that none of the
functions should be applied to nil objects.
*/
​
/* Caching the hash (ob_shash) saves recalculation of a string&#39;s hash value.
   This significantly speeds up dict lookups. */
​
#ifndef Py_LIMITED_API
typedef struct {
    PyObject_VAR_HEAD
    Py_hash_t ob_shash;
    char ob_sval[1];
​
    /* Invariants:
     *     ob_sval contains space for &#39;ob_size+1&#39; elements.
     *     ob_sval[ob_size] == 0.
     *     ob_shash is the hash of the string or -1 if not computed yet.
     */
} PyBytesObject;
#endif&lt;/code&gt;&lt;p&gt;在 3.x 之后取消了 &lt;code class=&quot;inline&quot;&gt;stringobject.h&lt;/code&gt; 一系列相关的 api 和接口，重新修改了 bytes 和 str 的实现，其中 3.x 之中的 bytes 仅保存字符编码，而 str 则承担了之前 unicode 类型的功能。这里的 PyBytesObject 就对应之前的 PyStringObject 的实现。这个结构看起来非常的熟悉了，包含一个 PyObject 的 header ，其中主要存储字符串的位置是 &lt;code class=&quot;inline&quot;&gt;ob_sval&lt;/code&gt; ，另外还包含一个 &lt;code class=&quot;inline&quot;&gt;ob_shash&lt;/code&gt; 来存储 String 的 hash 信息。另外就正如之前介绍 PyVarObject 的结构之中的 &lt;code class=&quot;inline&quot;&gt;ob_size&lt;/code&gt; 之中存储了字符串的所占空间。&lt;/p&gt;&lt;blockquote&gt;基本上在大型的 C 项目里要是想要使用动态的 string ，都要自己搞一套这样的实现。之前看 redis 的代码实现之中也包含这样的实现。否则不用 chars 来存储的话仍会受限于 c-style string 的 &quot;\0&quot; 的限制。&lt;/blockquote&gt;&lt;p&gt;这里来看一下 PyString 创建的一些逻辑，挑一个最简单的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;PyObject *
PyBytes_FromString(const char *str) // 接受一个 c style 的字符串指针
{
    size_t size;
    PyBytesObject *op;
    assert(str != NULL);
    size = strlen(str);
    if (size &amp;gt; PY_SSIZE_T_MAX - PyBytesObject_SIZE) {
        PyErr_SetString(PyExc_OverflowError,
            &quot;byte string is too long&quot;);
        return NULL;
    }
    if (size == 0 &amp;amp;&amp;amp; (op = nullstring) != NULL) {
#ifdef COUNT_ALLOCS
        _Py_null_strings++; // 增加引用计数
#endif
        Py_INCREF(op);
        return (PyObject *)op; // null 的 PyBytesObject 的返回结果
    }
    if (size == 1 &amp;amp;&amp;amp; (op = characters[*str &amp;amp; UCHAR_MAX]) != NULL) {
#ifdef COUNT_ALLOCS
        _Py_one_strings++;
#endif
        Py_INCREF(op);
        return (PyObject *)op; // 
    }
    // 创建 PyBytesObject 对象 申请空间、增加引用计数。
    /* Inline PyObject_NewVar */
    op = (PyBytesObject *)PyObject_MALLOC(PyBytesObject_SIZE + size);
    if (op == NULL)
        return PyErr_NoMemory();
    (void)PyObject_INIT_VAR((PyVarObject *)op, &amp;amp;PyBytes_Type, size);
    op-&amp;gt;ob_shash = -1;
    memcpy(op-&amp;gt;ob_sval, str, size+1);
    /* share short strings */
    if (size == 0) {
        nullstring = op;
        Py_INCREF(op);
    } else if (size == 1) {
        characters[*str &amp;amp; UCHAR_MAX] = op;
        Py_INCREF(op);
    }
    return (PyObject *) op;
}&lt;/code&gt;&lt;p&gt;PyBytesObject 之中也同样包括共享池的优化手段，这就是之前在生成对象时判断 size 0、1 的关系：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;static PyBytesObject *characters[UCHAR_MAX + 1]; // 单字符的缓存池
static PyBytesObject *nullstring;  // 空字串对象&lt;/code&gt;&lt;p&gt;在 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0393/#rationale&quot;&gt;pep-393&lt;/a&gt; 之后 &lt;code class=&quot;inline&quot;&gt;str&lt;/code&gt; 接管了之前的 &lt;code class=&quot;inline&quot;&gt;unicode&lt;/code&gt; 的相关内容，并且更新为了一种层级关系：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;typedef struct {
  PyObject_HEAD
  Py_ssize_t length;
  Py_hash_t hash;
  struct {
      unsigned int interned:2;
      unsigned int kind:2;
      unsigned int compact:1;
      unsigned int ascii:1;
      unsigned int ready:1;
  } state;
  wchar_t *wstr;
} PyASCIIObject;
​
typedef struct {
  PyASCIIObject _base;
  Py_ssize_t utf8_length;
  char *utf8;
  Py_ssize_t wstr_length;
} PyCompactUnicodeObject;
​
typedef struct {
  PyCompactUnicodeObject _base;
  union {
      void *any;
      Py_UCS1 *latin1;
      Py_UCS2 *ucs2;
      Py_UCS4 *ucs4;
  } data;
} PyUnicodeObject;&lt;/code&gt;&lt;p&gt;这种层级关系在我们使用不同范围的初始化字段的时候会被初始化。而之前 str 相关的有优化手段也在 unicode 之中实现了：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;static PyObject *unicode_latin1[256] = {NULL};&lt;/code&gt;&lt;p&gt;看到了熟悉的东西在 str 这部分之中也包含一个字符池，在一定数据范围的字符都会进行复用。除此之外 str 还包含另一种 intern 的复用逻辑，其中包含了一个 internal state 状态，状态的有以下集中情况：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define SSTATE_NOT_INTERNED 0             // 未共享
#define SSTATE_INTERNED_MORTAL 1          // 共享 但是不增加引用计数
#define SSTATE_INTERNED_IMMORTAL 2        // 永久 不会被销毁&lt;/code&gt;&lt;p&gt;对 interned-state 状态的修改和代用 PyUnicode_Interned&lt;i&gt;* 系列，通过 PyUnicode&lt;/i&gt;* 的方法提供了优化的手段，在方法 &lt;code class=&quot;inline&quot;&gt;unicodeobject.c#PyUnicode_InternInPlace&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;    [unicodeobject.c]
    PyObject *PyUnicode_InternFromString(const char *cp) {
        PyObject *s = PyUnicode_FromString(cp);
        if (s == NULL)
            return NULL;
        PyUnicode_InternInPlace(&amp;amp;s);
        return s;
    }
​
    // PyUnicode_InternInPlace
    ...
    Py_ALLOW_RECURSION
    t = PyDict_SetDefault(interned, s, s);
    Py_END_ALLOW_RECURSION
    if (t == NULL) {
        PyErr_Clear();
        return;
    }
    if (t != s) {
        Py_INCREF(t);
        Py_SETREF(*p, t);
        return;
    }
    /* The two references in interned are not counted by refcnt.
       The deallocator will take care of this */
    Py_REFCNT(s) -= 2;
    _PyUnicode_STATE(s).interned = SSTATE_INTERNED_MORTAL;&lt;/code&gt;&lt;p&gt;从 &lt;code class=&quot;inline&quot;&gt;PyUnicode_InternFromString&lt;/code&gt; 方法之中可见，Py 并不会在创建 PyUnicodeObject 的时候之前检查是否已经创建这个 Object，而是会先创建出一个临时变量的 PyObject 。然后在 &lt;code class=&quot;inline&quot;&gt;PyUnicode_InternInPlace&lt;/code&gt; 之中 check 从 &lt;code class=&quot;inline&quot;&gt;PyDict_SetDefault&lt;/code&gt; 返回的函数指针（缓存在 interned 这个字典之中），如果相同表示已经进行 interned 存储过了，就会增加引用。&lt;/p&gt;&lt;p&gt;这个地方的逻辑有点复杂，这里对 interned 的讨论不过就是有两种情况，我们可以分开来讨论：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;插入新的 PyUnicodeObject 的时候：&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;text&quot;&gt;// s 进入 dict 之后 ref 会 + 2
t = PyDict_SetDefault(interned, s, s);
/* The two references in interned are not counted by refcnt.
The deallocator will take care of this */
// 第一次插入减少被 dict 持有的 ref 
Py_REFCNT(s) -= 2;
_PyUnicode_STATE(s).interned = SSTATE_INTERNED_MORTAL;&lt;/code&gt;&lt;p&gt;因为 interned string 被放进 dict 之后 key value 都会增加一次 ref ，因此在之后会调整状态为 &lt;code class=&quot;inline&quot;&gt;SSTATE_INTERNED_MORTAL&lt;/code&gt; 之后并且补充 ref - 2。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;插入已有的 PyUnicodeObject 的时候：&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;text&quot;&gt;// 已有不会在内部 ref 增加 (里面查到了 value_attr )
t = PyDict_SetDefault(interned, s, s);
// 查到了已有的 PyObject 因此指针地址不同 
if (t != s) {
    Py_INCREF(t);
    Py_SETREF(*p, t);
    return;
}&lt;/code&gt;&lt;p&gt;这里真的增加了 t 的 ref，因为是被复用有一个增加的引用计数，把指针 p 指向的临时变量销毁掉，然后把 t （cache 的引用）填充进去。str 的 concat 和 join 开销对比也可以在 &lt;code class=&quot;inline&quot;&gt;unicodeobject.c&lt;/code&gt; 之中可以看出：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;// PyUnicode_Join
    items = PySequence_Fast_ITEMS(fseq);
    seqlen = PySequence_Fast_GET_SIZE(fseq);
    res = _PyUnicode_JoinArray(separator, items, seqlen);
​
// PyUnicode_Concat
    /* Shortcuts */
    if (left == unicode_empty)
        return PyUnicode_FromObject(right);
    if (right == unicode_empty)
        return PyUnicode_FromObject(left);
​
    left_len = PyUnicode_GET_LENGTH(left);
    right_len = PyUnicode_GET_LENGTH(right);
    if (left_len &amp;gt; PY_SSIZE_T_MAX - right_len) {
        PyErr_SetString(PyExc_OverflowError,
                        &quot;strings are too large to concat&quot;);
        return NULL;
    }
    new_len = left_len + right_len;
​
    maxchar = PyUnicode_MAX_CHAR_VALUE(left);
    maxchar2 = PyUnicode_MAX_CHAR_VALUE(right);
    maxchar = Py_MAX(maxchar, maxchar2);
​
    /* Concat the two Unicode strings */
    result = PyUnicode_New(new_len, maxchar);
    if (result == NULL)
        return NULL;
    _PyUnicode_FastCopyCharacters(result, 0, left, 0, left_len);
    _PyUnicode_FastCopyCharacters(result, left_len, right, 0, right_len);&lt;/code&gt;&lt;p&gt;从这里可以看出，在使用 join 功能的时候会算出 sequence 的长度一次申请内存进行一次拷贝，而 concat 每次连接都会进行一次内存申请、两次内存拷贝，因此当连接的次数多了的时候，性能就会有很大的下降。&lt;/p&gt;&lt;h2&gt;To be continue...&lt;/h2&gt;</description>
<author>lfkdsk</author>
<guid isPermaLink="false">2018-11-12-49451546</guid>
<pubDate>Mon, 12 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>把类型类用 record 实现出来</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-11-08-48920962.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/48920962&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f54476731ef15b5fb836dc587b86c555_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;推荐阅读&lt;a href=&quot;http://ice1000.org/lagda/Typeclassopedia.html&quot;&gt;我的博客&lt;/a&gt;的版本，这样你可以看到代码高亮，以及点击代码里的变量、类型以跳转到定义（没错，他们都是链接）。&lt;/p&gt;&lt;p&gt;前排提醒：你或许需要一个&lt;a href=&quot;https://baike.baidu.com/item/%E6%B8%B8%E6%A0%87%E5%8D%A1%E5%B0%BA&quot;&gt;游标卡尺&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;这是一个类型类教程，尝试使用我改进过的 Literate Agda 后端生成网页 （如果想使用我改进的功能，请拉取 master 分支的 Agda 编译器然后 &lt;code class=&quot;inline&quot;&gt;cabal install&lt;/code&gt; 编译。 我加的功能的使用说明见&lt;a href=&quot;https://agda.readthedocs.io/en/latest/tools/generating-html.html&quot;&gt;这个网页&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;为了让我能用我的手机正常显示自己的文章里的字符，本文会尽量使用非 Unicode 定义。&lt;/p&gt;&lt;p&gt;首先我们定义模块：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;{-# OPTIONS --no-unicode #-}
{-# OPTIONS --without-K  #-}
module Typeclassopedia where&lt;/code&gt;&lt;p&gt;为了强迫自己事先熟悉 HoTT 的 Agda 实现， 我已经开始全面使用 &lt;a href=&quot;https://github.com/HoTT/HoTT-Agda/tree/master/core/lib&quot;&gt;HoTT-Agda&lt;/a&gt; 作为编程基础库（和标准库基本一致）。&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;open import lib.Base&lt;/code&gt;&lt;p&gt;由于 &lt;code class=&quot;inline&quot;&gt;lib.types.Bool&lt;/code&gt; 依赖的包比较多（而且 Emacs 看不懂基于 dependent product 的 &lt;code class=&quot;inline&quot;&gt;Bool&lt;/code&gt;）， 就自己写一个，加上内置定义：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;data Bool : Type0 where false true : Bool

{-# BUILTIN BOOL  Bool  #-}
{-# BUILTIN FALSE false #-}
{-# BUILTIN TRUE  true  #-}&lt;/code&gt;&lt;p&gt;然后常用的函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;not : Bool -&amp;gt; Bool
not true  = false
not false = true&lt;/code&gt;&lt;p&gt;比较自然数大小：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;natEq : Nat -&amp;gt; Nat -&amp;gt; Bool
natEq  O     O    = true
natEq (S _)  O    = false
natEq  O    (S _) = false
natEq (S n) (S m) = natEq n m
{-# BUILTIN NATEQUALS natEq #-}&lt;/code&gt;&lt;p&gt;不熟悉这个库的读者不必担心，本文用到的定义都属于看名字就知道的那种 （基本上在标准库或者内置库里面都有一个名字一样的，另外 &lt;code class=&quot;inline&quot;&gt;idp&lt;/code&gt; 是 &lt;code class=&quot;inline&quot;&gt;refl&lt;/code&gt;）。&lt;/p&gt;&lt;p&gt;泛化一个阶变量（Girard 悖论你好），免得到处写隐式参数：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;variable i : ULevel&lt;/code&gt;&lt;p&gt;有个函数 &lt;code class=&quot;inline&quot;&gt;of-type&lt;/code&gt; 和 Idris 的函数 &lt;code class=&quot;inline&quot;&gt;the&lt;/code&gt; 语义一致：先传入一个类型，再传入这个类型的实例:&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ : (A : Type i) (u : A) -&amp;gt; A
_ = of-type&lt;/code&gt;&lt;p&gt;HoTT-Agda 提供了这种便利的语法来间接使用 &lt;code class=&quot;inline&quot;&gt;of-type&lt;/code&gt;:&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = 233 :&amp;gt; Nat
_ = lzero :&amp;gt; ULevel
_ = unit :&amp;gt; Unit
_ = idp :&amp;gt; (O == O)&lt;/code&gt;&lt;h2&gt;实例参数&lt;/h2&gt;&lt;code lang=&quot;agda&quot;&gt;module InstanceArgument where
&lt;/code&gt;&lt;p&gt;注：我的第一册书里译作&lt;i&gt;即时&lt;/i&gt;参数，因为在英语中这个名字是一语双关的（ 因为查找实例使用的算法比较快，所以 instance 此处有&lt;i&gt;即时&lt;/i&gt;之意。 但这个特性又用于查找类型实例，所以 instance 又有&lt;i&gt;实例&lt;/i&gt;之意）， 现在决定改为取相对来说更内涵的含义。&lt;/p&gt;&lt;p&gt;实例参数类似隐式参数，只不过它们使用两层大括号：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;postulate f : {{ x : Nat }} -&amp;gt; Nat
&lt;/code&gt;&lt;p&gt;手动传值也是两层：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = f {{ 233 }} :&amp;gt; Nat
&lt;/code&gt;&lt;p&gt;隐式参数一般是通过后面的参数往前推导得到的，实例参数则使用另一种方式： &lt;b&gt;直接在上下文里查找变量。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;听起来很暴力，但其实也没有那么暴力啦，只有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;放在 &lt;code class=&quot;inline&quot;&gt;instance&lt;/code&gt; 代码块里的定义&lt;/li&gt;&lt;li&gt;局部变量&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;才属于被查找的对象，我们称之为实例。 Agda wiki 说构造器也会，但目前看编译器的行为应该是不允许了。&lt;/p&gt;&lt;p&gt;放在 &lt;code class=&quot;inline&quot;&gt;instance&lt;/code&gt; 代码块里的定义的例子：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;-- instance 代码块定义
  instance rua : Nat
           rua = 233
  -- 喏，自动传入啦
  _ = f :&amp;gt; Nat
&lt;/code&gt;&lt;p&gt;局部变量：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = let jojo = O in f :&amp;gt; Nat
  _ = f :&amp;gt; Nat where jojo = O
&lt;/code&gt;&lt;p&gt;如果作用域内有两个满足需求的实例，就会报错。&lt;/p&gt;&lt;h2&gt;依赖记录&lt;/h2&gt;&lt;code lang=&quot;agda&quot;&gt;module DependentRecord where
&lt;/code&gt;&lt;p&gt;这里&lt;i&gt;依赖&lt;/i&gt;是形容词，不是动词。英文原文是 dependent record ， 表示后面成员的类型可以依赖前面成员的 &lt;code class=&quot;inline&quot;&gt;record&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;Haskell 中的类型类使用 &lt;code class=&quot;inline&quot;&gt;class&lt;/code&gt; 关键字定义，比如 &lt;code class=&quot;inline&quot;&gt;Eq&lt;/code&gt; 类型类：&lt;/p&gt;&lt;p&gt;class Eq t where   (==) :: t -&amp;gt; t -&amp;gt; Bool&lt;/p&gt;&lt;p&gt;立即使用 &lt;code class=&quot;inline&quot;&gt;record&lt;/code&gt; 表达：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;record Eq {a} (A : Type a) : Type a where
    field _===_ : A -&amp;gt; A -&amp;gt; Bool
    infixl 32 _===_
&lt;/code&gt;&lt;p&gt;由于 Agda 的 &lt;code class=&quot;inline&quot;&gt;record&lt;/code&gt; 就是带参数的 &lt;code class=&quot;inline&quot;&gt;module&lt;/code&gt; ，我们可以把它的成员定义 &lt;code class=&quot;inline&quot;&gt;open&lt;/code&gt; 出来：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;module EqAsExplicitArgument where
    open Eq
&lt;/code&gt;&lt;p&gt;可以简单地看出，被 &lt;code class=&quot;inline&quot;&gt;open&lt;/code&gt; 出来的 &lt;code class=&quot;inline&quot;&gt;_===_&lt;/code&gt; 的类型：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = _===_ :&amp;gt; (Eq Nat -&amp;gt; Nat -&amp;gt; Nat -&amp;gt; Bool)
&lt;/code&gt;&lt;p&gt;要使用的话，先搞个实例，然后 Haskell 里当成 constraint 用的情况改成参数就是了：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;natEqInstance : Eq Nat
    natEqInstance = record { _===_ = natEq }
&lt;/code&gt;&lt;p&gt;我们还可以使用优美的余模式（copattern）：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;natEqInstance&#39; : Eq Nat
    _===_ natEqInstance&#39; = natEq
&lt;/code&gt;&lt;p&gt;根据 &lt;code class=&quot;inline&quot;&gt;Eq&lt;/code&gt; 类型类，定义不等于（就不 point-free 了，怕伤害不精通各种 arrow 操作的萌新）：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;natNeq&#39; : {A : Type i} -&amp;gt; (Eq A) -&amp;gt; A -&amp;gt; A -&amp;gt; Bool
    natNeq&#39; eq a b = not $ _===_ eq a b
&lt;/code&gt;&lt;p&gt;使用一下这个不等于：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ : false == natNeq&#39; natEqInstance 0 0
    _ = idp

    _ : true == natNeq&#39; natEqInstance 1 2
    _ = idp
&lt;/code&gt;&lt;p&gt;嗯，非常妙。&lt;/p&gt;&lt;p&gt;我们现在已经实现了一个非常不优美（不优美的原因是，我们要手动传入类型实例） 但比 Haskell 版本更灵活的类型类，并给它创建类型实例了！&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;module EqAsInstanceArgument where
&lt;/code&gt;&lt;p&gt;在这个基础上，我们如果把那个 &lt;code class=&quot;inline&quot;&gt;(Eq A)&lt;/code&gt; 做成实例参数，就可以让编译器自己去找类型实例， 实现 Haskell 中 &lt;code class=&quot;inline&quot;&gt;=&amp;gt;&lt;/code&gt; 一样的效果了！&lt;/p&gt;&lt;p&gt;我们需要做两个手脚，首先 &lt;code class=&quot;inline&quot;&gt;open&lt;/code&gt; 出来的 &lt;code class=&quot;inline&quot;&gt;_===_&lt;/code&gt; 中的 &lt;code class=&quot;inline&quot;&gt;(Eq A)&lt;/code&gt; 需要变成实例参数 &lt;code class=&quot;inline&quot;&gt;{{ Eq A }}&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;open Eq {{ ... }}
&lt;/code&gt;&lt;p&gt;没错，这个需求有点复杂，所以 Agda 专门做了个语法来简化这个流程。 当然，不代表我们不能手动实现这个语法糖实现的功能：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;module StupidImplementation
           {i} {A : Type i} {{ eq : Eq A }} where
      open module EqInstances = Eq eq public
&lt;/code&gt;&lt;p&gt;其次我们的类型实例需要被 &lt;code class=&quot;inline&quot;&gt;instance&lt;/code&gt; 修饰：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;instance
      natEqInstance : Eq Nat
      natEqInstance = record { _===_ = natEq }
&lt;/code&gt;&lt;p&gt;嗯，由于我们已经把 &lt;code class=&quot;inline&quot;&gt;Eq&lt;/code&gt; 以实例参数形式 &lt;code class=&quot;inline&quot;&gt;open&lt;/code&gt; 出来，就用不了余模式了 QAQ。&lt;/p&gt;&lt;p&gt;然后再试试用这个类型类实现不等于。先显式传入，找找感觉（ 实例参数必须 introduce 一个变量，不知道为什么。如果不想写，命名为下划线就是）：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;natNeq&#39; : {A : Type i} -&amp;gt; {{_ : Eq A}} -&amp;gt; A -&amp;gt; A -&amp;gt; Bool
    natNeq&#39; {{eq}} a b = not $ _===_ {{eq}} a b
&lt;/code&gt;&lt;p&gt;自动传入（终于能用上运算符语法了，嘤嘤嘤）：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;natNeq : {A : Type i} -&amp;gt; {{_ : Eq A}} -&amp;gt; A -&amp;gt; A -&amp;gt; Bool
    natNeq a b = not $ a === b
&lt;/code&gt;&lt;p&gt;运算符重载了解一下，自定义优先级结合性了解一下：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;infixl 32 _=/=_
    _=/=_ : {A : Type i} -&amp;gt; {{_ : Eq A}} -&amp;gt; A -&amp;gt; A -&amp;gt; Bool
    a =/= b = not $ a === b
&lt;/code&gt;&lt;p&gt;相信此时浏览器等宽字体设置为 Fira Code 的读者已经被爽到了（噫）。&lt;/p&gt;&lt;p&gt;简单地调用，证明一下性质：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ : false == O =/= O
    _ = idp

    _ : true == O =/= S O
    _ = idp
&lt;/code&gt;&lt;p&gt;完美！我们有类型类了！&lt;/p&gt;</description>
<author>兴趣使然千里冰封</author>
<guid isPermaLink="false">2018-11-08-48920962</guid>
<pubDate>Thu, 08 Nov 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
