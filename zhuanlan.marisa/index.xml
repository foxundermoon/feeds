<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Fri, 30 Mar 2018 17:45:46 +0800</lastBuildDate>
<item>
<title>C宏元编程:编译期LISP解释器（一）总体思路</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-30-35121316.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35121316&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一个超级神奇的项目 &lt;a href=&quot;https://github.com/BlueFlo0d/CSP&quot;&gt;CSP GIt Repo&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对！纯粹用C宏-那个只支持字符串替换和粘贴的东西-写的LISP解释器！&lt;/p&gt;&lt;p&gt;（目前还没有完成，最重要的lambda已经实现了，cond暂时还有问题嵌套会出错x）&lt;/p&gt;&lt;p&gt;（想拉一些小伙伴一起玩一起烧脑呀！可惜似乎人类玩家直接看源码大概率大脑爆栈，于是尝试写了一些文章之类。。原始wiki可以戳这里 &lt;a href=&quot;https://github.com/BlueFlo0d/CSP/wiki/Implementation-details&quot;&gt;CSP Wiki&lt;/a&gt;&lt;/p&gt;&lt;p&gt;那么现在就开始玩转（abuse）C宏定义的神奇（ドM）之旅吧！&lt;/p&gt;&lt;h2&gt;总体思路&lt;/h2&gt;&lt;p&gt;C宏定义想必大家都熟悉，姑且展开最天马行空的想象，进行LISP的列表操作（CAR CDR CONS之类）应该是可行的，First-class function某种程度上似乎也可行（传递宏名），比如这个例子：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define E(...) __VA_ARGS__ //单位宏
#define N(...) //零宏
#define __test(something,k,...) k(do something)
#define _test(something,...) __test(something,E)
_test(testit) // =&amp;gt; __test(testit,E) =&amp;gt; E(do testit) =&amp;gt; do testit
_test(E(N,N)) // =&amp;gt; __test(N,N,E) =&amp;gt; N(do N) =&amp;gt;
//_test(E(N,N))的输出消失了！&lt;/code&gt;&lt;p&gt;这个例子中我们看到我们将零宏和单位宏作为参数传入，并使得_test（封装 __test）具有一个零点 E(N,N)。这个技巧（私货！）在CSP的实现中经常用到！记笔记！&lt;/p&gt;&lt;p&gt;但是要实现lambda。。似乎纯粹的C宏很难做到（比如要把参数代入匿名函数体。。咋整啊）。。&lt;/p&gt;&lt;p&gt;不过别忘了神奇的LISP是可以实现自解释的！也就是可以用没有lambda语义的LISP解释器来实现完整的LISP解释器。&lt;/p&gt;&lt;p&gt;CSP的实现就按照了这个思路，首先实现解释器A（其实就是加载了一组实现LISP原语宏的C预处理器），然后再在解释器A上实现完整的LISP自解释器B。以下是自解释器的源码（不是最新的x 最新的在纠结那个有问题的cond）&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;//Line 176, csp.h
#define $zipped_eval(e,a) COND(\
        (ATOM e (EVAL_e $zipped_assoc(e,a)))    \
        (ATOM SAFE_CAR e \
         COND(($eq(SAFE_CAR e (quote))EVAL_e(SAFE_CAR SAFE_CDR e))  \
              ($eq(SAFE_CAR e (atom)) (EVAL_e ATOM\
              DELAY_INT_23($zipped_eval_R)() (SAFE_CAR SAFE_CDR e,a))) \
              ($eq(SAFE_CAR e (eq)) (EVAL_e $eq( DELAY_INT_25($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR e,a) DELAY_INT_25($zipped_eval_R)() \
              (SAFE_CAR SAFE_CDR SAFE_CDR e,a)))) \
              ($eq(SAFE_CAR e (car)) (EVAL_e SAFE_CAR DELAY_INT_23($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR e,a))) \
              ($eq(SAFE_CAR e (cdr)) (EVAL_e SAFE_CDR DELAY_INT_23($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR e,a))) \
              ($eq(SAFE_CAR e (cons)) (EVAL_e CONS DELAY_INT_23($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR e,a) DELAY_INT_23($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR SAFE_CDR e,a))) \
              ((T)(EVAL_e DELAY_INT_23($zipped_eval_R)()\
               (($zipped_assoc(SAFE_CAR e,a) EVAL_e SAFE_CDR e),a))) \
                 )                                                      \
                )                                                       \
        ($eq(SAFE_CAR SAFE_CAR e (lambda))\
        (DELAY_INT_26(EVAL_e_R)() DELAY_INT_23($zipped_eval_R)()(\
        EVAL_e(EVAL_e(EVAL_e(EVAL_e(SAFE_CAR SAFE_CDR SAFE_CDR SAFE_CAR e)))),\
        EVAL_e(APPEND DELAY_INT_13($pair_R)()(EVAL_e(EVAL_e(EVAL_e(SAFE_CAR SAFE_CDR SAFE_CAR e)))\
        (DELAY_INT_19($zipped_evlis_R)()(EVAL_e(_e EVAL_e(SAFE_CDR e)), a)))a)))\
        )                                                               \
)&lt;/code&gt;&lt;p&gt;是不是似曾相识啊23333&lt;/p&gt;&lt;p&gt;典型的自解释器实现。大家注意到这里：&lt;/p&gt;&lt;p&gt;1）有很多SAFE_XXX之类的东西，将来会解释。（C宏处理似乎难以实现短路condition，导致经常会对非法表达式进行求值，这种情况下使用naive的原语宏是会出事的-原地报错／破坏括号平衡-所以必须要很麻烦地一个一个实现为对于非法输入仍能给出合法结果的宏）&lt;/p&gt;&lt;p&gt;2）很多EVAL_e。这是一个单位宏，单位宏和零宏在C宏展开中作用非常大，因为可以用它们微调宏的展开顺序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define _CAT(x,y) x##y
#define CAT(x,y) _CAT(x,y) //典型的连接
//_e是一个单位宏，_n是一个零宏
#define b() )x(
_n(b()) //先展开_n再展开b，什么都没有了x
_e(_n _n()(b())) // =&amp;gt;_n()x() =&amp;gt; x()
//先展开b再展开_n&lt;/code&gt;&lt;p&gt;因为CPP展开_&lt;i&gt;e&lt;/i&gt;时对其括号内字符串调用展开过程（所以单位宏可以用来增加一次展开扫描过程），这个时候b会被展开，但第一个_n后面没有左括号不会展开，所以会先展开中间的_n()，下一次扫描时才第一个_n和左括号连起来被展开。&lt;/p&gt;&lt;p&gt;（是不是有些tricky？这是Lv0啦～等不及的可以自己看一下csp.h 2333如果能全部看懂帮我写文章吧qwq）&lt;/p&gt;&lt;p&gt;3) DELAY_INT_xxx(xxx_R)()(...) 这个是著名的延迟展开技巧，DELAY_INT_xxx定义如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define DELAY_REF(x) x _n()
#define DELAY_REF_2(x) x _n()
#define DELAY_INT_2(x) DELAY_REF(DELAY_REF_2)(x)
#define DELAY_INT_3(x) DELAY_REF(DELAY_INT_2)(x)
#define DELAY_INT_4(x) DELAY_REF(DELAY_INT_3)(x)
#define DELAY_INT_5(x) DELAY_REF(DELAY_INT_4)(x)
...&lt;/code&gt;&lt;p&gt;结合2）容易理解这样 DELAY_INT_n(xxx_R)() 每次扫描n会减一，直到“露出” xxx_R与后面的()结合，习惯上定义：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define xxx_R() xxx&lt;/code&gt;&lt;p&gt;这样xxx就被展开出来与参数列表结合，起到任意调节宏展开顺序的作用。&lt;/p&gt;&lt;p&gt;此外这个还被用于宏的递归。由于蓝色集合的限制，像这样的宏是不能实现递归的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define I_want_recursion(x) do_it(x) I_want_recursion(x)
I_want_recursion(x) //=&amp;gt;do_it(x) I_want_recursion(x)
//CPP认为它属于已经处理过的字符串于是就不会再展开了^
_e(I_want_recursion(x))//=&amp;gt;do_it(x) I_want_recursion(x)
//扫描多少遍都没有用！&lt;/code&gt;&lt;p&gt;但是可以这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define I_want_recursion_R() I_want_recursion
#define I_want_recursion(x) do_it(x) DELAY_REF(I_want_recursion_R)()(x)
I_want_recursion(x) //=&amp;gt;do_it(x) I_want_recursion_R()(x)
_e(I_want_recursion(x)) //=&amp;gt;do_it(x) do_it(x) I_want_recursion_R()(x)
//因为这次I_want_recursion是由I_want_recursion_R()新造出来的token所以可以继续展开下去&lt;/code&gt;&lt;p&gt;不过这样需要在外面套足够多的单位宏来进行足够次数的扫描。。。CSP中有一部分使用零点构造技术更优雅地实现了递归，将来会写的x&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这次就先写这些吧，下次写解释器A的列表操作实现和Currying？&lt;/p&gt;</description>
<author>K.Scarlet</author>
<guid isPermaLink="false">2018-03-30-35121316</guid>
<pubDate>Fri, 30 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Programming Languages: Application and Interpretation【译15中】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-30-35115633.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35115633&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b71b632ed7974538bb2e812bcd20914e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;初翻： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/9bebf466fc2535bec442451dca7cd13a&quot; data-hash=&quot;9bebf466fc2535bec442451dca7cd13a&quot; data-hovercard=&quot;p$b$9bebf466fc2535bec442451dca7cd13a&quot;&gt;@lotuc&lt;/a&gt; &lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;https://lotuc.gitbooks.io/plai-cn/content/&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;15.3 对核心的扩展&lt;/h2&gt;&lt;p&gt;现在我们已经有了基础的静态类型语言，下面探索一下如何将其扩展成为更有用的编程语言。&lt;/p&gt;&lt;h2&gt;15.3.1 显式的参数多态&lt;/h2&gt;&lt;p&gt;&lt;b&gt;下面哪些是相同的？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;(listof string)&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;事实上，上面任何两个都不太一样。但是第一个和第三个非常相似，因为第一个是Java代码而第三个是我们的静态语言代码，而第二个，是C++代码，和其它两个不同。清楚了吗？不清楚？很好，继续往下读！&lt;/p&gt;&lt;h2&gt;15.3.1.1 参数化类型&lt;/h2&gt;&lt;p&gt;我们所使用的编程语言已经展示了参数多态的价值，例如，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;函数的类型可以这样给出：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((&#39;a -&amp;gt; &#39;b) (listof &#39;a) -&amp;gt; (listof &#39;b))&lt;/code&gt;&lt;p&gt;意思是，对于任意类型&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;读入一个从&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;到&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;的函数，一个&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;的链表，生成对应的&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;的链表。这里，&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;不是具体的类型；它们是&lt;b&gt;类型变量&lt;/b&gt;（我们的术语中，这应该被称为“类型标识符”，因为它们在实例化过程中不会变化；但是我们还是使用传统术语）。&lt;/p&gt;&lt;p&gt;可以换种方式理解它：实际上有一族无穷多的这样的&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;函数。例如，其中一个&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;的类型是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((number -&amp;gt; string) (listof number) -&amp;gt; (listof string))&lt;/code&gt;&lt;p&gt;另一个的类型是这样的（没有限制说其中的类型必须是基本类型）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((number -&amp;gt; (number -&amp;gt; number)) (listof number) -&amp;gt; (listof (number -&amp;gt; number)))&lt;/code&gt;&lt;p&gt;还有这样的（也没有限制说&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;必须不同）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((string -&amp;gt; string) (listof string) -&amp;gt; (listof string))&lt;/code&gt;&lt;p&gt;以此类推。由于它们的类型不同，名字也需要不同：&lt;code class=&quot;inline&quot;&gt;map_num_str&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;map_num_num-&amp;gt;num&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;map_str_str&lt;/code&gt;等。但是这会让它们变成不同的函数，于是我们总得使用某个特定&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;，而不是直接使用比较一般的那个。&lt;/p&gt;&lt;p&gt;显然，不可能将所有这些函数放到我们的标准库中：毕竟它们有无穷多个！更好的方式是能按需获取我们需要的函数。我们的命名规则给出了一点提示：&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;接受两个&lt;b&gt;参数&lt;/b&gt;，它们都是&lt;b&gt;类型&lt;/b&gt;。给定了两个类型作为参数，我们可以得到针对特定类型的&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;函数。这种&lt;b&gt;类型的参数化&lt;/b&gt;被称为&lt;b&gt;参数多态&lt;/b&gt;。&lt;/p&gt;&lt;blockquote&gt;注意不要和对象“多态”搞混，后面会讨论它。&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;15.3.1.2 显式声明类型参数&lt;/h2&gt;&lt;p&gt;换句话说，我们相当于说&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;实际上是有四个参数的函数，其中两个是类型，另外两个是实际的值（函数和链表）。在需要显式声明类型的语言中，我们需要写成类似这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (map [a : ???] [b : ???] [f : (a -&amp;gt; b)] [l : (listof a)]) : (listof b)
  ...)&lt;/code&gt;&lt;p&gt;但是这会产生一些问题。首先，&lt;code class=&quot;inline&quot;&gt;???&lt;/code&gt;处应该填什么？它是&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;的类型。但是如果a和b本身将被&lt;b&gt;类型&lt;/b&gt;替换，那么类型的类型是什么？其次，我们真的希望每次调用map的时候传入四个参数吗？再者，我们真的希望在接收任何实际值之前先接收类型参数吗？对于这些问题的答案能延伸出关于多态类型系统巨大的讨论空间，其中的大部分我们这里将&lt;b&gt;不&lt;/b&gt;会涉及。&lt;/p&gt;&lt;blockquote&gt;推荐阅读Pierce的《Types and Programming Languages(类型和编程语言)》，获取易懂、现代的介绍。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;注意到一旦我们引入参数化，很多预期之外的代码都将被参数化。例如，考虑平平无奇的&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;函数的类型。它的类型需要基于链表中值的类型进行参数化（尽管它实际上并不依赖于这些值——稍后会解释这一点），于是每次使用&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;时都需要正确地进行类型实例化。说到这，即使用&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;创建空链表也必须类型实例化！当然，Java和C++程序员应该对这个痛点很熟悉了。&lt;/p&gt;&lt;h2&gt;15.3.1.3 一阶多态&lt;/h2&gt;&lt;p&gt;我们将只讨论这个空间中一个特别有用且易于理解的点上，也即 Standard ML 的类型系统、同时是本书使用的静态类型语言和早期版本的 &lt;br&gt;Haskell 的类型系统，有范型加成的 Java 和 C# 以及引入了模版的C++ &lt;br&gt;也差不多获得了这种类型系统的大部分能力。这类语言定义了被称为&lt;b&gt;谓词&lt;/b&gt;、&lt;b&gt;一阶&lt;/b&gt;或者叫&lt;b&gt;前缀&lt;/b&gt;多态的东西。关于上小节的问题它的答案是不填、没有、是。下面我们来探讨一下。&lt;/p&gt;&lt;p&gt;我们首先将类型的世界分成两组。第一组包含我们目前用到的静态类型语言，另外加上类型变量；它们被称为 &lt;b&gt;monotype（单型）&lt;/b&gt;。第二组包含参数化的类型，被称为 &lt;b&gt;polytype（多型）&lt;/b&gt;；按惯例它们是这样写的：&lt;code class=&quot;inline&quot;&gt;∀&lt;/code&gt;前缀，一组类型变量，再跟一个类型表达式，表达式中可以使用这些类型变量。因此，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;的类型将写作：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;∀ a, b : ((&#39;a -&amp;gt; &#39;b) (listof &#39;a) -&amp;gt; (listof &#39;b))&lt;/code&gt;&lt;p&gt;由于“&lt;code class=&quot;inline&quot;&gt;∀&lt;/code&gt;”是逻辑符号“对于所有的”的意思，于是上面的东西可以读作：“对于所有类型&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;的类型为……”。&lt;/p&gt;&lt;p&gt;在一阶多态（rank-1 polymorphism）中，类型变量只能被&lt;code class=&quot;inline&quot;&gt;monotype&lt;/code&gt;替换。（此外，它们只能被具体类型替换，否则剩下的类型变量将无法被替换掉。）因此，在类型变量参数和常规参数之间我们有了明确的界线。我们不需要为类型变量提供“类型注解”，因为我们知道它们可以是什么。这样得到的语言相对简洁，但仍提供了相当的表达能力。&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;非直谓性&lt;/b&gt;语言（&lt;a href=&quot;https://en.wikipedia.org/wiki/Impredicativity&quot;&gt;Impredicative&lt;/a&gt; language）取消了&lt;code class=&quot;inline&quot;&gt;monotype&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;polytype&lt;/code&gt;的区别，因此类型变量可以使用另一个多态类型实例化。&lt;/blockquote&gt;&lt;p&gt;注意到由于类型变量只能被&lt;code class=&quot;inline&quot;&gt;monotype&lt;/code&gt;替换，他们全相互对立。于是，类型参数可以全被提到参数表的前面。这使我们可以使用形如&lt;code class=&quot;inline&quot;&gt;∀ tv, ... : t&lt;/code&gt;的类型，其中&lt;code class=&quot;inline&quot;&gt;tv&lt;/code&gt;是类型变量，&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;monotype&lt;/code&gt;（其中可以引用这些类型变量）。此语法的意义就在这里，这也是之前称其为前缀多态的原因。而且后面也将看到这对其实现也很有用。&lt;/p&gt;&lt;h2&gt;15.3.1.4 通过去语法糖实现一阶多态解释器&lt;/h2&gt;&lt;p&gt;该特性最简单的实现就是将其视为一种去语法糖的形式：C++ 实际上就是这么做的。（具体来说，因为 C++ 有一个叫做模版的宏系统，所以使用模版，它非常巧合地达成了一阶多态。）举个例子，如果我们有一个语法形式&lt;code class=&quot;inline&quot;&gt;define-poly&lt;/code&gt;，它接收名字、类型变量和表达式。当传入类型的时候，它将表达式中对应类型变量替换为此类型，因此：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-poly (id t) (lambda ([x : t]) : t x))&lt;/code&gt;&lt;p&gt;通过将&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;定义为多态的方式定义了一个恒等（identity）函数：给&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;传入递任意具体类型，就得到一个单参数的类型为&lt;code class=&quot;inline&quot;&gt;(t -&amp;gt; t)&lt;/code&gt;的函数（其中&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;被替换）。我们可以使用各种类型实例化&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define id_num (id number))
(define id_str (id string))&lt;/code&gt;&lt;p&gt;从而获得针对这些类型的恒等函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (id_num 5) 5)
(test (id_str &quot;x&quot;)  &quot;x&quot;)&lt;/code&gt;&lt;p&gt;与之相对，像&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(id_num &quot;x&quot;)
(id_str 5)&lt;/code&gt;&lt;p&gt;这样的表达式将&lt;b&gt;不能通过类型检查&lt;/b&gt;（而不是运行时出错）。&lt;/p&gt;&lt;p&gt;如果你好奇的话，下面给出了实现。简单起见，我们假设只有一个类型参数；很容易使用&lt;code class=&quot;inline&quot;&gt;...&lt;/code&gt;实现多个参数的情形。我们不仅将&lt;code class=&quot;inline&quot;&gt;define-poly&lt;/code&gt;定义为宏，&lt;b&gt;它&lt;/b&gt;还会定义宏：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax define-poly
  (syntax-rules ()
    [(_ (name tyvar) body)
     (define-syntax (name stx)
       (syntax-case stx ()
         [(_ type)
          (with-syntax ([tyvar #&#39;type])
            #&#39;body)]))]))&lt;/code&gt;&lt;p&gt;因此，对于：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-poly (id t) (lambda ([x : t]) : t x))&lt;/code&gt;&lt;p&gt;该语言将创建名为&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的&lt;b&gt;宏&lt;/b&gt;：对应&lt;code class=&quot;inline&quot;&gt;(define-syntax (name ...) ...)&lt;/code&gt;的部分（对于这个例子，&lt;code class=&quot;inline&quot;&gt;name&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;）。&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的一个实例，如&lt;code class=&quot;inline&quot;&gt;(id number)&lt;/code&gt;，将类型变量&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;、宏里面的&lt;code class=&quot;inline&quot;&gt;typvar&lt;/code&gt;替换成给定的类型。因为要规避卫生，我们用&lt;code class=&quot;inline&quot;&gt;with-syntax&lt;/code&gt;来确保所有对于类型变量（typvar）的使用被替换为给定的类型。因此，实际效果是，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define id_num (id number))&lt;/code&gt;&lt;p&gt;被转换成了&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define id_num (lambda ([x : number]) : number x))&lt;/code&gt;&lt;p&gt;然而这种方式有两个重大局限性：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;来试试定义递归的多态函数，比如说&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;。之前我们说过，每个多态值（例如&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;）都需要类型实例化，但是为了简洁起见我们将依赖静态类型语言实现这点，而仅专注于&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;的类型参数。对应代码是：&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;(define-poly (filter t)&lt;br&gt;  (lambda ([f : (t -&amp;gt; boolean)] [l : (listof t)]) : (listof t)&lt;br&gt;    (cond&lt;br&gt;      [(empty? l) empty]&lt;br&gt;      [(cons? l) (if (f (first l))&lt;br&gt;                     (cons (first l)&lt;br&gt;                           ((filter t) f (rest l)))&lt;br&gt;                     ((filter t) f (rest l)))])))&lt;/p&gt;&lt;blockquote&gt;注意到递归的使用&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;时，必须使用恰当的类型对其实例化。&lt;/blockquote&gt;&lt;p&gt;上面的定义完全正确，只有一个问题，当我们尝试使用它时——如：&lt;/p&gt;&lt;p&gt;(define filter_num (filter number))&lt;/p&gt;&lt;blockquote&gt;DrRacket 将不会终止，更准确的说，是宏展开不会终止，因为它将不断的尝试创建&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;&lt;b&gt;代码的副本&lt;/b&gt;。不过如果用下面这种方式定义该函数，展开会终止——&lt;/blockquote&gt;&lt;p&gt;(define-poly (filter2 t)&lt;br&gt;  (letrec ([fltr&lt;br&gt;            (lambda ([f : (t -&amp;gt; boolean)] [l : (listof t)]) : (listof t)&lt;br&gt;              (cond&lt;br&gt;                [(empty? l) empty]&lt;br&gt;                [(cons? l) (if (f (first l))&lt;br&gt;                               (cons (first l) (fltr f (rest l)))&lt;br&gt;                               (fltr f (rest l)))]))])&lt;br&gt;    fltr))&lt;/p&gt;&lt;blockquote&gt;但是这给开发人员徒增了不必要的痛苦。实际上，一些模版展开程序会缓存之前展开的值，避免对于相同的参数反复生成代码。（Racket &lt;br&gt;做不到这点，因为一般来说，宏表达式可以依赖可变变量和值，甚至可以执行输入输出，因此 Racket 无法保证同样的输入表达式总是产生相同输出。）&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;考虑恒等函数的两个实例。我们无法比较&lt;code class=&quot;inline&quot;&gt;id_num&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;id_str&lt;/code&gt;，因为它们类型不同，但即使它们类型相同，使用&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;比较它们也不同：&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;(test (eq? (id number) (id number)) #f)&lt;/p&gt;&lt;blockquote&gt;这是因为对&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;每次实例化都会创建一份新的代码副本。即使使用了上面提到的优化，&lt;b&gt;同一种&lt;/b&gt;类型对应代码只有一份副本，但是不同类型的对应代码体还是会被重新生成【注释】——但这也是没必要的！例如，&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的实现的部分其实没任何东西依赖于参数的类型。实际上，&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;这一族无穷多个的函数可以共享同一个实现。简单的去语法糖策略实现不了这点。&lt;/blockquote&gt;&lt;p&gt;事实上，&lt;code class=&quot;inline&quot;&gt;C++&lt;/code&gt;模版因代码膨胀的问题而臭名昭著，这是原因之一。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;换种说法，基于去语法糖的策略本质上是使用替换的实现方式，它有着和我们之前函数调用时使用替换的方式实现相同的问题。不过，其它情况下，替换策略能达成我们关于程序行为的期望；对于多态也是一样，正如我们将看到的一样。&lt;/p&gt;&lt;p&gt;注意去语法糖策略的一个好处就是它不需要类型检查器“理解”多态。我们的核心语言仍可以是单态的（monomorphic），所有的（一阶）多态完全由宏展开处理。这提供了一种廉价的将多态添加到语言中的策略，但正如C++所示，它也引入了很大的开销。&lt;/p&gt;&lt;p&gt;最后，虽然这里我们只关注了函数，但前面的讨论同样适用于数据结构。&lt;/p&gt;&lt;h2&gt;15.3.1.5 其它实现方式&lt;/h2&gt;&lt;p&gt;有些其他实现策略不会遇到此类问题。这里我们不会深入讲解它们，但是其中一些策略的本质就是上面提到过的“缓存”方法。因为可以确定的是，对于给定的同一组类型参数，应该得到相同的实现代码，不需要对相同的类型参数实例化多次。这避免了无限循环。如果我们检查了使用特定类型实例化的代码一次，后续相同类型参数的实例化结果就无需再进行类型检查（因为它不会发生改变）。此外，我们无需保留实例化后的源码：一旦我们检查了展开后的程序，就可以将其丢弃，运行时也只需要保留一份实例化的副本。这样可以避免上述纯去语法糖策略中讨论过的所有问题，同时保留它的好处。&lt;/p&gt;&lt;p&gt;其实我们有点过分了。静态类型的好处之一就是能选择更精确的运行时表示。例如，静态类型可以告诉我们用的是数是32位的还是64位的甚至1位的（也就是布尔值）。然后编译器可以利用位的布局方式（例如，32个布尔值可以**打包*进一个32位字）为每种表示生成专用代码。因此，在对每种使用的类型进行检查之后，多态实例化程序可以跟踪函数或数据结构使用时用到的特定类型，并将这些信息提供给编译器用于代码生成。这会导致生成相关函数的若干副本，彼此都互不&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;——但这么做有充分的理由，因为它们要执行的操作的确不同，所以这是正确的。&lt;/p&gt;&lt;h2&gt;15.3.1.6 关系型参数&lt;/h2&gt;&lt;p&gt;我们还需解决关于多态的最后一个细节。&lt;/p&gt;&lt;p&gt;早先我们说过像&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;这样的函数不依赖于其参数的具体值。这一点对&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;等也成立。&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;接收一个函数作为参数，当它们要对单个元素进行操作时，实际上使用该函数进行操作，即该函数负责做出如何处理元素的决定；&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;本身只是遵从该函数参数。&lt;/p&gt;&lt;p&gt;“检验”这种情况是否属实的一种方法是，替换不同类型的值链表及对应的函数作为参数。也就是说假设两组值之间有映射关系；我们根据此关系替换链表元素和参数函数。问题是，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;的输出结果是否可以通过该关系预测？如果对于某些输入，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;的输出和关系预测的结果不同，这说明&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;肯定侦测了实际值并根据相关信息做出了处理。但事实上，这不会发生在&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;上，或者说实际上也不会发生在大多标准多态函数上。&lt;/p&gt;&lt;p&gt;遵从这类型关系准则的函数被称为&lt;b&gt;关系型参数&lt;/b&gt;（Relational Parametricity）【注释】。这是类型赋予我们的另一个非常强大的能力，因为它们告诉我们这种多态函数可以执行的操作很受限制：它们可以删除、复制或重新排列元素，但是不能考察这些元素，也不能对它们进行具体操纵。&lt;/p&gt;&lt;blockquote&gt;请参阅Wadler的《Theorems for Free!》和Reynolds的《Types, Abstraction and Parametric Polymorphism》。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;起初这听起来非常令人印象深刻（确实如此！），但细查，你可能会意识到这与经验并不一致。例如，在Java中，多态方法依然可以使用&lt;code class=&quot;inline&quot;&gt;instanceof&lt;/code&gt;在运行时检查、获得特定类型的值，并相应的改变行为。这种方法就不是关系型参数了！【注释】事实上，关系型参数也能被看作是语言弱点的一种表述：它只允许一组有限的操作。（你仍可以检查类型——但不能根据你获取的信息进行相关行动，这样检查就没有意义了。因此运行时系统如果想要模拟关系型参数，必须要移除类似&lt;code class=&quot;inline&quot;&gt;instanceof&lt;/code&gt;及它的替代行为：例如，对值进行加一操作并捕获异常以判断它是数。）然而，这是个非常优雅和令人吃惊的结果，显示了使用丰富类型系统能获得的强大程序推理能力。&lt;/p&gt;&lt;blockquote&gt;网上，你会经常发现这个属性被描述为函数不能检查其参数——这是不正确的。&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;15.3.2 类型推断&lt;/h2&gt;&lt;p&gt;手工书写每处多态类型的实例参数是一个令人沮丧的过程，很多版本的Java和C++用户可以证明这点。想象一下，每次使用&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt;时都需要传入类型参数是个什么场景！我们之所以能够避免这种命运，是因为我们的语言实现了&lt;b&gt;类型推断&lt;/b&gt;。这使我们可以编写定义：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (mapper f l)
  (cond
    [(empty? l) empty]
    [(cons? l) (cons (f (first l)) (mapper f (rest l)))]))&lt;/code&gt;&lt;p&gt;然后编程环境&lt;b&gt;自动&lt;/b&gt;声明&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; mapper
- ((&#39;a -&amp;gt; &#39;b) (listof &#39;a) -&amp;gt; (listof &#39;b))&lt;/code&gt;&lt;p&gt;它不仅是正确的类型，而且是非常一般的类型！从程序结构中派生出这种一般类型的过程感觉几乎就是魔法。我们来揭示其幕后。&lt;/p&gt;&lt;p&gt;首先，我们来了解类型推断做了什么。有些人错误的认为，有类型推断的语言无类型声明，其被类型推断取而代之了。这混淆了多个层面的东西。首先，即使在有类型推断的语言中，程序员仍被允许声明类型（并且为了文档更为清晰，通常会鼓励这样做——就像你之前被鼓励的一样）【注释】。此外，在没有这些声明的情况下，推断的实际&lt;b&gt;含义&lt;/b&gt;并不显明。&lt;/p&gt;&lt;blockquote&gt;有时（类型）推断是不可判定的，这时程序员别无选择只能声明某些类型。最后，显式的书写类型注解能够大大减少难以辨认的错误信息。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;相反，最好将底层语言看作需要完整地显式声明类型的——就如我们刚才研究的多态语言。然后我们说，在&lt;code class=&quot;inline&quot;&gt;:&lt;/code&gt;后类型注解部分可以留空，编程环境中的某个特性会为我们填充这些。（如果走得更远，我们可以丢弃&lt;code class=&quot;inline&quot;&gt;:&lt;/code&gt;及额外的修饰，它们都会被自动插入。因此，类型推断只是为用户提供的一种便利，减轻编写类型注解的负担，而底层的语言仍然是显式声明类型的。&lt;/p&gt;&lt;p&gt;我们怎么考虑类型推断做的是什么呢？假设我们有个表达式（或者程序）&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;，由显式声明类型语言书写：也就是说在任何需要类型注解的地方都有写出。现在假设我们擦除&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;中所有的类型注解，然后使用函数&lt;code class=&quot;inline&quot;&gt;infer&lt;/code&gt;将它们推断回来。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;code class=&quot;inline&quot;&gt;infer&lt;/code&gt;应该有何种属性？&lt;/blockquote&gt;&lt;p&gt;我们可以要求很多东西。其中之一为，它要产生和&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;原来恰好一样的注解。这在很多方面都是有问题的，尤其是当&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;本就不能通过类型检查的情况下，怎么能推断回它们（应该）是什么？你可能觉得这是个学究式的玩笑：毕竟，如果&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;本就不能通过类型检查，如果能在删除其注解之后还能还原回来呢？反正两者都不能通过类型检查，谁在乎啊？&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;这个推理正确吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;假设&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(lambda ([x : number]) : string x)&lt;/code&gt;&lt;p&gt;它显然不能通过类型检查。但是如果我们擦除类型注解——得到&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(lambda (x) x)&lt;/code&gt;&lt;p&gt;——这个函数显然可以合法地添加类型！因此，更合理的需求可以是，如果原始的&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;能通过类型检查，那么对应的使用了推导出的注解的版本也必须能。这种单向的含义的用途体现在两方面：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;它没有说&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;未通过类型检查应该怎样，也即它不会排除前述的类型推断算法，其会将例子中类型错误的恒等函数变成类型正确的。&lt;/li&gt;&lt;li&gt;更重要的是，它向我们保证，使用类型推断将不会使我们失去任何东西：之前能通过类型检测的程序不会被推断后而不能。这意味着我们可以在想要的地方显式添加类型注解，但不会被迫这样做。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;当然，这只在程序推断可判定的情况下才成立。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;我们还可能希望两者类型是相同的，但这不是能做到的：函数&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(lambda ([x : number]) : number x)&lt;/code&gt;&lt;p&gt;类型为&lt;code class=&quot;inline&quot;&gt;(number -&amp;gt; number)&lt;/code&gt;，而擦除类型注解后推导出的类型要一般得多。因此，将这些类型关联并给出类型相等的定义并不简单，尽管如此后面将简要讨论此问题。&lt;/p&gt;&lt;p&gt;有了这些准备，我们下面进入对类型推断机制的研究。最需要注意的地方，前述的简单递归下降的类型检查算法将不再起作用。它之前能起作用，是因为所有函数的边界处都有类型注解，所以我们下降进入函数体，同时用类型环境携带这些注解中包含的信息。没了这些注解，就不知如何递归下降了。&lt;/p&gt;&lt;p&gt;事实上，目前还不清楚哪个方向更合理。像上面&lt;code class=&quot;inline&quot;&gt;mapper&lt;/code&gt;的定义，各代码段之间互相影响。例如，从&lt;code class=&quot;inline&quot;&gt;empty?&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;cons?&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt;对&lt;code class=&quot;inline&quot;&gt;l&lt;/code&gt;的调用都可以看出它是链表。但是是什么的链表呢？从这些操作看不出来。然而，对于其每个（或者应该说，任意）&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;元素调用了&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;这点可以看出，链表成员的类型必须可以被传给&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;。同理，由&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;我们可以知道（&lt;code class=&quot;inline&quot;&gt;mapper&lt;/code&gt;的）返回表达式必须为链表。它的成员类型是什么呢？必须为&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的返回类型。最后，请注意最微妙的地方：当参数链表为空时，我们返回&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;而不是&lt;code class=&quot;inline&quot;&gt;l&lt;/code&gt;（这时我们是知道其被绑定到&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;）。使用前者，返回值的类型可能是任意类型的链表（仅受&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;返回类型的约束）；使用后者，返回的类型就被迫和参数链表的类型相同。&lt;/p&gt;&lt;p&gt;所有这些信息都包含在函数里。但是我们如何系统地提取出这些信息呢，而且使用的算法必须会终止，并满足前面陈述属性？我们分两步来做。首先，根据程序表达式&lt;b&gt;生成&lt;/b&gt;其必须要满足的类型&lt;b&gt;约束&lt;/b&gt;。然后，通过合并散布在函数体各处的约束、识别其中的不一致，最终&lt;b&gt;解决约束&lt;/b&gt;。每一步都相对简单，但是组合起来创造了魔力。&lt;/p&gt;&lt;h2&gt;15.3.2.1 约束生成&lt;/h2&gt;&lt;p&gt;我们最终的目标是给每个类型注解位置填入类型。将会证明，这也等同于找到每个&lt;b&gt;表达式&lt;/b&gt;的类型。简单想想就知道，这本来也是必要的：比如，在不知道函数体类型的情况下，如何能确定函数本身的类型？这也是足够的，因为如果每个表达式的类型都被计算得出，其中必然包括了那些需要被注解的表达式。&lt;/p&gt;&lt;p&gt;首先，我们需要生成（待解决的）约束。这一步会遍历程序源码，为每个表达式生成恰当的约束，最后返回这组约束。为了简单，使用递归下降的方式实现；它最终生成约束的&lt;b&gt;集合&lt;/b&gt;，所以原则上遍历和生成的顺序是无关紧要的——因此我们选择了相对简单的递归下降方式——当然，为了简单起见，我们使用链表表示这个集合。&lt;/p&gt;&lt;p&gt;约束是什么呢？就是关于表达式类型的陈述。此外，虽然变量绑定并不是表达式，但我们仍需计算其类型（因为函数需要参数和返回值类型）。一般来说，对于表达式的类型我们知道些什么呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;它和某些标识符的类型有关。&lt;/li&gt;&lt;li&gt;它和某些其它表达式的类型有关。&lt;/li&gt;&lt;li&gt;它是数。&lt;/li&gt;&lt;li&gt;它是函数，其定义域（domain）和值域（range）类型可能受到进一步的约束。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;因此，我们定义如下两个数据结构：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type Constraints
  [eqCon (lhs : Term) (rhs : Term)])

(define-type Term
  [tExp (e : ExprC)]
  [tVar (s : symbol)]
  [tNum]
  [tArrow (dom : Term) (rng : Term)])&lt;/code&gt;&lt;p&gt;接下来定义约束生成函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen&amp;gt; ::= ;约束生成

    (define (cg [e : ExprC]) : (listof Constraints)
      (type-case ExprC e
        &amp;lt;constr-gen-numC-case&amp;gt;
        &amp;lt;constr-gen-idC-case&amp;gt;
        &amp;lt;constr-gen-plusC/multC-case&amp;gt;
        &amp;lt;constr-gen-appC-case&amp;gt;
        &amp;lt;constr-gen-lamC-case&amp;gt;))&lt;/code&gt;&lt;p&gt;当表达式为数时，唯一能说的是，我们希望该表达式的类型为数类型：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-numC-case&amp;gt; ::=

    [numC (_) (list (eqCon (tExp e) (tNum)))]&lt;/code&gt;&lt;p&gt;听上去很微不足道，但我们不知道的是，其他包含它的表达式是什么。因此，某个更大的表达式可能会与此断言——这个表达式的类型必须是数型——相矛盾，从而导致类型错误。&lt;/p&gt;&lt;p&gt;对于标识符，我们只是简单地说，表达式的类型就是我们所期望该标识符应有的类型：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-idC-case&amp;gt; ::=

    [idC (s) (list (eqCon (tExp e) (tVar s)))]&lt;/code&gt;&lt;p&gt;如果上下文限制了其类型，该表达式的类型将自动受到限制，并且必须与上下文的期望一致。&lt;/p&gt;&lt;p&gt;加法是我们第一个遇到的上下文约束。对于加法表达式，首先需要确保我们生成（并返回）其两个子表达式的约束，而子表达式可以是复杂的。这两个约束中，我们期望什么？需要每个子表达式是数类型的。（如果其中一个子表达式不是数类型的，应该导致类型错误。）最后，我们断言整个表达式的类型为数。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-plusC/multC-case&amp;gt; ::=

    [plusC (l r) (append3 (cg l)
                          (cg r)
                          (list (eqCon (tExp l) (tNum))
                                (eqCon (tExp r) (tNum))
                                (eqCon (tExp e) (tNum))))]&lt;/code&gt;&lt;blockquote&gt;&lt;code class=&quot;inline&quot;&gt;append3&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;append&lt;/code&gt;的三参数版本。&lt;/blockquote&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;multC&lt;/code&gt;的情况与之相同，区别只在名字上。&lt;/p&gt;&lt;p&gt;下面我们来看另外两个有趣的情况，函数声明和调用。两种情况下我们都需要生成和返回子表达式的约束。&lt;/p&gt;&lt;p&gt;在函数定义中，函数的类型是函数（“箭头/arrow”）类型，其参数类型是形参的类型，其返回类型是函数体的类型。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-lamC-case&amp;gt; ::=

    [lamC (a b) (append (cg b)
                        (list (eqCon (tExp e) (tArrow (tVar a) (tExp b)))))]&lt;/code&gt;&lt;p&gt;最终，考虑函数调用。我们不能直接陈述函数调用的类型约束。不过，我们可以说，函数接受的参数类型必须和实际参数的类型相同，并且函数返回的类型就是调用表达式的类型。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-appC-case&amp;gt; ::=

    [appC (f a) (append3 (cg f)
                         (cg a)
                         (list (eqCon (tExp f) (tArrow (tExp a) (tExp e)))))]&lt;/code&gt;&lt;p&gt;完成了！我们已经完成约束的生成；现在只需解出它们。&lt;/p&gt;&lt;h2&gt;15.3.2.2 使用合一求解约束&lt;/h2&gt;&lt;p&gt;求解约束的过程也被称为&lt;b&gt;合一&lt;/b&gt;（unification）。合一器的输入是等式的集合，其中每个等式是变量到项（term）的映射，项的数据类型在上面定义了。注意到一点，我们实际上有&lt;b&gt;两&lt;/b&gt;种变量。&lt;code class=&quot;inline&quot;&gt;tvar&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;tExp&lt;/code&gt;都是“变量”，前者很明显，注意后者同样也是，因为我们需要求解此类表达式的类型。（另一种方式是为每个表达式引入新的类型变量，但我们仍需一种方法确定这些变量与表达式之间的对应关系，而现在这已经能通过对表达式进行&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;操作自动完成了。另外这会产生大得多的约束集，不好进行人工检查。）&lt;/p&gt;&lt;p&gt;就我们的目的而言，合一是为了是生成&lt;b&gt;替换&lt;/b&gt;（substitution），或者说将变量映射为不包含任何变量的项。这听起来应该很耳熟：我们有一组联立方程，其中每个变量都是线性使用的；这种方程组可以使用&lt;b&gt;高斯消元法&lt;/b&gt;求解。该情形中，我们清楚最终可能遇到缺少约束（under-constrained）或过度约束（over-constrained）的情况。这种事情同样也将发生这里。&lt;/p&gt;&lt;p&gt;合一算法会遍历约束集合。由于每个约束有两项，每个项有四种可能的类型，因此有十六种情况需要考虑。幸运的是，我们实际可以用比较少的代码覆盖这十六种情况。&lt;/p&gt;&lt;p&gt;算法从所有约束的集合和空替换开始。每个约束都会被处理一次，并从集合中删除，因此原则上终止判据应该非常简单，但是实际处理起来还有点小麻烦。随着约束被处理，替换集合会逐渐增长。当所有的约束都被处理完后，合一过程返回最后的替换集合。&lt;/p&gt;&lt;p&gt;对于给定的约束，合一器检查等式左边，如果它是变量，那么这时它就可以被消除了，合一器将该变量（等式）的右侧添加到替换中，为了真正完成消除，还需要将替换集中所有该变量的出现替换成该右侧。实践中，实现需要考虑效率；例如，使用可变值表示这些变量可以避免搜索—替换过程。然而我们可能需要进行回溯（我们在后面确实会需要），可变值表示也有缺点。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;注意到上面微妙的错误了吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;这个微妙的错误是，我们说合一器通过替换变量的所有实例来&lt;b&gt;消除&lt;/b&gt;它。不过，我们假设等式右侧不包含该变量的实例。不然的话，我们将得到循环定义，这将使替换变得不可能。出于这个原因，合一器会进行&lt;b&gt;出现检查&lt;/b&gt;（occurs check）：检查某个变量是否出现在等式两侧，如果是，则拒绝合一。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;构造一个其约束会触发出现检查的项。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;还记得&lt;code class=&quot;inline&quot;&gt;ω&lt;/code&gt;吗？&lt;/p&gt;&lt;p&gt;下面考虑合一的实现。惯例使用希腊字母&lt;code class=&quot;inline&quot;&gt;Θ&lt;/code&gt;表示替换。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type-alias Subst (listof Substitution))
(define-type Substitution
  [sub [var : Term] [is : Term]])

(define (unify [cs : (listof Constraints)]) : Subst
  (unify/Θ cs empty))&lt;/code&gt;&lt;p&gt;首先把简单的东西写出来：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ&amp;gt; ::=

    (define (unify/Θ [cs : (listof Constraints)] [Θ : Subst]) : Subst
      (cond
        [(empty? cs) Θ]
        [(cons? cs)
         (let ([l (eqCon-lhs (first cs))]
               [r (eqCon-rhs (first cs))])
           (type-case Term l
             &amp;lt;unify/Θ-tVar-case&amp;gt;
             &amp;lt;unify/Θ-tExp-case&amp;gt;
             &amp;lt;unify/Θ-tNum-case&amp;gt;
             &amp;lt;unify/Θ-tArrow-case&amp;gt;))]))&lt;/code&gt;&lt;p&gt;现在可以实现合一的核心了。我们需要一个辅助函数&lt;code class=&quot;inline&quot;&gt;extend-replace&lt;/code&gt;，其签名为&lt;code class=&quot;inline&quot;&gt;(Term Term Subst -&amp;gt; Subst)&lt;/code&gt;。它将执行出现检查，如果检查得出没有环路，则扩展替换集合，并将替换集合中所有出现的第一个项（第一个参数）替代为第二个项（第二个参数）。同样，我们假设&lt;code class=&quot;inline&quot;&gt;lookup: (Term subst -&amp;gt; (optionof Term))&lt;/code&gt;存在。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;定义&lt;code class=&quot;inline&quot;&gt;extend-replace&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;lookup&lt;/code&gt;。&lt;/blockquote&gt;&lt;p&gt;如果约束等式的左侧是个变量，我们先在替换集合中寻找它。如果存在，我们将当前约束换成新的约束；否则我们扩展替换集合。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ-tVar-case&amp;gt; ::=

    [tVar (s) (type-case (optionof Term) (lookup l Θ)
                [some (bound)
                      (unify/Θ (cons (eqCon bound r)
                                     (rest cs))
                               Θ)]
                [none ()
                      (unify/Θ (rest cs)
                               (extend+replace l r Θ))])]&lt;/code&gt;&lt;p&gt;同样的逻辑也适用于表达式的情况：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ-tExp-case&amp;gt; ::=

    [tExp (e) (type-case (optionof Term) (lookup l Θ)
                [some (bound)
                      (unify/Θ (cons (eqCon bound r)
                                     (rest cs))
                               Θ)]
                [none ()
                      (unify/Θ (rest cs)
                               (extend+replace l r Θ))])]&lt;/code&gt;&lt;p&gt;如果是基本类型，例如数，我们就需要检查等式右边。有四种可能：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果是数，那么该等式声明类型&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;等于&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;，这恒为真。因此我们可以忽略该约束——它没有告诉我们什么有用信息——继续检查剩下的。&lt;br&gt;当然，首先得解释为什么会出现这种约束。显然，我们的约束生成器不会生成这种约束。然而，前面替换集合的扩展会导致这种情况。事实是实践中我们会遇到好几个这种情况。&lt;/li&gt;&lt;li&gt;如果是函数类型，显然存在类型错误，因为数和函数类型不相交。同样，我们不会直接生成这样的约束，一定是由先前的替代产生。&lt;/li&gt;&lt;li&gt;它可能是两种变量类型之一。不过，我们的约束生成器经过了仔细的安排，不会将它们放在右侧。此外，替代过程也不会在右侧引入它们。因此，这两种情况不会发生。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;于是得出这样的代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ-tNum-case&amp;gt; ::=

    [tNum () (type-case Term r
               [tNum () (unify/Θ (rest cs) Θ)]
               [else (error &#39;unify &quot;number and something else&quot;)])]&lt;/code&gt;&lt;p&gt;最后还剩下函数类型。这里的论点几乎和数类型完全一样。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ-tArrow-case&amp;gt; ::=

    [tArrow (d r) (type-case Term r
                    [tArrow (d2 r2)
                            (unify/Θ (cons (eqCon d d2)
                                           (cons (eqCon r r2)
                                                 cs))
                                     Θ)]
                    [else (error &#39;unify &quot;arrow and something else&quot;)])]&lt;/code&gt;&lt;p&gt;请注意，我们并没有严格地缩小约束集合，因此仅通过约束集合的大小不足以判断这个过程会终止。需要同时综合考虑约束集合的大小以及替换的大小（包括其中变量的个数）。&lt;/p&gt;&lt;p&gt;上面的算法非常通用，不仅对数和函数，对于各种类型项也都适用。我们使用数代表各种基础类型；同样，使用函数代表各种构造类型，例如&lt;code class=&quot;inline&quot;&gt;listof&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;vectorof&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这就完成了。合一产生了替换。现在我们可以遍历这些替换，找到程序中所有表达式的类型，然后插入对应的类型注解。有定理（这里不证明）指出，上面过程的成功意味着程序通过了类型检查，因此我们无需对该程序显式地再跑一遍类型检查。&lt;/p&gt;&lt;p&gt;不过请注意，类型错误的性质在这里发生了巨大变化。之前，我们的递归下降算法利用类型环境遍历表达式。类型环境中的绑定是程序员定义的类型，因此可以被当作（期望的）权威的类型&lt;b&gt;规范&lt;/b&gt;（specification）。因此，所有的错误都应归咎于表达式，类型错误的报告很简单（而且很好懂）。然而这里，类型错误&lt;b&gt;无法通知&lt;/b&gt;。合一错误是两个智能算法——约束生成和合一——共同导致的，因此程序员不一定能理解。特别是，由于约束的本质是等式，报告的错误位置和“真实”的错误位置可能相差甚远。因此，生成更好的错误信息仍然是个活跃的研究领域。&lt;/p&gt;&lt;blockquote&gt;实践中，算法会维护涉及到的程序源码的元信息，并可能也会保存合一的历史，以便溯源错误回源程序。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;最后，请记住，约束可能不会精确指明所有变量的类型。如果方程组&lt;b&gt;过度&lt;/b&gt;约束，可能会有冲突，导致类型错误。如果&lt;b&gt;缺少&lt;/b&gt;约束，这意味着我们没有足够的信息对所有表达式做出明确的类型声明。例如，对于表达式&lt;code class=&quot;inline&quot;&gt;(lambda (x) x)&lt;/code&gt;，没有足够的约束指明&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型，从而无法以指明整个表达式的类型。这并非错误；它只是意味着&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;可以是&lt;b&gt;任意&lt;/b&gt;类型。换句话说，该表达式的类型是“&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型-&amp;gt;&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型”，无其它约束。这些欠约束标识符的类型以类型变量的方式展示，于是上面表达式的类型可以表示为&lt;code class=&quot;inline&quot;&gt;(&#39;a -&amp;gt; &#39;a)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;合一算法实际上有个很好的属性：它能自动计算表达式&lt;b&gt;最通用的类型&lt;/b&gt;，也被称为&lt;b&gt;主类型&lt;/b&gt;（principal type）。这就是说，表达式可以有的任何实际类型都可以通过（用实际类型）替换推导出的类型中的类型变量的得到。这是个异乎寻常的结果：没人能生成比前述算法得出的更为一般的类型！&lt;/p&gt;&lt;h2&gt;15.3.2.3 Let-多态&lt;/h2&gt;&lt;p&gt;很不幸，尽管这些类型变量表面上看和我们之前遇到的多态有诸多相似之处，但它们并不同。考虑下面的程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(let ([id (lambda (x) x)])
  (if (id true)
      (id 5)
      (id 6)))&lt;/code&gt;&lt;p&gt;如果加上显式的类型注解，它能通过类型检查：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(if ((id boolean) true)
    ((id number) 5)
    ((id number) 6))&lt;/code&gt;&lt;p&gt;然而，如果使用类型推断，它将不能通过类型检查！因为&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;中的类型&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;——取决于约束处理的顺序——要么和&lt;code class=&quot;inline&quot;&gt;boolean&lt;/code&gt;合一，要么和&lt;code class=&quot;inline&quot;&gt;number&lt;/code&gt;合一。对应的，那时&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的类型要么是&lt;code class=&quot;inline&quot;&gt;(boolean -&amp;gt; boolean)&lt;/code&gt;要么是&lt;code class=&quot;inline&quot;&gt;(number -&amp;gt; number)&lt;/code&gt;。当使用另一个类型调用&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;时，就会发生类型错误！&lt;/p&gt;&lt;p&gt;这是因为我们通过合一推断出来的类型实际并不是&lt;b&gt;多态的&lt;/b&gt;。这点很重要：将其称为类型变量不会使你获得多态!类型变量可以在下次使用时合一，彼时，最终得到的还只是单态函数。而真正的多态只有在能真正进行类型变量&lt;b&gt;实例化&lt;/b&gt;时才会获得。&lt;/p&gt;&lt;p&gt;所以在具有真正多态的语言中，约束生成和合一是不够的。相反，像ML和Haskell这种语言，甚至我们使用的静态类型语言也是，都实现了俗称&lt;b&gt;let-多态&lt;/b&gt;的东西。这种策略中，当包含类型变量的项在词法环境中被绑定时，该类型被自动提升为量化类型。每次使用时，该项被自动实例化。&lt;/p&gt;&lt;p&gt;很多实现策略可以做到这点。最简单（而不令人满意）的方式只需&lt;b&gt;复制&lt;/b&gt;绑定标识符代码的&lt;b&gt;代码&lt;/b&gt;；这样，上面每次&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的使用都会得到自己的&lt;code class=&quot;inline&quot;&gt;(lambda (x) x)&lt;/code&gt;副本，所以每个都有它自己的类型变量。第一个的类型可能是&lt;code class=&quot;inline&quot;&gt;(&#39;a -&amp;gt; &#39;a)&lt;/code&gt;，第二个是&lt;code class=&quot;inline&quot;&gt;(&#39;b -&amp;gt; &#39;b)&lt;/code&gt;，第三个是&lt;code class=&quot;inline&quot;&gt;(&#39;c -&amp;gt; &#39;c)&lt;/code&gt;，等等。这些类型变量互不冲突，因此我们得到多态的效果。显然，这不仅增加了程序的大小，而且在存在递归的情况下也不起作用。然而，这给我们提供了通往更好解决方案的思路：不是复制代码，而是复制&lt;b&gt;类型&lt;/b&gt;。因此在每次使用时，我们创建推导出类型的重命名版本：第一次使用时，id的类型&lt;code class=&quot;inline&quot;&gt;(&#39;a -&amp;gt; &#39;a)&lt;/code&gt;变成了&lt;code class=&quot;inline&quot;&gt;(&#39;b -&amp;gt; &#39;b)&lt;/code&gt;，以此类推，这种方式实现了拷贝代码相同的效果且没有它的包袱。不过，因为这些策略实质都是效仿代码拷贝，因此它们只能在词法环境下工作。&lt;/p&gt;</description>
<author>MrMathematica</author>
<guid isPermaLink="false">2018-03-30-35115633</guid>
<pubDate>Fri, 30 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Idris 教程中文版正式发布</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-28-35015527.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35015527&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c5246a546163f0bbfd814b28a1dcf606_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;经过一个月（并不）紧张的翻译和校对，&lt;a href=&quot;http://idris-zh.readthedocs.io/zh_CN/latest/tutorial/index.html&quot;&gt;Idris 教程&lt;/a&gt; 正式发布。 自此，官方文档的翻译暂时告一段落。&lt;a href=&quot;http://idris-zh.readthedocs.io/zh_CN/latest/st/index.html&quot;&gt;ST 教程&lt;/a&gt; 的翻译仍在进行中。&lt;/p&gt;&lt;p&gt;官方文档中还有 FAQ、Effect 教程、定理证明和语言参考尚未翻译，然而咱目前又有了别的计划（没错 Idris-zh 又坑了），于是甩锅给社区自然发展好了= =||&lt;/p&gt;&lt;p&gt;Idris 虽然非常漂亮，然而发展还不成熟，缺少一些常用的库和工具。目前她还十分小众，因此 Type-Driven Development with Idris 中文版的引进估计是不可能了。官方教程涉及的点较少，有些不够深入，对初学者也不如这本书友好。因此有条件和能力的读者建议读一下这本书。&lt;/p&gt;&lt;p&gt;如果你有兴趣继续参与翻译，欢迎直接戳咱，随时恭候~！&lt;/p&gt;</description>
<author>Oling Cat</author>
<guid isPermaLink="false">2018-03-28-35015527</guid>
<pubDate>Wed, 28 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（九）：Let polymorphism</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-26-34915143.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34915143&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d8893deacbd14601cc4881797561323d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;500&quot;&gt;&lt;h2&gt;&lt;b&gt;类型变量&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;到目前为止，我们遇到的每一个 &lt;equation&gt;\lambda&lt;/equation&gt; 项都有唯一确定的类型，&lt;br&gt;因为，项的类型都被显式的注释在了它的后面。&lt;br&gt;例如，我们可以定义一个恒等函数 &lt;equation&gt;id=\lambda x:Nat.~x:Nat\to Nat&lt;/equation&gt; ，&lt;br&gt;则 &lt;equation&gt;id&lt;/equation&gt; 的类型就是固定的， &lt;equation&gt;Nat\to Nat&lt;/equation&gt; ，而 &lt;equation&gt;id~true&lt;/equation&gt; 就不是良类型的。&lt;/p&gt;&lt;p&gt;为每一个类型的恒等函数都定义各自的版本，是非常繁琐的，&lt;br&gt;因此，一个自然的想法是，我们能否让 &lt;equation&gt;id&lt;/equation&gt; 的类型&lt;b&gt;参数化&lt;/b&gt;，&lt;br&gt;让它在不同的上下文中，实例化为不同的具体类型。&lt;br&gt;例如， &lt;equation&gt;id=\lambda x:X.~x:X\to X&lt;/equation&gt; ，其中 &lt;equation&gt;X&lt;/equation&gt; 是&lt;b&gt;类型参量&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;类型代换&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;类型代换&lt;/b&gt; &lt;equation&gt;\sigma&lt;/equation&gt; ，指的是一个从类型变量到类型的有限映射。&lt;br&gt;例如， &lt;equation&gt;\sigma=[X\mapsto T,Y\mapsto U]&lt;/equation&gt; ，会将类型变量 &lt;equation&gt;X,Y&lt;/equation&gt; 分别代换为 &lt;equation&gt;T,U&lt;/equation&gt; 。&lt;br&gt;其中， &lt;equation&gt;X,Y&lt;/equation&gt; 称为代换 &lt;equation&gt;\sigma&lt;/equation&gt; 的&lt;b&gt;定义域&lt;/b&gt;，记为 &lt;equation&gt;dom(\sigma)&lt;/equation&gt; ，&lt;br&gt;而 &lt;equation&gt;T,U&lt;/equation&gt; 称为代换 &lt;equation&gt;\sigma&lt;/equation&gt; 的&lt;b&gt;值域&lt;/b&gt;，记为 &lt;equation&gt;range(\sigma)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;值得一提的是，所有的代换都是同时进行的， &lt;equation&gt;\sigma=[X\mapsto Bool,Y\mapsto X\to X]&lt;/equation&gt; ，&lt;br&gt;是将 &lt;equation&gt;X&lt;/equation&gt; 映射成 &lt;equation&gt;Bool&lt;/equation&gt; ，将 &lt;equation&gt;Y&lt;/equation&gt; 映射成 &lt;equation&gt;X\to X&lt;/equation&gt; ，而不是 &lt;equation&gt;Bool\to Bool&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;代换&lt;/b&gt;可以用下面的方式来定义，&lt;br&gt;（1） &lt;equation&gt;\sigma(X)=X&lt;/equation&gt; ，如果 &lt;equation&gt;X\notin dom(\sigma)&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\sigma(X)=T&lt;/equation&gt; ，如果 &lt;equation&gt;(X\mapsto T)\in\sigma&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;\sigma(Nat)=Nat&lt;/equation&gt; ， &lt;equation&gt;\sigma(Bool)=Bool&lt;/equation&gt; &lt;br&gt;（4） &lt;equation&gt;\sigma(T_1\to T_2)=\sigma T_1\to\sigma T_2&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;对于类型上下文 &lt;equation&gt;\Gamma=\{x_1:T_1,\cdots,x_n:T_n\}&lt;/equation&gt; 来说， &lt;equation&gt;\sigma\Gamma=\{x_1:\sigma T_1,\cdots,x_n:\sigma T_n\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;类型代换的一个重要特性是它保留了类型声明的有效性，&lt;br&gt;如果包含类型变量的项是良类型的，那么它的所有代换实例也都是良类型的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;类型推断&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-691c692ba80fac2d4b7d02741c0a3da2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;753&quot; data-rawheight=&quot;496&quot;&gt;&lt;p&gt;在类型上下文 &lt;equation&gt;\Gamma&lt;/equation&gt; 中，对于包含类型变量的项 &lt;equation&gt;t&lt;/equation&gt; ，我们通常会提出两个问题，&lt;/p&gt;&lt;p&gt;（1）它的所有代换实例，是否都是良类型的？&lt;br&gt;即，是否 &lt;equation&gt;\forall\sigma\exists T,\sigma\Gamma\vdash\sigma t:T&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;（2）是否存在良类型的代换实例？&lt;br&gt;即，是否 &lt;equation&gt;\exists\sigma\exists T,\sigma\Gamma\vdash\sigma t:T&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;对于第一个问题，将引出&lt;b&gt;参数化多态&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Parametric_polymorphism&quot;&gt;parametric polymorphism&lt;/a&gt;），&lt;br&gt;例如， &lt;equation&gt;\lambda f:X\to X.\lambda a:X.f(f(a))&lt;/equation&gt; ，它的类型为 &lt;equation&gt;(X\to X)\to X\to X&lt;/equation&gt; ，&lt;br&gt;无论用什么具体类型 &lt;equation&gt;T&lt;/equation&gt; 来代换 &lt;equation&gt;X&lt;/equation&gt; ，代换实例都是良类型的。&lt;/p&gt;&lt;p&gt;对于第二个问题，原始的项可能不是良类型的，&lt;br&gt;但是可以选择合适的类型代换使之实例化为良类型的项。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\lambda f:Y.\lambda a:X.f(f(a))&lt;/equation&gt; ，是不可类型化的，&lt;br&gt;但是如果用 &lt;equation&gt;Nat\to Nat&lt;/equation&gt; 代换 &lt;equation&gt;Y&lt;/equation&gt; ，用 &lt;equation&gt;Nat&lt;/equation&gt; 代换 &lt;equation&gt;X&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\sigma=[X\mapsto Nat,Y\mapsto Nat\to Nat]&lt;/equation&gt; ，&lt;br&gt;就可以得到， &lt;equation&gt;\lambda f:Nat\to Nat.\lambda a:Nat.f(f(a))&lt;/equation&gt; ，&lt;br&gt;可类型化为 &lt;equation&gt;(Nat\to Nat)\to Nat\to Nat&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;或者，取 &lt;equation&gt;\sigma&#39;=[Y\mapsto X\to X]&lt;/equation&gt; ，结果也能得到一个良类型的项，尽管仍包含变量。&lt;/p&gt;&lt;p&gt;在寻找类型变量有效实例的过程中，出现了&lt;b&gt;类型推断&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Type_inference&quot;&gt;type inference&lt;/a&gt;）的概念。&lt;br&gt;意味着由编译器来帮助推断 &lt;equation&gt;\lambda&lt;/equation&gt; 项的具体类型，&lt;br&gt;在&lt;a href=&quot;https://en.wikipedia.org/wiki/ML_(programming_language)&quot;&gt;ML&lt;/a&gt;语言中，程序员可以忽略所有的类型注释——隐式类型（&lt;a href=&quot;http://wiki.c2.com/?ImplicitTyping&quot;&gt;implicit typing&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;在进行推断的时候，对每一个原始的 &lt;equation&gt;\lambda&lt;/equation&gt; 抽象 &lt;equation&gt;\lambda x.t&lt;/equation&gt; ，&lt;br&gt;都用新的类型变量进行注释，写成 &lt;equation&gt;\lambda x:X.t&lt;/equation&gt; ，&lt;br&gt;然后采取特定的类型推导算法，找到使项通过类型检查的一个最一般化的解。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;\Gamma&lt;/equation&gt; 为类型上下文， &lt;equation&gt;t&lt;/equation&gt; 为项，&lt;br&gt; &lt;equation&gt;(\Gamma,t)&lt;/equation&gt; 的&lt;b&gt;解&lt;/b&gt;，是指这样的一个序对 &lt;equation&gt;(\sigma,T)&lt;/equation&gt; ，使得 &lt;equation&gt;\sigma\Gamma\vdash\sigma t:T&lt;/equation&gt; 成立。&lt;/p&gt;&lt;p&gt;例如，设 &lt;equation&gt;\Gamma=f:X,a:Y&lt;/equation&gt; ， &lt;equation&gt;t=f~a&lt;/equation&gt; ，则&lt;br&gt; &lt;equation&gt;(\sigma=[X\mapsto Y\to Nat],Nat)&lt;/equation&gt; ， &lt;equation&gt;(\sigma=[X\mapsto Y\to Z],Z)&lt;/equation&gt; ，都是 &lt;equation&gt;(\Gamma,t)&lt;/equation&gt; 的解。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;基于约束的类型化&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-281fd8e3781690168c07b31e22bc9325_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;333&quot; data-rawheight=&quot;109&quot;&gt;&lt;p&gt;&lt;b&gt;（1）约束集&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在实际情况中， &lt;equation&gt;(\Gamma,t)&lt;/equation&gt; 的解，并不一定满足其他类型表达式的约束条件，&lt;br&gt;所以，我们寻找的是满足这些约束条件的特解。&lt;/p&gt;&lt;p&gt;所谓&lt;b&gt;约束条件&lt;/b&gt;，实际上指的是约束集 &lt;equation&gt;C&lt;/equation&gt; ，&lt;br&gt;它由一些包含类型参量的项的等式构成， &lt;equation&gt;\{S_i=T_i|i\in l..n\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果一个代换 &lt;equation&gt;\sigma&lt;/equation&gt; 的代换实例， &lt;equation&gt;\sigma S&lt;/equation&gt; 和 &lt;equation&gt;\sigma T&lt;/equation&gt; 相同，则称该代换&lt;b&gt;合一&lt;/b&gt;（unify）了等式 &lt;equation&gt;S=T&lt;/equation&gt; 。&lt;br&gt;如果 &lt;equation&gt;\sigma&lt;/equation&gt; 能合一 &lt;equation&gt;C&lt;/equation&gt; 中的所有等式，则称 &lt;equation&gt;\sigma&lt;/equation&gt; 能&lt;b&gt;合一&lt;/b&gt;（unify）或满足（satisfy） &lt;equation&gt;C&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们用 &lt;equation&gt;\Gamma\vdash t:T|_\chi C&lt;/equation&gt; ，来表示约束集 &lt;equation&gt;C&lt;/equation&gt; 满足时，项 &lt;equation&gt;t&lt;/equation&gt; 在 &lt;equation&gt;\Gamma&lt;/equation&gt; 下的类型为 &lt;equation&gt;T&lt;/equation&gt; ，&lt;br&gt;其中 &lt;equation&gt;\chi&lt;/equation&gt; 为约束集中，所有类型变量的集合，有时为了讨论方便可以省略它。&lt;/p&gt;&lt;p&gt;例如，对于项 &lt;equation&gt;t=\lambda x:X\to Y.x~0&lt;/equation&gt; ，&lt;br&gt;约束集可以写为 &lt;equation&gt;\{Nat\to Z=X\to Y\}&lt;/equation&gt; ，则 &lt;equation&gt;t&lt;/equation&gt; 类型为 &lt;equation&gt;(X\to Y)\to Z&lt;/equation&gt; 。（算法略）&lt;br&gt;而代换 &lt;equation&gt;\sigma=[X\mapsto Nat,Z\mapsto Bool,Y\mapsto Bool]&lt;/equation&gt; ，使得等式 &lt;equation&gt;Nat\to Z=X\to Y&lt;/equation&gt; 成立，&lt;br&gt;所以，我们推断出了 &lt;equation&gt;(Nat\to Bool)\to Bool&lt;/equation&gt; 是项 &lt;equation&gt;t&lt;/equation&gt; 的一个可能类型。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）约束集的解&lt;/b&gt;&lt;/p&gt;&lt;p&gt;约束集的解一般不是唯一的，所以一个关键问题是如何确定一个“最好”的解。&lt;/p&gt;&lt;p&gt;我们称代换 &lt;equation&gt;\sigma&lt;/equation&gt; 比 &lt;equation&gt;\sigma&#39;&lt;/equation&gt; &lt;b&gt;更具一般性&lt;/b&gt;（more general），如果 &lt;equation&gt;\sigma&#39;=\gamma\circ\sigma&lt;/equation&gt; ，记为 &lt;equation&gt;\sigma\sqsubseteq\sigma&#39;&lt;/equation&gt; ，&lt;br&gt;其中， &lt;equation&gt;\gamma&lt;/equation&gt; 为一个代换， &lt;equation&gt;\gamma\circ\sigma&lt;/equation&gt; 表示代换的复合， &lt;equation&gt;(\gamma\circ\sigma)S=\gamma(\sigma S)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;约束集 &lt;equation&gt;C&lt;/equation&gt; 的&lt;b&gt;主合一子&lt;/b&gt;（principal unifier）指的是代换 &lt;equation&gt;\sigma&lt;/equation&gt; ，&lt;br&gt;它能满足 &lt;equation&gt;C&lt;/equation&gt; ，且对于所有满足 &lt;equation&gt;C&lt;/equation&gt; 的代换 &lt;equation&gt;\sigma&#39;&lt;/equation&gt; ，都有 &lt;equation&gt;\sigma\sqsubseteq\sigma&#39;&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;(\Gamma,t,S,C)&lt;/equation&gt; 的解 &lt;equation&gt;(\sigma,T)&lt;/equation&gt; ，对于任何其他解 &lt;equation&gt;(\sigma&#39;,T&#39;)&lt;/equation&gt; ，都有 &lt;equation&gt;\sigma\sqsubseteq\sigma&#39;&lt;/equation&gt; ，&lt;br&gt;则称 &lt;equation&gt;(\sigma,T)&lt;/equation&gt; 是一个&lt;b&gt;主解&lt;/b&gt;（principal solution），称 &lt;equation&gt;T&lt;/equation&gt;  为 &lt;equation&gt;t&lt;/equation&gt; 的&lt;b&gt;主类型&lt;/b&gt;（principal type）。&lt;br&gt;可以证明，如果 &lt;equation&gt;(\Gamma,t,S,C)&lt;/equation&gt; 有解，则它必有一个主解。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;let多态&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-98db611b8facd70dd4be4eebdc7e1212_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;633&quot; data-rawheight=&quot;357&quot;&gt;&lt;p&gt;&lt;b&gt;多态&lt;/b&gt;（polymorphism）指的是单独一段程序能在不同的上下文中实例化为不同的类型。&lt;br&gt;其中let多态，是由let表达式引入的多态性。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）单态性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;假设我们定义了一个 &lt;equation&gt;double&lt;/equation&gt; 函数，它能将一个函数对参数应用两次，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:Nat\to Nat.\lambda a:Nat.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~double~(\lambda x:Nat.succ~x)~1&lt;/equation&gt; &lt;br&gt;此时， &lt;equation&gt;double&lt;/equation&gt; 的类型为 &lt;equation&gt;(Nat\to Nat)\to Nat\to Nat&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果我们想将 &lt;equation&gt;double&lt;/equation&gt; 应用于其他类型，就必须重写一个新的 &lt;equation&gt;double&#39;&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;let~double&#39;=\lambda f:Bool\to Bool.\lambda a:Bool.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~double&#39;~(\lambda x:Bool.x)~true&lt;/equation&gt; &lt;br&gt;此时 &lt;equation&gt;double&#39;&lt;/equation&gt; 的类型为 &lt;equation&gt;(Bool\to Bool)\to Bool\to Bool&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们不能让一个 &lt;equation&gt;double&lt;/equation&gt; 函数，既能用于 &lt;equation&gt;Nat&lt;/equation&gt; 类型，又能用于 &lt;equation&gt;Bool&lt;/equation&gt; 类型。&lt;br&gt;即使在 &lt;equation&gt;double&lt;/equation&gt; 中用类型变量也没有用，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in~\cdots&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;例如，如果写，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~let~a=double~(\lambda x:Nat.succ~x)~1~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~~~~~let~b=double~(\lambda x:Bool.x)~true~in~\cdots&lt;/equation&gt; &lt;br&gt;则在 &lt;equation&gt;a&lt;/equation&gt; 定义中使用 &lt;equation&gt;double&lt;/equation&gt; ，会产生一个约束 &lt;equation&gt;X\to X=Nat\to Nat&lt;/equation&gt; ，&lt;br&gt;而在 &lt;equation&gt;b&lt;/equation&gt; 定义中使用 &lt;equation&gt;double&lt;/equation&gt; ，则会产生约束 &lt;equation&gt;X\to X=Bool\to Bool&lt;/equation&gt; ，&lt;br&gt;这样会使类型变量 &lt;equation&gt;X&lt;/equation&gt; 的求解发生矛盾，导致整个程序不可类型化。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）多态性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;let多态所做的事情，就是打破这个限制，&lt;br&gt;让类型参量 &lt;equation&gt;X&lt;/equation&gt; 在上述不同的上下文中，可以分别实例化为 &lt;equation&gt;Nat&lt;/equation&gt; 和 &lt;equation&gt;Bool&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;这需要改变与let表达式相关的类型推导规则，在第七篇中，我们提到过，&lt;br&gt; &lt;equation&gt;\frac{\Gamma\vdash t_1:T_1~~~~\Gamma,x:T_1\vdash t_2:T_2}{\Gamma\vdash let~x:T_1=t_1~in~t_2:T_2}&lt;/equation&gt; &lt;br&gt;它会首先计算 &lt;equation&gt;T_1&lt;/equation&gt; 作为 &lt;equation&gt;x&lt;/equation&gt; 的类型，然后再用 &lt;equation&gt;x&lt;/equation&gt; 来确定 &lt;equation&gt;T_2&lt;/equation&gt; 的类型。&lt;br&gt;此时，let表达式 &lt;equation&gt;let~x=t_1:T_1~in~t_2&lt;/equation&gt; ，可以看做 &lt;equation&gt;(\lambda x:T_1.t_2)t_1&lt;/equation&gt; 的简写。&lt;/p&gt;&lt;p&gt;为了引入多态性，我们需要对上述类型推导规则进行修改，&lt;br&gt; &lt;equation&gt;\frac{\Gamma\vdash[x\mapsto t_1]t_2:T_2}{\Gamma\vdash let~x=t_1~in~t_2:T_2}&lt;/equation&gt; &lt;br&gt;它表示，先将 &lt;equation&gt;t_2&lt;/equation&gt; 中的 &lt;equation&gt;x&lt;/equation&gt; 用 &lt;equation&gt;t_1&lt;/equation&gt; 代换掉，然后再确定 &lt;equation&gt;t_2&lt;/equation&gt; 的类型。&lt;/p&gt;&lt;p&gt;这样的话，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~let~a=double~(\lambda x:Nat.succ~x)~1~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~~~~~let~b=double~(\lambda x:Bool.x)~true~in~\cdots&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;就相当于，&lt;br&gt; &lt;equation&gt;let~a=\lambda f:X\to X.\lambda a:X.f(f(a))~(\lambda x:Nat.succ~x)~1~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~let~b=\lambda f:Y\to Y.\lambda a:Y.f(f(a))~(\lambda x:Bool.x)~true~in~\cdots&lt;/equation&gt; &lt;br&gt;通过let多态，产生了 &lt;equation&gt;double&lt;/equation&gt; 的两个&lt;b&gt;副本&lt;/b&gt;，并为之分配了不同的类型参量。&lt;/p&gt;&lt;p&gt;此时，let表达式 &lt;equation&gt;let~x=t_1~in~t_2&lt;/equation&gt; ，可以看做 &lt;equation&gt;[x\mapsto t_1]t_2&lt;/equation&gt; 的简写。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Let-polymorphism&quot;&gt;Hindley–Milner type system&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1761910/&quot;&gt;Types and programming languages&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.haskell.org/definition/haskell2010.pdf&quot;&gt;Haskell 2010 Language Report&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-26-34915143</guid>
<pubDate>Mon, 26 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（六）：最多有多少个程序</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-14-34484014.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34484014&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上一篇中，我们通过引入极小化算子定义了递归函数，&lt;br&gt;使用递归函数，我们又定义了递归集与递归可枚举集，&lt;br&gt;本文我们要讨论，为什么递归可枚举集是“可枚举”的，以及什么是可计算函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;可计算性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a4af83dc0f3607efe72758004eb1e9f5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;429&quot;&gt;&lt;p&gt;我们听说过，现代计算机在计算能力上是与图灵机等价的，&lt;br&gt;什么叫做计算能力呢？&lt;br&gt;它指的是图灵机可计算的函数集，与现代计算机可计算的函数集是相等的。&lt;/p&gt;&lt;p&gt;为了简单起见，我们不去讨论图灵机，而是从现代计算机直接说起，&lt;br&gt;设 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 是一段程序， &lt;equation&gt;n&lt;/equation&gt; 是一个正整数，&lt;br&gt;我们称数论函数 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 为&lt;b&gt;程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 所计算的&lt;/b&gt; &lt;equation&gt;n&lt;/equation&gt; 元部分函数，&lt;br&gt;如果对于相同的输入，&lt;br&gt;要么：（1）程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的计算可以终止，此时计算结果等于 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 的相应函数值；&lt;br&gt;要么：（2）程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的计算不能终止，此时 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 无定义。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;f(x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 是一个部分函数，&lt;br&gt;如果存在程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 可计算 &lt;equation&gt;f&lt;/equation&gt; ，则称 &lt;equation&gt;f&lt;/equation&gt; 是&lt;b&gt;部分可计算的&lt;/b&gt;。&lt;br&gt;如果一个函数，既是部分可计算的，又是全函数，则称这个函数是&lt;b&gt;可计算的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;可以证明，所有的原始递归函数和递归函数都是部分可计算的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;通用程序&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们使用现代计算机进行编程的时候，并不是直接把程序的输入传给程序，&lt;br&gt;而是将程序本身以及它的输入，传给计算机，最后由计算机得到计算结果，&lt;br&gt;像这种接受任何程序和它的输入作为自己的输入，返回程序执行结果的程序，称为&lt;b&gt;通用程序&lt;/b&gt;。&lt;br&gt;为此，通用程序需要把输入的程序进行&lt;b&gt;编码&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;常用的编码方法，涉及&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%85%8D%E5%AF%B9%E5%87%BD%E6%95%B0&quot;&gt;配对函数&lt;/a&gt;和&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E6%95%B0&quot;&gt;哥德尔编码&lt;/a&gt;。&lt;br&gt;为了不引入太多的复杂性，我们可以将程序的编码理解为存储程序的二进制数据，&lt;br&gt;不同的程序会有不同的二进制表示，每一个二进制表示可以对应一段程序&lt;br&gt;（虽然可能不合法）。&lt;/p&gt;&lt;p&gt;哥德尔编码做的事情就是将程序和自然数集一一对应起来。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9a7c9ce767daf3bef81c5e3e7d5c152e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;565&quot;&gt;&lt;p&gt;因此，所有程序的个数是&lt;b&gt;可数的&lt;/b&gt;，而这些程序可计算的函数个数也一定是可数的，&lt;br&gt;它们可能是全函数，也可能是部分函数。&lt;br&gt;（其中，“可数”指的是可数集，&lt;b&gt;可数集&lt;/b&gt;是与自然数集之间存在一一映射的集合。&lt;/p&gt;&lt;p&gt;然而，自然数集上的函数全体并不可数，（证略&lt;br&gt;所以肯定存在程序不可计算的函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;集合个数的可枚举性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-216f0ef423d8f37598db6eee7ed05452_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;389&quot; data-rawheight=&quot;182&quot;&gt;&lt;p&gt;程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 所计算的函数，我们可以记为 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; ，&lt;br&gt;由此，我们可以定义通用程序 &lt;equation&gt;\Phi&lt;/equation&gt; ，则有，&lt;br&gt; &lt;equation&gt;\Phi (x_1,x_2,\cdots ,x_n,y)=\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; &lt;br&gt;其中， &lt;equation&gt;y&lt;/equation&gt; 是程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的编码。&lt;/p&gt;&lt;p&gt;因为，所有的程序与自然数集一一对应，&lt;br&gt;所以， &lt;equation&gt;\Phi (x_1,x_2,\cdots ,x_n,0),\Phi (x_1,x_2,\cdots ,x_n,1),\cdots&lt;/equation&gt; &lt;b&gt;枚举了所有的 &lt;equation&gt;n&lt;/equation&gt; 元可计算函数。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们定义 &lt;equation&gt;W_y=\lbrace x\in N|\Phi(x,y)\downarrow \rbrace&lt;/equation&gt; ，&lt;br&gt;根据递归可枚举集的定义，每一个 &lt;equation&gt;W_y&lt;/equation&gt; 是一个递归可枚举集。&lt;/p&gt;&lt;p&gt;又因为 &lt;equation&gt;\Phi(x,0),\Phi(x,1),\cdots&lt;/equation&gt; 枚举了所有的可计算函数，&lt;br&gt;而上一篇中我们看到，递归可枚举集是由部分递归函数（即，可计算函数）定义的，&lt;br&gt;一个部分递归函数确定出一个递归可枚举集，&lt;br&gt;所以， &lt;equation&gt;W_0,W_1,\cdots&lt;/equation&gt; &lt;b&gt;枚举了所有的递归可枚举集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;因此，集合 &lt;equation&gt;B&lt;/equation&gt; 是递归可枚举的，当且仅当存在 &lt;equation&gt;y\in N&lt;/equation&gt; ，使得 &lt;equation&gt;B=W_y&lt;/equation&gt; ，&lt;br&gt;称为&lt;b&gt;枚举定理&lt;/b&gt;，这就是“枚举”的含义。&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;K=\lbrace n\in N|n\in W_n\rbrace&lt;/equation&gt; ，&lt;br&gt;则 &lt;equation&gt;K&lt;/equation&gt; 是递归可枚举的，但不是递归的，（证略&lt;br&gt;因此， &lt;equation&gt;\bar{K}&lt;/equation&gt; 不是递归可枚举的，否则 &lt;equation&gt;K&lt;/equation&gt; 就是递归集了。&lt;br&gt;（根据，集合 &lt;equation&gt;B&lt;/equation&gt; 是递归的当且仅当 &lt;equation&gt;B&lt;/equation&gt; 和 &lt;equation&gt;\bar{B}&lt;/equation&gt; 是递归可枚举的，见上一篇&lt;/p&gt;&lt;p&gt;因此，我们找到了一个非递归的递归可枚举集 &lt;equation&gt;K&lt;/equation&gt; ，&lt;br&gt;以及一个非递归可枚举集 &lt;equation&gt;\bar{K}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;停机问题&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2649469b93d96783266c38873773ab78_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;374&quot; data-rawheight=&quot;234&quot;&gt;&lt;p&gt;任给一个程序和一个自然数，问该程序对这个自然数输入的计算是否停止，&lt;br&gt;这个问题称为&lt;b&gt;停机问题&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;我们可以用谓词 &lt;equation&gt;H(x,y)&lt;/equation&gt; 描述这个问题，&lt;br&gt; &lt;equation&gt;H(x,y)&lt;/equation&gt; ，表示以 &lt;equation&gt;y&lt;/equation&gt; 为代码的程序对输入 &lt;equation&gt;x&lt;/equation&gt; 的计算最终停止。&lt;br&gt;那么， &lt;equation&gt;H(x,y)&lt;/equation&gt; 是不可计算的，即，不存在一个程序来计算 &lt;equation&gt;H(x,y)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们来证明一下，假设有一个程序可以计算 &lt;equation&gt;H(x,y)&lt;/equation&gt; ，&lt;br&gt;那么我们就能用它来构造一个新程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; ，它的输入是 &lt;equation&gt;x&lt;/equation&gt; ，&lt;br&gt;这段程序当 &lt;equation&gt;H(x,x)&lt;/equation&gt; 为真时，计算不停止，而当 &lt;equation&gt;H(x,x)&lt;/equation&gt; 为假时，计算停止。&lt;/p&gt;&lt;p&gt;程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 也可以进行编码，假设为 &lt;equation&gt;y_0&lt;/equation&gt; ，现在我们来判断 &lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 为真，意味着编码为 &lt;equation&gt;y_0&lt;/equation&gt; 的程序以 &lt;equation&gt;y_0&lt;/equation&gt; 作为输入最终停止，&lt;br&gt;即程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; ，输入为 &lt;equation&gt;y_0&lt;/equation&gt; 时，最终停止，&lt;br&gt;可是根据 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的定义，此时 &lt;equation&gt;H(x,x)=H(y_0,y_0)&lt;/equation&gt; 为假才会停止，矛盾。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 为假，意味着编码为 &lt;equation&gt;y_0&lt;/equation&gt; 的程序以 &lt;equation&gt;y_0&lt;/equation&gt; 作为参数最终不会停止，&lt;br&gt;即程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; ，输入为 &lt;equation&gt;y_0&lt;/equation&gt; 时，最终不停止，&lt;br&gt;可是根据 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的定义，此时 &lt;equation&gt;H(x,x)=H(y_0,y_0)&lt;/equation&gt; 为真才不会停止，矛盾。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 不能为真也不能为假，矛盾，&lt;br&gt;因此，计算 &lt;equation&gt;H(x,y)&lt;/equation&gt; 的程序&lt;b&gt;不存在&lt;/b&gt;，我们也无法用它来构造程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;可判定性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2b6940df2115ed418d982f28f5263301_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;380&quot;&gt;&lt;p&gt;&lt;b&gt;可判定性问题&lt;/b&gt;，指的是一个询问真或者假的问题是否可以被回答。&lt;br&gt;如果我们总能回答出这个问题是真或者是假，就称该问题是&lt;b&gt;可判定的&lt;/b&gt;，&lt;br&gt;如果我们只能当问题为真的时候确定为真，为假的时候所进行的计算可能不会终止，&lt;br&gt;那么就称该问题是&lt;b&gt;半可判定的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;某元素是否属于一个递归集，是可判定的，&lt;br&gt;某元素是否属于一个递归可枚举集，是半可判定的。&lt;/p&gt;&lt;p&gt;因为，递归集是使用一个递归的全函数定义的，&lt;br&gt;而递归可枚举集是使用第一个部分递归函数定义的，&lt;br&gt;我们无法判断某个部分递归函数，在接受某参数时，是没有定义，还是计算尚未停止。&lt;br&gt;即，判断元素是否属于某递归可枚举集的程序可能永不停机&lt;b&gt;。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了函数的可计算性，通用程序，以及最多有多少个程序，&lt;br&gt;还了解了停机问题和可判定性问题。&lt;/p&gt;&lt;p&gt;这些都是可计算性理论的基础，我们清晰的看到了人类的计算能力，&lt;br&gt;以及用递归所能计算的函数范围，后文中我们开始讨论不动点理论，&lt;br&gt;这同样是一个有趣的话题。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;附&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;配对函数和哥德尔数，是对数偶和有穷数列的一种编码方式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）配对函数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;\langle x,y\rangle=2^x(2y+1)-1&lt;/equation&gt; ，称 &lt;equation&gt;\langle x,y\rangle&lt;/equation&gt; 为&lt;b&gt;配对函数&lt;/b&gt;，它是一个原始递归函数。&lt;/p&gt;&lt;p&gt;任给一个数 &lt;equation&gt;z&lt;/equation&gt; ，存在唯一的一对数 &lt;equation&gt;x&lt;/equation&gt; 和 &lt;equation&gt;y&lt;/equation&gt; ，使得 &lt;equation&gt;\langle x,y\rangle =z&lt;/equation&gt; 。&lt;br&gt; &lt;equation&gt;x&lt;/equation&gt; 是 &lt;equation&gt;z+1&lt;/equation&gt; 含有因子 &lt;equation&gt;2&lt;/equation&gt; 的个数，即使得 &lt;equation&gt;2^t|(z+1)&lt;/equation&gt; 的 &lt;equation&gt;t&lt;/equation&gt; 的最大值。&lt;br&gt; &lt;equation&gt;(z+1)/2^x&lt;/equation&gt; 必为奇数， &lt;equation&gt;y&lt;/equation&gt; 是 &lt;equation&gt;2y+1=(z+1)/2^x&lt;/equation&gt; 的唯一解。&lt;/p&gt;&lt;p&gt;一般的，记 &lt;equation&gt;l(z)=x&lt;/equation&gt; ， &lt;equation&gt;r(z)=y&lt;/equation&gt; ，则 &lt;equation&gt;l(z)&lt;/equation&gt; 和 &lt;equation&gt;r(z)&lt;/equation&gt; 也是原始递归函数。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）哥德尔数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;记 &lt;equation&gt;[a_1,a_2,\cdots ,a_n]=\prod_{i=1}^{n}p_i^{a_i}&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;[a_1,a_2,\cdots ,a_n]&lt;/equation&gt; 称为有穷数列 &lt;equation&gt;(a_1,a_2,\cdots ,a_n)&lt;/equation&gt; 的哥德尔数，其中， &lt;equation&gt;p_i&lt;/equation&gt; 是第 &lt;equation&gt;i&lt;/equation&gt; 个素数。&lt;/p&gt;&lt;p&gt;例如，[ &lt;equation&gt;[2,0,1,3]=2^2\cdot 3^0\cdot 5^1\cdot 7^3=6860&lt;/equation&gt; 。&lt;br&gt;对于每一个固定的 &lt;equation&gt;n&lt;/equation&gt; ， &lt;equation&gt;[a_1,a_2,\cdots ,a_n]&lt;/equation&gt; 是原始递归函数，并且这种编码具有唯一性。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%85%8D%E5%AF%B9%E5%87%BD%E6%95%B0&quot;&gt;配对函数&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E6%95%B0&quot;&gt;哥德尔数&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%95%B8%E9%9B%86&quot;&gt;可数集&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%88%A4%E5%AE%9A%E6%80%A7&quot;&gt;可判定性&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E5%BA%B7%E6%89%98%E5%B0%94%E5%AE%9A%E7%90%86&quot;&gt;康托尔定理&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-14-34484014</guid>
<pubDate>Wed, 14 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>[公告] Idris-zh 中文翻译项目启动</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-07-34328106.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34328106&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-581b50e22da06e58321ea076d8ee5e8e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;Idris 是个通用的依赖类型纯函数式编程语言，比起 Coq 来说更注重现实世界的编程。说起来咱对这货感兴趣还是受了某莎某 be5 和某智猫的影响= =||&lt;/p&gt;&lt;p&gt;其实 Idris 中文文档翻译的坑很早就挖下了，可惜咱能力有限现在才正式启动。目前只翻译了官方教程的第一章，大家可以在 &lt;a href=&quot;http://idris-zh.readthedocs.io/&quot;&gt;Idris-zh 文档主页&lt;/a&gt; 查看。对应的 &lt;a href=&quot;https://github.com/Idris-zh/Idris-dev/tree/master/docs&quot;&gt;Idris-zh 项目地址&lt;/a&gt; 中可以找到源码。&lt;/p&gt;&lt;p&gt;官方文档的量并不算太多，本打算翻译完官方教程再说，不过咱最近忙于考试，加上人多力量大，思来想去还是在魔法店发个公告比较好。有兴趣的译者可以戳咱加入项目组一起翻译。&lt;/p&gt;&lt;p&gt;以上。&lt;/p&gt;</description>
<author>Oling Cat</author>
<guid isPermaLink="false">2018-03-07-34328106</guid>
<pubDate>Wed, 07 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Emacs之魂（七）：变量捕获与卫生宏</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-07-34106490.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34106490&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-be0646e5c6a0b48056bfdf78f3442375_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;843&quot; data-rawheight=&quot;370&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们介绍了宏，它与函数是不同的，函数调用发生在程序执行期间，函数在调用之前，会先对它所有的实参进行求值，然后将形参绑定到这些实参的求值结果上，函数的返回值会作为函数调用表达式的值，Lisp求值器不断的求值表达式，从而程序得以运行。&lt;/p&gt;&lt;p&gt;宏调用（macro call）发生在程序的编译期，或者说，宏调用发生在表达式的求值之前，在执行宏调用的过程中，宏形参直接绑定为实参所代表的语法对象（syntax object）上，宏调用的返回值，会进行表达式替换，将宏调用表达式替换为它的返回值，这个过程称为宏展开（macro expansion），之后在运行时，求值器就不会遇到宏了，所进行求值的只有被展开之后的表达式。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 交互函数&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在介绍常用的宏之前，我们先介绍Emacs中交互函数（interactive function）的概念。&lt;br&gt;交互函数可以使用&lt;code class=&quot;inline&quot;&gt;M-x&lt;/code&gt;在echo area中通过输入函数名进行调用（交互式调用），所以交互函数也称为命令（command）。&lt;br&gt;交互函数也可以被Lisp程序中的其他函数直接调用，这种调用方式称为非交互式调用。&lt;/p&gt;&lt;p&gt;Emacs中函数定义&lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Defining-Functions.html#Defining-Functions&quot;&gt;defun&lt;/a&gt;&lt;/code&gt;包含以下几个部分，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;defun name args [doc] [declare] [interactive] body ...&lt;/code&gt;&lt;p&gt;其中，&lt;code class=&quot;inline&quot;&gt;doc&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;declare&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;interactive&lt;/code&gt;都是可选的。&lt;/p&gt;&lt;p&gt;交互函数的定义中，具有&lt;code class=&quot;inline&quot;&gt;interactive&lt;/code&gt;部分，&lt;br&gt;它是一个形如&lt;code class=&quot;inline&quot;&gt;(interactive arg-descriptor)&lt;/code&gt;的表达式，用来指定该函数被交互调用时的行为，&lt;br&gt;对于非交互式调用，&lt;code class=&quot;inline&quot;&gt;interactive&lt;/code&gt;部分将失去作用。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;arg-descriptor&lt;/code&gt;有三种可能的写法：省略，一个字符串，或者一个Lisp表达式。&lt;br&gt;具体情况可能会比较复杂，可以参考&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Using-Interactive.html#Using-Interactive&quot;&gt;Using-Interactive&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.1 describe-key&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;describe-key&lt;/code&gt;是一个交互函数，用来展示某个快键键相关的文档信息，&lt;br&gt;我们可以使用&lt;code class=&quot;inline&quot;&gt;M-x describe-key&lt;/code&gt;来调用它，echo area中会显示如下内容，等待我们键入一个快捷键，&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e9c4d71238a11558bae673bd850860ce_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;678&quot; data-rawheight=&quot;121&quot;&gt;&lt;p&gt;如果我们键入一个快捷键，例如&lt;code class=&quot;inline&quot;&gt;C-a&lt;/code&gt;，Emacs就会展示出与&lt;code class=&quot;inline&quot;&gt;C-a&lt;/code&gt;相关的文档信息了。我们还可以使用快捷键&lt;code class=&quot;inline&quot;&gt;C-h k&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;C-h k&lt;/code&gt;相当于&lt;code class=&quot;inline&quot;&gt;M-x describe-key&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;C-a runs the command move-beginning-of-line (found in global-map),
which is an interactive compiled Lisp function in ‘simple.el’.

It is bound to C-a.

(move-beginning-of-line ARG)

Move point to beginning of current line as displayed.
(If there’s an image in the line, this disregards newlines
which are part of the text that the image rests on.)

With argument ARG not nil or 1, move forward ARG - 1 lines first.
If point reaches the beginning or end of buffer, it stops there.
To ignore intangibility, bind ‘inhibit-point-motion-hooks’ to t.&lt;/code&gt;&lt;p&gt;&lt;b&gt;1.2 describe-function&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;describe-function&lt;/code&gt;也是一个交互函数，用来展示某个函数（或者宏）相关的文档信息，它绑定到了快捷键&lt;code class=&quot;inline&quot;&gt;C-h f&lt;/code&gt;上，&lt;br&gt;调用后，echo area中会显示如下内容，等待我们输入函数（或者宏）的名字，&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d8c0390d2d4077bcdac4cdd5b810cf44_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;674&quot; data-rawheight=&quot;117&quot;&gt;&lt;p&gt;例如，&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;相关的文档信息如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;when is a Lisp macro in ‘subr.el’.

(when COND BODY...)

If COND yields non-nil, do BODY, else return nil.
When COND yields non-nil, eval BODY forms sequentially and return
value of last one, or nil if there are none.&lt;/code&gt;&lt;p&gt;它指出，&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;是一个宏，并且定义在&lt;code class=&quot;inline&quot;&gt;subr.el&lt;/code&gt;文件中。&lt;/p&gt;&lt;p&gt;鼠标左键点击&lt;code class=&quot;inline&quot;&gt;subr.el&lt;/code&gt;，会打开本地&lt;code class=&quot;inline&quot;&gt;subr.el.gz&lt;/code&gt;文件中&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;的定义，如下，&lt;br&gt;（文件路径为：&lt;code class=&quot;inline&quot;&gt;/Applications/Emacs.app/Contents/Resources/lisp/subr.el.gz&lt;/code&gt;&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(defmacro when (cond &amp;amp;rest body)
  &quot;If COND yields non-nil, do BODY, else return nil.
When COND yields non-nil, eval BODY forms sequentially and return
value of last one, or nil if there are none.
\(fn COND BODY...)&quot;
  (declare (indent 1) (debug t))
  (list &#39;if cond (cons &#39;progn body)))&lt;/code&gt;&lt;p&gt;可见，&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;只是一个语法糖，最终会展开成&lt;code class=&quot;inline&quot;&gt;if&lt;/code&gt;表达式。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;subr.el.gz&lt;/code&gt;文件中包含了很多常用的宏，&lt;br&gt;我们可以访问线上地址&lt;a href=&quot;https://github.com/emacs-mirror/emacs/blob/master/lisp/subr.el&quot;&gt;Github: emacs-mirror/emacs subr.el&lt;/a&gt;进行查阅。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 变量捕获&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;2.1 插入一个绑定&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-52535d0d127c59e76c691246b377b071_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;421&quot; data-rawheight=&quot;334&quot;&gt;&lt;code lang=&quot;emacs&quot;&gt;; -*- lexical-binding: t -*-

(defmacro insert-binding (x)
    `(let ((a 1))
        (+ ,x a)))&lt;/code&gt;&lt;p&gt;以上代码定义了一个宏&lt;code class=&quot;inline&quot;&gt;insert-binding&lt;/code&gt;，它将展开成一个&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;表达式，&lt;br&gt;将&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;插入到一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;值为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;的词法环境中。&lt;/p&gt;&lt;p&gt;其中，`&lt;code class=&quot;inline&quot;&gt;(let ((a 1)) (+ ,x a)))&lt;/code&gt;是反引用表达式，&lt;br&gt;下一篇文章中我们再详细讨论。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;(insert-binding 3)&lt;/code&gt;将展开成，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 1))
    (+ 3 a))    ; 4&lt;/code&gt;&lt;p&gt;然而，如果&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;中包含&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，就会引发歧义，例如，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (insert-binding (+ a 3)))&lt;/code&gt;&lt;p&gt;上式会展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (let ((a 1))
        (+ (+ a 3) a)))    ; 5&lt;/code&gt;&lt;p&gt;我们看表达式&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a))&lt;/code&gt;，&lt;br&gt;其中，左边第一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开之前的词法绑定，即，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (insert-binding (+ a 3)))&lt;/code&gt;&lt;p&gt;而第二个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开式中的词法绑定，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;`(let ((a 1))
        (+ ,x a))&lt;/code&gt;&lt;p&gt;在进行宏定义时，我们并不知道&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;中有没有&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，&lt;br&gt;结果导致了，宏展开式中的词法绑定意外捕获了&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;中的&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在本例中，&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;就是&lt;code class=&quot;inline&quot;&gt;(+ a 3)&lt;/code&gt;，其中&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值本来应该是&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;，&lt;br&gt;结果展开后，被宏展开式所捕获，值变成了&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，&lt;br&gt;我们通过插入一个词法绑定，完成了本例。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 插入一个自由变量&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a5d6fa2b397681d42d4ca20162e8ff13_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;403&quot; data-rawheight=&quot;328&quot;&gt;&lt;code lang=&quot;emacs&quot;&gt;; -*- lexical-binding: t -*-

(let ((a 1))
    (defmacro insert-free (x)
        `(+ ,x a)))&lt;/code&gt;&lt;p&gt;以上代码定义了一个宏&lt;code class=&quot;inline&quot;&gt;insert-free&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;(insert-free 3)&lt;/code&gt;将展开为&lt;code class=&quot;inline&quot;&gt;(+ 3 a)&lt;/code&gt;，其中&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;是自由变量，&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值取决于&lt;code class=&quot;inline&quot;&gt;(insert-free 3)&lt;/code&gt;在何处被展开。&lt;/p&gt;&lt;p&gt;例如，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (insert-free (+ a 3)))&lt;/code&gt;&lt;p&gt;将展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (+ (+ a 3) a))    ; 7&lt;/code&gt;&lt;p&gt;我们再来看表达式&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a))&lt;/code&gt;，&lt;br&gt;其中，左边第一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开之前的词法绑定，即，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (insert-free (+ a 3)))&lt;/code&gt;&lt;p&gt;而第二个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开式中的词法绑定，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 1))
    (defmacro insert-free (x)
        `(+ ,x a)))&lt;/code&gt;&lt;p&gt;在进行宏定义时，虽然我们显式的将&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;绑定为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，&lt;br&gt;但是&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;中包含的绑定，意外影响到了它，使得&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值变成了&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;。&lt;br&gt;我们通过插入一个含自由变量的表达式，让它受展开式所处的位置影响。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3 hygienic macro&lt;/b&gt;&lt;/p&gt;&lt;p&gt;以上两个例子中，插入一个绑定会污染宏展开后的环境，而插入一个自由变量会被宏展开后环境所影响，&lt;br&gt;它们都有变量捕获问题，都不是卫生的（hygienic）。&lt;/p&gt;&lt;p&gt;hygienic macro通常翻译成“卫生宏”，是一种避免变量捕获的技术，&lt;br&gt;如果所使用的宏是卫生的，那么以上两个例子中，最后的求值结果应该都是&lt;code class=&quot;inline&quot;&gt;6&lt;/code&gt;，而不是&lt;code class=&quot;inline&quot;&gt;5&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;7&lt;/code&gt;。&lt;br&gt;卫生宏是一种语言特性，&lt;a href=&quot;http://community.schemewiki.org/?RnRS&quot;&gt;Scheme&lt;/a&gt;中的宏是卫生的，而Emacs Lisp不是。&lt;/p&gt;&lt;p&gt;&lt;b&gt;如果一个宏是卫生的，&lt;/b&gt; &lt;b&gt;那么宏展开式中的所有标识符，仍处于其来源处的词法作用域中。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;（1）例如，根据&lt;code class=&quot;inline&quot;&gt;insert-binding&lt;/code&gt;的定义，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;; -*- lexical-binding: t -*-

(let ((a 1))
    (defmacro insert-free (x)
        `(+ ,x a)))
(let ((a 2))
    (insert-binding (+ a 3)))&lt;/code&gt;&lt;p&gt;将展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (let ((a 1))
        (+ (+ a 3) a)))&lt;/code&gt;&lt;p&gt;其中，&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a)&lt;/code&gt;中，&lt;br&gt;第一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开之前的词法环境，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值为&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;，&lt;br&gt;第二个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏定义式，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，&lt;br&gt;因此，&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a)&lt;/code&gt;求值为&lt;code class=&quot;inline&quot;&gt;6&lt;/code&gt;。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0f0d0d03df4a9d2654648399f00f87d1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;358&quot;&gt;&lt;p&gt;（2）又例，根据&lt;code class=&quot;inline&quot;&gt;insert-free&lt;/code&gt;的定义，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;; -*- lexical-binding: t -*-

(let ((a 1))
    (defmacro insert-free (x)
        `(+ ,x a)))
(let ((a 2))
    (insert-free (+ a 3)))&lt;/code&gt;&lt;p&gt;将展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (+ (+ a 3) a))&lt;/code&gt;&lt;p&gt;同理，&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a)&lt;/code&gt;中，&lt;br&gt;第一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开之前的词法环境，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值为&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;，&lt;br&gt;第二个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏定义式，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，&lt;br&gt;因此，&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a)&lt;/code&gt;的值也为&lt;code class=&quot;inline&quot;&gt;6&lt;/code&gt;。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d506193ef43253a3bd3b2ed80fc56297_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;352&quot;&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了交互函数，介绍了如何查看一个函数或者宏的文档和定义，&lt;br&gt;一些常用的宏，都可以通过查看&lt;code class=&quot;inline&quot;&gt;subr.el&lt;/code&gt;来找到它们。&lt;br&gt;然后，我们介绍了两种与宏相关的变量捕获问题，引出了卫生宏的概念。&lt;/p&gt;&lt;p&gt;下文，我们继续讨论宏，来看一看展开为宏定义的宏之强大威力。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/elisp.html&quot;&gt;GNU Emacs Lisp Reference Manual&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1432683/&quot;&gt;On Lisp&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/3864436/&quot;&gt;Let Over Lambda&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;http://www.scheme.com/tspl4/&quot;&gt;The Scheme Programming Language&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-07-34106490</guid>
<pubDate>Wed, 07 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>区块链与函数式编程</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-06-34287276.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34287276&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;区块链是对软件正确性要求极高的领域。过去软件bug和安全漏洞带来的损失，一般就是停机维护，被拖个库就已经是很重大的影响了。而区块链软件的漏洞被利用，那将是灾难性的，因为上面跑的都是真金白银。随着区块链技术对传统经济领域渗透的加深，这种风险将会大大提升。&lt;/p&gt;&lt;p&gt;传统软件工程只重视产品的快速上线快速迭代，从来没有把软件的正确性摆在一个优先级很高的位置，究其根本还是传统领域软件出bug带来的成本不高。&lt;/p&gt;&lt;p&gt;行业里其实已经有一些关键领域是对软件的正确性要求极高的，比如航天系统，金融领域一些核心系统等。1962年软件bug造成火箭偏航，损失1850万美元；1978年CAD软件bug造成体育竞技场倒塌，损失上亿美元；1985年放射机软件bug导致病人受到大量辐射，1987年金融交易软件bug导致美国股灾，等等。&lt;/p&gt;&lt;p&gt;这些问题促使人们去思考如何保证软件正确性，而这些年来业界针对这种对软件正确性要求高的领域，也确实发展了一套技术手段来支持，形式验证、类型系统、纯函数式编程等。这些方法对程序员要求更高，开发时间也更长，所以在大部分编程领域，这种方法显得不是那么经济，换句话说大部分程序员其实并不了解这个领域的技术。而现在传统程序员开始进入区块链软件的开发，如果不能在思维、流程、工具各方面作出相应调整的话，是很危险的事情。&lt;/p&gt;&lt;p&gt;但是真正的形式验证成本巨大，只好用来解决一些最核心的问题。而另一种同时兼顾实用性的方案是函数式编程（函数式编程这个词语这些年有些定义模糊，这里特指静态类型纯函数式语言，基本上就是ML一族的语言），而Haskell是其中的佼佼者，也是Cardano项目使用的开发语言。&lt;/p&gt;&lt;p&gt;Haskell是一门 &lt;i&gt;纯函数式&lt;/i&gt; &lt;i&gt;静态类型&lt;/i&gt; 惰性求值的语言，这里关键字有几个：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;纯函数式是说，函数除了将输入转换为输出以外，不能有其他副作用（比如执行IO操作、修改全局变量、或者发射个导弹啥的），并且对于相同的输入永远返回相同的输出。这意味着不存在变量的概念，数据结构也都是immutable的。显然这样的函数会有很多良好的性质：好测试, 线程安全, 代码可重用, 可读性强等等。另外这样的代码还有一个性质是可证明，因为你可以机械地把函数的调用替代成函数的实现，而不改变其语意，所以你可以形式地证明比如说两个函数等价。还有一些其他的好处，比如一些代码重构工具能够自动调整代码，编译器也可以更激进地对代码进行优化，因为他们能够确保对程序的语意没有影响。&lt;br&gt;如果在*纯*的基础上，再加上total的约束，那就更好了，total是说函数对参数的所有取值都有定义，相对应的partial的函数可能对某些输入没有定义。 不过有点遗憾的是，函数是否total无法静态地检测出来，因为从程序语意的角度，未定义和死循环是一样的，所以检测total性和停机问题是一样的。 （但是如果我们愿意牺牲图灵完备性的话，是可以支持total检查的，这样的语言里可以没有死循环和partial函数， 智能合约语言就非常需要这样的设计，而智能合约语言 &lt;a href=&quot;https://blockstream.com/2017/10/30/simplicity.html&quot;&gt;Simplicity&lt;/a&gt; 正是这么设计的）&lt;/li&gt;&lt;li&gt;静态类型系统，按照“柯里-霍华德同构”定理，类型对应于命题，而程序对应于证明。当我们把问题的模型编码成类型后，编译器通过类型检查可以保证程序的正确性。在实践中，类型是可以逐步细化的，越细化，能够通过编译的实现就越少，甚至可能细化到只剩下一个有意义的实现，这种情况下甚至可以通过工具实现自动生成实现代码。类型系统还带来其他一些便利的工具，比如hoogle，可以根据类型签名搜索现有库提供的函数实现。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;关于Haskell语言其实可以说的还有很多，未来会继续写一些具体的编程模式，尤其是与区块链相关的，以及它在Cardano项目中的具体实践，敬请期待。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;更正：Plutus还是图灵完备的语言，已经改成Simplicity。&lt;/p&gt;</description>
<author>黄毅</author>
<guid isPermaLink="false">2018-03-06-34287276</guid>
<pubDate>Tue, 06 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>柯里化的前生今世（八）：尾调用与CPS</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-02-34064655.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34064655&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;关于&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文是系列文章中的第八篇，发布在&lt;a href=&quot;https://zhuanlan.zhihu.com/c_166576777&quot;&gt;业余程序员的个人修养&lt;/a&gt;这个专栏中：&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34060802&quot;&gt;柯里化的前生今世（一）：函数面面观&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34063576&quot;&gt;柯里化的前生今世（二）：括号神教&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34063805&quot;&gt;柯里化的前生今世（三）：语言和同像性&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34064164&quot;&gt;柯里化的前生今世（四）：编译器与解释器&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34064286&quot;&gt;柯里化的前生今世（五）：动态作用域&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34064446&quot;&gt;柯里化的前生今世（六）：词法作用域和闭包&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34064549&quot;&gt;柯里化的前生今世（七）：first-class continuation&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在上一篇中，我们介绍了continuation的概念，还介绍了Lisp中威力强大的&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;，它提供了first-class continuation，最后我们用&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;实现了python中的generator和yield。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;赋予了我们很强的表达能力，Lisp中的异常处理机制也很人性化。&lt;br&gt;例如，&lt;a href=&quot;https://en.wikipedia.org/wiki/Common_Lisp#Condition_system&quot;&gt;Common Lisp: Condition_system&lt;/a&gt;，&lt;br&gt;由于&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;可以捕捉到异常处的continuation，&lt;br&gt;我们就可以手动调用这个continuation，&lt;br&gt;让程序从错误的位置以给定状态重新开始执行，&lt;br&gt;甚至结合&lt;a href=&quot;https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop&quot;&gt;REPL&lt;/a&gt;还可以询问用户，让用户输入这个状态。&lt;/p&gt;&lt;p&gt;其他语言的&lt;code class=&quot;inline&quot;&gt;try/catch&lt;/code&gt;是无法做到这一点的，&lt;br&gt;我们拿到错误时，出现错误的那个环境已经被丢弃了，无法恢复，&lt;br&gt;那么除了提示用户程序崩溃了就没有别的办法了。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;这么强大，更坚定了我们实现它的想法，&lt;br&gt;本文就从实现的角度来看&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;尾调用&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;In computer science, a tail call is a subroutine call performed as the final action of a procedure. &lt;/blockquote&gt;&lt;p&gt;如果在某个函数的末尾调用了另一个函数，这个调用就称为尾调用。&lt;br&gt;我们举个例子吧，&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (f a)
  (display a)
  (g 2))

(define (g b)
  (display b))

(f 1)&lt;/code&gt;&lt;p&gt;我们看到，函数&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的末尾调用了函数&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;(g 2)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;尾调用有什么好处呢？&lt;br&gt;一个基本的事实是，如果&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的尾调用，&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;就可以不返回到&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;中，&lt;br&gt;而直接返回到&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;该返回的地方。&lt;/p&gt;&lt;p&gt;因为&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的尾调用，&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;后面没有其他调用了，&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;(g 2)&lt;/code&gt;调用结束后就可以不必返回到&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的函数体中了，而是直接返回到&lt;code class=&quot;inline&quot;&gt;(f 1)&lt;/code&gt;处。&lt;br&gt;因此，调用&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的时候，调用栈可以不增加，而是直接废弃&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的调用环境即可。&lt;/p&gt;&lt;p&gt;注意，我们上面提到的是『不必返回到&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的函数体中』，&lt;br&gt;因为不是每个语言都可以做到这一点，&lt;br&gt;这个语言特性，称为尾调用优化（tail call optimization）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;调用栈和调用图&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;调用栈对我们来说是一个耳熟能详的名词，&lt;br&gt;可是我们有没有考虑过，为什么调用构成了一个『栈』呢？&lt;br&gt;有这么多的数据结构，为什么不是一个队列，不是一个树，不是一个图呢？&lt;/p&gt;&lt;p&gt;是因为函数的调用和返回机制，恰好可以用帧（frame）的压栈和弹栈来描述。&lt;br&gt;可是，尾调用优化，开始动摇了这一点，&lt;br&gt;为了能返回到调用者该返回的地方，调用栈有的时候可能会弹出两次，或者弹出更多次。&lt;/p&gt;&lt;p&gt;进一步，我们再来看call/cc的场景，它使得程序可以直接跳转到之前的某个状态，&lt;br&gt;根本上改变了压栈弹栈的规则，跳过去以后，以全新的状态重新开始执行。&lt;br&gt;然而，发生跳转时的状态还不能丢弃，因为有可能再跳回来。&lt;br&gt;因此，call/cc让调用不再构成一个栈，而是构成了一个调用图。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fe4f369ec3c287b75e28c710accccc64_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;466&quot; data-rawheight=&quot;336&quot;&gt;&lt;h2&gt;&lt;b&gt;CPS&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在这些复杂场景中，为了能显式的表示执行过程，&lt;br&gt;将程序转化为CPS（continuation passing style）是一种常用的办法，&lt;br&gt;CPS是一种程序的书写风格，经常作为编译器的一种中间表示。（&lt;a href=&quot;https://en.wikipedia.org/wiki/Intermediate_representation&quot;&gt;IR&lt;/a&gt;&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;; 调用风格
(define (f x)
  (+ (g x) 1))

(define (g x)
  (* x 2))

(f 1)

; CPS
(define (f x cont)
  (g x (lambda (v)
         (cont (+ v 1)))))

(define (g x cont)
  (cont (* x 2)))

(f 1 display)&lt;/code&gt;&lt;p&gt;我们发现写成CPS之后，每个函数多了一个&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;参数，&lt;br&gt;用来表示该函数调用表达式的continuation，&lt;br&gt;我们调用一个函数，就应该把它相应的continuation显式的传给它。&lt;br&gt;例如，我们在&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;中调用了&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;，那么我们就将&lt;code class=&quot;inline&quot;&gt;(g x)&lt;/code&gt;的continuation传给了&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;，即&lt;code class=&quot;inline&quot;&gt;(lambda (v) (cont (+ v 1)))&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;除此之外，我们还发现，CPS是一个尾调用形式，&lt;br&gt;因此程序的执行就变成了continuation的不断变换生长。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;开始动手术&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;为了实现call/cc，首先我们要把解释器改造成CPS形式，&lt;br&gt;然后再将continuation拿出来包装一下，提供给用户使用。&lt;/p&gt;&lt;p&gt;我们先进行第一步改造，CPS，&lt;br&gt;回忆一下，为了实现词法作用域，我们给解释器中每个函数末尾加上了参数&lt;code class=&quot;inline&quot;&gt;env&lt;/code&gt;，用于表示被求值表达式的环境。这次也相似，我们给每个函数加上了新的参数&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;，用于表示被求值表达式的continuation，这样我们就可以将解释器改造成CPS形式了。&lt;/p&gt;&lt;p&gt;下一步改造我们要实现call/cc了，它直接使用了这些包含&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;参数的函数，限于篇幅，CPS形式的解释器我们就略过了，这里我们只是先看一下&lt;code class=&quot;inline&quot;&gt;handle-decision-tree&lt;/code&gt;的样子吧，&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (handle-decision-tree tree exp env cont)
  (if (null? tree)
      (error &#39;handle-decision-tree &quot;failed to make decision&quot;)
      (let* ((head (car tree))
             (predicator (car head))
             (decision (cadr head)))

        (predicator exp env 
                    (lambda (predicate-result)
                      (if predicate-result
                          (if (not (list? decision))
                              (decision exp env cont)
                              (handle-decision-tree decision exp env cont))
                          (handle-decision-tree (cdr tree) exp env cont)))))))&lt;/code&gt;&lt;h2&gt;&lt;b&gt;实现call/cc&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;将解释器转换成CPS之后，我们就可以将&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;进行包装了，&lt;br&gt;下面的实现中，我们将&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;包装成了一个内部的数据结构&lt;code class=&quot;inline&quot;&gt;continuation&lt;/code&gt;。&lt;br&gt;（和闭包一样，continuation从实现的角度来看也是一个数据结构&lt;/p&gt;&lt;p&gt;然后，把这个数据结构提供给用户，就可以让用户代码实现自定义跳转了。&lt;br&gt;为了实现这一点，我们在解释器中判断是否调用了continuation，来做相应的处理。&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;handle-decision-tree&lt;/code&gt;增加了两个分支，&lt;code class=&quot;inline&quot;&gt;is-continuation?&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;is-continuation-call?&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang racket

; tool

(struct closure 
  (param body env))

(struct continuation 
  (cont))

(define (create-frame)
  (make-hash))

(define (extend-frame frame key value)
  (hash-set! frame key value))

(define (extend-env env frame)
  (cons frame env))

(define (get-symbol-value env key)
  (let lookup-env
    ((env env))
    (if (null? env)
        (error &#39;get-symbol-value &quot;failed to find symbol&quot;)
        (let ((head-frame (car env)))
          (if (hash-has-key? head-frame key)
              (hash-ref head-frame key &#39;())
              (lookup-env (cdr env)))))))

(define (handle-decision-tree tree exp env cont)
  (if (null? tree)
      (error &#39;handle-decision-tree &quot;failed to make decision&quot;)
      (let* ((head (car tree))
             (predicator (car head))
             (decision (cadr head)))

        (predicator exp env 
                    (lambda (predicate-result)
                      (if predicate-result
                          (if (not (list? decision))
                              (decision exp env cont)
                              (handle-decision-tree decision exp env cont))
                          (handle-decision-tree (cdr tree) exp env cont)))))))

; env &amp;amp; cont

(define *env* `(,(create-frame)))

(define *cont* (lambda (v)
                 (display v)))

; main

(define (eval-exp exp env cont)
  (handle-decision-tree 
   `((,is-symbol? ,eval-symbol)
     (,is-self-eval-exp? ,eval-self-eval-exp)
     (,is-continuation? ,eval-continuation)
     (,is-list?
      ((,is-lambda? ,eval-lambda)
       (,is-call/cc? ,eval-call/cc)
       (,is-continuation-call? ,eval-continuation-call)
       (,is-function-call-list? ,eval-function-call-list))))
   exp env cont))

(define (is-symbol? exp env cont)
  (display &quot;is-symbol?\n&quot;)
  (cont (symbol? exp)))

(define (eval-symbol exp env cont)
  (display &quot;eval-symbol\n&quot;)
  (cont (get-symbol-value env exp)))

(define (is-self-eval-exp? exp env cont)
  (display &quot;is-self-eval-exp?\n&quot;)
  (cont (number? exp)))

(define (eval-self-eval-exp exp env cont)
  (display &quot;eval-self-eval-exp\n&quot;)
  (cont exp))

(define (is-continuation? exp env cont)
  (display &quot;is-continuation?\n&quot;)
  (cont (continuation? exp)))

(define (eval-continuation exp env cont)
  (display &quot;eval-continuation\n&quot;)
  (cont exp))

(define (is-list? exp env cont)
  (display &quot;is-list?\n&quot;)
  (cont (list? exp)))

(define (is-lambda? exp env cont)
  (display &quot;is-lambda?\n&quot;)
  (cont (eq? (car exp) &#39;lambda)))

(define (eval-lambda exp env cont)
  (display &quot;eval-lambda\n&quot;)
  (let ((param (caadr exp))
        (body (caddr exp)))
    (cont (closure param body env))))

(define (is-call/cc? exp env cont)
  (display &quot;is-call/cc?\n&quot;)
  (cont (eq? (car exp) &#39;call/cc)))

(define (eval-call/cc exp env cont)
  (display &quot;eval-call/cc\n&quot;)
  (let ((fn (cadr exp))
        (data-cont (continuation cont)))
    (eval-function-call-list `(,fn ,data-cont) env cont)))

(define (is-continuation-call? exp env cont)
  (display &quot;is-continuation-call?\n&quot;)
  (eval-exp (car exp) env
            (lambda (value)
              (cont (continuation? value)))))

(define (eval-continuation-call exp env cont)
  (display &quot;eval-continuation-call\n&quot;)
  (eval-exp (car exp) env
            (lambda (data-cont)
              (let ((wrapped-cont (continuation-cont data-cont)))
                (eval-exp (cadr exp) env
                          (lambda (arg)
                            (wrapped-cont arg)))))))

(define (is-function-call-list? exp env cont)
  (display &quot;is-function-call-list?\n&quot;)
  (cont #t))

(define (eval-function-call-list exp env cont)
  (display &quot;eval-function-call-list\n&quot;)
  (eval-exp (car exp) env
            (lambda (clos)
              (eval-exp (cadr exp) env
                        (lambda (arg)
                          (let ((body (closure-body clos))
                                (lexical-env (closure-env clos))
                                (param (closure-param clos))

                                (frame (create-frame)))

                            (extend-frame frame param arg)

                            (let ((executing-env (extend-env lexical-env frame)))
                              (eval-exp body executing-env cont))))))))&lt;/code&gt;&lt;p&gt;&lt;b&gt;注：&lt;/b&gt;其中&lt;code class=&quot;inline&quot;&gt;eval-call/cc&lt;/code&gt;，调用了&lt;code class=&quot;inline&quot;&gt;eval-function-call-list&lt;/code&gt; ，&lt;br&gt;这将导致这个表达式&lt;code class=&quot;inline&quot;&gt;(call/cc (lambda (k) (call/cc k)))&lt;/code&gt; 无法解释执行。&lt;br&gt;（感谢 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6c0662069049e4fb6960a77beebf4a9b&quot; data-hash=&quot;6c0662069049e4fb6960a77beebf4a9b&quot; data-hovercard=&quot;p$b$6c0662069049e4fb6960a77beebf4a9b&quot;&gt;@御坂黒子&lt;/a&gt; 指出错误。。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (eval-call/cc exp env cont)
  (display &quot;eval-call/cc\n&quot;)
  (let ((fn (cadr exp))
        (data-cont (continuation cont)))
    (eval-function-call-list `(,fn ,data-cont) env cont)))&lt;/code&gt;&lt;h2&gt;&lt;b&gt;测试&lt;/b&gt;&lt;/h2&gt;&lt;code lang=&quot;racket&quot;&gt;(eval-exp &#39;1 *env* *cont*)

(display &quot;\n\n&quot;)
(eval-exp &#39;(lambda (x) x) 
          *env* *cont*)

(display &quot;\n\n&quot;)
(eval-exp &#39;((lambda (x) x) 
            1) 
          *env* *cont*)

(display &quot;\n\n&quot;)
(eval-exp &#39;((lambda (x)
              ((lambda (y) x)
               2))
            1) 
          *env* *cont*)

(display &quot;\n\n&quot;)
(eval-exp &#39;((lambda (x)
              ((lambda (f)
                 ((lambda (x)
                    (f 3))
                  2))
               (lambda (z) x)))
            1)
          *env* *cont*)

(display &quot;\n\n&quot;)
(eval-exp &#39;(call/cc (lambda (k)
                      1))
          *env* *cont*)

(display &quot;\n\n&quot;)
(eval-exp &#39;(call/cc (lambda (k)
                      (k 2)))
          *env* *cont*)&lt;/code&gt;&lt;h2&gt;&lt;b&gt;要点分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;（1）&lt;code class=&quot;inline&quot;&gt;eval-call/cc&lt;/code&gt;时会创建一个&lt;code class=&quot;inline&quot;&gt;continuation&lt;/code&gt;，&lt;br&gt;然后用这个&lt;code class=&quot;inline&quot;&gt;continuation&lt;/code&gt;作为参数调用&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;的参数。&lt;br&gt;（&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;的参数，就是后面的&lt;code class=&quot;inline&quot;&gt;(lambda (k) 1)&lt;/code&gt;，因此&lt;code class=&quot;inline&quot;&gt;k&lt;/code&gt;就是这个&lt;code class=&quot;inline&quot;&gt;continuation&lt;/code&gt;&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;; (call/cc (lambda (k) 1))

(define (eval-call/cc exp env cont)
  (display &quot;eval-call/cc\n&quot;)
  (let ((fn (cadr exp))
        (data-cont (continuation cont)))
    (eval-function-call-list `(,fn ,data-cont) env cont)))&lt;/code&gt;&lt;p&gt;（2）&lt;code class=&quot;inline&quot;&gt;eval-continuation-call&lt;/code&gt;会解开&lt;code class=&quot;inline&quot;&gt;continuation&lt;/code&gt;的包装，得到内部包含的&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;，&lt;br&gt;然后用这个&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;作为参数求值表达式，&lt;br&gt;这样就实现了，表达式求值完以后跳转到产生&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;位置的效果。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (eval-continuation-call exp env cont)
  (display &quot;eval-continuation-call\n&quot;)
  (eval-exp (car exp) env
            (lambda (data-cont)
              (let ((wrapped-cont (continuation-cont data-cont)))
                (eval-exp (cadr exp) env
                          (lambda (arg)
                            (wrapped-cont arg)))))))&lt;/code&gt;&lt;p&gt;（3）&lt;code class=&quot;inline&quot;&gt;(call/cc ...)&lt;/code&gt;表达式中，如果&lt;code class=&quot;inline&quot;&gt;k&lt;/code&gt;没有被调用，那么&lt;code class=&quot;inline&quot;&gt;(call/cc ...)&lt;/code&gt;的值，就是&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;参数函数的返回值，即&lt;code class=&quot;inline&quot;&gt;(call/cc (lambda (k) 1)) = 1&lt;/code&gt;。&lt;br&gt;这一点看起来很难实现，实则不然。&lt;/p&gt;&lt;p&gt;我们只需要巧妙的指定&lt;code class=&quot;inline&quot;&gt;(lambda (k) 1)&lt;/code&gt;的continuation，&lt;br&gt;让它就是&lt;code class=&quot;inline&quot;&gt;(call/cc (lambda (k) 1))&lt;/code&gt;的continuation即可。&lt;br&gt;这一点体现在&lt;code class=&quot;inline&quot;&gt;eval-call/cc&lt;/code&gt;中，我们直接将&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;原封不动的传给了&lt;code class=&quot;inline&quot;&gt;eval-function-call-list&lt;/code&gt;&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (eval-call/cc exp env cont)
   ...
    (eval-function-call-list `(,fn ,data-cont) env cont)))&lt;/code&gt;&lt;h2&gt;&lt;b&gt;下文&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Lisp语言真是博大精深，写到这里我们甚至还没有提及它最重要的语言特性——宏，&lt;br&gt;Lisp宏提供了一种元编程的手段，&lt;a href=&quot;http://www.jianshu.com/p/1031cd06b172&quot;&gt;同像性&lt;/a&gt;让Lisp元编程异常强大，&lt;br&gt;然而，把宏说清楚也颇费笔墨，因此，我打算在适当的时候单独讨论它。&lt;/p&gt;&lt;p&gt;本系列标题为『柯里化的前生今世』，意在通过柯里化引入种种有趣的概念，&lt;br&gt;目前为止，我们讨论了高阶函数，闭包，continuation，这些可以看做『柯里化的前生』，&lt;br&gt;我们不但理解了这些概念，还实现了它们，算是小有收获吧。&lt;/p&gt;&lt;p&gt;使用Racket也有一段日子了，对它也逐渐从陌生到熟悉，&lt;br&gt;可是偏执却容易让人误入歧途，错过其他风景，&lt;br&gt;下文我们将开启新的旅程了，Let&#39;s go !&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.scheme.com/tspl4/further.html#./further:h4&quot;&gt;continuation passing style&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1762126/&quot;&gt;Compiling with Continuations&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;ftp://ftp.cs.utexas.edu/pub/garbage/cs345/schintro-v14/schintro_toc.html&quot;&gt;An Introduction to Scheme and its Implementation&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-02-34064655</guid>
<pubDate>Fri, 02 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>从字符串到能用的数据结构到底有多远？——Haskell的Parsec实战</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-02-28-34103708.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34103708&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先，为什么要用Parsec解析文本而不是正则表达式？在其它语言中，将内容分割成数组，用正则表达式来解析内容是普遍存在的。在Haskell中也可以沿着这一条路线走下去。但Parsec是一个更好的方式。看了Parsec之后我就用Parsec解析JSON文本（作为学习），从字符串到JSON类型没有想像中的那么远，以后再也不用害怕字符串了。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Parsec简介&lt;/h2&gt;&lt;p&gt;依赖包： - parsec&lt;/p&gt;&lt;p&gt;必要的引入： import qualified Text.Parsec as P&lt;/p&gt;&lt;p&gt;定义：type P.Parsec s u = P.ParsecT s u Identity :: * -&amp;gt; *&lt;/p&gt;&lt;p&gt;Parsec是ParsecT的一个简写,ParsecT主要是以下类型类的实例&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;instance [safe] A.Alternative (P.ParsecT s u m)
  -- Defined in ‘Text.Parsec.Prim’
instance [safe] Applicative (P.ParsecT s u m)
  -- Defined in ‘Text.Parsec.Prim’
instance [safe] Functor (P.ParsecT s u m)
  -- Defined in ‘Text.Parsec.Prim’
instance [safe] Monad (P.ParsecT s u m)
  -- Defined in ‘Text.Parsec.Prim’
instance [safe] (Monoid a,
                 Data.Semigroup.Semigroup (P.ParsecT s u m a)) =&amp;gt;
                Monoid (P.ParsecT s u m a)
&lt;/code&gt;&lt;p&gt;以下只列出关键点&lt;br&gt;Alternative : 可以使用&amp;lt;|&amp;gt;来表达『逻辑或』的关系。&lt;br&gt;Applicative: 可以使用pure，&amp;lt;*&amp;gt; ，&amp;lt;*，&lt;b&gt;*&lt;/b&gt;&amp;gt; 函数，可以更改容器内的值。&lt;/p&gt;&lt;p&gt;Functor: 一般我用&amp;lt;$&amp;gt;替代fmap函数，另外还有一个有用的函数&amp;lt;$ 用于更改容器内的值&lt;br&gt;Monad: do 语句块&lt;br&gt;当然上面列的不全，ParsecT也是一个MonadTrans ，可以嵌入Monad(如最常用的IO)用lift升格。&lt;br&gt;&lt;/p&gt;&lt;p&gt;Parsec  s u a : s是源（也就是要解析的文本）类型，u是用户状态类型，a是结果&lt;/p&gt;&lt;p&gt;&lt;b&gt;Parsec一些关键的函数（常用的函数）&lt;br&gt;&lt;/b&gt;&lt;br&gt;P.parse 解析入口函数&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;P.parse                                                                      
  :: P.Stream s Identity t =&amp;gt;                                                 
     P.Parsec s () a -&amp;gt; P.SourceName -&amp;gt; s -&amp;gt; Either P.ParseError a 
&lt;/code&gt;&lt;p&gt;parse Parsec 源文件名字（解析失败时用来定位文件）  待解析文本  -&amp;gt; Either &lt;br&gt;&lt;br&gt;P.char、P.oneOf、P.digit、P.string、P.noneOf 、P.anyChar等都会返回Parsec用来解析 一个字符、多个字符之一、数字、字符串、非多个字符之一、任意字符等。&lt;/p&gt;&lt;p&gt;P.many  Parsec 解析零个或多个Parsec直到解析失败&lt;br&gt;P.many1  Parsec 至少解析一个或者多个&lt;br&gt;P.skipMany、P.skipMany1 与上面many、many1一样只不过忽略返回结果&lt;br&gt;P.sepBy  a b 用parsec b来分割parsec a（如解析1,12,34,4以固定字符隔开的token）&lt;br&gt;P.lookAhead Parsec 主要作用是不产生消耗还会给你结果&lt;br&gt;P.try 由于 a&amp;lt;|&amp;gt;b只对第一个字符做判断如果第一个字符成功了就返回a而不管整体失败与否,try是为了整体失败走b&lt;/p&gt;&lt;p&gt;P.eof 表示文件结尾的Parsec&lt;/p&gt;&lt;p&gt;了解了上面这些函数，类型类就可以完成解析JSON字符串的任务了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;JSON解析&lt;/h2&gt;&lt;p&gt;解析之前，一般我会先定义适用于JSON的模型&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Number&#39; = Int Int | Float Float deriving Show
data JSON = Null
  | Number Number&#39;
  | String String
  | Bool Bool
  | Undefined
  | Object [(String ,JSON)]
  | List [JSON]
  deriving (Show)&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;写好『骨架』&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;parse :: String -&amp;gt; Either P.ParseError JSON
parse text = P.parse jsonParsec &quot;JSON:&quot; text

jsonParsec :: P.Parsec String () JSON
jsonParsec = P.spaces *&amp;gt; myParsec &amp;lt;* P.spaces &amp;lt;* P.eof &lt;/code&gt;&lt;p&gt;parse使用jsonParsec解析text, P.spaces表示空白字符，前后可有任意空白字符最终返回myParsec（*&lt;b&gt;&amp;gt;、&amp;lt;&lt;/b&gt;* 函数来自于Applicative）&lt;br&gt;&lt;/p&gt;&lt;h2&gt;解析Null,和undefined&lt;/h2&gt;&lt;code lang=&quot;haskell&quot;&gt;myParsec = nullParsec
  &amp;lt;|&amp;gt; undefinedParsec

undefinedParsec = Undefined &amp;lt;$ P.string &quot;undefined&quot;
nullParsec = P.string &quot;null&quot; &amp;gt;&amp;gt; return Null&lt;/code&gt;&lt;p&gt;myParsec:  &amp;lt;|&amp;gt;函数来自Alternative，如果NullParsec解析失败就用undefinedParsec解析&lt;br&gt;undefinedParsec : &amp;lt;$来自Functor ，如果解析成功容器内部的值改为Undefined&lt;/p&gt;&lt;p&gt;nullParsec : &amp;gt;&amp;gt; 来自Monad , 如果解析成功内部值改为Null。和undefinedParsec的功能相同。&lt;/p&gt;&lt;p&gt;现在可以运行parse函数，输入null,undefined得的结果和预期一致。&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;*Main Lib A&amp;gt; parse &quot;null&quot;
Right Null
*Main Lib A&amp;gt; parse &quot;undefined&quot;
Right Undefined
*Main Lib A&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解析String和Bool&lt;/b&gt;&lt;/p&gt;&lt;p&gt;js的字符串分为两种写法（es6以下），单引号，双引号，需要写两个Parsec。&lt;/p&gt;&lt;p&gt;写完Parsec之后在myParsec中加入进来&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;myParsec = nullParsec
  &amp;lt;|&amp;gt; stringParsec
  &amp;lt;|&amp;gt; stringParsec1
  &amp;lt;|&amp;gt; boolParsec
  &amp;lt;|&amp;gt; undefinedParsec

boolParsec = (Bool True &amp;lt;$ P.string &quot;true&quot;) &amp;lt;|&amp;gt; (Bool False &amp;lt;$ P.string &quot;false&quot;)
stringParsec = do
  P.oneOf &quot;\&quot;&quot;
  x &amp;lt;- P.many $ P.noneOf &quot;\&quot;&quot;
  P.oneOf &quot;\&quot;&quot;
  return $ String x

stringParsec1 = do
  P.oneOf &quot;\&#39;&quot;
  x &amp;lt;- P.many $ P.noneOf &quot;\&#39;&quot;
  P.oneOf &quot;\&#39;&quot;
  return $ String x
&lt;/code&gt;&lt;p&gt;boolParsec中所涵盖的内容前面已介绍过了，这里不在介绍&lt;br&gt;stringParsec解析双引号的字符串整体流程是：消费双引号-&amp;gt;消费非双引号并把结果给x-&amp;gt;消费双引号-&amp;gt;返回。里面的P.oneOf  &quot;\&quot;&quot; 也可以换为 P.char &#39;&quot;&#39;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;运行parse函数&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;*Main Lib A&amp;gt; parse &quot;&#39;hello&#39;&quot;
Right (String &quot;hello&quot;)
*Main Lib A&amp;gt; parse &quot;\&quot;diqye\&quot;&quot;
Right (String &quot;diqye&quot;)
*Main Lib A&amp;gt; parse &quot;abc&quot;
Left &quot;JSON:&quot; (line 1, column 1):
unexpected &quot;a&quot;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解析Array和Object&lt;/b&gt;&lt;/p&gt;&lt;p&gt;原本以为这块会很困难，没想到很自然而然的写出来了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;listParsec = do
  P.char &#39;[&#39;
  P.spaces
  a &amp;lt;- P.sepBy myParsec (P.try symbol1)
  P.spaces
  P.char &#39;]&#39;
  return $ List a

symbol1 = do
  P.spaces
  P.char &#39;,&#39;
  P.spaces

keyParsec :: P.Parsec String () String
keyParsec = do
  c &amp;lt;- P.lookAhead P.anyChar
  let val | C.isDigit c = fail &quot;非法的key&quot;
          | otherwise = P.many1 $ P.noneOf &quot;: &quot;

objectInnerParsec = do
  (String key) &amp;lt;- stringParsec &amp;lt;|&amp;gt; stringParsec1 &amp;lt;|&amp;gt; (pure String &amp;lt;*&amp;gt; keyParsec) P.&amp;lt;?&amp;gt; &quot;符合规定的key&quot; 
  P.spaces
  P.char &#39;:&#39;
  P.spaces
  val &amp;lt;- myParsec
  return (key,val)

objectParsec = do
  P.char &#39;{&#39;
  P.spaces
  a &amp;lt;- P.sepBy objectInnerParsec (P.try symbol1)
  P.spaces
  P.char &#39;}&#39;
  return $ Object a
&lt;/code&gt;&lt;p&gt;symbol1 只解析了一个逗号，只不过前后都忽略了空白字符， try symbol1是为了整体失败之后不在做消耗（主要是空白字符），参见简介处的介绍。&lt;br&gt;&lt;br&gt;listParsec： 消费以『[』开头『]』结尾的字符，通过sepBy以逗号隔开，每一项使用myParsec来解析（递归解析）。 &lt;br&gt;&lt;br&gt;objectParsec:  以『{』开头『}』结尾，中间部分通过objectInnerParsec解析key和val，key可以是一个字符串也可以是普通的key。这里的keyParsec只是简单的解析为不能以数字开头。lookAhead不消费字符，这里使用它的主要目的是使报错的行号、列号更加精确。&lt;br&gt;&lt;b&gt;解析数字&lt;/b&gt;&lt;/p&gt;&lt;p&gt;数字比较麻烦，分为整数，浮点数，负整数，负浮点数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;negdigit = pure (:)  &amp;lt;*&amp;gt; p.char &#39;-&#39; &amp;lt;*&amp;gt; posdigit
posdigit = p.many1 p.digit

negfloat = pure (:)  &amp;lt;*&amp;gt; p.char &#39;-&#39; &amp;lt;*&amp;gt; posfloat
posfloat = do
  digits &amp;lt;- p.many1 p.digit
  dot &amp;lt;- p.char &#39;.&#39;
  rdigits &amp;lt;- p.many1 p.digit
  return $ digits ++ (dot:rdigits)

digitparsec = number . int . (read :: string -&amp;gt; int) &amp;lt;$&amp;gt; (posdigit &amp;lt;|&amp;gt; negdigit)
floatparsec = number . float . (read :: string -&amp;gt; float) &amp;lt;$&amp;gt; (posfloat &amp;lt;|&amp;gt; negfloat)&lt;/code&gt;&lt;p&gt;有了Parsec这些也不再困难咯。&lt;/p&gt;&lt;p&gt;&lt;b&gt;完整的myParsec&lt;br&gt;&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;myParsec = nullParsec
  &amp;lt;|&amp;gt; stringParsec
  &amp;lt;|&amp;gt; stringParsec1
  &amp;lt;|&amp;gt; listParsec
  &amp;lt;|&amp;gt; objectParsec 
  &amp;lt;|&amp;gt; boolParsec
  &amp;lt;|&amp;gt; undefinedParsec
  &amp;lt;|&amp;gt; floatParsec &amp;lt;|&amp;gt; digitParsec &lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;repl中的测验&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;*Main Lib A&amp;gt; parse &quot;[&#39;abc&#39;,{name:&#39;diqye&#39;,age:10},-10,1.01]&quot;
Right (List [String &quot;abc&quot;,Object [(&quot;name&quot;,String &quot;diqye&quot;),(&quot;age&quot;,Number (Int 10))],Number (Int (-10)),Number (Float 1.01)])
*Main Lib A&amp;gt; parse &quot;[&#39;abc&#39;,{name:&#39;diqye&#39;,age:10},-10,1.01] i&quot;
Left &quot;JSON:&quot; (line 1, column 40):
unexpected &#39;i&#39;
expecting space or end of input&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;以上代码以上传至  &lt;a href=&quot;https://github.com/ppzzppz/json-demo&quot;&gt;ppzzppz/json-demo&lt;/a&gt; &lt;/p&gt;&lt;p&gt;这个JSON作为学习来说没毛病，作为使用来说，还有很多不足，一些特殊情况没有做处理。代码上可能有一些更好改进，欢迎指正和建议。&lt;/p&gt;</description>
<author>第七页</author>
<guid isPermaLink="false">2018-02-28-34103708</guid>
<pubDate>Wed, 28 Feb 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
