<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Sun, 12 Aug 2018 15:17:53 +0800</lastBuildDate>
<item>
<title>Recursion Schemes（一）新手入门</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-08-10-41754330.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41754330&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e5a2a9858bfa0c0e317c6943a84edb5b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;序章&lt;/h2&gt;&lt;p&gt;时间回到1991年，Erik Meijer， Maarten Fokkinga， 和 Ross Paterson 发表了一篇论文，&lt;a href=&quot;http://maartenfokkinga.github.io/utwente/mmf91m.pdf&quot;&gt;Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire&lt;/a&gt; 这篇论文在即使在今天看来仍是函数式编程领域的经典之作。尽管在函数式编程社区之外，这篇论文并不广为人知，但它的贡献仍然是巨大的：作者使用范畴论表达了一组被称为 Recursion Schemes 的简洁组合子。使用这组组合子，可以自动化地完成嵌套式数据结构的递归遍历。尽管 Recursion Schemes 的提出早于 Erik Meijer 等人的工作，这篇文章将范畴论中的强大抽象能力应用于遍历数据结构这一主题——这正是范畴论如何使我们日常编程任务变得简洁而富有秩序的一个有力例证。&lt;/p&gt;&lt;p&gt;嵌套式数据结构几乎出现在每一个编程领域中，从3D绘图到文件系统，遍历这样的数据结构是非常常见的，常见到程序员们几乎感知不到他们做了这件事。因此，泛化递归和遍历这一动作几乎立即就可以为真实世界带来好处：使用新的泛化的遍历模式取代掉那些旧的依赖于类型的遍历函数。而且通过将如何遍历数据和如何使用数据解耦，可以减轻程序员们的对代码的理解负担，而更专注于如何使用数据这一核心行为。无论怎样的数据结构，链表，目录树，控制流图还是数据库表项，使用 Recursion Schemes 都可以准确有序地遍历它们。而且 Recursion Schemes 并不依赖与编程语言或编程环境——任何将函数作为一等公民的语言都可以使用 Recursion Schemes，例如 Clojure 的 &lt;a href=&quot;http://richhickey.github.io/clojure/clojure.walk-api.html&quot;&gt;clojure.walk&lt;/a&gt; API 就广泛使用了 Recursion Schemes 来遍历 s-expression 和 map。&lt;/p&gt;&lt;p&gt;实际上 Meijer 等人的工作非常成功，以至于基本上可以说函数式编程缺少 Recursion Schemes 就等于在命令式编程中使用 &lt;code class=&quot;inline&quot;&gt;goto&lt;/code&gt;。仅管这里引用 Djikstra 写给 ACM 的&lt;a href=&quot;http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html&quot;&gt;那封广为人知的信&lt;/a&gt;不免有些陈词滥调，但是这个比喻是恰当的：只使用 &lt;code class=&quot;inline&quot;&gt;for&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;while&lt;/code&gt; 而不使用 &lt;code class=&quot;inline&quot;&gt;goto&lt;/code&gt; 使得命令式语言的控制流和谐简洁，对于函数式语言，使用 Recursion Schemes 而非为对数据结构手写递归计算，带来了相似的效果。这一见解非常深刻，以至于我要再重复一遍：&lt;i&gt;Recursion Schemes 之于函数式编程范式，就如同 &lt;code class=&quot;inline&quot;&gt;for&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;while&lt;/code&gt; 之于命令式编程范式。&lt;/i&gt;&lt;/p&gt;&lt;p&gt;尽管 &lt;i&gt;Bananas, Lenses, Envelopes and Barbed Wire&lt;/i&gt; 论文发表时间远早于 Haskell 语言的诞生时间，本文仍选择使用 Haskell 作为编程语言来展示文中背后的想法[1]。如果你并不十分熟悉 Haskell， &lt;i&gt;&lt;b&gt;别慌：&lt;/b&gt;&lt;/i&gt; 理解本文的思想不需要您成为一个 Haskell 专家。我实际上只用到了 Haskell 的&lt;a href=&quot;http://cheatsheet.codeslower.com/CheatSheet.pdf&quot;&gt;语法&lt;/a&gt;以及 &lt;a href=&quot;http://learnyouahaskell.com/making-our-own-types-and-typeclasses&quot;&gt;algebraic data types&lt;/a&gt;。我会使用一些语法特性来更好地展示 Recursion Schemes 背后的思想，在我使用这些语法特性的时候，我都会解释一下它们的作用。如果您之前完全没有 Haskell 的使用经验，或许阅读 &lt;a href=&quot;http://learnyouahaskell.com/&quot;&gt;Learn You a Haskell&lt;/a&gt; 的前几章的内容有助于您理解本文。&lt;/p&gt;&lt;p&gt;本文的例子会从一个简单的类型完备的语法树的定义开始，接着我会展示在这样一颗语法树上进行泛化遍历和修改树结构是相当困难的。接着我们会使用 Haskell 的语法特性以及强大的 parameterized data types 来重新定义语法树，而就在我们使用常见的 Haskell 语法一步步定义和描述递归模式的过程中，Recursion Schemes 自然而然地就会被导出。&lt;/p&gt;&lt;p&gt;如果你对本文中使用的代码感兴趣，你可以在这个 &lt;a href=&quot;https://github.com/patrickt/recschemes/blob/master/src/Part1.hs&quot;&gt;Github 仓库&lt;/a&gt; 中找到对应的代码。代码中还包括一组单元测试以用来验证代码的正确性。&lt;/p&gt;&lt;h2&gt;递归的语法树&lt;/h2&gt;&lt;p&gt;我们首先来看一下在 Haskell 中使用 algebraic datatype 来最简单地表达一个语法树应该怎样做。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Lit  
  = StrLit String
  | IntLit Int
  | Ident String
  deriving (Show, Eq)

data Expr  
  = Index Expr Expr
  | Call Expr [Expr]
  | Unary String Expr
  | Binary Expr String Expr
  | Paren Expr
  | Literal Lit
  deriving (Show, Eq)

data Stmt  
  = Break 
  | Continue
  | Empty
  | IfElse Expr [Stmt] [Stmt]
  | Return (Maybe Expr)
  | While Expr [Stmt]
  | Expression Expr
  deriving (Show, Eq)&lt;/code&gt;&lt;p&gt;可以看到这已经是一个相当不错的语法树了：它简单直白，可以直接应用在一些语法树解析库上，例如 &lt;a href=&quot;http://hackage.haskell.org/package/attoparsec&quot;&gt;attoparsec&lt;/a&gt; 或 &lt;a href=&quot;http://tanakh.github.io/Peggy/&quot;&gt;Peggy&lt;/a&gt;。然而为这样的一棵语法树写一个操作子节点和子表达式的函数是一件非常乏味的工作。下面是一个例子，flatten 函数接受一棵语法树，并递归地删除其所有的代表括号的 &lt;code class=&quot;inline&quot;&gt;Paren&lt;/code&gt; 节点：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;-- this would turn the expression  
--    (((anArray[(10)])))
-- into
--    anArray[10]

flatten :: Expr -&amp;gt; Expr  
-- base case: do nothing to literals
flatten (Literal i) = Literal i

-- this is the important case: we shed the Paren constructor and just 
-- apply `flatten` to its contents
flatten (Paren e) = flatten e

-- all the other cases preserve their constructors and just apply 
-- the flatten function to their children that are of type `Expr`.
flatten (Index e i)     = Index (flatten e) (flatten i)  
flatten (Call e args)   = Call (flatten e) (map flatten args)  
flatten (Unary op arg)  = Unary op (flatten arg)  
flatten (Binary l op r) = Binary (flatten l) op (flatten r)&lt;/code&gt;&lt;p&gt;可以看到这段代码难以忍受地丑陋，并且难以维护。6行代码中的4行代码实际上在完成一件非常无聊但又不得不做的工作，确保 &lt;code class=&quot;inline&quot;&gt;flatten&lt;/code&gt; 函数在可以正确地在子表达式下递归下去。这样的代码不仅书写十分无趣，而且之后对&lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt;的任何改变（例如增加了新的域或语法关键字）都必须修改这个函数。（我把这种递归行为称为&lt;i&gt;显式递归&lt;/i&gt;，以与 Recursion Schemes 提供的&lt;i&gt;隐式递归&lt;/i&gt;进行区别）而且，这样的定义方式极易出错——显式递归引入的语法噪音使得检查是否有子表达式遗漏变得非常困难。而这样的疏漏就有可能引入灾难性的 bug。&lt;/p&gt;&lt;p&gt;我们可以使用 &lt;code class=&quot;inline&quot;&gt;apply&lt;/code&gt; 函数为这段混乱的代码带来些许秩序，它接受一个以 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 为参数的函数 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 并应用这个函数操作 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 和它所有的子表达式：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;applyExpr :: (Expr -&amp;gt; Expr) -&amp;gt; Expr -&amp;gt; Expr  
-- base case: applyExpr is the identity function on constants
applyExpr f (Literal i) = Literal i

-- recursive cases: apply f to each subexpression
applyExpr f (Paren p) = Paren (f p)  
applyExpr f (Index e i) = Index (f e) (f i)  
applyExpr f (Call e args) = Call (f e) (map f args)  
applyExpr f (Unary op arg) = Unary op (f arg)  
applyExpr f (Binary l op r) = Binary (f l) op (f r)&lt;/code&gt;&lt;p&gt;通过隔离递归这一操作，我们可以将 &lt;code class=&quot;inline&quot;&gt;flatten&lt;/code&gt; 函数从6行减为2行，在 &lt;code class=&quot;inline&quot;&gt;flatten&lt;/code&gt; 函数内部，我们只需要关注 &lt;code class=&quot;inline&quot;&gt;Paren&lt;/code&gt; 节点即可，而将其他节点上的递归操作交给 &lt;code class=&quot;inline&quot;&gt;applyExpr&lt;/code&gt; 函数即可：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;flatten (Paren e) = flatten e  
flatten x = applyExpr flatten x&lt;/code&gt;&lt;p&gt;这使得我们可以非常方便地书写和维护一段代码了。&lt;code class=&quot;inline&quot;&gt;apply&lt;/code&gt; 函数将负责所有平凡情况的处理，并且完成在子表达式上的递归，而我们写的函数只需要负责那些我们感兴趣的部分即可，例如，处理 &lt;code class=&quot;inline&quot;&gt;Paren&lt;/code&gt; 节点，&lt;i&gt;酷！&lt;/i&gt;&lt;/p&gt;&lt;p&gt;但我们暂且不要高兴得太早，实际上我们并没有杜绝模板文件，这里仍有出现 bug 的可能：&lt;code class=&quot;inline&quot;&gt;applyExpr&lt;/code&gt; 仅仅只是隔离了模板与内容，每当我们定义了新的语法或类型，我们都需要重写 &lt;code class=&quot;inline&quot;&gt;applyExpr&lt;/code&gt; 函数。但实际上一个异常聪明的编译器，例如 GHC，可以帮助我们完成这件事。不过首先我们需要对 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 数据类型进行适当的修改，以使其具有更加泛化的表达能力。&lt;/p&gt;&lt;h2&gt;参数化类型&lt;/h2&gt;&lt;code lang=&quot;haskell&quot;&gt;data Expr a  
  = Index a a
  | Call a [a]
  | Unary String a
  | Binary a String a
  | Paren a
  | Literal Lit
  deriving (Show, Eq)&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 的新定义与我们之前的完全相同，除了我们加入了一个类型变量 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 并且用它将所有递归出现的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 替换掉。换句话来说，我们对 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 的子表达式完成了&lt;i&gt;参数化&lt;/i&gt;。因此我们也需要修改 &lt;code class=&quot;inline&quot;&gt;applyExpr&lt;/code&gt;：我们向下层的函数类型不再是 &lt;code class=&quot;inline&quot;&gt;Expr -&amp;gt; Expr&lt;/code&gt; 而变为了 &lt;code class=&quot;inline&quot;&gt;a -&amp;gt; a&lt;/code&gt;：实际上我们甚至可以定义为 &lt;code class=&quot;inline&quot;&gt;a -&amp;gt; b&lt;/code&gt;，这样输入函数就具备了改变底层 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 的底层子表达式的能力。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;apply :: (a -&amp;gt; b) -&amp;gt; Expr a -&amp;gt; Expr b&lt;/code&gt;&lt;p&gt;敏锐的读者已经察觉到了这个函数与内置与 &lt;code class=&quot;inline&quot;&gt;list&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt; 函数多么相似：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;-- `map` takes a function (a -&amp;gt; b) and makes it operate on lists containing &#39;a&#39;s  
map :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]&lt;/code&gt;&lt;p&gt;这并不是一个巧合，实际上 &lt;code class=&quot;inline&quot;&gt;apply&lt;/code&gt; 函数就是和 &lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt; 同构的——你可以将这两个函数都看作将函数 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 提升并应用于更大的数据类型上，这个更大的数据类型可以是 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 也可以是列表(&lt;code class=&quot;inline&quot;&gt;[]&lt;/code&gt;)。而这种映射的模式实际上在 Haskell 中十分常见，以至于它的泛化版本正是 Haskell 中的一个核心概念：类型类 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt; 代表了所有的能提供类似映射功能的函数，称作 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;[2]:&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class Functor f where  
  fmap :: Functor f =&amp;gt; (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&lt;/code&gt;&lt;p&gt;无数的类型——列表，树，可选值（&lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt;），IO 操作，甚至于函数本身，都实现了 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt; 类型类。实际上由于这个函数如此常见，而实现 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt; 又非常直白，GHC 提供了一个内置的机制来帮你实现 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;：我们只需要将 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt; 加入 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 的推导声明中，就跟 &lt;code class=&quot;inline&quot;&gt;Show&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Eq&lt;/code&gt; 一样：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;{-# LANGUAGE DeriveFunctor #-}

data Expr a  
  = Index a a
  | Call [a]
  | Unary String a
  | Binary a String a
  | Paren a
  | Literal Lit
  deriving (Show, Eq, Functor) -- fmap for free&lt;/code&gt;&lt;p&gt;甚至于说，你可以导出 &lt;code class=&quot;inline&quot;&gt;Foldable&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Traversable&lt;/code&gt; 这些类型类，这为我们访问和遍历 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 提供了丰富的手段，在我们为 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;Foldable&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Traversable&lt;/code&gt; 所提供的丰富功能震惊时，也必须要注意到，现在的参数化版本 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 其实和我们之前的版本并不完全一样！&lt;/p&gt;&lt;p&gt;我们之前版本的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 因为在子节点上是递归的，所以我们可以表达任意嵌套的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt;，但我们的新版本定义做不到这一点。一个任意嵌套的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt;，我们在叶子节点使用 &lt;code class=&quot;inline&quot;&gt;Lit&lt;/code&gt; :&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Expr Lit&lt;/code&gt; 表示一个没有子表达式的表达式&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Expr (Expr Lit)&lt;/code&gt; 表示一个含有一层子表达式的表达式&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Expr (Expr (Expr Lit))&lt;/code&gt; 表示一个含有两层的，以此类推&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为了使我们的参数化版本定义的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 具备这种特性，我们需要一种类型，这种类型可以在当我们确定 &lt;code class=&quot;inline&quot;&gt;Expr a&lt;/code&gt; 中的 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 类型时，得到一个嵌套任意多层 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 子表达式的类型。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type NestedExpr = Expr (Expr (Expr (Expr …)))&lt;/code&gt;&lt;p&gt;为了得到这种类型，我们需要一些技巧，使我们可以用有限长的语句，构造任意多层嵌套类型的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;不动点&lt;/h2&gt;&lt;p&gt;考虑一个 Y-组合子，给定一个输入为一个参数的函数 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;y(f)&lt;/code&gt; 实际上就表示了不断将 f 应用在自己本身上：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;y(f) = f(f(f(f(f ...))))&lt;/code&gt;&lt;p&gt;敏锐的读者们想必已经察觉 &lt;code class=&quot;inline&quot;&gt;y(f)&lt;/code&gt; 的形式与我们所需要的 &lt;code class=&quot;inline&quot;&gt;NestedExpr&lt;/code&gt; 的形式非常相似，如果我们把一个 Y-组合子整合进类型系统的话，我们就可以描述 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 不断应用于自己这样的形式了，而整合的过程只需保持与在值域上作用于函数的 Y-组合子的同构即可。这样我们就可以描述任意嵌套的表达式 &lt;code class=&quot;inline&quot;&gt;Expr a&lt;/code&gt; 了，其中 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 代表任意嵌套的表达式 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Y t = t (t (t (t (t ...))))&lt;/code&gt;&lt;p&gt;实际上这就是不动点[3]的定义：我们称 &lt;code class=&quot;inline&quot;&gt;y(f)&lt;/code&gt; 是函数 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 的一个不动点，而 &lt;code class=&quot;inline&quot;&gt;Y Expr&lt;/code&gt; 就是函子 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 的一个&lt;i&gt;不动点&lt;/i&gt;。而关键性的一点在于，我们可以在类型系统中构建 Y-组合子，这样就可以表示 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 和其子表达式间相似这一本质特征。&lt;/p&gt;&lt;p&gt;我们需要一个类型 &lt;code class=&quot;inline&quot;&gt;Y&lt;/code&gt;，它接受另一个类型 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;，它将 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 应用到类型为 (Y f) 的子节点上，我们定义这样的 &lt;code class=&quot;inline&quot;&gt;Y&lt;/code&gt; 类型为 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt;，而它的构造函数为 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt;，表示我们将一层的递归变成了固定形式，接着我们定义 &lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt; 函数来辅助解析 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Term f = In (f (Term f))

out :: Term f -&amp;gt; f (Term f)  
out (In t) = t&lt;/code&gt;&lt;p&gt;接着我们非常自然地应用 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 到 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 上：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;Term Expr = In (Expr (Term Expr))

out :: Term Expr -&amp;gt; Expr (Term Expr)&lt;/code&gt;&lt;p&gt;从这个定义我们可以看到，给定一个 &lt;code class=&quot;inline&quot;&gt;Term Expr&lt;/code&gt;，我们可以使用 &lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt; 函数将其转化为一个 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 表达式，而它的子表达式是 &lt;code class=&quot;inline&quot;&gt;Term Expr&lt;/code&gt;。这表示我们对一个 &lt;code class=&quot;inline&quot;&gt;Term Expr&lt;/code&gt; 连续应用 &lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt; 函数就可以把它解析成&lt;i&gt;任意嵌套&lt;/i&gt;的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt;：&lt;code class=&quot;inline&quot;&gt;Term Expr&lt;/code&gt; 可以变成 &lt;code class=&quot;inline&quot;&gt;Expr (Term Expr)&lt;/code&gt; 接着变为 &lt;code class=&quot;inline&quot;&gt;Expr (Expr (Term Expr))&lt;/code&gt;，以此类推。这种使用函子不动点来定义递归类型的风格，正是一个 &lt;i&gt;codata&lt;/i&gt; 的例子，完整地讨论 codata 理论（还有 codata 的各种变种）已经超出了本文的范围。感兴趣的话，&lt;a href=&quot;http://www.tac-tics.net/data-vs-codata&quot;&gt;这里&lt;/a&gt;有一个非常详尽的介绍。&lt;/p&gt;&lt;h2&gt;泛化遍历&lt;/h2&gt;&lt;p&gt;在本章，我们将为使用不动点和函子来定义我们的数据结构打下基础。&lt;/p&gt;&lt;p&gt;考虑一个自底向上的遍历过程，我们用伪码来看看一个函子的不动点遍历需要具备哪些功能：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;我们使用 ƒ 自底向上地遍历一个 Term
  1. 解析 Term 以访问它的所有孩子
  2. 使用 ƒ 递归地应用于 Term 的每一个孩子
  3. 重新封装好 Term
  4. 应用 ƒ 到 Term 上&lt;/code&gt;&lt;p&gt;我们定义函数 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt; 来总结刚才伪码所做的过程。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;bottomUp :: Functor a =&amp;gt; (Term a -&amp;gt; Term a) -&amp;gt; Term a -&amp;gt; Term a&lt;/code&gt;&lt;p&gt;给定一个从 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 到 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 的函数 &lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt;，我们先用 &lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt; 函数对 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 解包，接着使用  &lt;code class=&quot;inline&quot;&gt;fmap (bottomUp fn)&lt;/code&gt; 来递归遍历它的每一个子节点，接着使用 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 重新封装，最后只需要应用 &lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt; 得到最后结果即可。其中 &lt;code class=&quot;inline&quot;&gt;fmap bottomUp&lt;/code&gt; 的调用完成了函数中最重要的类型提升部分：它使用函子完成了对所有子节点的递归遍历。&lt;/p&gt;&lt;p&gt;我不会分别定义 &lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt; 的参数和 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 的参数，取而代之的是我准备直接定义 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt; 函数，直接把 &lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;fmap bottomUp&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt; 组合起来。这里会用到在 &lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/Control.Arrow&quot;&gt;Control.Arrow&lt;/a&gt;&lt;/code&gt; 中的 &lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 操作符，从左向右结合，&lt;code class=&quot;inline&quot;&gt;f &amp;gt;&amp;gt;&amp;gt; g x&lt;/code&gt; 等价于 &lt;code class=&quot;inline&quot;&gt;g(f(x))&lt;/code&gt;。这个风格稍显古怪，实际上自右向左的结合 &lt;code class=&quot;inline&quot;&gt;.&lt;/code&gt; 更加常见，这里我们使用这个风格是因为这样我们将对于函数间的调用顺序有一个清晰的可视化，而这一顺序之后会变得十分重要。&lt;/p&gt;&lt;p&gt;现在我们按自左向右的顺序使用 &lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 操作符将函数拼接起来：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;bottomUp fn =  
  out                    -- 1) unpack
  &amp;gt;&amp;gt;&amp;gt; fmap (bottomUp fn) -- 2) recurse
  &amp;gt;&amp;gt;&amp;gt; In                 -- 3) repack
  &amp;gt;&amp;gt;&amp;gt; fn                 -- 4) apply&lt;/code&gt;&lt;p&gt;于是，我们的第一个 Recursion Schemes 函数出现了！我们可以使用 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt; 函数完成了一个类型安全并且支持泛型的组合子，使其可以递归地对任何函子进行变换：比如我们的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt;，或者列表，多叉树，或任何其他结构。老实说，这非常酷！我们再一次重写之前的 &lt;code class=&quot;inline&quot;&gt;flatten&lt;/code&gt; 函数，以使它支持嵌套了任意多层 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt;:&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;flattenTerm :: Term Expr -&amp;gt; Term Expr  
flattenTerm (In (Paren e)) = e  -- remove all Parens  
flattenTerm other = other       -- do nothing otherwise

flatten :: Term Expr -&amp;gt; Term Expr  
flatten = bottomUp flattenTerm&lt;/code&gt;&lt;p&gt;我们的上一个使用 &lt;code class=&quot;inline&quot;&gt;apply&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;flatten&lt;/code&gt; 版本不可谓不简洁，但是新的版本更加优雅：我们的 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt; 函数使用 Recusion Scheme 使我们彻底规避了定义递归形式。我们可以专注于 &lt;code class=&quot;inline&quot;&gt;flatten&lt;/code&gt; 函数的行为本身——从语法树中去除所有的括号节点——而完成这一函数也仅仅只需 2 行。而且使用 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;flattenTerm&lt;/code&gt; 比显式的定义整个递归函数更加简明清晰。相比于我们之前版本的 &lt;code class=&quot;inline&quot;&gt;flatten&lt;/code&gt;，我们已经获得了不小的进展，我想不到比这更简洁的表达方式编码方式了。&lt;/p&gt;&lt;p&gt;但是我们还是不要就此止步为好，让我们考虑一下自底向上遍历的天然对偶形式，自顶向下遍历一个 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;我们使用 ƒ 自顶向下地遍历一个 Term
  1. 应用 ƒ 到 Term
  2. 解析 Term 以访问它的所有孩子
  3. 使用 ƒ 递归地应用于 Term 的每一个孩子
  4. 重新封装好 Term&lt;/code&gt;&lt;p&gt;注意到这些指令与自底向上遍历的指令惊人地相似，只需要我们逆序整个流程，并把解析和封装交换下位置，二者就完全相同了，而美妙的是：我们的代码也可以这样做。代码中我们只需要将自左向右的操作符 &lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 替换为自右向左的操作符 &lt;code class=&quot;inline&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;[4]，并把 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Out&lt;/code&gt; 交换位置就可以了！&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;topDown, bottomUp :: Functor f =&amp;gt; (Term f -&amp;gt; Term f) -&amp;gt; Term f -&amp;gt; Term f

topDown f  = In &amp;lt;&amp;lt;&amp;lt; fmap (topDown f) &amp;lt;&amp;lt;&amp;lt; out &amp;lt;&amp;lt;&amp;lt; f 

bottomUp f = out &amp;gt;&amp;gt;&amp;gt; fmap (bottomUp f) &amp;gt;&amp;gt;&amp;gt; In &amp;gt;&amp;gt;&amp;gt; f&lt;/code&gt;&lt;p&gt;我们通过“反转箭头”就完成了自顶向下自底向上这一组对偶概念的表达，同时保持类型安全并不失一般性，而且这些概又可由 Haskell 的两大核心概念函子和不动点自然导出，还有什么比这更激动人心呢？&lt;/p&gt;&lt;h2&gt;结语&lt;/h2&gt;&lt;p&gt;自顶向下和自底向上是 Recursion Schemes 中最为简单的一组。我们只是接触到了 &lt;i&gt;Bananas, Lenses, Envelopes and Barbed Wire&lt;/i&gt; 论文的一些初级应用。在下一篇介绍中，我会谈谈 Recursion Schemes 的另外两个变种以及如何让 Recursion Schemes 更加泛化。&lt;/p&gt;&lt;p&gt;我要感谢所有阅读这篇文章的人，特别是 Nate Soares 和 Manuel Chakravarty，我还要感谢 Colin Barrett，与我熬夜讨论文章的细节，如果你有任何关于本文的评论或疑问，可以在 &lt;a href=&quot;https://twitter.com/importantshock&quot;&gt;Twitter&lt;/a&gt; 上找到我。&lt;/p&gt;&lt;p&gt;下一章我们将定义并讨论 catamorphisms 和 anamorphisms。&lt;/p&gt;&lt;h2&gt;译者后记&lt;/h2&gt;&lt;p&gt;译者也是还在 Haskell 学习中，本来是在读 &lt;a href=&quot;https://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383&quot;&gt;Pearls Functional Algorithm Design&lt;/a&gt;，一不留神就掉进了 Recursion Schemes 的坑里，目前来看坑也是有越开越大的趋势。本文翻译自 &lt;a href=&quot;https://blog.sumtypeofway.com/&quot;&gt;Adventures in Uncertainty&lt;/a&gt; 博客，关于一些术语和技术的翻译可能不够准确，原文的神韵也多有折扣，恳请大家指正。阅读的过程中如果遇到什么问题，也欢迎与我交流讨论。&lt;/p&gt;&lt;p&gt;最后再次感谢大家的阅读！&lt;/p&gt;&lt;p&gt;[1]:实际上在 &lt;i&gt;Bananas, Lenses, Envelopes and Barbed Wire&lt;/i&gt; 一文中，Meijer 等人并没有使用任何一种特定的编程语言，而是使用了一套由 &lt;a href=&quot;http://en.wikipedia.org/wiki/Bird%E2%80%93Meertens_Formalism&quot;&gt;Bird-Meertens formalism&lt;/a&gt; 导出的符号。（Bird-Meertens formalism 是一套基于 Recursion Schemes 的程序构造演算系统，Meijer 的博士论文就是在讨论一套使用 Bird-Meertens formalis 的编译器规范）这套演算系统也被称为 “Squiggol”，这是源于它扭曲的符号记法。尽管记法本身十分详尽，单其中的一些描述符号如“香蕉括号”（形如&lt;code class=&quot;inline&quot;&gt;(||)&lt;/code&gt;）和 “凹透镜”（形如&lt;code class=&quot;inline&quot;&gt;[()]&lt;/code&gt;）仍令人倍感困惑。&lt;/p&gt;&lt;p&gt;[2]:你或许会好奇既然 &lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt; 只是 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt; 的一个特化，那么为什么 Haskell 提供了 &lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt; 两个函数，而这正是 Haskell 社区的一个核心论点。正如 &lt;a href=&quot;http://www.haskell.org/haskellwiki/Typeclassopedia#Instances&quot;&gt;Typeclassopedia&lt;/a&gt; 的作者 Brent Yorgey 所说：“对于一个 Haskell 的初学者，当错误的使用 &lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt; 函数时，他显然更想看到一个关于列表的错误，而非一个关于函子的错误”。&lt;/p&gt;&lt;p&gt;[3]:完整地讨论不动点的优雅与重要显然超出了本文的范围，对此感兴趣的读者可以阅读 Raymond Smullyan 的一篇精彩教材 &lt;a href=&quot;http://www.amazon.com/To-Mock-Mockingbird-Other-Puzzles/dp/0192801422&quot;&gt;Mock a Mockingbird&lt;/a&gt; 或是阅读 Reginald Braithwaite 的 &lt;a href=&quot;https://github.com/raganwald/combinators.info&quot;&gt;combinators.info&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;[4]:即为 Haskell 中的 &lt;code class=&quot;inline&quot;&gt;.&lt;/code&gt; 操作符。&lt;/p&gt;</description>
<author>禾木旁</author>
<guid isPermaLink="false">2018-08-10-41754330</guid>
<pubDate>Fri, 10 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>从 Haskell 到 WebAssembly（2）</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-08-10-41377372.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41377372&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5eb1e96120e1c903ae939425f3d2b173_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;GHC 的编译管线和插件机制&lt;/h2&gt;&lt;p&gt;上期讲了 WebAssembly 跑起来和写起来是什么感觉。这期讲讲怎么把 Haskell 代码变成 WebAssembly 代码。首先要设法从 GHC 的编译管线里面把某个 IR 捞出来（而且要 in-memory 的形式，要是 dump 到文本再解析那就实在太。。）&lt;/p&gt;&lt;p&gt;这里我们先只关心单个 Haskell module 的 pipeline。在 GHC 进程启动以后，首先会解析 major mode，如果 major mode 对应 &quot;ghc --make&quot; 或者 &quot;ghc -c&quot; 等编译 Haskell 代码的模式，经过依赖分析以后，会对每一个 Haskell module 启动一个 pipeline，相关代码在 GHC API 的 DriverPipeline 模块中。&lt;/p&gt;&lt;p&gt;在 pipeline 中，Haskell 源代码经过预处理器展开 CPP 宏以后，经历的中间表示有：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Parsed module。保留了所有的源代码语法特性的 AST。&lt;/li&gt;&lt;li&gt;Renamed module。解析所有 identifier 的作用域，诸如 lambda 参数之类的 identifier 重命名到全局唯一，从模块导出的 identifier 带上模块前缀。从这一步开始，GHC 要求跑一个模块的 pipeline 之前，其依赖模块的 pipeline 必须已经跑过，并且成功通过类型检查，将相关信息存入其 interface file 以供查询。&lt;/li&gt;&lt;li&gt;Typechecked module。类型检查过的模块。类型检查一通过，可以生成 interface file 了，其他依赖该模块的模块在编译时需要查询 interface file 里面的各种信息。值得一提的是，前面这几个中间表示共用一套 AST，至于如何区分诸如 identifier 等细节的类型差异？依靠 Trees that Grow 设计模式。&lt;/li&gt;&lt;li&gt;Core。这是一个极小的带类型 lambda calculus，基于某个 System F 变种。大多数优化都是在 Core 上跑的带类型优化。Core 是有形式化 spec，并且保证 Core 类型不出错，运行时就不会 segfault 的（前提是如果你不用 FFI 之类的作死）&lt;/li&gt;&lt;li&gt;STG。这是一个经过 ANF 变换，term 形状受限的另一个极小 lambda calculus，在 STG 中，所有的 thunk allocation 和 evaluation 的时机直接由 term 的形状决定。大多数 Haskell to JavaScript 编译器（haste 和 ghcjs）选择用 STG 作为编译到 JavaScript 的中间表示。&lt;/li&gt;&lt;li&gt;Cmm。一个长得勉强有点像 C（毕竟叫 C-minus-minus）的玩意，作为各种不同平台代码生成器共用的中间表示，设计目的是“平台无关汇编”。当然，GHC 的年代比 LLVM 年代早多了所以用这个，要是 LLVM 火了以后再开坑，估计就直接用 LLVM IR 了。&lt;/li&gt;&lt;li&gt;默认的汇编后端，生成 gcc 能识别的 .asm 文本，然后 gcc 编译成 .o 文件。LLVM 后端会生成 LLVM IR 文本，调用 llc/opt 编译。C 后端直接生成 C 代码编译。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们要从 Haskell 编译到 WebAssembly，自然要挑一个接近底层的 IR，这里我们选择 Cmm，从 Cmm 开始做代码生成，大致相当于开发一个新架构的原生后端。（选其他的也不是不行，我跟同事讨论时开玩笑说能不能做个新后端把 x64 assembly 编译到 WebAssembly，他说你还是直接用 Emscripten 编译个 qemu 算了。。）&lt;/p&gt;&lt;p&gt;接下来的任务是：设法劫持正常的 GHC pipeline，加载我们自定义的逻辑，获得 in-memory IR 并进行我们自己的代码生成。如果你是个想要写函数式编译器来玩玩的萌新，觉得拿 GHC 搞有戏的话，听我一句劝，转去弄 Idris 后端还来得及。还不听劝？好吧，你大致会经历几个阶段：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;看了一些 GHC API 的文档和博客啥的，觉得有搞头。写了一个能编译单个 .hs 的 demo。&lt;/li&gt;&lt;li&gt;能编译自己的 .hs 模块了，这很 OK，然后你如果想成为新世界的卡密，不对，写面向新架构的编译器的话，你需要把整个 Haskell 标准库，连带整个运行时都能编译过去。这个过程叫“booting”。但是你的小儿科 demo 没有办法编译标准库，因为标准库的编译流程相当复杂，一堆涉及 autoconf，sed 之类的乱七八糟的脚本。。。&lt;/li&gt;&lt;li&gt;经过 n 个小时以后，你发现 ezyang 的某篇 &lt;a href=&quot;http://blog.ezyang.com/2017/02/how-to-integrate-ghc-api-programs-with-cabal/&quot;&gt;blog&lt;/a&gt; 提到，GHC 有个叫 &lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/extending_ghc.html#frontend-plugins&quot;&gt;frontend plugin&lt;/a&gt; 的机制，可以用来制造一个 ghc wrapper，这个 ghc wrapper 用于替代正常的 ghc，执行自定义逻辑。很好，你写了一个 ghc frontend plugin，然后额外花了 n 个小时，处理诸如 cabal/stack 支持、package database 相关参数等琐碎问题，总算能把 ghc wrapper 跑起来了。&lt;/li&gt;&lt;li&gt;ghc wrapper 里面可以实现自定义逻辑，但是手头还是没有结构化的 IR，咋整？如果需要的是 Typechecked module 或者 Core 那都比较好办，不过 STG 和 Cmm 是没有暴露出相关表示的，在 pipeline 里面一个 doCodegen 一把梭，直接从 desugared Core 搞到汇编了。你又花了 n 小时，找到了 GHC 的 Hooks 机制，可以用来对 GHC 运行中的一些函数下钩子，其中有个 runPhaseHook 可以把整个 pipeline 换掉！你有了一个大胆的想法。&lt;/li&gt;&lt;li&gt;又过了 n 小时，你的自定义 pipeline 上线了，可喜可贺。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;总的来说，为了最大化与 Cabal 的兼容性，我们需要假装自己是 ghc，也完成 ghc 本身的编译任务生成 native code，但是可以夹带私货干点别的（配置和输入输出不能污染 process args/stdout 什么的，但是可以用环境变量）。&lt;/p&gt;&lt;p&gt;跟 GHC API 打交道相当不愉快，you&#39;ve been warned。不过我靠对 Haskell 的爱扛下来了。&lt;/p&gt;&lt;h2&gt;ghc-toolkit：Haskell to X 编译器的可重用框架&lt;/h2&gt;&lt;p&gt;跟 GHC API 打过交道以后，一个自然的想法就是能不能做个框架封装一下所有这些 hacks，这样一来我做 Haskell to X 的编译器时用框架就不用管太多了。所以 asterius 项目的一个子库就是 ghc-toolkit，实现了这个封装。&lt;/p&gt;&lt;p&gt;使用 ghc-toolkit 大致只需要关心以下几个东西：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data HaskellIR = HaskellIR
  { parsed :: HsParsedModule
  , typeChecked :: TcGblEnv
  , core :: CgGuts
  , stg :: [StgTopBinding]
  , cmm :: [CmmDecl]
  , cmmRaw :: [RawCmmDecl]
  }

data CmmIR = CmmIR
  { cmm :: [CmmDecl]
  , cmmRaw :: [RawCmmDecl]
  }

data Compiler = Compiler
  { patch :: ModSummary -&amp;gt; HsParsedModule -&amp;gt; Hsc HsParsedModule
  , withHaskellIR :: ModSummary -&amp;gt; HaskellIR -&amp;gt; CompPipeline ()
  , withCmmIR :: CmmIR -&amp;gt; CompPipeline ()
  , finalize :: Ghc ()
  }

makeFrontendPlugin :: Ghc Compiler -&amp;gt; FrontendPlugin

data FakeGHCOptions = FakeGHCOptions
  { ghc, ghcLibDir :: FilePath
  , frontendPlugin :: GHC.FrontendPlugin
  }

fakeGHCMain :: FakeGHCOptions -&amp;gt; IO ()&lt;/code&gt;&lt;p&gt;解释一下。前面两个数据类型是 GHC 在编译 .hs/.cmm 时分别会获得的 IR 的集合。假如想要写一个基于 GHC 的 Haskell to X 编译器，那么把自定义的逻辑放在 Compiler 类型里面就行了——Hsc、CompPipeline、Ghc 等这几个不同 GHC phase 对应的 monad 都是 MonadIO instance，所以也支持插入任意副作用（比如读写你自己的 object file 之类的玩意）。每当 GHC 对一个模块启动 pipeline 时，会触发 withHaskellIR/withCmmIR 回调函数，执行你自己自定义的逻辑，其中你可以拿到当前模块的模块信息以及各种 IR。&lt;/p&gt;&lt;p&gt;为了把 Compiler 类型用起来，首先用 makeFrontendPlugin，可以把 Compiler 转换成一个 GHC 的 frontend plugin（Compiler 是在 Ghc monad 里面初始化的，按前面说的，初始化的逻辑也可以带副作用，而所有模块编译完以后的 finalizer 也可以插进去）。这个 frontend plugin 可以用 GHC 的 --frontend 机制动态加载，也可以通过 fakeGHCMain 直接生成一个假的 ghc wrapper executable，这个 ghc wrapper executable 的行为大多数时候和 ghc 一致，不过用 --make 编译 Haskell 模块时，会自动加载 Compiler 中的各种回调函数。&lt;/p&gt;&lt;p&gt;简而言之，使用 ghc-toolkit，用上面的机制搞出一个假的 ghc，然后编译标准库或者自己的模块时，用这个假的 ghc 直接代替 ghc，即可把自己的 Haskell 编译器给跑起来了。可喜可贺。&lt;/p&gt;&lt;p&gt;最后值得一提的是，Compiler 里面额外提供了一个 patch 回调函数，这个玩意可以用来重写 parsed IR（实现重写其他 IR 的回调函数很容易，但是其他 IR 很容易改坏了，自己改要么把 GHC 给 crash 掉，要么编译出什么不可名状的玩意）。这个重写机制可以拿来做很多很有意思的事，比如给所有函数打个 INLINEABLE 标记，让 GHC 自动变成全局优化编译器（逃。GHC 8.6 已经加了 source plugin 功能，可以用 GHC Plugin 重写 parsed/renamed/typechecked IR，原理和这个基本上一样。&lt;/p&gt;&lt;p&gt;这期先讲这么多。感觉都是 GHC 相关的 hack，下一期就有 WebAssembly 了。&lt;/p&gt;</description>
<author>Felis sapiens</author>
<guid isPermaLink="false">2018-08-10-41377372</guid>
<pubDate>Fri, 10 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>从 Haskell 到 WebAssembly（1）</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-08-05-41324925.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41324925&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5eb1e96120e1c903ae939425f3d2b173_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;项目简介&lt;/h2&gt;&lt;p&gt;安利一下我最近在 Tweag I/O 做的项目：一个基于 GHC 的 Haskell to WebAssembly 编译器。项目地址：&lt;a href=&quot;https://github.com/tweag/asterius&quot;&gt;tweag/asterius&lt;/a&gt;&lt;/p&gt;&lt;p&gt;目前项目处于 alpha 阶段，可以编译一些简单的 Haskell 程序并在 Node.js 上运行。支持特性：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;除 Template Haskell 以外的大多数 GHC 扩展&lt;/li&gt;&lt;li&gt;ghc-prim/integer-simple/base/array 中不涉及 IO 的部分。IO 靠运行时内建的接口以及 JavaScript FFI&lt;/li&gt;&lt;li&gt;运行时暂不支持垃圾回收，可在链接时设定 initial heap size，可在运行期动态申请新内存&lt;/li&gt;&lt;li&gt;可以通过 foreign import javascript 语法在 Haskell 程序中运行 JavaScript 片段，支持 first-class 的 JSRef 类型&lt;/li&gt;&lt;li&gt;除了需要打开 V8 的实验性 BigInt 扩展以外，只要 JavaScript 引擎实现 WebAssembly MVP 版本的特性即可，无需 anyref/host-bindings/gc 等提案的支持&lt;/li&gt;&lt;li&gt;链接器支持 debug mode，可在运行期打印包含内存读写、控制流转移的日志&lt;/li&gt;&lt;li&gt;实现了 binaryen 的多层 Haskell 绑定，底层是 raw C bindings 以及自动编译、链接 binaryen 库的功能，中层是一套 Haskell IR 对应 binaryen IR，支持序列化、符号解析与跨模块链接等，高层有一个 monadic EDSL，可以在 Haskell 里用 do-notation 之类的语法糖直接写 WebAssembly 代码&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最简单的试用方法是下载 Docker image，每个通过单元测试的 commit 会自动上传一个 Ubuntu-based 的 image。直接 docker pull terrorjack/asterius 可以获得对应 master 分支的最新 image，进一步指示参考 ahc-link --help 即可，可以将 .hs 编译到一个 .wasm 文件和 .js 文件，.js 文件用 node 运行时会加载 .wasm 文件，初始化运行时，并运行 Main.main 对应的导出函数。运行自己写的样例时，不妨先参考几个单元测试对应的输入代码。&lt;/p&gt;&lt;p&gt;当然，项目状态距离能在浏览器里愉快地跑 Haskell 代码还是有不少差距的，剩下的工作主要是运行时方面的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;storage manager 增加垃圾回收。虽然无脑默认开个 1G 的堆也已经可以运行不少 demo 了，这样总不是个办法对吧？当然，我要是有 Simon Marlow 十分之一的本事的话这个早就做出来了，原版的 GHC 里面是并行分代 GC，我会先做个非并行非分代的实现然后慢慢迭代的（&lt;/li&gt;&lt;li&gt;scheduler 支持 Haskell 线程调度，包括运行 unbound thread、中断和恢复 thread 等。这个弄完以后，foreign export javascript 就有戏了，毕竟一个前端语言如果不能从 JavaScript 调用进去的话那没法用啊是不。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上面的坑填上以后还有不少周边的工作可以做，比如加强 Cabal 支持，能编译 Haskell 标准库以外的更多库、做个 WebIDL 到 Haskell 模块的编译器，调 Web API 更容易，etc。在做了，你智猫姐姐骗过人吗（&lt;/p&gt;&lt;p&gt;大致介绍完了，接下来简单说下 WebAssembly 和开发面向 WebAssembly 的编译器的那些事，先讲 non-Haskell specific 的部分，再讲 Haskell specific 的。会分几期慢慢讲。&lt;/p&gt;&lt;h2&gt;WebAssembly 介绍&lt;/h2&gt;&lt;p&gt;总之，如果你是个吃瓜群众，你只需要知道，WebAssembly 能让你享受做前端开发以及写 C/C++ 的双份快乐（逃。目前使用第三方语言编译到 WebAssembly 的使用体验最完善的是 C/C++ 和 Rust。Rust 的话官方编译器可以基于 LLVM 的 wasm32 实验性后端生成代码，而 C/C++ 自然是靠我们熟悉的 Emscripten，Emscripten 有 LLVM/binaryen 的模式可以选择。教程网上很多我就不贴了。这里主要写如果你想自己写编译器，顺带蹭一波 WebAssembly 的热点的话，大概需要了解的东西。&lt;/p&gt;&lt;p&gt;关于 WebAssembly 版本：目前主流 JavaScript 都实现了的是 WebAssembly MVP，另外 WebAssembly 官方有不少 proposal 在或快或慢地进行讨论和实现，以下如果没有特别声明，WebAssembly 均一律指代 MVP 版本的 wasm32。&lt;/p&gt;&lt;p&gt;WebAssembly 跑起来是个什么感觉：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;首先你要有个 WebAssembly 的 binary file。WebAssembly 官方有一个 S-exp 的语法，那个是给人看的，还有一个 binary format，浏览器认 binary format。一个 binary 代表一个 WebAssembly 的 module。&lt;/li&gt;&lt;li&gt;然后，在 JavaScript 中调用相关接口编译，读入 binary，对其进行 parse 和 validation，生成一个 Module。这个 Module 暂时还不是可运行的。&lt;/li&gt;&lt;li&gt;对编译成功生成的 Module 进行初始化。初始化的时候需要提供 import object，比如 WebAssembly module 中声明需要导入什么 JavaScript 函数的话，相关函数必须在 import object 里存在（不过并不在 JavaScript 侧进行类型检查）。&lt;/li&gt;&lt;li&gt;编译/初始化都是异步的，两个步骤可以合一。初始化完，拿到 Instance 以后，Instance 的 exports 里是该模块导出的函数，在 JavaScript 中可以运行这些函数，并获得其运行结果，顺带触发相关副作用。所有 WebAssembly 函数都是同步、运行到底的，不会返回 Promise 之类的玩意或者要让你传个 callback 啥的。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;以上是跑起来的感觉，那么写起来的感觉呢？&lt;/p&gt;&lt;ul&gt;&lt;li&gt;类型系统：静态强类型，没有任何的隐式转换，基本类型就只有 i32/i64/f32/f64 这几种。函数类型是从若干个基本类型的参数值生成 0 个或 1 个基本类型的结果值。&lt;/li&gt;&lt;li&gt;线性内存：有一个 32 位寻址的内存空间可以读写基本类型，支持 unaligned access。内存大小可以按 64KB 的页为基本单位，声明初始/最大大小、查询当前大小和申请扩充。函数代码等数据并不放在线性内存里。哦对了，0 也是合法的内存地址。&lt;/li&gt;&lt;li&gt;全局变量：除线性内存以外，另一个跨函数可以共享的全局状态就是全局变量，可以声明全局变量的初始化值，以及是否可变。&lt;/li&gt;&lt;li&gt;栈虚拟机：WebAssembly 没有“表达式”概念，而是假设运行时实现了一个栈，多数指令的作用就是从栈顶弹出若干个基本类型的值，做做计算，把结果写到栈顶。&lt;/li&gt;&lt;li&gt;函数抽象：呵呵，没有尾调用。把想要支持被间接调用的函数放到一个表中，编号就是其“函数指针”，可以用 call_indirect 指令进行间接调用，间接调用在运行时进行类型检查。另外，函数可以声明局部变量。&lt;/li&gt;&lt;li&gt;异常处理：可以调用 trap 立即中止 WebAssembly 代码，在 JavaScript 侧抛出异常。WebAssembly 自身不能处理异常。&lt;/li&gt;&lt;li&gt;导入导出：支持导入导出的对象有：函数、全局变量、线性内存。函数必须满足 WebAssembly 的函数类型要求。不用说，JavaScript 的引用类型是不支持的。另外 i64 也不行（不过有 workaround）&lt;/li&gt;&lt;li&gt;控制流：没有任意跳转指令。有 block/loop 指令、label 和作用域的概念，所有的跳转指令只能跳转到外层的 label，有点类似于 lambda calculus 里面的参数绑定。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;更具体的细节，可以去慢慢抠 WebAssembly spec，以及 MDN 上有关 WebAssembly 的 API 描述。如果有不清楚的地方，WebAssembly 官方有个 OCaml 写的参考解释器可以看看源码。（参考解释器不带 JavaScript 引擎，所以如果想要观测副作用，得通过修改全局变量/线性内存来实现）&lt;/p&gt;&lt;h2&gt;生成 WebAssembly 模块&lt;/h2&gt;&lt;p&gt;以上介绍了单个 WebAssembly 模块大概长什么样，以及怎么跑起来。首先你需要有个 binary 模块，这个东西怎么生成，难道要对照 spec 自己拼二进制串？这里列几种不同的思路：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;通过 S-exp 语法的源代码，解析以后重新生成 binary。比如 WebAssembly 官方提供的 wabt 工具，可以在 S-exp 和 binary 之间进行转换，并且支持 validate 和 interpret 操作。基于 wabt 的在线版工具 &lt;a href=&quot;https://webassembly.studio/&quot;&gt;WebAssembly Studio&lt;/a&gt; 可以直接在网页上编辑和运行 S-exp 格式的 WebAssembly 模块。&lt;/li&gt;&lt;li&gt;通过 LLVM 的 wasm32 后端生成 WebAssembly module。前面可以对接 clang（不带 C 标准库支持），后面可以对接 lld，lld 实现了实验性的 WebAssembly 链接功能。如果不关心单个 WebAssembly module，而是想要立等可取的整个 WebAssembly-based app，那么直接 Emscripten 走起，C/C++ 标准库和 SDL2 都有移植。&lt;/li&gt;&lt;li&gt;通过 binaryen 库生成 WebAssembly module，这个主要就是面向编译器开发者的。本项目底层也用到了 binaryen，所以接下来着重介绍 binaryen。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;binaryen 本身是一个 WebAssembly 官方支持的 C++ 库，提供了 C/JavaScript 接口可供第三方编译器开发者使用。binaryen 库主要支持的功能包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;解析/生成/验证单个 WebAssembly 模块，支持 S-exp 文本格式的解析和输出。与 V8/SpiderMonkey 等引擎相比，binaryen 支持的 WebAssembly 特性集相对保守，目前除了 MVP 以外，额外支持的特性只有 thread/atomics 相关指令。&lt;/li&gt;&lt;li&gt;解释执行 WebAssembly 模块。这个解释器和官方的 spec 解释器/wabt 解释器支持的功能大致类似。&lt;/li&gt;&lt;li&gt;支持两套不同的 IR：基于表达式的递归 IR，以及贴近 WebAssembly 底层的栈 IR。C API 中目前只支持表达式 IR，主要出于历史原因：WebAssembly 草案最初是表达式 IR，binaryen 也这么实现，后来转向栈 IR 以后，表达式 IR 的接口仍然保留了下来。对于编译器开发者而言，使用表达式 IR 可以稍微比栈 IR 省一点点工作（其实就是后序遍历一下 AST 的事）&lt;/li&gt;&lt;li&gt;WebAssembly 中涉及函数名、函数类型名、函数表索引等需要索引的地方，一律是一个 i32，而在 binaryen 中可以用字符串命名，这点微小的工作对编译器开发者还是很贴心的，不要求自行维护符号表。&lt;/li&gt;&lt;li&gt;最重要的是，binaryen 中提供了 Relooper 算法的实现。很多编译器涉及的中间表示是带任意跳转的控制流图，控制流图的节点之间不一定存在拓扑序，也就无法非常简单地用一系列嵌套的 block/loop 来表示。Relooper 算法接受控制流图输入，输出基于 block/loop 实现的控制流。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;所以，如果你是个编译器开发者，想要体验一波 WebAssembly 的代码生成的话，大致需要做什么事呢？&lt;/p&gt;&lt;ul&gt;&lt;li&gt;翻一下 MDN 上 WebAssembly 的文档，大致知道怎么在 JavaScript 中编译和运行一个 binary 模块。Node.js 中的接口大致相同，不过不支持流式编译。&lt;/li&gt;&lt;li&gt;可以通过拼接文本生成 S-exp 源代码，然后调 wabt 生成 binary，或者调用 binaryen 的接口。&lt;/li&gt;&lt;li&gt;拿到 binary 之后，再生成一个很小的 JavaScript wrapper 脚本，这个脚本负责读入 binary 然后执行。&lt;/li&gt;&lt;li&gt;有什么不理解的地方，多做做实验，然后回头翻一下 WebAssembly spec。不过，一开始一行代码都不写就去翻 spec，我是不推荐的，很容易自以为看懂了结果根本不是那么回事。一点小小的人生经验（逃&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;预定下一期介绍 asterius 编译器的代码生成器。&lt;/p&gt;</description>
<author>Felis sapiens</author>
<guid isPermaLink="false">2018-08-05-41324925</guid>
<pubDate>Sun, 05 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Linear type入门</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-08-04-41266828.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41266828&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;linear type是类型系统的一种扩展，可以实现在编译期指定资源必须且只能使用一次，另外LT的特性也表达了量子力学不可复制原理。为了在Haskell中实现LT，我们只需要引入一个新的linear函数类型：⊸ 。这个新类型和原来的普通函数类型 -&amp;gt;  很相似，但是在定义一个a⊸b的linear函数时，其参数a必须使用一次，即给定a计算b时，a必须要使用而且只能用一次。比如下面这2种都无法通过编译：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fst :: (a,b) ⊸ a
fst (x,_) = x

dup :: a ⊸ (a,a)
dup x = (x,x)
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;a href=&quot;https://www.tweag.io/posts/2017-03-13-linear-types.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Linear typesmake performance more predictable&lt;/a&gt;&lt;p&gt;另外，现在很火的Rust是affine type system（move semantics）,与Linear type同属Substructural type system,不同之处是参数最多使用一次，而不是必须使用一次。&lt;/p&gt;&lt;a href=&quot;https://gankro.github.io/blah/linear-rust/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;The Pain Of Real Linear Types in Rust&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Martin awodey</author>
<guid isPermaLink="false">2018-08-04-41266828</guid>
<pubDate>Sat, 04 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Contravariant Functors</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-07-21-40272611.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40272611&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5c90cc84819d9084f9b13fc09bd6abf2_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;a href=&quot;https://youtu.be/IJ_bVVsQhvc&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;George Wilson - Contravariant Functors: The Other Side of the Coin (youtube)&lt;/a&gt;&lt;p&gt;吃外卖的时候看的, 不长又欢乐的一个 talk.&lt;/p&gt;&lt;p&gt;从 Contravariant 的  Functor 开始介绍它的 Applicative , Alternative 版: Divisible 和 Decidable.&lt;/p&gt;&lt;p&gt;一开始拿 predicate 作为 Contravariant 的例子,  自嘲 so boring 之后换 pretty printer 作为例子最后总结出:&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e31336410b2e758342acc23eaedc4c23_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1396&quot; data-rawheight=&quot;780&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e31336410b2e758342acc23eaedc4c23&quot; data-watermark-src=&quot;v2-b4b6daa28d4c5aaee30d9f7cca8d7d8a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt; Applicative, Alternative 一个比较 practical 的例子是 async 里的 &lt;a href=&quot;https://hackage.haskell.org/package/async/docs/Control-Concurrent-Async.html#t:Concurrently&quot;&gt;Concurrently&lt;/a&gt;, 当 fork 出多个 “线程” 一起计算结果的时候, 所有结果都要就是 applicative, 只需要其中一个就是 alternative (how to combine multiple results). 另外的例子可以看 Parser Combinator (Parser Combinator 真是万能的例子&lt;/p&gt;&lt;p&gt;Contravariant, Divisible, Decidable 的中缀运算符设计得也特别有意思, 就是把&quot;&amp;lt;&amp;gt;&quot;到过来变&quot;&amp;gt;&amp;lt;&quot;, Haskell 里的运算符设计还是有点规律的不是鬼画符  XD&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;BTW, 这个 talk 很好地展现用 Haskell 的语言特性&amp;lt;del&amp;gt;猫论&amp;lt;/del&amp;gt;做抽象吸引我的一面:&lt;/p&gt;&lt;p&gt;type class hierarchy 就是个做抽象跟复用的地图: 当发现一个东西是 Functor 的时候就会想这货有没有可能也是一个 Applicative/Alternative ? 如果是, 这个 “computation”(type class) 在这个 context 下代表什么操作? 更进一步如果是 Applicative 的话, 有没有可能是 Monad? 这个 talk QA部分就有人问是不是 Monad, George 小哥早就准备好了答案 XD.&lt;/p&gt;&lt;p&gt;而且这种抽象和复用不像一些&quot;设计模式&quot;一样, 只能靠例子和自然语言来描述, 它们是有 law 的, talk 里每次提到 law 大家都会欢呼一下 XD&lt;/p&gt;&lt;p&gt;这些抽象的关系有时候就调换个参数(Contravariant), 反转个箭头(monad -&amp;gt; comonad), uncurry 一下 (学 Haskell 真不需要懂多少猫论的, 会看类型签名就好&lt;/p&gt;&lt;p&gt;当然了 &lt;a href=&quot;http://hackage.haskell.org/package/contravariant&quot;&gt;contravariant&lt;/a&gt; 这个库的作者依旧是神奇的 Edward Kmett, 如果想知道更多 Functor 请看依旧是 George Wilson 小哥去年同样在 YOW! Lambda Jam 的 &lt;a href=&quot;https://youtu.be/JUVMiRRq6wU&quot;&gt;The Extended Functor Family&lt;/a&gt;, 当然了里面提到的库都是 Edward Kmett 写的. George Wilson 的 talk 都好赞, 写的库也是.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;(别看到 Haskell 就 BB Monad 了, 还有很多可以 BB 是不是 &lt;/p&gt;</description>
<author>祖与占</author>
<guid isPermaLink="false">2018-07-21-40272611</guid>
<pubDate>Sat, 21 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Safety and Liveness Properties</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-07-15-37864854.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37864854&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在程序运行时, 我们会特别在意程序的一些性质(Program properties), 例如程序正确, 程序停机, 无异常等等. 对于我们关心的程序性质, 将可以分为两类:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;Safety Properties&lt;/b&gt;, 在程序运行中不会进入非预期的状态(如非法调用参数, 数组下标越界等运行错误).&lt;/li&gt;&lt;li&gt;&lt;b&gt;Liveness Properties&lt;/b&gt;, 在程序运行中预期状态一定会到达(如停机, 获取资源请求一定有返回结果等等).&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面将介绍程序性质的拓扑结构, 最后展示对于任意程序性质, 均可将其分解为其Safety分量(safety component)与Liveness分量(liveness component)的交.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义1: 转移系统(transition system)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;转移系统由一个状态集合 &lt;equation&gt;\Sigma&lt;/equation&gt; 与转移关系 &lt;equation&gt;\to\subseteq\Sigma\times\Sigma&lt;/equation&gt; 构成, 形如 &lt;equation&gt;\langle\Sigma,\to\rangle&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;其中状态表示程序执行的当前状态, 一般由当前执行程序位置(指令指针)与程序符号值(内存空间)构成. 转移关系由程序语义定义.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义2: 轨迹(trace)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\Sigma^{*} = \bigcup_{k=0}^{}\Sigma^{k}\\ &amp;amp;\Sigma^{\overrightarrow{*}} = \left\{ \sigma=(\sigma_1\sigma_2\cdots\sigma_k)\in \Sigma^{*}\;|\;\forall i&amp;lt;|\sigma|:\sigma_i \to\sigma_{i+1}\right\} \\ &amp;amp;\Sigma^{\overrightarrow{\omega}} = \left\{ \sigma=(\sigma_1\sigma_2\sigma_3\cdots)\in \Sigma^{\omega}\;|\;\forall i:\sigma_i \to\sigma_{i+1}\right\}\\ &amp;amp;\Sigma^{\overrightarrow{\infty}} = \Sigma^{\overrightarrow{*}}\cup\Sigma^{\overrightarrow{\omega}} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;( &lt;equation&gt;|\sigma|&lt;/equation&gt; 为 &lt;equation&gt;\sigma&lt;/equation&gt; 的长度)&lt;/p&gt;&lt;p&gt;显然 &lt;equation&gt;\Sigma^{\overrightarrow{*}}\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , 其中 &lt;equation&gt;\sigma\in\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 称为trace.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义3: 拼接(concatenation), 前缀(prefix), 后缀(suffix), 拓展(extension)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对于 &lt;equation&gt;u=(u_1\cdots u_n)\in\Sigma^{\overrightarrow{*}}&lt;/equation&gt; , &lt;equation&gt;v=(v_1,v_2\cdots)\in\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , &lt;equation&gt;u_{n}\to v_1&lt;/equation&gt;, 记&lt;equation&gt;uv=(u_1\cdots u_n,v_1,v_2\cdots)&lt;/equation&gt; 为 &lt;equation&gt;u&lt;/equation&gt; 与 &lt;equation&gt;v&lt;/equation&gt; 的拼接.&lt;/p&gt;&lt;p&gt;对于 &lt;equation&gt;U, V\subseteq \Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , 记 &lt;equation&gt;UV=\left\{ uv\;|\;u\in U,v\in V \right\}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;若 &lt;equation&gt;\exists v:uv=w &lt;/equation&gt; 则称 &lt;equation&gt;u&lt;/equation&gt; 为 &lt;equation&gt;w&lt;/equation&gt; 的前缀, &lt;equation&gt;v&lt;/equation&gt; 为 &lt;equation&gt;w&lt;/equation&gt; 的后缀, 记作 &lt;equation&gt;u\preceq w&lt;/equation&gt; , 称 &lt;equation&gt;w&lt;/equation&gt; 为 &lt;equation&gt;u&lt;/equation&gt; 的拓展, 记作 &lt;equation&gt;w\succeq u&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;空串为 &lt;equation&gt;\epsilon&lt;/equation&gt; , 其中有 &lt;equation&gt;|\varepsilon|=0&lt;/equation&gt; , &lt;equation&gt;\epsilon\sigma=\sigma\epsilon=\sigma&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义4: Prefix与Extension Closed&lt;/b&gt;&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; &lt;/p&gt;&lt;ul&gt;&lt;li&gt;若 &lt;equation&gt;\forall u\preceq v\in V&lt;/equation&gt; 有 &lt;equation&gt;u\in V&lt;/equation&gt; , 则称 &lt;equation&gt;V&lt;/equation&gt; 为prefix closed.&lt;/li&gt;&lt;li&gt;若 &lt;equation&gt;\forall w\succeq v\in V&lt;/equation&gt; 有 &lt;equation&gt;w\in V&lt;/equation&gt; , 则称 &lt;equation&gt;V&lt;/equation&gt; 为extension closed.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义5: Limit Closed与Finite Witnesses&lt;/b&gt;&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;若 &lt;equation&gt;\forall w\in \Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , 对于任意有限长度 &lt;equation&gt;u\preceq w&lt;/equation&gt; 均满足 &lt;equation&gt;u\in V&lt;/equation&gt; 那么有 &lt;equation&gt;w\in V&lt;/equation&gt; , 则称 &lt;equation&gt;V&lt;/equation&gt; 为limit closed.&lt;/li&gt;&lt;li&gt;若 &lt;equation&gt;\forall w\in V&lt;/equation&gt; , 存在有限长度 &lt;equation&gt;u\preceq w&lt;/equation&gt; 使得 &lt;equation&gt;u\in V&lt;/equation&gt; , 则称 &lt;equation&gt;V&lt;/equation&gt; 为finite witnesses.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;命题1:&lt;/b&gt; &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 为prefix closed(extension closed)集, 则&lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为extension closed(prefix closed)集.&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;若 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为非extension closed集, 则 &lt;equation&gt;\exists w\succeq v\in \Sigma^{\overrightarrow{\infty}}\setminus V: w\not\in \Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 即 &lt;equation&gt;w\in V&lt;/equation&gt; . 因为 &lt;equation&gt;V&lt;/equation&gt; 为prefix closed, 故 &lt;equation&gt;w\succeq v\in V&lt;/equation&gt; . 矛盾, 故 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为extension closed集.&lt;/p&gt;&lt;p&gt;类似地, 若 &lt;equation&gt;V&lt;/equation&gt; 为extension closed集, 则&lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为prefix closed集.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;命题2:&lt;/b&gt; &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 为limit closed(finite witnesses)集, 则&lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为finite witnesses(limit closed)集.&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;若 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为非finite witnesses集, 则 &lt;equation&gt;\exists w\in \Sigma^{\overrightarrow{\infty}}\setminus V: \forall u\preceq w: u\not\in \Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; ( &lt;equation&gt;u&lt;/equation&gt; 长度有限) 即 &lt;equation&gt;\forall u\preceq w: u\in V&lt;/equation&gt; . 因为 &lt;equation&gt;V&lt;/equation&gt; 为limit closed, 故 &lt;equation&gt;w\in V&lt;/equation&gt; . 矛盾, 故 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为finite witnesses集.&lt;/p&gt;&lt;p&gt;类似地, 若 &lt;equation&gt;V&lt;/equation&gt; 为finite witnesses集, 则&lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为limit closed集.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义6: Topology space on &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; :  &lt;equation&gt;(\Sigma^{\overrightarrow{\infty}}, \tau)&lt;/equation&gt;&lt;/b&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;\tau&lt;/equation&gt; 为开集族(open sets), &lt;equation&gt;\tau = \left\{ W\Sigma^{\overrightarrow{\infty}}\;|\;W\subseteq\Sigma^{\overrightarrow{*}}\right\}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;命题3:&lt;/b&gt; &lt;equation&gt;\tau&lt;/equation&gt; 为开集族&lt;/p&gt;&lt;p&gt;证明: &lt;/p&gt;&lt;p&gt;• &lt;equation&gt;\emptyset=W\Sigma^{\overrightarrow{\infty}}\in\tau&lt;/equation&gt; , 其中 &lt;equation&gt;W=\emptyset&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;• &lt;equation&gt;\Sigma^{\infty}=W\Sigma^{\overrightarrow{\infty}}\in\tau&lt;/equation&gt; , 其中 &lt;equation&gt;W=\{\epsilon\}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;• &lt;equation&gt;W_{\alpha}\subseteq\Sigma^{\overrightarrow{*}}&lt;/equation&gt; , &lt;equation&gt;\alpha\in I&lt;/equation&gt; , 有 &lt;equation&gt;\bigcup_{\alpha\in I}^{}(W_{\alpha}\Sigma^{\overrightarrow{\infty}})=W\Sigma^{\overrightarrow{\infty}}\in\tau&lt;/equation&gt; , 其中 &lt;equation&gt;W=\left( \bigcup_{\alpha\in I}^{}W_{\alpha} \right)\subseteq\Sigma^{\overrightarrow{*}}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;• &lt;equation&gt;U, V\subseteq \Sigma^{\overrightarrow{*}}&lt;/equation&gt; , 定义 &lt;equation&gt;U_{V}=\{u\in U\;|\;\exists v\in V: v\preceq u\}\subseteq U&lt;/equation&gt; , 类似地定义 &lt;equation&gt;V_{U}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;w\in U\Sigma^{\overrightarrow{\infty}}\cap V\Sigma^{\overrightarrow{\infty}}\\ \Leftrightarrow\;&amp;amp;\exists u\in U, v\in V: x, y\in \Sigma^{\overrightarrow{\infty}}, w=ux=vy\\ \Leftrightarrow\;&amp;amp;w\in V_U\Sigma^{\overrightarrow{\infty}}\;\text{or}\;w\in U_V\Sigma^{\overrightarrow{\infty}}\;(u\preceq v\;\text{or}\;v\preceq u) \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;   因此有 &lt;equation&gt;U\Sigma^{\overrightarrow{\infty}} \cap V\Sigma^{\overrightarrow{\infty}}=U_V\Sigma^{\overrightarrow{\infty}} \cup V_U\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , 设 &lt;equation&gt;W=U_V \cup V_U\subseteq\Sigma^{\overrightarrow{*}}&lt;/equation&gt; , 那么&lt;/p&gt;&lt;p&gt;&lt;equation&gt;U\Sigma^{\overrightarrow{\infty}} \cap V\Sigma^{\overrightarrow{\infty}}=W\Sigma^{\overrightarrow{\infty}}\in \tau&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;故 &lt;equation&gt;(\Sigma^{\overrightarrow{\infty}}, \tau)&lt;/equation&gt; 为 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 上的一个拓扑.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;引理1:&lt;/b&gt; &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 为闭集当且仅当:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\forall w\in \Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 若对于任意有限长度 &lt;equation&gt;u\preceq w&lt;/equation&gt; 存在 &lt;equation&gt;v\succeq u&lt;/equation&gt; 使得 &lt;equation&gt;v\in V&lt;/equation&gt; , 那么 &lt;equation&gt;w\in V&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;(\Rightarrow)&lt;/equation&gt; 若 &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 为闭集, 则存在 &lt;equation&gt;U\subseteq\Sigma^{\overrightarrow{*}}&lt;/equation&gt; 满足 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V=U\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , 若 &lt;equation&gt;w\in \Sigma^{\overrightarrow{\infty}}, w\not\in V&lt;/equation&gt; , 那么 &lt;equation&gt;w\in U\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , 存在长度有限前缀 &lt;equation&gt;u\preceq w, u\in U&lt;/equation&gt; , 有 &lt;equation&gt;\forall v\succeq u: v\in U\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 即 &lt;equation&gt;v\not\in V&lt;/equation&gt; , 故逆否命题&lt;equation&gt;(\forall (w\in \Sigma^{\overrightarrow{\infty}}, \text{finite}\;u\preceq w): \exists v\succeq u: v\in V) \to w\in V&lt;/equation&gt; 成立.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;(\Leftarrow)&lt;/equation&gt; 令 &lt;equation&gt;U=\left\{ u\in\Sigma^{\overrightarrow{*}}\;|\; \forall v\succeq u: v\not\in V \right\}&lt;/equation&gt;, 显然 &lt;equation&gt;U\Sigma^{\overrightarrow{\infty}}\subseteq\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; . 若 &lt;equation&gt;w\not\in V&lt;/equation&gt; 则有 &lt;equation&gt;\exists \text{finite}\;u\preceq w: \forall v\succeq u: v\not\in V&lt;/equation&gt; , 那么 &lt;equation&gt;u\in U&lt;/equation&gt; 故 &lt;equation&gt;\exists v:uv=w&lt;/equation&gt; 即 &lt;equation&gt;w\in U\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V\subseteq U\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; . 因此 &lt;equation&gt;U\Sigma^{\overrightarrow{\infty}}=\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为开集, 即 &lt;equation&gt;V&lt;/equation&gt; 为闭集.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;命题4: open and closed set&lt;/b&gt;&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;equation&gt;V&lt;/equation&gt; 为闭集当且仅当 &lt;equation&gt;V&lt;/equation&gt; 为prefix closed与limit closed.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;V&lt;/equation&gt; 为开集当且仅当 &lt;equation&gt;V&lt;/equation&gt; 为extension closed与finite witnesses.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;• &lt;equation&gt;(\Rightarrow)&lt;/equation&gt; 若 &lt;equation&gt;V&lt;/equation&gt; 为闭集, 对于任意 &lt;equation&gt;u\preceq v\in V&lt;/equation&gt; , 设 &lt;equation&gt;u^{&#39;}&lt;/equation&gt; 为 &lt;equation&gt;u&lt;/equation&gt; 的任意有限前缀 &lt;equation&gt;u^{&#39;}\preceq u&lt;/equation&gt; , 有 &lt;equation&gt;v\succeq u \succeq u^{&#39;}&lt;/equation&gt; , 根据引理1得 &lt;equation&gt;u\in V&lt;/equation&gt; 即 &lt;equation&gt;V&lt;/equation&gt; 为prefix closed. &lt;/p&gt;&lt;p&gt;由引理1直接可得 &lt;equation&gt;V&lt;/equation&gt; 为limit closed.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;(\Leftarrow)&lt;/equation&gt; 若 &lt;equation&gt;V&lt;/equation&gt; 为prefix closed与limit closed, 若 &lt;equation&gt;w\not\in V&lt;/equation&gt; 即 &lt;equation&gt;w\in \Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; , 由命题1和命题2得, &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为extension closed与finite witnesses, 由finite witnesses存在有限长度 &lt;equation&gt;u\preceq w&lt;/equation&gt; 使得 &lt;equation&gt;u\in \Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; , 又由extension closed对于任意 &lt;equation&gt;v\succeq u&lt;/equation&gt; 均有 &lt;equation&gt;v\in \Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 即 &lt;equation&gt;v\not\in V&lt;/equation&gt; , 故其逆否命题&lt;equation&gt;(\forall (w\in \Sigma^{\overrightarrow{\infty}}, \text{finite}\;u\preceq w): \exists v\succeq u: v\in V) \to w\in V&lt;/equation&gt; 成立. 由引理1得 &lt;equation&gt;V&lt;/equation&gt; 为闭集.&lt;/p&gt;&lt;p&gt;•   &lt;equation&gt;V&lt;/equation&gt; 为开集当且仅当 &lt;equation&gt;V&lt;/equation&gt; 为extension closed与finite witnesses.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\Leftrightarrow&lt;/equation&gt; &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为prefix closed与limit closed. (命题1和命题2)&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\Leftrightarrow&lt;/equation&gt; &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为闭集 (proved above)&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\Leftrightarrow&lt;/equation&gt; &lt;equation&gt;V&lt;/equation&gt; 为开集&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;命题5: closure与interior&lt;/b&gt;&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;equation&gt;cl(V)=\left\{ w\in\Sigma^{\overrightarrow{\infty}} \;|\; \forall \text{finite}\;u\preceq w:\exists v\succeq u: v\in V\right\}&lt;/equation&gt;.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;int(V)=\left\{ w\in\Sigma^{\overrightarrow{\infty}} \;|\; \exists \text{finite}\;u\preceq w:\forall v\succeq u: v\in V\right\}&lt;/equation&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;• 令 &lt;equation&gt;C(V)=\left\{ w\in\Sigma^{\overrightarrow{\infty}} \;|\; \forall \text{finite}\;u\preceq w:\exists v\succeq u: v\in V\right\}&lt;/equation&gt; , &lt;equation&gt;\forall w\in \Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 若对于任意有限长度 &lt;equation&gt;u\preceq w&lt;/equation&gt; 存在 &lt;equation&gt;v\succeq u&lt;/equation&gt; 使得 &lt;equation&gt;v\in C(V)&lt;/equation&gt; , 由 &lt;equation&gt;C(V)&lt;/equation&gt; 的定义存在 &lt;equation&gt;v^{&#39;}\succeq u&lt;/equation&gt; 使得 &lt;equation&gt;v^{&#39;}\in V&lt;/equation&gt; , 故 &lt;equation&gt;w\in C(V)&lt;/equation&gt; 由引理1得 &lt;equation&gt;C(V)&lt;/equation&gt; 为闭集.&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;V\subseteq \Gamma \subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , &lt;equation&gt; \Gamma&lt;/equation&gt; 为闭集, 设 &lt;equation&gt;w\in C(V)&lt;/equation&gt; 那么有 &lt;equation&gt;\forall \text{finite}\;u\preceq w:\exists v\succeq u: v\in V \subseteq \Gamma &lt;/equation&gt; , 又由 &lt;equation&gt; \Gamma&lt;/equation&gt; 为闭集, 根据引理1得 &lt;equation&gt;w\in \Gamma&lt;/equation&gt; 即 &lt;equation&gt;C(V)\subseteq\Gamma&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;故 &lt;equation&gt;C(V)&lt;/equation&gt; 为 &lt;equation&gt;V&lt;/equation&gt; 的closure.&lt;/p&gt;&lt;p&gt;• 令 &lt;equation&gt;I(V)=\left\{ w\in\Sigma^{\overrightarrow{\infty}} \;|\; \exists\text{finite}\;u\preceq w:\forall v\succeq u: v\in V\right\}&lt;/equation&gt; , 设 &lt;equation&gt;w\in I(V)&lt;/equation&gt; 那么 &lt;equation&gt;\exists\text{finite}\;u\preceq w:\forall v\succeq u: v\in V&lt;/equation&gt; , 由 &lt;equation&gt;I(V)&lt;/equation&gt; 的定义 &lt;equation&gt;\forall v\succeq u: v\in I(V)&lt;/equation&gt; , 故 &lt;equation&gt;w\in u\Sigma^{\overrightarrow{\infty}}\subseteq I(V)&lt;/equation&gt; 且 &lt;equation&gt;u\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 为开集, &lt;equation&gt;I(V)=\bigcup_{w\in I(V)}^{}u\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 因此 &lt;equation&gt;I(V)&lt;/equation&gt; 为开集.&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;w\in\Delta\subseteq V&lt;/equation&gt; , &lt;equation&gt;\Delta&lt;/equation&gt; 为开集, 故存在 &lt;equation&gt;U \subseteq\Sigma^{\overrightarrow{*}}&lt;/equation&gt; 满足 &lt;equation&gt;w\in U\Sigma^{\overrightarrow{\infty}} \subseteq \Delta&lt;/equation&gt; , 因此 &lt;equation&gt;\exists u\in U: u\preceq w&lt;/equation&gt; , 故 &lt;equation&gt;\forall v\succeq u: v\in U\Sigma^{\overrightarrow{\infty}} \subseteq \Delta\subseteq V&lt;/equation&gt; , 根据 &lt;equation&gt;I(V)&lt;/equation&gt; 定义有 &lt;equation&gt;w\in I(V)&lt;/equation&gt; 即 &lt;equation&gt;\Delta\subseteq I(V)&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;故 &lt;equation&gt;I(V)&lt;/equation&gt; 为 &lt;equation&gt;V&lt;/equation&gt; 的interior.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义7: safety property与liveness property&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;若 &lt;equation&gt;\forall w\in\left(\Sigma^{\overrightarrow{\infty}}\setminus W\right): \exists\text{finite}\;u\preceq w\;\text{s.t.}\;\forall v:uv\in\left(\Sigma^{\overrightarrow{\infty}}\setminus W\right)&lt;/equation&gt; 则称 &lt;equation&gt;W&lt;/equation&gt; 为safety property.&lt;/li&gt;&lt;li&gt;若 &lt;equation&gt;\forall\text{finite}\;u:\exists v\;\text{s.t.}\;uv\in W&lt;/equation&gt; 则称 &lt;equation&gt;W&lt;/equation&gt; 为liveness property.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;注: safety property的含义为若某trace违反safety property则能通过其有限长度的前缀识别. liveness property的含义为对于任意的有限长度的trace, 总存在拓展满足liveness property.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;命题6:&lt;/b&gt; &lt;equation&gt;W&lt;/equation&gt; 为safety property当且仅当 &lt;equation&gt;W&lt;/equation&gt; 为闭集.&lt;/p&gt;&lt;p&gt;证明: &lt;/p&gt;&lt;p&gt;&lt;equation&gt;W&lt;/equation&gt; 为safety property&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\Leftrightarrow \forall w\in\left(\Sigma^{\overrightarrow{\infty}}\setminus W\right): \exists\text{finite}\;u\preceq w\;\text{s.t.}\;\forall v:uv\in\left(\Sigma^{\overrightarrow{\infty}}\setminus W\right)\\ &amp;amp;\Leftrightarrow \left(\forall w\not\in W\right)\to\left(\exists\text{finite}\;u\preceq w\;\text{s.t.}\;\forall u^{&#39;}\succeq u:u^{&#39;}\in\left(\Sigma^{\overrightarrow{\infty}}\setminus W\right)\right)\\ &amp;amp;\Leftrightarrow \left(\forall\text{finite}\;u\preceq w\;\text{s.t.}\;\exists u^{&#39;}\succeq u:u^{&#39;}\in W\right)\to w\in W \quad\text{[contrapositive]}\\ &amp;amp;\Leftrightarrow W\;\text{is closed}\;\quad\text{[lemma 1]}\\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;命题7: &lt;/b&gt;&lt;equation&gt;V&lt;/equation&gt; 为liveness property当且仅当 &lt;equation&gt;V&lt;/equation&gt; 稠密.&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;(\Rightarrow)&lt;/equation&gt; &lt;equation&gt;V&lt;/equation&gt; 为liveness property. 设 &lt;equation&gt;V\subseteq \Gamma&lt;/equation&gt; , &lt;equation&gt;\Gamma&lt;/equation&gt; 为闭集. 若存在 &lt;equation&gt;w\in\Sigma^{\overrightarrow{\infty}}\setminus \Gamma&lt;/equation&gt; 即 &lt;equation&gt;w\not\in\Gamma&lt;/equation&gt; , 由引理1得存在有限长度 &lt;equation&gt;u\preceq w&lt;/equation&gt; 对于任意 &lt;equation&gt;v\succeq u&lt;/equation&gt; 使得 &lt;equation&gt;v\not\in V&lt;/equation&gt; . 又由 &lt;equation&gt;V&lt;/equation&gt; 为liveness property, 故存在 &lt;equation&gt;v\succeq u&lt;/equation&gt; 满足 &lt;equation&gt;v\in V\subseteq \Gamma&lt;/equation&gt; , 矛盾. 故 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus \Gamma=\emptyset&lt;/equation&gt; 即 &lt;equation&gt;\Gamma=\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , &lt;equation&gt;V&lt;/equation&gt; 稠密.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;(\Leftarrow)&lt;/equation&gt; &lt;equation&gt;V&lt;/equation&gt; 稠密. 若 &lt;equation&gt;V&lt;/equation&gt; 不为liveness property, 则存在有限长度 &lt;equation&gt;u&lt;/equation&gt; 使得 &lt;equation&gt;\forall v\succeq u&lt;/equation&gt; 均有 &lt;equation&gt;v\not\in V&lt;/equation&gt; , 因此 &lt;equation&gt;u\Sigma^{\overrightarrow{\infty}}\subseteq\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 即 &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}\setminus u\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , 又 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus u\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 为闭集, 而 &lt;equation&gt;V&lt;/equation&gt; 稠密, 故 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus u\Sigma^{\overrightarrow{\infty}}=\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , &lt;equation&gt;u\Sigma^{\overrightarrow{\infty}}=\emptyset&lt;/equation&gt; 即 &lt;equation&gt;u&lt;/equation&gt; 不存在, 矛盾. 故 &lt;equation&gt;V&lt;/equation&gt; 为liveness property.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义8: safety component与liveness component&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;equation&gt;safe(V)=cl(V)&lt;/equation&gt; .&lt;/li&gt;&lt;li&gt;&lt;equation&gt;live(V)=\Sigma^{\overrightarrow{\infty}}\setminus \left( cl(V)\setminus V \right)&lt;/equation&gt; .&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;引理2:&lt;/b&gt; &lt;equation&gt;(X,\tau)&lt;/equation&gt; 为Topology space, &lt;equation&gt;Y\subseteq X&lt;/equation&gt; 则 &lt;equation&gt;X\setminus (cl(Y)\setminus Y)&lt;/equation&gt; 稠密.&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;X\setminus (cl(Y)\setminus Y)\subseteq Z&lt;/equation&gt; , &lt;equation&gt;Z&lt;/equation&gt; 为闭集.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;X\setminus Z \subseteq cl(Y) \setminus Y&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;又由 &lt;equation&gt;Y\subseteq cl(Y)&lt;/equation&gt; 故&lt;/p&gt;&lt;p&gt;&lt;equation&gt;Y\subseteq cl(Y)\setminus(X\setminus Z)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;X\setminus Z&lt;/equation&gt; 为闭集故 &lt;equation&gt;cl(Y)\setminus(X\setminus Z)&lt;/equation&gt; 亦为闭集, 那么有 &lt;equation&gt;cl(Y)\setminus(X\setminus Z) \subseteq cl(Y)&lt;/equation&gt; 即 &lt;equation&gt;X\setminus Z=\emptyset&lt;/equation&gt; ,&lt;equation&gt;Z=X&lt;/equation&gt; . 因此 &lt;equation&gt;X\setminus (cl(Y)\setminus Y)&lt;/equation&gt; 稠密.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;推论1: &lt;/b&gt;&lt;equation&gt;V&lt;/equation&gt; 为safety property当且仅当 &lt;equation&gt;safe(V)=V&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;由命题6得, &lt;equation&gt;V&lt;/equation&gt; 为safety property当且仅当 &lt;equation&gt;V&lt;/equation&gt; 为闭集, 故 &lt;equation&gt;V=cl(V)\overset{\mathrm{def}}{=}safe(V)&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;推论2:&lt;/b&gt; 对于任意 &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt;, &lt;equation&gt;safe(V)&lt;/equation&gt; 为safety property.&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;safe(V)\overset{\mathrm{def}}{=}cl(V)&lt;/equation&gt; 为闭集, 由命题6得, &lt;equation&gt;safe(V)&lt;/equation&gt; 为safety property.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;推论3:&lt;/b&gt; &lt;equation&gt;V&lt;/equation&gt; 为liveness property当且仅当 &lt;equation&gt;live(V)=V&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;由命题7得, &lt;equation&gt;V&lt;/equation&gt; 为liveness property当且仅当 &lt;equation&gt;V&lt;/equation&gt; 稠密, 故 &lt;equation&gt;cl(V)=\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; &lt;equation&gt;live(V)\overset{\mathrm{def}}{=}\Sigma^{\overrightarrow{\infty}}\setminus \left( cl(V)\setminus V \right)=\Sigma^{\overrightarrow{\infty}}\setminus \left( \Sigma^{\overrightarrow{\infty}}\setminus V \right)=V&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;推论4: &lt;/b&gt;对于任意 &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt;, &lt;equation&gt;live(V)&lt;/equation&gt; 为liveness property.&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;live(V)\overset{\mathrm{def}}{=}\Sigma^{\overrightarrow{\infty}}\setminus \left( cl(V)\setminus V \right)&lt;/equation&gt; 由引理2得其稠密, 由命题7得, &lt;equation&gt;live(V)&lt;/equation&gt; 为liveness property.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;引理3:&lt;/b&gt; &lt;equation&gt;(X,\tau)&lt;/equation&gt; 为Topology space, &lt;equation&gt;Y\subseteq X&lt;/equation&gt; 则&lt;/p&gt;&lt;p&gt;&lt;equation&gt;Y=cl(Y)\cap(X\setminus (cl(Y)\setminus Y))&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} cl(Y)\cap(X\setminus (cl(Y)\setminus Y))&amp;amp;=(X\cap cl(Y))\setminus ((cl(Y)\setminus Y)\cap cl(Y))\\ &amp;amp;=cl(Y)\setminus (cl(Y)\setminus Y)\\ &amp;amp;=Y \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定理1: property decomposition&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对于任意性质 &lt;equation&gt;P&lt;/equation&gt; , 其均可分解为safety component与liveness component的交.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;P=safe(P)\cap live(P)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} P&amp;amp;=safe(P)\cap live(P)\\ &amp;amp;\overset{\mathrm{def}}{=}cl(P)\cap\left(\Sigma^{\overrightarrow{\infty}}\setminus (cl(P)\setminus P)\right)\\ &amp;amp;=P\quad\text{[lemma 3]} \end{align}&lt;/equation&gt; &lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一个例子: &lt;/p&gt;&lt;p&gt;程序total correctness可以分解为partial correctness(safety component)与termination(liveness component).&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;equation&gt;\Upsilon\subseteq\Sigma&lt;/equation&gt; 为初始状态.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;\Omega\subseteq\Sigma&lt;/equation&gt; 为终止状态.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;\Psi\subseteq\Upsilon\times\Omega&lt;/equation&gt; 为partial correctness relation.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;\Phi\overset{\mathrm{def}}{=}\left\{ (s,s^{&#39;})\;|\;(s\in\Upsilon) \Rightarrow((s\to^{*}s^{&#39;})\wedge (s^{&#39;}\in\Omega)\wedge (s,s^{&#39;})\in\Psi)\right\}&lt;/equation&gt;为total correctness relation.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;partial correctness:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\forall s,s^{&#39;}\in\Sigma:\left((s\to^{*}s^{&#39;})\wedge (s\in\Upsilon)\wedge (s^{&#39;}\in\Omega))\right)\Rightarrow \left( (s,s^{&#39;})\in\Psi \right)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;termination:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\forall \sigma\in\Sigma^{\overrightarrow{*}}:\left( \sigma_0 \in\Upsilon \right)\Rightarrow\left(\exists l=|\sigma|:\sigma_l\in\Omega\right)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;total correctness:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\forall \sigma\in\Sigma^{\overrightarrow{*}}:\left(\exists l=|\sigma|:(\sigma_1,\sigma_l)\in\Phi\right)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\forall \sigma\in\Sigma^{\overrightarrow{*}}:\left( \sigma_0 \in\Upsilon \right)&amp;amp;\text{[initial states]}\\ \Rightarrow\;&amp;amp;\sigma_0 \in\Upsilon\wedge\exists l=|\sigma|:\sigma_l\in\Omega&amp;amp;\text{[termination]}\\ \Rightarrow\;&amp;amp;(\sigma_0, \sigma_l)\in\Psi&amp;amp;\text{[partial correctness]}\\ \Rightarrow\;&amp;amp;(\sigma_0, \sigma_l)\in\Phi&amp;amp;\text{[proving total correctness]}\\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;好久都没写新文章啦, 最近了解了一下程序性质的拓扑结构觉得还蛮有趣的, 所以来写个小文章介绍一下.  有机会将来再深入介绍一下在此之上与Linear temporal logic(LTL)的一些有趣的性质, 在model checking中有着比较多的应用.&lt;/p&gt;&lt;p&gt;谢谢大家的阅读~&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>梨梨喵</author>
<guid isPermaLink="false">2018-07-15-37864854</guid>
<pubDate>Sun, 15 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>tensorflow on idris学习项目</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-07-06-39147186.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/39147186&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;希望在idris中实现安全的深度学习api。目前已经成功调用C api获取tf版本&lt;/p&gt;&lt;a href=&quot;https://github.com/doofin/tensorflow-idris&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-03ab6f034de1e41a73ac9fd84abbf1bf&quot; data-image-width=&quot;420&quot; data-image-height=&quot;420&quot; data-image-size=&quot;ipico&quot;&gt;doofin/tensorflow-idris&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Martin awodey</author>
<guid isPermaLink="false">2018-07-06-39147186</guid>
<pubDate>Fri, 06 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>The combinator of combinator</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-06-18-38200636.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38200636&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;组合子的组合子&lt;/p&gt;&lt;p&gt;大雾~&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;最近把之前写的&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25411428&quot;&gt;Parser combinator&lt;/a&gt;拿了出来, 因为刚好想到一些有趣的东西. 之前的组合子是不能回溯的, 因为所有的组合子的构建是自下而上的, 当前组合子的语法分析只能看到其子组合子的综合属性, 返回一条分支的值之后便不再尝试其他分支. 这会对其表达能力造成一些限制.&lt;/p&gt;&lt;p&gt;一个解决办法是像一般的Parser combinator一样, 传入一个所有的当前分析位置的list, 对每一个位置进行分析, 保存所有分支的结果传出一个新的list.&lt;/p&gt;&lt;p&gt;我使用的是另一种思路, 对组合子的组合函数进行CPS变换, 这样每一个组合子除了能看见子组合子的综合属性还能看见后续的分析结果, 于是分支选择变成了可能, 即是对应与Direct style的回溯.&lt;/p&gt;&lt;p&gt;详细的构造请看文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25411428&quot;&gt;Parser combinator 在C++里的DSL&lt;/a&gt;更新的第4节, 是我新加入哒.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;为什么需要回溯呢? 那当然是我想到了一些好玩的东西啦, 在之前的文章里通过Parser combinator构造了一个小的四则运算计算器, 组合子是:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;ParserCombinator&amp;lt;int&amp;gt; Additive&lt;/code&gt;&lt;p&gt;返回的是表达式的语义值, 一个 &lt;equation&gt;\texttt{int}&lt;/equation&gt; 类型的数值表示算式的值.&lt;/p&gt;&lt;p&gt;于是问题来了, 很自然地会想到一个生成Parser combinator的Parser combinator是什么呢?&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一个典型的最简单的例子, 正则表达式!&lt;/p&gt;&lt;p&gt;对! 又是正则表达式~&lt;/p&gt;&lt;p&gt;理由很简单, 在Chomsky hierarchy里, 正则表达式是Type-3 grammars, 弱于Parser combinator描述的Type-2 grammars上下文无关文法. 显然地, 我们可以使用组合子来构造一个正则表达式的匹配器.&lt;/p&gt;&lt;p&gt;正则表达式的匹配器是一个返回 &lt;equation&gt;\texttt{bool}&lt;/equation&gt; 型的Parser combinator, 返回 &lt;equation&gt;\texttt{true}&lt;/equation&gt; 表示匹配成功.&lt;/p&gt;&lt;p&gt;对于正则表达式的字符匹配:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;ParserCombinator&amp;lt;bool&amp;gt; match;
match = (Token(ch) &amp;gt;&amp;gt; Return(true));&lt;/code&gt;&lt;p&gt;&lt;equation&gt;\texttt{ch}&lt;/equation&gt; 是需要匹配的 &lt;equation&gt;\texttt{char}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;对于正则表达式的连接&lt;equation&gt;\texttt{(+)}&lt;/equation&gt;:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;//ParserCombinator&amp;lt;bool&amp;gt; part_1, part_2;
ParserCombinator&amp;lt;bool&amp;gt; match;
match = part_1 + part_2 &amp;gt;&amp;gt; Return(true);&lt;/code&gt;&lt;p&gt;&lt;equation&gt;\texttt{part_1}&lt;/equation&gt; 和 &lt;equation&gt;\texttt{part_2}&lt;/equation&gt; 是子表达式.&lt;/p&gt;&lt;p&gt;对于正则表达式的分支 &lt;equation&gt;\texttt{(|)}&lt;/equation&gt; :&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;ParserCombinator&amp;lt;bool&amp;gt; match;
match = part_1 | part_2;&lt;/code&gt;&lt;p&gt;&lt;equation&gt;\texttt{part_1}&lt;/equation&gt; 和 &lt;equation&gt;\texttt{part_2}&lt;/equation&gt; 是子表达式.&lt;/p&gt;&lt;p&gt;对于正则表达式的闭包&lt;equation&gt;\texttt{(*)}&lt;/equation&gt;:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;ParserCombinator&amp;lt;bool&amp;gt; match;
match = match + unit &amp;gt;&amp;gt; Return(true) | Epsilon(true);&lt;/code&gt;&lt;p&gt;&lt;equation&gt;\texttt{unit}&lt;/equation&gt; 是子表达式.&lt;/p&gt;&lt;p&gt;有了以上的构造之后可以轻松地写出生成正则表达式组合子:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;ParserCombinator&amp;lt;ParserCombinator&amp;lt;bool&amp;gt;&amp;gt; unit, repeat, connection, branch, regex;

unit = Token([](char ch) { return ch != &#39;(&#39; &amp;amp;&amp;amp; ch != &#39;)&#39; &amp;amp;&amp;amp; ch != &#39;|&#39; &amp;amp;&amp;amp; ch != &#39;+&#39;; }) &amp;gt;&amp;gt;
	[](char ch)
{
	ParserCombinator&amp;lt;bool&amp;gt; match;
	match = (Token(ch) &amp;gt;&amp;gt; Return(true));
	return match;
} | &#39;\\&#39;_T + Token(AnyChar{}) &amp;gt;&amp;gt; [](Placeholder, char ch)
{
	ParserCombinator&amp;lt;bool&amp;gt; match;
	match = (Token(ch) &amp;gt;&amp;gt; Return(true));
	return match;
} | &#39;(&#39;_T + regex + &#39;)&#39;_T &amp;gt;&amp;gt; [](Placeholder, const ParserCombinator&amp;lt;bool&amp;gt;&amp;amp; unit, Placeholder)
{
	return unit;
};

repeat = unit + &#39;*&#39;_T &amp;gt;&amp;gt; [](const ParserCombinator&amp;lt;bool&amp;gt;&amp;amp; unit, Placeholder)
{
	ParserCombinator&amp;lt;bool&amp;gt; match;
	match = match + unit &amp;gt;&amp;gt; Return(true) | Epsilon(true);
	return match;
} | unit;

connection = connection + repeat &amp;gt;&amp;gt;
	[](const ParserCombinator&amp;lt;bool&amp;gt;&amp;amp; part_1, const ParserCombinator&amp;lt;bool&amp;gt;&amp;amp; part_2)
{
	ParserCombinator&amp;lt;bool&amp;gt; match;
	match = part_1 + part_2 &amp;gt;&amp;gt; Return(true);
	return match;
} | repeat;

branch = branch + &#39;|&#39;_T + connection &amp;gt;&amp;gt;
	[](const ParserCombinator&amp;lt;bool&amp;gt;&amp;amp; part_1, Placeholder, const ParserCombinator&amp;lt;bool&amp;gt;&amp;amp; part_2)
{
	ParserCombinator&amp;lt;bool&amp;gt; match;
	match = part_1 | part_2;
	return match;
} | connection;

regex = branch &amp;gt;&amp;gt; [](const ParserCombinator&amp;lt;bool&amp;gt;&amp;amp; match)
{
	ParserCombinator&amp;lt;bool&amp;gt; regex(match);
	regex.ReturnDefaultWhenFail(true);	//return false
	return regex;
};

std::string pattern = &quot;(a|b)*abb&quot;;
std::string match   = &quot;babaababb&quot;;

std::cout &amp;lt;&amp;lt; regex(pattern)(match) &amp;lt;&amp;lt; std::endl;
//print: 1&lt;/code&gt;&lt;p&gt;看到 &lt;equation&gt;\texttt{ParserCombinator&amp;lt;ParserCombinator&amp;lt;bool&amp;gt;&amp;gt;}&lt;/equation&gt; 了嘛, 于是我们在50行内写出了一个正则表达式引擎(特大雾).&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我感觉我都快成正则表达式专业户了(笑~). 其实我是用CPS改写了我的Parser combinator, 更新文章了不过感觉没什么人会看到, 于是来水了一篇文章(抱歉占用了大家宝贵的阅读时间).&lt;/p&gt;&lt;p&gt;继续拓展, 一个能生成生成Parser combinator的Parser combinator的Parser combinator会是什么呢? 这个嘛...嗯...我不知道. 更加地, 一个能生成自生Parser combinator的Parser combinator又会是什么呢(无限嵌套的递归类型, C++也里实现不出来呀哈)?&lt;/p&gt;&lt;p&gt;知道的小伙伴请告诉我&amp;gt;.&amp;lt;&lt;/p&gt;</description>
<author>梨梨喵</author>
<guid isPermaLink="false">2018-06-18-38200636</guid>
<pubDate>Mon, 18 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>PCP Theorem Part 2: Expander Graph</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-06-18-38113778.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38113778&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cfad1bac7ce7f070d2594ae717c075ac_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;上次我们证明了 &lt;equation&gt;\text{GAP-3SAT}_{1,s} \in \mathsf{NP-hard}&lt;/equation&gt; 和 PCP Theorem是等价的。事实上，在Dinur的证明中，她并没有直接证明 &lt;equation&gt;\text{GAP-3SAT}_{1,s} \in \mathsf{NP-hard}&lt;/equation&gt; 而是通过证明&lt;equation&gt;\text{GAP-3COLOR}_{1,s} \in \mathsf{NP-hard}&lt;/equation&gt; 来得到PCP Theorem。我们知道 &lt;equation&gt;\text{3COLOR} \in \text{NP-hard}&lt;/equation&gt; ,那么 &lt;equation&gt;\text{GAP-3COLOR}_{1,1-\frac{1}{m}} \in \mathsf{NP-hard}&lt;/equation&gt; 是显然的（一个无法被3COLOR的图，不管什么染色方案，至少有一条边不满足限制）。Dinur通过巧妙的构造把gap从 &lt;equation&gt;1-\frac{1}{m}&lt;/equation&gt; 放大到一个常数倍来得到这个结果。其中很大部分都是巧妙的利用 expander graph的性质，这篇文章会给大家补充一些expander graph的知识，在Part 3. 我们会正式进入 Dinur的证明。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;扩展图 (Expander Graph)&lt;/h2&gt;&lt;p&gt;扩展图是一种没有瓶颈的图，也就是说这是一种有很强的联通性的图。下面的定义就是根据它的这个性质定义的。&lt;/p&gt;&lt;p&gt;首先我们需要定义一下Edge Expansion（有的中文资料把他翻译成边扩展率）,对于一个图 &lt;equation&gt;G=(V,E)&lt;/equation&gt; 它的Edge Expansion定义如下&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\phi(G)=\min_{S\subseteq V,|S|\leq \frac{|V|}{2}} \frac{|E(S,\bar S)|}{|S|}&lt;/equation&gt;这里 &lt;equation&gt;\bar S=V\setminus S&lt;/equation&gt; ， &lt;equation&gt;E(S,\bar S) = \{(u,v) \in E | u \in S \text{ and }v\in \bar S\}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;我们说一个图的Edge Expansion是至少是一个正的常数的话，那我们称这个图是一个扩展图。事实上，找到一个扩展图并不难：任何一个完全图都是扩展图。然而在这里我们希望能够找到稀疏的扩展图：更加准确得说，我们希望找到一个扩展图而且它的每个点的度数都是一个常数d，对于这样的图，我们把它称为&lt;b&gt;d-正则扩展图&lt;/b&gt;。（我们把每个点度数都为d的图，叫做d-正则图）&lt;/p&gt;&lt;p&gt;为了方便我们后面的证明，下面介绍一些关于谱图论(Spectral Graph Theory)的记号：&lt;/p&gt;&lt;p&gt;对于一个d-正则图 &lt;equation&gt;G&lt;/equation&gt; ,我们用 &lt;equation&gt;A_G&lt;/equation&gt; 来表示 &lt;equation&gt;G&lt;/equation&gt; 所对应的邻接矩阵，因此对于没有边权且有重边的图 &lt;equation&gt;(A_G)_{i,j}&lt;/equation&gt; 表示i, j之间边的数量。因为&lt;equation&gt;A_G&lt;/equation&gt; 是实对称矩阵，所以它一定有 &lt;equation&gt;n &lt;/equation&gt; 个实数特征值，我们把它们标作 &lt;equation&gt;\lambda_1 \geq \lambda_2 \geq \ldots \geq \lambda_n&lt;/equation&gt; 。显然 &lt;equation&gt;\vec{1}&lt;/equation&gt; 是&lt;equation&gt;A_G&lt;/equation&gt;的一个特征向量，并且它的特征值是 &lt;equation&gt;d&lt;/equation&gt; 。我们可以轻易的证明 &lt;equation&gt;d &lt;/equation&gt; 是最大的特征值：&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;我们不妨设 &lt;equation&gt;\vec{x}&lt;/equation&gt; 是最大特征值 &lt;equation&gt;\lambda_1&lt;/equation&gt; 所对应的特征向量，那么我们有 &lt;equation&gt;\[|\lambda_1|x_k = |\sum_{j=1}^n A_{kj}x_j| \leq \sum_{j=1}^n A_{kj}|x_j| \leq \sum_{j=1}^n A_{kj}x_k = x_k \sum_{j=1}^n A_{kj} = dx_k .\]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;所以特征值一定小于等于d。&lt;/p&gt;&lt;p&gt;因为我们知道对于任意一个d-正则图，它最大的特征值总是d，我们更加关心它绝对值第二大的特征值。我们把这个特征值定义为 &lt;equation&gt;\lambda&lt;/equation&gt; ，也就是说 &lt;equation&gt;\lambda = \max_{i&amp;gt;1}\{|\lambda_i|\}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;定义2.1： &lt;/b&gt;对于一个有n个点的d-正则图 G，如果我们有 &lt;equation&gt;\lambda &amp;lt; d&lt;/equation&gt; ，那么我们把他称作 &lt;equation&gt;(n,d,\lambda)-\text{扩展图}&lt;/equation&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;定理2.2 (Cheeger&#39;s inequality)&lt;/b&gt;： &lt;equation&gt;\[\frac{\phi(G)^2}{2d} \leq d-\lambda \leq 2\phi(G)\]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;对于本文来说，我们只关心右边的不等式，所以我们只证明右边的。&lt;/p&gt;&lt;p&gt;证明：假设点集 &lt;equation&gt;S \subseteq V&lt;/equation&gt; 且 &lt;equation&gt;|S| \leq n/2&lt;/equation&gt; ，我们将证明 &lt;equation&gt;\phi(S) \geq (d -\lambda )/2&lt;/equation&gt; 。我们构造一个这样的向量 &lt;equation&gt;\vec{x} = \begin{cases} -|\bar S| &amp;amp; \text{ if } v\in S \\ |S| &amp;amp; \text{ if } v \in \bar S \end{cases}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;那么我们有 &lt;equation&gt;\vec{x}\cdot \vec{1}=\sum x_v=0&lt;/equation&gt; 所以 &lt;equation&gt;\vec{x}\perp\vec{1}&lt;/equation&gt; 。既然 &lt;equation&gt;\vec{x} \perp \vec{1}&lt;/equation&gt;，那么 &lt;equation&gt;\|A_G\vec{x}\| \leq \lambda \|\vec{x}\|&lt;/equation&gt;，因为我们证明了只有 &lt;equation&gt;\vec{1}&lt;/equation&gt; 才可能有比 &lt;equation&gt;\lambda&lt;/equation&gt; 更大的特征值。那么，我们有 &lt;equation&gt;\langle A_G\vec{x},\vec{x}\rangle \leq \|A_G\vec{x}\|\cdot \|\vec{x}\| \leq \lambda\|\vec{x}\|^2&lt;/equation&gt; ，而且 &lt;equation&gt;\|x\|^2=|S||\bar S|^2+|\bar S||S|^2=|S||\bar S|(|S|+|\bar S|)=|S||\bar S|n&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;现在，我们来算一下 &lt;equation&gt;\langle A_G\vec{x},\vec{x}\rangle&lt;/equation&gt; :&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align*} \langle A_G\vec{x},\vec{x}\rangle &amp;amp;= \sum_u x_u \sum_{(u,v)\in E} x_v \\ &amp;amp;= 2 \sum_{(u,v)\in E} x_ux_v \\ &amp;amp;= 2 \sum_{(u,v)\in E(S,S)} x_v + 2 \sum_{(u,v)\in E(\bar S, \bar S)} x_v + 2 \sum_{(u,v)\in E(S,\bar S)} x_v\\ &amp;amp;= (d|S|-|E(S,\bar S)|)|\bar S|^2 + (d|\bar S|-|E(S,\bar S)|)|S|^2 - 2|E(S, \bar S)||S||\bar S|\\ &amp;amp;=d|S||\bar S| n - |E(S,\bar S)|n^2 \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;然后我们知道 &lt;equation&gt;\langle A_G\vec{x},\vec{x}\rangle\leq \lambda\|\vec{x}\|^2&lt;/equation&gt; ,也就是 &lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align*} &amp;amp;d|S||\bar S| n - |E(S,\bar S)|n^2 \leq \lambda |S||\bar S|n \\ &amp;amp;\Rightarrow (d-\lambda)\leq \frac{|E(S,\bar S)|n}{|S||\bar S|} \\ &amp;amp;\Rightarrow \frac{(d-\lambda) |\bar S|}{n}\leq \frac{|E(S,\bar S)|}{|S|} \\ &amp;amp;\Rightarrow \frac{(d-\lambda) |\bar S|}{n}\leq \phi(G) \\ \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;因为 &lt;equation&gt;|S| \leq n/2&lt;/equation&gt; 那么 &lt;equation&gt;|\bar S| &amp;gt; n/2&lt;/equation&gt; ，所以 &lt;equation&gt; \frac{d-\lambda}{2}\leq \frac{(d-\lambda) |\bar S|}{n}\leq \phi(G) &lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;证毕&lt;/p&gt;&lt;p&gt;&lt;b&gt;定理2.3&lt;/b&gt;：如果G是一个d-正则图，H是一个d&#39;-正则图，且G和H的点集相同，那么 &lt;equation&gt;G&#39;=G\cup H=(V,E(G)\cup E(H))&lt;/equation&gt; 是一个(d+d&#39;)-正则图，且满足 &lt;equation&gt;\lambda(G&#39;)\leq \lambda(G)+\lambda(H)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;证明: &lt;/p&gt;&lt;p&gt;假设 &lt;equation&gt;\vec{x}&lt;/equation&gt; 满足 &lt;equation&gt;\|x\|=1&lt;/equation&gt; ， &lt;equation&gt;\vec{x}\perp \vec{1}&lt;/equation&gt; ，且 &lt;equation&gt;\lambda(G&#39;)=\langle A_{G&#39;}\vec{x},\vec{x}\rangle&lt;/equation&gt; 。那么&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align*} \langle A_{G&#39;}\vec{x},\vec{x}\rangle &amp;amp;= \langle A_{G}\vec{x},\vec{x}\rangle + \langle A_{H}\vec{x},\vec{x}\rangle \\ &amp;amp; \leq \lambda(G) + \lambda(H) \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;证毕。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定理2.4&lt;/b&gt;: 我们能找到常数 d 和 &lt;equation&gt;\lambda&lt;/equation&gt; (&lt;equation&gt;\lambda &amp;lt; d&lt;/equation&gt;)，使得对于任意整数 n 我们都能找到一个 &lt;equation&gt;(n,d,\lambda&#39;)-\text{正则图}&lt;/equation&gt;  (&lt;equation&gt;\lambda &#39; &amp;lt; \lambda&lt;/equation&gt; )。&lt;/p&gt;&lt;p&gt;在这里我们会给出这样的例子，但是并不会给出证明。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Gaber-Galil Expanders&lt;/b&gt;: 我们可以构造出有 &lt;equation&gt;n^2&lt;/equation&gt; 个点的拓展图，对于一个点 &lt;equation&gt;v=(x,y)&lt;/equation&gt; ，把它连向下列点 &lt;equation&gt;(x+2y,y),(x,2x+y),(x+2y+1,y),(x,2x+y+1)&lt;/equation&gt;  这里的加法是模n意义下的加法。这是一个8-正则图，且我们能够证明 &lt;equation&gt;\lambda \leq 5\sqrt 2 &amp;lt; 8&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;课后习题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;证明 &lt;equation&gt;\lambda_n=-d&lt;/equation&gt; 当且仅当图 G 是一个二分图。&lt;/li&gt;&lt;li&gt;证明 &lt;equation&gt;\lambda_2 &amp;lt; d&lt;/equation&gt; 当且仅当图 G 是一个联通图。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在下一节中，我们将运用这节关于扩展图的结论来讲解Dinur证明的前两部，并粗略的证明这个方向是可行的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Guanghao Ye</author>
<guid isPermaLink="false">2018-06-18-38113778</guid>
<pubDate>Mon, 18 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>PCP Theorem Part 1: Introduction</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-06-13-37270132.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37270132&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cfad1bac7ce7f070d2594ae717c075ac_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;PCP Theorem的定义&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们先给出一个传统的&lt;b&gt;证明系统&lt;/b&gt; (proof system)的定义：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;我们有一个命题 (statement)&lt;/li&gt;&lt;li&gt;有一个证明者 (prover) 会给出一个证明对上面的命题证明或证否&lt;/li&gt;&lt;li&gt;验证者(verifier)检查上述证明，然后接受或拒绝这个证明&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;The PCP (Probabilistically Checkable Proof) Theorem&lt;/b&gt;: &lt;/p&gt;&lt;p&gt;对于任何一个在NP里面的语言 &lt;equation&gt;L &lt;/equation&gt; ，我们都有一个如下的P.C.P. 系统&lt;/p&gt;&lt;ul&gt;&lt;li&gt;对于一个长为n的输入&lt;/li&gt;&lt;li&gt;然后证明者给出一个多项式长度的证明&lt;/li&gt;&lt;li&gt;验证者生成 &lt;equation&gt;O(\log n)&lt;/equation&gt; 长度的随机串，根据这个随机串在证明里面随机的选 &lt;equation&gt;C&lt;/equation&gt; 个位置。这里的 &lt;equation&gt;C&lt;/equation&gt; 是一个常数。&lt;/li&gt;&lt;li&gt;验证者读取这 &lt;equation&gt;C&lt;/equation&gt; 个位置的内容，然后进行测试来决定接受或拒绝这个证明。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里的验证者要满足如下条件:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;可靠性：对于任何不满足条件的输入，验证者接受它的概率不超过一半&lt;/li&gt;&lt;li&gt;完备性：对于如何满足条件的输入，验证者一定接受它&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;PCP Theorem和 &lt;equation&gt;\textrm{GAP-3SAT} \in \textrm{NP-hard}&lt;/equation&gt; 等价&lt;/h2&gt;&lt;p&gt;&lt;equation&gt;\textrm{GAP-3SAT} _{c, s}(0&amp;lt;s\leq c\leq 1)&lt;/equation&gt; 的定义：给一个有m个子句(clause)的3SAT的表达式，假设我们最多能满足其中的 &lt;equation&gt;k&lt;/equation&gt; 个句子。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果 &lt;equation&gt;k\geq cm&lt;/equation&gt; ，接受这个表达式&lt;/li&gt;&lt;li&gt;如果 &lt;equation&gt;k &amp;lt; sm &lt;/equation&gt; ，拒绝这个表达式&lt;/li&gt;&lt;li&gt;如果 &lt;equation&gt;sm \leq k &amp;lt; cm&lt;/equation&gt; ，我们不在意这种情况，随机选择&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定理1&lt;/b&gt;. PCP Theorem和 &lt;equation&gt;\textrm{GAP-3SAT}_{1,s} \in \textrm{NP-hard}&lt;/equation&gt; 是等价的&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\Leftarrow&lt;/equation&gt;  假设 &lt;equation&gt;\textrm{GAP-3SAT}_{1,s} \in \textrm{NP-hard}&lt;/equation&gt;。我们这里会证明3COLOR有P.C.P.系统。假设输入是一个有 &lt;equation&gt;n &lt;/equation&gt; 个点的图G。那么验证者首先把这个输入归于到一个有m个子句的 &lt;equation&gt;\textrm{GAP-3SAT}_{1,s}&lt;/equation&gt; 表达式 &lt;equation&gt;\phi&lt;/equation&gt; 。这个时候证明者会被要求给出一个 &lt;equation&gt;\phi&lt;/equation&gt; 的赋值。然后此时证明者，只需要随机选择一个子句，获得对应的三个布尔变量的赋值就好了。这个时候显然 &lt;equation&gt;C=3&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;可靠性 (Soundness)：如果G不能被三染色的话，那么我们有 &lt;equation&gt;\phi&lt;/equation&gt; 满足的子句小于 &lt;equation&gt;sm&lt;/equation&gt; 。那么我们随机选择的子句不满足的概率是 &lt;equation&gt;s&lt;/equation&gt; 。如果这个时候 &lt;equation&gt;s&amp;gt;\frac{1}{2}&lt;/equation&gt; 的话，我们重复 &lt;equation&gt;O(1)&lt;/equation&gt; 次就好了。&lt;/p&gt;&lt;p&gt;完备性 (Completeness)：如果G可以被三染色的话，那么&lt;equation&gt;\phi&lt;/equation&gt; 一定可以全部被满足。所以我们接受的概率是1。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\Rightarrow&lt;/equation&gt; 假设我们有PCP theorem，这个时候我们把3COLOR规约到 &lt;equation&gt;\textrm{GAP-3SAT}_{1,s} &lt;/equation&gt; 来证明 &lt;equation&gt;\textrm{GAP-3SAT}_{1,s} &lt;/equation&gt; 是NP-hard的。首先我们有PCP theorem，那么我们可以得到一个多项式长度的证明，在这里我们会认为证明是对于一个3SAT表达式的赋值。然后，我们用 &lt;equation&gt;O(\log n)&lt;/equation&gt; 长度的随机串生成 &lt;equation&gt;2^{O(\log n)}=\text{poly}(n)=N&lt;/equation&gt; 个随机选择。对于每个这样的选择，我们会生成 &lt;equation&gt;C&lt;/equation&gt;个位置，然后读取这 &lt;equation&gt;C&lt;/equation&gt;个位置的值，把他们标作 &lt;equation&gt;x_1,x_2,\ldots,x_C&lt;/equation&gt; 。我们定义一个布尔函数 &lt;equation&gt;H(x_1,x_2,\ldots,x_C)&lt;/equation&gt; ，当原有的3SAT表达式能在不改变这C个位置的值满足时返回一，否则返回0。因为Cook-Levin Theorem，我们知道我们可以在多项式的时间内生成这个函数对应的3SAT表达式。因为只有 &lt;equation&gt;C&lt;/equation&gt; 个变量，我们不妨假设这个对应3SAT表达式有 &lt;equation&gt;K=2^C\cdot C&lt;/equation&gt; 个子句。然后，我们用 &lt;equation&gt;\land&lt;/equation&gt; 把这 &lt;equation&gt;N&lt;/equation&gt; 个长度为 &lt;equation&gt;K&lt;/equation&gt; 的表达式连接在一起，得到了一个有 &lt;equation&gt;N\cdot K&lt;/equation&gt; 的3SAT表达式 &lt;equation&gt;\phi&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;完备性 (Completeness)：如果原有的输入是可以三染色的话，那么我们一定可以得到完美的证明，或者说一个满足所有子句的赋值。那么我们新的3SAT表达式显然是可以满足所有子句的。&lt;/p&gt;&lt;p&gt;可靠性 (Soundness)：如果原有的输入不是三染色的话，那么根据PCP theorem，我们每次至少有一半的机会得到一个不可满足的3SAT表达式。那么这个3SAT表达式不可满足的时候，它最多有 &lt;equation&gt;K-1=K(1-\frac{1}{K})&lt;/equation&gt; 个可以满足的子句。那么对于 &lt;equation&gt;\phi&lt;/equation&gt; ，我们能够同时满足的不超过 &lt;equation&gt;\frac{N}{2}K(1-\frac{1}{K})+\frac{N}{2}K=NK(1-\frac{1}{2K})=m(1-\frac{1}{2K})&lt;/equation&gt; 。也就是说我们能够得到一个常数 &lt;equation&gt;s=1-\frac{1}{2K}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们后面将通过证明 &lt;equation&gt;\textrm{GAP-3SAT}_{1,s} \in \textrm{NP-hard}&lt;/equation&gt; 来证明PCP theorem。&lt;/p&gt;&lt;p&gt;在下一节中，我们将介绍Expander Graph和它的一些基本定理，来为后面的证明做一些铺垫&amp;gt;_&amp;lt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;P.S. 感觉中文写得很别扭，欢迎大家提出翻译上的建议。如果实在看不懂我在写什么的话，可以和&lt;a href=&quot;https://courses.cs.washington.edu/courses/cse533/05au&quot;&gt;我校05年的Notes&lt;/a&gt;的Lec 1, 2交叉阅读。&lt;/p&gt;</description>
<author>Guanghao Ye</author>
<guid isPermaLink="false">2018-06-13-37270132</guid>
<pubDate>Wed, 13 Jun 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
