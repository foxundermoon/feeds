<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Thu, 08 Mar 2018 15:18:00 +0800</lastBuildDate>
<item>
<title>[公告] Idris-zh 中文翻译项目启动</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-07-34328106.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34328106&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-581b50e22da06e58321ea076d8ee5e8e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;Idris 是个通用的依赖类型纯函数式编程语言，比起 Coq 来说更注重现实世界的编程。说起来咱对这货感兴趣还是受了某莎某 be5 和某智猫的影响= =||&lt;/p&gt;&lt;p&gt;其实 Idris 中文文档翻译的坑很早就挖下了，可惜咱能力有限现在才正式启动。目前只翻译了官方教程的第一章，大家可以在 &lt;a href=&quot;http://idris-zh.readthedocs.io/&quot;&gt;Idris-zh 文档主页&lt;/a&gt; 查看。对应的 &lt;a href=&quot;https://github.com/Idris-zh/Idris-dev/tree/master/docs&quot;&gt;Idris-zh 项目地址&lt;/a&gt; 中可以找到源码。&lt;/p&gt;&lt;p&gt;官方文档的量并不算太多，本打算翻译完官方教程再说，不过咱最近忙于考试，加上人多力量大，思来想去还是在魔法店发个公告比较好。有兴趣的译者可以戳咱加入项目组一起翻译。&lt;/p&gt;&lt;p&gt;以上。&lt;/p&gt;</description>
<author>Oling Cat</author>
<guid isPermaLink="false">2018-03-07-34328106</guid>
<pubDate>Wed, 07 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Emacs之魂（七）：变量捕获与卫生宏</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-07-34106490.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34106490&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-be0646e5c6a0b48056bfdf78f3442375_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;843&quot; data-rawheight=&quot;370&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们介绍了宏，它与函数是不同的，函数调用发生在程序执行期间，函数在调用之前，会先对它所有的实参进行求值，然后将形参绑定到这些实参的求值结果上，函数的返回值会作为函数调用表达式的值，Lisp求值器不断的求值表达式，从而程序得以运行。&lt;/p&gt;&lt;p&gt;宏调用（macro call）发生在程序的编译期，或者说，宏调用发生在表达式的求值之前，在执行宏调用的过程中，宏形参直接绑定为实参所代表的语法对象（syntax object）上，宏调用的返回值，会进行表达式替换，将宏调用表达式替换为它的返回值，这个过程称为宏展开（macro expansion），之后在运行时，求值器就不会遇到宏了，所进行求值的只有被展开之后的表达式。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 交互函数&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在介绍常用的宏之前，我们先介绍Emacs中交互函数（interactive function）的概念。&lt;br&gt;交互函数可以使用&lt;code class=&quot;inline&quot;&gt;M-x&lt;/code&gt;在echo area中通过输入函数名进行调用（交互式调用），所以交互函数也称为命令（command）。&lt;br&gt;交互函数也可以被Lisp程序中的其他函数直接调用，这种调用方式称为非交互式调用。&lt;/p&gt;&lt;p&gt;Emacs中函数定义&lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Defining-Functions.html#Defining-Functions&quot;&gt;defun&lt;/a&gt;&lt;/code&gt;包含以下几个部分，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;defun name args [doc] [declare] [interactive] body ...&lt;/code&gt;&lt;p&gt;其中，&lt;code class=&quot;inline&quot;&gt;doc&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;declare&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;interactive&lt;/code&gt;都是可选的。&lt;/p&gt;&lt;p&gt;交互函数的定义中，具有&lt;code class=&quot;inline&quot;&gt;interactive&lt;/code&gt;部分，&lt;br&gt;它是一个形如&lt;code class=&quot;inline&quot;&gt;(interactive arg-descriptor)&lt;/code&gt;的表达式，用来指定该函数被交互调用时的行为，&lt;br&gt;对于非交互式调用，&lt;code class=&quot;inline&quot;&gt;interactive&lt;/code&gt;部分将失去作用。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;arg-descriptor&lt;/code&gt;有三种可能的写法：省略，一个字符串，或者一个Lisp表达式。&lt;br&gt;具体情况可能会比较复杂，可以参考&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Using-Interactive.html#Using-Interactive&quot;&gt;Using-Interactive&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.1 describe-key&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;describe-key&lt;/code&gt;是一个交互函数，用来展示某个快键键相关的文档信息，&lt;br&gt;我们可以使用&lt;code class=&quot;inline&quot;&gt;M-x describe-key&lt;/code&gt;来调用它，echo area中会显示如下内容，等待我们键入一个快捷键，&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e9c4d71238a11558bae673bd850860ce_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;678&quot; data-rawheight=&quot;121&quot;&gt;&lt;p&gt;如果我们键入一个快捷键，例如&lt;code class=&quot;inline&quot;&gt;C-a&lt;/code&gt;，Emacs就会展示出与&lt;code class=&quot;inline&quot;&gt;C-a&lt;/code&gt;相关的文档信息了。我们还可以使用快捷键&lt;code class=&quot;inline&quot;&gt;C-h k&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;C-h k&lt;/code&gt;相当于&lt;code class=&quot;inline&quot;&gt;M-x describe-key&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;C-a runs the command move-beginning-of-line (found in global-map),
which is an interactive compiled Lisp function in ‘simple.el’.

It is bound to C-a.

(move-beginning-of-line ARG)

Move point to beginning of current line as displayed.
(If there’s an image in the line, this disregards newlines
which are part of the text that the image rests on.)

With argument ARG not nil or 1, move forward ARG - 1 lines first.
If point reaches the beginning or end of buffer, it stops there.
To ignore intangibility, bind ‘inhibit-point-motion-hooks’ to t.&lt;/code&gt;&lt;p&gt;&lt;b&gt;1.2 describe-function&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;describe-function&lt;/code&gt;也是一个交互函数，用来展示某个函数（或者宏）相关的文档信息，它绑定到了快捷键&lt;code class=&quot;inline&quot;&gt;C-h f&lt;/code&gt;上，&lt;br&gt;调用后，echo area中会显示如下内容，等待我们输入函数（或者宏）的名字，&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d8c0390d2d4077bcdac4cdd5b810cf44_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;674&quot; data-rawheight=&quot;117&quot;&gt;&lt;p&gt;例如，&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;相关的文档信息如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;when is a Lisp macro in ‘subr.el’.

(when COND BODY...)

If COND yields non-nil, do BODY, else return nil.
When COND yields non-nil, eval BODY forms sequentially and return
value of last one, or nil if there are none.&lt;/code&gt;&lt;p&gt;它指出，&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;是一个宏，并且定义在&lt;code class=&quot;inline&quot;&gt;subr.el&lt;/code&gt;文件中。&lt;/p&gt;&lt;p&gt;鼠标左键点击&lt;code class=&quot;inline&quot;&gt;subr.el&lt;/code&gt;，会打开本地&lt;code class=&quot;inline&quot;&gt;subr.el.gz&lt;/code&gt;文件中&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;的定义，如下，&lt;br&gt;（文件路径为：&lt;code class=&quot;inline&quot;&gt;/Applications/Emacs.app/Contents/Resources/lisp/subr.el.gz&lt;/code&gt;&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(defmacro when (cond &amp;amp;rest body)
  &quot;If COND yields non-nil, do BODY, else return nil.
When COND yields non-nil, eval BODY forms sequentially and return
value of last one, or nil if there are none.
\(fn COND BODY...)&quot;
  (declare (indent 1) (debug t))
  (list &#39;if cond (cons &#39;progn body)))&lt;/code&gt;&lt;p&gt;可见，&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;只是一个语法糖，最终会展开成&lt;code class=&quot;inline&quot;&gt;if&lt;/code&gt;表达式。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;subr.el.gz&lt;/code&gt;文件中包含了很多常用的宏，&lt;br&gt;我们可以访问线上地址&lt;a href=&quot;https://github.com/emacs-mirror/emacs/blob/master/lisp/subr.el&quot;&gt;Github: emacs-mirror/emacs subr.el&lt;/a&gt;进行查阅。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 变量捕获&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;2.1 插入一个绑定&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-52535d0d127c59e76c691246b377b071_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;421&quot; data-rawheight=&quot;334&quot;&gt;&lt;code lang=&quot;emacs&quot;&gt;; -*- lexical-binding: t -*-

(defmacro insert-binding (x)
    `(let ((a 1))
        (+ ,x a)))&lt;/code&gt;&lt;p&gt;以上代码定义了一个宏&lt;code class=&quot;inline&quot;&gt;insert-binding&lt;/code&gt;，它将展开成一个&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;表达式，&lt;br&gt;将&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;插入到一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;值为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;的词法环境中。&lt;/p&gt;&lt;p&gt;其中，`&lt;code class=&quot;inline&quot;&gt;(let ((a 1)) (+ ,x a)))&lt;/code&gt;是反引用表达式，&lt;br&gt;下一篇文章中我们再详细讨论。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;(insert-binding 3)&lt;/code&gt;将展开成，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 1))
    (+ 3 a))    ; 4&lt;/code&gt;&lt;p&gt;然而，如果&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;中包含&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，就会引发歧义，例如，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (insert-binding (+ a 3)))&lt;/code&gt;&lt;p&gt;上式会展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (let ((a 1))
        (+ (+ a 3) a)))    ; 5&lt;/code&gt;&lt;p&gt;我们看表达式&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a))&lt;/code&gt;，&lt;br&gt;其中，左边第一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开之前的词法绑定，即，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (insert-binding (+ a 3)))&lt;/code&gt;&lt;p&gt;而第二个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开式中的词法绑定，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;`(let ((a 1))
        (+ ,x a))&lt;/code&gt;&lt;p&gt;在进行宏定义时，我们并不知道&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;中有没有&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，&lt;br&gt;结果导致了，宏展开式中的词法绑定意外捕获了&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;中的&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在本例中，&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;就是&lt;code class=&quot;inline&quot;&gt;(+ a 3)&lt;/code&gt;，其中&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值本来应该是&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;，&lt;br&gt;结果展开后，被宏展开式所捕获，值变成了&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，&lt;br&gt;我们通过插入一个词法绑定，完成了本例。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 插入一个自由变量&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a5d6fa2b397681d42d4ca20162e8ff13_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;403&quot; data-rawheight=&quot;328&quot;&gt;&lt;code lang=&quot;emacs&quot;&gt;; -*- lexical-binding: t -*-

(let ((a 1))
    (defmacro insert-free (x)
        `(+ ,x a)))&lt;/code&gt;&lt;p&gt;以上代码定义了一个宏&lt;code class=&quot;inline&quot;&gt;insert-free&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;(insert-free 3)&lt;/code&gt;将展开为&lt;code class=&quot;inline&quot;&gt;(+ 3 a)&lt;/code&gt;，其中&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;是自由变量，&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值取决于&lt;code class=&quot;inline&quot;&gt;(insert-free 3)&lt;/code&gt;在何处被展开。&lt;/p&gt;&lt;p&gt;例如，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (insert-free (+ a 3)))&lt;/code&gt;&lt;p&gt;将展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (+ (+ a 3) a))    ; 7&lt;/code&gt;&lt;p&gt;我们再来看表达式&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a))&lt;/code&gt;，&lt;br&gt;其中，左边第一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开之前的词法绑定，即，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (insert-free (+ a 3)))&lt;/code&gt;&lt;p&gt;而第二个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开式中的词法绑定，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 1))
    (defmacro insert-free (x)
        `(+ ,x a)))&lt;/code&gt;&lt;p&gt;在进行宏定义时，虽然我们显式的将&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;绑定为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，&lt;br&gt;但是&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;中包含的绑定，意外影响到了它，使得&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值变成了&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;。&lt;br&gt;我们通过插入一个含自由变量的表达式，让它受展开式所处的位置影响。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3 hygienic macro&lt;/b&gt;&lt;/p&gt;&lt;p&gt;以上两个例子中，插入一个绑定会污染宏展开后的环境，而插入一个自由变量会被宏展开后环境所影响，&lt;br&gt;它们都有变量捕获问题，都不是卫生的（hygienic）。&lt;/p&gt;&lt;p&gt;hygienic macro通常翻译成“卫生宏”，是一种避免变量捕获的技术，&lt;br&gt;如果所使用的宏是卫生的，那么以上两个例子中，最后的求值结果应该都是&lt;code class=&quot;inline&quot;&gt;6&lt;/code&gt;，而不是&lt;code class=&quot;inline&quot;&gt;5&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;7&lt;/code&gt;。&lt;br&gt;卫生宏是一种语言特性，&lt;a href=&quot;http://community.schemewiki.org/?RnRS&quot;&gt;Scheme&lt;/a&gt;中的宏是卫生的，而Emacs Lisp不是。&lt;/p&gt;&lt;p&gt;&lt;b&gt;如果一个宏是卫生的，&lt;/b&gt; &lt;b&gt;那么宏展开式中的所有标识符，仍处于其来源处的词法作用域中。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;（1）例如，根据&lt;code class=&quot;inline&quot;&gt;insert-binding&lt;/code&gt;的定义，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;; -*- lexical-binding: t -*-

(let ((a 1))
    (defmacro insert-free (x)
        `(+ ,x a)))
(let ((a 2))
    (insert-binding (+ a 3)))&lt;/code&gt;&lt;p&gt;将展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (let ((a 1))
        (+ (+ a 3) a)))&lt;/code&gt;&lt;p&gt;其中，&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a)&lt;/code&gt;中，&lt;br&gt;第一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开之前的词法环境，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值为&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;，&lt;br&gt;第二个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏定义式，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，&lt;br&gt;因此，&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a)&lt;/code&gt;求值为&lt;code class=&quot;inline&quot;&gt;6&lt;/code&gt;。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0f0d0d03df4a9d2654648399f00f87d1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;358&quot;&gt;&lt;p&gt;（2）又例，根据&lt;code class=&quot;inline&quot;&gt;insert-free&lt;/code&gt;的定义，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;; -*- lexical-binding: t -*-

(let ((a 1))
    (defmacro insert-free (x)
        `(+ ,x a)))
(let ((a 2))
    (insert-free (+ a 3)))&lt;/code&gt;&lt;p&gt;将展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (+ (+ a 3) a))&lt;/code&gt;&lt;p&gt;同理，&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a)&lt;/code&gt;中，&lt;br&gt;第一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开之前的词法环境，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值为&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;，&lt;br&gt;第二个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏定义式，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，&lt;br&gt;因此，&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a)&lt;/code&gt;的值也为&lt;code class=&quot;inline&quot;&gt;6&lt;/code&gt;。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d506193ef43253a3bd3b2ed80fc56297_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;352&quot;&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了交互函数，介绍了如何查看一个函数或者宏的文档和定义，&lt;br&gt;一些常用的宏，都可以通过查看&lt;code class=&quot;inline&quot;&gt;subr.el&lt;/code&gt;来找到它们。&lt;br&gt;然后，我们介绍了两种与宏相关的变量捕获问题，引出了卫生宏的概念。&lt;/p&gt;&lt;p&gt;下文，我们继续讨论宏，来看一看展开为宏定义的宏之强大威力。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/elisp.html&quot;&gt;GNU Emacs Lisp Reference Manual&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1432683/&quot;&gt;On Lisp&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/3864436/&quot;&gt;Let Over Lambda&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;http://www.scheme.com/tspl4/&quot;&gt;The Scheme Programming Language&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-07-34106490</guid>
<pubDate>Wed, 07 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>区块链与函数式编程</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-06-34287276.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34287276&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;区块链是对软件正确性要求极高的领域。过去软件bug和安全漏洞带来的损失，一般就是停机维护，被拖个库就已经是很重大的影响了。而区块链软件的漏洞被利用，那将是灾难性的，因为上面跑的都是真金白银。随着区块链技术对传统经济领域渗透的加深，这种风险将会大大提升。&lt;/p&gt;&lt;p&gt;传统软件工程只重视产品的快速上线快速迭代，从来没有把软件的正确性摆在一个优先级很高的位置，究其根本还是传统领域软件出bug带来的成本不高。&lt;/p&gt;&lt;p&gt;行业里其实已经有一些关键领域是对软件的正确性要求极高的，比如航天系统，金融领域一些核心系统等。1962年软件bug造成火箭偏航，损失1850万美元；1978年CAD软件bug造成体育竞技场倒塌，损失上亿美元；1985年放射机软件bug导致病人受到大量辐射，1987年金融交易软件bug导致美国股灾，等等。&lt;/p&gt;&lt;p&gt;这些问题促使人们去思考如何保证软件正确性，而这些年来业界针对这种对软件正确性要求高的领域，也确实发展了一套技术手段来支持，形式验证、类型系统、纯函数式编程等。这些方法对程序员要求更高，开发时间也更长，所以在大部分编程领域，这种方法显得不是那么经济，换句话说大部分程序员其实并不了解这个领域的技术。而现在传统程序员开始进入区块链软件的开发，如果不能在思维、流程、工具各方面作出相应调整的话，是很危险的事情。&lt;/p&gt;&lt;p&gt;但是真正的形式验证成本巨大，只好用来解决一些最核心的问题。而另一种同时兼顾实用性的方案是函数式编程（函数式编程这个词语这些年有些定义模糊，这里特指静态类型纯函数式语言，基本上就是ML一族的语言），而Haskell是其中的佼佼者，也是Cardano项目使用的开发语言。&lt;/p&gt;&lt;p&gt;Haskell是一门 &lt;i&gt;纯函数式&lt;/i&gt; &lt;i&gt;静态类型&lt;/i&gt; 惰性求值的语言，这里关键字有几个：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;纯函数式是说，函数除了将输入转换为输出以外，不能有其他副作用（比如执行IO操作、修改全局变量、或者发射个导弹啥的），并且对于相同的输入永远返回相同的输出。这意味着不存在变量的概念，数据结构也都是immutable的。显然这样的函数会有很多良好的性质：好测试, 线程安全, 代码可重用, 可读性强等等。另外这样的代码还有一个性质是可证明，因为你可以机械地把函数的调用替代成函数的实现，而不改变其语意，所以你可以形式地证明比如说两个函数等价。还有一些其他的好处，比如一些代码重构工具能够自动调整代码，编译器也可以更激进地对代码进行优化，因为他们能够确保对程序的语意没有影响。&lt;br&gt;如果在*纯*的基础上，再加上total的约束，那就更好了，total是说函数对参数的所有取值都有定义，相对应的partial的函数可能对某些输入没有定义。 不过有点遗憾的是，函数是否total无法静态地检测出来，因为从程序语意的角度，未定义和死循环是一样的，所以检测total性和停机问题是一样的。 （但是如果我们愿意牺牲图灵完备性的话，是可以支持total检查的，这样的语言里可以没有死循环和partial函数， 智能合约语言就非常需要这样的设计，而智能合约语言 &lt;a href=&quot;https://blockstream.com/2017/10/30/simplicity.html&quot;&gt;Simplicity&lt;/a&gt; 正是这么设计的）&lt;/li&gt;&lt;li&gt;静态类型系统，按照“柯里-霍华德同构”定理，类型对应于命题，而程序对应于证明。当我们把问题的模型编码成类型后，编译器通过类型检查可以保证程序的正确性。在实践中，类型是可以逐步细化的，越细化，能够通过编译的实现就越少，甚至可能细化到只剩下一个有意义的实现，这种情况下甚至可以通过工具实现自动生成实现代码。类型系统还带来其他一些便利的工具，比如hoogle，可以根据类型签名搜索现有库提供的函数实现。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;关于Haskell语言其实可以说的还有很多，未来会继续写一些具体的编程模式，尤其是与区块链相关的，以及它在Cardano项目中的具体实践，敬请期待。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;更正：Plutus还是图灵完备的语言，已经改成Simplicity。&lt;/p&gt;</description>
<author>黄毅</author>
<guid isPermaLink="false">2018-03-06-34287276</guid>
<pubDate>Tue, 06 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>柯里化的前生今世（八）：尾调用与CPS</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-02-34064655.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34064655&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;关于&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文是系列文章中的第八篇，发布在&lt;a href=&quot;https://zhuanlan.zhihu.com/c_166576777&quot;&gt;业余程序员的个人修养&lt;/a&gt;这个专栏中：&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34060802&quot;&gt;柯里化的前生今世（一）：函数面面观&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34063576&quot;&gt;柯里化的前生今世（二）：括号神教&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34063805&quot;&gt;柯里化的前生今世（三）：语言和同像性&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34064164&quot;&gt;柯里化的前生今世（四）：编译器与解释器&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34064286&quot;&gt;柯里化的前生今世（五）：动态作用域&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34064446&quot;&gt;柯里化的前生今世（六）：词法作用域和闭包&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34064549&quot;&gt;柯里化的前生今世（七）：first-class continuation&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在上一篇中，我们介绍了continuation的概念，还介绍了Lisp中威力强大的&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;，它提供了first-class continuation，最后我们用&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;实现了python中的generator和yield。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;赋予了我们很强的表达能力，Lisp中的异常处理机制也很人性化。&lt;br&gt;例如，&lt;a href=&quot;https://en.wikipedia.org/wiki/Common_Lisp#Condition_system&quot;&gt;Common Lisp: Condition_system&lt;/a&gt;，&lt;br&gt;由于&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;可以捕捉到异常处的continuation，&lt;br&gt;我们就可以手动调用这个continuation，&lt;br&gt;让程序从错误的位置以给定状态重新开始执行，&lt;br&gt;甚至结合&lt;a href=&quot;https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop&quot;&gt;REPL&lt;/a&gt;还可以询问用户，让用户输入这个状态。&lt;/p&gt;&lt;p&gt;其他语言的&lt;code class=&quot;inline&quot;&gt;try/catch&lt;/code&gt;是无法做到这一点的，&lt;br&gt;我们拿到错误时，出现错误的那个环境已经被丢弃了，无法恢复，&lt;br&gt;那么除了提示用户程序崩溃了就没有别的办法了。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;这么强大，更坚定了我们实现它的想法，&lt;br&gt;本文就从实现的角度来看&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;尾调用&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;In computer science, a tail call is a subroutine call performed as the final action of a procedure. &lt;/blockquote&gt;&lt;p&gt;如果在某个函数的末尾调用了另一个函数，这个调用就称为尾调用。&lt;br&gt;我们举个例子吧，&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (f a)
  (display a)
  (g 2))

(define (g b)
  (display b))

(f 1)&lt;/code&gt;&lt;p&gt;我们看到，函数&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的末尾调用了函数&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;(g 2)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;尾调用有什么好处呢？&lt;br&gt;一个基本的事实是，如果&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的尾调用，&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;就可以不返回到&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;中，&lt;br&gt;而直接返回到&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;该返回的地方。&lt;/p&gt;&lt;p&gt;因为&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的尾调用，&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;后面没有其他调用了，&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;(g 2)&lt;/code&gt;调用结束后就可以不必返回到&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的函数体中了，而是直接返回到&lt;code class=&quot;inline&quot;&gt;(f 1)&lt;/code&gt;处。&lt;br&gt;因此，调用&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的时候，调用栈可以不增加，而是直接废弃&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的调用环境即可。&lt;/p&gt;&lt;p&gt;注意，我们上面提到的是『不必返回到&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的函数体中』，&lt;br&gt;因为不是每个语言都可以做到这一点，&lt;br&gt;这个语言特性，称为尾调用优化（tail call optimization）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;调用栈和调用图&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;调用栈对我们来说是一个耳熟能详的名词，&lt;br&gt;可是我们有没有考虑过，为什么调用构成了一个『栈』呢？&lt;br&gt;有这么多的数据结构，为什么不是一个队列，不是一个树，不是一个图呢？&lt;/p&gt;&lt;p&gt;是因为函数的调用和返回机制，恰好可以用帧（frame）的压栈和弹栈来描述。&lt;br&gt;可是，尾调用优化，开始动摇了这一点，&lt;br&gt;为了能返回到调用者该返回的地方，调用栈有的时候可能会弹出两次，或者弹出更多次。&lt;/p&gt;&lt;p&gt;进一步，我们再来看call/cc的场景，它使得程序可以直接跳转到之前的某个状态，&lt;br&gt;根本上改变了压栈弹栈的规则，跳过去以后，以全新的状态重新开始执行。&lt;br&gt;然而，发生跳转时的状态还不能丢弃，因为有可能再跳回来。&lt;br&gt;因此，call/cc让调用不再构成一个栈，而是构成了一个调用图。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fe4f369ec3c287b75e28c710accccc64_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;466&quot; data-rawheight=&quot;336&quot;&gt;&lt;h2&gt;&lt;b&gt;CPS&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在这些复杂场景中，为了能显式的表示执行过程，&lt;br&gt;将程序转化为CPS（continuation passing style）是一种常用的办法，&lt;br&gt;CPS是一种程序的书写风格，经常作为编译器的一种中间表示。（&lt;a href=&quot;https://en.wikipedia.org/wiki/Intermediate_representation&quot;&gt;IR&lt;/a&gt;&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;; 调用风格
(define (f x)
  (+ (g x) 1))

(define (g x)
  (* x 2))

(f 1)

; CPS
(define (f x cont)
  (g x (lambda (v)
         (cont (+ v 1)))))

(define (g x cont)
  (cont (* x 2)))

(f 1 display)&lt;/code&gt;&lt;p&gt;我们发现写成CPS之后，每个函数多了一个&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;参数，&lt;br&gt;用来表示该函数调用表达式的continuation，&lt;br&gt;我们调用一个函数，就应该把它相应的continuation显式的传给它。&lt;br&gt;例如，我们在&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;中调用了&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;，那么我们就将&lt;code class=&quot;inline&quot;&gt;(g x)&lt;/code&gt;的continuation传给了&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;，即&lt;code class=&quot;inline&quot;&gt;(lambda (v) (cont (+ v 1)))&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;除此之外，我们还发现，CPS是一个尾调用形式，&lt;br&gt;因此程序的执行就变成了continuation的不断变换生长。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;开始动手术&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;为了实现call/cc，首先我们要把解释器改造成CPS形式，&lt;br&gt;然后再将continuation拿出来包装一下，提供给用户使用。&lt;/p&gt;&lt;p&gt;我们先进行第一步改造，CPS，&lt;br&gt;回忆一下，为了实现词法作用域，我们给解释器中每个函数末尾加上了参数&lt;code class=&quot;inline&quot;&gt;env&lt;/code&gt;，用于表示被求值表达式的环境。这次也相似，我们给每个函数加上了新的参数&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;，用于表示被求值表达式的continuation，这样我们就可以将解释器改造成CPS形式了。&lt;/p&gt;&lt;p&gt;下一步改造我们要实现call/cc了，它直接使用了这些包含&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;参数的函数，限于篇幅，CPS形式的解释器我们就略过了，这里我们只是先看一下&lt;code class=&quot;inline&quot;&gt;handle-decision-tree&lt;/code&gt;的样子吧，&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (handle-decision-tree tree exp env cont)
  (if (null? tree)
      (error &#39;handle-decision-tree &quot;failed to make decision&quot;)
      (let* ((head (car tree))
             (predicator (car head))
             (decision (cadr head)))

        (predicator exp env 
                    (lambda (predicate-result)
                      (if predicate-result
                          (if (not (list? decision))
                              (decision exp env cont)
                              (handle-decision-tree decision exp env cont))
                          (handle-decision-tree (cdr tree) exp env cont)))))))&lt;/code&gt;&lt;h2&gt;&lt;b&gt;实现call/cc&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;将解释器转换成CPS之后，我们就可以将&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;进行包装了，&lt;br&gt;下面的实现中，我们将&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;包装成了一个内部的数据结构&lt;code class=&quot;inline&quot;&gt;continuation&lt;/code&gt;。&lt;br&gt;（和闭包一样，continuation从实现的角度来看也是一个数据结构&lt;/p&gt;&lt;p&gt;然后，把这个数据结构提供给用户，就可以让用户代码实现自定义跳转了。&lt;br&gt;为了实现这一点，我们在解释器中判断是否调用了continuation，来做相应的处理。&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;handle-decision-tree&lt;/code&gt;增加了两个分支，&lt;code class=&quot;inline&quot;&gt;is-continuation?&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;is-continuation-call?&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang racket

; tool

(struct closure 
  (param body env))

(struct continuation 
  (cont))

(define (create-frame)
  (make-hash))

(define (extend-frame frame key value)
  (hash-set! frame key value))

(define (extend-env env frame)
  (cons frame env))

(define (get-symbol-value env key)
  (let lookup-env
    ((env env))
    (if (null? env)
        (error &#39;get-symbol-value &quot;failed to find symbol&quot;)
        (let ((head-frame (car env)))
          (if (hash-has-key? head-frame key)
              (hash-ref head-frame key &#39;())
              (lookup-env (cdr env)))))))

(define (handle-decision-tree tree exp env cont)
  (if (null? tree)
      (error &#39;handle-decision-tree &quot;failed to make decision&quot;)
      (let* ((head (car tree))
             (predicator (car head))
             (decision (cadr head)))

        (predicator exp env 
                    (lambda (predicate-result)
                      (if predicate-result
                          (if (not (list? decision))
                              (decision exp env cont)
                              (handle-decision-tree decision exp env cont))
                          (handle-decision-tree (cdr tree) exp env cont)))))))

; env &amp;amp; cont

(define *env* `(,(create-frame)))

(define *cont* (lambda (v)
                 (display v)))

; main

(define (eval-exp exp env cont)
  (handle-decision-tree 
   `((,is-symbol? ,eval-symbol)
     (,is-self-eval-exp? ,eval-self-eval-exp)
     (,is-continuation? ,eval-continuation)
     (,is-list?
      ((,is-lambda? ,eval-lambda)
       (,is-call/cc? ,eval-call/cc)
       (,is-continuation-call? ,eval-continuation-call)
       (,is-function-call-list? ,eval-function-call-list))))
   exp env cont))

(define (is-symbol? exp env cont)
  (display &quot;is-symbol?\n&quot;)
  (cont (symbol? exp)))

(define (eval-symbol exp env cont)
  (display &quot;eval-symbol\n&quot;)
  (cont (get-symbol-value env exp)))

(define (is-self-eval-exp? exp env cont)
  (display &quot;is-self-eval-exp?\n&quot;)
  (cont (number? exp)))

(define (eval-self-eval-exp exp env cont)
  (display &quot;eval-self-eval-exp\n&quot;)
  (cont exp))

(define (is-continuation? exp env cont)
  (display &quot;is-continuation?\n&quot;)
  (cont (continuation? exp)))

(define (eval-continuation exp env cont)
  (display &quot;eval-continuation\n&quot;)
  (cont exp))

(define (is-list? exp env cont)
  (display &quot;is-list?\n&quot;)
  (cont (list? exp)))

(define (is-lambda? exp env cont)
  (display &quot;is-lambda?\n&quot;)
  (cont (eq? (car exp) &#39;lambda)))

(define (eval-lambda exp env cont)
  (display &quot;eval-lambda\n&quot;)
  (let ((param (caadr exp))
        (body (caddr exp)))
    (cont (closure param body env))))

(define (is-call/cc? exp env cont)
  (display &quot;is-call/cc?\n&quot;)
  (cont (eq? (car exp) &#39;call/cc)))

(define (eval-call/cc exp env cont)
  (display &quot;eval-call/cc\n&quot;)
  (let ((fn (cadr exp))
        (data-cont (continuation cont)))
    (eval-function-call-list `(,fn ,data-cont) env cont)))

(define (is-continuation-call? exp env cont)
  (display &quot;is-continuation-call?\n&quot;)
  (eval-exp (car exp) env
            (lambda (value)
              (cont (continuation? value)))))

(define (eval-continuation-call exp env cont)
  (display &quot;eval-continuation-call\n&quot;)
  (eval-exp (car exp) env
            (lambda (data-cont)
              (let ((wrapped-cont (continuation-cont data-cont)))
                (eval-exp (cadr exp) env
                          (lambda (arg)
                            (wrapped-cont arg)))))))

(define (is-function-call-list? exp env cont)
  (display &quot;is-function-call-list?\n&quot;)
  (cont #t))

(define (eval-function-call-list exp env cont)
  (display &quot;eval-function-call-list\n&quot;)
  (eval-exp (car exp) env
            (lambda (clos)
              (eval-exp (cadr exp) env
                        (lambda (arg)
                          (let ((body (closure-body clos))
                                (lexical-env (closure-env clos))
                                (param (closure-param clos))

                                (frame (create-frame)))

                            (extend-frame frame param arg)

                            (let ((executing-env (extend-env lexical-env frame)))
                              (eval-exp body executing-env cont))))))))&lt;/code&gt;&lt;p&gt;&lt;b&gt;注：&lt;/b&gt;其中&lt;code class=&quot;inline&quot;&gt;eval-call/cc&lt;/code&gt;，调用了&lt;code class=&quot;inline&quot;&gt;eval-function-call-list&lt;/code&gt; ，&lt;br&gt;这将导致这个表达式&lt;code class=&quot;inline&quot;&gt;(call/cc (lambda (k) (call/cc k)))&lt;/code&gt; 无法解释执行。&lt;br&gt;（感谢 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6c0662069049e4fb6960a77beebf4a9b&quot; data-hash=&quot;6c0662069049e4fb6960a77beebf4a9b&quot; data-hovercard=&quot;p$b$6c0662069049e4fb6960a77beebf4a9b&quot;&gt;@御坂黒子&lt;/a&gt; 指出错误。。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (eval-call/cc exp env cont)
  (display &quot;eval-call/cc\n&quot;)
  (let ((fn (cadr exp))
        (data-cont (continuation cont)))
    (eval-function-call-list `(,fn ,data-cont) env cont)))&lt;/code&gt;&lt;h2&gt;&lt;b&gt;测试&lt;/b&gt;&lt;/h2&gt;&lt;code lang=&quot;racket&quot;&gt;(eval-exp &#39;1 *env* *cont*)

(display &quot;\n\n&quot;)
(eval-exp &#39;(lambda (x) x) 
          *env* *cont*)

(display &quot;\n\n&quot;)
(eval-exp &#39;((lambda (x) x) 
            1) 
          *env* *cont*)

(display &quot;\n\n&quot;)
(eval-exp &#39;((lambda (x)
              ((lambda (y) x)
               2))
            1) 
          *env* *cont*)

(display &quot;\n\n&quot;)
(eval-exp &#39;((lambda (x)
              ((lambda (f)
                 ((lambda (x)
                    (f 3))
                  2))
               (lambda (z) x)))
            1)
          *env* *cont*)

(display &quot;\n\n&quot;)
(eval-exp &#39;(call/cc (lambda (k)
                      1))
          *env* *cont*)

(display &quot;\n\n&quot;)
(eval-exp &#39;(call/cc (lambda (k)
                      (k 2)))
          *env* *cont*)&lt;/code&gt;&lt;h2&gt;&lt;b&gt;要点分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;（1）&lt;code class=&quot;inline&quot;&gt;eval-call/cc&lt;/code&gt;时会创建一个&lt;code class=&quot;inline&quot;&gt;continuation&lt;/code&gt;，&lt;br&gt;然后用这个&lt;code class=&quot;inline&quot;&gt;continuation&lt;/code&gt;作为参数调用&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;的参数。&lt;br&gt;（&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;的参数，就是后面的&lt;code class=&quot;inline&quot;&gt;(lambda (k) 1)&lt;/code&gt;，因此&lt;code class=&quot;inline&quot;&gt;k&lt;/code&gt;就是这个&lt;code class=&quot;inline&quot;&gt;continuation&lt;/code&gt;&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;; (call/cc (lambda (k) 1))

(define (eval-call/cc exp env cont)
  (display &quot;eval-call/cc\n&quot;)
  (let ((fn (cadr exp))
        (data-cont (continuation cont)))
    (eval-function-call-list `(,fn ,data-cont) env cont)))&lt;/code&gt;&lt;p&gt;（2）&lt;code class=&quot;inline&quot;&gt;eval-continuation-call&lt;/code&gt;会解开&lt;code class=&quot;inline&quot;&gt;continuation&lt;/code&gt;的包装，得到内部包含的&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;，&lt;br&gt;然后用这个&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;作为参数求值表达式，&lt;br&gt;这样就实现了，表达式求值完以后跳转到产生&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;位置的效果。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (eval-continuation-call exp env cont)
  (display &quot;eval-continuation-call\n&quot;)
  (eval-exp (car exp) env
            (lambda (data-cont)
              (let ((wrapped-cont (continuation-cont data-cont)))
                (eval-exp (cadr exp) env
                          (lambda (arg)
                            (wrapped-cont arg)))))))&lt;/code&gt;&lt;p&gt;（3）&lt;code class=&quot;inline&quot;&gt;(call/cc ...)&lt;/code&gt;表达式中，如果&lt;code class=&quot;inline&quot;&gt;k&lt;/code&gt;没有被调用，那么&lt;code class=&quot;inline&quot;&gt;(call/cc ...)&lt;/code&gt;的值，就是&lt;code class=&quot;inline&quot;&gt;call/cc&lt;/code&gt;参数函数的返回值，即&lt;code class=&quot;inline&quot;&gt;(call/cc (lambda (k) 1)) = 1&lt;/code&gt;。&lt;br&gt;这一点看起来很难实现，实则不然。&lt;/p&gt;&lt;p&gt;我们只需要巧妙的指定&lt;code class=&quot;inline&quot;&gt;(lambda (k) 1)&lt;/code&gt;的continuation，&lt;br&gt;让它就是&lt;code class=&quot;inline&quot;&gt;(call/cc (lambda (k) 1))&lt;/code&gt;的continuation即可。&lt;br&gt;这一点体现在&lt;code class=&quot;inline&quot;&gt;eval-call/cc&lt;/code&gt;中，我们直接将&lt;code class=&quot;inline&quot;&gt;cont&lt;/code&gt;原封不动的传给了&lt;code class=&quot;inline&quot;&gt;eval-function-call-list&lt;/code&gt;&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (eval-call/cc exp env cont)
   ...
    (eval-function-call-list `(,fn ,data-cont) env cont)))&lt;/code&gt;&lt;h2&gt;&lt;b&gt;下文&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Lisp语言真是博大精深，写到这里我们甚至还没有提及它最重要的语言特性——宏，&lt;br&gt;Lisp宏提供了一种元编程的手段，&lt;a href=&quot;http://www.jianshu.com/p/1031cd06b172&quot;&gt;同像性&lt;/a&gt;让Lisp元编程异常强大，&lt;br&gt;然而，把宏说清楚也颇费笔墨，因此，我打算在适当的时候单独讨论它。&lt;/p&gt;&lt;p&gt;本系列标题为『柯里化的前生今世』，意在通过柯里化引入种种有趣的概念，&lt;br&gt;目前为止，我们讨论了高阶函数，闭包，continuation，这些可以看做『柯里化的前生』，&lt;br&gt;我们不但理解了这些概念，还实现了它们，算是小有收获吧。&lt;/p&gt;&lt;p&gt;使用Racket也有一段日子了，对它也逐渐从陌生到熟悉，&lt;br&gt;可是偏执却容易让人误入歧途，错过其他风景，&lt;br&gt;下文我们将开启新的旅程了，Let&#39;s go !&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.scheme.com/tspl4/further.html#./further:h4&quot;&gt;continuation passing style&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1762126/&quot;&gt;Compiling with Continuations&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;ftp://ftp.cs.utexas.edu/pub/garbage/cs345/schintro-v14/schintro_toc.html&quot;&gt;An Introduction to Scheme and its Implementation&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-02-34064655</guid>
<pubDate>Fri, 02 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>从字符串到能用的数据结构到底有多远？——Haskell的Parsec实战</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-02-28-34103708.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34103708&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先，为什么要用Parsec解析文本而不是正则表达式？在其它语言中，将内容分割成数组，用正则表达式来解析内容是普遍存在的。在Haskell中也可以沿着这一条路线走下去。但Parsec是一个更好的方式。看了Parsec之后我就用Parsec解析JSON文本（作为学习），从字符串到JSON类型没有想像中的那么远，以后再也不用害怕字符串了。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Parsec简介&lt;/h2&gt;&lt;p&gt;依赖包： - parsec&lt;/p&gt;&lt;p&gt;必要的引入： import qualified Text.Parsec as P&lt;/p&gt;&lt;p&gt;定义：type P.Parsec s u = P.ParsecT s u Identity :: * -&amp;gt; *&lt;/p&gt;&lt;p&gt;Parsec是ParsecT的一个简写,ParsecT主要是以下类型类的实例&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;instance [safe] A.Alternative (P.ParsecT s u m)
  -- Defined in ‘Text.Parsec.Prim’
instance [safe] Applicative (P.ParsecT s u m)
  -- Defined in ‘Text.Parsec.Prim’
instance [safe] Functor (P.ParsecT s u m)
  -- Defined in ‘Text.Parsec.Prim’
instance [safe] Monad (P.ParsecT s u m)
  -- Defined in ‘Text.Parsec.Prim’
instance [safe] (Monoid a,
                 Data.Semigroup.Semigroup (P.ParsecT s u m a)) =&amp;gt;
                Monoid (P.ParsecT s u m a)
&lt;/code&gt;&lt;p&gt;以下只列出关键点&lt;br&gt;Alternative : 可以使用&amp;lt;|&amp;gt;来表达『逻辑或』的关系。&lt;br&gt;Applicative: 可以使用pure，&amp;lt;*&amp;gt; ，&amp;lt;*，&lt;b&gt;*&lt;/b&gt;&amp;gt; 函数，可以更改容器内的值。&lt;/p&gt;&lt;p&gt;Functor: 一般我用&amp;lt;$&amp;gt;替代fmap函数，另外还有一个有用的函数&amp;lt;$ 用于更改容器内的值&lt;br&gt;Monad: do 语句块&lt;br&gt;当然上面列的不全，ParsecT也是一个MonadTrans ，可以嵌入Monad(如最常用的IO)用lift升格。&lt;br&gt;&lt;/p&gt;&lt;p&gt;Parsec  s u a : s是源（也就是要解析的文本）类型，u是用户状态类型，a是结果&lt;/p&gt;&lt;p&gt;&lt;b&gt;Parsec一些关键的函数（常用的函数）&lt;br&gt;&lt;/b&gt;&lt;br&gt;P.parse 解析入口函数&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;P.parse                                                                      
  :: P.Stream s Identity t =&amp;gt;                                                 
     P.Parsec s () a -&amp;gt; P.SourceName -&amp;gt; s -&amp;gt; Either P.ParseError a 
&lt;/code&gt;&lt;p&gt;parse Parsec 源文件名字（解析失败时用来定位文件）  待解析文本  -&amp;gt; Either &lt;br&gt;&lt;br&gt;P.char、P.oneOf、P.digit、P.string、P.noneOf 、P.anyChar等都会返回Parsec用来解析 一个字符、多个字符之一、数字、字符串、非多个字符之一、任意字符等。&lt;/p&gt;&lt;p&gt;P.many  Parsec 解析零个或多个Parsec直到解析失败&lt;br&gt;P.many1  Parsec 至少解析一个或者多个&lt;br&gt;P.skipMany、P.skipMany1 与上面many、many1一样只不过忽略返回结果&lt;br&gt;P.sepBy  a b 用parsec b来分割parsec a（如解析1,12,34,4以固定字符隔开的token）&lt;br&gt;P.lookAhead Parsec 主要作用是不产生消耗还会给你结果&lt;br&gt;P.try 由于 a&amp;lt;|&amp;gt;b只对第一个字符做判断如果第一个字符成功了就返回a而不管整体失败与否,try是为了整体失败走b&lt;/p&gt;&lt;p&gt;P.eof 表示文件结尾的Parsec&lt;/p&gt;&lt;p&gt;了解了上面这些函数，类型类就可以完成解析JSON字符串的任务了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;JSON解析&lt;/h2&gt;&lt;p&gt;解析之前，一般我会先定义适用于JSON的模型&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Number&#39; = Int Int | Float Float deriving Show
data JSON = Null
  | Number Number&#39;
  | String String
  | Bool Bool
  | Undefined
  | Object [(String ,JSON)]
  | List [JSON]
  deriving (Show)&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;写好『骨架』&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;parse :: String -&amp;gt; Either P.ParseError JSON
parse text = P.parse jsonParsec &quot;JSON:&quot; text

jsonParsec :: P.Parsec String () JSON
jsonParsec = P.spaces *&amp;gt; myParsec &amp;lt;* P.spaces &amp;lt;* P.eof &lt;/code&gt;&lt;p&gt;parse使用jsonParsec解析text, P.spaces表示空白字符，前后可有任意空白字符最终返回myParsec（*&lt;b&gt;&amp;gt;、&amp;lt;&lt;/b&gt;* 函数来自于Applicative）&lt;br&gt;&lt;/p&gt;&lt;h2&gt;解析Null,和undefined&lt;/h2&gt;&lt;code lang=&quot;haskell&quot;&gt;myParsec = nullParsec
  &amp;lt;|&amp;gt; undefinedParsec

undefinedParsec = Undefined &amp;lt;$ P.string &quot;undefined&quot;
nullParsec = P.string &quot;null&quot; &amp;gt;&amp;gt; return Null&lt;/code&gt;&lt;p&gt;myParsec:  &amp;lt;|&amp;gt;函数来自Alternative，如果NullParsec解析失败就用undefinedParsec解析&lt;br&gt;undefinedParsec : &amp;lt;$来自Functor ，如果解析成功容器内部的值改为Undefined&lt;/p&gt;&lt;p&gt;nullParsec : &amp;gt;&amp;gt; 来自Monad , 如果解析成功内部值改为Null。和undefinedParsec的功能相同。&lt;/p&gt;&lt;p&gt;现在可以运行parse函数，输入null,undefined得的结果和预期一致。&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;*Main Lib A&amp;gt; parse &quot;null&quot;
Right Null
*Main Lib A&amp;gt; parse &quot;undefined&quot;
Right Undefined
*Main Lib A&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解析String和Bool&lt;/b&gt;&lt;/p&gt;&lt;p&gt;js的字符串分为两种写法（es6以下），单引号，双引号，需要写两个Parsec。&lt;/p&gt;&lt;p&gt;写完Parsec之后在myParsec中加入进来&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;myParsec = nullParsec
  &amp;lt;|&amp;gt; stringParsec
  &amp;lt;|&amp;gt; stringParsec1
  &amp;lt;|&amp;gt; boolParsec
  &amp;lt;|&amp;gt; undefinedParsec

boolParsec = (Bool True &amp;lt;$ P.string &quot;true&quot;) &amp;lt;|&amp;gt; (Bool False &amp;lt;$ P.string &quot;false&quot;)
stringParsec = do
  P.oneOf &quot;\&quot;&quot;
  x &amp;lt;- P.many $ P.noneOf &quot;\&quot;&quot;
  P.oneOf &quot;\&quot;&quot;
  return $ String x

stringParsec1 = do
  P.oneOf &quot;\&#39;&quot;
  x &amp;lt;- P.many $ P.noneOf &quot;\&#39;&quot;
  P.oneOf &quot;\&#39;&quot;
  return $ String x
&lt;/code&gt;&lt;p&gt;boolParsec中所涵盖的内容前面已介绍过了，这里不在介绍&lt;br&gt;stringParsec解析双引号的字符串整体流程是：消费双引号-&amp;gt;消费非双引号并把结果给x-&amp;gt;消费双引号-&amp;gt;返回。里面的P.oneOf  &quot;\&quot;&quot; 也可以换为 P.char &#39;&quot;&#39;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;运行parse函数&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;*Main Lib A&amp;gt; parse &quot;&#39;hello&#39;&quot;
Right (String &quot;hello&quot;)
*Main Lib A&amp;gt; parse &quot;\&quot;diqye\&quot;&quot;
Right (String &quot;diqye&quot;)
*Main Lib A&amp;gt; parse &quot;abc&quot;
Left &quot;JSON:&quot; (line 1, column 1):
unexpected &quot;a&quot;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;解析Array和Object&lt;/b&gt;&lt;/p&gt;&lt;p&gt;原本以为这块会很困难，没想到很自然而然的写出来了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;listParsec = do
  P.char &#39;[&#39;
  P.spaces
  a &amp;lt;- P.sepBy myParsec (P.try symbol1)
  P.spaces
  P.char &#39;]&#39;
  return $ List a

symbol1 = do
  P.spaces
  P.char &#39;,&#39;
  P.spaces

keyParsec :: P.Parsec String () String
keyParsec = do
  c &amp;lt;- P.lookAhead P.anyChar
  let val | C.isDigit c = fail &quot;非法的key&quot;
          | otherwise = P.many1 $ P.noneOf &quot;: &quot;

objectInnerParsec = do
  (String key) &amp;lt;- stringParsec &amp;lt;|&amp;gt; stringParsec1 &amp;lt;|&amp;gt; (pure String &amp;lt;*&amp;gt; keyParsec) P.&amp;lt;?&amp;gt; &quot;符合规定的key&quot; 
  P.spaces
  P.char &#39;:&#39;
  P.spaces
  val &amp;lt;- myParsec
  return (key,val)

objectParsec = do
  P.char &#39;{&#39;
  P.spaces
  a &amp;lt;- P.sepBy objectInnerParsec (P.try symbol1)
  P.spaces
  P.char &#39;}&#39;
  return $ Object a
&lt;/code&gt;&lt;p&gt;symbol1 只解析了一个逗号，只不过前后都忽略了空白字符， try symbol1是为了整体失败之后不在做消耗（主要是空白字符），参见简介处的介绍。&lt;br&gt;&lt;br&gt;listParsec： 消费以『[』开头『]』结尾的字符，通过sepBy以逗号隔开，每一项使用myParsec来解析（递归解析）。 &lt;br&gt;&lt;br&gt;objectParsec:  以『{』开头『}』结尾，中间部分通过objectInnerParsec解析key和val，key可以是一个字符串也可以是普通的key。这里的keyParsec只是简单的解析为不能以数字开头。lookAhead不消费字符，这里使用它的主要目的是使报错的行号、列号更加精确。&lt;br&gt;&lt;b&gt;解析数字&lt;/b&gt;&lt;/p&gt;&lt;p&gt;数字比较麻烦，分为整数，浮点数，负整数，负浮点数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;negdigit = pure (:)  &amp;lt;*&amp;gt; p.char &#39;-&#39; &amp;lt;*&amp;gt; posdigit
posdigit = p.many1 p.digit

negfloat = pure (:)  &amp;lt;*&amp;gt; p.char &#39;-&#39; &amp;lt;*&amp;gt; posfloat
posfloat = do
  digits &amp;lt;- p.many1 p.digit
  dot &amp;lt;- p.char &#39;.&#39;
  rdigits &amp;lt;- p.many1 p.digit
  return $ digits ++ (dot:rdigits)

digitparsec = number . int . (read :: string -&amp;gt; int) &amp;lt;$&amp;gt; (posdigit &amp;lt;|&amp;gt; negdigit)
floatparsec = number . float . (read :: string -&amp;gt; float) &amp;lt;$&amp;gt; (posfloat &amp;lt;|&amp;gt; negfloat)&lt;/code&gt;&lt;p&gt;有了Parsec这些也不再困难咯。&lt;/p&gt;&lt;p&gt;&lt;b&gt;完整的myParsec&lt;br&gt;&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;myParsec = nullParsec
  &amp;lt;|&amp;gt; stringParsec
  &amp;lt;|&amp;gt; stringParsec1
  &amp;lt;|&amp;gt; listParsec
  &amp;lt;|&amp;gt; objectParsec 
  &amp;lt;|&amp;gt; boolParsec
  &amp;lt;|&amp;gt; undefinedParsec
  &amp;lt;|&amp;gt; floatParsec &amp;lt;|&amp;gt; digitParsec &lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;repl中的测验&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;*Main Lib A&amp;gt; parse &quot;[&#39;abc&#39;,{name:&#39;diqye&#39;,age:10},-10,1.01]&quot;
Right (List [String &quot;abc&quot;,Object [(&quot;name&quot;,String &quot;diqye&quot;),(&quot;age&quot;,Number (Int 10))],Number (Int (-10)),Number (Float 1.01)])
*Main Lib A&amp;gt; parse &quot;[&#39;abc&#39;,{name:&#39;diqye&#39;,age:10},-10,1.01] i&quot;
Left &quot;JSON:&quot; (line 1, column 40):
unexpected &#39;i&#39;
expecting space or end of input&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;以上代码以上传至  &lt;a href=&quot;https://github.com/ppzzppz/json-demo&quot;&gt;ppzzppz/json-demo&lt;/a&gt; &lt;/p&gt;&lt;p&gt;这个JSON作为学习来说没毛病，作为使用来说，还有很多不足，一些特殊情况没有做处理。代码上可能有一些更好改进，欢迎指正和建议。&lt;/p&gt;</description>
<author>第七页</author>
<guid isPermaLink="false">2018-02-28-34103708</guid>
<pubDate>Wed, 28 Feb 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>【综述长文】因果关系是什么？结构因果模型入门</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-02-28-33860572.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33860572&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f8c56dd3e243757fb00744c02ec3cf01_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;i&gt;因果关系是什么？&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;当我们在问「为什么」的时候，我们在问什么？&lt;/i&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;i&gt;Shallow men believe in luck or in circumstance. Strong men believe in cause and effect.&lt;/i&gt; &lt;i&gt;― Ralph Waldo Emerson&lt;/i&gt;&lt;/blockquote&gt;&lt;h2&gt;目录&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;第一章——前言&lt;/b&gt;：用通俗的语言介绍「什么是因果关系？」这一问题的讨论背景，并概括若干个传统的哲学观点，以及和下文的统计因果模型相比，这些传统定义存在的缺陷。&lt;/li&gt;&lt;li&gt;&lt;b&gt;第二章——事件性因果&lt;/b&gt;&lt;/li&gt;&lt;li&gt;2.1. 随机对照试验&lt;/li&gt;&lt;li&gt;2.2. 介入主义的因果观&lt;/li&gt;&lt;li&gt;2.3. 虚拟事实模型（RCM）&lt;/li&gt;&lt;li&gt;2.4. 贝叶斯网络&lt;/li&gt;&lt;li&gt;2.5. 结构方程（SEM）+ 结构因果模型（SCM）&lt;/li&gt;&lt;li&gt;2.6. SCM的反事实推理&lt;/li&gt;&lt;li&gt;&lt;b&gt;第三章——过程性因果&lt;/b&gt;：因果环路图（CLD）与微分方程&lt;/li&gt;&lt;li&gt;&lt;b&gt;第四章——后记&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;除前言外，本文其他部分默认读者已经理解基础概率论（概率、条件概率、贝叶斯定理、随机变量、期望值、相互独立事件）、基础图论（节点、边、有向无环图）、概率图模型初步（贝叶斯网络、d分隔）、统计学基础（随机对照试验）等知识。&lt;/p&gt;&lt;p&gt;另外，本文可以看作Judea Pearl的《Causality》的一篇导读。&lt;/p&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/30f4c8f8f80bd067003f527f67ec43e7&quot; data-hash=&quot;30f4c8f8f80bd067003f527f67ec43e7&quot; data-hovercard=&quot;p$b$30f4c8f8f80bd067003f527f67ec43e7&quot;&gt;@光喻&lt;/a&gt; 。&lt;b&gt;禁止全文转载，大篇幅引用请标注出处并私信告知。&lt;/b&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;一、前言&lt;/h2&gt;&lt;p&gt;因果关系在生活中无处不在。经济、法律、医学、物理、统计、哲学、宗教等众多学科，都与因果的分析密不可分。然而，和其他概念，例如统计的相关性相比，&lt;b&gt;因果（causality）非常难以定义&lt;/b&gt;。利用直觉，我们可以轻易判断日常生活中的因果关系；但是，用清晰、没有歧义的语言准确回答「因果关系是什么？」这个问题，往往超出了常人的能力范围。&lt;/p&gt;&lt;p&gt;（感兴趣的读者，不妨暂停阅读，然后试着给出一个「因果关系」的定义。）&lt;/p&gt;&lt;p&gt;不得不承认，回答这个问题是如此困难，以至于部分哲学家认为，因果关系是不可还原的、最基础的认知公理，无法被用其他方式描述。不过，&lt;b&gt;本文即将描述的众多统计因果模型，将会是针对这一观点的有力反驳。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在知乎上，也有一些对于因果关系的探讨，例如哲学话题下的「&lt;a href=&quot;https://www.zhihu.com/question/20318246&quot;&gt;因果关系是真实存在，还是我们认识世界的一种方法？&lt;/a&gt;」令人遗憾的是，这个问题下的大多数答案，都把重心放在了认知论上，即「如何回应休谟的归纳问题？」以及「我们怎么知道，我们认知的因果关系是可靠的？」大家似乎都默认，「什么是因果关系」是一个琐碎得不需要讨论的前提（但显然并非如此），&lt;b&gt;陷入怀疑论和先验论，从而无法给出一个实用的因果模型&lt;/b&gt;。事实上，&lt;b&gt;因果关系是一个本体论的话题&lt;/b&gt;：我们需要找到一个符合直觉、足够广泛，但也足够具体的&lt;b&gt;定义&lt;/b&gt;来描述因果关系；在此基础之上，我们还需要一套可靠的&lt;b&gt;判定因果的方法&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;常用的统计因果模型都采用了&lt;b&gt;介入主义（interventionism）&lt;/b&gt;的诠释：&lt;b&gt;因果关系的定义依赖于「介入」的概念&lt;/b&gt;；&lt;b&gt;外在的介入是因，产生现象的变化是果&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;在此之前，我们先了解一下其他传统的对于「因果关系」的定义，以及为什么它们不符合直觉。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7c8f73a1d0f267a00f2b4b1c40c45156_r.jpg&quot; data-caption=&quot;大卫·休谟（David Hume）&quot; data-size=&quot;small&quot; data-rawwidth=&quot;757&quot; data-rawheight=&quot;900&quot;&gt;&lt;p&gt;休谟：因果就是「&lt;b&gt;经常性联结&lt;/b&gt;」（constant conjunction）。如果我们观察到，A总是在B之前发生，事件A与事件B始终联结在一起，那么A就导致了B，或者说A是B的原因。&lt;/p&gt;&lt;p&gt;反驳：令A表示公鸡打鸣，令B表示日出。自然条件下，日出之前总有公鸡打鸣，但不会有人认为公鸡打鸣导致了日出。假如我们进行介入，监禁了所有的公鸡，使它们无法打鸣，太阳仍然会照常升起。&lt;/p&gt;&lt;p&gt;在这里，有必要注意一个细节：&lt;/p&gt;&lt;p&gt;大卫·休谟（David Hume，1711年－1776年）。&lt;/p&gt;&lt;p&gt;卡尔·皮尔逊（Karl Pearson，1857年－1936年）。&lt;/p&gt;&lt;p&gt;提出「统计相关性」概念的皮尔逊，比休谟晚出生了一百多年。&lt;/p&gt;&lt;p&gt;&lt;b&gt;我们现在的思维方式，并非是自古以来就存在的：我们眼里理所应当的常识，在古人脑中可能从未出现。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在统计学成为一门严谨的学科、皮尔逊清晰地分离相关性和因果性之前，大多数人都把相关性和因果性混为一谈。即便到了现在，认为相关就代表因果的人也不在少数。&lt;/p&gt;&lt;p&gt;我们没有必要因为休谟的历史地位，就把他下的定义奉为金科玉律。所以，休谟用的经常性联结只能定义相关性，不能定义因果性。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-527cbeca6d5ab2127118ace7d469b087_r.jpg&quot; data-caption=&quot;相关性未必意味着因果性&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;459&quot; data-rawheight=&quot;185&quot;&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;相关性不代表因果性。&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;相关性是对称的，而因果性是不对称的。&lt;/b&gt;如果A是B的原因，那么B是A的结果，但我们绝不会同时说「事件A是事件B的原因，事件A也是事件B的结果」。至于相关性，随机变量X与Y之间的相关性定义为 &lt;equation&gt;\mathrm {corr} (X,Y)={\mathrm {cov} (X,Y) \over \sigma _{X}\sigma _{Y}}={E[(X-\mu _{X})(Y-\mu _{Y})] \over \sigma _{X}\sigma _{Y}}&lt;/equation&gt; ，所以必然有 &lt;equation&gt;\mathrm {corr} (X,Y) = \mathrm {corr} (Y,X)&lt;/equation&gt; 。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;因果关系的不对称性，曾被用于反驳亨佩尔用DN模型定义「科学解释」的做法，但这是属于科学哲学的题外话了。&lt;/p&gt;&lt;p&gt;以上两条直觉，可以反驳以下一系列不使用「介入」概念的因果定义。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;充分因： &lt;equation&gt;A \rightarrow B&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;必然因： &lt;equation&gt;A \leftarrow B&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;朴素的反事实因果： &lt;equation&gt;(A→B)∧(¬A→¬B)&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;加入概率论，用相关性定义因果性。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;一个典型的反例：用事件A表示「冰激凌销量增加」，用B表示「溺水死亡者数量增加」。A与B之间成正相关，但我们都知道，A与B之间不存在因果关系，它们都是由一个共同的因素「夏天」导致的。由此可见，&lt;b&gt;仅仅使用概率统计的工具，并不足以让我们在现实中做出理性的因果推断&lt;/b&gt;。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;INUS条件：原因是&lt;b&gt;I&lt;/b&gt;nsufficient but &lt;b&gt;N&lt;/b&gt;ecessary parts of a condition which is itself &lt;b&gt;U&lt;/b&gt;nnecessary but &lt;b&gt;S&lt;/b&gt;ufficient。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;是INUS条件，但不是原因的例子，并不难构造：闪电、干草堆、消防员玩忽职守、空气干燥都是一场火灾的INUS条件。但是，我们知道闪电和雷声永远符合「如果有闪电，那么必然有雷声」；因此，雷声也是火灾的INUS条件，却不是火灾的原因。&lt;/p&gt;&lt;p&gt;上述一系列模型/定义，都有一个共同的缺陷：给定一个因果关系，这些模型可以完美套用；然而，给定一个此类模型，我们却无法直接确定不同变量之间的因果关系，因为这样的单个模型可以&lt;b&gt;同时描述多种不同的因果、甚至非因果的关系&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;哲学家们看似没有对因果关系提出令人满意的诠释。但是，这至多只是一种流行于哲学爱好者之间的误解。&lt;/b&gt;普通哲学爱好者们在因果关系方面的了解，通常不会超过休谟与康德，能知道刘易斯、必然论、多元主义之类都极为难得。实际上，&lt;b&gt;在统计、经济等领域，已经有大量成熟且投入使用的因果模型，它们准确反映了我们对因果的直觉认识，而且能被精确的数学语言描述。&lt;/b&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;二、事件性因果&lt;/h2&gt;&lt;p&gt;当我们说「A是因，B是对应的果」的时候，A和B可以是什么「东西」？&lt;/p&gt;&lt;p&gt;一般而言，我们认为A和B是某种&lt;b&gt;事件&lt;/b&gt;，而且&lt;b&gt;A必须发生在B之前&lt;/b&gt;。因为「因」必须发生在「果」之前，所以&lt;b&gt;如果A导致了B，那么不可能同时有B导致了A——两个事件无法互为因果&lt;/b&gt;。由此可见，因果关系存在一种&lt;b&gt;不对称性&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;针对「在时间上，因必须先于果」这一条件，哲学家们有过大量的讨论（&lt;a href=&quot;https://plato.stanford.edu/entries/causation-backwards/&quot;&gt;Backward Causation&lt;/a&gt;），其中不少还涉及尖端的量子力学。不过，我们仍然没有理由放弃这一条件。因为，不同的模型有不同的适用范围，而因果模型的适用范围主要是宏观现象、经济、医疗、复杂动力/电路系统，不论微观物理的结论如何，它在已知领域的有效性都不受影响。&lt;/p&gt;&lt;p&gt;有人或许会质疑，为什么两个东西不能互为因果呢？例如，让A1表示草原上羊的数量，让B1表示草原上狼的数量；其他条件不变，狼的增加会导致羊的减少，羊的减少会导致狼的减少，狼的减少会反而导致羊的增加，羊的增加进而导致狼的增加；A1和B1互为因果。&lt;/p&gt;&lt;p&gt;值得注意，A1与B1表示了某种&lt;b&gt;过程&lt;/b&gt;，而不是某些固定时间点上的&lt;b&gt;事件&lt;/b&gt;，所以A1与B1之间完整的因果关系无法用事件性因果表示。所以，对于这种质疑，我有以下几条回应：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;我们可以按照时间顺序，把每个时间点上的A和B拆分为单独的事件，即B1（狼增加）→A1（羊减少）→B2（狼减少）→A2（羊增加）。如此一来，事件性因果也能表达A与B之间的关系。&lt;/li&gt;&lt;li&gt;针对过程性的因果，我们有另一种模型——因果环路图（CLD），将在本文第三章介绍。&lt;/li&gt;&lt;li&gt;&lt;b&gt;过程性因果比事件性因果复杂。&lt;/b&gt;在理解过程性因果模型之前，我们需要先理解更简单的事件性因果模型。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;对于事件性因果，当前最成熟、最广泛的模型是&lt;b&gt;结构因果模型（Structural Causal Model，以下简称SCM）&lt;/b&gt;。SCM结合了结构方程（SEM）、虚拟事实模型（RCM）、概率图模型（主要是贝叶斯网络），并将其应用于因果分析。各类常用因果模型，都可以看作SCM的子类。接下来，我将以RCM、贝叶斯网络、SEM的顺序，按照SCM的发展思路，对其进行详细的介绍。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.1. 随机对照试验&lt;/b&gt;&lt;/p&gt;&lt;p&gt;任何一本初级统计学课本都会提到，基于观测的统计模型无法可靠地识别因果关系。要确定因果关系，必须通过&lt;b&gt;随机对照试验&lt;/b&gt;（Randomized Controlled Trial）。&lt;/p&gt;&lt;p&gt;在一个简单随机对照试验中，试验对象（通常是参加研究的志愿者，下文每一个对象用u表示）会被随机分入两组：&lt;b&gt;实验组&lt;/b&gt;（treatment group，下文用t表示）和&lt;b&gt;对照组&lt;/b&gt;（control group，下文用c表示）。&lt;/p&gt;&lt;p&gt;我们有多种不同的随机分组方式，例如&lt;b&gt;简单随机分组&lt;/b&gt;、&lt;b&gt;随机区组设计&lt;/b&gt;、&lt;b&gt;配对设计&lt;/b&gt;。使用随机区组设计时，研究者会先根据个体的特征（年龄、性别等）将其分入不同的区组，再在每个区组内实施简单随机分组。使用配对设计时，研究者会把在各方面都非常相似的个体（例如双胞胎、不同时间节点的同一个人）配成对，在每一对个体中随机选一个作为实验组，另一个作为对照组。&lt;/p&gt;&lt;p&gt;实验组的对象会接受干预，但对照组的对象不会受到任何干预/介入。在医学实验中，实验组的对象会接受真正的治疗，而对照组的对象只会收到安慰剂。实验结束后，研究者会比较实验组和对照组的结果。&lt;/p&gt;&lt;p&gt;如果我们用Y表示我们感兴趣的结果变量，那么我们可以用以下符号表示随机对照试验的结果：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;equation&gt;Y_c(u)&lt;/equation&gt; 是在对照组条件下，对象u展现出的结果变量Y。&lt;/li&gt;&lt;li&gt;&lt;equation&gt;Y_t(u)&lt;/equation&gt; 是在实验组条件下，对象u展现出的结果变量Y。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在研究中，我们通常会探究 &lt;equation&gt;Y_t(u)&lt;/equation&gt; 是否统计显著地不同于 &lt;equation&gt;Y_c(u)&lt;/equation&gt; 。这一过程涉及较为具体的统计假设检验，与本文的主要内容无关。但是，我们至少可以意识到，&lt;b&gt;t与c的区别是因果关系中的「因」， &lt;equation&gt;Y_t(u)&lt;/equation&gt; 与 &lt;equation&gt;Y_c(u)&lt;/equation&gt; 的区别是因果关系中的「果」&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2. 介入主义的因果观&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在随机对照实验的基础框架上，我们可以建立起一个&lt;b&gt;介入主义（interventionism）&lt;/b&gt;因果观。&lt;/p&gt;&lt;p&gt;一个介入主义的因果模型包括三部分：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;所有的系统 &lt;equation&gt;U&lt;/equation&gt;&lt;/b&gt; ：一个包含所有系统 &lt;equation&gt;u&lt;/equation&gt; 的集合。一个系统 &lt;equation&gt;u&lt;/equation&gt; 我们讨论的对象，可以是人体、机械、星球、化学反应系统、经济实体等。&lt;/li&gt;&lt;li&gt;&lt;b&gt;所有的介入方式 &lt;equation&gt;T&lt;/equation&gt;&lt;/b&gt; ：一个包含所有可能的介入方式 &lt;equation&gt;t&lt;/equation&gt; 的集合。例如，假设我们讨论的系统 &lt;equation&gt;U&lt;/equation&gt; 是一个有两个按钮的黑箱，一个按钮是红色的，另一个按钮是绿色的，那么所有可能的介入方式为 {按红按钮，按绿按钮，两个按钮都按，两个按钮都不按} 。（在这个具体的例子里，根据黑箱的结构不同，可能的介入方式或许不止四种，所以这只是一个经过简化，以便直观理解的模型。）&lt;/li&gt;&lt;li&gt;&lt;b&gt;状态函数 &lt;equation&gt;Y&lt;/equation&gt;&lt;/b&gt; ：输入一个系统 &lt;equation&gt;u&lt;/equation&gt; 和一种介入方式 &lt;equation&gt;t&lt;/equation&gt; ，输出系统的某个状态 &lt;equation&gt;y&lt;/equation&gt; ，写作 &lt;equation&gt;y=Y_t(u)&lt;/equation&gt; 。例如，在一个医疗实验中， &lt;equation&gt;Y&lt;/equation&gt; 可以反映「u（病人甲）在受到干预t（服用降压药）之后的y（血压）」。注意，&lt;b&gt;y不一定要完整描述u的状态的所有部分，只反映几个变量也是可以的&lt;/b&gt;。我们当然可以让y表示某个病人全身所有分子的运动状态，但这类过于复杂的状态函数，往往没有太大的实用价值。可是，在简单电路这样的系统中，完整表达电路每个节点的状态不仅可行，而且有利。因此，在建立因果模型时，我们需要具体问题具体分析，选择一个合适的状态函数。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;值得注意的是，因为「果」的定义涉及到 &lt;equation&gt;Y_t(u)&lt;/equation&gt; 与 &lt;equation&gt;Y_c(u)&lt;/equation&gt; 的区别，而单次介入只说明了t却没有说明c，所以 &lt;b&gt;&lt;equation&gt;T&lt;/equation&gt; 必须包含一种表示「不介入」的介入方式 &lt;equation&gt;c&lt;/equation&gt;&lt;/b&gt; 。也就是说，在一个因果模型中，&lt;b&gt;任何一个系统都必须有一种不受干预的「自然状态」&lt;/b&gt;。如果现实情况过于复杂，很难找到不受干预的自然状态，&lt;b&gt;我们可以把某种介入方式 &lt;equation&gt;c&lt;/equation&gt; 默认为「不介入」&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;因此：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;任意一个介入主义的因果模型，都必须明确指出一种代表「不介入」的介入方式。&lt;/li&gt;&lt;li&gt;当我们在问「为什么发生了现象 &lt;equation&gt;y_1&lt;/equation&gt;」的时候，我们其实在问：「在我对世界建立的因果模型中，自然状态的现象是 &lt;equation&gt;y_0=Y_c(u)&lt;/equation&gt; ，但是我观察到了现象 &lt;equation&gt;y1 \ne y0&lt;/equation&gt; 。于是，我认为实际发生的情况是 &lt;equation&gt;y_1=Y_t(u)&lt;/equation&gt; ，其中 &lt;equation&gt;t \ne c&lt;/equation&gt; 。 &lt;equation&gt;t&lt;/equation&gt; 与 &lt;equation&gt;c&lt;/equation&gt; 之间的区别是什么？」&lt;/li&gt;&lt;li&gt;或者，更简单地说，当我们问「为什么A」的时候，我们往往省略了后半句：「为什么A，而不是B？」&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以知乎搜索「为什么」前几个结果为例，我们可以发现，「默认状态」的思维方式的确无处不在。&lt;/p&gt;&lt;blockquote&gt;例1：&lt;a href=&quot;https://www.zhihu.com/question/58896903&quot;&gt;现在的男生为什么不追女生？&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;默认状态：男生应当追女生。&lt;/p&gt;&lt;blockquote&gt;例2：&lt;a href=&quot;https://www.zhihu.com/question/21128697&quot;&gt;为什么有人会点两百多块一杯的猫屎咖啡？&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;默认状态：一般人不会花两百多块买一杯咖啡。&lt;/p&gt;&lt;p&gt;另一些情形中，两个对话者可能选择了不同的默认状态，便带来了以下的对话：&lt;/p&gt;&lt;p&gt;甲：「你为什么做了A这件事？」（默认「不做A」是自然状态，要求乙为「做A」提供理由）&lt;/p&gt;&lt;p&gt;乙：「为什么不呢？」（默认「做A」是自然状态，把论证的责任转移到甲身上）&lt;/p&gt;&lt;p&gt;在下一部分（2.3），我们将把这一系列直觉发展为正式的虚拟事实模型。&lt;/p&gt;&lt;p&gt;不过，我希望先对&lt;b&gt;格兰杰因果（Granger causality）&lt;/b&gt;做出一些澄清。格兰杰因果的定义：如果得知事件A的发生有助于预测之后的事件B，那么我们说A是B的格兰杰因。然而，格兰杰因果&lt;b&gt;只包含了观测，却没有包含介入&lt;/b&gt;，直接操纵A并不一定能影响B，这与我们日常对因果的直觉不符。所以，格兰杰因果虽然名叫「因果」，却只是一个统计相关性的概念，而非真正的因果概念。在下文中，我不会对格兰杰因果做更多讨论。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3. 虚拟事实模型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;虚拟事实模型&lt;/b&gt;（Rubin Causal Model，简称RCM）由Donald Rubin提出。在RCM中，因果关系「果」的定义是 &lt;equation&gt;\delta(u)=Y_t(u)-Y_c(u)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;在实际生活中，我们考虑的系统往往不止一个——对于某个正在研发的药品，我们最感兴趣的无疑是它在&lt;b&gt;所有目标人群&lt;/b&gt;上的效果，而不仅仅是某个病人甲。继续采用RCM对于因果的定义，那么一个介入「因」对群体内所有个体的「果」是 &lt;equation&gt;E[\delta(u)]=E[Y_t(u)-Y_c(u)]=E[Y_t(u)]-E[Y_c(u)]&lt;/equation&gt; 。（由期望值的线性可得）&lt;/p&gt;&lt;p&gt;在上帝视角下，上述定义并不复杂。即使变量 &lt;equation&gt;y=Y_t(u)&lt;/equation&gt; 不是一个数值变量，我们也可以通过其他方式定义 &lt;equation&gt;\delta(u)&lt;/equation&gt; 。从更广泛的角度考虑，RCM定义中的减法未必是实数域的减法；针对更复杂的变量y（例如张量、概率分布），我们可以采用其他的减法，只要符合数学规范和具体研究需要即可。&lt;/p&gt;&lt;p&gt;可是在实际生活中，我们无法获得完美的信息：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;无法同时知晓 &lt;equation&gt;Y_c(u)&lt;/equation&gt; 与 &lt;equation&gt;Y_t(u)&lt;/equation&gt;&lt;/b&gt; 。由于每个人都是独一无二的，每个时间节点也是独一无二的，所以在受到了一种介入，并表现出新状态之后，这个系统不可能完美恢复到原来的状态，重新接受另一种介入。这种情况被称为「&lt;b&gt;因果推断的根本问题&lt;/b&gt;」（the Fundamental Problem of Causal Inference，以下简称&lt;b&gt;FPCI&lt;/b&gt;）。&lt;/li&gt;&lt;li&gt;&lt;b&gt;无法同时知晓每个个体的情况。&lt;/b&gt;正如在检测手机在极端条件下的质量时，我们不可能去砸坏每一个手机一样，我们只能随机从群体中抽取样本，再利用样本的统计数据推断群体参数。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;「无法同时知晓每个个体」的问题，已经有常规的统计学手段解决。但为了避免FPCI，我们必须对群体参数的分布做出额外的假设，包括但不限于以下的一种或多种：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;个体处理效应稳定假设&lt;/b&gt;（Stable unit treatment value assumption，简称SUTVA）：对于任意个体 &lt;equation&gt;u_1&lt;/equation&gt; 的干预不会影响到另一个任意个体 &lt;equation&gt;u_2&lt;/equation&gt; 的状态。SUTVA使我们可以把样本中每个个体的反应看作独立事件，从而降低了我们需要的样本体积、模型体积和建模时间。&lt;/li&gt;&lt;li&gt;&lt;b&gt;同效果假设&lt;/b&gt;（assumption of constant effect）：&lt;b&gt;对于所有的个体，某种介入方式造成的效果是相同的。&lt;/b&gt;例如，某个降压药对所有人的效果都是降低血压，不会产生增高血压的情况——即使有，也只不过是统计的噪声，可以用大样本、大数定理和中心极限定理消解。于是，我们可以得到 &lt;equation&gt;\hat{\delta}(u)=\bar{Y_t}(u)-\bar{Y_c}(u)&lt;/equation&gt; ，用样本内的平均效果估算这一介入方法对所有个体的因果效果。&lt;/li&gt;&lt;li&gt;&lt;b&gt;同质性假设&lt;/b&gt;（assumption of homogeneity）：&lt;b&gt;对于任意个体 &lt;equation&gt;u_1&lt;/equation&gt; 和 &lt;equation&gt;u_2&lt;/equation&gt; ，以及任意介入方式 &lt;equation&gt;t^*&lt;/equation&gt; ，始终有 &lt;equation&gt;Y_{t^*}(u_1)=Y_{t^*}(u_2)&lt;/equation&gt;&lt;/b&gt; 。&lt;b&gt;同质性假设强于同效果假设。&lt;/b&gt;例如，一个简单的FizzBuzz电脑程序在不同时间点上的性质理应完全相同。虽然在同一时间点上，我们无法同时测试它在不同输入下的输出，但是它在不同时间点上的表现必然相同。如果我们把「不同时间点上的FizzBuzz程序」看作一个群体，那么其中个体「每个时间点上的FizzBuzz程序」均符合同质性假设。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3.1. 虚拟事实模型的不足&lt;/b&gt;&lt;/p&gt;&lt;p&gt;虽然RCM提供了一个可以用数学、统计定义的因果模型，但是它的缺点也很明显：在介入时，我们通常&lt;b&gt;一次只能改变一个变量&lt;/b&gt;，观测的状态也只有一个变量。如果我们增加变量，模型的体积、需要的训练数据、训练时间都将以&lt;b&gt;指数级增长&lt;/b&gt;。在下一部分，我们可以看到，贝叶斯网络先验的条件独立信息可以缓解这一困难。&lt;/p&gt;&lt;p&gt;此外，RCM从自变量的「因」到应变量的「果」的结构&lt;b&gt;几乎完全是个黑箱&lt;/b&gt;，缺乏更清晰的可解释性。因此，单个RCM所能解决的问题也较为有限。相比之下，结构因果模型能为因果律、多变量之间的因果关系提供更详细的解释。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.4. 贝叶斯网络&lt;/b&gt;&lt;/p&gt;&lt;p&gt;贝叶斯网络是一种基于&lt;b&gt;有向无环图（directed acyclic graph，简称DAG）&lt;/b&gt;的概率图模型。虽然贝叶斯网络并不能直接表示因果，只能表示相关，但是它的图结构是SCM的基础。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d9b0f455833ccf4bbf4c94feaca40196_r.jpg&quot; data-caption=&quot;贝叶斯网络示例&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1033&quot; data-rawheight=&quot;875&quot;&gt;&lt;p&gt;在一个贝叶斯网络中，每个节点是一个随机变量，代表一个事件。通常，这个随机变量服从某个离散或连续的分布。一个节点 &lt;equation&gt;X&lt;/equation&gt; 中，储存了给定它的所有父节点 &lt;equation&gt;\mathrm{pa}(X)&lt;/equation&gt; 时 &lt;equation&gt;X&lt;/equation&gt; 的分布，即 &lt;equation&gt;P(X=x|\mathrm{pa}(x))&lt;/equation&gt; 。&lt;equation&gt;\mathrm{pa}(X)&lt;/equation&gt;表示节点X的所有父节点，即所有「拥有直接指向X的有向边」的节点。以上图为例， &lt;equation&gt;\mathrm{pa}(Grade)= \{\textit{Difficulty}, \textit{Intelligence}\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;贝叶斯网络（以及其他所有的概率图模型）相比于原始的联合分布模型，最大的优势在于增加了变量之间&lt;b&gt;条件独立&lt;/b&gt;的先验信息，从而&lt;b&gt;减小了模型的体积，与模型进行推断、学习的时间&lt;/b&gt;。例如，上图共有5个变量，如果用朴素的联合分布模型建模，条件概率表格的体积将会是 &lt;equation&gt;2 \times3\times2\times2\times2=48&lt;/equation&gt; ，而采用贝叶斯网络后，条件概率表格的总体积为 &lt;equation&gt;2 + 2 + 4 \times 2 + 2\times 1 + 3 \times 1 = 17&lt;/equation&gt; 。在小型的网络中，这种简化的效果尚不明显，但在大型网络中，假设每个变量有a种取值，那么联合分布模型的体积将为 &lt;equation&gt;O(a^n)&lt;/equation&gt; ，而一个合适的贝叶斯网络或许能把体积复杂度降低到多项式级别。最极端的情况是朴素贝叶斯，即所有的随机变量均独立，此时模型的体积复杂度为 &lt;equation&gt;O(an)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;条件独立的信息是先验的，它们往往由任务相关的专家提供，而非从数据中学习得到。&lt;/b&gt;这种做法能保证网络结构的可靠。（此处讨论的是parameter learning而非structure learning，网络结构已知而参数未知；对于后者，我们有Chow-Liu算法，但此处不讨论。）之后，我们也会发现，类似的先验因果假设在SCM中有重要地位。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.4.1. d分隔&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-92fbac23e221826585c55d4bddb09255_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;638&quot; data-rawheight=&quot;345&quot;&gt;&lt;p&gt;如图所示，对于一个贝叶斯网络中的三个节点/变量而言，一共有三种基本的结构。两种不同的条件独立假设。用 &lt;equation&gt;X \perp Y&lt;/equation&gt;表示X与Y之间独立：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;cascade&lt;/b&gt;: &lt;equation&gt;A \rightarrow B \rightarrow C&lt;/equation&gt; ，则必有 &lt;equation&gt;(A\perp C)|B&lt;/equation&gt; 以及 &lt;equation&gt;A \not\perp C&lt;/equation&gt; 。&lt;/li&gt;&lt;li&gt;&lt;b&gt;common parent&lt;/b&gt;: &lt;equation&gt;A \leftarrow B \rightarrow C&lt;/equation&gt;，同样有 &lt;equation&gt;(A\perp C)|B&lt;/equation&gt; 以及 &lt;equation&gt;A \not\perp C&lt;/equation&gt; 。&lt;/li&gt;&lt;li&gt;&lt;b&gt;V-structure&lt;/b&gt;: &lt;equation&gt;A \rightarrow B \leftarrow C&lt;/equation&gt; ，必有 &lt;equation&gt;A \perp C&lt;/equation&gt; 与 &lt;equation&gt;(A \not\perp C) | B&lt;/equation&gt; ，与前两种基本结构的条件独立情况不同。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;为了回答「给定一个随机变量的集合Z，随机变量A与B之间是否条件独立」这个问题，我们需要引入d分隔的概念。&lt;b&gt;d分隔（d-separation）&lt;/b&gt;的全名是「有向分隔」（directed separation）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;某个节点集合O能d分隔节点A与节点B，当且仅当：给定O时，A与B之间不存在有效路径（active path）。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对于A与B之间的无向无环路径P，如果P上的每三个连续节点，都符合以下四种情况中的一种，那么P就是一条有效路径：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;X←Y←Z且Y∉O&lt;/li&gt;&lt;li&gt;X→Y→Z且Y∉O&lt;/li&gt;&lt;li&gt;X←Y→Z且Y∉O&lt;/li&gt;&lt;li&gt;X→Y←Z且Y∈O。这种情况被称为&lt;b&gt;伯克森悖论（Berkson&#39;s Paradox）&lt;/b&gt;：当两个独立事件的共同结果被观察到时，这两个独立事件就不再相互独立了。例如，扔两个硬币，硬币A朝上的面和硬币B朝上的面之间，应该是相互独立的；然而，如果我们已知「有一个硬币正面朝上」，那么A与B朝上的面之间就不再相互独立了。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;相应地，&lt;b&gt;如果给定O之后，一条路径P不是一条有效路径&lt;/b&gt;，那么我们称&lt;b&gt;O节点集合 d分隔 了路径P&lt;/b&gt;。d分隔的概念适用于两个节点，也适用于两个节点之间的路径，后者在「后门准则」的定义中非常有用。&lt;/p&gt;&lt;p&gt;如果两个变量没有被d分隔，那么它们之间的状态被称为&lt;b&gt;d联结（d-connection）&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;d分隔能极大简化贝叶斯网络中 &lt;equation&gt;(X\perp Y )| Z&lt;/equation&gt; 等条件独立情况的判定。Pearl将其进一步泛化，提出了&lt;b&gt;拟图（graphoid）&lt;/b&gt;的概念。一个graphoid是一组形如「已知变量Z，则变量X与变量Y相互独立」的陈述，服从以下五条&lt;b&gt;拟图公理&lt;/b&gt;：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-220c102184781b71c753f20ea7e824da_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;901&quot; data-rawheight=&quot;357&quot;&gt;&lt;p&gt;关于graphoid中文翻译的备注：graphoid尚无权威的中文翻译，而且在互联网上几乎没有任何相关的中文材料。我在选择译名时，参考了matroid的翻译。既然matrix是矩阵，而matroid是拟阵，那么graph是图，所以graphoid应该被称为拟图。&lt;/p&gt;&lt;p&gt;拟图的概念只出现在Pearl的著作中。不过，如果我们采用概率论对于「独立事件」的定义，那么我们可以把它们当做定理推导得出，可见概率论的「独立」符合拟图公理体系。当然，intersection的成立需要一个额外条件：针对所有的事件A，如果 &lt;equation&gt;A \ne \emptyset&lt;/equation&gt; ，那么 &lt;equation&gt;P(A)&amp;gt;0&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.4.2. 为什么贝叶斯网络不适合做因果模型？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;有了一个学习完毕的贝叶斯网络后，我们可以用它进行各类推断，主要是概率推断&lt;equation&gt;P(X_i|X_{j_1}, X_{j_2}, X_{j_3}, ..., X_{j_k})&lt;/equation&gt; ：已知 &lt;equation&gt;X_{j_1}, X_{j_2}, X_{j_3}, ..., X_{j_k}&lt;/equation&gt; 等随机变量的值，求另一随机变量 &lt;equation&gt;X_i&lt;/equation&gt; 的条件概率。贝叶斯网络的优越性体现于，&lt;b&gt;即使有大量的缺失、未知变量值，它也能利用边缘化操作，毫无障碍地进行概率推断&lt;/b&gt;。在SCM中，这一功能仍然有相当重要的地位。&lt;/p&gt;&lt;p&gt;如果我们把箭头看作从因指向果，把A→B看作A导致了B，那么贝叶斯网络&lt;b&gt;看起来似乎&lt;/b&gt;能表达因果关系。然而，&lt;b&gt;贝叶斯网络本身无法区分出因果的方向&lt;/b&gt;。例如，A←B←C与A→B→C的因果方向完全相反，但在贝叶斯网络的模型描述下，它们表达的概率分布和条件独立假设完全相同。&lt;/p&gt;&lt;p&gt;此外，概率论「给定/已知随机变量Z」里的&lt;b&gt;「给定/已知」只能用于表达观察，而非介入&lt;/b&gt;。例如，P(下雨|地面是湿的)与P(地面是湿的|下雨)的概率值都很高，其中「给定“地面是湿的”」与「给定“下雨”」&lt;b&gt;都是观察而非介入的结果&lt;/b&gt;。用&lt;b&gt;do(X)表示「介入，使得事件X发生」&lt;/b&gt;，现在考虑另一种情况：P(下雨|do(地面是湿的))。根据直觉，显然P(下雨|do(地面是湿的)) &amp;lt; P(下雨|地面是湿的)，因为把地面弄湿并不能导致下雨。&lt;/p&gt;&lt;p&gt;综上所述，贝叶斯网络虽然十分强大，但无法准确描述因果关系。下文的SEM将主要解决这个问题。在学习贝叶斯网络的过程中，我们也应该尽量避免使用「因果」相关的词语——贝叶斯网络中，A→B未必等同于A导致B。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.5. 结构方程+结构因果模型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;为了表示因果关系，我们需要对贝叶斯网络进行改进。&lt;b&gt;结构方程模型（Structural Equation Model，简称SEM）&lt;/b&gt;在经济与工程领域十分常用。在贝叶斯网络的基础上加入SEM的成分之后，我们就离完善的SCM（结构因果模型）更近了一步。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.5.1. 打破对称性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在贝叶斯网络中，节点 &lt;equation&gt;X&lt;/equation&gt; 的概率分布 &lt;equation&gt;P(X=x|\mathrm{pa}(X))&lt;/equation&gt; 由它的父节点 &lt;equation&gt;\mathrm{pa}(x)&lt;/equation&gt; 决定，记录在一个条件概率表格中。然而，条件概率表格和一些简单的连续概率分布都是&lt;b&gt;可逆&lt;/b&gt;的。例如，对于随机变量 &lt;equation&gt;X&lt;/equation&gt; 和 &lt;equation&gt;Y&lt;/equation&gt; ，如果 &lt;equation&gt;Y=\alpha X + \beta&lt;/equation&gt; ，那么我们可以操纵代数表达式，得到 &lt;equation&gt;X=\frac{Y-\beta}{\alpha}&lt;/equation&gt; 。然而，这种&lt;b&gt;对称性&lt;/b&gt;在因果关系里是&lt;b&gt;不符合直觉&lt;/b&gt;的。对称的代数表达式表明，如果我们改变Y，X就会发生相应的改变；可是，修改温度计的读数并不会改变环境温度，调整闹钟的时针并不会改变真正时间的流动。&lt;/p&gt;&lt;p&gt;因此，在SEM中，我们用&lt;b&gt;函数式&lt;/b&gt;的方程表示某个变量 &lt;equation&gt;X&lt;/equation&gt; ： &lt;equation&gt;X=f_X(\mathrm{pa}(X),\mathrm{u}(X))&lt;/equation&gt; 。其中， &lt;equation&gt;\mathrm{pa}(X)&lt;/equation&gt; 表示X的父节点中的&lt;b&gt;内生变量（endogenous variable）&lt;/b&gt;； &lt;equation&gt;\mathrm{u}(X)&lt;/equation&gt; 表示X的父节点中的&lt;b&gt;外生变量（exogenous variable）&lt;/b&gt;，只有一个。内生变量依赖于其他变量，在SCM中表示为「存在父节点的节点」，即至少有一条边指向该节点；外生变量独立于其他变量，在SCM中表示为「不存在父节点的节点」，即没有边指向该节点。&lt;/p&gt;&lt;p&gt;传统的路径分析研究中， &lt;equation&gt;f_X&lt;/equation&gt; 通常是一个线性函数，因果律的定义也局限与 &lt;equation&gt;Y=\alpha X + \beta&lt;/equation&gt; 中的 &lt;equation&gt;\alpha&lt;/equation&gt; 。但是，在数据越发复杂的现在，我们完全可以采用非线性函数、非参数模型。相对地，「因果」的定义也从路径参数 &lt;equation&gt;\alpha&lt;/equation&gt; 变成了更广义的&lt;b&gt;「变化传递」&lt;/b&gt;，参见前文RCM的部分。作为一个广泛的模型框架，SCM可以产生各式各样的复杂模型。&lt;/p&gt;&lt;p&gt;在最广泛的条件下，函数 &lt;equation&gt;f_X&lt;/equation&gt; 是不可逆的。我们需要把 &lt;equation&gt;X=f_X(\mathrm{pa}(X),\mathrm{u}(X))&lt;/equation&gt; 理解为&lt;b&gt;「（大自然/模型本身）对X的赋值」&lt;/b&gt;，而不仅仅是一个普通的代数等式。SCM要求所有的箭头 &lt;equation&gt;A\to B&lt;/equation&gt; 必须表示「A直接导致B」。所以，在因果推断的过程中，我们必须按照因果箭头的方向进行推理，不能颠倒顺序。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2f59fbad01d5b57d7c151822c14712ac_r.jpg&quot; data-caption=&quot;图1：结构因果模型示意图&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;531&quot; data-rawheight=&quot;138&quot;&gt;&lt;p&gt;如上图所示， &lt;equation&gt;U_X&lt;/equation&gt; 与 &lt;equation&gt;U_Y&lt;/equation&gt; 是外生变量， X与Y是内生变量，X可以导致Y。在图(a)中， &lt;equation&gt;U_X&lt;/equation&gt; 与 &lt;equation&gt;U_Y&lt;/equation&gt; 之间没有边相连，而在图(b)中， &lt;equation&gt;U_X&lt;/equation&gt; 与 &lt;equation&gt;U_Y&lt;/equation&gt; 之间有一条用虚线表示的双向箭头。在SCM里，我们用&lt;b&gt;单向箭头&lt;/b&gt;表达&lt;b&gt;直接的因果关系&lt;/b&gt;，用&lt;b&gt;双向箭头&lt;/b&gt;表明&lt;b&gt;两个外生变量之间可能存在未知的混杂因素&lt;/b&gt;（confounding variable）。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;U_X&lt;/equation&gt; 与 &lt;equation&gt;U_Y&lt;/equation&gt; 等外生变量可以表示「模型没有考虑到的环境噪音」，从而为看似非随机的结构方程模型加入&lt;b&gt;随机的成分&lt;/b&gt;。因此，SEM并非完全确定，它也可以拥有概率、不确定性等特征；SCM比普通的贝叶斯网络更广泛。此外，一个SCM描述了数据的生成原理，而不仅是表面观测到的概率分布，所以SCM比贝叶斯网络更稳定。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.5.2. 介入&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如上文所言，SCM是对于贝叶斯网络的一种泛化。一般的贝叶斯网络可以解答两类问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;条件概率： &lt;equation&gt;P(Y|E=e)&lt;/equation&gt; ，其中Y是我们感兴趣的一组未知变量，E是一组我们&lt;b&gt;观察&lt;/b&gt;到的已知变量，e是我们&lt;b&gt;观察&lt;/b&gt;到的E的值。E可以是空集，代表「我们没有观察到任何变量」。&lt;/li&gt;&lt;li&gt;最大后验概率（MAP）： &lt;equation&gt;\arg\max_{y}{P(Y=y|E=e)}&lt;/equation&gt; ，我们想要找到的是一组最有可能的Y值。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果不考虑算法复杂度，一个能估计条件概率的模型必然能估计MAP，所以下文将只讨论条件概率的情况。&lt;/p&gt;&lt;p&gt;&lt;b&gt;在「观察」的基础上，SCM还能做到「介入」&lt;/b&gt;： &lt;equation&gt;P(Y|E=e, do(X=x))&lt;/equation&gt; 。其中，我们对系统进行介入，迫使一组变量X拥有值x。在X是一个空集的情况下，SCM与普通的贝叶斯网络差别不大。&lt;/p&gt;&lt;p&gt;以下图为例，我将展示SCM实现介入的方法。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bfddee417c2bc99edd58383eae72548c_r.jpg&quot; data-caption=&quot;图2：一个SCM&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;560&quot; data-rawheight=&quot;117&quot;&gt;&lt;p&gt;在这个SCM中，变量X、Y、Z之间的关系可以用以下的结构方程表示：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;equation&gt;Z=f_Z(U_Z)&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;&lt;equation&gt;X=f_X(Z, U_X)&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;&lt;equation&gt;Y=f_Y(X, U_Y)&lt;/equation&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在此模型中，我们假设 &lt;equation&gt;U_X&lt;/equation&gt; 与 &lt;equation&gt;U_Y&lt;/equation&gt; 与 &lt;equation&gt;U_Z&lt;/equation&gt; 这三个外生变量独立。所以，图(a)与图(b)中的 &lt;equation&gt;U_X&lt;/equation&gt; 与 &lt;equation&gt;U_Y&lt;/equation&gt; 与 &lt;equation&gt;U_Z&lt;/equation&gt; 之间均没有边相连。&lt;/p&gt;&lt;p&gt;如图(b)所示，当我们进行介入 &lt;equation&gt;do(X=x_0)&lt;/equation&gt; 时，我们&lt;b&gt;切断了所有指向X的边，并将X赋值为 &lt;equation&gt;x_0&lt;/equation&gt;&lt;/b&gt; 。于是，新的SCM包括了一套新的结构方程：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;equation&gt;Z=f_Z(U_Z)&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;&lt;equation&gt;X=x_0&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;&lt;equation&gt;Y=f_Y(X, U_Y)&lt;/equation&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;b&gt;综上所述，一个SCM（写作&lt;/b&gt; &lt;equation&gt;M_1&lt;/equation&gt; &lt;b&gt;）估计 &lt;equation&gt;P_{M_1}(Y|E=e,do(X=x))&lt;/equation&gt; 的方式为：完成对原有模型 &lt;equation&gt;M_1&lt;/equation&gt; 的介入 &lt;equation&gt;do(X=x)&lt;/equation&gt; 之后，得到一个新的模型&lt;/b&gt; &lt;equation&gt;M_2&lt;/equation&gt; &lt;b&gt;。随后，在 &lt;equation&gt;M_2&lt;/equation&gt; 上估计 &lt;equation&gt;P_{M_2}(Y|E=e)&lt;/equation&gt; 。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;有人可能会产生疑问：「观察和介入，有什么本质区别吗？」&lt;/p&gt;&lt;p&gt;一个日常例子式的回答如下：&lt;/p&gt;&lt;p&gt;用A代表「环境温度」，用B代表「温度计读数」，A与B之间的因果关系为 &lt;equation&gt;A \to B&lt;/equation&gt; 。在默认状态下，温度计不会受到外在干预。因此，&lt;b&gt;观察&lt;/b&gt;到温度计读数升高，我们可以推断出环境温度升高。但是，当我们直接干预温度计时（例如用手握住温度计），我们进行了&lt;b&gt;介入&lt;/b&gt; &lt;equation&gt;do(B=b_1)&lt;/equation&gt; ，使温度计的读数变成了 &lt;equation&gt;b_1&lt;/equation&gt; ；同时，因为是介入而非观察，&lt;b&gt;从A到B的因果箭头被切断了&lt;/b&gt;，我们有 &lt;equation&gt;A\not\to B&lt;/equation&gt; 或 &lt;equation&gt;A \ \ \ \ \ B&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;假设 &lt;equation&gt;b_1&lt;/equation&gt; 是一个较高的温度，那么 &lt;equation&gt;P(A=b_1|B=b_1)&lt;/equation&gt; 代表「在自然状态下，观察到温度计的读数是 &lt;equation&gt;b_1&lt;/equation&gt; 时，实际的环境温度为 &lt;equation&gt;b_1&lt;/equation&gt; 的概率」； &lt;equation&gt;P(A=b_1|do(B=b_1))&lt;/equation&gt; 代表「在外在干预使温度计读数成为 &lt;equation&gt;b_1&lt;/equation&gt; 时，实际的环境温度为 &lt;equation&gt;b_1&lt;/equation&gt; 的概率」。&lt;b&gt;显然， &lt;equation&gt;P(A=b_1|B=b_1) &amp;gt; P(A=b_1|do(B=b_1))&lt;/equation&gt; ，可见观察与介入是两种完全不同的行为。观察不会影响模型的自然状态，但介入会。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.5.3. 因果推断的数学原理&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在这一部分，我将介绍SCM进行因果推断的数学基础。&lt;/p&gt;&lt;p&gt;我们说一个SCM具有&lt;b&gt;马尔可夫性质&lt;/b&gt;，当且仅当&lt;b&gt;这个SCM不包含任何的有向环，且所有外生变量均相互独立&lt;/b&gt;。因为外生变量通常被理解为某种「误差项」或「噪音项」，所以如果某些外生变量之间存在相关性，那么它们之间可能存在&lt;b&gt;混淆变量&lt;/b&gt;。在一个马尔可夫式SCM中，我们可以得到以下的基本定理：&lt;/p&gt;&lt;p&gt;&lt;b&gt;因果马尔可夫条件&lt;/b&gt;： &lt;equation&gt;P(v_1, v_2, ..., v_n)=\prod_{i=1}^{n}P(v_i|\mathrm{pa}(v_i))&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中， &lt;equation&gt;v_i&lt;/equation&gt; 代表我们感兴趣的变量， &lt;equation&gt;\mathrm{pa}(v_i)&lt;/equation&gt; 代表它的父节点中的所有内生变量。利用因果马尔可夫条件，我们可以把一个联合概率分布分解为多个条件概率分布的积。&lt;/p&gt;&lt;p&gt;一个符合因果马尔可夫条件的SCM经过介入之后，仍然符合因果马尔可夫条件，条件概率计算如下：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;P(v_1, v_2, ..., v_n|do(X=x))=\prod_{i=1, v_i\notin X}^{n}P(v_i|\mathrm{pa}(v_i))|_{X=x}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中，X是一系列受到干预的变量，x是X中变量受干预之后的数值。 &lt;equation&gt;P(v_i|\mathrm{pa}(v_i))|_{X=x}&lt;/equation&gt; 表示， &lt;equation&gt;\mathrm{pa}(v_i)&lt;/equation&gt; 里同时也在X里（即在 &lt;equation&gt;\mathrm{pa}(v_i) \cup X&lt;/equation&gt; 中）的变量将被赋值为 &lt;equation&gt;x&lt;/equation&gt; 的对应值。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bfddee417c2bc99edd58383eae72548c_r.jpg&quot; data-caption=&quot;图2&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;560&quot; data-rawheight=&quot;117&quot;&gt;&lt;p&gt;以图2为例，在干预之前， &lt;equation&gt;P(Z, Y, X) = P(Z)P(X|Z)P(Y|X)&lt;/equation&gt; ，而在干预 &lt;equation&gt;do(X=x_1)&lt;/equation&gt; 之后， &lt;equation&gt;P(Z, Y|do(X=x_1)) = P(Z)P(Y|X=x_1)&lt;/equation&gt; 。注意，由于从Z到X的因果箭头已经被切断， &lt;equation&gt;P(Z)=P(Z|do(X=x_1))&lt;/equation&gt; ，因为直接改变X无法影响Z。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在《Causality》中，Pearl证明了一个更广泛的结论：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;P(Y=y|do(X=x))=\sum_t{P(Y=y|T=t,X=x)P(T=t)}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中，每一个t都代表X所有父节点的一种可能取值。由于所有直接指向X的箭头已经被切断，所以自然有 &lt;equation&gt;P(T=t|X=x)=P(T=t)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.5.4. 后门准则（back-door criterion）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;考虑如下图3所示的SCM：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6e12dd916d27ef0130aded624a625500_r.jpg&quot; data-caption=&quot;图3&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;431&quot; data-rawheight=&quot;311&quot;&gt;&lt;p&gt;在SCM中，如果&lt;b&gt;一条无向连接X与Y的路径有一条指向X的箭头&lt;/b&gt;，那么我们把这条路径称为&lt;b&gt;从X到Y的后门路径&lt;/b&gt;。按照正常的因果链，「X导致Y」的结构应该是 &lt;equation&gt;X\to V_1 \to V_2 \to ... \to V_{k-1} \to V_{k} \to Y&lt;/equation&gt; ；然而，如果X与Y之间后门路径存在，那么实际结果中很可能出现虚假的统计相关性。&lt;/p&gt;&lt;p&gt;因此，当一个变量集合S符合以下两个条件时，我们称S符合后门准则：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;S中不包括X的后代。&lt;/li&gt;&lt;li&gt;S能d分隔所有从X到Y的后门路径。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;例如，在图3里， &lt;equation&gt;\{Z_1, Z_2, Z_3\}, \{Z_1, Z_3\}, \{W_1, Z_3\}, \{W_2, Z_3\}&lt;/equation&gt; 等集合都满足后门准则，但 &lt;equation&gt;\{Z_3\}&lt;/equation&gt; 不满足后门准则。&lt;/p&gt;&lt;p&gt;后门准则的重要性在于，它进一步泛化了2.5.3.结尾的公式。如果S满足从X到Y的后门准则，那么，我们可以推导得到：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;P(Y = y|do(X = x), S = s) = P(Y = y|X = x, S = s)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;P(Y = y|do(X = x)) = \sum_s P(Y = y|X = x, S = s)P(S=s)=\sum_s \frac{P(Y = y, X = x, S = s)}{P(X=x, S=s)}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;这极大简化了SCM推导时的运算。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.6. SCM的反事实推理&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;反事实推理（counterfactual inference）&lt;/b&gt;的核心在于：虽然现实情况下 &lt;equation&gt;X=x_1&lt;/equation&gt; ，但是假如&lt;equation&gt;X=x_2&lt;/equation&gt; 的话，Y会怎么样呢？&lt;/p&gt;&lt;p&gt;有些人后悔，「如果我当年……，那么我现在就能……。」这一思维方式就是反事实推理。&lt;/p&gt;&lt;p&gt;反事实推理与FPCI（因果推断的根本问题）息息相关。对于一个已经接受了实验组介入的样本u，我们只能观察到u的 &lt;equation&gt;Y_t(u)&lt;/equation&gt; ，却永远无法观察到 &lt;equation&gt;Y_c(u)&lt;/equation&gt; ，反之亦然。RCM（虚拟事实模型）对反事实推理有一定的描述，但RCM整体不如SCM清晰、明确、易解释。&lt;/p&gt;&lt;p&gt;下面，我将&lt;b&gt;用SCM重新表达2.2部分中提到的介入主义因果观&lt;/b&gt;。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;RCM考虑的对象是一个种群 &lt;equation&gt;U&lt;/equation&gt; 内的所有个体 &lt;equation&gt;u&lt;/equation&gt; 。在很多情形下，同质性假设不成立，每个个体都不尽相同。在SCM中，&lt;b&gt;个体的差异会被误差项 &lt;equation&gt;U_V&lt;/equation&gt; 表示&lt;/b&gt;（外生变量 &lt;equation&gt;U_V&lt;/equation&gt; 会相对应地影响内生变量 &lt;equation&gt;V&lt;/equation&gt; ）。除了 &lt;equation&gt;U_V&lt;/equation&gt; 之外，模型 &lt;equation&gt;M&lt;/equation&gt; 本身所代表的「自然法则」保持不变。&lt;/li&gt;&lt;li&gt;RCM的表达式 &lt;equation&gt;Y_t(u)&lt;/equation&gt; 可以表示为 &lt;equation&gt;M.\mathtt{query}(P(Y|do(T=t), U=u))&lt;/equation&gt; 。即：&lt;b&gt;我们对模型M进行干预，使得变量T赋值为t；同时，我们观察到所有外生变量U的值为u；在此情况下，我们向模型M查询我们感兴趣变量Y的条件概率。&lt;/b&gt;&lt;/li&gt;&lt;li&gt;RCM要求模型拥有一个「不受介入」的默认状态。显然，SCM符合要求：&lt;equation&gt;Y_c(u)=M.\mathtt{query}(P(Y|U=u))&lt;/equation&gt; &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因此，SCM可以回答类似「假如 &lt;equation&gt;X=x_1&lt;/equation&gt; 而非现实中的 &lt;equation&gt;X=x_0&lt;/equation&gt; ，Y的值是什么？」的反事实问题。但是，在现实生活中，由于个体信息 &lt;equation&gt;U=u&lt;/equation&gt; 通常未知，而复杂的非线性结构方程可能会随着U的分布变化而变化，所以反事实推理普遍比较困难。&lt;/p&gt;&lt;p&gt;总而言之，所有RCM均可以用SCM表达，而且SCM的白箱比RCM的黑箱更清晰、更稳定。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;三、过程性因果&lt;/h2&gt;&lt;p&gt;在第二章，我们使用的SCM（结构因果模型）建立在三条基本直觉上：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;因和果都是单独时间点上的单独事件&lt;/li&gt;&lt;li&gt;因在前，果在后&lt;/li&gt;&lt;li&gt;（由1和2可得）两个事件无法互为因果&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;不过，在其他一些情境中，例如掠食者的数量与猎物的数量，两个变量似乎「互为因果」。SCM与贝叶斯网络不允许环路的存在，故无法表示此类直觉上的因果关系。所以，我们需要一个更复杂的因果模型——&lt;b&gt;因果环路图（Causal Loop Diagram，简称CLD）&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;CLD中的变量基于以下的直觉：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;因和果是某种&lt;b&gt;过程&lt;/b&gt;，有一段持续的时间&lt;/li&gt;&lt;li&gt;因和果的持续时间段可以相互重叠&lt;/li&gt;&lt;li&gt;两个过程可以互为因果，甚至一个过程自身也可以形成因果环路&lt;/li&gt;&lt;/ol&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2d54fa8887f3ca929ff3d1aca035c6ff_r.gif&quot; data-caption=&quot;因果环路图：银行存款与利息&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;264&quot; data-rawheight=&quot;308&quot; data-thumbnail=&quot;https://pic4.zhimg.com/v2-2d54fa8887f3ca929ff3d1aca035c6ff_b.jpg&quot;&gt;&lt;p&gt;和SCM相比，CLD尚未有那么严谨、广泛的理论框架。我们可以把CLD理解为一个「从时间标量（实数）到一个SCM集」的函数映射。为了方便建模，所有的变量都是数值变量，而且多个过程变量之间的相互影响往往都是线性的，形如 &lt;equation&gt;Y=\alpha X + \beta&lt;/equation&gt; 。如果 &lt;equation&gt;\alpha = \frac{dY}{dX} &amp;gt; 0&lt;/equation&gt; ，那么我们说从X到Y的链接是&lt;b&gt;正链接&lt;/b&gt;；如果 &lt;equation&gt;\alpha = \frac{dY}{dX} &amp;lt; 0&lt;/equation&gt; ，那么我们说从X到Y的链接是&lt;b&gt;负链接&lt;/b&gt;。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-793e119dfa33cf7b26893a16572c2de6_r.gif&quot; data-caption=&quot;正链接（左）与负链接（右）&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;464&quot; data-rawheight=&quot;236&quot; data-thumbnail=&quot;https://pic3.zhimg.com/v2-793e119dfa33cf7b26893a16572c2de6_b.jpg&quot;&gt;&lt;p&gt;对于&lt;b&gt;因果环路&lt;/b&gt; &lt;equation&gt;A \to B \to A&lt;/equation&gt; ：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果A起初的一点增加（或减少）会通过因果环路，导致A进一步增加（或减少），那么我们称之为&lt;b&gt;强化反馈回路&lt;/b&gt;。&lt;/li&gt;&lt;li&gt;如果A起初的一点增加（或减少）会通过因果环路，反而导致A减少（或增加），从而中和最初的增加（减少），那么我们称之为&lt;b&gt;平衡反馈回路&lt;/b&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;假设A&amp;gt;0且B&amp;gt;0，那么：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果 &lt;equation&gt;A\to B&lt;/equation&gt; 与 &lt;equation&gt;B \to A&lt;/equation&gt; 的链接正负&lt;b&gt;相同&lt;/b&gt;，那么我们通常可以得到一个&lt;b&gt;强化&lt;/b&gt;反馈回路。&lt;/li&gt;&lt;li&gt;如果 &lt;equation&gt;A\to B&lt;/equation&gt; 与 &lt;equation&gt;B \to A&lt;/equation&gt; 的链接正负&lt;b&gt;相反&lt;/b&gt;，那么我们通常可以得到一个&lt;b&gt;平衡&lt;/b&gt;反馈回路。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;更一般地，在一个因果环路图中：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果有&lt;b&gt;偶数个负链接&lt;/b&gt;，那么它是一个&lt;b&gt;强化&lt;/b&gt;反馈回路。&lt;/li&gt;&lt;li&gt;如果有&lt;b&gt;奇数个负链接&lt;/b&gt;，那么它是一个&lt;b&gt;平衡&lt;/b&gt;反馈回路。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;反馈回路的实际意义通常如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;强化&lt;/b&gt;反馈回路通常意味着&lt;b&gt;指数增加、指数衰减&lt;/b&gt;，例如「利滚利」的银行存款与利息、不受限制的人口增长。&lt;/li&gt;&lt;li&gt;&lt;b&gt;平衡&lt;/b&gt;反馈回路通常意味着&lt;b&gt;达到某个平衡状态&lt;/b&gt;，例如洛特卡-沃尔泰拉方程的解。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在未来，一个可能的研究方向是把SCM中较为成熟、广泛的因果推断框架推广到CLD上。研究的重点在于引入非线性、非参数的复杂因果链接。此类研究必然十分困难，但随着电脑计算能力的增强，我们将逐渐有能力构建更复杂的CLD。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;参考资料、拓展阅读：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://ermongroup.github.io/cs228-notes/&quot;&gt;CS228 Notes&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2836213/&quot;&gt;An Introduction to Causal Inference&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://books.google.com/books?id=dOruCwAAQBAJ&amp;amp;printsec=frontcover&amp;amp;source=gbs_ge_summary_r&amp;amp;cad=0#v=onepage&amp;amp;q&amp;amp;f=false&quot;&gt;Probabilistic Graphical Models: Principles and Techniques&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://books.google.com/books?id=LLkhAwAAQBAJ&amp;amp;printsec=frontcover&amp;amp;dq=causality&amp;amp;hl=en&amp;amp;sa=X&amp;amp;ved=0ahUKEwjyxfTFy7XZAhXS2lMKHQTnAcwQ6AEIJjAA#v=onepage&amp;amp;q=causality&amp;amp;f=false&quot;&gt;Causality - Judea Pearl&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://bayes.cs.ucla.edu/LECTURE/lecture_sec1.htm&quot;&gt;The Art and Science of Cause and Effect - Judea Pearl&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;后记&lt;/h2&gt;&lt;p&gt;经过此次文献阅读，我意识到，很多看似困难的哲学问题，或许在其他领域（经济学、人工智能、社会学、统计学、心理学、流行病学等）已经有了足够好的解答。因此，&lt;b&gt;不论我们在学习什么学科，我们都不能被脚下的一亩三分地限制了视野。恰恰相反，我们应该多从不同的学科汲取灵感&lt;/b&gt;，切莫给自己打上「只研究xxxx领域」、故步自封。&lt;/p&gt;&lt;p&gt;同时，我们也应当意识到，&lt;b&gt;学习形而上学等较为抽象、高级的学科时，很容易产生一种虚假的优越感&lt;/b&gt;，认为自己比那些「只知道实际应用的人」高一等，从而忽视了实践的重要性。这种做法是不可取的——例如，我不能因为研究因果关系而忽视数据挖掘调参技巧……总之，&lt;b&gt;仰望星空，脚踏实地&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;如果喜欢的话，不妨点个赞，让更多的人看到；欢迎关注我 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/30f4c8f8f80bd067003f527f67ec43e7&quot; data-hash=&quot;30f4c8f8f80bd067003f527f67ec43e7&quot; data-hovercard=&quot;p$b$30f4c8f8f80bd067003f527f67ec43e7&quot;&gt;@光喻&lt;/a&gt; 和我的专栏&lt;a href=&quot;https://zhuanlan.zhihu.com/tenniel-ai&quot;&gt;光喻的人工智能笔记&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;下半年就要高三了，所以这类长文以后可能会写得比较少……总之先打算多学习、多输入、多提升自己，希望我分享的知识能为大家带来启发和帮助。&lt;/p&gt;&lt;p&gt;这是我第一次写比较深入的综述文章。在网上，我还没有找到能全面介绍统计因果模型的中文材料，所以几乎所有观点都是根据论文和《Causality》书籍原文综合总结得出的，翻译也可能有错漏的地方。如果有什么失误或者解释得不清楚的地方，请在评论区指出，我会及时更新的。&lt;/p&gt;&lt;p&gt;谢谢各位的阅读啦~&lt;/p&gt;&lt;p&gt;(｀・ω・´)&lt;/p&gt;</description>
<author>光喻</author>
<guid isPermaLink="false">2018-02-28-33860572</guid>
<pubDate>Wed, 28 Feb 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Programming Languages: Application and Interpretation【译15上】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-02-18-33865846.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33865846&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b71b632ed7974538bb2e812bcd20914e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;初翻： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/9bebf466fc2535bec442451dca7cd13a&quot; data-hash=&quot;9bebf466fc2535bec442451dca7cd13a&quot; data-hovercard=&quot;p$b$9bebf466fc2535bec442451dca7cd13a&quot;&gt;@lotuc&lt;/a&gt; &lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;https://lotuc.gitbooks.io/plai-cn/content/&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;15 静态地检查程序中的不变量：类型&lt;/h2&gt;&lt;p&gt;当程序变得更大或者更为复杂时，程序员希望能有工具帮助他们描述、验证程序中的&lt;b&gt;不变量&lt;/b&gt;。顾名思义，不变量指的就是关于程序组成元素的那些不会发生改变的陈述。例如，当我们在静态类型语言中写下&lt;code class=&quot;inline&quot;&gt;x : number&lt;/code&gt;时，表示 x 中存放的总是数，程序中依赖 x 的部分都可以认定它是数的这个事实不会改变。我们将会看到，类型只是我们想要陈述的各类不变量中的一种，静态类型检测——一个分支众多的技术家族——也只是用于控制不变量的众多方法中的一个。&lt;/p&gt;&lt;h2&gt;15.1 静态类型规则&lt;/h2&gt;&lt;p&gt;本章我们将专注于&lt;b&gt;静态类型检查&lt;/b&gt;：即在程序执行前检查（声明的）类型。之前使用的静态类型语言已经让我们积攒了一些这种形式程序的经验。我们将探索类型的设计空间及这些设计中的权衡取舍。尽管类型是控制不变量的一种非常强大且有效的方法，最后我们还是会考察一些其它可用的技术。&lt;/p&gt;&lt;p&gt;考虑下面这段静态语言写就的程序：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (f [n : number]) : number
  (+ n 3))

(f &quot;x&quot;)&lt;/code&gt;&lt;p&gt;程序开始执行前我们就会得到一个静态类型错误。使用普通 Racket 写就的同样的程序（去除类型注解）只会在运行时出错：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (f n)
  (+ n 3))

(f &quot;x&quot;)&lt;/code&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;如何判断错误是在程序执行前还是运行时抛出的？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;考虑下面这段 Racket 程序：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define f n
  (+ n 3))&lt;/code&gt;&lt;p&gt;它也是在程序执行前就遇到错误——语法解析错误——终止。尽管我们认为语法解析和类型检查有所不同——通常是因为类型检测是针对已经被解析好的程序做的——但是将语法解析看作一种最简单形式的类型检查也很有用：它（静态地）判定程序是否遵守某个&lt;b&gt;上下文无关&lt;/b&gt;语法。随后，类型检查判定它是否遵守某个&lt;b&gt;上下文相关&lt;/b&gt;（或者一个更丰富的）语法。简而言之，类型检查从某种程度上看是语法解析的泛化，它们都是通过&lt;b&gt;语法&lt;/b&gt;控制程序遵循指定的规则。&lt;/p&gt;&lt;h2&gt;15.2 关于类型的经典看法&lt;/h2&gt;&lt;p&gt;我们先介绍传统的包含类型的核心语言；然后我们将探索其扩展和变种。&lt;/p&gt;&lt;h2&gt;15.2.1 简单的类型检查器&lt;/h2&gt;&lt;p&gt;要定义类型检查器，我们先需要就两件事达成一致：我们静态类型&lt;b&gt;核心&lt;/b&gt;语言的语法，对应的类型的语法。&lt;/p&gt;&lt;p&gt;先回到我们之前实现过的&lt;a href=&quot;https://github.com/lotuc/PLAI-cn/blob/master/chap7.md&quot;&gt;函数作为值&lt;/a&gt;的那一版语言，其中并不包含赋值等其它稍复杂的东西（后面将讲到添加其中的一些）。我们需要为该语言添加类型注解。按惯例，我们不对常量或基本操作（如加法）强加类型注释；相反，我们把类型注释加在函数或方法的边界上。在本章讨论的过程中，我们将探讨为什么这么做。&lt;/p&gt;&lt;p&gt;鉴于此决定，我们静态类型的核心语言变成了：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define-type TyExprC
  [numC (n : number)]
  [idC (s : symbol)]
  [appC (fun : TyExprC) (arg : TyExprC)]
  [plusC (l : TyExprC) (r : TyExprC)]
  [multC (l : TyExprC) (r : TyExprC)]
  [lamC (arg : symbol) (argT : Type) (retT : Type) (body : TyExprC)])&lt;/code&gt;&lt;p&gt;每个函数都添加了其参数及返回值类型的注解。&lt;/p&gt;&lt;p&gt;现在我们需要对类型语言作出选择。我们遵从传统定义，即类型是&lt;b&gt;一组值的集合的抽象&lt;/b&gt;。我们的语言中有两类值：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define-type Value
  [numV (n : number)]
  [closV (arg : symbol) (body : TyExprC) (env : Env)])&lt;/code&gt;&lt;p&gt;因此我们有两种类型：数和函数。&lt;/p&gt;&lt;p&gt;即使数类型也并不那么简单直接：数类型应该记录何种信息？大部分语言中，实际上有&lt;b&gt;很多&lt;/b&gt;数类型，甚至没有哪个类型表示“数”。然而，我们忽略了数的层级结构（译注，第三章），对于我们来说有一种数的类型足矣。这样决定之后，我们是否需要记录&lt;b&gt;哪种&lt;/b&gt;数的信息？ 原则上可以，但这样我们很快就会遇到可判定性问题。&lt;/p&gt;&lt;p&gt;至于函数，我们有更多信息：参数的类型，返回值的类型。我们不妨记录下这些信息，除非事后证实这些信息没有用处。结合这些，我们得出这样的类型的抽象语言：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define-type Type
  [numT]
  [funT (arg : Type) (ret : Type)])&lt;/code&gt;&lt;p&gt;既然已经确定了语言中项和类型的结构，接下来我们来确定语言中哪些算是类型错误（并且，如果程序中不包含这里列出的类型错误，它就会通过类型检查）。显然有三种形式的类型错误：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;的参数不是数，即不是&lt;code class=&quot;inline&quot;&gt;numT&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt;的参数不是数。&lt;/li&gt;&lt;li&gt;函数调用时函数位置的表达式不是函数，即不是&lt;code class=&quot;inline&quot;&gt;funT&lt;/code&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;还有其它形式的类型错误吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;事实上我们遗漏了一个：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;函数调用时实参的类型和函数形参的类型不一致。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们的语言中的所有其他程序似乎都应该通过类型检查。&lt;/p&gt;&lt;p&gt;关于类型检查器的签名，初步设想，它可以接受表达式作为参数，返回布尔值指明该表达式是否通过检查。由于我们知道表达式中包含标识符，所以很显然我们还需要一个&lt;b&gt;类型环境&lt;/b&gt;，它将名字映射到类型，类似于我们之前用到的值环境。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;定义与类型环境相关的数据类型以及函数。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;于是，我们开始写下的程序结构大致是这样：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-take-1&amp;gt; ::=  ;;类型检查，第一次尝试

    (define (tc [expr : TyExprC] [tenv : TyEnv]) : boolean
      (type-case TyExprC expr
        &amp;lt;tc-take-1-numC-case&amp;gt;
        &amp;lt;tc-take-1-idC-case&amp;gt;
        &amp;lt;tc-take-1-appC-case&amp;gt;))&lt;/code&gt;&lt;p&gt;正如上面程序中列出的要处理几种情形所表明的，这种方法行不通。我们很快将知道这是为什么。&lt;/p&gt;&lt;p&gt;首先处理简单的情形：数。单独的一个数能通过类型检查吗？显然可以；它所处的上下文可能想要的不是数类型，但是这种错误应该在其它地方被检查出。因此：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-take-1-numC-case&amp;gt; ::=

    [numC (n) true]&lt;/code&gt;&lt;p&gt;下面处理标识符。如何判断标识符是否通过类型检查呢？同样，就其自身来说，如果是绑定标识符，总是通过检查的；它可能不是上下文要求的那种类型，但是这种错误应该在其它地方检查。因此，我们得出：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-take-1-idC-case&amp;gt; ::=

    [idC (n) (if (lookup n tenv)
                 true
                 (error &#39;tc &quot;not a bound identifier&quot;))]  ;不是绑定标识符&lt;/code&gt;&lt;p&gt;上面的代码你可能感觉不太对：如果标识符未绑定的话，&lt;code class=&quot;inline&quot;&gt;lookup&lt;/code&gt;会抛出异常，因此没必要再去重复处理该情况（事实上，代码永远不会执行到&lt;code class=&quot;inline&quot;&gt;error&lt;/code&gt;调用那个分支）。但是让我们先继续。&lt;/p&gt;&lt;p&gt;下面来处理函数调用。我们应该首先检查函数位置，确定它是个函数，然后确保实际参数的类型和该函数定义时声明的形式参数类型相同。例如，函数可能需要参数是数，但调用给的是个函数，或者反之，在这两种情况下，我们都需要防止错误的函数调用。&lt;/p&gt;&lt;p&gt;代码该怎么写？&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-take-1-appC-case&amp;gt; ::=

    [appC (f a) (let ([ft (tc f tenv)])
                  ...)]&lt;/code&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;tc&lt;/code&gt;的递归调用只能让我们知道函数位置是否通过类型检查。如果它通过了，怎么知道它具体是什么类型的呢？如果是个简单的函数定义的话，我们可以直接从语法上取得其参数和返回值的类型。但是如果是个复杂的表达式，我们就需要一个函数能&lt;b&gt;计算&lt;/b&gt;出表达式类型。当然，只有这个表达式是个类型正确的表达式时，该函数才能返回类型结果；否则的话它将不能得出正确的结果。换句话说，&lt;b&gt;“类型检查”是“类型计算”的一种特殊情形&lt;/b&gt;！因此，我们应该增强&lt;code class=&quot;inline&quot;&gt;tc&lt;/code&gt;的归纳不变量：即，不仅仅返回表达式是否能通过类型检查，而是返回表达式的类型。事实上，只要有返回值，就说明该表达式通过了类型检查；否则它会抛出错误。&lt;/p&gt;&lt;p&gt;下面我们来定义这个更完善的类型“检查器”。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc&amp;gt; ::=

    (define (tc [expr : TyExprC] [tenv : TyEnv]) : Type
      (type-case TyExprC expr
        &amp;lt;tc-numC-case&amp;gt;
        &amp;lt;tc-idC-case&amp;gt;
        &amp;lt;tc-plusC-case&amp;gt;
        &amp;lt;tc-multC-case&amp;gt;
        &amp;lt;tc-appC-case&amp;gt;
        &amp;lt;tc-lamC-case&amp;gt;))&lt;/code&gt;&lt;p&gt;现在填充具体实现。数很简单：它的类型就是数类型。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-numC-case&amp;gt; ::=

    [numC (n) (numT)]&lt;/code&gt;&lt;p&gt;与之相似，标识符的类型从环境中查询得到（如果其未被绑定则会抛出错误）。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-idC-case&amp;gt; ::=

    [idC (n) (lookup n tenv)]&lt;/code&gt;&lt;p&gt;到此，我们可以观察到该类型检查器与解释器之间的一些异同：对于标识符，两者做的事情其实一样（只不过这里返回的是标识符的类型而不是一个实际的值），对于数的情况，这里返回了抽象的“数”而不是具体的数。&lt;/p&gt;&lt;p&gt;下面考虑加法。必须确保其两个子表达式都具有数类型；如果满足该条件，则加法表达式本身返回的是数类型。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-plusC-case&amp;gt; ::=

    [plusC (l r) (let ([lt (tc l tenv)]
                       [rt (tc r tenv)])
                   (if (and (equal? lt (numT))
                            (equal? rt (numT)))
                       (numT)
                       (error &#39;tc &quot;+ not both numbers&quot;)))] ;+不都是数&lt;/code&gt;&lt;p&gt;通常在处理完加法的情形之后，对于乘法我们就一笔带过了，但是这里显式处理一下它还是很有教益的：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-multC-case&amp;gt; ::=

    [multC (l r) (let ([lt (tc l tenv)]
                       [rt (tc r tenv)])
                   (if (and (equal? lt (numT))
                            (equal? rt (numT)))
                       (numT)
                       (error &#39;tc &quot;* not both numbers&quot;)))] ;*不都是数&lt;/code&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;看出其中的区别了吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;是的，基本上&lt;b&gt;完全&lt;/b&gt;没区别！（仅有的区别是在&lt;code class=&quot;inline&quot;&gt;type-case&lt;/code&gt;时使用的分别&lt;code class=&quot;inline&quot;&gt;multC&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;plusC&lt;/code&gt;，以及错误提示信息稍有不同）。这是因为，从（此静态类型语言）类型检查的角度来说，加法和乘法没有区别，更甚，&lt;b&gt;任意&lt;/b&gt;接受两个数作为参数返回一个数的函数都没有区别。&lt;/p&gt;&lt;p&gt;注意到代码解释和类型检查之间另一个不同点。它们的参数都得是数。解释器返回加或者乘它们得到的确切数值，但是类型检查器并不在乎具体的数值：因此该表达式的计算结果（&lt;code class=&quot;inline&quot;&gt;(numT)&lt;/code&gt;）是个常数，两种情形返回都是该常数。&lt;/p&gt;&lt;p&gt;最后还剩下两个难一点的情形：函数调用和函数。我们已经讨论过怎么处理函数调用：计算函数以及参数表达式的值；确保函数表达式为函数类型；检查参数类型和函数形参类型相容。如果这些条件满足，函数调用得到的结果类型就是函数体的类型（因为运行时最终的返回值就是计算函数体得到的值）。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-appC-case&amp;gt; ::=

    [appC (f a) (let ([ft (tc f tenv)]
                      [at (tc a tenv)])
                  (cond
                    [(not (funT? ft))
                     (error &#39;tc &quot;not a function&quot;)] ;不是函数
                    [(not (equal? (funT-arg ft) at))
                     (error &#39;tc &quot;app arg mismatch&quot;)] ;app参数不匹配
                    [else (funT-ret ft)]))]&lt;/code&gt;&lt;p&gt;最后还剩下函数定义。函数有一个形参，函数体中一般会用到；除非它被绑定到环境中，不然函数体应该不太可能通过类型检查。因此我们需要扩展类型环境，添加形参与其类型的绑定，然后在扩展后的环境中检查函数体。最终计算得到的函数体类型必须和函数定义中指定的函数返回值类型相同。如果满足了这些，该函数的类型就是指定参数类型到函数体类型的函数。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;上面说的“不太可能通过类型检查”是什么意思？&lt;br&gt;&lt;/blockquote&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-lamC-case&amp;gt; ::=

    [lamC (a argT retT b)
          (if (equal? (tc b (extend-ty-env (bind a argT) tenv)) retT)
              (funT argT retT)
              (error &#39;tc &quot;lam type mismatch&quot;))] ;λ类型不匹配&lt;/code&gt;&lt;p&gt;注意到解释器与类型检查器另一个有趣的不同点。解释器中，函数调用负责计算参数表达式的值，扩展环境，然后对函数体求值。而这里，函数调用的情形中的确也检查了参数表达式，但是没有涉及到环境的处理，直接返回了函数体的类型，而&lt;b&gt;没有遍历它&lt;/b&gt;。对函数体的遍历检查过程实际是在检查函数&lt;b&gt;定义&lt;/b&gt;的过程中进行的，因此环境也是在这个地方才实际被扩展的。&lt;/p&gt;&lt;h2&gt;15.2.2 条件语句的类型检查&lt;/h2&gt;&lt;p&gt;考虑为上面的语言添加条件语句，即使最简单的 if 表达式都会引入若干设计抉择。这里我们先讨论其中的两个，后面会回过头讨论其中的一个。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;条件表达式的类型应该是什么？某些语言中它必须计算得到布尔值，这种情况下需要为我们的语言添加布尔值类型（这可能是个好主意）。其它语言中，它可以是任意值，某些值被认为是“真值”，其它的则被视为“假值”。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;then-&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;else-&lt;/code&gt;两个分支之间的关系应该是什么呢？一些语言中它们的类型必须相同，因此整个 if 表达式有一个确定无歧义的类型。其它语言中，两个分支可以有不同的类型，这极大地改变了静态类型语言的设计和它的类型检查器，而且也改变了编程语言本身的性质。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;为该静态类型语言添加布尔值。至少需要添加些啥？在典型的语言中还需要加什么？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;为条件语句添加类型规则，其中条件表达式应该计算得到布尔值，且&lt;code class=&quot;inline&quot;&gt;then-&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;else-&lt;/code&gt;分支必须有相同的类型，同时该类型也是整个条件语句的类型。&lt;/blockquote&gt;&lt;h2&gt;15.2.3 代码中的递归&lt;/h2&gt;&lt;p&gt;现在我们已经得到了基本的编程语言，下面为其添加递归。之前我们实现过递归，可以很容易的通过去语法糖实现。这里的情况要更复杂一些。&lt;/p&gt;&lt;h2&gt;15.2.3.1 递归的类型，初次尝试&lt;/h2&gt;&lt;p&gt;首先尝试表示一个简单的递归函数。最简单的当然就是无限循环。我们可以仅使用函数实现无限循环吗？可以：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;((lambda (x) (x x))
 (lambda (x) (x x)))&lt;/code&gt;&lt;p&gt;因为我们的语言中已经支持将函数作为值。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;为什么这会构成无限循环？它是如何巧妙地依赖于函数调用的本质的？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;现在我们的静态类型语言要求我们为所有函数添加类型注解。我们来为该函数添加类型注解。简单起见，假设从现在开始我们写的程序使用的语法是静态类型的表层语法，去语法糖将帮我们将其转换为核心语言。&lt;/p&gt;&lt;p&gt;首先注意到，我们有两个完全一样的表达式，它们互相调用。历史原因，整个表达式被称为Ω（希腊字母大写欧米茄），那两个一样的子表达式被称为ω（希腊字母小写欧米茄）。两个一样的表达式并非得是同种类型的，因为这还依赖于具体使用环境中对于不变量的定义。这个例子中，观察到 x 被绑定到ω，于是ω将出现在在&lt;code class=&quot;inline&quot;&gt;(x x)&lt;/code&gt;式子的第一个和第二个部分。即，确定其中一个表达式的类型，另一个式子的类型也被确定。&lt;/p&gt;&lt;p&gt;那么我们就来尝试计算ω的类型；称该类型为γ。显然它是一个函数类型，而且是单参数的函数，所以它的类型必然是&lt;code class=&quot;inline&quot;&gt;φ -&amp;gt; ψ&lt;/code&gt;这种形式的。该函数的参数是什么类型？就是ω的类型。也即，传入φ的值的类型就是γ。因此，ω的类型是γ，也即&lt;code class=&quot;inline&quot;&gt;φ -&amp;gt; ψ&lt;/code&gt;，展开即&lt;code class=&quot;inline&quot;&gt;(φ -&amp;gt; ψ) -&amp;gt; ψ&lt;/code&gt;，进一步展开得&lt;code class=&quot;inline&quot;&gt;((φ -&amp;gt; ψ) -&amp;gt; ψ) -&amp;gt; ψ&lt;/code&gt;，还可以继续下去。也就是说，该类型不能用有限的字符串写出来！&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;你注意到了我们刚做的的微妙但重要的跳跃吗？&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;15.2.3.2 程序终止&lt;/h2&gt;&lt;p&gt;我们观察到，试图直接地计算Ω的类型，需要先计算γ的类型，这似乎导致了严重的问题。然后我们就得出结论：此类型不能用有限长度的字符串表示，但是这只是直觉的结果，并非证明。更奇怪的事实是：在我们迄今定义的类型系统中，&lt;b&gt;根本无法给出Ω的类型&lt;/b&gt;！&lt;/p&gt;&lt;p&gt;这是一个很强的表述，但事实上我们可以给出更强的描述。我们目前所用的&lt;b&gt;静态类型&lt;/b&gt;语言有一个属性，称为&lt;b&gt;强归一化&lt;/b&gt;（strong normalization）：任何有类型的表达式都会在有限步骤后终止计算。换句话，这个特殊的（奇特的）无限循环程序并不是唯一不可获得类型的程序；&lt;b&gt;任何&lt;/b&gt;无限循环（或潜在存在无限循环）程序都无法求得类型。一个简单的直觉说明可以帮助我们理解，任何类型——必须能被有限长度的字符串表示——只能包含有限个&lt;code class=&quot;inline&quot;&gt;-&amp;gt;&lt;/code&gt;，每次调用会去除一个&lt;code class=&quot;inline&quot;&gt;-&amp;gt;&lt;/code&gt;，因此我们只能进行有限次数的函数调用。&lt;/p&gt;&lt;p&gt;如果我们的程序只允许非转移程序（&lt;a href=&quot;https://en.wikipedia.org/wiki/Straight-line_program&quot;&gt;straight-line program&lt;/a&gt;），这点也无足为奇。但是，我们有条件语句，还有可以当做值任意传递的函数，通过这些我们可以编码得到任何我们想要的数据结构。然而我们仍能得到这个保证！这使得这个结果令人吃惊。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;试着使用函数分别在动态类型和静态类型语言中编码实现列表。你看到了什么？这说明此类型系统对于编码产生了何种影响？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;这个结果展示了某种更深层次的东西。它表明，和你可能相信的——类型系统只是用来避免一些程序 BUG 在运行时才被发现——相反，类型系统可能&lt;b&gt;改变语言的语义&lt;/b&gt;。之前我们一两行就能写出无限循环，现在我们怎么都写不出来。这也表明，类型系统不仅可以建立关于某个特定程序的不变量，还能建立&lt;b&gt;关于语言本身的&lt;/b&gt;不变量。如果我们非常需要确保某个程序将会终止，只要用该语言来写然后交由类型检查器检查通过即可。&lt;/p&gt;&lt;p&gt;一门语言，用其书写的所有程序都将终止，有什么用处？对于通用编程来说，当然没用。但是在很多特殊领域，这是非常有用的保证。例如，你要实现一个复杂的调度算法；你希望知道调度程序保证会终止，以便那些被调度的任务被执行。还有许多其他领域，我们将从这样的保证中受益：路由器中的数据包过滤器；实时事件处理器；设备初始化程序；配置文件；单线程&lt;br&gt; JavaScript 中的回调；甚至编译器或链接器。每种情况下，我们都有一个不成文的期望，即这些程序最终会终止。而现在我们有一个语言能保证这点——且这点是不可测试的。&lt;/p&gt;&lt;blockquote&gt;这不是假想的例子。在Standard ML语言中，链接模块基本上就是使用这种静态类型语言来编写模块链接规范。这意味着开发人员可以编写相当复杂的抽象概念——毕竟可以将函数作为值使用——且同时链接过程被保证会终止，产生最终的程序。&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;15.2.3.3 静态类型的递归&lt;/h2&gt;&lt;p&gt;这就意味着，之前我们可以只通过去语法糖来实现&lt;code class=&quot;inline&quot;&gt;rec&lt;/code&gt;，现在则必须在我们的静态类型语言中显式的实现。简单起见，我们仅考虑&lt;code class=&quot;inline&quot;&gt;rec&lt;/code&gt;的一种特殊形式——它涵盖了常见用法，即递归标识符被绑定到函数。因此，表层语法中，我们可能写出如下的累加函数：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(rec (Σ num (n num)
        (if0 n
             0
             (n + (Σ (n + -1))))) ;译注，原文如此，+应前置
  (Σ 10))&lt;/code&gt;&lt;p&gt;其中，&lt;code class=&quot;inline&quot;&gt;Σ&lt;/code&gt;是函数名，&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;为其参数，&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;为函数参数以及返回值的类型。表达式&lt;code class=&quot;inline&quot;&gt;(Σ 10)&lt;/code&gt;表示使用该函数计算从 10 累加到 0 的和。&lt;/p&gt;&lt;p&gt;如何计算这个表达式的类型？显然，求类型过程中，&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;在函数体中的类型需要绑定（但是在函数调用处就不需要了）；这一点计算函数类型的时候我们就知道了。那么&lt;code class=&quot;inline&quot;&gt;Σ&lt;/code&gt;呢？显然，在检查&lt;code class=&quot;inline&quot;&gt;(Σ 10)&lt;/code&gt;的类型时，它应该在类型环境中被绑定，类型必须为&lt;code class=&quot;inline&quot;&gt;num -&amp;gt; num&lt;/code&gt;。不过，在检查函数体时，它&lt;b&gt;同样&lt;/b&gt;需要被绑定到此类型。（还要注意，函数体返回值的类型需要和事先声明的返回类型相同。）&lt;/p&gt;&lt;p&gt;现在我们可以看到如何打破类型有限性的束缚。程序代码中，我们只能编写包含有限数量&lt;code class=&quot;inline&quot;&gt;-&amp;gt;&lt;/code&gt;的类型。但是，这种递归类型的规则在函数体中引用自身时复制了&lt;code class=&quot;inline&quot;&gt;-&amp;gt;&lt;/code&gt;，从而供应了无穷的函数调用。这是包含无穷箭矢的箭筒。&lt;/p&gt;&lt;p&gt;实现这种规则的代码如下。假设&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;被绑定到函数的名字，&lt;code class=&quot;inline&quot;&gt;aT&lt;/code&gt;是函数参数的类型，&lt;code class=&quot;inline&quot;&gt;rT&lt;/code&gt;为返回类型，&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;是函数体，&lt;code class=&quot;inline&quot;&gt;u&lt;/code&gt;是函数的使用：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-lamC-case&amp;gt; ::=

    [recC (f a aT rT b u)
          (let ([extended-env
                 (extend-ty-env (bind f (funT aT rT)) tenv)])
            (cond
              [(not (equal? rT (tc b
                                   (extend-ty-env
                                    (bind a aT)
                                    extended-env))))
               (error &#39;tc &quot;body return type not correct&quot;)] ;函数体类型错误
              [else (tc u extended-env)]))]&lt;/code&gt;&lt;h2&gt;15.2.4 数据中的递归&lt;/h2&gt;&lt;p&gt;我们已经见识了静态类型的递归程序，但是它还不能使我们创建递归的数据。我们已经有一种递归数据——函数类型——但是这是内建的。现在还没看到如何创建自定义的递归数据类型。&lt;/p&gt;&lt;h2&gt;15.2.4.1 递归数据类型定义&lt;/h2&gt;&lt;p&gt;当我们说允许程序员创建递归数据时，我们实际在同时谈论三种东西：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;创建新的类型&lt;/li&gt;&lt;li&gt;让新类型的实例拥有一个或多个字段&lt;/li&gt;&lt;li&gt;让这些字段中的某些指向同类型的实例&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;实际上，一旦我们允许了第三点，我们就必须再允许一点：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;允许该类型中非递归的基本情况的存在&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这些设计准则的组合产生了通常被称为&lt;b&gt;代数数据类型&lt;/b&gt;（algebraic datatype）的东西，比如我们的静态语言中支持的类型。举个例子，考虑下面这个数二叉树的定义：【注释】&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define-type BTnum
  [BTmt]
  [BTnd (n : number) (l : BTnum) (r : BTnum)])&lt;/code&gt;&lt;blockquote&gt;后面我们会讨论如何参数化类型。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;请注意，如果这个新的数据类型没有名字，&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;，我们将不能在&lt;code class=&quot;inline&quot;&gt;BTnd&lt;/code&gt;中引用回该类型。同样地，如果只允许定义一种&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;构造，那么就无法定义 &lt;code class=&quot;inline&quot;&gt;BTmt&lt;/code&gt;，这会导致递归无法终止。当然，最后我们需要多个字段（如&lt;code class=&quot;inline&quot;&gt;BTnd&lt;/code&gt;中的一样）来构造有用、有趣的数据。换句话说，所有这三种机制被打包在一起，因为它们结合在一起才最有用。（但是，有些语言确实允许定义独立结构体。后文我们将回来讨论这个设计决策对类型系统的影响）。&lt;/p&gt;&lt;p&gt;我们关于递归表示的初步讨论暂告一个段落，但这里有个严重的问题。我们并没有真正解释这个新的数据类型&lt;code class=&quot;inline&quot;&gt;BTum&lt;/code&gt;的来源。因为我们不得不假装它已经在我们的类型检查器中实现了。然而，为每个新的递归类型改变我们的类型检查器有点不切实际——这就好比需要为每个新出现的递归函数去修改解释器！相反，我们需要找到一种方法，使得这种定义成为静态类型语言的固有能力。后面我们会回来讨论这个问题。&lt;/p&gt;&lt;p&gt;这种风格的数据定义有时也被称为&lt;b&gt;乘积的和&lt;/b&gt;，“乘”指代字段组合成不变量的方式：例如，&lt;code class=&quot;inline&quot;&gt;BTnd&lt;/code&gt;的合法值是传递给&lt;code class=&quot;inline&quot;&gt;BTnd&lt;/code&gt;构造器的每个字段合法值的叉乘。“和”是所有这些不变量的总数：任何给定的&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;值是其中之一。（将“乘”想作“且”，“加”想作“或”。）&lt;/p&gt;&lt;h2&gt;15.2.4.2 自定义类型&lt;/h2&gt;&lt;p&gt;想一想，数据结构的定义会产生哪些影响？首先，它引入了新的类型；其次它基于此类型定义若干构造器、谓词和选择器。例如，在上面的例子中，首先引入 &lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;，然后使用它创建以下类型：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;BTmt : -&amp;gt; BTnum
BTnd : number * BTnum * BTnum -&amp;gt; BTnum
BTmt? : BTnum -&amp;gt; boolean
BTnd? : BTnum -&amp;gt; boolean
BTnd-n : BTnum -&amp;gt; number
BTnd-l : BTnum -&amp;gt; BTnum
BTnd-r : BTnum -&amp;gt; BTnum&lt;/code&gt;&lt;p&gt;观察几个显著的事实：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;这里的构造器创建&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;的实例，而不是更具体的东西。稍后我们将讨论这个设计抉择。&lt;/li&gt;&lt;li&gt;这里的谓词函数都接受&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;类型参数，而不是“Any”（任意值）。这是因为类型系统已经可以告诉我们某个值的类型是什么，因此我们只需要区分该类型的不同形式。&lt;/li&gt;&lt;li&gt;选择器只能作用于类型中相关形式的实例——例如，&lt;code class=&quot;inline&quot;&gt;BTnd-n&lt;/code&gt;只对&lt;code class=&quot;inline&quot;&gt;BTnd&lt;/code&gt;的实例有效，对&lt;code class=&quot;inline&quot;&gt;BTmt&lt;/code&gt;的实例则不行——但是由于缺乏合适的静态类型，我们无法在静态类型系统中表示这点。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;递归类型中还有很多值得讨论的东西，我们不久将回到这个话题。&lt;/p&gt;&lt;h2&gt;15.2.4.3 模式匹配和去语法糖&lt;/h2&gt;&lt;p&gt;类型定义的讨论告一段落，剩下要提供的功能就是模式匹配。例如，我们可以这样写：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(type-case BTnum t
    [BTnum () e1]
    [BTnd (nv lt rt) e2])&lt;/code&gt;&lt;p&gt;我们知道，这可以用前述的函数来实现。用 let 就可以模拟此模式匹配所实现的绑定：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(cond
    [(BTmt? t) e1]
    [(BTnd? t) (let ([nv (BTnd-n t)]
                     [lt (BTnd-l t)]
                     [rt (BTnd-r t)]
                 e2)])&lt;/code&gt;&lt;p&gt;总之，它可以通过宏实现，所以模式匹配不需要被添加到核心语言中，直接用去语法糖即可实现。这也意味着一门语言可以有很多不同的模式匹配机制。&lt;/p&gt;&lt;p&gt;不过，这不完全正确。生成上面代码中的&lt;code class=&quot;inline&quot;&gt;cond&lt;/code&gt;表达式时，宏需要通过某种手段知道&lt;code class=&quot;inline&quot;&gt;BTnd&lt;/code&gt;的三个位置选择器分别是&lt;code class=&quot;inline&quot;&gt;BTnd-n&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;BTnd-l&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;BTnd-r&lt;/code&gt;。这些信息在类型定义时显式给出，但是在模式匹配时是隐含的（划重点）。因此，这些信息必须要从类型定义处传过来。因此宏扩展器需要使用类似类型环境的东西完成其任务。&lt;/p&gt;&lt;p&gt;此外，还要注意，例如&lt;code class=&quot;inline&quot;&gt;e1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;e2&lt;/code&gt;这样的表达式无法类型检查——事实上，甚至不能被可靠地识别为表达式——直到宏扩展器完成了&lt;code class=&quot;inline&quot;&gt;type-case&lt;/code&gt;的扩展之后。因此，扩展依赖于类型环境，而类型检查依赖于扩展的结果。换句话说这两者是共生关系，不仅仅是并行运行，而是同步运行。因此，静态类型语言中进行去语法糖操作时，如果语法糖需要对相关类型作出推测，要比动态类型语言中更复杂一些。&lt;/p&gt;&lt;h2&gt;15.2.5 类型、时间和空间&lt;/h2&gt;&lt;p&gt;明显，类型已经赋予了类型安全语言一些性能优势。因为一些本来需要运行时执行的检查（例如，检查加法的两个参数的确是数）现在是静态执行的。在静态类型语言中，类似&lt;code class=&quot;inline&quot;&gt;:number&lt;/code&gt;的注解已经回答了关于某个值是否是特定类型这种问题；无需在运行时再去检查。因此，类型级别的谓词以及程序中对它们的使用将会（并且需要）完全消失。&lt;/p&gt;&lt;p&gt;对于开发者来说这需要付出一些代价，他们必须说服静态类型系统他们的程序不会导致类型错误；由于可判定性的限制，有些可以正确运行的程序也可能与类型系统冲突。不过，类型系统为满足了它要求的程序提供了可观的运行时性能优势。&lt;/p&gt;&lt;p&gt;接下来我们来讨论空间。到目前为止，语言的运行时系统需要对每个值附加存储其类型信息。这也是其实现类型级别谓词如 &lt;code class=&quot;inline&quot;&gt;number?&lt;/code&gt; 的基础，这些谓词既可被开发人员使用也可被语言内部使用。如果不需要这些谓词，那么这些为了实现它们而存储的信息所占据的空间也将不再需要。因此（静态语言）不需要类型标签。&lt;/p&gt;&lt;blockquote&gt;然而，垃圾回收器仍然需要它们，但其他表示法（如BIBOP(译注BIg Bag Of Pages)）能极大减少它们对空间的需求。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;类型变体相关的谓词仍要保留：如上面例子中的&lt;code class=&quot;inline&quot;&gt;BTmt?&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;BTnd?&lt;/code&gt;。它们的调用需要在运行时求值。例如，如前所述，选择器&lt;code class=&quot;inline&quot;&gt;BTnd-n&lt;/code&gt;就需要执行这种检查。当然，进一步的优化是可能的。考虑模式匹配去语法糖后生成的代码：其中的三个选择器就无需执行这些检查，因为只有&lt;code class=&quot;inline&quot;&gt;BTnd?&lt;/code&gt;返回真值时才会执行对应代码片。因此，运行时系统可以给去语法糖层面提供特殊的&lt;b&gt;不安全&lt;/b&gt;（unsafe）指令，也就是不执行类型检查的版本，从而生成如下所示的代码：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(cond
  [(BTmt? t) e1]
  [(BTnd? t) (let ([nv (BTnd-n/no-check t)]
                   [lt (BTnd-l/no-check t)]
                   [rt (BTnd-r/no-check t)])
               e2)])&lt;/code&gt;&lt;p&gt;但最终的结果是，运行时系统仍然需要存储足够的信息来准确回答这些问题。不过，相比于之前需要使用足够的位来区分每种类型及类型变体，现在，由于类型被静态地隔离了，对于没有变体的类型（例如，只有一种类型的字符串），不再需要存储任何变体相关的信息；这意味着运行时系统可以使用所有可用位来存储实际的动态值。&lt;/p&gt;&lt;p&gt;与之相对，如果类型存在变体，运行时系统需要牺牲一些空间用于区分不同变体，不过一个类型中变体的数量显然比&lt;b&gt;所有类型&lt;/b&gt;和其变体的数量要小得多。在上面的例子中，&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;只有两个变体，因此运行时系统只需要使用一个比特来记录某个值是&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;的哪个变体。&lt;/p&gt;&lt;p&gt;特别要注意的是，类型体系的隔离可以防止混淆。如果有两种不同的数据类型，每种都有两种变体，在动态类型的世界中，所有这四种变体都需要有不同的表示法；与之相对，在静态类型的世界中，这些表示法可以跨类型重叠，因为静态类型系统会保证一种类型中的变体和另一种类型中的不被混淆。因此，类型系统对于程序的空间（节约表示所需空间）和时间（消除运行时检查）上都有实打实的性能提升。&lt;/p&gt;&lt;h2&gt;15.2.6 类型和赋值&lt;/h2&gt;&lt;p&gt;我们已经覆盖了核心语言中除赋值之外的大部分基本特性。从某些方面看，类型和赋值之间的相互作用很简单，这是因为在经典环境中，它们根本不相互作用。例如，考虑下面动态类型程序：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(let ([x 10])
  (begin
    (set! x 5)
    (set! x &quot;某物&quot;)))&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的“类型”是什么？它并没有确定的类型，它在一段时间内是数，&lt;b&gt;后来&lt;/b&gt;（注意里面蕴含时间意味）是字符串。我们根本无法给它定类型。一般来说，类型检查是种&lt;b&gt;非时间性的&lt;/b&gt;活动：它只在程序运行之前执行一次，因此必须独立于程序执行的特定顺序。因此，跟踪贮存中的精确值超出了类型检查程序的能力范围。&lt;/p&gt;&lt;p&gt;上面的例子当然可以简单的静态的被理解，不过我们不能被简单的例子误导。考虑下面的程序：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(let ([x 10])
  (if (even? (read-number &quot;输入数字&quot;))
      (set! x 5)
      (set! x &quot;某物&quot;)))&lt;/code&gt;&lt;p&gt;现在，静态检查不可能得到关于&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型的结论，因为只有在运行时我们才能获得用户输入的值。&lt;/p&gt;&lt;p&gt;为了避免这种情况，传统的类型检查器采用了一个简单策略：赋值过程中类型必须&lt;b&gt;保持不变&lt;/b&gt;。也就是说，赋值操作，不论是变量赋值还是结构体赋值，都不能改变被赋值的量的类型。因此，上面的代码在我们当前的语言中将不能通过类型检查。给程序员提供多少灵活性就取决与语言了。例如，如果我们引入更加灵活的类型表示“数或字符串”，上面的例子将能通过类型检查，但是&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型就永远不那么精确，所有使用&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的地方都需要处理这种降低了的精度，后面我们会回到这个问题。&lt;/p&gt;&lt;p&gt;简而言之，在传统的类型系统中赋值相对容易处理，因为它采用了简单的规则，值可以在类型系统指定的限度下进行改变，但是类型不能被改变。在像&lt;code class=&quot;inline&quot;&gt;set!&lt;/code&gt;这种操作的情况下（或者我们的核心语言中的&lt;code class=&quot;inline&quot;&gt;setC&lt;/code&gt;），这意味着赋值的类型必须和变量的类型匹配。在结构体赋值的情况下，例如&lt;code class=&quot;inline&quot;&gt;box&lt;/code&gt;，这意味着赋值的类型必须和&lt;code class=&quot;inline&quot;&gt;box&lt;/code&gt;容器内容的类型匹配。&lt;/p&gt;&lt;h2&gt;15.2.7 中心定理：类型的可靠性&lt;/h2&gt;&lt;p&gt;之前我们说过，一些静态类型语言可以为其书写的程序所能达成某些特性作出很坚实的证明：例如，该语言书写的程序肯定会终止。当然，一般来说，我们无法获得这样的保证（事实上，正是为了能写出无限循环我们才添加的通用递归）。然而，一个有意义的类型系统——事实上，任何值得&lt;b&gt;类型系统&lt;/b&gt;这一高贵头衔的东西【注释】——应该为所有静态类型程序提供某种有意义的保证。这是给程序员的回报：通过给程序加上类型，她可以确保某些不好的事情不会发生。没有类型的话，我们也能找到bug；这是有用的，但它不足以提供构建高级别工具（例如要保证安全性、隐私性或健壮性）的必要基础。&lt;/p&gt;&lt;blockquote&gt;我们一再使用“类型系统”这个术语。类型系统通常是三个组件的组合：类型的语言、类型规则，以及将这些规则应用于程序的算法。我们的讨论中将类型规则放入函数中，因此模糊了第二者和第三者之间的区别，但它们仍然可以在逻辑上加以区分。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;我们可能希望类型系统给我们提供什么样的保证呢？请记住，类型检查器在程序运行前静态地对程序进行检查。这意味着它本质上是对程序行为的&lt;b&gt;预测&lt;/b&gt;：例如，当它指出某个复杂表达式的类型为&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;，它实际是在预测程序运行时，该表达式将产生一个数值。我们怎么知道这个预测是正确的呢，也就是说检查器从不撒谎？每种类型系统都应该附带一个证明这一点的定理。&lt;/p&gt;&lt;p&gt;对于类型系统存疑有一个很好的理由，不是怀疑主义的那种。类型检查器和程序求值器工作方式上有很多不同：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;类型检查器能见到的只有程序文本，求值器运行在真实的存储器上。&lt;/li&gt;&lt;li&gt;类型环境将标识符绑定到类型，求值器的环境则绑定标识符到值或者存储位置。&lt;/li&gt;&lt;li&gt;类型检查器将值的集合（甚至是无限集合）压缩成类型，而求值器处理的是值本身。&lt;/li&gt;&lt;li&gt;类型检查器一定会终止，求值器不一定会。&lt;/li&gt;&lt;li&gt;类型检查器仅需检查表达式一遍，求值器运行时某个表达式的运行次数可能从零次到无穷次。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因此，我们不应假设这两者将始终对应！&lt;/p&gt;&lt;p&gt;对于给定的类型系统，我们希望达到的核心目标是——该类型系统是&lt;b&gt;可靠的&lt;/b&gt;（sound）。它的意思是：给定表达式（或者程序）&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;，类型检查得出其类型为&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;，当我们运行&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;时，假设得到了值&lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt;，那么&lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt;的类型是&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;证明这个定理的标准方法是分两步进行，&lt;b&gt;进展&lt;/b&gt;（progress）和&lt;b&gt;保持&lt;/b&gt;（preservation）。进展的意思是，如果一个表达式能够通过类型检查，那么它应该能进行进一步求值得到新的东西（除非它本身就是值）；保持的意思是，这个求值步骤前后类型不变。如果我们交错进行这些步骤（先进展再保持，不断重复），可以得出一个结论，最终的结果和最初被求值的表达式类型相同，因此类型系统确实是可靠的。&lt;/p&gt;&lt;p&gt;例如，考虑表达式：&lt;code class=&quot;inline&quot;&gt;(+ 5 (* 2 3))&lt;/code&gt;。它的类型为&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;。在一个可靠的类型系统中，进展证明，由于该表达式能通过类型检查，且其当前不是值，它可以进行一步求值——这里它显然可以。进行一步求值之后，它被规约成了&lt;code class=&quot;inline&quot;&gt;(+ 5 6)&lt;/code&gt;。不出所料，正如保持给出的证明，它的类型也为&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;。进展表明它还能进行一步求值，得到&lt;code class=&quot;inline&quot;&gt;11&lt;/code&gt;。保持再次表明它的类型和上一步的表达式类型相同，都为&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;。现在，进展发现我们已经得到最终结果，无后续要进行的求值步骤，该值的类型和最初的表达式类型相同。&lt;/p&gt;&lt;p&gt;但这不是完整的故事。有两点需要说明：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;程序可能不会得出最终的结果，它可能永远循环。这种情况下，该定理严格来说并不适用。但是我们仍能看到，计算得到的中间表达式类型将一直保持不变，因此即使程序没有最终产生一个值，它仍在进行着有意义的计算。&lt;/li&gt;&lt;li&gt;任何特性足够丰富的语言中都存在一些不能静态决定的属性（有些属性也许本来可以，但是语言的设计者决定将其推迟到运行时决定）。当这类属性出错时——比如，数组的索引越界——关于这种程序没有很好的类型可以约束它们。因此，每个类型完备性定理中都隐含了一组已发布的、允许的异常或者可能发生的错误条件。使用该类型系统的开发者隐式的接受了这些条件。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;作为第二点的一个例子，典型的静态类型语言中，都会指明对于向量的寻址、列表的索引等操作可能抛出异常。&lt;/p&gt;&lt;p&gt;后面这个说明好像站不住脚。事实上，我们很容易忘记这其实是一条关于运行时&lt;b&gt;不能&lt;/b&gt;发生的事情的陈述：这一组异常之外的异常将能被证明不会产生。当然，对最开始就设计为静态类型的语言，除了不那么严格的类比外，可能搞不清这组异常具体是什么，因为一开始本就无须定义它们。但是当我们将类型系统添加到已有的语言时——特别是动态类型语言，如Racket或Python——那么这里已经有一组明确定义的异常，类型检查器将会指明其中一些异常（像“函数调用位置不是函数”或者“未找到方法”）不会发生。这就是程序员接纳类型系统语法上限制所得到的回报。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>MrMathematica</author>
<guid isPermaLink="false">2018-02-18-33865846</guid>
<pubDate>Sun, 18 Feb 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>持久化数据结构学习笔记——序列</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-02-18-33859991.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33859991&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-097294ad42f4c76aa3bebf30e8ba09f7_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;本学期正在修读一门数据结构课程，内容是持久化数据结构（Persistent Data Structures）。我感到这门课的内容十分有趣，希望可以写一些笔记记录一下学习过程。笔记的内容将会围绕课程展开，但是其中主要是我自己的一些思考得出的“私货”。&lt;/p&gt;&lt;p&gt;我们日常接触到的数据结构多是可变的（mutable），这意味着对于一个数据结构的更新将会破坏其过去的版本。与之相对应的，持久化数据结构在更新时会创建一个“新”的数据结构，从而与此同时保证对旧有版本的访问与修改。持久化数据结构可以带来许多好处，比如异常安全（Exception Safety）和并发性（Concurrency）。但是，这并不意味着我们必须为此付出很大的代价。实际上，许多持久化数据结构在实现上会更加自然直观，也可以保持很高的效率。&lt;/p&gt;&lt;p&gt;持久化数据结构与不可变性（Immutability）有一些相关性。我们往往会利用不可变性来实现高效率的持久化数据结构。不可变性保证了同一数据结构的不同版本可以共享相同的部分，从而节省达到节省空间的目的。&lt;/p&gt;&lt;p&gt;让我们从最简单的例子开始。&lt;/p&gt;&lt;h2&gt;序列&lt;/h2&gt;&lt;p&gt;序列（Sequence）是一种抽象数据类型（Abstract Data Type）。它由四个函数定义：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;emtpy&lt;/code&gt; 返回一个空序列&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt; 作用在一个序列上，返回其第一个元素&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt; 作用在一个序列上，返回除去其首元素以后的新序列&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; 作用在一个元素和一个序列上，返回一个新的序列，使得 &lt;code class=&quot;inline&quot;&gt;first (cons h t) = h&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;rest (cons h t) = t&lt;/code&gt; 成立&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在OCaml中，上述定义表达如下&lt;/p&gt;&lt;code lang=&quot;ocaml&quot;&gt;module type sequence = sig
    type &#39;a sequence
    val empty : &#39;a sequence
    val first : &#39;a sequence -&amp;gt; &#39;a option
    val rest : &#39;a sequence -&amp;gt; &#39;a sequence option
    val cons : &#39;a -&amp;gt; &#39;a sequence -&amp;gt; &#39;a sequence 
end&lt;/code&gt;&lt;p&gt;在函数式语言中常见的列表（List）就是一个符合本定义的数据结构。值得注意的是列表就是一个持久化数据结构的简单例子。列表是非常高效的，上述函数的时间复杂度均为&lt;equation&gt;O(1)&lt;/equation&gt; ，同时其不可变性保证了高效的内存利用与持久性。&lt;/p&gt;&lt;p&gt;但是，如果我们并不需要频繁使用以上操作，而希望我们的序列有相对高效的随机访问呢？我们在之前的序列定义中添加一个新的接口 &lt;code class=&quot;inline&quot;&gt;index : int -&amp;gt; &#39;a sequence -&amp;gt; &#39;a option&lt;/code&gt; ，作用在一个整数和一个序列上，返回其对应位置的元素。符合我们要求的新的实现可以有相对较慢的 &lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; ，但是需要有比&lt;equation&gt;O(n)&lt;/equation&gt; 更快的 &lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 。一个自然的想法是使用树状的结构代替线性结构提高访问效率。&lt;/p&gt;&lt;h2&gt;第一个尝试&lt;/h2&gt;&lt;p&gt;我们选择使用二叉树来存储（编码？encode?）一个序列结构，这要求我们在序列的位置和二叉树的中存储元素的位置之间建立一个双射。一个比较显而易见的做法是选取一棵深度为&lt;equation&gt;k&lt;/equation&gt; 的满二叉树，用他的所有叶子结点来存储数据。叶子结点从左向右分别标注为 &lt;equation&gt;0&lt;/equation&gt; 至 &lt;equation&gt;2^{k-1}-1&lt;/equation&gt; 。这样我们建立了这棵树的叶子结点和序列中的位置的一一对应。并不令人意外的是，这种对应关系实际上就是 &lt;equation&gt;0&lt;/equation&gt; 至 &lt;equation&gt;2^n-1&lt;/equation&gt; 的自然数的 &lt;equation&gt;n&lt;/equation&gt; 位二进制（高位补全 &lt;equation&gt;0&lt;/equation&gt; ）表示。这一关系给出了一个查找我们的二叉树中的元素的方法：将序列中的位置转换成二进制表示，补齐高位的零，然后从二叉树的根节点开始，按照二进制表示的从高位到低位，逢0向左逢1向右，直至达到叶子结点。&lt;/p&gt;&lt;p&gt;以上思路给出了一个看似可能的实现。但是，这一次尝试中我们只使用了二叉树的叶子结点，造成了空间的浪费。这一点并没有真的影响到我们的实现的空间复杂度。但是，它暴露出了一件更重要的事情：我们的思路引入了不必要的信息，而这是不自然的。&lt;/p&gt;&lt;h2&gt;解决方法&lt;/h2&gt;&lt;p&gt;让我们试着分析一下这件事的原因是什么。我们为了让自然数和它的二进制表示是一一对应，必须限定二进制表示的位数，同时对位数不足的二进制表示补全高位的0。这种关系是我们人为限定的，而我们引入的冗余信息就是对二进制表示的位数的限定，与之相对应的，就是我们只使用了二叉树的叶子结点，而空置了其余节点。那么，解决这个问题的思路似乎明朗了。我们需要找寻一种自然数的表示，它必须是base-2的（只使用两种符号，与二叉树的结构对应），使得他是一种同构计数（Bijective Numeration）。换句话说，我们需要的表示是一个由两种字符 &lt;equation&gt;\{a,b\}&lt;/equation&gt; 构成的任意长度的字符串。我们需要做的就是赋予这些字符串组成的集合 &lt;equation&gt;\{a,b\}^*&lt;/equation&gt; 一个到自然数集的双射。&lt;/p&gt;&lt;p&gt;我们选取 &lt;equation&gt;1&lt;/equation&gt; 和 &lt;equation&gt;2&lt;/equation&gt; 来组成这个字符串。我们用空字符串 &lt;equation&gt;\varepsilon&lt;/equation&gt; 来表示 &lt;equation&gt;0&lt;/equation&gt; ，用 &lt;equation&gt;a_n…a_1a_0&lt;/equation&gt; 表示&lt;equation&gt;\sum_{i=0}^n a_i2^i&lt;/equation&gt;&lt;i&gt;，&lt;/i&gt;其中&lt;equation&gt;a_i\in\{1,2\}&lt;/equation&gt;. 例如：&lt;equation&gt;4&lt;/equation&gt;被表示为&lt;equation&gt;12&lt;/equation&gt;，&lt;equation&gt;7&lt;/equation&gt;被表示为&lt;equation&gt;111&lt;/equation&gt;。容易证明这种表示是一个双射。这是一种常用的计数方法，被称为bijective base-2 numeration。&lt;/p&gt;&lt;p&gt;由此，我们可以得到一个更紧凑的在二叉树中存储序列的方法。将表示序列位置的自然数展开成它的bijective base-2表示（展开方法类似二进制数），然后从树的根节点、二进制表示的最高位开始逢1向左逢2向右直至走完，停止的位置就是在二叉树中应该存放的位置。直观上看，二叉树中的节点被我们从上到下从左到右依次标注。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8cb20f6c28b55ccfb0ec61c8e0b6e34e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1444&quot; data-rawheight=&quot;1444&quot;&gt;&lt;p&gt;如果我们选用这样的结构，&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 的实现是显然的。随着元素增多，这棵树的形态始终是接近满的，这保证了&lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 一定是 &lt;equation&gt;O(\log n)&lt;/equation&gt; 的。但是，似乎并没有一个直观的方法提示我们应该如何高效的实现 &lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt;。究其原因，每当我们插入新元素或者去除旧元素时，树的结构会被破坏，每一个其中的元素的位置都会受到影响。同时，甚至是 &lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 的实现都是不甚自然的，因为我们需要首先展开一个自然数，完整存储这个结果，再从高到低使用。那么，如果我们使用逆序的bijective base-2 numeration呢？&lt;/p&gt;&lt;h2&gt;新的结构 Braun tree&lt;/h2&gt;&lt;p&gt;考虑一个序列 &lt;equation&gt; \varepsilon,1,2,11,12,21,22,…&lt;/equation&gt; 如果把它们当作逆序以后的表示，即 &lt;equation&gt;a_0a_1…a_n&lt;/equation&gt; 表示 &lt;equation&gt;\sum_{i=0}^n a_i2^i&lt;/equation&gt; ，那么这个序列将对应 &lt;equation&gt;0,1,2,3,5,4,6,…&lt;/equation&gt; 用这样的表示来编码二叉树中的位置，我们会得到结构如下的树：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-097294ad42f4c76aa3bebf30e8ba09f7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1588&quot; data-rawheight=&quot;1114&quot;&gt;&lt;p&gt;这样的树被称为Braun tree。这个改变看似只是方便了我们实现&lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt;，但它却具有更大的意义。Braun tree 具有如下的性质：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Braun tree的左支和右支都是Braun tree&lt;/li&gt;&lt;li&gt;Braun tree的左支的元素个数只可能和右支相等或多1&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第二条性质保证了Braun tree总是平衡的的，我们可以高效的访问它的节点。第一条性质保证了我们可以方便地递归实现对于Braun tree的一些操作。同时，我们发现对于任意的&lt;equation&gt;i&lt;/equation&gt;，序数是&lt;equation&gt;2i+1&lt;/equation&gt;的元素和&lt;equation&gt;2i+2&lt;/equation&gt;的元素总是在同一父节点的左右子树中处在同一个位置。这个性质和我们选取的自然数的逆序同构表示是直接相关的。这一性质为我们提供了高效实现 &lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt; 的思路。&lt;/p&gt;&lt;p&gt;当我们想要在Braun tree的根节点增加新元素时，我们新增元素替换了旧的根节点元素。由于上述性质，新的二叉树的右子树将是当前的左子树，新的左子树将是旧的二叉树的右子树增加了旧根节点元素以后的结果。我们可以递归地将根节点替换，将旧元素插入右子树，然后交换左右子树。&lt;/p&gt;&lt;h2&gt;OCaml 实现&lt;/h2&gt;&lt;p&gt;我们按照上述讨论在OCaml中定义Braun tree，并声明它是序列的一种实现：&lt;/p&gt;&lt;code lang=&quot;ocaml&quot;&gt;type &#39;a brt = Empty | Node of &#39;a * &#39;a brt * &#39;a brt
type &#39;a sequence = &#39;a brt&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt; 的实现非常显然，在此不做赘述。&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; 应当对它作用的的Braun tree进行判断，如果为空则返回只有一个节点的树，否则按照我们的讨论返回一个新的树，其根节点是新的元素。&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; 实现如下：&lt;/p&gt;&lt;code lang=&quot;ocaml&quot;&gt;let rec cons x = function
    Empty -&amp;gt; Node (x, Empty, Empty)
  | Node (x&#39;, lt, rt) -&amp;gt; Node (x, cons x&#39; rt, lt)&lt;/code&gt;&lt;p&gt;要实现 &lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt; ，更容易入手的方法是实现&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; 的逆运算&lt;code class=&quot;inline&quot;&gt;uncons&lt;/code&gt;。&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; 作用在一个元素和一棵树上，返回一棵新树。&lt;code class=&quot;inline&quot;&gt;uncons&lt;/code&gt; 则应当作用在一棵树上，“拆解”出它的根节点，并返回根节点元素和一棵由剩余元素组成的树。考虑到&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;的值域中没有&lt;code class=&quot;inline&quot;&gt;Empty&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;uncons&lt;/code&gt; 的返回值应当是一个 &lt;code class=&quot;inline&quot;&gt;option&lt;/code&gt; 类型。因此，&lt;code class=&quot;inline&quot;&gt;uncons&lt;/code&gt; 的类型应当为 &lt;code class=&quot;inline&quot;&gt;&#39;a sequence -&amp;gt; (&#39;a * &#39;a sequence) option&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;由于&lt;code class=&quot;inline&quot;&gt;uncons&lt;/code&gt; 是 &lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;的逆运算，它的实现可以直接得到。对于空的树，我们应当返回&lt;code class=&quot;inline&quot;&gt;None&lt;/code&gt;。而对于非空的树，我们返回的“拆解”下的元素则为当前的根节点。同时我们应当对这棵树的左子树（由旧的树的右子树&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;旧的根节点得到）递归地进行&lt;code class=&quot;inline&quot;&gt;uncons&lt;/code&gt;，如果返回结果是一个元素和一棵树构成的二元组，那么我们返回的树的根节点为递归返回的元素，左右子树分别是当前的右子树和递归返回的树。如果递归返回的结果是&lt;code class=&quot;inline&quot;&gt;None&lt;/code&gt;，返回的树应当为空。在OCaml中实现如下：&lt;/p&gt;&lt;code lang=&quot;ocaml&quot;&gt;let rec uncons = function
    Empty -&amp;gt; None
  | Node (x, lt, rt) -&amp;gt;
     match uncons lt with
       None -&amp;gt; Some (x, Empty)
     | Some (x&#39;, lt&#39;) -&amp;gt; Some (x, Node (x&#39;, rt, lt&#39;))

let rest t = match uncons t with
    None -&amp;gt; None
  | Some (_, t&#39;) -&amp;gt; Some t&#39;&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 我们已经进行了详细的讨论，它的实现在此按下不表。&lt;/p&gt;&lt;h2&gt;分析总结&lt;/h2&gt;&lt;p&gt;上述的实现保证了持久性，同时有相对较高的效率。&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 的时间复杂度均为&lt;equation&gt;O(\log n)&lt;/equation&gt;，同时由于我们的实现是不可变的，新旧版本的树可以共享数据和节点。值得注意的是想要用&lt;equation&gt;n&lt;/equation&gt;个元素创建一棵Braun tree可以在&lt;equation&gt;O(n)&lt;/equation&gt;的时间完成，具体的实现参见文末Okasaki的文章。&lt;/p&gt;&lt;p&gt;Braun tree的序列实现并不是非常的高效，但至少是可用的。同时Braun tree本身是一种在持久化数据结构中时常出现的数据结构，它被用来实现很多复杂的数据结构。除此以外，实际应用中也有和传统的序列（如C++ vector）一样高效的持久化实现，比如Clojure的persistent vector。&lt;/p&gt;&lt;h2&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.eecs.northwestern.edu/~robby/courses/395-495-2013-fall/three-algorithms-on-braun-trees.pdf&quot;&gt;Three Algorithms on Braun Trees by Chris Okasaki&lt;/a&gt;&lt;/p&gt;</description>
<author>廿人口木</author>
<guid isPermaLink="false">2018-02-18-33859991</guid>
<pubDate>Sun, 18 Feb 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>delimited continuations完全攻略</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-02-15-33399006.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33399006&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-eb471c83c20ac7b33a45d0f2bf17a90c_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;宣传一下我的群：Expert Scheme：523791077&lt;/p&gt;&lt;p&gt;&lt;b&gt;Part I ： shift and reset&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;警告：在racket中使用shift/reset，请加上这句：&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(require racket/control)&lt;/code&gt;&lt;p&gt;&lt;b&gt;A. shift和reset的基本规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;要了解shift和reset如何使用，就必须先了解shift和reset的求值规则：&lt;/p&gt;&lt;p&gt;当reset的内部是简单表达式的时候，整个表达式直接返回其值。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (+ 1 2)) =&amp;gt; 3&lt;/code&gt;&lt;p&gt;当reset的内部的shift被求值时，需要注意，返回shift的body。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (+ 1 (shift k 2)))  =&amp;gt; 2&lt;/code&gt;&lt;p&gt;把reset想象成一个整块，shift就是在其中打洞。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(+ 1 hole)&lt;/code&gt;&lt;p&gt;你现在需要一个值把洞填上去，我们可以写一个函数：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (hole) (+ 1 hole))&lt;/code&gt;&lt;p&gt;而shift的第一个标识符k所绑定的值就是这个函数(一般称为continuation，用字母k表示，或者用ctx表示）。&lt;/p&gt;&lt;p&gt;这个表达式：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (+ (shift k (k (k 1))) 1))&lt;/code&gt;&lt;p&gt;我们的k函数应当是（注意，这个例子中的hole与上一个例子的hole位置是不同的）&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (hole) (+ hole 1))&lt;/code&gt;&lt;p&gt;整个表达式应当返回shift的body部分，即：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(k (k 1))&lt;/code&gt;&lt;p&gt;而我们已经知道k的值了，直接带入表达式计算得出3。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;B. 与Arclisp中方括号的关系&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;Since functions of one argument are so often used in Lisp programs,&lt;br&gt;Arc has a special notation for them.  [... _ ...]  is an abbreviation&lt;br&gt;for (fn (_) (... _ ...)).  So our first map example could have been&lt;br&gt;written&lt;br&gt;&lt;br&gt;arc&amp;gt; (map [+ _ 10] &#39;(1 2 3))&lt;br&gt;(11 12 13)&lt;/blockquote&gt;&lt;p&gt;Arclisp允许你在表达式中开洞，这样表达式就成了一个函数。&lt;/p&gt;&lt;p&gt;而reset/shift中也允许你这么做。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (shift k k))  = 
(lambda (x) x) = 
[ _ ] (in Arclisp)&lt;/code&gt;&lt;p&gt;第二个例子：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (+ 1 (* 2 (shift k k))))  =
(lambda (x) (+ 1 (* 2 x)))  =
[+ 1 (* 2 _)] (in Arclisp)&lt;/code&gt;&lt;p&gt;我们发现Arclisp中的_与(shift k k)某种意义上有很大的相似性。&lt;/p&gt;&lt;p&gt;下面是一个更酷的例子：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (+ (shift k1 k1) (shift k2 k2)))&lt;/code&gt;&lt;p&gt;为了区分前后两个k，我将它们分别标记为k1和k2。&lt;/p&gt;&lt;p&gt;很明显k1是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x1)
  (+ x1 (shift k2 k2)))&lt;/code&gt;&lt;p&gt;我们的reset表达式返回了k1。&lt;/p&gt;&lt;p&gt;尝试向k1这个函数中喂一个值2：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(+ 2 (shift k2 k2))&lt;/code&gt;&lt;p&gt;现在你应该感到犯难了，还有一个shift表达式，但是外层已经没有reset了。&lt;/p&gt;&lt;p&gt;于是shift并不知道把k2返回到哪里，也不知道&lt;b&gt;打洞的范围是多大&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;k2是:&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x) x)&lt;/code&gt;&lt;p&gt;还是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x) (+ 2 x))&lt;/code&gt;&lt;p&gt;幸运的是，shift和reset已经帮我们考虑到这个难题了，会帮我们自动地在k1体内加一个reset。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;k1 = (lambda (x1) (reset (+ x1 (shift k2 k2))))&lt;/code&gt;&lt;p&gt;很明显，我们可以直接写出k2 （别弄丢了reset）：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x2) (reset (+ x1 x2)))&lt;/code&gt;&lt;p&gt;综合起来结果就是&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x1)
  (lambda (x2)
    (+ x1 x2)))&lt;/code&gt;&lt;p&gt;因为当reset体内没有shift时，直接返回其值，所以我们可以将两个reset消去。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;请验证 (shift k (k &lt;i&gt;val&lt;/i&gt;))和&lt;i&gt;val&lt;/i&gt;在reset体内是等价的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;C. 重新认识shift/reset&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们从shift里面获得一个k，上一节讨论过这个k应当是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x) (reset expr ...))&lt;/code&gt;&lt;p&gt;考虑下面的表达式：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (shift k (shift k 1)))&lt;/code&gt;&lt;p&gt;结果是1，按照我们原来的规则进行求值：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;=&amp;gt; (shift k 1)&lt;/code&gt;&lt;p&gt;遇到了同样的难题！外层没有reset，肯定是自动帮我们加的:&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;=&amp;gt; (reset (shift k 1))&lt;/code&gt;&lt;p&gt;所以，是时候拓展我们的求值规则了。&lt;/p&gt;&lt;p&gt;(reset val) =&amp;gt; val&lt;br&gt;(reset E[(shift k expr)]) =&amp;gt; (&lt;b&gt;reset&lt;/b&gt; ((lambda (k) expr) (lambda (v) (&lt;b&gt;reset&lt;/b&gt; E[v]))))&lt;br&gt; ; where E has no reset&lt;/p&gt;&lt;p&gt;我将其中需要添加reset的部分用粗体标出。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;D. 与不确定性计算，list monad的关系&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这是一个计算a+b是否等于c的程序，如果等于c，那么输出整个式子：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(let ([a 1])
  (let ([b 1])
    (let ([c 2])
      (when (= (+ a b) c) (printf &quot;~a+~a=~a\n&quot; a b c)))))&lt;/code&gt;&lt;p&gt;可以把他们写成reset/shift的形式：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (let ([a (shift k (k 1))])
         (let ([b (shift k (k 1))])
           (let ([c (shift k (k 2))])
             (when (= (+ a b) c) (printf &quot;~a+~a=~a\n&quot; a b c))))))&lt;/code&gt;&lt;p&gt;两种写法是等价的，现在我们的a，b，c可能是多个不确定的值，也就是要进行多次计算。&lt;/p&gt;&lt;p&gt;我们可以把k想象成填一个值，进行一次计算，于是我们将函数k进行细胞分裂，多次计算。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (let ([a (shift k (k 1) (k 2) (k 3))])
         (let ([b (shift k (k 1) (k 2) (k 3))])
           (let ([c (shift k (k 1)(k 2)(k 3))])
             (when (= (+ a b) c) (printf &quot;~a+~a=~a\n&quot; a b c))))))&lt;/code&gt;&lt;p&gt;返回结果：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;1+1=2
1+2=3
2+1=3&lt;/code&gt;&lt;p&gt;如果你觉得这个例子难以理解，那么下面的呢（输出 123）：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (let ([a (shift k (k 1) (k 2) (k 3))])
         (print a)))&lt;/code&gt;&lt;p&gt;list monad或是list comprehension是一种很好用的计算列表的方法，但是racket中没有do notation，必须用宏来替代。（实际上racket提供了for comprehension作为替代方案，我们这里为了演示reset和shift的作用不考虑。）&lt;/p&gt;&lt;p&gt;但是，我们也可以用reset和shift来直接实现：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define return list)
(define (in-list lst)
  (shift k
         (apply append
                (map k lst))))

(reset (let ([a (in-list &#39;(1 2 3))]
             [b (in-list &#39;(1 2 3))])
         (return (list a b))))&lt;/code&gt;&lt;p&gt;返回结果：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&#39;((1 1) (1 2) (1 3) (2 1) (2 2) (2 3) (3 1) (3 2) (3 3))&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;E. 与状态，state monad的关系&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在一些语言中不支持赋值语句，无法保存状态，可以用state monad来模拟，同样地，state monad也可以用reset和shift模拟。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (get)
  (shift k (lambda (s) ((k s) s))))
(define (put s)
  (shift k (lambda (-s)
             ((k (void)) s))))
(define ((return x) s) x)&lt;/code&gt;&lt;p&gt;下面展现了一个很有意思的例子：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (tick)
  (let ([a (get)])
    (put (+ a 1))))
((reset (tick)
       (tick)
       (tick)
       (return (get))) 0)&lt;/code&gt;&lt;p&gt;试试看用shift和reset是否能实现其他monad。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;F. 与stream，generator的关系&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当我们需要表示无穷时，我们通常借助于stream与generator，而shift/reset与这二者间有着微妙的关系。&lt;/p&gt;&lt;p&gt;我们需要使用define-syntax-rule，不了解的请看：&lt;a href=&quot;http://docs.racket-lang.org/reference/stx-patterns.html?q=define-syntax-rule#%28form._%28%28lib._racket%2Fprivate%2Fmisc..rkt%29._define-syntax-rule%29%29&quot;&gt;12.1 Pattern-Based Syntax Matching&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;看下面的例子：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define s (reset (shift k (stream-cons 1 (k (void))))
                 (shift k (stream-cons 2 (k (void))))
                 (shift k (stream-cons 3 (k (void))))
                 (shift k &#39;())))&lt;/code&gt;&lt;p&gt;这个例子生成了一个内容为1 2 3的stream，而内部的语法却接近generator！&lt;/p&gt;&lt;p&gt;我们可以写宏来让你看的更加清楚：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define-syntax-rule (stream/generate expr ...)
  (reset expr ...))
(define-syntax-rule (stream/yield expr ...)
  (shift k (stream-cons (begin expr ...) (k (void)))))

(define s (stream/generate
           (stream/yield 1)
           (stream/yield 2)
           (stream/yield 3)))

(define (integer-sequences x)
  (stream/generate (stream/yield x)
                   (integer-sequences (+ x 1))))&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;用shift和reset实现generator的任务更为艰巨，我们曾经在&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25749077&quot;&gt;愉悦的scheme之旅（2）--用callcc合成控制流&lt;/a&gt;介绍过用call/cc实现的generator，但是因为有了shift和reset一切都变简单了。&lt;/p&gt;&lt;p&gt;我们需要使用syntax-parameter，不了解的请看&lt;a href=&quot;http://docs.racket-lang.org/reference/stxparam.html?q=syntax-parameter&quot;&gt;12.5 Syntax Parameters&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;完整程序如下：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang racket
(require racket/control racket/stxparam)
(define-syntax-parameter yield 
  (syntax-rules ()
    [(_ expr ...)
     (raise-syntax-error &#39;generator-err
                         &quot;You must use yield in the body of generator&quot;)]))

(define-syntax-rule (generate expr ...)
  (letrec ([state (lambda ()
                 (syntax-parameterize
                     ([yield (syntax-rules ()
                               [(_ expr2 (... ...)) (shift k
                                                           (set! state
                                                                 (lambda () (k (void))))
                                                           (values expr2 (... ...)))])])
                   (reset (begin expr ... (void)))))])
    (lambda ()
      (state)
      )))
(define g (generate (yield 1)
                    (yield 6)
                    (yield 7)
                    (yield 10)))&lt;/code&gt;&lt;p&gt;宏会干扰我们的思考，我们看看展开后是什么样子吧。&lt;/p&gt;&lt;p&gt;racket的macro stepper是宏调试的利器，通过它，我们可以直接看到展开的结果：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(syntax-parameterize
  ((yield
    (syntax-rules ()
      ((_ expr2 ...)
       (shift k (set! state (lambda () (k (void)))) (values expr2 ...))))))
  (reset (begin (yield 1) (yield 6) (yield 7) (yield 10) (void))))&lt;/code&gt;&lt;p&gt;这并不是最终的结果，因为syntax-parameterize没有展开,由于一些限制，我们手动展开一下：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (begin (shift k (set! state (lambda () (k (void)))) (values 1))
                (shift k (set! state (lambda () (k (void)))) (values 6))
                (shift k (set! state (lambda () (k (void)))) (values 7))
                (shift k (set! state (lambda () (k (void)))) (values 10))
                (void)))&lt;/code&gt;&lt;p&gt;现在应该看的很清楚了，第一次调用时返回1，state则变成了：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda () (reset (begin (void)
                         (shift k (set! state (lambda () (k (void)))) (values 6))
                         (shift k (set! state (lambda () (k (void)))) (values 7))
                         (shift k (set! state (lambda () (k (void)))) (values 10))
                         (void))))&lt;/code&gt;&lt;p&gt;剩下的应该不难了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;G.  算法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;考虑函数genlist：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(genlist &#39;(1 2)) =&amp;gt; &#39;((1) (1 2))
(genlist &#39;(1 2 3 4)) =&amp;gt; &#39;((1) (1 2) (1 2 3) (1 2 3 4))&lt;/code&gt;&lt;p&gt;有人会这么做：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (genlist lst)
  (define (genlist lst last)
    (if (null? lst) &#39;()
        (let ([x (append last (list (car lst)))])
          (cons x (genlist (cdr lst) x)))))
  (genlist lst &#39;()))&lt;/code&gt;&lt;p&gt;可惜效率并不高，因为多次向队尾插入数据。&lt;/p&gt;&lt;p&gt;借助CPS，我们可以这么写（其实也可看成difference list）：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (genlist lst)
  (define (genlist lst ctx)
    (if (null? lst)
        (list (ctx &#39;()))
        (cons (ctx (list (car lst)))
              (genlist (cdr lst)
                       (lambda (x) (ctx (cons (car lst) x)))))))
  (if (null? lst)
      &#39;()
      (genlist lst (lambda (x) x))))&lt;/code&gt;&lt;p&gt;考虑lst=&#39;(1 2 3 4)的情况，ctx分别是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;ctx1 = [list* _]
ctx2 = [list* 1 _]
ctx3 = [list* 1 2 _]
ctx4 = [list* 1 2 3 _]&lt;/code&gt;&lt;p&gt;我们可以用shift和reset重写：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (genlist lst)
  (define (genlist lst)
    (if (null? lst)
        (shift k &#39;())
        (shift k
               (cons (k (list (car lst)))
                     (reset (k (cons (car lst)
                                     (genlist (cdr lst)))))))))
  (reset (genlist lst)))&lt;/code&gt;&lt;p&gt;可以自己尝试推倒一下。&lt;/p&gt;&lt;p&gt;shift和reset还能做其他一些算法例如cps变换，anf变换，closure conversion等，这里不再详细介绍。&lt;/p&gt;&lt;p&gt;新手的课后作业：&lt;/p&gt;&lt;p&gt;尝试用shift和reset实现cps变换和anf变换。&lt;/p&gt;&lt;p&gt;老手的课后作业(难度非常大，做好心理准备）：&lt;/p&gt;&lt;p&gt;阅读&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.schemeworkshop.org/2016/scheme16-paper6.pdf&quot;&gt;Deriving Pure, Naturally-Recursive Operations for Processing Tail-Aligned Lists&lt;/a&gt;(SCHEME AND FUNCTIONAL PROGRAMMING WORKSHOP 2016)&lt;/p&gt;&lt;p&gt;并尝试用shift和reset改写其中的算法。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Part II : shift0 and reset0&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;A. 求值规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;直接给出shift0和reset0的求值规则：&lt;/p&gt;&lt;p&gt;(reset0 &lt;i&gt;val&lt;/i&gt;) &lt;a href=&quot;file:///C:/Program%20Files/Racket/doc/reference/if.html?q=shift#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29&quot;&gt;=&amp;gt;&lt;/a&gt; &lt;i&gt;val&lt;/i&gt;&lt;/p&gt;&lt;p&gt;(reset0 &lt;i&gt;E&lt;/i&gt;[(shift0 &lt;i&gt;k&lt;/i&gt; &lt;i&gt;expr&lt;/i&gt;)]) &lt;a href=&quot;file:///C:/Program%20Files/Racket/doc/reference/if.html?q=shift#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29&quot;&gt;=&amp;gt;&lt;/a&gt; ((lambda (&lt;i&gt;k&lt;/i&gt;) &lt;i&gt;expr&lt;/i&gt;) (lambda (&lt;i&gt;v&lt;/i&gt;) (&lt;b&gt;reset0&lt;/b&gt; &lt;i&gt;E&lt;/i&gt;[&lt;i&gt;v&lt;/i&gt;])))&lt;/p&gt;&lt;p&gt;仔细比较与shift和reset的不同，你会发现是不是少了一个reset0，也就是说&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset0 (shift0 k expr)) =&amp;gt; expr&lt;/code&gt;&lt;p&gt;而不是&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (shift k expr)) =&amp;gt; (reset expr)&lt;/code&gt;&lt;p&gt;那么思考下面这段程序，k1和k2分别是什么？&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset0 (+ 1
           (reset0 (+ 2 (shift0 k1 (shift0 k2 3))))))&lt;/code&gt;&lt;p&gt;k1是显而易见的：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x1)
  (reset0 (+ 2 x1)))&lt;/code&gt;&lt;p&gt;根据我们刚才讨论的内容继续求值：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;=&amp;gt; (reset0 (+ 1 (shift0 k2 1)))&lt;/code&gt;&lt;p&gt;然后就能得到k2了&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x2) (reset0 (+ 1 x2)))&lt;/code&gt;&lt;p&gt;这里，我们最先得到的k1，是内层的continuation，而k2，是外层的continuation。&lt;/p&gt;&lt;p&gt;我们可以将他们组合一下，得到整个continuation：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset0 (+ 1 (reset0
              (+ 2 (shift0 k1
                           (shift0 k2 (k2 (k1 3))))))))&lt;/code&gt;&lt;p&gt;这与 (+ 1 (+ 2 3))是等价的。&lt;/p&gt;&lt;p&gt;我们捕获的continuation具有了层次这一概念，接下来我们该利用这一特点搞事了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;B. 括号解析&lt;/b&gt;&lt;/p&gt;&lt;p&gt;下面思考这个问题，给与一个含有左括号的标记&#39;left 和右括号标记的&#39;right的列表，将其转换成有层次的列表。&lt;/p&gt;&lt;p&gt;(parse-parens &#39;(a b left c right)) =&amp;gt; &#39;(a b (c))&lt;/p&gt;&lt;p&gt;(parse-parens &#39;(a left b left c right right d)) =&amp;gt; &#39;(a (b (c)) d)&lt;/p&gt;&lt;p&gt;现在我们考虑解析&#39;(a b left c right)，以continuation的思维来看的话：&lt;/p&gt;&lt;p&gt;符号a ，ctx = (lambda (x) x)&lt;/p&gt;&lt;p&gt;符号b，ctx = (lambda (x) (cons a x))&lt;/p&gt;&lt;p&gt;符号left，ctx = (lambda (x) (list* a b x))&lt;/p&gt;&lt;p&gt;到这里我们就觉得有些困难了，因为left c right是一个整体，我们必须要解析到right才能知道这个整体的内容是&#39;(c)。&lt;/p&gt;&lt;p&gt;我们可以考虑使用双层的continuation：&lt;/p&gt;&lt;p&gt;符号a，ctx-inner = (lambda (x) x) ctx-outer = (lambda (x) x)&lt;/p&gt;&lt;p&gt;符号b，ctx-inner = (lambda (x) x) ctx-outer = (lambda (x) (cons a x))&lt;/p&gt;&lt;p&gt;符号left,ctx-inner = (lambda (x) x) ctx-outer = (lambda (x) (list* a b x))&lt;/p&gt;&lt;p&gt;符号c ,  ctx-inner = (lambda (x) (cons c x)) ctx-outer = (lambda (x) (list* a b x))&lt;/p&gt;&lt;p&gt;符号right , 清空ctx-inner， 结果送入ctx-outer&lt;/p&gt;&lt;p&gt;ctx-inner = (lambda (x) x) ctx-outer = (lambda (x) (list* a b c x))&lt;/p&gt;&lt;p&gt;解析完毕，清空ctx-outer。&lt;/p&gt;&lt;p&gt;解析时ctx-inner负责处理内部，ctx-outer负责解析外部。&lt;/p&gt;&lt;p&gt;当我们的括号的层次不止两层时，我们的ctx也不止两个，无穷无尽的ctx组成了一个ctx栈。&lt;/p&gt;&lt;p&gt;现在，考虑如何用shift0和reset0实现：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (parse-parens lst)
  (define (parse-parens lst)
    (if (null? lst) &#39;()
        (match (car lst)
          [&#39;left (reset0 (parse-parens (cdr lst)))]
          [&#39;right (shift0 k1 (shift0 k2 (reset0 (k2 (cons (k1 &#39;()) (parse-parens (cdr lst)))))))]
          [_ (shift0 k (reset0 (k (cons (car lst) (parse-parens (cdr lst))))))])))
  (reset0 (parse-parens lst)))&lt;/code&gt;&lt;p&gt;每次遇到left时，我们开辟一个新的reset0层，每次遇到right时，我们将该层次闭合。&lt;/p&gt;&lt;p&gt;这是利用同样办法写出来的表达式解析器：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (parse-exp lst)
  (define (parse-exp lst)
    (if (null? lst) (error &quot;No exp&quot;)
        (match lst
          [(list (? number? x)) x]
          [(list (? number? x) (and (or &#39;+ &#39;-) op) rst ...) (shift0 k1
                                                                    (shift0 k2 (shift0 k3
                                                                                       (reset0 
                                                                                        (list op  (k3 (k2 (k1 x))) (reset0
                                                                                                                    (reset0
                                                                                                                     (parse-exp rst))))))))]
          [(list (? number? x) (and (or &#39;* &#39;/) op) rst ...) (shift0
                                                             k1 (shift0 k2
                                                                        (reset0  (list op (k1 (k2 x)) (reset0
                                                                                                       (parse-exp rst))))))]
          [(list (? number? x) (and &#39;^ op) rst ...) (shift0
                                                     k (reset0
                                                        (list op (k x) (parse-exp rst))))]
          )))
  (reset0 (reset0 (reset0 (parse-exp lst)))))&lt;/code&gt;&lt;p&gt;比如1+2*3^6-7*8的层次是：&lt;/p&gt;&lt;p&gt;1 + [ 2 * (3^6) ] - [ 7*8 ]&lt;/p&gt;&lt;p&gt;这就是为什么有三个优先级就需要三个reset0的缘故。&lt;/p&gt;&lt;p&gt;课后作业：&lt;/p&gt;&lt;p&gt;1.可以用shift0和reset0实现shift和reset吗，试试看。&lt;/p&gt;&lt;p&gt;2.这个表达式解析器存在一个缺陷，所有操作符都会视为左结合的，然而：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(parse-exp &#39;(1 ^ 2 ^ 3))  =&amp;gt; &#39;(^ (^ 1 2) 3)&lt;/code&gt;&lt;p&gt;指数运算应当是右结合的，请尝修复这个bug。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>御坂黒子</author>
<guid isPermaLink="false">2018-02-15-33399006</guid>
<pubDate>Thu, 15 Feb 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>【OI】【奇技淫巧】bitset在OI中的应用</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-01-29-33406432.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33406432&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d825293370685bfc6c285d7b2ad50ea1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;震惊，GDKOI2018D1T3竟有bitset水法！&lt;/p&gt;&lt;p&gt;作为一只标准蒟蒻，我在学不会标准正解FFT的情况下然后去学了一下bitset。。。&lt;/p&gt;&lt;p&gt;一般你翻开一个关于介绍bitset的blog，基本画风是这样的：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e433874acf5a3b6b77c4413512410809_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;761&quot;&gt;&lt;p&gt;（来源：&lt;a href=&quot;https://www.cnblogs.com/BaiYiShaoNian/p/4591167.html&quot;&gt;https://www.cnblogs.com/BaiYiShaoNian/p/4591167.html&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;然而作为菜鸡的我一看完就有点懵，不是说bitset可以快速查找某一个元素喵，这些...都是处理二进制的呀。&lt;/p&gt;&lt;p&gt;然后经过我的几次无脑实验我大概就摸清了使用bitset的基本套路：&lt;/p&gt;&lt;p&gt;1、bitset其实是可以看做是&lt;b&gt;一个bool类型的数组&lt;/b&gt;，只不过bitset的一个元素只占1bit的空间，而bool里面则是占1byte，这样就相当于同时减少了时间复杂度和空间复杂度，这也是bitset的优势所在。&lt;/p&gt;&lt;p&gt;2、使用bitset的时候你需要先声明，类似声明vector一样，基本格式：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;#include&amp;lt;bitset&amp;gt;
bitset&amp;lt;10005&amp;gt;a;  //10005是bitset的大小，相当于数组大小，a就相当于一个bool数组。&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;3、前面说了bitset是基本和bool数组的用法一样的，所以其实赋值的时候&lt;b&gt;完全可以这样写&lt;/b&gt;：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;a[0]=1;//等价于写a.set(0);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;4、那么话说回来&lt;b&gt;如何快速查找一个元素是否在集合内&lt;/b&gt;呢，你大可这样写：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;//x为查找元素：
if (f[x]) printf(&quot;Yes\n&quot;); else printf(&quot;No\n&quot;);&lt;/code&gt;&lt;p&gt;有人可能会问了，那这不是bool数组也可以做到吗，其实还是&lt;b&gt;空间&lt;/b&gt;的问题，用bitset可以轻松存10^8个数字并查询，bool空间是它的八倍然后就极有可能MLE~&lt;/p&gt;&lt;p&gt;那我们就来一道水题练练手吧&lt;/p&gt;&lt;a href=&quot;http://poj.org/problem?id=2443&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;2443 -- Set Operation&lt;/a&gt;&lt;p&gt;果然很水对吧（&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;bitset&amp;gt;
using namespace std;
int n,i,j,k,q,x,g,y;
bool fl;
bitset&amp;lt;10005&amp;gt; a[1015];
int main()
{
	scanf(&quot;%d&quot;,&amp;amp;n);
	for (i=1;i&amp;lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;amp;x);
		for (j=1;j&amp;lt;=x;j++)
		{
			scanf(&quot;%d&quot;,&amp;amp;g);
			a[i][g]=1;
		}
	}
	scanf(&quot;%d&quot;,&amp;amp;q);
	for (i=1;i&amp;lt;=q;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;amp;x,&amp;amp;y);
		fl=1;
		for (j=1;j&amp;lt;=n;j++)
			if (a[j][x]&amp;amp;&amp;amp;a[j][y]) {printf(&quot;Yes\n&quot;);fl=0;break;}
		if (fl) printf(&quot;No\n&quot;);
	}
	return 0;
}&lt;/code&gt;&lt;p&gt;Q：有没有好玩一点的题&lt;/p&gt;&lt;p&gt;A：bzoj3687把dp和bitset结合了起来，可惜是一道权限题qwq。有兴趣的可以看hzwer的blog看一下这道题w（http://hzwer.com/3697.html）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>萌萌哒喵酱</author>
<guid isPermaLink="false">2018-01-29-33406432</guid>
<pubDate>Mon, 29 Jan 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
