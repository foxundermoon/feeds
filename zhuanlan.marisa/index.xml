<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Fri, 30 Nov 2018 23:48:01 +0800</lastBuildDate>
<item>
<title>Recursion Schemes（六）基本函子革命</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-11-30-51286145.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51286145&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e5a2a9858bfa0c0e317c6943a84edb5b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;为了能够不拖更，我决定讨论一些小一点的话题，本章中我们将讨论基本函子（base functor）这一概念，以及 &lt;a href=&quot;https://hackage.haskell.org/package/recursion-schemes&quot;&gt;recursion-schemes&lt;/a&gt; 库函数中如何使用基本函子来使 recursion scheme 在实践中更为优雅高效。&lt;/p&gt;&lt;h2&gt;前情回顾&lt;/h2&gt;&lt;p&gt;在之前数篇文章中，我们已经看到了某种定义参数化数据类型的模式，我们从这样的数据类型定义：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Expr
  = Index Expr Expr
  | Call Expr [Expr]
  | Unary String Expr
  | Binary Expr String Expr
  | Paren Expr
  | Literal Int
  deriving (Show, Eq)&lt;/code&gt;&lt;p&gt;变为了这样：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data ExprF a
  = Index a a
  | Call a [a]
  | Unary String a
  | Binary a String a
  | Paren a
  | Literal Int
  deriving (Show, Eq, Functor)&lt;/code&gt;&lt;p&gt;一样的数据类型，但是 kind [1] 变为了 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; *&lt;/code&gt;，所有的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 都用 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 做了替换。接着我们使用了 Y-组合子的技巧来定义 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt;，这样的定义与之前的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 等价，但是可以使用 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;，以及 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Term f = In { out :: f (Term f) }

type Expr = ExprF (Term ExprF)&lt;/code&gt;&lt;p&gt;类似地，在第四章中，我们定义了自然数，它的 kind 也是 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; *&lt;/code&gt; 的：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Nat a
    = Zero
    | Next a
    deriving Functor&lt;/code&gt;&lt;p&gt;我们也定义了 &lt;code class=&quot;inline&quot;&gt;Plant&lt;/code&gt;，也是类似的定义：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Plant a
  = Root a
  | Stalk a
  | Fork a a a
  | Bloom&lt;/code&gt;&lt;p&gt;这个表达数据的办法确实清晰明了，但是也有相应的问题。&lt;/p&gt;&lt;p&gt;假设我们考虑一个最简单地链表类型：&lt;code class=&quot;inline&quot;&gt;a:[a]&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;infixr 5 :
data [] a = a : [a]
          | []&lt;/code&gt;&lt;p&gt;显然 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt;，我们最基本的右折叠操作，应该可以支持这一结构。毕竟它的 kind 也是 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; *&lt;/code&gt;。但如果我在这一结构上使用 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt;，我们马上就遇到了麻烦：我们无法在了链表里存储元素了。 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 只能表示嵌套的 &lt;code class=&quot;inline&quot;&gt;Term a&lt;/code&gt; 这一结构。没有地方来存储链表本身的元素。可以想见，这样的链表并不十分有用。&lt;/p&gt;&lt;p&gt;当然我们也可以将 &lt;code class=&quot;inline&quot;&gt;[a]&lt;/code&gt; 转换为之前我们常见的那种模式，新加入一个参数来表达递归的部分。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data ListF a b
  = Cons a b
  | Nil
    deriving (Show, Eq, Functor)&lt;/code&gt;&lt;p&gt;在这样的结构上我们就可以完成递归了：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;listSum :: Num a =&amp;gt; Algebra (ListF a) a
listSum (Cons a b) = a + b
listSum Nil = 0&lt;/code&gt;&lt;p&gt;但是这一办法非常丑陋，如果对于 &lt;code class=&quot;inline&quot;&gt;[]&lt;/code&gt;，这样的类型全部进行手动替换的话，我们完全丧失了使用 recursion scheme 的初衷。幸好并不是我一个人这么觉得，实际上有非常多种做法来绕开这个问题，我们会着重描述 &lt;a href=&quot;https://hackage.haskell.org/package/recursion-schemes&quot;&gt;recursion-schemes&lt;/a&gt; 中解决该问题的办法。&lt;/p&gt;&lt;h2&gt;救星基本函子&lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 库文档中有如下定义：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type family Base t :: * -&amp;gt; *&lt;/code&gt;&lt;p&gt;这个定义明显会吓到不少人，但实际上并没有那么难以理解，而正是这一定义使得 &lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 在易用性上远远超越了它的竞争对手们。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Base&lt;/code&gt; 类型类的目的就是将 Haskell 中的原生类型定义，或者我们自己的类型定义与相对应的参数化类型定义绑定起来。对 type family 的详尽用法进行介绍显然超出了本文的范畴（感兴趣的读者可参阅 &lt;a href=&quot;https://wiki.haskell.org/GHC/Type_families&quot;&gt;GHC wiki&lt;/a&gt;），我们可以简单认为 type family 是一个在类型上定义函数的方式。如果我们定义了一个 type family，以及一个它的实例（这与 typeclass 以及它的实例实际上是类似的）：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type family Something t

type instance Something Foo = Bar&lt;/code&gt;&lt;p&gt;那么之后我们无论在哪里遇到调用 &lt;code class=&quot;inline&quot;&gt;Something Foo&lt;/code&gt;，GHC 类型系统都会将它代换为 &lt;code class=&quot;inline&quot;&gt;Bar&lt;/code&gt;，为什么不直接写 &lt;code class=&quot;inline&quot;&gt;Bar&lt;/code&gt; 呢？—— 这初看起来无关紧要，但这为我们建立两种类型间的联系提供了便利。&lt;/p&gt;&lt;p&gt;我们观察一下 &lt;code class=&quot;inline&quot;&gt;Base&lt;/code&gt; 的定义，当你传入 &lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt; 时，你得到了一个 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; *&lt;/code&gt; 的类型，回想一下不难发现，我们也把 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 变成 &lt;code class=&quot;inline&quot;&gt;ExprF&lt;/code&gt; 的过程也是一个 &lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt; 到 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; *&lt;/code&gt; 的过程。同理，&lt;code class=&quot;inline&quot;&gt;list&lt;/code&gt; 就是一个 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; *&lt;/code&gt; 到 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt; 的过程。&lt;/p&gt;&lt;p&gt;一个 &lt;code class=&quot;inline&quot;&gt;Base&lt;/code&gt; 类型的实例或许更能说明问题：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type instance Base [a] = ListF a&lt;/code&gt;&lt;p&gt;简单来说，这样的写法使得 &lt;code class=&quot;inline&quot;&gt;ListF a&lt;/code&gt; 可以用 &lt;code class=&quot;inline&quot;&gt;Base [a]&lt;/code&gt; 来表达。对应于每种类型，它的参数化递归类型（&lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt; 变换为 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; *&lt;/code&gt;）只有一种合法实现，对应来看，对于任意 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;Base a&lt;/code&gt; 也只有一种合法实现。&lt;/p&gt;&lt;p&gt;当我们把这一定义与 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 类型类相结合以后，事情变得有趣起来。（为了阐述方便，这里的定义进行了适当简化）。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class (Functor (Base t)) =&amp;gt; Recursive t where
  project :: t -&amp;gt; Base t t
  cata    :: (Base t a -&amp;gt; a) -&amp;gt; t -&amp;gt; a&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 类型类与 &lt;code class=&quot;inline&quot;&gt;Foldable&lt;/code&gt; 类型类实际上是同构的[2]。无论我们定义了怎样的 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 实例，&lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 或是 &lt;code class=&quot;inline&quot;&gt;[a]&lt;/code&gt;，我们都可以在上面做折叠操作。实际上这里我们定义了两种方法，&lt;code class=&quot;inline&quot;&gt;project&lt;/code&gt; 参数为一个 &lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt; 类型变量，得到变化后的 &lt;code class=&quot;inline&quot;&gt;Base&lt;/code&gt; 形式。以及 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 函数，给定一个 &lt;code class=&quot;inline&quot;&gt;Base t a -&amp;gt; a&lt;/code&gt; 函数，一个初始化的 &lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;，最后得到一个 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这里的 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 和我们之前的定义初看上去似乎有所不同。我们定义的 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 只有 &lt;code class=&quot;inline&quot;&gt;Founctor&lt;/code&gt; 的约束：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;cata :: (Functor f) =&amp;gt; Algebra f a -&amp;gt; Term f -&amp;gt; a
cata f = out &amp;gt;&amp;gt;&amp;gt; fmap (cata f) &amp;gt;&amp;gt;&amp;gt; f&lt;/code&gt;&lt;p&gt;但我们的 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 必须使用 &lt;code class=&quot;inline&quot;&gt;Term List&lt;/code&gt; 而不是简单的 &lt;code class=&quot;inline&quot;&gt;[a]&lt;/code&gt;，而使用 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 类型类允许我们向 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 传入一般的数据类型 &lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt; 而不是 &lt;code class=&quot;inline&quot;&gt;Term t&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 的实例使用 &lt;code class=&quot;inline&quot;&gt;project&lt;/code&gt; 函数来将提供的类型转换为带参数的类型，并将它传递给 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 函数，省去了我们包装 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 和拼接 &lt;code class=&quot;inline&quot;&gt;Cons&lt;/code&gt; 的工作。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;sumList :: Num a =&amp;gt; [a] -&amp;gt; a
sumList = cata go where
  go Nil = 0
  go (Cons a acc) = a + acc&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 的魔法不止于此，根据它的最小编译指示，我们实现 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 类时，最低限度只需要实现 &lt;code class=&quot;inline&quot;&gt;project&lt;/code&gt; 函数即可。&lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 等函数可以沿用默认定义。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class Functor (Base t) =&amp;gt; Recursive t where
  project :: t -&amp;gt; Base t t

  cata :: (Base t a -&amp;gt; a) -- ^ a (Base t)-algebra
       -&amp;gt; t               -- ^ fixed point
       -&amp;gt; a               -- ^ result
  cata f = c where c = f . fmap c . project&lt;/code&gt;&lt;p&gt;这只是 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 的默认实现而已，如果在你特定的数据结构上，&lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 存在更好的实现，当然你可以重写这一定&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 类型类中还定义了其他方法，例如我们曾在之前的文章中讨论过的 &lt;code class=&quot;inline&quot;&gt;para&lt;/code&gt;，还包括一些我们没涉及的比如泛化的 paramorphism &lt;code class=&quot;inline&quot;&gt;gpara&lt;/code&gt;，以及 Fokkinga 提出的 prepromorphism &lt;code class=&quot;inline&quot;&gt;prepro&lt;/code&gt;，或许我们会在之后的文章中讨论它们（译者注：作者在之后的文章中并未讨论它们，或许我会在之后的文章中讨论它们？）。&lt;/p&gt;&lt;p&gt;注意 Base 类型受限于 Recursive 实例：&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt; 必须有一个 &lt;code class=&quot;inline&quot;&gt;Base&lt;/code&gt; 的实例，而且 &lt;code class=&quot;inline&quot;&gt;Base t&lt;/code&gt; 必须是一个 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt; 类型，这是因为 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 依赖于使用 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt; 在进行递归操作。&lt;/p&gt;&lt;p&gt;正是因为有了 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 类型类，我们可以操作 &lt;code class=&quot;inline&quot;&gt;[a]&lt;/code&gt; 而非 &lt;code class=&quot;inline&quot;&gt;ListF&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 而非 &lt;code class=&quot;inline&quot;&gt;ExprF&lt;/code&gt;，我们可以在简单数据类型上使用 Recursion Scheme。这一技巧在其它的库中也有采用，比如 José Pedro Magalhães 的 &lt;a href=&quot;https://hackage.haskell.org/package/regular/docs/Generics-Regular-Base.html#t:PF&quot;&gt;regular&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;下面我们看一下定义 &lt;code class=&quot;inline&quot;&gt;[a]&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 的实例。&lt;code class=&quot;inline&quot;&gt;[]&lt;/code&gt; 变为了 &lt;code class=&quot;inline&quot;&gt;Nil&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;:&lt;/code&gt; 变为了 &lt;code class=&quot;inline&quot;&gt;Cons&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;instance Recursive [a] where
  project (x:xs) = Cons x xs
  project [] = Nil&lt;/code&gt;&lt;p&gt;另外一个重要的例子是 &lt;code class=&quot;inline&quot;&gt;Natural&lt;/code&gt; —— 我们在之前也讨论过。我们自己定义了自然数类型 &lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt;，这一类型与 &lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt; 等同的。所以在 &lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 中就使用了 &lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt; 来实现 &lt;code class=&quot;inline&quot;&gt;Natural&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Base&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type instance Base Natural = Maybe

instance Recursive Natural where
  project 0 = Nothing
  project n = Just (n - 1)&lt;/code&gt;&lt;h2&gt;更进一步&lt;/h2&gt;&lt;p&gt;正如我们之前所看到的，给定一个 &lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;，构造 &lt;code class=&quot;inline&quot;&gt;Base&lt;/code&gt; 的示例是非常直观的：为原来的类型定义加入一个新的类型变量，接着改造每一个构造函数使其可以加入递归的新的类型变量。而借助 Haskell 的模板能力，&lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 可以生成如下的代码：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;import Data.Functor.Foldable.TH

data Expr
  = Index Expr Expr
  | Call Expr [Expr]
  | Unary String Expr
  | Binary Expr String Expr
  | Paren Expr
  | Literal Lit
  deriving (Show, Eq)

makeBaseFunctor &#39;&#39;Expr&lt;/code&gt;&lt;p&gt;其中 &lt;code class=&quot;inline&quot;&gt;makeBaseFunctor&lt;/code&gt; 生成的代码实际上等价于：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data ExprF a
  = IndexF a a
  | CallF a [a]
  | UnaryF String a
  | BinaryF a String a
  | ParenF a
  | LiteralF Lit
  deriving (Show, Eq, Functor)

type instance Base Expr = ExprF

instance Recursive Expr where
  project (Index a b) = IndexF a b
  project (Call a b)  = CallF a b
  -- and so on and so forth&lt;/code&gt;&lt;p&gt;这实际上就是讲上述描述应用而生成的代码，为了避免命名冲突，新的类型构造函数带一个后缀 ‘F’（中缀表达式后缀为‘$’）。&lt;/p&gt;&lt;p&gt;应用了 Haskell 模板以后，意味着对于我们这些库使用者，使用 &lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 的代价非常之小。而这些处理嵌套结构的能力，在我编写 Haskell 生产级别代码时带来了非常大的益处。你可以非常优雅地处理嵌套结构，不需要引入任何额外代码。&lt;/p&gt;&lt;h2&gt;再次翻转箭头&lt;/h2&gt;&lt;p&gt;在之前的文章中，我们多次使用翻转箭头的操作来生成展开操作。所以想必读者们对于我们要进行的操作也不会陌生，我们会同样对 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 进行类似操作。从而得到 &lt;code class=&quot;inline&quot;&gt;Corecursive&lt;/code&gt; 类型类，对应相应的展开操作。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class Functor (Base t) =&amp;gt; Corecursive t where
  embed :: Base t t -&amp;gt; t
  ana :: (a -&amp;gt; Base t a) -&amp;gt; a -&amp;gt; t&lt;/code&gt;&lt;p&gt;我们已经展示过，从 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 生成 &lt;code class=&quot;inline&quot;&gt;ana&lt;/code&gt; 的过程，所以只剩下通过翻转箭头从 &lt;code class=&quot;inline&quot;&gt;project&lt;/code&gt; 生成 &lt;code class=&quot;inline&quot;&gt;embed&lt;/code&gt; 的过程，我们从 &lt;code class=&quot;inline&quot;&gt;Base&lt;/code&gt; 函子生成 &lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;也对应于 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;ana&lt;/code&gt; 使用 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;embed&lt;/code&gt; 生成：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class Functor (Base t) =&amp;gt; Corecursive t where
  embed :: Base t t -&amp;gt; t
  ana
    :: (a -&amp;gt; Base t a) -- ^ a (Base t)-coalgebra
    -&amp;gt; a               -- ^ seed
    -&amp;gt; t               -- ^ resulting fixed point
  ana g = a where a = embed . fmap a . g&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;embed&lt;/code&gt; 实例的定义也是非常直观的对称：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;instance Corecursive [a] where
  embed (Cons x xs) = x:xs
  embed Nil = []&lt;/code&gt;&lt;p&gt;更棒的是，实际上你不必真的自己写 &lt;code class=&quot;inline&quot;&gt;Corecursive&lt;/code&gt; 的实例，&lt;code class=&quot;inline&quot;&gt;makeBaseFunctor&lt;/code&gt; 会同时自动生成 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Corecursive&lt;/code&gt; 的实例。&lt;/p&gt;&lt;h2&gt;餐后甜点&lt;/h2&gt;&lt;p&gt;敏锐的读者可能已经注意到了，&lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 库中的 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 实现与我们之前的形式有一些微妙的不同。我们的定义中，包括 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 的柯里化—— &lt;code class=&quot;inline&quot;&gt;cata f&lt;/code&gt;，将它传给了 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;cata :: (Functor f) =&amp;gt; Algebra f a -&amp;gt; Term f -&amp;gt; a
cata f = out &amp;gt;&amp;gt;&amp;gt; fmap (cata f) &amp;gt;&amp;gt;&amp;gt; f&lt;/code&gt;&lt;p&gt;而 &lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 则实现了 where 语句定义了变量 &lt;code class=&quot;inline&quot;&gt;c&lt;/code&gt; 来代换 &lt;code class=&quot;inline&quot;&gt;cata f&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;两种 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 定义都是 point-free 的，但是 &lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 的实现曾令笔者十分困惑，&lt;code class=&quot;inline&quot;&gt;c&lt;/code&gt; 的出现似乎毫无意义。直到若干年以后，我才大致理解了其中的含义。如果你避免了这样的柯里化，GHC 会生成更加高效的代码。柯里化函数必须携带它们的参数，在调用过程中必须追溯这些参数。而对于一个裸函数，调用的过程会简单得多（你可以访问 GHC 的 wiki 页面 &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects&quot;&gt;heap objects&lt;/a&gt; 来获得更多恶心的细节）。&lt;/p&gt;&lt;p&gt;当得知这一知识以后，我们就可以发现 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 的实现十分优雅，通过 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 的命名，我们可以像一个普通函数一样对待它，从而生成更加高效的代码。一般来说这样的优化，效果是微乎其微的，但是由于 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 在每层折叠操作中都会被调用，累积导致的效率损失对于一个库函数来说也是不可忽视的。&lt;/p&gt;&lt;h2&gt;结语&lt;/h2&gt;&lt;p&gt;我必须向 Edward Kmett 表示感谢，他的 &lt;code class=&quot;inline&quot;&gt;recursion-schemes&lt;/code&gt; 库优雅且富有启发性。同时我还要感谢 Austin Seipp，帮我检查了文章关于 GHC 代码生成部分的描述。&lt;/p&gt;&lt;p&gt;我希望能在下一篇文章中介绍 hylomorphisms and chronomorphisms，从而可以结束这一系列文章。感谢大家的耐心阅读！&lt;/p&gt;&lt;p&gt;[1]: 如果你对 kind 这一定义并不熟悉，你可以大致地认为，kind 描述了数据类型需要的参数个数，&lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 中不需要参数，所以 kind 为 &lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt;，需要一个参数的则为 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; *&lt;/code&gt;。需要更多参数的比如 &lt;code class=&quot;inline&quot;&gt;Either&lt;/code&gt;，kind 为 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; * -&amp;gt; *&lt;/code&gt;，对于 kind 更精准的描述是类型的类型，但是我们可以简单地将其理解为参数的个数表示。对于任意类型，在 GHCi 中可以使用 &lt;code class=&quot;inline&quot;&gt;:k&lt;/code&gt; 来查看它所属的类型。&lt;/p&gt;&lt;p&gt;[2]: 你可以从它所属的模块名 &lt;code class=&quot;inline&quot;&gt;Data.Functor.Foldable&lt;/code&gt; 中看到这样的暗示。这个类原本就叫 &lt;code class=&quot;inline&quot;&gt;Foldable&lt;/code&gt;，由于与标准库中的 &lt;code class=&quot;inline&quot;&gt;Foldable&lt;/code&gt; 重名，才改为 &lt;code class=&quot;inline&quot;&gt;Recursive&lt;/code&gt;。&lt;/p&gt;</description>
<author>禾木旁</author>
<guid isPermaLink="false">2018-11-30-51286145</guid>
<pubDate>Fri, 30 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>形式验证、依赖类型与动态类型</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-11-25-50792280.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50792280&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-22a53ae89319b99e314a4886dc6f882b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;aka 依赖类型传教文&lt;/p&gt;&lt;p&gt;推荐阅读&lt;a href=&quot;https://ice1000.org/lagda/DependentFunctionsVersusDynamicTyping.html&quot;&gt;我的博客的版本&lt;/a&gt;，你可以点击网页的代码块里面的变量名，可以跳转到定义。&lt;/p&gt;&lt;p&gt;前排提醒：你或许&lt;b&gt;不&lt;/b&gt;需要一个&lt;a href=&quot;https://baike.baidu.com/item/%E6%B8%B8%E6%A0%87%E5%8D%A1%E5%B0%BA&quot;&gt;游标卡尺&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;本文面向一切有任何形式编程经验的读者，将会使用 Agda 和极少量其他语言展示代码例子。 读不懂的代码可以借助附近的文字描述理解它的含义，所以不用担心语言问题。&lt;/p&gt;&lt;p&gt;一切规矩照旧，这篇文章是一个 Agda 模块，我们导入一些基本库：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;{-# OPTIONS --no-unicode #-}
{-# OPTIONS --without-K  #-}
{-# OPTIONS --safe       #-}
module DependentFunctionsVersusDynamicTyping where

open import lib.Basics
&lt;/code&gt;&lt;p&gt;这次，我们需要使用 &lt;a href=&quot;https://github.com/HoTT/HoTT-Agda/tree/master/core/lib&quot;&gt;HoTT-Agda&lt;/a&gt; 中的自然数类型的相关定义：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;open import lib.types.Nat
&lt;/code&gt;&lt;p&gt;泛化阶：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;variable i : ULevel
&lt;/code&gt;&lt;p&gt;本人承诺不会在这种面向非 Agda 专业人士的文章里使用 Unicode 。&lt;/p&gt;&lt;p&gt;在这个没有 &lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt; 的语言里，我们有时还是需要使用 &lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt; 的：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;data Nullable {i} (A : Type i) : Type i where
  nullptr : Nullable A
  new_    : A -&amp;gt; Nullable A
&lt;/code&gt;&lt;p&gt;这样， &lt;code class=&quot;inline&quot;&gt;nullptr&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;new 1&lt;/code&gt; 都是 &lt;code class=&quot;inline&quot;&gt;Nullable Nat&lt;/code&gt; 类型的实例了（这些符号马上就介绍）：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = nullptr :&amp;gt; Nullable Nat
_ = (new 1) :&amp;gt; Nullable Nat
&lt;/code&gt;&lt;h2&gt;依赖类型的数组&lt;/h2&gt;&lt;p&gt;定义一个数组类型，数组长度是类型的一部分：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;infixr 5 _cat_
data Vec {i} (A : Type i) : Nat -&amp;gt; Type i where
  []    : Vec A O
  _cat_ : forall {n} -&amp;gt; A -&amp;gt; Vec A n -&amp;gt; Vec A (S n)
&lt;/code&gt;&lt;p&gt;这样，我们可以有空数组，以自然数类型为例：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = [] :&amp;gt; Vec Nat 0
&lt;/code&gt;&lt;p&gt;其中， &lt;code class=&quot;inline&quot;&gt;:&amp;gt;&lt;/code&gt; 左边是一个表达式（在这里是 &lt;code class=&quot;inline&quot;&gt;[]&lt;/code&gt;），右边是它的类型。&lt;code class=&quot;inline&quot;&gt;_ =&lt;/code&gt; 表示把这个表达式赋值给一个无法被使用的变量，也就是丢掉这个表达式。 以这种形式写出来，我就可以在编译我的博客的时候让 Agda 编译器检查我的这些代码片段是否在类型上是正确的。&lt;/p&gt;&lt;p&gt;把代码编译成网页是 Agda 编译器的一个功能，我目前正在着手改善它的这个功能。 也就是说，如果我给我的博客写一个 &lt;code class=&quot;inline&quot;&gt;main&lt;/code&gt; 函数，我就可以运行我的博客了……&lt;/p&gt;&lt;p&gt;先不说这个，一个元素的数组，也就是一个元素和一个空数组连接的结果：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = (233 cat []) :&amp;gt; Vec Nat 1
&lt;/code&gt;&lt;p&gt;两个元素：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = (666 cat 233 cat []) :&amp;gt; Vec Nat 2
&lt;/code&gt;&lt;p&gt;观察发现，数组的类型 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 有两个参数，第一个参数是元素的类型 &lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt; ，也就是自然数，第二个是长度，这两个参数都是编译期已知的。 这个数组的定义常常被 Idris 语言的粉丝用于布道——因为它很安全，可以在编译的时候防止越界的情况发生，就像 C++ 程序员会推荐 &lt;code class=&quot;inline&quot;&gt;std::array&lt;/code&gt; 一样。 而由于 Agda 语言人气不足，别人布道的时间 Agda 程序员都写论文去了。&lt;/p&gt;&lt;p&gt;我们来尝试一下 Agda 的『小于』类型。小于关系是一个类型，如果我们有一个类型为 &lt;code class=&quot;inline&quot;&gt;a &amp;lt; b&lt;/code&gt; 的变量，那么我们就『证明』了 &lt;code class=&quot;inline&quot;&gt;a &amp;lt; b&lt;/code&gt;。 也就是说，我们可以弄出一个类型为 &lt;code class=&quot;inline&quot;&gt;3 &amp;lt; 4&lt;/code&gt; 的变量：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = ltS :&amp;gt; (3 &amp;lt; 4)
&lt;/code&gt;&lt;p&gt;也可以有 &lt;code class=&quot;inline&quot;&gt;114514 &amp;lt; 114516&lt;/code&gt; 类型的变量：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = ltSR ltS :&amp;gt; (114514 &amp;lt; 114516)
&lt;/code&gt;&lt;p&gt;但是我们无论如何也弄不出 &lt;code class=&quot;inline&quot;&gt;1 &amp;lt; 1&lt;/code&gt; 类型的对象——这是由 &lt;code class=&quot;inline&quot;&gt;&amp;lt;&lt;/code&gt; 的定义决定的，这里就不展开说了（涉及的东西有点多）。&lt;/p&gt;&lt;p&gt;因此，我们可以写出这样一个函数：它『从长度为 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 数组中获取第 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 个元素』，并要求调用这个函数的人额外传入一个 类型为 &lt;code class=&quot;inline&quot;&gt;n &amp;lt; m&lt;/code&gt; 的变量。&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;module GetAtIndex where
  _!!_&amp;lt;[_]&amp;gt; : {A : Type i} -&amp;gt; forall {l} -&amp;gt; Vec A l
          -&amp;gt; (n : Nat) -&amp;gt; n &amp;lt; l -&amp;gt; A
  (x cat _) !! O &amp;lt;[ _ ]&amp;gt; = x
  (_ cat a) !! S n &amp;lt;[ p ]&amp;gt; = a !! n &amp;lt;[ &amp;lt;-cancel-S p ]&amp;gt;
&lt;/code&gt;&lt;p&gt;这样，有了 &lt;code class=&quot;inline&quot;&gt;n &amp;lt; m&lt;/code&gt; 的证明，我们无论如何都能安全地从数组里拿出一个元素了。 举一个简单的调用的例子。这是一个测试用的数组：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;sampleList : Vec Nat 4
  sampleList = 0 cat 1 cat 2 cat 3 cat []
&lt;/code&gt;&lt;p&gt;我们试图取它的第 2 项，没有问题（下面的代码是让编译器试图验证『从刚才那个数组中取第 2 项得到的是 2』）：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = idp :&amp;gt; ((sampleList !! 2 &amp;lt;[ ltSR ltS ]&amp;gt;) == 2)
&lt;/code&gt;&lt;p&gt;试试第一项？&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = idp :&amp;gt; ((sampleList !! 1 &amp;lt;[ ltSR (ltSR ltS) ]&amp;gt;) == 1)
&lt;/code&gt;&lt;h2&gt;运行时错误&lt;/h2&gt;&lt;code lang=&quot;agda&quot;&gt;module RuntimeErrors where
  open GetAtIndex
&lt;/code&gt;&lt;p&gt;一个老生常谈（我在两个群里被问过了）的问题：如果下标和数组都是运行时获取的，编译器的验证不就凉了吗？&lt;/p&gt;&lt;p&gt;解决方法：在运行时进行判断——如果下标小于数组长度，那么在这样的条件下可以得到一个小于关系的证明， 就可以安全地进行函数调用。否则，你将不能调用这个函数，请自行处理非法输入。&lt;/p&gt;&lt;p&gt;给出一个简单的实现（库里面其实有一个 &lt;code class=&quot;inline&quot;&gt;Decidable&lt;/code&gt; 的版本，但是它里面用了 Unicode ，我不想用，所以就自己写了一个）。 首先，我们需要判断两个自然数的大小，并在小于的时候返回小于的证明，其他时候返回 &lt;code class=&quot;inline&quot;&gt;nullptr&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;lessThan : forall a b -&amp;gt; Nullable (a &amp;lt; b)
  lessThan O O = nullptr
  lessThan O (S b) = new O&amp;lt;S b 
  lessThan (S a) O = nullptr
  lessThan (S a) (S b) with lessThan a b
  ... | nullptr = nullptr
  ... | new x   = new &amp;lt;-ap-S x
&lt;/code&gt;&lt;p&gt;然后，我们就可以在不模式匹配、直接把参数拿来用的情况下，对 &lt;code class=&quot;inline&quot;&gt;_!!_&amp;lt;[_]&amp;gt;&lt;/code&gt; 进行调用了。 这个函数通过接收任意的自然数和任意的数组来模拟运行时无法保证的输入，并返回可能不存在的输出：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;runtimeInput : forall {m} -&amp;gt; Vec Nat m -&amp;gt; Nat -&amp;gt; Nullable Nat
  runtimeInput [] _ = nullptr
  runtimeInput{m}vn with lessThan n m
  ... | nullptr = nullptr
  ... | new x   = new (v !! n &amp;lt;[ x ]&amp;gt;)
&lt;/code&gt;&lt;p&gt;这个函数和 Java、JavaScript 函数就没什么可见的区别了，这也体现出了形式验证的一个小小的局限性。&lt;/p&gt;&lt;p&gt;但在运行时的情况下，我们还是能看出形式验证的好处的——类型签名里函数对参数需要满足的关系以非常清晰的形式呈现了（比如， &lt;code class=&quot;inline&quot;&gt;a &amp;gt; b&lt;/code&gt; 这种表达式），表达的也很简洁， 函数的调用者无需阅读文档即可安全地进行 API 调用，运行时不需要任何错误处理——编译的时候就能保证所有的错误得到处理，运行时当然是把这些东西全部都擦除掉了。&lt;/p&gt;&lt;h2&gt;稍微弱一点的类型系统&lt;/h2&gt;&lt;p&gt;看到这里，我们会想起，像 Java 和 JavaScript 里类似的函数都会在参数不合法的时候抛出一个异常。 因此，如果我们的程序要足够健壮，我们会选择：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;处理这个异常&lt;/li&gt;&lt;li&gt;判断下标是否小于长度，提前避免错误&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;具有证明命题能力的编程语言一般会强制程序员进行后者的操作，具有责任心的程序员会主动进行后者的操作， 绝大多数时间我们是忽略了这件事的——编译器、程序员、用户都没有去证明输入数据对程序来说一定合法。 当输入不合法时（尽管这很少发生），我们的程序会崩溃掉（&lt;b&gt;运行时错误&lt;/b&gt;），否则将正常运行。&lt;/p&gt;&lt;p&gt;运行时错误，从动态类型到静态类型的过程中已经大幅减少了。但这里可以看出，它还是存在的。&lt;/p&gt;&lt;p&gt;不知道 C++ 程序员有没有想到 SFINAE 呢？（笑）&lt;/p&gt;&lt;p&gt;但总而言之，把证明传来传去是一件很麻烦的事情，光是阅读命题本来就是额外工作，证明就更麻烦了。 像 C++ 的 SFINAE，在参数不合法的时候，如果不手动让编译器抛出一些可读的异常，编译器会产生大量的错误信息， 印在厕纸上都能用一年。&lt;/p&gt;&lt;p&gt;但是呢，会把程序写成这样的形式验证研究员都是垃圾（凭空制造复杂度），他们的思维都被限制了。&lt;/p&gt;&lt;p&gt;我们首先来看看大家觉得虽然邪恶但是写起来爽的『动态类型』。&lt;/p&gt;&lt;h2&gt;更浅显的话题&lt;/h2&gt;&lt;p&gt;程序员们常常对『动态类型和静态类型哪个更好』这一话题产生激烈的讨论。 这其实是一个完全没有意义的讨论，因为这首先是一个罗卜白菜的问题——两者都有能称得上是『优点』的地方； 其次不同的人对程序有不同的追求，有人想写出健壮可扩展的程序，有人只是想快速交付收钱； 再其次同一个人也有不同的需求，有时只是想批量处理一些文件，有时需要构建长期维护的大型项目。&lt;/p&gt;&lt;p&gt;对于简单的批处理需求，我们甚至会完全不考虑任何的可读性、可维护性、可扩展性、安全性、鲁棒性， 写出类似这样的代码（已经整理过了，再看不懂就是语言的问题）：&lt;/p&gt;&lt;code lang=&quot;perl&quot;&gt;while (my $line = &amp;lt;$imguiHeader&amp;gt;) {
  chomp $line;
  $_ = $line;
  if (m!^// dear imgui, (.*)$!) {
    my $commandPrefix = &#39;cd ../imgui &amp;amp;&amp;amp; git rev-parse&#39;;
    print &quot;--- Generating for dear-imgui version $1\n&quot;, &quot;--- Revision &quot;, `$commandPrefix --verify HEAD`;
    print &quot;--- Branch &quot;, `$commandPrefix --abbrev-ref HEAD`, &quot;---\n\n&quot;, &quot;local $moduleName = { _version = &#39;@{[ $1 =~ s/[^∙↓]//gr ]}&#39; }\n&quot;;
  }
  elsif (/^\s*enum\s(\w+)_/) {
    $currentEnum = $1;
    $currentEnumMangled = $currentEnum =~ s/^Im(Gui)?(.)([^\s]*)$/@{[ lc $2 ]}$3/r =~ s/Flags$//gr;
    # =~ s/([a-z])([A-Z])/$1.@{[ lc $2 ]}/gr;
    print &quot;\n&quot;, &#39;--{&#39;, &#39;{&#39;, &quot;{ $currentEnumMangled\n&quot;, &quot;---\@type _$currentEnumMangled\n&quot;, &quot;local $currentEnumMangled = {}\n&quot;
  }
  elsif (length $currentEnum) {
    if (/\}/) {
      print &quot;$moduleName.$currentEnumMangled = $currentEnumMangled\n&quot;;
      print &quot;$currentEnumMangled = nil\n&quot;, &#39;--}&#39;, &#39;}&#39; &quot;} $currentEnumMangled\n&quot;;
      $currentEnum = &#39;&#39;; $previousDefault = 0;
    }
    elsif (m!^\s*${currentEnum}_(\w+)((\s*=\s*([^,/]+))?),?\s*(//\s*(.*))?!) {
      print &quot;\n--- $6\n&quot; if $5 and length $6;
      $mangledName = length $1 == 1 ? &quot;_$1&quot; : $1;
      $value = $2 ? calculate $4 : $previousDefault++;
      print &quot;$currentEnumMangled.$mangledName = &quot;, $value, &quot;\n&quot;;
    }
    elsif (m!^\s*//(.*)!) { print &quot;---$1\n&quot; }
  }
}&lt;/code&gt;&lt;p&gt;这样的代码完全是一个精雕细琢的艺术品——它的每一个字符都是我（没错这是我写的……用来提取一段 C++ 代码中的一部分定义并翻译成 Lua） 小心翼翼写出来的，稍微改一点就会出错，输入数据有一点点变化也可能出错，静态分析工具对这个代码的正确性完全没有保障（Perl 的解释器在运行你的代码的时候也不知道你的程序的目的，只是一行一行地运行而已）。&lt;/p&gt;&lt;p&gt;动态类型往往因为其灵活性被一些程序员（不是我）喜欢。比如我们可以写出这样的 JavaScript 程序：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;const Error = {}
const getAtIndex = (a, n) =&amp;gt; n &amp;lt; a.length ? a[n] : Error;&lt;/code&gt;&lt;p&gt;简单地运行：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;&amp;gt; getAtIndex([1, 2, 3], 2)
&amp;lt; 3
&amp;gt; GetAtIndex([], 1)
&amp;lt; {}&lt;/code&gt;&lt;p&gt;这个 &lt;code class=&quot;inline&quot;&gt;getAtIndex&lt;/code&gt; 接收一个数组和一个整数，返回『有时是一个数组元素，有时是 &lt;code class=&quot;inline&quot;&gt;Error&lt;/code&gt;』。 用 TypeScript 描述一下它的类型，就是：&lt;/p&gt;&lt;code lang=&quot;ts&quot;&gt;&amp;lt;a&amp;gt;(a[], number): a|Error&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;而我们调用这个函数，它到底会返回什么类型，我们也必须看它的实现才能知道。 返回 &lt;code class=&quot;inline&quot;&gt;Error&lt;/code&gt; 只是方便起见，我们大可使用异常来代替返回一个表达异常的对象。 但它做到了一点——在我们不想处理错误的时候，我们可以不处理错误，让运行时炸。 在我们想处理错误的时候，我们可以处理错误。&lt;/p&gt;&lt;p&gt;但这给了我们一个启发。或许我们可以实现这样的函数：在很明显没有错误的时候，我们可以不处理错误。 在有可能错误的时候，我们需要处理错误。&lt;/p&gt;&lt;p&gt;或许有人会说，我们不还有异常吗？但首先异常这一概念首先本身就足够『运行时』， 我们对什么样的函数会抛出什么样的异常都一无所知。Java 的 Checked Exception 作为一个例外，是静态的异常， &lt;b&gt;但是这种语法结构和返回带有错误信息的类型&lt;/b&gt; （可以理解为 Haskell 的 &lt;code class=&quot;inline&quot;&gt;Either&lt;/code&gt;， Rust 的 &lt;code class=&quot;inline&quot;&gt;Result&lt;/code&gt;） &lt;b&gt;是&lt;a href=&quot;http://www.yinwang.org/blog-cn/2017/05/23/kotlin&quot;&gt;同构&lt;/a&gt;的&lt;/b&gt;（这篇文章本身说的很有道理，但请不要看它所引用的《给 Java 说句公道话》）。&lt;/p&gt;&lt;blockquote&gt;首先，写 C# 代码时最让我头痛的事情之一，就是 C# 没有 CE。每调用一个函数（不管是标准库函数，第三方库函数，还是队友写的函数，甚至我自己写的函数），我都会疑惑这个函数是否会抛出异常。由于 C# 的函数类型上不需要标记它可能抛出的异常，为了确保一个函数不会抛出异常，你就需要检查这个函数的源代码，以及它调用的那些函数的源代码……&lt;br&gt;也就是说，你必须检查这个函数的整个“调用树”的代码，才能确信这个函数不会抛出异常。这样的调用树可以是非常大的。说白了，这就是在用人工对代码进行“全局静态分析”，遍历整个调用树。这不但费时费力，看得你眼花缭乱，还容易漏掉出错。显然让人做这种事情是不现实的，所以绝大部分时候，程序员都不能确信这个函数调用不会出现异常。&lt;/blockquote&gt;&lt;p&gt;在静态类型中，我们要么使用静态的带错误信息的返回类型（强制检查错误，即使很明显的正确的代码也必须处理错误）、要么使用异常（静态变动态，你干啥不去用 Python）。&lt;/p&gt;&lt;p&gt;而且，刚才那段 JavaScript 根本不可能在静态类型语言里实现（当然，这里没有考虑支持和类型的语言。但是要考虑到 支持和类型的编程语言大部分都是渐进类型或者以动态类型编程语言为目标语言的编程语言）——我们写不出一个同时有两种可能的返回类型的语言。&lt;/p&gt;&lt;p&gt;也就是说，动态类型能做（即使做的不完美，比如那个 &lt;code class=&quot;inline&quot;&gt;getAtIndex&lt;/code&gt; 并不会强制你处理异常，即使可能异常）的事静态类型做不到； 静态类型能做动态类型做不到的事就多了去了，在绝大多数情况下使用静态类型还是能带来远高于动态类型的编程体验的（ 包括 IDE 补全重构跳转、尽可能减少了类型错误等），这里就略过不提了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;难道鱼和熊掌真的不可兼得吗？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;不，小孩才做选择。&lt;/p&gt;&lt;h2&gt;我全都要&lt;/h2&gt;&lt;code lang=&quot;agda&quot;&gt;module IQuanDouWant where
  open RuntimeErrors&lt;/code&gt;&lt;p&gt;这时我们就需要用到依赖类型了。&lt;/p&gt;&lt;p&gt;我们除了传入证明作为参数之外，还可以使用依赖函数！&lt;/p&gt;&lt;p&gt;我们的 &lt;code class=&quot;inline&quot;&gt;getAtIndex&lt;/code&gt; 函数，在下标越界的时候返回 &lt;code class=&quot;inline&quot;&gt;Error&lt;/code&gt;，其他时候返回正常的值。 我们先定义一个表达错误的类型：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;data ???? : Type0 where ??? : ????
&lt;/code&gt;&lt;p&gt;我们的函数 &lt;code class=&quot;inline&quot;&gt;getAtIndex&lt;/code&gt;，返回的类型，是根据两个参数决定的。 所以，我们需要先写一个函数，接收两个自然数，返回『我们的 &lt;code class=&quot;inline&quot;&gt;getAtIndex&lt;/code&gt; 的返回类型』， 也就是说如果左边大于右边，就返回『自然数』这个类型，否则返回表达错误的类型。 请注意，只有带有较好的依赖类型支持的类型系统才能做到这种事。如果一个语言声称自己支持依赖类型， 你可以问问他能不能写出这样的代码。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;returnType : (_ _ : Nat) -&amp;gt; Type0
  returnType O _ = ????
  returnType (S _) O = Nat
  returnType (S n) (S m) = returnType n m
&lt;/code&gt;&lt;p&gt;然后，我们的 &lt;code class=&quot;inline&quot;&gt;getAtIndex&lt;/code&gt; 需要返回的，就是这个类型。&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;getAtIndex : forall {m} -&amp;gt; (v : Vec Nat m) -&amp;gt; (n : Nat) -&amp;gt; returnType m n
  getAtIndex [] _ = ???
  getAtIndex (x cat _) O = x
  getAtIndex (_ cat v) (S n) = getAtIndex v n
&lt;/code&gt;&lt;p&gt;看看看！这个函数的实现真的好简单啊！&lt;/p&gt;&lt;p&gt;我们试试证明它的性质？我们先传入合法的参数，看看是不是就直接返回了数组的元素：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;open GetAtIndex using (sampleList)
  _ = idp :&amp;gt; (getAtIndex sampleList 2 == 2)
  _ = idp :&amp;gt; (getAtIndex sampleList 1 == 1)
&lt;/code&gt;&lt;p&gt;真的耶！那如果是超过长度上限的下标，是不是就会返回那个错误类型呢？&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = idp :&amp;gt; (getAtIndex sampleList 233 == ???)
&lt;/code&gt;&lt;p&gt;是的！&lt;/p&gt;&lt;p&gt;这个函数的返回类型真的在变耶！而且这是非常非常纯正的静态类型编程哦！&lt;/p&gt;&lt;p&gt;你看，静态类型做不到的事，依赖类型做到了。动态类型没法编译期进行类型检查，依赖类型可以。&lt;/p&gt;&lt;h2&gt;实际应用&lt;/h2&gt;&lt;code lang=&quot;text&quot;&gt;module FSharpLang where

  -- ...
&lt;/code&gt;&lt;p&gt;就懒得写了，毕竟本来就是我的另一篇博客。这是一个依赖函数的经典应用—— &lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://ice1000.org/2018/08/04/TypeSafePrintf/&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;。 它的类型是：&lt;code class=&quot;inline&quot;&gt;String -&amp;gt; ??&lt;/code&gt;，其中 &lt;code class=&quot;inline&quot;&gt;??&lt;/code&gt; 具体的值，取决于 &lt;code class=&quot;inline&quot;&gt;String&lt;/code&gt; 参数中有多少个 &lt;code class=&quot;inline&quot;&gt;%d&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;%c&lt;/code&gt; 等。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;啊，今泉影狼真可爱啊。&lt;/p&gt;</description>
<author>兴趣使然千里冰封</author>
<guid isPermaLink="false">2018-11-25-50792280</guid>
<pubDate>Sun, 25 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>我的 Linux 再也滚不挂了—— NixOS 桌面试用</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-11-22-50623869.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50623869&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-152bfce18c290103b65114d7e273ce1e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;之前在虚拟机里用了一段时间的 NixOS。昨天终于在笔记本上抛弃了“正常”发行版的带镜像下载速度，安装了 NixOS。那个 Fastly 的 CDN 稍微 slowly 点就 slowly 点吧……&lt;/p&gt;&lt;h2&gt;安装&lt;/h2&gt;&lt;p&gt;（本文不是 NixOS 安装和配置教程。安装教程请参考文档。）&lt;/p&gt;&lt;p&gt;NixOS 没有像 Ubuntu 或者 Fedora 那样的完全一站式的安装程序，所以一开始和 Arch 有点像，需要自己分区然后 mount 上。这一步参照 manual 就可以了。&lt;/p&gt;&lt;p&gt;之后 nixos-generate-config 命令会从当前挂载的分区和存在的硬件生成一个 /etc/nixos/hardware-configuration.nix 和一个基础系统的 /etc/nixos/configuration.nix。&lt;/p&gt;&lt;p&gt;默认的 configuration.nix 里面注释写的是举例形式的，比较简洁但是不难懂。先把网络和图形界面配置上：&lt;/p&gt;&lt;code lang=&quot;nixos&quot;&gt;networking.hostName = &quot;&amp;lt;It&#39;s important to pick a good name&amp;gt;&quot;; # https://www.xkcd.com/910/
networking.networkmanager.enable = true;
services.xserver.displayManager.sddm.enable = true;
services.xserver.desktopManager.plasma5.enable = true;&lt;/code&gt;&lt;p&gt;（Bootloader 默认是 systemd-boot，保留即可，换 GRUB 也行。）（题图是我的 Bootloader 和内核相关配置）&lt;/p&gt;&lt;p&gt;然后 nixos-install 就可以了，各种乱七八糟的自动按照 configuration.nix 配置好，最后让你设一个 root 密码，之后重启进系统就可以了。这一步比 Arch 简单多了。&lt;/p&gt;&lt;p&gt;在这里我们已经在体验 NixOS 系统配置的“一条龙服务”。在写下一行配置的时候，里面就包括了软件依赖、配置文件、Systemd 的 unit 文件等内容。&lt;/p&gt;&lt;p&gt;像这种声明式的系统配置，一大好处就是更加紧凑，更容易复现。日常使用上最明显的一点就是，我们再也不用担心忘了系统配置都改了什么了。&lt;/p&gt;&lt;h2&gt;使用&lt;/h2&gt;&lt;p&gt;和预料中的没有太大的差别。用户账户用什么东西直接 nix-env 安装就好，使用上和一般的包管理器比较接近，只是不需要 sudo 就可以装东西。实现上是在系统全局安装好后 symlink 到 ~/.nix-profile 下，成为一个“prefix”的样子，还是比较科学的。&lt;/p&gt;&lt;p&gt;我加了个 alias：&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;alias nixpkgs=&quot;nix-env -f &#39;&amp;lt;nixpkgs&amp;gt;&#39;&quot;&lt;/code&gt;&lt;p&gt;系统配置的话，用 /etc/nixos/configuration.nix 真是简直不能再爽。我的笔记本是 SSD 的，所以配置了一个 fstrim。&lt;/p&gt;&lt;code lang=&quot;nixos&quot;&gt;services.fstrim = {
  enable = true;
  interval = &quot;tuesday&quot;;  
};&lt;/code&gt;&lt;p&gt;SDDM 的 HiDPI 支持默认确实是打开的，不过貌似没有检测出我的机器需要 1.5x，所以加点配置：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;services.xserver.displayManager.sddm.extraConfig = &#39;&#39;
  [X11]
  ServerArguments=-dpi 144
&#39;&#39;;&lt;/code&gt;&lt;p&gt;（KDE 里面 Scale Display 到 1.5x，然后底栏高度拉高点就好了，不需要系统配置）&lt;/p&gt;&lt;p&gt;文本编辑器 Vim Emacs Nano 啥的默认统统没有，随手开个默认 EDITOR。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;programs.vim.defaultEditor = true;&lt;/code&gt;&lt;p&gt;ucode 啥的，我才不记得什么 initrd 呢，直接：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;hardware.cpu.intel.updateMicrocode = true;&lt;/code&gt;&lt;h2&gt;发行版&lt;/h2&gt;&lt;p&gt;Nixpkgs 里面的包少……吗？&lt;/p&gt;&lt;p&gt;有一些标记为非自由软件的包默认不会显示，安装也会失败。（nix-env 直接什么都不做……这应该是个 bug）如果需要用的话必须手动允许：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;nixpkgs.config.allowUnfree = true;&lt;/code&gt;&lt;p&gt;Nixpkgs 包总体来说应该还算可以吧……除了有大量常见自由软件以外（KDE 算不算……），许多小众的包和非自由软件 patched binary 的包在 Nixpkgs 里都能找到：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先就是整个 Haskell 的 Hackage 都在 Nixpkgs 里面，贡献了很大的包的总数……&lt;/li&gt;&lt;li&gt;Sarasa Gothic 字体都有&lt;a href=&quot;https://github.com/NixOS/nixpkgs/blob/master/pkgs/data/fonts/sarasa-gothic/default.nix&quot;&gt;打包&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;连 Mathematica 都有&lt;a href=&quot;https://github.com/NixOS/nixpkgs/blob/master/pkgs/applications/science/math/mathematica/default.nix&quot;&gt;打包&lt;/a&gt;。从 binary 开始 PatchELF……&lt;/li&gt;&lt;li&gt;VSCode 确实有，但是只有 binary 的没有 OSS 的。&lt;/li&gt;&lt;li&gt;Chrome 和 Chromium 倒是都有。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为什么 binary 要 PatchELF 呢？如果尝试运行一下就会发现有很多 so 找不到。&lt;/p&gt;&lt;p&gt;容易发现，NixOS 是缺少很多 FHS 目录的。比如 /bin 下只有一个 /bin/sh，/usr 下只有一个 /usr/bin/env，其余真正的软件都分开存放在不同的目录下，然后系统配置是 symlink 出来的，放在 /run/current-system。既然 /usr/lib 啥的都没有，能找到库就怪了。&lt;/p&gt;&lt;p&gt;这种隔离式的设计事实上帮助实现了原子更新和快速回滚。从启动界面上列出的不同版本的系统 profile 就可以看出，NixOS 是一个可以字面意义上“恢复上一次正确的配置”的发行版（趴）。而且配置 profile 之间的切换不需要复制好多文件之类的，所以非常迅速。&lt;/p&gt;&lt;p&gt;所以是不是左传可以在此立下 NixOS 滚不挂 Flag 一枚 23333&lt;/p&gt;&lt;p&gt;（实在不行，进启动盘重新 nixos-install 一遍，反正也是按照 configuration.nix 安装的）&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;所以你们可能关心的问题是：到底要不要用 NixOS。&lt;/p&gt;&lt;p&gt;如果你不需要 Ubuntu 那种的开箱即用的，觉得 Arch 那样的自己动手可以接受，喜欢 Gentoo 的可配置性，又不想自己完全编译整个世界，并且觉得所有系统配置全都由统一格式写出来的可复现性确实很棒，并且觉得那帮人为了 portable 和轻量级，自己做了个 Nix 语言可以接受的话，NixOS 可能就是专门为你设计的。&lt;/p&gt;&lt;p&gt;哦对，如果你特别想用 Lisp 或者特别想坚持用自由软件的话出门左转 GuixSD……&lt;/p&gt;&lt;h2&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://nixos.org/nixos/manual&quot;&gt;NixOS manual&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;我的 /etc/nixos/configuration.nix&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/dramforever/config/blob/master/nixos/configuration.nix&quot;&gt;https://github.com/dramforever/config/blob/master/nixos/configuration.nix&lt;/a&gt;&lt;/p&gt;</description>
<author>dram</author>
<guid isPermaLink="false">2018-11-22-50623869</guid>
<pubDate>Thu, 22 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Recursion Schemes（五）自未来而来</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-11-14-49814311.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49814311&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e5a2a9858bfa0c0e317c6943a84edb5b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;控制未来的 Futumorphism&lt;/h2&gt;&lt;p&gt;通过翻转箭头的技巧，我们可以获得 fold 的对偶形式 unfold，同理我们可以翻转箭头来获得 histomorphism 的对偶形式。不过首先为了获得 &lt;code class=&quot;inline&quot;&gt;histo&lt;/code&gt; 的对偶形式，我们要先得到 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt; 的对偶形式。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt; 结构中我们保存了 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;f (Attr f a)&lt;/code&gt; 两部分，而对偶的 &lt;code class=&quot;inline&quot;&gt;CoAttr&lt;/code&gt; 保存一个 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; &lt;i&gt;或者&lt;/i&gt; 一个 &lt;code class=&quot;inline&quot;&gt;f (CoAttr f a)&lt;/code&gt;，它的定义如下：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data CoAttr f a
  = Automatic a
  | Manual (f (CoAttr f a))&lt;/code&gt;&lt;p&gt;所以 CV-algebra 的对偶形式 CV-coalgebra 为：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type CVCoalgebra f a = a -&amp;gt; f (CoAttr f a)&lt;/code&gt;&lt;p&gt;注意 &lt;code class=&quot;inline&quot;&gt;CoAttr&lt;/code&gt; 的构造子，为什么命名是 &lt;code class=&quot;inline&quot;&gt;Automatic&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Manual&lt;/code&gt; 呢？因为对于 &lt;code class=&quot;inline&quot;&gt;Manual&lt;/code&gt; 我们需要手动指定在这一层级的 unfold 操作该如何进行。与之相反的是，&lt;code class=&quot;inline&quot;&gt;Automatic&lt;/code&gt; 则自动对该层级进行 unfold。这也是 Futumorphism 命名的由来，CV-coalgebra 可以决定，未来如何进行 unfold。（futumorphism 实际上词源是混杂的，futu 是拉丁语中的前缀，而 morpho 则是希腊语中的后缀，我们实际上有很多词都是词源混杂的，比如 television，automobile 等）&lt;/p&gt;&lt;p&gt;与前面我们介绍的 &lt;code class=&quot;inline&quot;&gt;ana&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;apo&lt;/code&gt; 类似，futumorphism 接受一个 coalgebra，一个种子值 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，并返回一个表达式 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;futu :: Functor f =&amp;gt; CVCoalgebra f a -&amp;gt; a -&amp;gt; Term f&lt;/code&gt;&lt;p&gt;我们使用翻转箭头推导了 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;para&lt;/code&gt; 的对偶形式，我们继续沿用当时的技巧，将 &lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 变为 &lt;code class=&quot;inline&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt; 变为 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;futu :: Functor f =&amp;gt; CVCoalgebra f a -&amp;gt; a -&amp;gt; Term f
futu f = In &amp;lt;&amp;lt;&amp;lt; fmap _worker &amp;lt;&amp;lt;&amp;lt; f

/Users/patrick/src/morphisms/src/Main.hs:28:32: error:
    • Found hole: ‘_worker’ with type :: CoAttr f a -&amp;gt; Term f&lt;/code&gt;&lt;p&gt;这也与 &lt;code class=&quot;inline&quot;&gt;histo&lt;/code&gt; 中 worker 函数的类型 &lt;code class=&quot;inline&quot;&gt;Term f -&amp;gt; Attr f a&lt;/code&gt; 照应了起来。所以 futu 的定义非常符合直觉：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;futu :: Functor f =&amp;gt; CVCoalgebra f a -&amp;gt; a -&amp;gt; Term f
futu f = In &amp;lt;&amp;lt;&amp;lt; fmap worker &amp;lt;&amp;lt;&amp;lt; f where
    worker (Automatic a) = futu f a        -- 继续本层级的递归
    worker (Manual g) = In (fmap worker g) -- 忽略本层的，直接进入更深层&lt;/code&gt;&lt;p&gt;当我们遇到 &lt;code class=&quot;inline&quot;&gt;Automatic&lt;/code&gt; 时，我们继续进行递归。而当遇到 &lt;code class=&quot;inline&quot;&gt;Manual&lt;/code&gt; 时，我们直接生成 &lt;code class=&quot;inline&quot;&gt;Term f&lt;/code&gt;，以作为 &lt;code class=&quot;inline&quot;&gt;futu&lt;/code&gt; 的返回值。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;futu&lt;/code&gt; 相比于 &lt;code class=&quot;inline&quot;&gt;apo&lt;/code&gt;，有着更强的表达能力，&lt;code class=&quot;inline&quot;&gt;apo&lt;/code&gt; 允许我们在不同的位置决定是否要继续进行 unfold，对于每个函子 f，我们都可决定是否要进行 unfold，&lt;code class=&quot;inline&quot;&gt;apo&lt;/code&gt; 提供了一个二元选择，&lt;code class=&quot;inline&quot;&gt;Left&lt;/code&gt; 为停止递归，而 &lt;code class=&quot;inline&quot;&gt;Right&lt;/code&gt; 则继续递归。而 &lt;code class=&quot;inline&quot;&gt;futu&lt;/code&gt;，则允许我们自己构造任意多层，使得我们可以自己指定它的形状，或委托给下一层的 unfold 执行。&lt;/p&gt;&lt;p&gt;这是一种十分有趣的 unfold 模式，一个只返回 &lt;code class=&quot;inline&quot;&gt;Automatic&lt;/code&gt; 的 CV-coalgebra 会进入死循环，例如一个生产所有自然数的 unfold。所以我们可以直接了当地判定我们的 unfold 操作是否会终止。&lt;/p&gt;&lt;p&gt;可能有的读者会发现这一切有点像元胞自动机，这种感觉是对的，CV-coalgebras 描述了树型自动机，coalgebras 描述了有限状态自动机，而 R-coalgebras 描述了流式自动机，我们会运用这一点定义一个 CV-coalgebra 的例子，一个随机植物生命[1]。&lt;/p&gt;&lt;h2&gt;Futumorphism 园艺学&lt;/h2&gt;&lt;p&gt;首先我们定义一棵植物。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Plant a
  = Root a     -- 植物的根
  | Stalk a    -- 植物的枝干
  | Fork a a a -- 枝干可以分叉
  | Bloom      -- 最后植物会在顶端开花
    deriving (Show, Functor)&lt;/code&gt;&lt;p&gt;下面我们定义一下植物生长的规则（你看，与树型自动机多么相似）：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;1. 植物从地面开始生长
2. 植物的高度不超过10。
3. 植物随机的选择分叉，继续生长，或者开花。
4. 每次植物的分叉后必须其中一支为花，另外两支为枝干。&lt;/code&gt;&lt;p&gt;根据上述规则我们定义一下植物的行为：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Action
  = Flower  -- 停止生长
  | Upwards -- 生长为枝干
  | Branch  -- 生长为分叉&lt;/code&gt;&lt;p&gt;因为我们需要跟踪高度并进行随机生成，我们的 unfold 操作会在一个包含高度和随机数生成器的结构上完成：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Seed = Seed
    { height :: Int
    , rng    :: Random.StdGen
    }&lt;/code&gt;&lt;p&gt;下面我们需要定义生长函数 &lt;code class=&quot;inline&quot;&gt;grow&lt;/code&gt;，它随机生成 1 到 5 之间的整数，1 为开花，2 为分支，其余则继续生长，并使用 &lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt; 值来记录高度。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;grow :: Seed -&amp;gt; (Action, Seed, Seed)
grow seed@(Seed h rand) = (choose choice, left { height = h + 1}, right { height = h + 1})
  where (choice, _) = Random.randomR (1 :: Int, 5) rand
        (leftR, rightR) = Random.split rand
        left = Seed h leftR
        right = Seed h rightR
        choose 1 = Flower
        choose 2 = Branch
        choose _ = Upwards&lt;/code&gt;&lt;p&gt;下面我们要定义 CV-coalgebra，它接受一个 &lt;code class=&quot;inline&quot;&gt;Seed&lt;/code&gt; 并返回一个包含 &lt;code class=&quot;inline&quot;&gt;CoAttr&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;Plant&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;sow seed =
  let (action, left, right) = grow seed
  in case (action, height seed) of
    (_, 0)       -&amp;gt; Root (Automatic left)
    (_, 10)      -&amp;gt; Bloom
    (Flower, _)  -&amp;gt; Bloom
    (Upwards, _) -&amp;gt; Stalk (Automatic right)
    (Branch, _)  -&amp;gt; Fork (Manual (Stalk (Automatic left)))
                         (Manual Bloom)
                         (Manual (Stalk (Automatic right)))&lt;/code&gt;&lt;p&gt;注意这里对于 Fork 的处理，我们使用了 &lt;code class=&quot;inline&quot;&gt;Manual&lt;/code&gt; 来保证分支时的生成枝干是符合规则的，我们使用 futumorphism 在 11 行代码里就干净清晰地解决了这个问题。&lt;/p&gt;&lt;p&gt;最后是我们的 &lt;code class=&quot;inline&quot;&gt;main&lt;/code&gt; 函数，我们获取一个随机数生成器，通过 &lt;code class=&quot;inline&quot;&gt;futu&lt;/code&gt; 函数生成一个 &lt;code class=&quot;inline&quot;&gt;Term Plant&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;main :: IO ()
main = do
  rnd &amp;lt;- newStdGen
  let ourPlant :: Term Plant
      ourPlant = futu sow (Seed 0 rnd)&lt;/code&gt;&lt;p&gt;最后我们使用一个打印函数来对结果进行可视化（这里省略了实现，读者可以使用 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 来自己尝试一下，这里的渲染似乎受是否为等宽字体的影响，如果排版不太正常请见谅）：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;⚘
| ⚘    ⚘          ⚘
|⚘|    |          |
└─┘    |          |
 |     |          |      ⚘
 |  ⚘  |          |      |
 └─────┘          |   ⚘  |
    |             └──────┘
    |        ⚘      |
    └───────────────┘
             |
             _&lt;/code&gt;&lt;p&gt;最后的一点细节：正如 anamorphism 可以被 apomorphism 所表示，futumorphism 也可以表示 anamorphisms 和 apomorphism：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;ana :: (Functor f) =&amp;gt; Coalgebra f a -&amp;gt; a -&amp;gt; Term f
ana f = futu (fmap Automatic &amp;lt;&amp;lt;&amp;lt; f)

apo :: Functor f =&amp;gt; RCoalgebra f a -&amp;gt; a -&amp;gt; Term f
apo f = futu (fmap (either termToCoattr Automatic) &amp;lt;&amp;lt;&amp;lt; f)
  where termToCoattr = Manual &amp;lt;&amp;lt;&amp;lt; fmap termToCoattr &amp;lt;&amp;lt;&amp;lt; out&lt;/code&gt;&lt;h2&gt;Comonad 隆重登场&lt;/h2&gt;&lt;p&gt;上文我们介绍了 histomorphism 和 futumorphism。histomorphism 允许我们查询我们之前计算的结果，而 futumorphism 允许我们决定未来某些展开位置的形状。类似的定义不仅仅是 recursion scheme 的一种，它蕴含着某些更加基础和深远的性质。&lt;/p&gt;&lt;p&gt;实际上，我们之前 &lt;code class=&quot;inline&quot;&gt;CoAttr&lt;/code&gt; 的定义与 &lt;code class=&quot;inline&quot;&gt;Free&lt;/code&gt; monad 是等价的。而 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt; 的定义则和 &lt;code class=&quot;inline&quot;&gt;Cofree&lt;/code&gt; comonad 等价。&lt;/p&gt;&lt;p&gt;一般我们将 &lt;code class=&quot;inline&quot;&gt;Free&lt;/code&gt; （即 &lt;code class=&quot;inline&quot;&gt;CoAttr&lt;/code&gt;）表达为两个构造子：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Free f a
    = Pure a
    | Impure (f (Free f a))&lt;/code&gt;&lt;p&gt;而 &lt;code class=&quot;inline&quot;&gt;Cofree&lt;/code&gt; comonad，则被表达为一个中缀的构造函数：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Cofree f a = a :&amp;lt; (f (Cofree f a))&lt;/code&gt;&lt;p&gt;在数个 Haskell 生态系统中，&lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;para&lt;/code&gt; 就实现的方法非常类似。而 &lt;code class=&quot;inline&quot;&gt;histo&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;futu&lt;/code&gt; 则并非如此，Edward Kmett 在 &lt;a href=&quot;https://hackage.haskell.org/package/recursion-schemes&quot;&gt;recursion-schemes&lt;/a&gt; 包中使用 &lt;code class=&quot;inline&quot;&gt;Free&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Cofree&lt;/code&gt; 来协助实现（来源于 &lt;a href=&quot;https://hackage.haskell.org/package/free&quot;&gt;free&lt;/a&gt;），&lt;code class=&quot;inline&quot;&gt;fixplate&lt;/code&gt; 则使用了与 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt; 不同的定义，不是将递归部分与值类型打包在一起，而是让 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 接受一个更泛化的 &lt;code class=&quot;inline&quot;&gt;Ann&lt;/code&gt; 类型。&lt;code class=&quot;inline&quot;&gt;compdata&lt;/code&gt; 则更加复杂一点，它使用另外的 typeclass &lt;code class=&quot;inline&quot;&gt;compdata&lt;/code&gt; 来提供节点的属性，但它们的本质是一致的，每一种都是等价的。&lt;/p&gt;&lt;p&gt;free monad 和 cofree comonad 这组对偶形式，代表着函数式编程中的一组有趣的结构。宥于笔者的能力与精力，这里无法对它们进行详细的介绍。这里推荐 &lt;a href=&quot;https://twitter.com/GabrielG439&quot;&gt;Gabriel Gonzales&lt;/a&gt; 的博客 &lt;a href=&quot;http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html&quot;&gt;free monads&lt;/a&gt;，以及 &lt;a href=&quot;https://twitter.com/sigfpe&quot;&gt;Dan Piponi&lt;/a&gt; 的文章 &lt;a href=&quot;http://blog.sigfpe.com/2014/05/cofree-meets-free.html&quot;&gt;cofree comonad&lt;/a&gt;，当然还有 Oleg Kiselyov 在 free 和 freer monad 上 的&lt;a href=&quot;http://okmij.org/ftp/Computation/free-monad.html&quot;&gt;工作&lt;/a&gt;。在我们探寻递归的本质构造时，与 free monad 这一组不同来源的深刻的概念产生了联系。这正是范畴论为函数式编程中提供统一优美的框架的又一有效例证，而这本身就足够激荡人心。&lt;/p&gt;&lt;p&gt;我要感谢 Rob Rix，他是我完成文章的关键助力。 Colin Barrett，在我困扰的时候一直为我提供各种资料。以及 Manuel Chakaravarty，为我进行校对。Jeanine Adkisson，对 futumorphism 的叙述进行校对。 Greg Pfiel，Scott Vokes 和 Josh Bohde 也对草稿提出了许多有价值的建议。Mark Needham，Ian Griffiths，How Si Wei 和 Bryan Grounds，在初版的文章中找到了一些重要的缺陷。这里对他们表示深深的感谢。&lt;/p&gt;&lt;p&gt;下一章中，我们将讨论 recursion scheme 最激动人心的部分，它们服从的规律，以及 unfold 与 fold 的组合：hylomorphism 和 chronomorphism。&lt;/p&gt;&lt;h2&gt;译者的话&lt;/h2&gt;&lt;p&gt;实际上，作者在下篇文章中并未讨论 hylomorphism 和 chronomorphism，下一篇文章主要讨论了 recursion-schemes 库实践上与之前的理论的联系与区别。hylomorphism 和 chronomorphism 会在下下一篇文章中介绍。&lt;/p&gt;&lt;p&gt;抱歉从上一篇更新到现在中间拖了如此久的时间，中间读者如果有哪些知识遗忘了可以看一下之前文章回顾一下。拖更一方面是工作比较忙，另一方面也是在考虑之后专栏的坑要怎么挖，目前终于找到了一些头绪，目前考虑除了一些纯概念上的介绍，也穿插一些偏工程上的文章，毕竟这还是一个方向编程领域的专栏。&lt;/p&gt;&lt;p&gt;如果有什么意见和建议欢迎跟我交流，感谢大家的耐心阅读！&lt;/p&gt;&lt;p&gt;[1]: 一个随机植物需要一个随机“种子”。&lt;/p&gt;</description>
<author>禾木旁</author>
<guid isPermaLink="false">2018-11-14-49814311</guid>
<pubDate>Wed, 14 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>CPython 源码分析 - 0</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-11-12-49451546.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49451546&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-37fb5c99681f9c8f08d017ab823a0f5d_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;之前和几个 py 在做一个的 Python 编译器的前端项目 —— &lt;a href=&quot;https://github.com/Xython/YAPyPy&quot;&gt;XPython/YAPyPy&lt;/a&gt;（目前还在施工之中，但是 codegen 都做好了，上次跑了一个 sklearn 的测试脚本也都能跑通了），在做的期间了解了很多和 py、cpy 相关实现方式的知识。感觉 CPython 作为一个大型 C 项目结构和功能还是非常清晰的，所以说打算索性就把 CPython 的代码都看一遍好了。&lt;br&gt;&lt;br&gt;相关的资料中 《Python源码剖析》据说不错，但是书中的 py 版本有点老，不过读者也可以互为参考。还有就是这个系列里面的文字基本都是看的时候随手写的，可能写的也不像是系统的分析更像是阅读笔记，诸位聊为一笑。&lt;/blockquote&gt;&lt;h2&gt;C-Level PyObject&lt;/h2&gt;&lt;h2&gt;PyObject_*&lt;/h2&gt;&lt;p&gt;阅读 CPython 的源码可以先从 Python 其中相较重要的对象机制上进行分析，首先从 &lt;code class=&quot;inline&quot;&gt;Include&lt;/code&gt; 部分的源码进行看起，其中 PyObject 的对象的 c-level 层的定义都在这个文件夹之中，先从 &lt;code class=&quot;inline&quot;&gt;object.h&lt;/code&gt; 的源代码进行分析：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/* Nothing is actually declared to be a PyObject, but every pointer to
 * a Python object can be cast to a PyObject*.  This is inheritance built
 * by hand.  Similarly every pointer to a variable-size Python object can,
 * in addition, be cast to PyVarObject*.
 */
typedef struct _object {
    _PyObject_HEAD_EXTRA
    Py_ssize_t ob_refcnt;
    struct _typeobject *ob_type;
} PyObject;
​
typedef struct {
    PyObject ob_base;
    Py_ssize_t ob_size; /* Number of items in variable part */
} PyVarObject;&lt;/code&gt;&lt;p&gt;先来看上述的两个结构体的定义，CPython 在 C 源码之中实现了一套多态系统，PyObject 不存储 Py 对象之中的实际的数据，但是所有的 Object 在 C-Level 都能被转换为一个 PyObject。从这个结构体中可以看出其中主要包含两个 &lt;code class=&quot;inline&quot;&gt;field&lt;/code&gt; ，&lt;code class=&quot;inline&quot;&gt;ob_refcnt&lt;/code&gt; 保存着对象的引用计数，&lt;code class=&quot;inline&quot;&gt;ob_type&lt;/code&gt;  存储着 PyObject 的类型对象，类型对象之中提供了更多的信息。&lt;/p&gt;&lt;p&gt;其中还包含一个 Marco &lt;code class=&quot;inline&quot;&gt;_PyObject_HEAD_EXTRA&lt;/code&gt; 这个宏主要是在 Debug 模式会被用到，其中将所有 heap 中对象都连接到了一个链上，用于调试方便：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define _PyObject_HEAD_EXTRA            \
    struct _object *_ob_next;           \
    struct _object *_ob_prev;
​
#define _PyObject_EXTRA_INIT 0, 0,&lt;/code&gt;&lt;p&gt;而在正常运行的模式之下，这两个宏全都是空的。除了 PyObject 之外，PyVarObject 代表了一类 Py 之中的变长对象的实现方式，其中除了包含一个 PyObject 作为 header 之外还包含了一个 ob_size 代表实际的存储空间大小。通过同样的 Header 能够让所有的 PyObject 的子类型有相似的内存布局，在获取一些公有的参数能获取很多便利，并且在 cast 的时候也很方便。&lt;/p&gt;&lt;p&gt;在看过这些类型的基类（说基类并不严谨，或者说泛化对象？）的实现之后，可以来看 py 支持的具体类型的实现方式了，2.x 和 3.x 在这方面有一部分区别，2.x 之中包含独立的 &lt;code class=&quot;inline&quot;&gt;intobject.h&lt;/code&gt; 实现，在 3.x 之中全部是用来 &lt;code class=&quot;inline&quot;&gt;longobject.h&lt;/code&gt; 来实现了。具体 integer 的数据范围则是由 sys.maxsize 来控制的。这里可以看 &lt;code class=&quot;inline&quot;&gt;longintrepr.h&lt;/code&gt; 的具体实现：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/* Long integer representation.
   The absolute value of a number is equal to
        SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)
   Negative numbers are represented with ob_size &amp;lt; 0;
   zero is represented by ob_size == 0.
   In a normalized number, ob_digit[abs(ob_size)-1] (the most significant
   digit) is never zero.  Also, in all cases, for all valid i,
        0 &amp;lt;= ob_digit[i] &amp;lt;= MASK.
   The allocation function takes care of allocating extra memory
   so that ob_digit[0] ... ob_digit[abs(ob_size)-1] are actually available.
​
   CAUTION:  Generic code manipulating subtypes of PyVarObject has to
   aware that ints abuse  ob_size&#39;s sign bit.
*/
struct _longobject {
    PyObject_VAR_HEAD
    digit ob_digit[1];
};&lt;/code&gt;&lt;p&gt;longobject 使用了 ob_digit[] 作为实际的数据的数组，用 ob_size 来表示数据的正负关系，这个实现得非常简单其中还包含一个 PyObject_VAR_HEAD 的宏，其实就是一个 PyVarObject 来作为 header 。&lt;code class=&quot;inline&quot;&gt;longobject.h&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;longinterpr.h&lt;/code&gt; 的很多方法都是通过宏包装的，这样可以直接通过很多对 PyObject 的方法来提供子类型的分析。&lt;/p&gt;&lt;blockquote&gt;这里要感叹一下自己写大型 C 代码项目的功力之浅。一直没什么机会编写大型的 C 项目，看着 CPython 构建的类型系统和 redis 构建的很多精巧的数据结构有种望洋兴叹的构建。&lt;/blockquote&gt;&lt;p&gt;可以再来分析一个简单的 bool 实现在 &lt;code class=&quot;inline&quot;&gt;boolobject.h&lt;/code&gt; 之中：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;PyAPI_DATA(PyTypeObject) PyBool_Type;
​
#define PyBool_Check(x) (Py_TYPE(x) == &amp;amp;PyBool_Type)
​
/* Py_False and Py_True are the only two bools in existence.
Don&#39;t forget to apply Py_INCREF() when returning either!!! */
​
/* Don&#39;t use these directly */
PyAPI_DATA(struct _longobject) _Py_FalseStruct, _Py_TrueStruct;
​
/* Use these macros */
#define Py_False ((PyObject *) &amp;amp;_Py_FalseStruct)
#define Py_True ((PyObject *) &amp;amp;_Py_TrueStruct)
/* Macros for returning Py_True or Py_False, respectively */
#define Py_RETURN_TRUE return Py_INCREF(Py_True), Py_True
#define Py_RETURN_FALSE return Py_INCREF(Py_False), Py_False&lt;/code&gt;&lt;p&gt;这里直接使用了两个 longobject 来代表 True of False，每次返回的对象之前都要增加引用计数。&lt;/p&gt;&lt;h2&gt;PyTypeObject 类型对象&lt;/h2&gt;&lt;p&gt;在 Python 的 Doc 之中的 C-api 部分提到了其中的 api 有两种层次的支持：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Abstract Objects Layer&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/object.html&quot;&gt;Object Protocol&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/number.html&quot;&gt;Number Protocol&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/sequence.html&quot;&gt;Sequence Protocol&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/mapping.html&quot;&gt;Mapping Protocol&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/iter.html&quot;&gt;Iterator Protocol&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/objbuffer.html&quot;&gt;Old Buffer Protocol&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Concrete Objects Layer&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/concrete.html#fundamental-objects&quot;&gt;Fundamental Objects&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/concrete.html#numeric-objects&quot;&gt;Numeric Objects&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/concrete.html#sequence-objects&quot;&gt;Sequence Objects&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/concrete.html#mapping-objects&quot;&gt;Mapping Objects&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/concrete.html#other-objects&quot;&gt;Other Objects&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以看出 AOL 支持的层次是可以对某种具体特性的接口提供了一套 API ，具有这种特性的 Object 都口以使用这类方法。而 Concrete Objects Layer 所提供的方法就会更为细化，会细化到某个具体的内建类型上，要先 check type  才能使用。&lt;/p&gt;&lt;p&gt;而这些 PyObject 类型的实现都依赖于结构体中的 &lt;code class=&quot;inline&quot;&gt;_typeobject&lt;/code&gt; PyTypeObject 对象的实现，在 &lt;code class=&quot;inline&quot;&gt;object.h&lt;/code&gt; 下可以看到这样的定义：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#ifdef Py_LIMITED_API
typedef struct _typeobject PyTypeObject; /* opaque */
#else
typedef struct _typeobject {
    PyObject_VAR_HEAD
    const char *tp_name; /* For printing, in format &quot;&amp;lt;module&amp;gt;.&amp;lt;name&amp;gt;&quot; */
    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */
​
    /* Methods to implement standard operations */
​
    destructor tp_dealloc;
    printfunc tp_print;
    getattrfunc tp_getattr;
    setattrfunc tp_setattr;
    ...&lt;/code&gt;&lt;p&gt;这里节选了部分的代码，可以看到其实 PyTypeObject 本身也是一个 PyVarObject 对象。其中 &lt;code class=&quot;inline&quot;&gt;tp_name&lt;/code&gt; 保存 format 格式的定义，&lt;code class=&quot;inline&quot;&gt;tp_basicsize, tp_itemsize&lt;/code&gt; 记录这个对象应该要使用多少的内存空间，在 &lt;code class=&quot;inline&quot;&gt;tp_new&lt;/code&gt; 的流程之中会被用到，而下面的这几个函数指针则为 PyObject 提供了一些标准操作符的支持。值得留意的方法还有下面这些：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;    /* Method suites for standard classes */
    PyNumberMethods *tp_as_number;
    PySequenceMethods *tp_as_sequence;
    PyMappingMethods *tp_as_mapping;
    ...
    initproc tp_init;
    allocfunc tp_alloc;
    newfunc tp_new;
    ...&lt;/code&gt;&lt;p&gt;这其中的 init alloc new 方法都和 PyObject 实际的创建有关系，而上面的 tp_as_number，&lt;code class=&quot;inline&quot;&gt;tp_as_squence&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;tp_as_mapping&lt;/code&gt; 则代表了三种主要的方法族，这三个主要的方法族提供了一系列的方法，能够让一个 object 支持作为一个数字、序列和字典的功能。PyTypeObject 的基本实现对象都在 &lt;code class=&quot;inline&quot;&gt;typeobject.h&lt;/code&gt; 文件之中：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;PyTypeObject PyType_Type = {
    PyVarObject_HEAD_INIT(&amp;amp;PyType_Type, 0)
    &quot;type&quot;,                                     /* tp_name */
    sizeof(PyHeapTypeObject),                   /* tp_basicsize */
    sizeof(PyMemberDef),                        /* tp_itemsize */
    (destructor)type_dealloc,                   /* tp_dealloc */
    0,                                          /* tp_print */
    0,                                          /* tp_getattr */
    0,                                          /* tp_setattr */
    0,                                          /* tp_reserved */
    ...
}
​
...
​
PyTypeObject PyBaseObject_Type = {
    PyVarObject_HEAD_INIT(&amp;amp;PyType_Type, 0)
    &quot;object&quot;,                                   /* tp_name */
    sizeof(PyObject),                           /* tp_basicsize */
    0,                                          /* tp_itemsize */
    object_dealloc,                             /* tp_dealloc */
    0,                                          /* tp_print */
    0,                                          /* tp_getattr */
    0,                                          /* tp_setattr */
    0,                                          /* tp_reserved */
    object_repr,                                /* tp_repr */
    0,                                          /* tp_as_number */
    0,                                          /* tp_as_sequence */
    0,              
    ...
}&lt;/code&gt;&lt;p&gt;这里还是可以看到两个这样的定义，其中一个是 &lt;code class=&quot;inline&quot;&gt;PyType_Type&lt;/code&gt; 另一个是 &lt;code class=&quot;inline&quot;&gt;PyBaseObject_Type&lt;/code&gt; 仔细观察两者传入的第一个参数，可以看到两者都传入了 PyType_Type 作为 Header，其实这两者的关系比较类似 PyObject 和 PyVarObject 之间的关系。一个是作为 Header 的基类实现，另一个再次之上构建了一套对构建对象的实现。PyType_Type 本身就像 PyObject 一样作为了一层的 Header 来标识了此 PyObject 对象为一个类型对象。&lt;/p&gt;&lt;p&gt;在据此我们可以来看一下子类型的实现，在 &lt;code class=&quot;inline&quot;&gt;bool_object.c&lt;/code&gt; 的文件之中包含 bool 类型的类型信息：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/* The type object for bool.  Note that this cannot be subclassed! */
PyTypeObject PyBool_Type = {
    PyVarObject_HEAD_INIT(&amp;amp;PyType_Type, 0)
    &quot;bool&quot;,
    sizeof(struct _longobject),
    ...
    bool_repr,                                  /* tp_repr */
    &amp;amp;bool_as_number,                            /* tp_as_number */
    0,                                          /* tp_as_sequence */
    0,                                          /* tp_as_mapping */
    bool_repr,                                  /* tp_str */
    Py_TPFLAGS_DEFAULT,                         /* tp_flags */
    bool_doc,                                   /* tp_doc */
    ...
    &amp;amp;PyLong_Type,                               /* tp_base */
    ...
    bool_new,                                   /* tp_new */
};&lt;/code&gt;&lt;p&gt;可以看出具体的初始化 bool 类型的函数指针、bool 类型的标识字串，通过的 as_number 函数指针都在这种子类型之中进行了提供。&lt;/p&gt;&lt;p&gt;这里注意到很多 c 代码的之中都有类似如下的注释开头：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/*[clinic input]
class bytearray &quot;PyByteArrayObject *&quot; &quot;&amp;amp;PyByteArray_Type&quot;
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=5535b77c37a119e0]*/
​
char _PyByteArray_empty_string[] = &quot;&quot;;&lt;/code&gt;&lt;p&gt;这里去了解了一下，这是一个叫 Clinic 的 DSL 语言工具，写在 C 的注释里用来生成和管理 C 与 Python 的接口函数的类型、签名、文档等信息。&lt;/p&gt;&lt;blockquote&gt;Clinic 的相关信息：&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/3/howto/clinic.html#argument-clinic-how-to&quot;&gt;Argument Clinic How-To&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-0436/#abstract&quot;&gt;PEP 436 -- The Argument Clinic DSL&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;PyLongObject&lt;/h2&gt;&lt;p&gt;实际到某种 PyObject 的具体实现方式之中还都有一些独特的优化手段。老版本有单独的 PyIntObject 的时候，是有独立的小整数缓存池和大整数链共享内存的，不过 3.x 把 int 归到了 PyLongObject 之中大整数的共享内存机制似乎已经被删除掉了，这里还能看得到小整数对象的共享逻辑：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define NSMALLPOSINTS           257
#endif
#ifndef NSMALLNEGINTS
#define NSMALLNEGINTS           5
#endif
​
_Py_IDENTIFIER(little);
_Py_IDENTIFIER(big);
​
/* convert a PyLong of size 1, 0 or -1 to an sdigit */
#define MEDIUM_VALUE(x) (assert(-1 &amp;lt;= Py_SIZE(x) &amp;amp;&amp;amp; Py_SIZE(x) &amp;lt;= 1),   \
         Py_SIZE(x) &amp;lt; 0 ? -(sdigit)(x)-&amp;gt;ob_digit[0] :   \
             (Py_SIZE(x) == 0 ? (sdigit)0 :                             \
              (sdigit)(x)-&amp;gt;ob_digit[0]))
​
PyObject *_PyLong_Zero = NULL;
PyObject *_PyLong_One = NULL;
​
#if NSMALLNEGINTS + NSMALLPOSINTS &amp;gt; 0
/* Small integers are preallocated in this array so that they
   can be shared.
   The integers that are preallocated are those in the range
   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).
*/
static PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];
#ifdef COUNT_ALLOCS
Py_ssize_t _Py_quick_int_allocs, _Py_quick_neg_int_allocs;
#endif
​
static PyObject *
get_small_int(sdigit ival)
{
    PyObject *v;
    assert(-NSMALLNEGINTS &amp;lt;= ival &amp;amp;&amp;amp; ival &amp;lt; NSMALLPOSINTS);
    v = (PyObject *)&amp;amp;small_ints[ival + NSMALLNEGINTS];
    Py_INCREF(v);
#ifdef COUNT_ALLOCS
    if (ival &amp;gt;= 0)
        _Py_quick_int_allocs++;
    else
        _Py_quick_neg_int_allocs++;
#endif
    return v;&lt;/code&gt;&lt;p&gt;默认保存了 -5 ~ 257 之中的小整数，在模块 init 的时候初始化整个整数池，当数据范围在这个范围之内的时候就直接使用缓存池中的 PyObject 并增加引用计数就好了。大部分这种 PyObject 的内建类型都提供了多重方法去创建一个 obj，比如 PyLongObject 就包括 FromLong、FromString 等几种创建方法。还有就是 Long （包含 Int）类型的 PyObject 本质上是一种不可变的对象，可以注意到其他的加减乘除的方法返回的都是一个新的对象而不是之前的对象。&lt;/p&gt;&lt;h2&gt;PyBytesObject、PyUnicodeObject&lt;/h2&gt;&lt;p&gt;接着可以来分析 &lt;code class=&quot;inline&quot;&gt;PyStringObject&lt;/code&gt; 的具体实现方式，在 &lt;code class=&quot;inline&quot;&gt;bytesobject.h&lt;/code&gt; 文件之中：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/*
Type PyBytesObject represents a character string.  An extra zero byte is
reserved at the end to ensure it is zero-terminated, but a size is
present so strings with null bytes in them can be represented.  This
is an immutable object type.
​
There are functions to create new string objects, to test
an object for string-ness, and to get the
string value.  The latter function returns a null pointer
if the object is not of the proper type.
There is a variant that takes an explicit size as well as a
variant that assumes a zero-terminated string.  Note that none of the
functions should be applied to nil objects.
*/
​
/* Caching the hash (ob_shash) saves recalculation of a string&#39;s hash value.
   This significantly speeds up dict lookups. */
​
#ifndef Py_LIMITED_API
typedef struct {
    PyObject_VAR_HEAD
    Py_hash_t ob_shash;
    char ob_sval[1];
​
    /* Invariants:
     *     ob_sval contains space for &#39;ob_size+1&#39; elements.
     *     ob_sval[ob_size] == 0.
     *     ob_shash is the hash of the string or -1 if not computed yet.
     */
} PyBytesObject;
#endif&lt;/code&gt;&lt;p&gt;在 3.x 之后取消了 &lt;code class=&quot;inline&quot;&gt;stringobject.h&lt;/code&gt; 一系列相关的 api 和接口，重新修改了 bytes 和 str 的实现，其中 3.x 之中的 bytes 仅保存字符编码，而 str 则承担了之前 unicode 类型的功能。这里的 PyBytesObject 就对应之前的 PyStringObject 的实现。这个结构看起来非常的熟悉了，包含一个 PyObject 的 header ，其中主要存储字符串的位置是 &lt;code class=&quot;inline&quot;&gt;ob_sval&lt;/code&gt; ，另外还包含一个 &lt;code class=&quot;inline&quot;&gt;ob_shash&lt;/code&gt; 来存储 String 的 hash 信息。另外就正如之前介绍 PyVarObject 的结构之中的 &lt;code class=&quot;inline&quot;&gt;ob_size&lt;/code&gt; 之中存储了字符串的所占空间。&lt;/p&gt;&lt;blockquote&gt;基本上在大型的 C 项目里要是想要使用动态的 string ，都要自己搞一套这样的实现。之前看 redis 的代码实现之中也包含这样的实现。否则不用 chars 来存储的话仍会受限于 c-style string 的 &quot;\0&quot; 的限制。&lt;/blockquote&gt;&lt;p&gt;这里来看一下 PyString 创建的一些逻辑，挑一个最简单的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;PyObject *
PyBytes_FromString(const char *str) // 接受一个 c style 的字符串指针
{
    size_t size;
    PyBytesObject *op;
    assert(str != NULL);
    size = strlen(str);
    if (size &amp;gt; PY_SSIZE_T_MAX - PyBytesObject_SIZE) {
        PyErr_SetString(PyExc_OverflowError,
            &quot;byte string is too long&quot;);
        return NULL;
    }
    if (size == 0 &amp;amp;&amp;amp; (op = nullstring) != NULL) {
#ifdef COUNT_ALLOCS
        _Py_null_strings++; // 增加引用计数
#endif
        Py_INCREF(op);
        return (PyObject *)op; // null 的 PyBytesObject 的返回结果
    }
    if (size == 1 &amp;amp;&amp;amp; (op = characters[*str &amp;amp; UCHAR_MAX]) != NULL) {
#ifdef COUNT_ALLOCS
        _Py_one_strings++;
#endif
        Py_INCREF(op);
        return (PyObject *)op; // 
    }
    // 创建 PyBytesObject 对象 申请空间、增加引用计数。
    /* Inline PyObject_NewVar */
    op = (PyBytesObject *)PyObject_MALLOC(PyBytesObject_SIZE + size);
    if (op == NULL)
        return PyErr_NoMemory();
    (void)PyObject_INIT_VAR((PyVarObject *)op, &amp;amp;PyBytes_Type, size);
    op-&amp;gt;ob_shash = -1;
    memcpy(op-&amp;gt;ob_sval, str, size+1);
    /* share short strings */
    if (size == 0) {
        nullstring = op;
        Py_INCREF(op);
    } else if (size == 1) {
        characters[*str &amp;amp; UCHAR_MAX] = op;
        Py_INCREF(op);
    }
    return (PyObject *) op;
}&lt;/code&gt;&lt;p&gt;PyBytesObject 之中也同样包括共享池的优化手段，这就是之前在生成对象时判断 size 0、1 的关系：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;static PyBytesObject *characters[UCHAR_MAX + 1]; // 单字符的缓存池
static PyBytesObject *nullstring;  // 空字串对象&lt;/code&gt;&lt;p&gt;在 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0393/#rationale&quot;&gt;pep-393&lt;/a&gt; 之后 &lt;code class=&quot;inline&quot;&gt;str&lt;/code&gt; 接管了之前的 &lt;code class=&quot;inline&quot;&gt;unicode&lt;/code&gt; 的相关内容，并且更新为了一种层级关系：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;typedef struct {
  PyObject_HEAD
  Py_ssize_t length;
  Py_hash_t hash;
  struct {
      unsigned int interned:2;
      unsigned int kind:2;
      unsigned int compact:1;
      unsigned int ascii:1;
      unsigned int ready:1;
  } state;
  wchar_t *wstr;
} PyASCIIObject;
​
typedef struct {
  PyASCIIObject _base;
  Py_ssize_t utf8_length;
  char *utf8;
  Py_ssize_t wstr_length;
} PyCompactUnicodeObject;
​
typedef struct {
  PyCompactUnicodeObject _base;
  union {
      void *any;
      Py_UCS1 *latin1;
      Py_UCS2 *ucs2;
      Py_UCS4 *ucs4;
  } data;
} PyUnicodeObject;&lt;/code&gt;&lt;p&gt;这种层级关系在我们使用不同范围的初始化字段的时候会被初始化。而之前 str 相关的有优化手段也在 unicode 之中实现了：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;static PyObject *unicode_latin1[256] = {NULL};&lt;/code&gt;&lt;p&gt;看到了熟悉的东西在 str 这部分之中也包含一个字符池，在一定数据范围的字符都会进行复用。除此之外 str 还包含另一种 intern 的复用逻辑，其中包含了一个 internal state 状态，状态的有以下集中情况：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define SSTATE_NOT_INTERNED 0             // 未共享
#define SSTATE_INTERNED_MORTAL 1          // 共享 但是不增加引用计数
#define SSTATE_INTERNED_IMMORTAL 2        // 永久 不会被销毁&lt;/code&gt;&lt;p&gt;对 interned-state 状态的修改和代用 PyUnicode_Interned&lt;i&gt;* 系列，通过 PyUnicode&lt;/i&gt;* 的方法提供了优化的手段，在方法 &lt;code class=&quot;inline&quot;&gt;unicodeobject.c#PyUnicode_InternInPlace&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;    [unicodeobject.c]
    PyObject *PyUnicode_InternFromString(const char *cp) {
        PyObject *s = PyUnicode_FromString(cp);
        if (s == NULL)
            return NULL;
        PyUnicode_InternInPlace(&amp;amp;s);
        return s;
    }
​
    // PyUnicode_InternInPlace
    ...
    Py_ALLOW_RECURSION
    t = PyDict_SetDefault(interned, s, s);
    Py_END_ALLOW_RECURSION
    if (t == NULL) {
        PyErr_Clear();
        return;
    }
    if (t != s) {
        Py_INCREF(t);
        Py_SETREF(*p, t);
        return;
    }
    /* The two references in interned are not counted by refcnt.
       The deallocator will take care of this */
    Py_REFCNT(s) -= 2;
    _PyUnicode_STATE(s).interned = SSTATE_INTERNED_MORTAL;&lt;/code&gt;&lt;p&gt;从 &lt;code class=&quot;inline&quot;&gt;PyUnicode_InternFromString&lt;/code&gt; 方法之中可见，Py 并不会在创建 PyUnicodeObject 的时候之前检查是否已经创建这个 Object，而是会先创建出一个临时变量的 PyObject 。然后在 &lt;code class=&quot;inline&quot;&gt;PyUnicode_InternInPlace&lt;/code&gt; 之中 check 从 &lt;code class=&quot;inline&quot;&gt;PyDict_SetDefault&lt;/code&gt; 返回的函数指针（缓存在 interned 这个字典之中），如果相同表示已经进行 interned 存储过了，就会增加引用。&lt;/p&gt;&lt;p&gt;这个地方的逻辑有点复杂，这里对 interned 的讨论不过就是有两种情况，我们可以分开来讨论：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;插入新的 PyUnicodeObject 的时候：&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;text&quot;&gt;// s 进入 dict 之后 ref 会 + 2
t = PyDict_SetDefault(interned, s, s);
/* The two references in interned are not counted by refcnt.
The deallocator will take care of this */
// 第一次插入减少被 dict 持有的 ref 
Py_REFCNT(s) -= 2;
_PyUnicode_STATE(s).interned = SSTATE_INTERNED_MORTAL;&lt;/code&gt;&lt;p&gt;因为 interned string 被放进 dict 之后 key value 都会增加一次 ref ，因此在之后会调整状态为 &lt;code class=&quot;inline&quot;&gt;SSTATE_INTERNED_MORTAL&lt;/code&gt; 之后并且补充 ref - 2。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;插入已有的 PyUnicodeObject 的时候：&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;text&quot;&gt;// 已有不会在内部 ref 增加 (里面查到了 value_attr )
t = PyDict_SetDefault(interned, s, s);
// 查到了已有的 PyObject 因此指针地址不同 
if (t != s) {
    Py_INCREF(t);
    Py_SETREF(*p, t);
    return;
}&lt;/code&gt;&lt;p&gt;这里真的增加了 t 的 ref，因为是被复用有一个增加的引用计数，把指针 p 指向的临时变量销毁掉，然后把 t （cache 的引用）填充进去。str 的 concat 和 join 开销对比也可以在 &lt;code class=&quot;inline&quot;&gt;unicodeobject.c&lt;/code&gt; 之中可以看出：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;// PyUnicode_Join
    items = PySequence_Fast_ITEMS(fseq);
    seqlen = PySequence_Fast_GET_SIZE(fseq);
    res = _PyUnicode_JoinArray(separator, items, seqlen);
​
// PyUnicode_Concat
    /* Shortcuts */
    if (left == unicode_empty)
        return PyUnicode_FromObject(right);
    if (right == unicode_empty)
        return PyUnicode_FromObject(left);
​
    left_len = PyUnicode_GET_LENGTH(left);
    right_len = PyUnicode_GET_LENGTH(right);
    if (left_len &amp;gt; PY_SSIZE_T_MAX - right_len) {
        PyErr_SetString(PyExc_OverflowError,
                        &quot;strings are too large to concat&quot;);
        return NULL;
    }
    new_len = left_len + right_len;
​
    maxchar = PyUnicode_MAX_CHAR_VALUE(left);
    maxchar2 = PyUnicode_MAX_CHAR_VALUE(right);
    maxchar = Py_MAX(maxchar, maxchar2);
​
    /* Concat the two Unicode strings */
    result = PyUnicode_New(new_len, maxchar);
    if (result == NULL)
        return NULL;
    _PyUnicode_FastCopyCharacters(result, 0, left, 0, left_len);
    _PyUnicode_FastCopyCharacters(result, left_len, right, 0, right_len);&lt;/code&gt;&lt;p&gt;从这里可以看出，在使用 join 功能的时候会算出 sequence 的长度一次申请内存进行一次拷贝，而 concat 每次连接都会进行一次内存申请、两次内存拷贝，因此当连接的次数多了的时候，性能就会有很大的下降。&lt;/p&gt;&lt;h2&gt;To be continue...&lt;/h2&gt;</description>
<author>lfkdsk</author>
<guid isPermaLink="false">2018-11-12-49451546</guid>
<pubDate>Mon, 12 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>把类型类用 record 实现出来</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-11-08-48920962.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/48920962&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f54476731ef15b5fb836dc587b86c555_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;推荐阅读&lt;a href=&quot;http://ice1000.org/lagda/Typeclassopedia.html&quot;&gt;我的博客&lt;/a&gt;的版本，这样你可以看到代码高亮，以及点击代码里的变量、类型以跳转到定义（没错，他们都是链接）。&lt;/p&gt;&lt;p&gt;前排提醒：你或许需要一个&lt;a href=&quot;https://baike.baidu.com/item/%E6%B8%B8%E6%A0%87%E5%8D%A1%E5%B0%BA&quot;&gt;游标卡尺&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;这是一个类型类教程，尝试使用我改进过的 Literate Agda 后端生成网页 （如果想使用我改进的功能，请拉取 master 分支的 Agda 编译器然后 &lt;code class=&quot;inline&quot;&gt;cabal install&lt;/code&gt; 编译。 我加的功能的使用说明见&lt;a href=&quot;https://agda.readthedocs.io/en/latest/tools/generating-html.html&quot;&gt;这个网页&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;为了让我能用我的手机正常显示自己的文章里的字符，本文会尽量使用非 Unicode 定义。&lt;/p&gt;&lt;p&gt;首先我们定义模块：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;{-# OPTIONS --no-unicode #-}
{-# OPTIONS --without-K  #-}
module Typeclassopedia where&lt;/code&gt;&lt;p&gt;为了强迫自己事先熟悉 HoTT 的 Agda 实现， 我已经开始全面使用 &lt;a href=&quot;https://github.com/HoTT/HoTT-Agda/tree/master/core/lib&quot;&gt;HoTT-Agda&lt;/a&gt; 作为编程基础库（和标准库基本一致）。&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;open import lib.Base&lt;/code&gt;&lt;p&gt;由于 &lt;code class=&quot;inline&quot;&gt;lib.types.Bool&lt;/code&gt; 依赖的包比较多（而且 Emacs 看不懂基于 dependent product 的 &lt;code class=&quot;inline&quot;&gt;Bool&lt;/code&gt;）， 就自己写一个，加上内置定义：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;data Bool : Type0 where false true : Bool

{-# BUILTIN BOOL  Bool  #-}
{-# BUILTIN FALSE false #-}
{-# BUILTIN TRUE  true  #-}&lt;/code&gt;&lt;p&gt;然后常用的函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;not : Bool -&amp;gt; Bool
not true  = false
not false = true&lt;/code&gt;&lt;p&gt;比较自然数大小：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;natEq : Nat -&amp;gt; Nat -&amp;gt; Bool
natEq  O     O    = true
natEq (S _)  O    = false
natEq  O    (S _) = false
natEq (S n) (S m) = natEq n m
{-# BUILTIN NATEQUALS natEq #-}&lt;/code&gt;&lt;p&gt;不熟悉这个库的读者不必担心，本文用到的定义都属于看名字就知道的那种 （基本上在标准库或者内置库里面都有一个名字一样的，另外 &lt;code class=&quot;inline&quot;&gt;idp&lt;/code&gt; 是 &lt;code class=&quot;inline&quot;&gt;refl&lt;/code&gt;）。&lt;/p&gt;&lt;p&gt;泛化一个阶变量（Girard 悖论你好），免得到处写隐式参数：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;variable i : ULevel&lt;/code&gt;&lt;p&gt;有个函数 &lt;code class=&quot;inline&quot;&gt;of-type&lt;/code&gt; 和 Idris 的函数 &lt;code class=&quot;inline&quot;&gt;the&lt;/code&gt; 语义一致：先传入一个类型，再传入这个类型的实例:&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ : (A : Type i) (u : A) -&amp;gt; A
_ = of-type&lt;/code&gt;&lt;p&gt;HoTT-Agda 提供了这种便利的语法来间接使用 &lt;code class=&quot;inline&quot;&gt;of-type&lt;/code&gt;:&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = 233 :&amp;gt; Nat
_ = lzero :&amp;gt; ULevel
_ = unit :&amp;gt; Unit
_ = idp :&amp;gt; (O == O)&lt;/code&gt;&lt;h2&gt;实例参数&lt;/h2&gt;&lt;code lang=&quot;agda&quot;&gt;module InstanceArgument where
&lt;/code&gt;&lt;p&gt;注：我的第一册书里译作&lt;i&gt;即时&lt;/i&gt;参数，因为在英语中这个名字是一语双关的（ 因为查找实例使用的算法比较快，所以 instance 此处有&lt;i&gt;即时&lt;/i&gt;之意。 但这个特性又用于查找类型实例，所以 instance 又有&lt;i&gt;实例&lt;/i&gt;之意）， 现在决定改为取相对来说更内涵的含义。&lt;/p&gt;&lt;p&gt;实例参数类似隐式参数，只不过它们使用两层大括号：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;postulate f : {{ x : Nat }} -&amp;gt; Nat
&lt;/code&gt;&lt;p&gt;手动传值也是两层：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = f {{ 233 }} :&amp;gt; Nat
&lt;/code&gt;&lt;p&gt;隐式参数一般是通过后面的参数往前推导得到的，实例参数则使用另一种方式： &lt;b&gt;直接在上下文里查找变量。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;听起来很暴力，但其实也没有那么暴力啦，只有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;放在 &lt;code class=&quot;inline&quot;&gt;instance&lt;/code&gt; 代码块里的定义&lt;/li&gt;&lt;li&gt;局部变量&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;才属于被查找的对象，我们称之为实例。 Agda wiki 说构造器也会，但目前看编译器的行为应该是不允许了。&lt;/p&gt;&lt;p&gt;放在 &lt;code class=&quot;inline&quot;&gt;instance&lt;/code&gt; 代码块里的定义的例子：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;-- instance 代码块定义
  instance rua : Nat
           rua = 233
  -- 喏，自动传入啦
  _ = f :&amp;gt; Nat
&lt;/code&gt;&lt;p&gt;局部变量：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = let jojo = O in f :&amp;gt; Nat
  _ = f :&amp;gt; Nat where jojo = O
&lt;/code&gt;&lt;p&gt;如果作用域内有两个满足需求的实例，就会报错。&lt;/p&gt;&lt;h2&gt;依赖记录&lt;/h2&gt;&lt;code lang=&quot;agda&quot;&gt;module DependentRecord where
&lt;/code&gt;&lt;p&gt;这里&lt;i&gt;依赖&lt;/i&gt;是形容词，不是动词。英文原文是 dependent record ， 表示后面成员的类型可以依赖前面成员的 &lt;code class=&quot;inline&quot;&gt;record&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;Haskell 中的类型类使用 &lt;code class=&quot;inline&quot;&gt;class&lt;/code&gt; 关键字定义，比如 &lt;code class=&quot;inline&quot;&gt;Eq&lt;/code&gt; 类型类：&lt;/p&gt;&lt;p&gt;class Eq t where   (==) :: t -&amp;gt; t -&amp;gt; Bool&lt;/p&gt;&lt;p&gt;立即使用 &lt;code class=&quot;inline&quot;&gt;record&lt;/code&gt; 表达：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;record Eq {a} (A : Type a) : Type a where
    field _===_ : A -&amp;gt; A -&amp;gt; Bool
    infixl 32 _===_
&lt;/code&gt;&lt;p&gt;由于 Agda 的 &lt;code class=&quot;inline&quot;&gt;record&lt;/code&gt; 就是带参数的 &lt;code class=&quot;inline&quot;&gt;module&lt;/code&gt; ，我们可以把它的成员定义 &lt;code class=&quot;inline&quot;&gt;open&lt;/code&gt; 出来：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;module EqAsExplicitArgument where
    open Eq
&lt;/code&gt;&lt;p&gt;可以简单地看出，被 &lt;code class=&quot;inline&quot;&gt;open&lt;/code&gt; 出来的 &lt;code class=&quot;inline&quot;&gt;_===_&lt;/code&gt; 的类型：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ = _===_ :&amp;gt; (Eq Nat -&amp;gt; Nat -&amp;gt; Nat -&amp;gt; Bool)
&lt;/code&gt;&lt;p&gt;要使用的话，先搞个实例，然后 Haskell 里当成 constraint 用的情况改成参数就是了：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;natEqInstance : Eq Nat
    natEqInstance = record { _===_ = natEq }
&lt;/code&gt;&lt;p&gt;我们还可以使用优美的余模式（copattern）：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;natEqInstance&#39; : Eq Nat
    _===_ natEqInstance&#39; = natEq
&lt;/code&gt;&lt;p&gt;根据 &lt;code class=&quot;inline&quot;&gt;Eq&lt;/code&gt; 类型类，定义不等于（就不 point-free 了，怕伤害不精通各种 arrow 操作的萌新）：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;natNeq&#39; : {A : Type i} -&amp;gt; (Eq A) -&amp;gt; A -&amp;gt; A -&amp;gt; Bool
    natNeq&#39; eq a b = not $ _===_ eq a b
&lt;/code&gt;&lt;p&gt;使用一下这个不等于：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ : false == natNeq&#39; natEqInstance 0 0
    _ = idp

    _ : true == natNeq&#39; natEqInstance 1 2
    _ = idp
&lt;/code&gt;&lt;p&gt;嗯，非常妙。&lt;/p&gt;&lt;p&gt;我们现在已经实现了一个非常不优美（不优美的原因是，我们要手动传入类型实例） 但比 Haskell 版本更灵活的类型类，并给它创建类型实例了！&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;module EqAsInstanceArgument where
&lt;/code&gt;&lt;p&gt;在这个基础上，我们如果把那个 &lt;code class=&quot;inline&quot;&gt;(Eq A)&lt;/code&gt; 做成实例参数，就可以让编译器自己去找类型实例， 实现 Haskell 中 &lt;code class=&quot;inline&quot;&gt;=&amp;gt;&lt;/code&gt; 一样的效果了！&lt;/p&gt;&lt;p&gt;我们需要做两个手脚，首先 &lt;code class=&quot;inline&quot;&gt;open&lt;/code&gt; 出来的 &lt;code class=&quot;inline&quot;&gt;_===_&lt;/code&gt; 中的 &lt;code class=&quot;inline&quot;&gt;(Eq A)&lt;/code&gt; 需要变成实例参数 &lt;code class=&quot;inline&quot;&gt;{{ Eq A }}&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;open Eq {{ ... }}
&lt;/code&gt;&lt;p&gt;没错，这个需求有点复杂，所以 Agda 专门做了个语法来简化这个流程。 当然，不代表我们不能手动实现这个语法糖实现的功能：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;module StupidImplementation
           {i} {A : Type i} {{ eq : Eq A }} where
      open module EqInstances = Eq eq public
&lt;/code&gt;&lt;p&gt;其次我们的类型实例需要被 &lt;code class=&quot;inline&quot;&gt;instance&lt;/code&gt; 修饰：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;instance
      natEqInstance : Eq Nat
      natEqInstance = record { _===_ = natEq }
&lt;/code&gt;&lt;p&gt;嗯，由于我们已经把 &lt;code class=&quot;inline&quot;&gt;Eq&lt;/code&gt; 以实例参数形式 &lt;code class=&quot;inline&quot;&gt;open&lt;/code&gt; 出来，就用不了余模式了 QAQ。&lt;/p&gt;&lt;p&gt;然后再试试用这个类型类实现不等于。先显式传入，找找感觉（ 实例参数必须 introduce 一个变量，不知道为什么。如果不想写，命名为下划线就是）：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;natNeq&#39; : {A : Type i} -&amp;gt; {{_ : Eq A}} -&amp;gt; A -&amp;gt; A -&amp;gt; Bool
    natNeq&#39; {{eq}} a b = not $ _===_ {{eq}} a b
&lt;/code&gt;&lt;p&gt;自动传入（终于能用上运算符语法了，嘤嘤嘤）：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;natNeq : {A : Type i} -&amp;gt; {{_ : Eq A}} -&amp;gt; A -&amp;gt; A -&amp;gt; Bool
    natNeq a b = not $ a === b
&lt;/code&gt;&lt;p&gt;运算符重载了解一下，自定义优先级结合性了解一下：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;infixl 32 _=/=_
    _=/=_ : {A : Type i} -&amp;gt; {{_ : Eq A}} -&amp;gt; A -&amp;gt; A -&amp;gt; Bool
    a =/= b = not $ a === b
&lt;/code&gt;&lt;p&gt;相信此时浏览器等宽字体设置为 Fira Code 的读者已经被爽到了（噫）。&lt;/p&gt;&lt;p&gt;简单地调用，证明一下性质：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_ : false == O =/= O
    _ = idp

    _ : true == O =/= S O
    _ = idp
&lt;/code&gt;&lt;p&gt;完美！我们有类型类了！&lt;/p&gt;</description>
<author>兴趣使然千里冰封</author>
<guid isPermaLink="false">2018-11-08-48920962</guid>
<pubDate>Thu, 08 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Estimate Size of Transitive Closure</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-11-08-48553348.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/48553348&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cfad1bac7ce7f070d2594ae717c075ac_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;Estimate Size of Transitive Closure&lt;/h2&gt;&lt;p&gt;PCP的那个坑先继续咕一段时间，今天给大家介绍一下最近学到的一个很有意思的问题。 本文的idea来自&lt;a href=&quot;https://www.ilyaraz.org/&quot;&gt;Ilya Razenshteyn&lt;/a&gt;, 基于&lt;a href=&quot;http://cohenwang.com/edith/Papers/tcest.pdf&quot;&gt;Cohen 94&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;一个有向图&lt;equation&gt;G=(V,E)&lt;/equation&gt;。我们把能够从点&lt;equation&gt;v&lt;/equation&gt;到达的点的集合叫做点&lt;equation&gt;v&lt;/equation&gt;的传递闭包，记作&lt;equation&gt;R_v&lt;/equation&gt;。现在我们想知道这个图&lt;equation&gt;G&lt;/equation&gt;每个点的传递闭包的大小。对于这个问题的确定性算法，最好的已知复杂度是&lt;equation&gt;\mathcal O(\min(|V||E|), |V|^{2.38}))&lt;/equation&gt;。&lt;/p&gt;&lt;p&gt;然而如果我们允许随机和近似的话，我们能够做到近乎线性：通过&lt;equation&gt;\mathcal O\left(\frac{m\log^2 n}{\epsilon^2}\right)&lt;/equation&gt;的时间复杂度，对于每个点&lt;equation&gt;v\in V&lt;/equation&gt;,我们可以得到&lt;equation&gt;R_v&lt;/equation&gt;的近似&lt;equation&gt;R_v&#39;&lt;/equation&gt;使得&lt;equation&gt;(1-\epsilon)R_v &amp;lt;R_v&#39; &amp;lt; (1+\epsilon)R_v&lt;/equation&gt;。&lt;/p&gt;&lt;h2&gt;算法&lt;/h2&gt;&lt;p&gt;首先我们对每一个点&lt;equation&gt;v&lt;/equation&gt;, 我们随机从指数分布给它赋值&lt;equation&gt;X_v&lt;/equation&gt;， 使得&lt;equation&gt;X_v\sim\text{Exp}(1)&lt;/equation&gt;， 并且反转原图所有边的方向。然后，对于所有的&lt;equation&gt;X_v&lt;/equation&gt;, 我们从小到大的取出，从点&lt;equation&gt;v&lt;/equation&gt;开始进行BFS，对于被BFS到的点&lt;equation&gt;u&lt;/equation&gt;,我们标记&lt;equation&gt;Y_u = X_v&lt;/equation&gt;,然后删除所有访问过的点。直到所有点都被访问过恰好一次。&lt;/p&gt;&lt;p&gt;我们可以证明,&lt;equation&gt;\mathbb E[Y_v] = 1/|R_v|&lt;/equation&gt;&lt;/p&gt;&lt;p&gt;我们每次都是在选出最小的&lt;equation&gt;X_v&lt;/equation&gt;然后标记&lt;equation&gt;v&lt;/equation&gt;在反向图里面能到达的所有点，所以&lt;equation&gt;Y_v&lt;/equation&gt;的定义等价于&lt;equation&gt;Y_v=\min_{u\in R_v} X_u&lt;/equation&gt;.&lt;/p&gt;&lt;h2&gt;指数分布的最小值&lt;/h2&gt;&lt;p&gt;定理1: 如果我们有&lt;equation&gt;n&lt;/equation&gt;个指数分布的随机变量&lt;equation&gt;X_1\sim \text{Exp}(\lambda_1), X_2\sim \text{Exp}(\lambda_2), \ldots,X_n\sim \text{Exp}(\lambda_n)&lt;/equation&gt;,那么&lt;equation&gt;\min\{X_1,X_2,\ldots, X_n\} \sim \text{Exp}(\lambda_1+\lambda_2+\ldots+\lambda_n)&lt;/equation&gt;。&lt;/p&gt;&lt;p&gt;证明： 我们考虑指数分布的cdf的补集：我们知道如果&lt;equation&gt;X\sim \text{Exp}(\lambda)&lt;/equation&gt;，那么&lt;equation&gt;\Pr[X &amp;gt; t] = \exp(\lambda t)&lt;/equation&gt;我们计算最小值的cdf的补集&lt;equation&gt;\begin{align*} \Pr(\min\{X_1,\ldots, X_n\} &amp;gt; t) &amp;amp;= \Pr(X_1 &amp;gt; t, X_2 &amp;gt; t, \ldots, X_n &amp;gt; t) \\ &amp;amp;= \prod_{i=1}^n \exp(-\lambda_i t) \\ &amp;amp;=\exp\left(\sum_{i=1}^n \lambda_i t\right) \end{align*}&lt;/equation&gt;&lt;/p&gt;&lt;p&gt;所以&lt;equation&gt;\min\{X_1,X_2,\ldots, X_n\} \sim \text{Exp}(\lambda_1+\lambda_2+\ldots+\lambda_n)&lt;/equation&gt;。&lt;/p&gt;&lt;p&gt;这个告诉我们了&lt;equation&gt;\mathbb E[Y_v] = \mathbb E[\min_{u\in R_v} X_u] = \mathbb E[\text{Exp(|R_v|)}] = 1/|R_v|.&lt;/equation&gt;&lt;/p&gt;&lt;p&gt;我们知道了&lt;equation&gt;1/Y_v&lt;/equation&gt;是对&lt;equation&gt;|R_v|&lt;/equation&gt;一个很好的估计(Estimator)，那么我们需要多少个&lt;equation&gt;Y_v&lt;/equation&gt;的样本，才能很好的估计出&lt;equation&gt;|R_v|&lt;/equation&gt;呢？&lt;/p&gt;&lt;h2&gt;Median Trick&lt;/h2&gt;&lt;p&gt;事实上，我们只需要&lt;equation&gt;O\left(\frac{\log 1/\delta}{\epsilon^2}\right)&lt;/equation&gt;个样本就有很高的概率(&lt;equation&gt;1-\delta&lt;/equation&gt;)得到&lt;equation&gt;1\pm\epsilon&lt;/equation&gt;的估计。&lt;/p&gt;&lt;p&gt;证明：&lt;/p&gt;&lt;p&gt;首先假设我们我们有&lt;equation&gt;k&lt;/equation&gt;个&lt;equation&gt;Y_v&lt;/equation&gt;的样本，标记为&lt;equation&gt;Z_1,Z_2,\ldots, Z_k&lt;/equation&gt;，然后我们取他们的平均值&lt;equation&gt;\bar Z = \mu = \sum Z_i/k&lt;/equation&gt;。很显然，此处&lt;equation&gt;\mathbb E[\bar Z] = 1/|R_v|&lt;/equation&gt;。 为了使用切比雪夫不等式，我们计算它的方差：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align*} \text{Var}(\bar{Z}) &amp;amp;= \text{Var}\left(\sum_{i=1}^k \frac{Z_i}{k}\right) \\ &amp;amp;=\frac{1}{k^2}\text{Var}(\sum_{i=1}^k Z_i) \\ &amp;amp;=\frac{1}{k^2} \cdot k \cdot \frac{1}{{|R_v|}^2} \\ &amp;amp;=\frac{1}{k{|R_v|}^2}\\ &amp;amp;=\frac{\mu^2}{k} \end{align*}&lt;/equation&gt;&lt;/p&gt;&lt;p&gt;同时，我们注意到，当&lt;equation&gt;\epsilon &amp;lt; 0.1&lt;/equation&gt;的时候，如果得到了&lt;equation&gt;1/|R_v|&lt;/equation&gt;误差在&lt;equation&gt;0.5\epsilon&lt;/equation&gt;的估计，那么&lt;equation&gt;|R_v|&lt;/equation&gt;的误差范围在&lt;equation&gt;\epsilon&lt;/equation&gt;内。&lt;/p&gt;&lt;p&gt;切比学夫不等式告诉我们，&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align*} \Pr[|{\bar{Z} -\mu}| \leq 0.5\epsilon \mu] &amp;amp;\geq 1-\frac{\mu^2}{0.25k \epsilon^2 \mu^2} \\ &amp;amp;=1-\frac{1}{0.25k\epsilon^2} \end{align*}&lt;/equation&gt;&lt;/p&gt;&lt;p&gt;我们让&lt;equation&gt;k= \frac{4}{\epsilon^2}&lt;/equation&gt;, 我们有大于0.9的概率得到一个&lt;equation&gt;1\pm \epsilon&lt;/equation&gt;的估计。显然这个是不够高的 (考虑到我们后面需要使用union bound)，为了得到更高的概率，我们使用median trick来继续提高成功的概率。&lt;/p&gt;&lt;p&gt;假设我们把上面的过程独立地重复&lt;equation&gt;\ell&lt;/equation&gt;次，把这&lt;equation&gt;\ell&lt;/equation&gt;次的结果标做&lt;equation&gt;R_1,\ldots, R_\ell&lt;/equation&gt;。我们观察到：如果有一半以上的结果满足条件，那么这些数的中位数也满足条件。&lt;/p&gt;&lt;p&gt;我们定义&lt;equation&gt;H_i := 𝟙[{R_i \in ((1-\epsilon){|R_v|}, (1+\epsilon){|R_v|})}].&lt;/equation&gt;&lt;/p&gt;&lt;p&gt;因为&lt;equation&gt;\Pr[H_i] \geq 0.9&lt;/equation&gt;,所以&lt;equation&gt;\mathbb E[\sum_{i=1}^\ell H_i] = \ell\cdot \sum_{i=1}^\ell \mathbb E[H_i] \geq 0.9l.&lt;/equation&gt;&lt;/p&gt;&lt;p&gt;然后我们使用Hoeffding不等式:&lt;equation&gt;\Pr\left[\sum_{i=1}^\ell H_i \leq \frac{\ell}{2}\right] \leq \Pr\left[\sum_{i=1}^\ell H_i - \mathbb E\left[\sum_{i=1}^\ell H_i \right] &amp;gt; \frac{\ell}{4}\right]\leq e^{-\ell/8}.&lt;/equation&gt;&lt;/p&gt;&lt;p&gt;要让&lt;equation&gt;e^{-\ell/8} \leq \delta&lt;/equation&gt;, 我们只需要让&lt;equation&gt;\ell = \mathcal O(\log 1/\delta)&lt;/equation&gt;。所以我们一共需要&lt;equation&gt;\ell \cdot k=\mathcal O\left(\frac{\log 1/\delta}{\epsilon^2}\right)&lt;/equation&gt;个样本。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;根据布尔不等式(Union bound), 我们每次都成功的概率大于&lt;equation&gt;n\cdot \delta&lt;/equation&gt;, 要让这个概率大于&lt;equation&gt;0.9&lt;/equation&gt;的话，那么&lt;equation&gt;\delta \leq 1/n&lt;/equation&gt;，所以我们把原图复制&lt;equation&gt;O(\log(1/\delta)/\epsilon^2)&lt;/equation&gt;次，然后独立的运行最开始的算法，我们就有很高的概率得到原图的&lt;equation&gt;1\pm\epsilon&lt;/equation&gt;估计。 总的运行时间是:&lt;equation&gt;\mathcal O\left(\frac{1}{\epsilon^2} \cdot m\log^2 n \right).&lt;/equation&gt;&lt;/p&gt;</description>
<author>Guanghao Ye</author>
<guid isPermaLink="false">2018-11-08-48553348</guid>
<pubDate>Thu, 08 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Some Pattern on Programming</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-10-28-47852685.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/47852685&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我想说一些旧闻。更准确的说，我收集了很多旧闻，想整理一下，变成一个没那么旧的旧闻。&lt;/p&gt;&lt;p&gt;&lt;b&gt;0：对于很多编程语言，我们真能做到‘给出编程语言X跟Y，给X一步步加功能，修改下原本的功能，最后成为Y’。我们姑且叫这做计算力吧。这方面的Work数不胜数。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对于Effect，我们有：&lt;/p&gt;&lt;p&gt;C is a purely functional language&lt;/p&gt;&lt;p&gt;Dijkstra Monad（被EK吐槽就是hoare monad on continuation）&lt;/p&gt;&lt;p&gt;Lazy Functional State Thread&lt;/p&gt;&lt;p&gt;Lambda The Ultimate Imperative&lt;/p&gt;&lt;p&gt;Gedanken&lt;/p&gt;&lt;p&gt;对于Subtyping，我们有：&lt;/p&gt;&lt;p&gt;The Essence of Algol（这也应该算Effect的，但那边挤满了）&lt;/p&gt;&lt;p&gt;A Semantics of Multiple Inheritance&lt;/p&gt;&lt;p&gt;至于Type？那就更多了&lt;/p&gt;&lt;p&gt;Untyped Program is unityped program&lt;/p&gt;&lt;p&gt;Gradual Typing上的work，不太清楚&lt;/p&gt;&lt;p&gt;Well typed program cant be blamed&lt;/p&gt;&lt;p&gt;Type System as Macro&lt;/p&gt;&lt;p&gt;Semantic上面有Unified Theory of Programming&lt;/p&gt;&lt;p&gt;编译器上面某种意义上也符合这个样子，如Lambda The Ultimate Goto，Compiling With Continuation，就是在给你说‘你看，函数，高阶函数，其实还是goto那一套。’&lt;/p&gt;&lt;p&gt;当然，LTU Goto严格来说不算Compiler，各种东西都算一点，但不放这一个Compiling With Continuation好孤单（&lt;/p&gt;&lt;p&gt;最后，Prolog也能&lt;a href=&quot;https://vanemden.wordpress.com/2016/11/12/the-essence-of-algol/&quot;&gt;这样搞&lt;/a&gt;，Dijkstra老爷子厉害啊，一个小改动（GCL）竟然能影响到这&lt;/p&gt;&lt;p&gt;&lt;b&gt;1：在PL以外，我们也能做到这点，有的时候还能直接unify出以前还没发现的东西&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A Unifying theory of Garbage Collection - 你看看，各种GC算法都是一个路子的&lt;/p&gt;&lt;p&gt;The Periodic Table of Data Structures - 我给你把各种数据结构一家人排得齐齐整整，还给你说你还差啥家人&lt;/p&gt;&lt;p&gt;Demystifying Differentiable Programming - Symbolic Diff = ANF on forward mode, ho reverse mode = CPS fo reverse mode，dual on dual，好漂亮啊&lt;/p&gt;&lt;p&gt;The simple essence of Automatic Differentiation - 跟上面一个样子，Unify各种AD，但是更categorically theoretic&lt;/p&gt;&lt;p&gt;A Discipline of Programming, The Craft of Programming, A Principled Approach to OS，都是教你Stepwise Refinement怎么玩（推算法/写OS），ADOP附加到分布式的伏笔。&lt;/p&gt;&lt;p&gt;A Duality of Sorts，The algebra of programming就是Program Calculation的例子。顺带一提，Program Calculation，Stepwise Refinement，也是刚好对一起啊&lt;/p&gt;&lt;p&gt;Liquid Type，看完给我的感觉就是，I have a Subtyping，I have an Algol W，Uh! Liquid-Type！ &lt;/p&gt;&lt;p&gt;Stackless Scala With Free Monads，从Free搞TCO&lt;/p&gt;&lt;p&gt;最后不得不提Lambda the ultimate opcode，直接从某个Lisp Interpreter给你推出CPU wire！如果你问我我最喜欢那篇paper，以我的性格，估计我会看着这篇跟The essence of Algol，最后说出你们都是我的翅膀这种话吧。&lt;/p&gt;&lt;p&gt;另外一提，&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43163820&quot;&gt;如何制造SCP018&lt;/a&gt; 就是我看完Lambda The Ultimate Opcode，Compiling With Continuation，Stackless Scala With Free Monads，然后想，LTU Opcode能从代码推出wire，我为啥不能反其道而行之，CWC说cont = PC，我就从PC推出cont，再弄出TCO。这操作秀得我自己都好开心，觉得这是最有难度的一篇（其他的收集收集资料谁都能写，就这篇有点original work的样子），然而人民群众不喜欢，正所谓知识越多越反动，orz&lt;/p&gt;&lt;p&gt;差点忘了，CH-XXXXX同构。在这下面我们甚至开始Unify Lazy/Strict了，见Haskell is not not ML。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2：很多时候，我们能发现些Pattern，但我们不知道怎么从一边算到另一边。有的时候甚至不知道怎么用。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;CPU其实就是个Interpreter&lt;/p&gt;&lt;p&gt;SuperScalar那就对应Program Analysis&lt;/p&gt;&lt;p&gt;Binary Translation不就是jit吗，我建议大家把x86 cpu加进list of transpiler里面troll JavaScript weenie（（（&lt;/p&gt;&lt;p&gt;Types As Abstract Interpretations - 字面意义&lt;/p&gt;&lt;p&gt;Your computer is already a distributed system - 字面意义&lt;/p&gt;&lt;p&gt;Algebra, Algebra, Algebra。。。Algebraic Data Type, The Derivative of Regular Type, Partially-Static Data As Free Extension Of Algebras，还有各种算法里面都会有Algebra&lt;/p&gt;&lt;p&gt;DSL, DSL, DSL everywhere - SQL, ASM, BPF，各个都有安全隐患，需要设计防止（SQL injection, page protection, BPF的整个BPF instruction就是安全措施，不然直接ring0跑用户输入asm就行了啊，还要啥BPF instruction自行车）但是转念一想，这不就是在argue for effect system吗？&lt;br&gt; &lt;b&gt;3：还有些。。。insight？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/34819931/answer/482024102&quot;&gt;同时，这些例子都是Abstraction的极优例子&lt;/a&gt;，SQL/ASM抽象得原本领域是啥都不知道。&lt;/p&gt;&lt;p&gt;最后，差点忘了Machine Learning。以前就吐槽过，&lt;a href=&quot;https://www.zhihu.com/question/24975949/answer/370015097&quot;&gt;branch prediction就是mini classifier&lt;/a&gt;，想不到真有人用NN去做branch prediction了，maya。这不说，ML对各种连续的任务最近大发神威啊，Learned Index Structure, Auto TVM, Peloton, Data Calculator，Deep Coder，乃至AlphaGo，最近很流行的做法就是用ML去学概率/Cost，剩下的接着上传统方法（读作爆搜）。&lt;/p&gt;&lt;p&gt;一个Recurrent problem是concurrency - Distributed System，Database，Algorithm， OS，Cache Coherent，甚至钻牛角尖点，我们还可以说metastable态也是concurrency issue - tyranny of the clock。然而我们还是没有解决concurrency的方案&lt;/p&gt;&lt;p&gt;&lt;b&gt;4：有时候还发现更多的fundamental incoherency&lt;/b&gt;&lt;/p&gt;&lt;p&gt;比如说另一篇我很喜欢的paper就是Miscomputation in software: Learning to live with errors，尽管我早读过了，去看那句‘Pupil Omega: Yo, I tell you, errors are fun! ’还是会被吓一跳。。也许Programming is interface能用stepwise refinement说几句，但是live programming。。。Hazel？圆不过去啊&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其实我写这么多，我还是不知道我的中心思想是啥。本文没有中心思想，我也不知道有啥用，我猜我只是想说‘看，我能从一个东西算出另一个，多有趣啊’。也许CHI跟periodic table of datastructure有用，但是剩下的其实都是hindsight。&lt;/p&gt;&lt;p&gt;希望有一天我们能把4/3/2/1都往上移，到最后只剩下0，然后有一天任何一个计算机本科毕业生都能做到‘从继电器开始给你推导出现在的本科CS课程’，那多美妙啊。&lt;/p&gt;&lt;p&gt;Calculemus。如果我漏了啥例子求补充。&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2018-10-28-47852685</guid>
<pubDate>Sun, 28 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>代码编辑器系列 #3 文本的存储 进化篇</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-10-13-46693881.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/46693881&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d695aa142b6fe04d3f6579a57771fa31_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;http://ice1000.org/2018/09/24/CodeEditor4/&quot;&gt;ice1000.org&lt;/a&gt; 这是原文，发表在我的博客。&lt;/p&gt;&lt;p&gt;在&lt;a href=&quot;http://ice1000.org/2018/04/29/CodeEditor2/&quot;&gt;上上篇文章&lt;/a&gt;中我说过，&lt;/p&gt;&lt;blockquote&gt;以后的方向主要是讲 JB 式编辑器的实现&lt;/blockquote&gt;&lt;p&gt;在&lt;a href=&quot;http://ice1000.org/2018/06/05/CodeEditor3/&quot;&gt;上一篇文章&lt;/a&gt;中我又说，&lt;/p&gt;&lt;blockquote&gt;那么这篇文章先说点别的吧&lt;/blockquote&gt;&lt;p&gt;简直是王镜泽定理的完美演绎啊。 为什么我要在半个月来第一篇博客开头说这个呢？因为这次讲的依然不是 JB 式编辑器的实现，真香。&lt;/p&gt;&lt;p&gt;关于上一篇博客在说 gap buffer 的时候提到的数据结构论文 Flexichain，我当时说读下来没学到什么东西。 实际上论文有两篇，内容应该基本上都在另一篇讲实现的里面。这是某活跃于 freenode #lisp 的 CL 厨告诉我的。&lt;/p&gt;&lt;p&gt;在我最近的新项目里，我使用了 Flexichain 论文里提到的 Hemlock 编辑器使用的数据结构 （我的那个使用C++实现，改自一个单独的 Java 项目 &lt;a href=&quot;https://github.com/ice1000/text-sequence&quot;&gt;text-sequence&lt;/a&gt;，前文提到的实验项目也换成了这个项目里的 &lt;code class=&quot;inline&quot;&gt;GapBuffer&lt;/code&gt;）， 这个数据结构在 &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.48.1265&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;piece table 的论文&lt;/a&gt;里有一个类似物叫 Line Span，于是我就直接叫它 &lt;code class=&quot;inline&quot;&gt;LineSpan&lt;/code&gt; 了。&lt;/p&gt;&lt;p&gt;本文包含这篇论文中的大部分知识。&lt;/p&gt;&lt;p&gt;前文说，&lt;/p&gt;&lt;blockquote&gt;由于 Swing 的 API 看起来更低效&lt;/blockquote&gt;&lt;p&gt;其实不是的， Swing 文本编辑器内部实现是一个 &lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/javax/swing/text/GapContent.html&quot;&gt;GapContent&lt;/a&gt;&lt;/code&gt;， 也就是一个过度 OO 设计的 &lt;code class=&quot;inline&quot;&gt;GapBuffer&lt;/code&gt;（可见写 Swing 的人并不是文盲，而且文化程度不低），这比我那时候用的更高效，所以我那时的想法还是太幼稚了。&lt;/p&gt;&lt;p&gt;既然本文是现代篇（对应上一篇的远古篇），那么讲的肯定是现代编辑器使用的数据结构啦。&lt;/p&gt;&lt;p&gt;介绍一个概念 end of line ，通常是 &lt;code class=&quot;inline&quot;&gt;\n&lt;/code&gt; 但考虑到有些情况下还有别的行分隔符就使用了 end of line 代表这个东西。&lt;/p&gt;&lt;h2&gt;Code 早期使用的数据结构&lt;/h2&gt;&lt;p&gt;应该很少有人使用可执行文件的名字来称呼这个全名叫 Visual Studio Code 的编辑器吧，正好可以显得很装逼（逃。 根据黑历史考据，我看到 Code 团队在 &lt;a href=&quot;https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation&quot;&gt;blog&lt;/a&gt; 里自述曾经使用按行存储的策略， 然后他们获得的好处是可以按行运行 Tokenizer ，可以提高代码高亮的性能（意思就是直接不考虑包含 end of line 的 Token ，很符合前端人员的编程思想）。&lt;/p&gt;&lt;p&gt;这历史应该是黑成碳了。根据上面那个链接里的博客来看，他们也没有使用优化 active line 的策略（比如我使用 GapBuffer ）。 不过呢，按行存储可以进行渲染上的优化（因为行可以被视为一个渲染单位，而且在屏幕移动时每行渲染出来的样子是不变的）， 这在某种意义上也是一种好处了（根据一个研究超算的软粉的说法，Visual Studio 会缓存每行的代码渲染后得到的 texture）。&lt;/p&gt;&lt;p&gt;LineSpan 的实现相对 GapBuffer 较为繁琐，它在插入的时候需要检查是否有插入 end of line 来考虑是否要拆掉当前的 active line 、 需要在删除的时候检查是否删除了一个 end of line 来考虑是否要合并当前行和下一行。 好处是，可以对行进行批量操作。&lt;/p&gt;&lt;p&gt;目前我的编辑器也是临时使用的这种数据结构，而且比起他们这个还提高了当前行的编辑效率和获取行的效率。 我原本计划使用一个线段树维护每行的长度的前缀和（之所以没有选择我最喜欢的树状数组，是因为我还需要删点），这样可以获得 &lt;code class=&quot;inline&quot;&gt;O(log(n))&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;getLineInfoAt&lt;/code&gt; 等函数。 但是在后来发现要获取对应行的迭代器还需要对链表进行高效的随机访问（或者存储迭代器到线段树里，但这意义已经没有那么大了，因为要换 Piece Table 实现），我就放弃了。 不过鄙视人家的黑历史也没什么意思，毕竟 Code 除了代码编辑的其他地方做的还是很不错的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;我做了一个 LineSpan 的数据结构可视化（非常妙），上传到了 &lt;a href=&quot;https://www.bilibili.com/video/av32595178/&quot;&gt;bilibili&lt;/a&gt; 和 &lt;a href=&quot;https://youtu.be/GOsf8OdeS08&quot;&gt;YouTube&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;其他杂七杂八的数据结构&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Split-Merge Tree ，保证 Rope 的最小单位 Sequence 在一个长度范围内，超过就拆，小于就合并两个相邻的，是比平衡树更平衡的平衡树&lt;/li&gt;&lt;li&gt;Fixed-Size-Buffer ，扁平版 Split-Merge Tree，你也可以叫它 Split-Merge LinkedList&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;文本序列数据结构的通用性质&lt;/h2&gt;&lt;p&gt;看到这里，我们脑中应该已经有了一个文本序列数据结构的一个通用模型了。 在前文讲 Rope 的时候我曾经提到，它是将最小的文本表示作为了一种抽象结构并使用平衡树组合他们，然后举例了几种可能的实现—— 一个获取文本的函数、字符数组（C 风格字符串）、惰性读取的文件、另一颗平衡树等。 GapBuffer 其实也是一种实现。&lt;/p&gt;&lt;p&gt;我们可以尝试把这种思想套到 LineSpan 上，然后发现也完全适用——它其实只是提出了一种新的最小文本表示的实现—— &lt;code class=&quot;inline&quot;&gt;Line&lt;/code&gt;，并使用链表或者平衡树去组合他们而已。 我们来给这个抽象里的概念起个名字吧。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一个 item 指文本序列的最小单位，通常是 &lt;code class=&quot;inline&quot;&gt;char&lt;/code&gt; 或者 &lt;code class=&quot;inline&quot;&gt;wchar_t&lt;/code&gt;&lt;/li&gt;&lt;li&gt;一个 sequence 指一系列以各种方式组合并在逻辑上是连续的 item ，即刚才提到的抽象结构，比如 &lt;code class=&quot;inline&quot;&gt;LinkedList&amp;lt;Character&amp;gt;&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;std::list&amp;lt;char&amp;gt;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;一个 buffer 指一段在物理上连续的 item ，一般只在实现中涉及&lt;/li&gt;&lt;ul&gt;&lt;li&gt;比如 &lt;code class=&quot;inline&quot;&gt;std::vector&amp;lt;char&amp;gt;::data&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;java.util.ArrayList&amp;lt;Character&amp;gt;&lt;/code&gt; 里面的那个数组&lt;/li&gt;&lt;li&gt;比如 mmap&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一个 item 序列如果同时是 sequence 和 buffer 那么它是一个 span&lt;/li&gt;&lt;ul&gt;&lt;li&gt;比如 &lt;code class=&quot;inline&quot;&gt;java.lang.String&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;std::string&lt;/code&gt;&lt;/li&gt;&lt;li&gt;buffer 中的逻辑连续的一部分可以算作一个 span ，比如 GapBuffer&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一个 descriptor 指描述一段 sequence 的数据结构，比如 LineSpan 中通常需要一个 &lt;code class=&quot;inline&quot;&gt;LineInfo&lt;/code&gt; 来保存 span 的位置、长度，那么这个 &lt;code class=&quot;inline&quot;&gt;LineInfo&lt;/code&gt; 就是一个 descriptor&lt;/li&gt;&lt;ul&gt;&lt;li&gt;descriptor 通常持有一个 sequence 的指针&lt;/li&gt;&lt;li&gt;这个定义和&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.48.1265&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;论文&lt;/a&gt;里说的不太一样，是我觉得更好的定义&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;然后我们来总结一下我们见过的各种东西吧：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;java.lang.Character&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;char&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;wchar_t&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;ImWchar&lt;/code&gt; 是 item&lt;/li&gt;&lt;li&gt;Ruby/Lua/JavaScript/Dart/Perl 等语言中的 &lt;code class=&quot;inline&quot;&gt;string&lt;/code&gt; 是 span&lt;/li&gt;&lt;li&gt;Rope 是一个递归的 sequence （&lt;code class=&quot;inline&quot;&gt;type Rope = BalancedTree (Either Span Rope)&lt;/code&gt;）&lt;/li&gt;&lt;ul&gt;&lt;li&gt;平衡树的 &lt;code class=&quot;inline&quot;&gt;Node&lt;/code&gt; 类可以看作 span 的 descriptor&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;java.lang.StringBuilder&lt;/code&gt; 是一个大 buffer ，最左边那部分是一个 span， descriptor 持有这个 &lt;code class=&quot;inline&quot;&gt;StringBuilder&lt;/code&gt; 要 build 的 &lt;code class=&quot;inline&quot;&gt;String&lt;/code&gt; 的长度&lt;/li&gt;&lt;li&gt;GapBuffer 内部有一个大 buffer ，它由两个中间有一个 gap 的不断变化的 span 组成&lt;/li&gt;&lt;ul&gt;&lt;li&gt;第一个 span 的 descriptor 存储这个 span 的长度，第二个 span 的 descriptor 存储这个 span 在大 buffer 里的的起始点&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;LineSpan 可以看作一个 &lt;code class=&quot;inline&quot;&gt;java.util.LinkedList&amp;lt;java.lang.CharSequence&amp;gt;&lt;/code&gt; 或者 &lt;code class=&quot;inline&quot;&gt;std::list&amp;lt;std::string&amp;gt;&lt;/code&gt; 的封装，属于 sequence&lt;/li&gt;&lt;ul&gt;&lt;li&gt;链表的迭代器就是 descriptor ，里面存的是 sequence ， Code 早期的这些 sequence 全是 span ，我的实现里 active line 是 sequence ，其他行是 span&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;是不是一下子就搞懂这些名词的含义了？下面我们将使用这套名词介绍一个新数据结构。&lt;/p&gt;&lt;h2&gt;Piece Table&lt;/h2&gt;&lt;p&gt;这是我目前觉得最好的文本编辑器存储数据所使用的数据结构。&lt;/p&gt;&lt;p&gt;Piece Table 由一个巨大的、 immutable 的、最好是 lazy 的 buffer （mmap 很适合作为这个 buffer）和一系列指向 span 的 descriptor 组成。 Descriptor 保存两个信息，头指针和长度。这一系列 descriptor 可以由链表保存（实现简单），也可以使用平衡树保存（更高效）。 由于我们不需要修改或者删除这些 descriptor 指向的 span ，我们可以把他们持有的 span 放进一个 buffer ，我们称之为 add buffer ，可以理解为一个 &lt;code class=&quot;inline&quot;&gt;ArrayList&amp;lt;Item&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在创建一个 Piece Table 的时候，我们需要初始化这个巨大的 buffer ，比如文本编辑器打开一个文件的时候就可以使用文件的 mmap 。 此时我们也初始化第一个 descriptor ，头指针指向大 buffer 的开头，长度就是整个 buffer 。&lt;/p&gt;&lt;h2&gt;查询&lt;/h2&gt;&lt;p&gt;如果给定 &lt;code class=&quot;inline&quot;&gt;offset&lt;/code&gt; 要取一个 Item ，就涉及存储 descriptor 的数据结构了—— 链表的话从头开始遍历 descriptor ，找到这个 &lt;code class=&quot;inline&quot;&gt;offset&lt;/code&gt; 所在的 descriptor 然后就可以从 buffer 里取值了，复杂度 &lt;code class=&quot;inline&quot;&gt;O(n)&lt;/code&gt;。 如果是平衡树就可以直接从 &lt;code class=&quot;inline&quot;&gt;offset&lt;/code&gt; 去找，复杂度 &lt;code class=&quot;inline&quot;&gt;O(log(n))&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;插入&lt;/h2&gt;&lt;p&gt;插入任意内容时（假设输入了 &lt;code class=&quot;inline&quot;&gt;offset&lt;/code&gt;（即&lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt;）和 &lt;code class=&quot;inline&quot;&gt;sequence&lt;/code&gt;），类似 LineSpan 插入 end of line 的情况，需要把这个 &lt;code class=&quot;inline&quot;&gt;offset&lt;/code&gt; 所在的那个 descriptor 拆掉，变成两个分别描述原本的 descriptor 在 &lt;code class=&quot;inline&quot;&gt;offset&lt;/code&gt; 前的那一半和后的那一半，然后把 &lt;code class=&quot;inline&quot;&gt;sequence&lt;/code&gt; 添加到 add buffer 的尾部， 然后在刚才这两个 descriptor 的中间插入一个指向这个 &lt;code class=&quot;inline&quot;&gt;sequence&lt;/code&gt; 在 add buffer 中位置的 descriptor 。&lt;/p&gt;&lt;p&gt;举个例子，假设我们有一个文件，里面有 &lt;code class=&quot;inline&quot;&gt;Piece&lt;/code&gt; 这几个字符。我们用它创建一个 Piece Table 后，大 buffer 里就是 &lt;code class=&quot;inline&quot;&gt;Piece&lt;/code&gt; ，长度为 5。 Descriptor 序列是这样的：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-aff8738ffefa9bc905cc7170c57aab5e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;305&quot; data-rawheight=&quot;80&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-aff8738ffefa9bc905cc7170c57aab5e&quot; data-watermark-src=&quot;v2-581d89340a84dabbbc456a3306380204&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们对他进行 &lt;code class=&quot;inline&quot;&gt;insert(1, &quot;Tb&quot;)&lt;/code&gt; ，那么先把 1 这个 &lt;code class=&quot;inline&quot;&gt;offset&lt;/code&gt; 所在的 0 号（查找 descriptor 的方法同查询） descriptor 拆开，原本长度为 5 的变成一个长度为 1 的和一个长度为 4 的：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7ee1f223b5c8a3abd3976c4d41f0ec9a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;307&quot; data-rawheight=&quot;107&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7ee1f223b5c8a3abd3976c4d41f0ec9a&quot; data-watermark-src=&quot;v2-2785f3696d94ccfb3e4b4d72d30c5bb3&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;然后向 add buffer 添加 &lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt; 这两个 Item ，然后在刚才两个 descriptor 中间插入一个新的 descriptor ：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e27847c18603aa4f1e62ccd12d8cc238_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;311&quot; data-rawheight=&quot;151&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e27847c18603aa4f1e62ccd12d8cc238&quot; data-watermark-src=&quot;v2-a505be4ef946b61cc3c4af3114f8b31f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;删除&lt;/h2&gt;&lt;p&gt;查找到 &lt;code class=&quot;inline&quot;&gt;offset&lt;/code&gt; 所在的 descriptor ，拆成两个并让左边那个的长度减一即可。&lt;/p&gt;&lt;h2&gt;Piece Table 的优良性质&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;可持久化数据结构&lt;/li&gt;&lt;li&gt;背后的大 buffer 可以完全 lazy 化，内存中的数据量将会巨小&lt;/li&gt;&lt;li&gt;descriptor 数量少&lt;/li&gt;&lt;li&gt;可以方便地使用平衡树优化&lt;/li&gt;&lt;li&gt;可以被翻译成『坨坨桌子』，很可爱&lt;/li&gt;&lt;li&gt;它可是 Code 使用的数据结构啊，搞懂了之后拿来吹的时候逼格挺高的&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Benchmark&lt;/h2&gt;&lt;p&gt;看论文去。&lt;/p&gt;&lt;p&gt;&amp;lt;end of blog&amp;gt;&lt;/p&gt;</description>
<author>兴趣使然千里冰封</author>
<guid isPermaLink="false">2018-10-13-46693881</guid>
<pubDate>Sat, 13 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>用Control.Dsl代替Monad</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-10-05-46014989.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/46014989&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Control.Dsl&lt;/code&gt;为Haskell提供了一套工具集来创建“可扩展”的领域特定语言，定制DSL&lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块。&lt;/p&gt;&lt;p&gt;DSL &lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块可以包含来自不同作者提供的各种操作。每个操作可以定义为一个GADT，由&lt;code class=&quot;inline&quot;&gt;Dsl&lt;/code&gt;类型类来解释执行，既可以有副作用，也可以是纯函数。&lt;/p&gt;&lt;p&gt;DSL &lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块是个抽象的“脚本”，其依赖的类型类可以自动推断。因此，只要提供不同的类型类实例，数据结构和解释器实现都可以随之改变。&lt;/p&gt;&lt;p&gt;本文剩下部分将会介绍如何用&lt;code class=&quot;inline&quot;&gt;Control.Dsl&lt;/code&gt;创建一门可扩展DSL，以及可以切换的两个解释器。 文中所有代码都基于&lt;code class=&quot;inline&quot;&gt;control-dsl&lt;/code&gt;包，可以在&lt;code class=&quot;inline&quot;&gt;ghci&lt;/code&gt;中运行。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Getting started&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Dsl&lt;/code&gt;类型类提供了&lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;、 &lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;=&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;return&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;fail&lt;/code&gt;等操作，用来代替&lt;code class=&quot;inline&quot;&gt;Monad&lt;/code&gt;中的对应操作。 你可以使用&lt;code class=&quot;inline&quot;&gt;RebindableSyntax&lt;/code&gt;扩展来启用&lt;code class=&quot;inline&quot;&gt;Dsl&lt;/code&gt;版的定制&lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块。 &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :set -XRebindableSyntax
&amp;gt;&amp;gt;&amp;gt; import Prelude hiding ((&amp;gt;&amp;gt;), (&amp;gt;&amp;gt;=), return, fail)
&amp;gt;&amp;gt;&amp;gt; import Control.Dsl&lt;/code&gt;&lt;h2&gt;&lt;b&gt;DSL model&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果你要创建一门DSL来执行控制台的IO操作，你可以以GADT方式定义一些DSL中的基本操作：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; data MaxLengthConfig r a where MaxLengthConfig :: MaxLengthConfig r Int
&amp;gt;&amp;gt;&amp;gt; data GetLine r a where GetLine :: GetLine r String
&amp;gt;&amp;gt;&amp;gt; data PutStrLn r a where PutStrLn :: String -&amp;gt; PutStrLn r ()&lt;/code&gt;&lt;h2&gt;&lt;b&gt;DSL&lt;/b&gt; &lt;b&gt;&lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;&lt;/b&gt;语句块&lt;/h2&gt;&lt;p&gt;以上操作可以用于&lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
dslBlock = do
  maxLength &amp;lt;- MaxLengthConfig
  line1 &amp;lt;- GetLine
  line2 &amp;lt;- GetLine
  when (length line1 + length line2 &amp;gt; maxLength) $ do
    PutStrLn &quot;The input is too long&quot;
    fail &quot;Illegal input&quot;
  PutStrLn (&quot;The input is &quot; ++ line1 ++ &quot; and &quot; ++ line2)
  return ()
:}&lt;/code&gt;&lt;p&gt;以上&lt;code class=&quot;inline&quot;&gt;dslBlock&lt;/code&gt;函数利用刚定义的操作和Control.Dsl内置操作创建了一段DSL抽象脚本。&lt;/p&gt;&lt;p&gt;GADT操作和结果语句（&lt;code class=&quot;inline&quot;&gt;return&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;fail&lt;/code&gt;）都是特设多态的限界continuation（ad-hoc polymorphic delimited continuations），由类型类&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;解释执行。GHC可以把所需的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;类型自动推断出来：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :type dslBlock
dslBlock
  :: (PolyCont (Return IOError) r Void, PolyCont (Return ()) r Void,
      PolyCont MaxLengthConfig r Int, PolyCont GetLine r [Char],
      PolyCont PutStrLn r ()) =&amp;gt;
     r&lt;/code&gt;&lt;h2&gt;&lt;b&gt;创建无副作用解释器&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;只要提供了适用的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt; 实例，&lt;code class=&quot;inline&quot;&gt;r&lt;/code&gt;可以是任意类型。比如：以下代码定义了无副作用的解释器&lt;code class=&quot;inline&quot;&gt;PureInterpreter&lt;/code&gt;以及对应的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;实例：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; type PureInterpreter = Int -&amp;gt; [String] -&amp;gt; Cont [String] IOError&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont MaxLengthConfig PureInterpreter Int where
  runPolyCont MaxLengthConfig = runPolyCont Get
:}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont PutStrLn PureInterpreter () where
  runPolyCont (PutStrLn s) = runPolyCont (Yield s)
:}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont (Return ()) PureInterpreter Void where
  runPolyCont (Return ()) = runPolyCont Empty
:}&lt;/code&gt;&lt;p&gt;以上三个&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;实例简单的转发到Control.Dsl的内置操作上。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont GetLine PureInterpreter String where
  runPolyCont k = runCont $ do
    x : xs &amp;lt;- Get @[String]
    Put xs
    return x
:}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;GetLine&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;实例要稍微复杂一些，实现为一个&lt;code class=&quot;inline&quot;&gt;Cont&lt;/code&gt; ，由若干个内置操作组合而成。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;无副作用地运行DSL&lt;/b&gt;&lt;/h2&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; runPurely = dslBlock :: PureInterpreter
&amp;gt;&amp;gt;&amp;gt; errorHandler e = [&quot;(handled) &quot; ++ show e]&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; runCont (runPurely 80 [&quot;LINE_1&quot;, &quot;LINE_2&quot;]) errorHandler
[&quot;The input is LINE_1 and LINE_2&quot;]&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; longInput = [replicate 40 &#39;*&#39;, replicate 41 &#39;*&#39;]
&amp;gt;&amp;gt;&amp;gt; runCont (runPurely 80 longInput) errorHandler
[&quot;The input is too long&quot;,&quot;(handled) user error (Illegal input)&quot;]&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; runCont (runPurely 80 [&quot;ONE_LINE&quot;]) errorHandler
[&quot;(handled) user error (Pattern match failure in do expression at &amp;lt;interactive&amp;gt;...&quot;]&lt;/code&gt;&lt;h2&gt;&lt;b&gt;创建有副作用的解释器&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;此外，只要提供了有副作用的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;实例，&lt;code class=&quot;inline&quot;&gt;dslBlock&lt;/code&gt;还能以带副作用的方式运行。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; type EffectfulInterpreter = Handle -&amp;gt; IO ()&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont GetLine EffectfulInterpreter String where
  runPolyCont GetLine = runCont $ do
    h &amp;lt;- Get
    line &amp;lt;- Monadic (hGetLine h)
    return line
:}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Monadic&lt;/code&gt;是个内置操作，可以在DSL &lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块执行monad操作，比如IO。其他操作（比如&lt;code class=&quot;inline&quot;&gt;Get&lt;/code&gt;）可以和&lt;code class=&quot;inline&quot;&gt;Monadic&lt;/code&gt;出现在同一个&lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块，而不需要任何monad transformer。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont MaxLengthConfig (IO ()) Int where
  runPolyCont MaxLengthConfig f = f 80
:}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont PutStrLn (IO ()) () where
  runPolyCont (PutStrLn s) = (Prelude.&amp;gt;&amp;gt;=) (putStrLn s)
:}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont (Return IOError) (IO ()) Void where
  runPolyCont (Return e) _ = hPutStrLn stderr (show e)
:}&lt;/code&gt;&lt;h2&gt;&lt;b&gt;以副作用方式运行DSL&lt;/b&gt;&lt;/h2&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; runEffectfully = dslBlock :: EffectfulInterpreter&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
withSystemTempFile &quot;tmp-input-file&quot; $ \_ -&amp;gt; \h -&amp;gt; do
  Monadic $ hPutStrLn h &quot;LINE_1&quot;
  Monadic $ hPutStrLn h &quot;LINE_2&quot;
  Monadic $ hSeek h AbsoluteSeek 0
  runEffectfully h
:}
The input is LINE_1 and LINE_2&lt;/code&gt;&lt;h2&gt;&lt;b&gt;结论&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了如何用&lt;code class=&quot;inline&quot;&gt;Control.Dsl&lt;/code&gt;创建自己的DSL。不同于&lt;code class=&quot;inline&quot;&gt;Monad&lt;/code&gt;，用&lt;code class=&quot;inline&quot;&gt;Control.Dsl&lt;/code&gt;创建的DSL可以扩展。只要创建GADT和对应的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;，就可以为现有的解释器添加新操作。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;相关链接&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Atry/Control.Dsl&quot;&gt;Control.Dsl on Github&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://hackage.haskell.org/package/control-dsl&quot;&gt;control-dsl on Hackage&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2018-10-05-46014989</guid>
<pubDate>Fri, 05 Oct 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
