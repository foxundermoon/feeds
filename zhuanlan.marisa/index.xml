<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Wed, 04 Apr 2018 21:30:10 +0800</lastBuildDate>
<item>
<title>Programming Languages: Application and Interpretation【译16】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-04-35291037.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35291037&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1575f6b8191e20ef774d57c41608be45_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;初翻： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/802e5a4b8b40cc8d665968a2ad620302&quot; data-hash=&quot;802e5a4b8b40cc8d665968a2ad620302&quot; data-hovercard=&quot;p$b$802e5a4b8b40cc8d665968a2ad620302&quot;&gt;@MrMathematica&lt;/a&gt; &lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//lotuc.gitbooks.io/plai-cn/content/&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;16 动态地检查程序中的不变量：契约&lt;/h2&gt;&lt;p&gt;类型系统提供了丰富且有价值的表示程序不变量的方式。然而，它们也代表了一种重要的权衡，因为并非所有程序的非平凡属性都可以被静态验证。【注释】此外，即使某个属性可以设计静态方法解决，注解和计算复杂度的负担也可能过大。因此，我们所关心的一些属性不可避免地只能被忽略或在运行时解决。本章我们来讨论运行时检查不变量。&lt;/p&gt;&lt;blockquote&gt;这是一个正式的定理，被称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Rice&#39;s_theorem&quot;&gt;赖斯定理&lt;/a&gt;。&lt;/blockquote&gt;&lt;p&gt;实际上，每种编程语言都包含某种形式的断言机制，使程序员能够编写比语言的静态类型系统允许的更丰富的属性。在没有静态类型的语言中，这些属性可能以简单的类型断言开始：例如，某个参数是否为数。然而，断言语言通常是整个编程语言，因此任何谓词都可以用作断言：例如，某个加密包的实现可能希望确保某些参数通过素性测试，或者某个平衡二叉搜索树可能想要确保其子树确实是平衡且有序的。&lt;/p&gt;&lt;h2&gt;16.1 以契约实现谓词&lt;/h2&gt;&lt;p&gt;因此很容易想到如何实现简单的契约（contract）。【注释】契约包含一个谓词。它读入一个值并将谓词应用于该值。如果值能通过谓词判断，则契约原样返回该值；否则，该契约会报告错误。其行为只能是返回原值或报错：它不应以任何方式更改值。简而言之，对于能通过谓词的值，契约本身就是恒等函数。&lt;/p&gt;&lt;blockquote&gt;下面我们将使用&lt;code class=&quot;inline&quot;&gt;#lang plai&lt;/code&gt;语言，原因有两个。首先，这更好地模拟了动态类型语言编程。其次，为了简单起见，我们将契约写成类型化的断言，但是在静态类型语言中，它们将由类型检查器处理，使得我们无法看到运行时行为。从效果来看，“关闭”类型检查器会更容易。然而，即使在静态类型的世界里，契约也是非常有意义的，因为它们增强了程序员可以表达的不变量。&lt;/blockquote&gt;&lt;p&gt;我们使用如下函数编码该本质：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (make-contract pred?)
  (lambda (val)
    (if (pred? val) val (blame &quot;violation&quot;))))

(define (blame s) (error &#39;contract &quot;~a&quot; s))&lt;/code&gt;&lt;p&gt;契约的例子：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define non-neg?-contract
  (make-contract
   (lambda (n) (and (number? n)
                    (&amp;gt;= n 0)))))&lt;/code&gt;&lt;p&gt;（在静态类型语言中，检查&lt;code class=&quot;inline&quot;&gt;number?&lt;/code&gt;当然是不必要的，因为它可以在类型系统中使用契约函数的方式静态检查！）假设我们要确保计算平方根时不会得到虚数；可以这么写&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (real-sqrt-1 x)
  (sqrt (non-neg?-contract x)))&lt;/code&gt;&lt;p&gt;在很多语言中，断言是写作语句而不是表达式，所以另一种编写方式是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (real-sqrt-2 x)
  (begin
    (non-neg?-contract x)
    (sqrt x)))&lt;/code&gt;&lt;p&gt;（在某些情况下，这种形式更清晰，因为它在函数的开始部分清晰地声明了参数的期望值。它还确保参数只被检查一次。实际上，在某些语言中，契约可以写入函数头部中 ，从而改善接口给出的信息。）现在，如果将&lt;code class=&quot;inline&quot;&gt;real-sqrt-1&lt;/code&gt;或&lt;code class=&quot;inline&quot;&gt;real-sqrt-2&lt;/code&gt;应用于&lt;code class=&quot;inline&quot;&gt;4&lt;/code&gt;，则它们产生&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;，但如果应用于&lt;code class=&quot;inline&quot;&gt;-1&lt;/code&gt;，则会引发违反契约的错误。&lt;/p&gt;&lt;h2&gt;16.2 标签、类型和对值的观测&lt;/h2&gt;&lt;p&gt;到这里我们已经重现了大多数语言中断言系统的本质。还有什么要讨论的？我们先假设手上的语言不是静态类型的。我们希望编写的断言至少要能重现传统的类型不变量，甚至更多。前述的&lt;code class=&quot;inline&quot;&gt;make-contract&lt;/code&gt;可以覆盖所有标准类型的属性，比如检查数、字符串等等，假设语言提供了合适的谓词，或者可以从已有的谓词中构造出来。是这样吗？&lt;/p&gt;&lt;p&gt;回想一下，即使我们最简单的类型语言也不仅仅只包含数等基本类型，还包含构造类型。尽管其中的一些，如链表和向量，似乎并不是很难，但一旦涉及赋值、性能和问责，挑战就来了，后面将讨论它们。然而，函数就很难处理了。&lt;/p&gt;&lt;p&gt;作为示例，我们来看这个函数：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define d/dx
  (lambda (f)
    (lambda (x)
      (/ (- (f (+ x 0.001))
            (f x))
         0.001))))&lt;/code&gt;&lt;p&gt;其静态类型是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;((number -&amp;gt; number) -&amp;gt; (number -&amp;gt; number))&lt;/code&gt;&lt;p&gt;（它读入一个函数，并生成其导数——也是个函数。）假设我们想用契约来处理这种情况。&lt;/p&gt;&lt;p&gt;根本的问题是，在大多数语言中，我们无法直接将其表示为谓词。大多数语言的运行时系统关于值的类型存储了非常有限的信息——相对于我们目前所看到的类型，这些信息太过有限，我们应该用不同的名称来描述它们；传统上它们被称为&lt;b&gt;标签&lt;/b&gt;（tag）。【注释】有些情况下，标签与我们认为是类型的不谋而合：例如，数会带上标识其为数的标签（甚至可能是某种特定类型的数）、字符串带有标识其为字符串的标签，等等。因此，我们可以基于这些标签的值来编写谓词。&lt;/p&gt;&lt;blockquote&gt;已经有一些工作试图保存丰富的类型信息，从源程序到较低的抽象层次、一直到汇编语言，但这些都是研究工作。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;当我们处理结构化值时，情况就复杂了。向量将会带有标签声明它是向量，但不会指明它的元素是什么类型的值（而且它们甚至可能都不是同一类型）；不过，程序通常也可以获得向量的大小，从而遍历向量来收集此信息。（然而，关于结构化值后面还更多有待讨论的。）&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;编写契约，检查只包含偶数的链表。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;这就是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define list-of-even?-contract
  (make-contract
   (lambda (l)
     (and (list? l) (andmap number? l) (andmap even? l)))))&lt;/code&gt;&lt;p&gt;（同样，请注意，如果我们静态地知道这是数的链表，则无需问前两个问题。）类似地，对象可能只将自己标识为对象，而不提供其他信息。但是，在允许对对象结构进行反射（reflection）的语言中，契约仍可以收集它所需的信息。&lt;/p&gt;&lt;p&gt;然而，在任何语言中，当遇到函数时就出问题了。我们一般将函数的类型理解为包含其输入和输出的类型，但是对运行时系统，函数只是带有函数标签的不透明对象，可能还有一些非常有限的元数据（如函数的参数数量）。运行时系统甚至难以分辨函数是否读入和生成函数——而非其他类型的值——更不用说判断它是否读入并生成&lt;code class=&quot;inline&quot;&gt;(number -&amp;gt; number)&lt;/code&gt;类型的函数了。&lt;/p&gt;&lt;p&gt;这个问题很好地体现在JavaScript的（错误命名的）&lt;code class=&quot;inline&quot;&gt;typeof&lt;/code&gt;运算符中。传给其数或字符串等基本类型的值，&lt;code class=&quot;inline&quot;&gt;typeof&lt;/code&gt;会返回对应类型名字的字符串（例如&lt;code class=&quot;inline&quot;&gt;&quot;number&quot;&lt;/code&gt;）。对于对象，它返回&lt;code class=&quot;inline&quot;&gt;&quot;object&quot;&lt;/code&gt;。最要命的是，对于函数它返回&lt;code class=&quot;inline&quot;&gt;&quot;function&quot;&lt;/code&gt;，没有额外的信息。&lt;/p&gt;&lt;blockquote&gt;出于这个原因，&lt;code class=&quot;inline&quot;&gt;typeof&lt;/code&gt;对这个操作符来说可能是个糟糕的名字。它应该被称为&lt;code class=&quot;inline&quot;&gt;tagof&lt;/code&gt;，为未来的可能出现的JavaScript静态类型系统留下的&lt;code class=&quot;inline&quot;&gt;typeof&lt;/code&gt;这个名字。&lt;/blockquote&gt;&lt;p&gt;总而言之，这意味着当遇到函数时，函数契约只能检查它是否的确是函数（如果不是，那显然是错误的）。它无法检查有关该函数的定义域和值域的任何信息。我们要放弃吗？&lt;/p&gt;&lt;h2&gt;16.3 高阶契约&lt;/h2&gt;&lt;p&gt;为了确定要做什么，我们先回忆一下契约最初提供了什么保证。在前述的&lt;code class=&quot;inline&quot;&gt;real-sqrt-1&lt;/code&gt;中，我们要求参数是非负的。然而，只有在&lt;code class=&quot;inline&quot;&gt;real-sqrt-1&lt;/code&gt;被实际使用时才会进行检查，并且仅检查实际传入的值。例如，如果程序包含片段&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda () (real-sqrt-1 -1))&lt;/code&gt;&lt;p&gt;但该thunk一直没被调用，那么程序员将永远不会看到这里的契约被违反。事实上，可能在程序的这次运行中没有调用此thunk，但在后一次运行中调用到了；因此，该程序包含一个潜在的契约错误。出于此原因，通常最好用静态类型来表示不变量；但在使用契约时，我们明白，仅当程序执行到相关位置时，我们才会收到错误通知。&lt;/p&gt;&lt;p&gt;这是有用的见解，因为它为我们的函数问题提供了解决方案。对于指明的函数值，我们立即检查它真的是函数。但是，我们不会忽略定义域和值域的契约，而是&lt;b&gt;延迟&lt;/b&gt;处理。我们在函数（每次）实际作用于某个值时检查定义域契约，并在函数实际返回值时检查值域契约。&lt;/p&gt;&lt;p&gt;这显然和&lt;code class=&quot;inline&quot;&gt;make-contract&lt;/code&gt;不是一种模式。因此，我们给&lt;code class=&quot;inline&quot;&gt;make-contract&lt;/code&gt;起个更具描述性的名称：它检查&lt;b&gt;即时的&lt;/b&gt;（immediate）契约（即当前可以完整检查的契约）。&lt;/p&gt;&lt;blockquote&gt;在Racket契约系统中，即时契约被称为&lt;b&gt;扁平的&lt;/b&gt;（flat）。这个术语有点误导，因为它们也可以保护数据结构。&lt;/blockquote&gt;&lt;code lang=&quot;racket&quot;&gt;(define (immediate pred?)
  (lambda (val)
    (if (pred? val) val (blame val))))&lt;/code&gt;&lt;p&gt;相比之下，函数契约读入两个契约作为参数——分别表示对定义域和值域的检查——并返回谓词。这个谓词作用于需要满足契约的值。首先，它会检查给定的值实际上是函数：这部分仍然是即时的。然后，我们创建一个&lt;b&gt;代理&lt;/b&gt;（surrogate）函数，由它来应用“剩余的”契约——检查定义域和值域——但其他方面与原函数行为相同。&lt;/p&gt;&lt;p&gt;创建代理这一行为背离了传统的断言机制，也就是只是简单地检查而不改变值。相反，对于函数，如果想要检查契约，我们必须使用新创建的代理。因此，一般来说我们需要创建封装函数，它会读入契约和值，并创建该值的保护版本：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (guard ctc val) (ctc val))&lt;/code&gt;&lt;p&gt;一个非常简单的例子，假设我们要用数契约包装&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;函数（使用稍后定义的函数契约的构造函数&lt;code class=&quot;inline&quot;&gt;function&lt;/code&gt;）：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define a1 (guard (function (immediate number?)
                            (immediate number?))
                  add1))&lt;/code&gt;&lt;p&gt;我们希望&lt;code class=&quot;inline&quot;&gt;a1&lt;/code&gt;本质上绑定到以下代码：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define a1
  (lambda (x)
    (num?-con (add1 (num?-con x)))))&lt;/code&gt;&lt;p&gt;其中&lt;code class=&quot;inline&quot;&gt;(lambda (x) ...)&lt;/code&gt;是代理；它会&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;的调用之处前后调用数值契约。回忆一下，在没有违规的情况下，契约的行为就是恒等函数，所以这个程序在不违规的情况下行为于&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;完全相同。&lt;/p&gt;&lt;p&gt;为了达到此目的，我们使用下面的&lt;code class=&quot;inline&quot;&gt;function&lt;/code&gt;定义。【注释】请记住，我们还必须确保给定的值真的是函数（这里的&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;的确是，这一点可以立即检查，这也是为什么在我们将代理绑定到a1时此项检查已经消失的原因）：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (function dom rng)
  (lambda (val)
    (if (procedure? val)
        (lambda (x) (rng (val (dom x))))
        (blame val))))&lt;/code&gt;&lt;blockquote&gt;简单起见，我们这里假设单参数函数，不过扩展到多参数的情况很简单。事实上，更复杂的契约甚至可以检查参数&lt;b&gt;之间&lt;/b&gt;的关系。&lt;/blockquote&gt;&lt;p&gt;要理解这是如何工作的，我们来替换参数。为了保持代码可读性，我们先构造&lt;code class=&quot;inline&quot;&gt;number?&lt;/code&gt;契约检查器，并将其命名：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define num?-con (immediate number?))
= (define num?-con
    (lambda (val)
      (if (number? val) val (blame val))))&lt;/code&gt;&lt;p&gt;回到&lt;code class=&quot;inline&quot;&gt;a1&lt;/code&gt;的定义。我们先调用&lt;code class=&quot;inline&quot;&gt;guard&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define a1
  ((function num?-con num?-con)
   add1))&lt;/code&gt;&lt;p&gt;接下来调用函数契约的构造函数：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define a1
  ((lambda (val)
     (if (procedure? val)
         (lambda (x) (num?-con (val (num?-con x))))
         (blame val)))
   add1))&lt;/code&gt;&lt;p&gt;调用左括号-左括号-lambda得：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define a1
  (if (procedure? add1)
      (lambda (x) (num?-con (add1 (num?-con x))))
      (blame add1)))&lt;/code&gt;&lt;p&gt;请注意，这一步会检查被保护的值的确是函数。因此我们得到&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define a1
  (lambda (x)
    (num?-con (add1 (num?-con x)))))&lt;/code&gt;&lt;p&gt;这正是我们想要获得的代理，对于不违规的调用，其行为就是&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;有多少种方式可以违背上述的&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;契约？&lt;/blockquote&gt;&lt;p&gt;三种方式，分别对应于三个契约构造函数：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;被封装的值可能不是函数；&lt;/li&gt;&lt;li&gt;被封装的是函数，它可能被作用于不为数的值；或者&lt;/li&gt;&lt;li&gt;被封装的是函数，输入也是数，但其返回值不是数类型。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;编写示例实现这三种违规行为，并观察契约系统的行为。你能改进错误信息以更好地区分这些情况吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;同样的封装技术也适用于&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define d/dx
  (guard (function (function (immediate number?) (immediate number?))
                   (function (immediate number?) (immediate number?)))
         (lambda (f)
           (lambda (x)
             (/ (- (f (+ x 0.001))
                   (f x))
                0.001)))))&lt;/code&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;违反此契约的方式有七种，分别对应于七个契约构造函数。根据需要，传入（错误的）参数或修改代码，以违反它们中的每一个。是否可以改进错误报告，以正确识别每种违规行为？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;请注意，嵌套函数的契约推迟了两处即时契约的检查，而不是一处。这符合我们的期望，因为即时契约只能报告实际值的问题，所以直到应用于实际值之前，它们无法报告任何错误。但是，这确实意味着“违规”这个概念很微妙：传递给&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;的函数值可能的确违反了契约，但这类违规只有在传递或返回数值之后才会被&lt;b&gt;观测&lt;/b&gt;到。&lt;/p&gt;&lt;h2&gt;16.4 便捷语法&lt;/h2&gt;&lt;p&gt;之前我们看到了两种扁平契约的使用风格，分别由&lt;code class=&quot;inline&quot;&gt;real-sqrt-1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;real-sqrt-2&lt;/code&gt;体现。这两种风格各有缺点。后者让人联想到传统的断言系统，它不能用于高阶值（函数），因为被封装的值才需要检查。（当然，传统的断言系统只处理扁平契约，所以它们忽略了这个细微的差别。）前者将值的使用放与契约之中，理论上这可行，但有三个缺点：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;开发人员可能会忘记封装某些使用。&lt;/li&gt;&lt;li&gt;契约在每次使用中都会被检查一次，在多次使用时这是浪费。&lt;/li&gt;&lt;li&gt;程序混合了契约检查和其功能行为，降低了可读性。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;幸运的是，一般情况下，明智地使用语法糖就可以解决此问题。例如，假设我们要将契约附加到函数的参数上，那么开发人员可以这么编写：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define/contract (real-sqrt (x :: (immediate positive?)))
  (sqrt x))&lt;/code&gt;&lt;p&gt;意图是用&lt;code class=&quot;inline&quot;&gt;positive?&lt;/code&gt;来保护&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;，但只在函数调用时只执行一次检查。这应该转化为：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (real-sqrt new-x)
  (let ([x (guard (immediate positive?) new-x)])
    (sqrt x)))&lt;/code&gt;&lt;p&gt;也就是说，宏为每个标识符生成新名称，然后将用户给出的名称关联到新名称的封装版本。这个宏的实现如下：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define-syntax (define/contract stx)
  (syntax-case stx (::)
    [(_ (f (id :: c) ...) b)
     (with-syntax ([(new-id ...) (generate-temporaries #&#39;(id ...))])
       #&#39;(define f
           (lambda (new-id ...)
             (let ([id (guard c new-id)]
                   ...)
               b))))]))&lt;/code&gt;&lt;p&gt;有了这些（语法上的）便利，契约语言的设计师可以提高契约使用的可读性、效率和健壮性。&lt;/p&gt;&lt;h2&gt;16.5 扩展到复合数据结构&lt;/h2&gt;&lt;p&gt;正如我们已经讨论过的，将契约扩展到结构化数据类型（如链表、向量和用户定义的递归数据类型）似乎很容易。只需要提供适当的对运行时观测集。一般来说这取决于语言提供类型的精度。例如，正如我们之前讨论过的，支持数据类型的语言不需要&lt;b&gt;类型&lt;/b&gt;谓词，但仍然会提供区分&lt;b&gt;变体&lt;/b&gt;的谓词；这种情况下，类型级别的“契约”检查最好（也许必须）留给静态类型系统，而由契约来断言更精确的结构特性。&lt;/p&gt;&lt;p&gt;但是，这种策略可能会遇到严重的性能问题。例如，假设我们编写了平衡二叉搜索树，能以对数渐近时间（相对树的大小）实现插入和查找。接下来我们将树封装在合适的契约中。遗憾的是，仅检查契约就会访问整个树，从而用去线性时间！因此，理想情况下更好的策略是，构建树的时候就（以增量方式）完成契约检查，查找时则不需要再次检查。&lt;/p&gt;&lt;p&gt;更糟的是，平衡和顺序都是搜索树的递归属性。因此原则上，每个子树都应满足，所以每次递归调用都需要检查。在插入过程中，由于插入是递归的，将在每个访问的子树上检查契约。在大小为 &lt;equation&gt;t&lt;/equation&gt; 的树中，契约谓词应用于 &lt;equation&gt;\frac{t}{2}&lt;/equation&gt; 元素的子树，然后应用于 &lt;equation&gt;\frac{t}{4}&lt;/equation&gt; 元素的子子树，依此类推，在最坏情况下，会访问总数为 &lt;equation&gt;\frac{t}{2}+\frac{t}{4}+...+\frac{t}{t}&lt;/equation&gt; 的元素——使我们预期的对数时间插入过程花费线性时间。&lt;/p&gt;&lt;p&gt;对这两个例子，许多情况下都可以采用措施缓解。每个值都需要与它已经通过的一组契约相关联（或内部存储，或存储于散列表中）。然后，当需要调用契约时，首先检查它是否已被检查过，如果有，则不再检查。这实质上是将契约检查记忆化（memoization），从而减少检查的算法复杂性。当然，对记忆化而言，最好值是不可变的。如果这些值可能发生变化，并且契约执行任意计算，那么此优化可能无法做到可靠。&lt;/p&gt;&lt;p&gt;检查数据结构还有一个微妙的问题。作为例子，考虑我们之前编写的检查数链表中所有值均是偶数的契约。假设我们已经用契约封装了链表，但只对链表的第一个元素感兴趣。当然，我们检查了列表中的所有值，这可能需要很长时间。但更重要的是，用户可能会争辩说，报告链表第二个元素违规的行为本身违反了我们对契约检查的期望，因为我们并未实际使用该元素。&lt;/p&gt;&lt;p&gt;这意味着推迟检查某些值，即使它们可以即时被检查。例如，可以将整个链表转换为包含延时检查的封装值，每个值仅在访问时被检查。这种策略可能很有吸引力，但编码该策略并不简单，尤其当存在&lt;b&gt;别名&lt;/b&gt;的情况下会遇到问题：如果两个不同的标识符引用同一链表，一个有契约保护而另一个没有，我们必须确保它们都按预期运行（这通常意味着我们不能在链表中存储任何可变状态）。&lt;/p&gt;&lt;h2&gt;16.6 再论契约和观测&lt;/h2&gt;&lt;p&gt;契约实现还有一个奇怪的普遍问题——遇到复杂数据时更甚。之前，我们抱怨说检查函数的契约很难，因为我们观测能力受限：我们能检查的只有值是否是函数。在真实的语言中，数据结构的问题其实是相反的：我们的观测能力过剩。例如，如果我们实施延迟检查链表的策略，则很可能需要使用某个结构体来保存实际链表，并修改&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt;，以此（检查契约后）获取结构体中的值。但是，像&lt;code class=&quot;inline&quot;&gt;list?&lt;/code&gt;这样的函数现在可能返回&lt;code class=&quot;inline&quot;&gt;false&lt;/code&gt;而不是&lt;code class=&quot;inline&quot;&gt;true&lt;/code&gt;，因为结构体不是链表；因此，&lt;code class=&quot;inline&quot;&gt;list?&lt;/code&gt;需要绑定到新函数上，遇到这些特殊的表示链表的延迟契约结构体也返回&lt;code class=&quot;inline&quot;&gt;true&lt;/code&gt;。但契约系统作者还需要记得解决&lt;code class=&quot;inline&quot;&gt;cons?&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;pair?&lt;/code&gt;，天知道还有多少其他函数都可以执行观测操作。&lt;/p&gt;&lt;p&gt;一般来说，有一个观测基本上不可能“修复”：&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;。通常情况下，每个值&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;它自己，即使函数也是如此。然而，函数封装以后就是新的函数了，不但&lt;b&gt;不&lt;/b&gt;&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;自己，也&lt;b&gt;不应该&lt;/b&gt;，因为其行为真的不同了（尽管只是在违反契约的情况下，并且只在提供了足够多的输入值得以观测到违规行为后）。然而，这意味着程序无法暗中保护自己，因为守护行为可以被观测到。因此，恶意模块有时可以检测它收到的是否是受保护的值，如果是就正常运行，否则就不！&lt;/p&gt;&lt;h2&gt;16.7 契约和赋值&lt;/h2&gt;&lt;p&gt;我们无疑应该关注契约与赋值之间的相互作用，当契约延迟检查——固有延迟或者以延迟方式实现——时更是如此。有两件事值得关注。一是将契约值存储在可变状态中；二是&lt;b&gt;为&lt;/b&gt;可变状态编写的契约。&lt;/p&gt;&lt;p&gt;当我们存储契约值时，封装策略确保契约检查正常进行。在每个步骤，契约都会尽可能多地检查现有的值，并创建包含其余检查的封装值。因此，即使这个封装值被存储在可变状态并在稍后检索以供使用，它仍然包含这些检查，并且当值最终被使用时它们将被执行。&lt;/p&gt;&lt;p&gt;另一个问题是编写可变数据的契约，如box和向量。在这种情况下，我们可能必须为包含契约的整个数据类型创建封装。然后，当数据类型中的值被替换为新值时，执行更新的操作（例如&lt;code class=&quot;inline&quot;&gt;set-box!&lt;/code&gt;）需要从封装中检索契约，将其应用于新值并存储新封装的值。因此，这需要修改数据结构赋值操作符的行为，使其对契约值敏感。然而，赋值不会改变违规行为的发生点：即时契约即时发生，延时契约遇到（非法）输入值时发生。&lt;/p&gt;&lt;h2&gt;16.8 契约的组合&lt;/h2&gt;&lt;p&gt;我们已经讨论过所有基本数据类型的组合，本节很自然要契约的组合。正如之前讨论的&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35291037/chap15.md#1533-%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B&quot;&gt;联合&lt;/a&gt;和&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35291037/chap15.md#1535-%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B&quot;&gt;交叉&lt;/a&gt;类型一样，我们应该考虑契约的联合和交叉（分别是“或”与“和”）；还应当考虑取反。然而，契约只是表面上类似于类型，所以我们必须根据契约来考虑这些问题，而不是试图将我们从类型学到的意义映射到契约领域。&lt;/p&gt;&lt;p&gt;直接的例子总是简单的。联合契约通过析取组合——事实上，因为是谓词，其结果可以字面上用&lt;code class=&quot;inline&quot;&gt;or&lt;/code&gt;组合——而交叉契约通过合取组合。我们依次调用谓词，进行短路求值（译注，参见&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35291037/chap17.md#1731-%E9%80%9A%E8%BF%87%E6%90%9C%E7%B4%A2%E8%8E%B7%E5%BE%97%E6%BB%A1%E8%B6%B3&quot;&gt;后文&lt;/a&gt;），最后产生错误或返回契约的值。交叉契约通过合取（&lt;code class=&quot;inline&quot;&gt;and&lt;/code&gt;）组合。而取反契约就是直接调用原始的契约，但对谓词取反（通过&lt;code class=&quot;inline&quot;&gt;not&lt;/code&gt;）。&lt;/p&gt;&lt;p&gt;在延迟、高阶的情况下，契约组合要困难得多。例如，考虑对数到数的函数的契约进行取反。这里取反到底是什么意思？是否表示该函数&lt;b&gt;不&lt;/b&gt;应接受数？或者如果接受了数，它不应该返回数？或两者都要？特别是，我们如何执行这样的契约？例如，如何检查某个函数不接受数——是否期望在给予数时会产生错误？但请考虑用这样的契约封装的恒等函数；因为当给予数（或者其他任何值）时，它显然不会出错，这是否意味着应该等到它产生值，如果它确实产生了数，那么拒绝它？但最糟糕的是，请注意，这意味着我们将在&lt;b&gt;未&lt;/b&gt;定义的定义域中运行函数：显然这会破坏程序中的不变量、污染堆栈、或使程序崩溃。&lt;/p&gt;&lt;p&gt;交叉契约要求值通过所有子契约。这意味着高阶值需要重新封装，检查所有定义域子契约以及所有值域子契约。只要一个子契约没有满足，整个交叉（契约）都会失败。&lt;/p&gt;&lt;p&gt;联合契约更加微妙，因为任何一个子契约失败都不直接导致值被拒绝。相反，它只是意味着这个子契约不再是所封装值所遵守的契约；其他子契约仍然可能被遵守，只有当没有任何子契约候选时才拒绝值。这意味着联合契约的实现中必须记录哪些子契约通过或失败——这里，记录就意味着赋值。【注释】由于每条子包契约失败时，它将被从候选名单删除，而剩下的会继续执行。当没有候选子契约时，系统必须报告违规行为。错误报告最好要提供导致每个子契约失败的实际值（请记住，这些值可能嵌套在多层函数中）。&lt;/p&gt;&lt;blockquote&gt;在类似Racket的多线程语言中，还需要加锁以避免竞争条件。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;Racket所实现的契约构造器和组合器对可接受的子契约形式提出了限制。这使得实现既有效率又能提供有用的错误消息。此外，上面讨论的极端情况很少在实践中出现——当然现在如果需要你知道如何实现它们。&lt;/p&gt;&lt;h2&gt;16.9 问责&lt;/h2&gt;&lt;p&gt;本节回过头讨论报告契约违反的问题。这指的不是打印什么字符串，而是更重要的问题，报告&lt;b&gt;什么&lt;/b&gt;。我们将看到，此问题实际上是语义上的考虑。&lt;/p&gt;&lt;p&gt;为了说明这个问题，回想一下上面&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;的定义，假设我们在没有任何契约检查的情况下运行。先假设我们将这个函数应用于完全不合适的&lt;code class=&quot;inline&quot;&gt;string-append&lt;/code&gt;（它既不读入也不产生数）。这么做只会产生一个值：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (define d/dx-sa (d/dx string-append))&lt;/code&gt;&lt;p&gt;（请注意，即使有契约检查，这也会通过，因为函数契约的即时部分认可&lt;code class=&quot;inline&quot;&gt;string-append&lt;/code&gt;是函数。）接下来假设我们将&lt;code class=&quot;inline&quot;&gt;d/dx-sa&lt;/code&gt;应用于一个数，这应是正常行为：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (d/dx-sa 10)
string-append: contract violation
  expected: string?
  given: 10.001&lt;/code&gt;&lt;p&gt;请注意，错误报告位于&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;函数体的内部。一方面，这完全是合理的：这是&lt;code class=&quot;inline&quot;&gt;string-append&lt;/code&gt;不正确调用发生的地方。另一方面，&lt;b&gt;错误&lt;/b&gt;并非来自&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;，而来自声称&lt;code class=&quot;inline&quot;&gt;string-append&lt;/code&gt;是合法的数到数的函数的代码。但问题是，做这件事的代码早已逃之夭夭；它已经不在堆栈中，因此也不在传统错误报告机制的范围内。&lt;/p&gt;&lt;p&gt;这个问题不是&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;所特有的；事实上，大型系统中它很常见。这是因为系统——尤其是含有图形、网络和其他外部接口的系统——中大量使用&lt;b&gt;回调&lt;/b&gt;（callback）：对某个实体感兴趣而被注册的函数（或方法），要发某种状态或值的信号时被调用。（在这里，&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;等价于图形层，而&lt;code class=&quot;inline&quot;&gt;string-append&lt;/code&gt;等价于传给它（并由它存储）的回调。）最终，系统层会调用回调。如果这会导致错误，那&lt;b&gt;既不是&lt;/b&gt;系统层的错误，它收到的回调符合要求的契约，&lt;b&gt;也不是&lt;/b&gt;回调本身的错误，它应该有合理的用途，只是被错误地提供给函数。相反，&lt;b&gt;错误来源于引入这两者的实体&lt;/b&gt;。然而，此时调用栈只包含回调（位于栈顶）和系统（位于其下）——唯一有错的一方不在了。这种类型的错误因此非常难调试。&lt;/p&gt;&lt;p&gt;解决办法是扩展契约系统，纳入&lt;b&gt;问责&lt;/b&gt;（blame）的概念。想法是，有效地记录将一对组件组合在一起的那个实体，以便如果它们之间发生契约违规，我们可以将失败归因于该实体。请注意，这只在函数的情况下才有实际意义，但为了一致性，我们以自然的方式也将问责扩展到即时契约中。&lt;/p&gt;&lt;p&gt;对于函数，请注意有两种可能的失败点：要么它被&lt;b&gt;给予了&lt;/b&gt;是错误的值（先验条件），要么是它&lt;b&gt;生成了&lt;/b&gt;错误的值（后验条件）。区分这两种情况很重要，因为在前一种情况下，我们应该将错误归咎于环境——这里，也即实参表达式——而在后一种情况下（假设参数已经通过），则应归咎于函数本身。（对即时值的自然扩展是我们只能对值值本身不满足契约进行问责，也就是“后验条件”）。&lt;/p&gt;&lt;p&gt;对于契约，我们引入术语&lt;b&gt;正&lt;/b&gt;（positive）和&lt;b&gt;负&lt;/b&gt;（negative）位置。对于一阶函数，负位置是先验条件，正位置是后验条件。这么看这似乎是不必要的额外术语。但我们很快就会看到，这两个术语具有更一般的含义。&lt;/p&gt;&lt;p&gt;现在将情况推广到契约的参数。之前，即时契约读入一个谓词，而函数契约读入定义域和值域的契约。这点保持不变。不过它们返回的将是函数，此函数有两个参数：正负位置的标签。（这个标签可以是任何合理的数据类型：抽象语法节点、缓冲区偏移量、或其他描述符。简单起见，我们使用字符串。）这样，函数契约将闭包于程序位置标签，以便将来对非法函数的提供方进行问责。&lt;/p&gt;&lt;p&gt;现在由&lt;code class=&quot;inline&quot;&gt;guard&lt;/code&gt;函数负责传入契约调用位置的标签：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (guard ctc val pos neg) ((ctc pos neg) val))&lt;/code&gt;&lt;p&gt;由&lt;code class=&quot;inline&quot;&gt;blame&lt;/code&gt;显示合适的标签（由契约实现传给它）：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (blame s) (error &#39;contract s))&lt;/code&gt;&lt;p&gt;假设我们像以前一样，保护&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;的使用。正负位置用什么名字有意义呢？正位置是后验条件：这里的任何失败都必须归咎于&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;的函数体。负位置是先验条件：这里的任何失败都必须归咎于&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;的参数。因此：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define a1 (guard (function (immediate number?)
                            (immediate number?))
                  add1
                  &quot;add1 body&quot; ;add1函数体
                  &quot;add1 input&quot;)) ;add1的输入&lt;/code&gt;&lt;p&gt;假设传给&lt;code class=&quot;inline&quot;&gt;guard&lt;/code&gt;的不是函数，我们会期望在“后验条件”位置出现错误：这并不是后验条件的失败，而是因为，如果调用的不是函数，不能去指责参数。（当然，这表明我们这里扩展了术语“后验条件”，更合理地应该使用术语“正（位置）”。）因为相信&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;的实现只会返回数，所以我们预计它不可能让后置条件失败。当然，我们期望像&lt;code class=&quot;inline&quot;&gt;(a1 &quot;x&quot;)&lt;/code&gt;这样的表达式触发先验条件错误，可以在&lt;code class=&quot;inline&quot;&gt;&quot;add1 input&quot;&lt;/code&gt;位置处发出契约错误。相反，如果我们保护的函数违反了后验条件，比如这样，&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define bad-a1 (guard (function (immediate number?)
                                (immediate number?))
                      number-&amp;gt;string
                      &quot;bad-add1 body&quot;
                      &quot;bad-add1 input&quot;))&lt;/code&gt;&lt;p&gt;我们希望将责任被归咎于&lt;code class=&quot;inline&quot;&gt;&quot;bad-add1 body&quot;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;接下来讨论如何实现这些契约构造函数。对于即时契约，我们说过应问责正位置：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (immediate pred?)
  (lambda (pos neg)
    (lambda (val)
      (if (pred? val) val (blame pos)))))&lt;/code&gt;&lt;p&gt;对于函数，我们可能想这么写&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (function dom rng)
  (lambda (pos neg)
    (lambda (val)
      (if (procedure? val)
          (lambda (x) (dom (val (rng x))))
          (blame pos)))))&lt;/code&gt;&lt;p&gt;但是这根本不能运作：它违反了契约所预期的签名。这是因为，现在所有契约都期望输入正负位置的标签，也就是&lt;code class=&quot;inline&quot;&gt;dom&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;rng&lt;/code&gt;不能像上面那样使用。（另一个理由，函数体中用到了&lt;code class=&quot;inline&quot;&gt;pos&lt;/code&gt;，但完全不含&lt;code class=&quot;inline&quot;&gt;neg&lt;/code&gt;，尽管已经看到过一些例子，我们认为责任必须归咎于&lt;code class=&quot;inline&quot;&gt;neg&lt;/code&gt;所绑定的位置。）所以很明显，我们要以某种方式使用&lt;code class=&quot;inline&quot;&gt;pos&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;neg&lt;/code&gt;实例化的值域和定义域契约，以便它们“知道”和“记住”可能调用非法函数的地方。&lt;/p&gt;&lt;p&gt;最显然的做法是用相同的&lt;code class=&quot;inline&quot;&gt;dom&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;rng&lt;/code&gt;值实例化这些契约构造函数：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (function dom rng)
  (lambda (pos neg)
    (let ([dom-c (dom pos neg)]
          [rng-c (rng pos neg)])
      (lambda (val)
        (if (procedure? val)
            (lambda (x) (rng-c (val (dom-c x))))
            (blame pos))))))&lt;/code&gt;&lt;p&gt;现在所有签名都匹配了，我们可以运行契约了。但这样做时，返回不太对劲。比如，在我们最简单的违反契约的例子中，返回是&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (a1 &quot;x&quot;)
contract: add1 body&lt;/code&gt;&lt;p&gt;咦？也许我们应该展开&lt;code class=&quot;inline&quot;&gt;a1&lt;/code&gt;的代码，来看看发生了什么。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(a1 &quot;x&quot;)
= (guard (function (immediate number?)
                   (immediate number?))
         add1
         &quot;add1 body&quot;
         &quot;add1 input&quot;)
= (((function (immediate number?) (immediate number?))
    &quot;add1 body&quot; &quot;add1 input&quot;)
   add1)
= (let ([dom-c ((immediate number?) &quot;add1 body&quot; &quot;add1 input&quot;)]
        [rng-c ((immediate number?) &quot;add1 body&quot; &quot;add1 input&quot;)])
    (lambda (x) (rng-c (add1 (dom-c x)))))
= (let ([dom-c (lambda (val)
                 (if (number? val) val (blame &quot;add1 body&quot;)))]
        [rng-c (lambda (val)
                 (if (number? val) val (blame &quot;add1 body&quot;)))])
    (lambda (x) (rng-c (add1 (dom-c x)))))&lt;/code&gt;&lt;p&gt;可怜的&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;：它都没有获得机会！剩下的唯一问责标签是&lt;code class=&quot;inline&quot;&gt;&quot;add1 body&quot;&lt;/code&gt;，所以只能归咎于它了。&lt;/p&gt;&lt;p&gt;等下会讨论此问题，先来观察上面的代码，其中没有任何函数契约的踪迹。我们有的只是即时契约，当实际值（如果）发生时进行问责。这与我们之前所说&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35291037/chap16.md#163-%E9%AB%98%E9%98%B6%E5%A5%91%E7%BA%A6&quot;&gt;只能观测到即时值&lt;/a&gt;完全一致。当然，这只适用于一阶函数；当遇到高阶函数时，这不再成立。&lt;/p&gt;&lt;p&gt;错在哪里？请注意，在&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;函数体中只有绑定到&lt;code class=&quot;inline&quot;&gt;rng-c&lt;/code&gt;的契约应该被问责。相反，&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;的输入中应该被问责的是绑定到&lt;code class=&quot;inline&quot;&gt;dom-c&lt;/code&gt;的契约。看起来，在函数契约的定义域位置，正负标签需要……交换。&lt;/p&gt;&lt;p&gt;考虑契约保护的&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;，我们会发现情况确实如此。关键的见解是，当调用的函数作为参数时，“外部”成为“内部”，反之亦然。也就是说，&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;的函数体——处于正位置——调用了被求微分的函数，将这个函数的函数体置于正位置，并将调用者——&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;的函数体——置于负位置。因此，在契约的定义域一侧，每次嵌套函数契约都会导致正负位置交换。&lt;/p&gt;&lt;p&gt;值域一侧无需交换。继续考虑&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;。它返回的函数代表导数，所以它的输入是数（代表计算导数的点），返回也是数（该点的导数）。这个函数的负位置就是使用微分函数的客户——即先验条件——正位置就是&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;本身——即后验条件——因为它负责生成导数。&lt;/p&gt;&lt;p&gt;这样，我们就更正的、正确的函数构造函数的定义：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (function dom rng)
  (lambda (pos neg)
    (let ([dom-c (dom neg pos)]
          [rng-c (rng pos neg)])
      (lambda (val)
        (if (procedure? val)
            (lambda (x) (rng-c (val (dom-c x))))
            (blame pos))))))&lt;/code&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;将此应用于之前的例子，确认得到的问责符合预期。此外，手动展开代码以了解为何。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;更进一步，假设我们定义&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;的正位置标签为&lt;code class=&quot;inline&quot;&gt;&quot;d/dx body&quot;&lt;/code&gt;，负位置标签为&lt;code class=&quot;inline&quot;&gt;&quot;d/dx input&quot;&lt;/code&gt;。假设我们传给它函数&lt;code class=&quot;inline&quot;&gt;number-&amp;gt;string&lt;/code&gt;（此函数明显无法计算导数），然后将结果应用于&lt;code class=&quot;inline&quot;&gt;10&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;((d/dx (guard (function (immediate number?)
                        (immediate string?))
              number-&amp;gt;string
              &quot;n-&amp;gt;s body&quot;
              &quot;n-&amp;gt;s input&quot;))
 10)&lt;/code&gt;&lt;p&gt;这正确地表明，应该归咎于将&lt;code class=&quot;inline&quot;&gt;number-&amp;gt;string&lt;/code&gt;假定为数函数提供给&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;的表达式——而不是&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;本身。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;手工计算&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;，将其作用于&lt;b&gt;所有&lt;/b&gt;相关的违规情况，并确认由此产生的问责是准确的。如果你将&lt;code class=&quot;inline&quot;&gt;string-&amp;gt;number&lt;/code&gt;传给&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;，附带函数契约指明它将字符串映射到数，会发生什么？如果你在没有契约的情况下传入相同的函数呢？&lt;/blockquote&gt;</description>
<author>lotuc</author>
<guid isPermaLink="false">2018-04-04-35291037</guid>
<pubDate>Wed, 04 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（八）：范畴</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-04-35237925.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35237925&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8fd16e3275832ced282b1a9c125bb8c2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;775&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文中，我们用群，拓扑空间，CPO作为例子，&lt;br&gt;来说明什么是&lt;b&gt;数学结构&lt;/b&gt;，以及数学结构是如何通过映射来保持的。&lt;br&gt;群同态保持了群结构，连续映射保持了拓扑结构，连续函数保持了完全偏序结构。&lt;/p&gt;&lt;p&gt;那么群结构与拓扑结构之间是否有联系呢？&lt;br&gt;我们能否建立拓扑空间与群之间的对应关系呢？&lt;/p&gt;&lt;p&gt;在代数拓扑中，就存在这样的例子，&lt;br&gt;人们找到了和拓扑空间相关的群论概念，例如基本群和同调群，&lt;br&gt;拓扑空间的连续映射可以导出这些群的群同态。&lt;/p&gt;&lt;p&gt;这就为了人们使用代数学方法研究其他数学分支，奠定了基础，&lt;br&gt;实际上，最原始的范畴论想法也是起源于此。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 图示法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在前一篇中我们学过了&lt;b&gt;幺半群&lt;/b&gt;，&lt;br&gt;它指的是一个集合 &lt;equation&gt;M&lt;/equation&gt; ，以及 &lt;equation&gt;M&lt;/equation&gt; 上的二元运算 &lt;equation&gt;\cdot&lt;/equation&gt; ，满足以下两个条件，&lt;br&gt;（1） &lt;equation&gt;\forall x,y,z\in M&lt;/equation&gt; ， &lt;equation&gt;(x\cdot y)\cdot z=x\cdot (y\cdot z)&lt;/equation&gt; ，&lt;br&gt;（2） &lt;equation&gt;\exists e\in M&lt;/equation&gt; ， &lt;equation&gt;\forall x\in M&lt;/equation&gt; ， &lt;equation&gt;x\cdot e=e\cdot x=x&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;这两个条件除了可以用等式来表示，还可以用&lt;b&gt;图&lt;/b&gt;（diagram）来表示，&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1bd56c30e34a673a998895029362c270_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1138&quot; data-rawheight=&quot;234&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们称以上两张图都是&lt;b&gt;可交换的&lt;/b&gt;（commutative），&lt;br&gt;即，沿着不同的路径进行运算，只要起点和终点相同，则运算的结果就相同。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;&amp;lt;x,y,z&amp;gt;\mapsto &amp;lt;x,yz&amp;gt;\mapsto x(yz)&lt;/equation&gt; ，总是等于 &lt;equation&gt;&amp;lt;x,y,z&amp;gt;\mapsto &amp;lt;xy,z&amp;gt;\mapsto (xy)z&lt;/equation&gt; ，&lt;br&gt;即， &lt;equation&gt;x(yz)=(xy)z&lt;/equation&gt; ，表明 &lt;equation&gt;M&lt;/equation&gt; 中元素的运算满足&lt;b&gt;结合律&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;又例， &lt;equation&gt;&amp;lt;0,x&amp;gt;\mapsto &amp;lt;e,x&amp;gt;\mapsto ex&lt;/equation&gt; ，总是等于 &lt;equation&gt;&amp;lt;0,x&amp;gt;\mapsto x&lt;/equation&gt; ，即 &lt;equation&gt;ex=x&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;&amp;lt;x,0&amp;gt;\mapsto &amp;lt;x,e&amp;gt;\mapsto xe&lt;/equation&gt; ，总是等于 &lt;equation&gt;&amp;lt;x,0&amp;gt;\mapsto x&lt;/equation&gt; ，即 &lt;equation&gt;xe=x&lt;/equation&gt; 。&lt;br&gt;因此， &lt;equation&gt;ex=x=xe&lt;/equation&gt; ，表明 &lt;equation&gt;M&lt;/equation&gt; 中存在&lt;b&gt;幺元&lt;/b&gt; &lt;equation&gt;e&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;所以，我们可以用以上两个图表，作为幺半群的定义，称为&lt;b&gt;图示法&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;另一方面，考虑在集合论中讨论映射的时候，一般都不写具体元素，还可以表示为，&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65f472da6c217b0f01bbc9704f4df946_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1070&quot; data-rawheight=&quot;218&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中， &lt;equation&gt;\mu:M\times M\to M&lt;/equation&gt; ， &lt;equation&gt;\eta:1\to M&lt;/equation&gt; ，是两个函数， &lt;equation&gt;1=\{0\}&lt;/equation&gt; 是只有一个元素的集合。&lt;/p&gt;&lt;p&gt;用图示法来表示幺半群，更具一般性。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 范畴&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;范畴是一个数学概念，也可以用图示法来表示。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-07f823a724618aaf5e160d394a7eab6e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;178&quot; data-rawheight=&quot;161&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;一个&lt;b&gt;范畴&lt;/b&gt; &lt;equation&gt;Cat&lt;/equation&gt; 由一系列&lt;b&gt;对象&lt;/b&gt;（object）和&lt;b&gt;箭头&lt;/b&gt;（arrow）组成。&lt;br&gt;对于每一个箭头 &lt;equation&gt;f&lt;/equation&gt; ，有两个对象与之关联，&lt;br&gt;称为箭头 &lt;equation&gt;f&lt;/equation&gt; 的&lt;b&gt;定义域&lt;/b&gt;（domain）和&lt;b&gt;值域&lt;/b&gt;（codomain）。&lt;/p&gt;&lt;p&gt;并且，还要满足以下几条规则，&lt;br&gt;（1）对于每一个对象 &lt;equation&gt;a&lt;/equation&gt; ，存在&lt;b&gt;恒等箭头&lt;/b&gt;（identity arrow）， &lt;equation&gt;i:a\to a&lt;/equation&gt; &lt;br&gt;（2）箭头满足&lt;b&gt;结合律&lt;/b&gt;，对于任意的箭头 &lt;equation&gt;f,g,h&lt;/equation&gt; ，有 &lt;equation&gt;(f\cdot g)\cdot h=f\cdot (g\cdot h)&lt;/equation&gt; &lt;br&gt;（3）箭头的集合在箭头组合运算下是&lt;b&gt;封闭的&lt;/b&gt;&lt;/p&gt;&lt;p&gt;其中， &lt;equation&gt;f\cdot g&lt;/equation&gt; 表示 &lt;equation&gt;g&lt;/equation&gt; 和 &lt;equation&gt;f&lt;/equation&gt; 的组合运算，它也是一个箭头，其中 &lt;equation&gt;g&lt;/equation&gt; 的值域是 &lt;equation&gt;f&lt;/equation&gt; 的定义域。&lt;/p&gt;&lt;p&gt;例子：&lt;br&gt;所有的集合，以集合为对象，集合之间的映射作为箭头，构成了一个范畴，&lt;br&gt;所有的群，以群作为对象，群同态作为箭头，构成了一个范畴，&lt;br&gt;所有的拓扑空间，以拓扑空间作为对象，拓扑空间之间的连续映射为箭头，构成了一个范畴。&lt;/p&gt;&lt;p&gt;以上三个例子中，&lt;br&gt;范畴中的对象都是集合，箭头都是映射，这就很容易造成误解。&lt;br&gt;因为，&lt;b&gt;范畴中的对象可以不是集合，箭头也可以不是映射，&lt;br&gt;&lt;/b&gt;理解这一点至关重要。&lt;/p&gt;&lt;p&gt;例如，完全偏序 &lt;equation&gt;(D,\leqslant)&lt;/equation&gt; ，&lt;br&gt;以 &lt;equation&gt;D&lt;/equation&gt; 中的元素作为对象，以 &lt;equation&gt;x\leqslant y&lt;/equation&gt; 作为 &lt;equation&gt;x,y&lt;/equation&gt; 之间的箭头，同样构成了一个范畴。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 函子&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;函子就是两个范畴之间的箭头。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9a2d8a5e543c0e1e27695a353869dda1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;436&quot; data-rawheight=&quot;243&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;一个&lt;b&gt;函子&lt;/b&gt; &lt;equation&gt;F&lt;/equation&gt; 是范畴 &lt;equation&gt;C&lt;/equation&gt; 到范畴 &lt;equation&gt;D&lt;/equation&gt; 的箭头， &lt;equation&gt;F:C\to D&lt;/equation&gt; ，它满足以下条件，&lt;br&gt; &lt;equation&gt;F&lt;/equation&gt; 把 &lt;equation&gt;C&lt;/equation&gt; 中的对象 &lt;equation&gt;c&lt;/equation&gt; 映射为 &lt;equation&gt;D&lt;/equation&gt; 中的对象 &lt;equation&gt;F~c&lt;/equation&gt; ，把 &lt;equation&gt;C&lt;/equation&gt; 中的箭头 &lt;equation&gt;f&lt;/equation&gt; 映射为 &lt;equation&gt;D&lt;/equation&gt; 中的箭头 &lt;equation&gt;F~f&lt;/equation&gt; 。&lt;br&gt;并且， &lt;equation&gt;F~(f\cdot g)=(F~f)\cdot (F~g)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;值得注意的是，等式左边的 &lt;equation&gt;\cdot&lt;/equation&gt; ，表示 &lt;equation&gt;C&lt;/equation&gt; 中的箭头组合运算，&lt;br&gt;等式右边的 &lt;equation&gt;\cdot&lt;/equation&gt; ，表示D&lt;i&gt;D&lt;/i&gt;中的箭头组合运算。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4. 自然变换&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;自然变换&lt;/b&gt;（natural transformation）是&lt;b&gt;一族箭头&lt;/b&gt;，&lt;br&gt;将范畴 &lt;equation&gt;A&lt;/equation&gt; 在一个函子中的像（picture），变换成了另一个函子的像。&lt;/p&gt;&lt;p&gt;给定两个函子 &lt;equation&gt;S,T:A\to B&lt;/equation&gt; ，其中 &lt;equation&gt;A&lt;/equation&gt; 和 &lt;equation&gt;B&lt;/equation&gt; 是范畴。&lt;br&gt;自然变换的每个&lt;b&gt;分量&lt;/b&gt;（components）使下图可交换。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-eed0e9ebd54183d14091dd04da29d37f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;696&quot; data-rawheight=&quot;225&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中， &lt;equation&gt;\tau_a&lt;/equation&gt; 是 &lt;equation&gt;B&lt;/equation&gt; 中的箭头， &lt;equation&gt;\tau_a:Sa\to Ta&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;5. Monad&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;范畴到自身的函子，称为&lt;b&gt;自函子&lt;/b&gt;（endofunctor）。&lt;br&gt;设 &lt;equation&gt;T:X\to X&lt;/equation&gt; 是任意范畴 &lt;equation&gt;X&lt;/equation&gt; 上的自函子，自函子复合之后仍为自函子，&lt;br&gt; &lt;equation&gt;T^2=T\circ T:X\to X&lt;/equation&gt; ， &lt;equation&gt;T^3=T^2\circ T:X\to X&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;\mu:T^2\to T&lt;/equation&gt; 是一个自然变换，其分量为 &lt;equation&gt;\mu_x:T^2x\to Tx&lt;/equation&gt; ， &lt;equation&gt;\forall x\in X&lt;/equation&gt; ，&lt;br&gt;则使用 &lt;equation&gt;\mu&lt;/equation&gt; 可以定义另外两个自然变换，&lt;br&gt; &lt;equation&gt;T\mu:T^3\to T^2&lt;/equation&gt; ，它的分量为 &lt;equation&gt;(T\mu)_x=T(\mu_x):T^3x\to T^2x&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\mu T:T^3\to T^2&lt;/equation&gt; ，它的分量为 &lt;equation&gt;(\mu T)_x=\mu_{Tx}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;范畴 &lt;equation&gt;X&lt;/equation&gt; 上的一个&lt;b&gt;Monad&lt;/b&gt;，指的是三元组 &lt;equation&gt;\left \langle T,\eta,\mu \right \rangle&lt;/equation&gt; ，它们使下图可交换，&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b877301e440b9c0f78a488e7e0022833_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;732&quot; data-rawheight=&quot;194&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中， &lt;equation&gt;T:X\to X&lt;/equation&gt; 是范畴 &lt;equation&gt;X&lt;/equation&gt; 上的自函子， &lt;equation&gt;\eta:I_X\to T&lt;/equation&gt; ， &lt;equation&gt;\mu:T^2\to T&lt;/equation&gt; 是两个自然变换。&lt;/p&gt;&lt;p&gt;值得注意的是，Monad与幺半群的图示法是相似的，&lt;br&gt;只需要将幺半群定义中的 &lt;equation&gt;\times&lt;/equation&gt; ，改写成自函子的复合运算，&lt;br&gt;把单位集合 &lt;equation&gt;1&lt;/equation&gt; ，改写成单位自函子即可。&lt;/p&gt;&lt;p&gt;因此，我们说&lt;b&gt;Monad是自函子范畴上的一个幺半群&lt;/b&gt;。&lt;/p&gt;&lt;blockquote&gt;All told, a monad in X is just a monoid in the category of endofunctors of X, with product x replaced by composition of endofunctors and unit set by the identity endofunctor.&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;6. Hask范畴上的Monad&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果把Haskell语言中的类型作为对象，把类型之间的函数看做箭头，&lt;br&gt;则在函数复合运算下，构成了一个范畴，称为&lt;b&gt;Hask范畴&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;函子&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Haskell中类型类（type class）&lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt;的每一个实例，定义了Hask范畴中的一个函子。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class Functor (f :: * -&amp;gt; *) where
    fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;表示了函子作用在箭头上的结果。&lt;br&gt;作用在对象上，可以使用&lt;code class=&quot;inline&quot;&gt;pure :: a -&amp;gt; f a&lt;/code&gt;来表示。&lt;/p&gt;&lt;p&gt;在Haskell中，一个类型要成为&lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt;的实例，还要满足相应的“&lt;a href=&quot;https://wiki.haskell.org/Functor#Functor_Laws&quot;&gt;Functor Law&lt;/a&gt;”，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fmap id = id
fmap (f . g) = fmap f . fmap g&lt;/code&gt;&lt;p&gt;可以&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Category_theory#Functors&quot;&gt;证明&lt;/a&gt;，这些“Functor Law”刚好使&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;pure&lt;/code&gt;构成了范畴论意义上的函子。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Monad&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Haskell中类型类&lt;code class=&quot;inline&quot;&gt;Monad&lt;/code&gt;的每一个实例，定义了Hask范畴中的一个Monad。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class Functor m =&amp;gt; Monad m where
    return :: a -&amp;gt; m a
    (&amp;gt;&amp;gt;=)  :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b&lt;/code&gt;&lt;p&gt;在Haskell中，一个类型要成为&lt;code class=&quot;inline&quot;&gt;Monad&lt;/code&gt;的实例，还要满足相应的“&lt;a href=&quot;https://wiki.haskell.org/Monad#Monad_class&quot;&gt;Monad Law&lt;/a&gt;”，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;return a &amp;gt;&amp;gt;= k                  =  k a
m        &amp;gt;&amp;gt;= return             =  m
m        &amp;gt;&amp;gt;= (\x -&amp;gt; k x &amp;gt;&amp;gt;= h)  =  (m &amp;gt;&amp;gt;= k) &amp;gt;&amp;gt;= h&lt;/code&gt;&lt;p&gt;可以&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Category_theory#Monads&quot;&gt;证明&lt;/a&gt;，这些“Monad Law”刚好使&lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;=&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;return&lt;/code&gt;构成了范畴论意义上的Monad。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了范畴论相关的一些内容，&lt;br&gt;介绍了什么是&lt;b&gt;范畴&lt;/b&gt;，什么是&lt;b&gt;函子&lt;/b&gt;，什么是&lt;b&gt;自然变换&lt;/b&gt;，&lt;br&gt;这些都是理解笛卡尔闭范畴所必须的。&lt;/p&gt;&lt;p&gt;为了理解什么是范畴，我们列举了前一篇提到的群，拓扑空间，CPO作为例子，&lt;br&gt;还借用了Haskell中的Functor和Monad学习了Hask范畴。&lt;/p&gt;&lt;p&gt;下文我们将继续学习范畴论，&lt;br&gt;理解什么是笛卡尔闭范畴，以及如何用它解释简单类型 &lt;equation&gt;\lambda&lt;/equation&gt; 演算的语义。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Category_(mathematics)&quot;&gt;Category (mathematics)&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Category_theory&quot;&gt;Haskell/Category theory&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1823110/&quot;&gt;Categories for the Working Mathematician&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-04-04-35237925</guid>
<pubDate>Wed, 04 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>C++函数式实现BST、线段树(单点修改)（2）</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-02-35201534.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35201534&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-39ccb0ee296de0b726bb2f2c939ca101_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35114696&quot;&gt;C++函数式实现BST、线段树(单点修改)（1）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;上一次是之前写的BST，那么我们今天就来聊一聊线段树~单点修改的。&lt;/p&gt;&lt;p&gt;本篇前置知识：线段树(普通递归的写法，非zwk)&lt;/p&gt;&lt;p&gt;最好掌握但是不掌握也没什么很大关系只是后面有一段论述可能会看不懂而已的知识：主席树&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Part I：线段树复习&lt;/p&gt;&lt;p&gt;我觉得每个人的对于线段树的写法可能不一样，比如这样一个例题：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1754&quot;&gt;Problem - 1754&lt;/a&gt;&lt;/p&gt;&lt;p&gt;单点更新：给出两个数x y，代表把x位置的数更新为y (y&amp;gt;=0)&lt;/p&gt;&lt;p&gt;查询区间max值：给出两个数x y，求区间[x,y]上的最大值&lt;/p&gt;&lt;p&gt;一开始长度为n的数组会指定初始值。&lt;/p&gt;&lt;p&gt;那么关键就是三个函数：(node代表当前节点编号，le和ri代表当前node代表的区间，st就是线段树数组)&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;void init(int node,int le,int ri){
    if(le==ri)
        st[node]=GIVEN_VALUE //GIVEN_VALUE只表示这里的给定的初始值，并不是预定义的常量
    else{
        int m=(le+ri)&amp;gt;&amp;gt;1;
        init(node&amp;lt;&amp;lt;1,le,m);
        init(node&amp;lt;&amp;lt;1|1,m+1,ri);
        st[node]=max(st[node&amp;lt;&amp;lt;1],st[node&amp;lt;&amp;lt;1|1]);
    }
}

void update(int node,int le,int ri){
    if(le==ri)
        st[node]=y;
    else{
        int m=(le+ri)&amp;gt;&amp;gt;1;
        if(x&amp;lt;=m)
            update(node&amp;lt;&amp;lt;1,le,m);
        else
            update(node&amp;lt;&amp;lt;1|1,m+1,ri);
        st[node]=max(st[node&amp;lt;&amp;lt;1],st[node&amp;lt;&amp;lt;1|1]);
    }
}

int query(int node,int le,int ri){
    int m=(le+ri)&amp;gt;&amp;gt;1;
    if(x&amp;lt;=le&amp;amp;&amp;amp;ri&amp;lt;=y)
        return st[node];
    if(y&amp;lt;=m)
        return query(node&amp;lt;&amp;lt;1,le,m);
    if(x&amp;gt;m)
        return query(node&amp;lt;&amp;lt;1|1,m+1,ri);
    if(le&amp;lt;x||ri&amp;gt;y)
        return max(query(node&amp;lt;&amp;lt;1,le,m),query(node&amp;lt;&amp;lt;1|1,m+1,ri));
}&lt;/code&gt;&lt;p&gt;（好早之前写的代码了...但是逻辑应该还是很清楚的，注意update是单点更新）&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Part II: 函数式写法&lt;/p&gt;&lt;p&gt;(没有提交，只测了样例，应该是正确的，提交肯定过不了..)&lt;/p&gt;&lt;p&gt;(new完没有delete)&lt;/p&gt;&lt;p&gt;让我们首先定义Node结构体，同之前的BST是类似的，注意声明了一个全局的root变量&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;struct Node{
    int v;
    Node* le,*ri;
    explicit Node(int value=0,Node* lef=nullptr,Node* righ=nullptr):
        v(value),le(lef),ri(righ){}
}*root;&lt;/code&gt;&lt;p&gt;然后就是init函数&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;Node* init(int le,int ri){
    if(le==ri)
        return new Node(GIVEN_VALUE);
    else{
        int m=(le+ri)&amp;gt;&amp;gt;1;
        Node* lef=init(le,m),*rig = init(m+1,ri);
        return new Node(max(lef-&amp;gt;v,rig-&amp;gt;v),lef,rig);
    }
}&lt;/code&gt;&lt;p&gt;这里的le和ri代表当前节点代表的区间，因此一开始的调用是init(1,n)。假设le==ri，代表当前已经走到叶子节点了，则直接返回，否则分别init完左右子之后再返回自身节点。&lt;/p&gt;&lt;p&gt;然后就是update函数：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;Node* update(Node* st,int le,int ri){
    if(le==ri)
        return new Node(y);
    else{
        int m=(le+ri)&amp;gt;&amp;gt;1;
        Node* tmp;
        if(x&amp;lt;=m){
            tmp=update(st-&amp;gt;le,le,m);
            return new Node(max(tmp-&amp;gt;v,st-&amp;gt;ri-&amp;gt;v),tmp,st-&amp;gt;ri);
        }else{
            tmp=update(st-&amp;gt;ri,m+1,ri);
            return new Node(max(tmp-&amp;gt;v,st-&amp;gt;le-&amp;gt;v),st-&amp;gt;le,tmp);
        }
    }
}&lt;/code&gt;&lt;p&gt;注意这里是单点更新..即更新的区间是[x,x]，因此只要考虑x&amp;lt;=m和x&amp;gt;m的情况即可。同BST类似，这一下又会开创出一条新链出来，即从root节点到最终的叶子节点是一条新链，然后这条链有链向原来的节点。这个过程基本和之前BST是一样的，就不画图了，而且鼠绘完全二叉树好难......，相比BST只是多了一个更新自身的值的操作而已。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Part III：主席树&lt;/p&gt;&lt;p&gt;在BST中，我们最外层调用bst_insert是这样调用的&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;root=bst_insert(rand()%100,root);&lt;/code&gt;&lt;p&gt;同理，我们这里最外层调用update&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;root=update(root,1,n);&lt;/code&gt;&lt;p&gt;但是，假如我们这里不把root的值覆盖掉，而是把root声明为一个数组，比如说这样&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;int size=0;
root[size++]=init(1,n);&lt;/code&gt;&lt;p&gt;我们每一次都这样更新&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;root[size+1]=update(root[size],1,n);
++size;&lt;/code&gt;&lt;p&gt;这里的意思就是，我们把单点更新之后的线段树，即仅仅有着一条新链，但是其余节点仍然指向上一棵线段树的节点的线段树的根节点保存起来。这也就意味着，我们做了m次操作之后，root里面会有m+1棵线段树(初始有1棵)。对于相邻两棵线段树来说，后面一棵仅仅和之前的一棵有一条链是不一样的而已，后面一棵其余的节点是仍然指向前面那一棵的，换而言之，后面一棵的非新链上的节点是和前面一棵公用的。&lt;/p&gt;&lt;p&gt;这样做有什么好处？&lt;/p&gt;&lt;p&gt;一个显而易见的好处就是我们现在能够查询历史版本了，比如说，询问在第k次修改之后的区间[x,y]上的最大值，因为对于每一次修改之后的线段树的root节点我们都保存在了数组里面，因此便直接调用&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;query(root[k],1,n)&lt;/code&gt;&lt;p&gt;即可。注意此处适用于单点修改，区间修改需要打lazy tag，我还需要仔细想一想。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么最后再来一个例题讲解 &lt;a href=&quot;http://poj.org/problem?id=2104&quot;&gt;2104 -- K-th Number&lt;/a&gt;&lt;/p&gt;&lt;p&gt;题意是给出 n和m，n是数组长度，m是操作次数，n为100,000，m为5000&lt;/p&gt;&lt;p&gt;每一次操作给出三个数x y k询问区间[x,y]上第k小的数&lt;/p&gt;&lt;p&gt;首先考虑简单情况，如何用线段树解决询问区间[1,n]上的第k小的数。&lt;/p&gt;&lt;p&gt;假设数组元素的数据范围是[1,100]，那么我们开一个至少有100个叶子节点的线段树，线段树的节点维护当前区间数字出现次数之和，每来一个数v，就对区间[v,v]进行+1操作。查询时先看左子树的次数之和left_sum是否超过k，若超过，进入左子树查询，否则进入右子树查询第k-left_sum小的数。&lt;/p&gt;&lt;p&gt;但是现在元素的数据范围是1e9太大了，因为n最多只有100,000，离散化即可。&lt;/p&gt;&lt;p&gt;我们解决了对于整个数组查询第k小的问题，接下来解决区间查询&lt;/p&gt;&lt;p&gt;注意到区间数字出现次数之和可以用前缀和来维护，即对于任意一个区间[x,y]&lt;/p&gt;&lt;p&gt;[x,y]中的数字出现次数之和等于 [1,y]中数字出现次数之和 - [1,x-1]中数字出现次数之和&lt;/p&gt;&lt;p&gt;这也就意味着我们只需要n棵线段树就能求出任意一个区间的数字出现次数之和，这n棵线段树对应着区间[1,1]、[1,2]、[1,3]、......、[1,n]。&lt;/p&gt;&lt;p&gt;对于查询任意一个区间[x,y]，我们只要拿对应[1,y]线段树上节点的值减掉[1,x-1]线段树上对应节点的值即可。&lt;/p&gt;&lt;p&gt;最后看这n个线段树有什么性质&lt;/p&gt;&lt;p&gt;对于相邻两个线段树，即[1,i]和[1,i+1]，相当于把源数组的第i+1个元素，无妨说是a，在[1,i]线段树上对区间[a,a]进行了+1操作，即，满足我们上面所说的，相邻两棵线段树只有一条链是不一样的。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Part IV：&lt;/p&gt;&lt;p&gt;函数式实现线段树代码：&lt;a href=&quot;https://github.com/Hatsunespica/CL/blob/master/Melange/segmentTree.cpp&quot;&gt;https://github.com/Hatsunespica/CL/blob/master/Melange/segmentTree.cpp&lt;/a&gt;&lt;/p&gt;&lt;p&gt;有关于例题的k-number的AC代码可以参看我的回答，我的回答只有两个...&lt;/p&gt;&lt;p&gt;写了很多，若有错误，还请指正。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Spica</author>
<guid isPermaLink="false">2018-04-02-35201534</guid>
<pubDate>Mon, 02 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Programming Languages: Application and Interpretation【译15下】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-02-35198525.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35198525&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b71b632ed7974538bb2e812bcd20914e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;初翻： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/9bebf466fc2535bec442451dca7cd13a&quot; data-hash=&quot;9bebf466fc2535bec442451dca7cd13a&quot; data-hovercard=&quot;p$b$9bebf466fc2535bec442451dca7cd13a&quot;&gt;@lotuc&lt;/a&gt; &lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;https://lotuc.gitbooks.io/plai-cn/content/&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;15.3.3 联合类型&lt;/h2&gt;&lt;p&gt;假设我们要建立动物园动物的链表，动物有这些种类：犰狳、红尾蚺等。目前，我们必须创建新的数据类型：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type Animal
  [armadillo (alive? : boolean)] ;犰狳
  [boa (length : number)]) ;蚺&lt;/code&gt;&lt;blockquote&gt;“在德州，马路中间除了黄线和死掉的犰狳什么都没有。” —— Jim Hightower&lt;/blockquote&gt;&lt;p&gt;然后创建它的链表：&lt;code class=&quot;inline&quot;&gt;(listof Animal)&lt;/code&gt;。因此，&lt;code class=&quot;inline&quot;&gt;Animal&lt;/code&gt;类型表示的是&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;的“联合（或称联合体，union）”，不过要创建这种联合的唯一方式是每次都创建新类型：比如要创建动物和植物的联合，就需要：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type LivingThings
  [animal (a : Animal)]
  [plant (p : Plant)])&lt;/code&gt;&lt;p&gt;这样实际的动物现在裹在了更深一“层”。这些类型被称为&lt;b&gt;带标签的联合&lt;/b&gt;（tagged union）或&lt;b&gt;可辨识的联合&lt;/b&gt;（discriminated union），因为我们需要显式引入类似&lt;code class=&quot;inline&quot;&gt;animal&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;plant&lt;/code&gt;的标签（或称&lt;b&gt;辨识符&lt;/b&gt;(discriminator)）来区分它们。相应地，结构体只能通过数据类型声明来定义；要创建只包含一种变体的数据结构，如&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type Constraints
  [eqCon (lhs : Term) (rhs : Term)])&lt;/code&gt;&lt;p&gt;来表示该数据结构，我们需要使用类型&lt;code class=&quot;inline&quot;&gt;Constraints&lt;/code&gt;而不是&lt;code class=&quot;inline&quot;&gt;eqCons&lt;/code&gt;，因为&lt;code class=&quot;inline&quot;&gt;eqCons&lt;/code&gt;不是类型，只是能在运行时区分的类型变体。&lt;/p&gt;&lt;p&gt;无论哪种方式，联合类型的要点是表示析取或“或”。值的类型是联合中某个类型。值通常只能是联合中某个特定的类型，不过这取决于联合类型的精确定义、规范它们的规则等等。&lt;/p&gt;&lt;h2&gt;15.3.3.1 作为类型的结构体&lt;/h2&gt;&lt;p&gt;对此自然的反应可能是，为什么不移除这种限制？为什么不允许每个结构体独立存在，将类型定义为一些结构体的集合？毕竟，不管是C还是Racket，程序员都可以定义独立的结构体，无需使用标签构造函数将它们包裹在其它类型里！例如，Racket里可以写：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(struct armadillo (alive?))
(struct boa (length))&lt;/code&gt;&lt;p&gt;加个注释：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;;; 动物是下面两者之一：
;; - (armadillo &amp;lt;boolean&amp;gt;)
;; - (boa &amp;lt;number&amp;gt;)&lt;/code&gt;&lt;p&gt;但是由于Racket不强制静态类型，这种比较不太清楚。然而，我们可以和 &lt;i&gt;Typed Racket&lt;/i&gt; （内置与DrRacket中的静态类型Racket）相比较。下面是对应的静态类型代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#lang typed/racket
 
(struct: armadillo ([alive? : Boolean]))
(struct: boa ([length : Real])) ;; feet&lt;/code&gt;&lt;p&gt;无需引用&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;就可以定义使用&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;类型值的函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;;; http://en.wikipedia.org/wiki/Boa_constrictor#Size_and_weight
(define: (big-one? [b : boa]) : Boolean
  (&amp;gt; (boa-length b) 8))&lt;/code&gt;&lt;p&gt;事实上，如果调用此函数时传入其它类型，如&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;——&lt;code class=&quot;inline&quot;&gt;(big-one? (armadillo true))&lt;/code&gt;——将发生&lt;b&gt;静态&lt;/b&gt;错误。因为&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;之间的关系等同与数和字符串之间的关系。&lt;/p&gt;&lt;p&gt;当然，我们仍可以定义这些类型的联合：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type Animal (U armadillo boa))&lt;/code&gt;&lt;p&gt;在这之上定义函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define: (safe-to-transport? [a : Animal]) : Boolean
  (cond
    [(boa? a) (not (big-one? a))]
    [(armadillo? a) (armadillo-alive? a)]))&lt;/code&gt;&lt;p&gt;之前我们有&lt;b&gt;一种包含两个变体的类型&lt;/b&gt;，现在则有&lt;b&gt;三种类型&lt;/b&gt;，其中两种类型恰巧能方便的通过联合定义第三种。&lt;/p&gt;&lt;h2&gt;15.3.3.2 无标签联合&lt;/h2&gt;&lt;p&gt;看起来我们好像还需要辨识标签，但并非如此。在支持联合类型的语言中，通常这样获取类型构造器&lt;code class=&quot;inline&quot;&gt;optionof&lt;/code&gt;：将期望的返回类型和用于表示失败或者&lt;code class=&quot;inline&quot;&gt;none&lt;/code&gt;的类型结合起来。例如，下面是&lt;code class=&quot;inline&quot;&gt;(optionof number)&lt;/code&gt;的等价实现：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type MaybeNumber (U Number Boolean))&lt;/code&gt;&lt;p&gt;同时，&lt;code class=&quot;inline&quot;&gt;Boolean&lt;/code&gt;本身也可以是&lt;code class=&quot;inline&quot;&gt;True&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;False&lt;/code&gt;的联合，在Typed Racket中也确实如此。因此，选择（option）类型更为准确的模拟实现应该是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type MaybeNumber (U Number False))&lt;/code&gt;&lt;p&gt;更为一般的，可以定义：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(struct: none ())
(define-type (Maybeof T) (U T none))&lt;/code&gt;&lt;p&gt;由于由于&lt;code class=&quot;inline&quot;&gt;none&lt;/code&gt;是新的、独特的类型，不会和其它类型混淆，因此该定义适用于所有类型。它提供给我们与选择类型相同的好处，且我们的值没有被埋入深一层的&lt;code class=&quot;inline&quot;&gt;some&lt;/code&gt;结构体，而是立即可用。例如&lt;code class=&quot;inline&quot;&gt;member&lt;/code&gt;，其Typed Racket中的类型是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(All (a) (a (Listof a) -&amp;gt; (U False (Listof a))))&lt;/code&gt;&lt;p&gt;如果元素未找到，&lt;code class=&quot;inline&quot;&gt;member&lt;/code&gt;返回&lt;code class=&quot;inline&quot;&gt;false&lt;/code&gt;；否则，它将返回从该元素开始的链表（即，链表的第一个元素是期望的元素）。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (member 2 (list 1 2 3))
&#39;(2 3)&lt;/code&gt;&lt;p&gt;将其转换为使用&lt;code class=&quot;inline&quot;&gt;Maybeof&lt;/code&gt;实现，可以写成：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define: (t) (in-list? [e : t] [l : (Listof t)]) : (Maybeof (Listof t))
  (let ([v [member e l]])
    (if v
        v
        (none))))&lt;/code&gt;&lt;p&gt;如果元素未找到，它将返回值&lt;code class=&quot;inline&quot;&gt;(none)&lt;/code&gt;；如果找到了，仍然是返回链表：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (in-list? 2 (list 1 2 3))
&#39;(2 3)&lt;/code&gt;&lt;p&gt;这样就无需从&lt;code class=&quot;inline&quot;&gt;some&lt;/code&gt;容器中取出链表。&lt;/p&gt;&lt;h2&gt;15.3.3.3 辨识无标签联合&lt;/h2&gt;&lt;p&gt;将值放入联合是一码事；我们还需要考虑如何以类型良好的方式将值从其中取出来。在我们的类ML类型系统中，我们使用程式化的符号——我们的语言中&lt;code class=&quot;inline&quot;&gt;type-case&lt;/code&gt;，ML中的模式匹配——来标识和取出各部分。具体来说，对于代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (safe-to-transport? [a : Animal]) : boolean
  (type-case Animal a
             [armadillo (a?) a?]
             [boa (l) (not (big-one? l))]))&lt;/code&gt;&lt;p&gt;在整个表达式中&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的类型保持一致。标识符&lt;code class=&quot;inline&quot;&gt;a?&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;l&lt;/code&gt;分别被绑定到布尔类型和数类型的值上，&lt;code class=&quot;inline&quot;&gt;big-one?&lt;/code&gt;接收的就是这些类型，而不是&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;。换句话说，&lt;code class=&quot;inline&quot;&gt;big-one?&lt;/code&gt;函数的输入类型不可以是&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;，因为根本没有这样的类型。&lt;/p&gt;&lt;p&gt;反之，使用联合类型的话，我们确实有&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;类型。因此，我们遵守对值进行谓词操作将&lt;b&gt;缩小其类型&lt;/b&gt;的原则。例如，在&lt;code class=&quot;inline&quot;&gt;cond&lt;/code&gt;的子句&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;[(boa? a) (not (big-one? a))]&lt;/code&gt;&lt;p&gt;中，尽管&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的初始类型为&lt;code class=&quot;inline&quot;&gt;Animal&lt;/code&gt;，在通过&lt;code class=&quot;inline&quot;&gt;boa?&lt;/code&gt;测试后，类型检查器会将其类型缩小到&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;的分支，这样&lt;code class=&quot;inline&quot;&gt;big-one?&lt;/code&gt;调用得以通过类型检查。反过来，其在条件表达式剩余部分的类型&lt;b&gt;不是&lt;/b&gt; &lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;——这里，只剩下&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;一种可能。这给类型检查器提出了更高的要求，它需要能测试并识别特定模式（称为&lt;b&gt;条件分割&lt;/b&gt;(if-splitting)）；缺了这种能力就无法使用联合类型编程；当然我们可以只识别类ML系统中能识别的模式，也就是模式匹配、&lt;code class=&quot;inline&quot;&gt;type-case&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;15.3.3.4 改造为静态类型&lt;/h2&gt;&lt;p&gt;毫不奇怪，Typed Racket使用联合类型。当将现有语言改造为静态类型时，它们尤其有用，因为现有语言（如脚本语言中）的程序没有用类ML类型系统的原则来定义。这种类型改造的通用的原则之一是尽可能多地静态捕获动态异常。当然，检查器最终会让一些程序无法通过检查【注释】，但如果它拒绝太多可以无错运行的程序，开发者不太可能采用它。由于这些程序是在没有考虑类型检查的情况下编写的，因此类型检查器需要以更为激进的方式接受该语言中被认为合理的习惯用法。&lt;/p&gt;&lt;blockquote&gt;除非它实现了称为&lt;b&gt;软类型&lt;/b&gt;（soft typing）的有趣想法：不拒绝任何程序，而是提供信息告知程序中无法通过类型检查之处。&lt;/blockquote&gt;&lt;p&gt;考虑下面的JavaScript函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;var slice = function (arr, start, stop) {
  var result = [];
  for (var i = 0; i &amp;lt;= stop - start; i++) {
      result[i] = arr[start + i];
  }
  return result;
}&lt;/code&gt;&lt;p&gt;它读入一个数组和两个索引，返回这两个索引之间的子数组。例如，&lt;code class=&quot;inline&quot;&gt;slice([5, 7, 11, 13], 0, 2)&lt;/code&gt;求得&lt;code class=&quot;inline&quot;&gt;[5, 7, 11]&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在JavaScript中，开发人员在函数调用时可以自由的省略任意或者所有尾部参数。每个被省略的参数都被赋予特定值&lt;code class=&quot;inline&quot;&gt;undefined&lt;/code&gt;，如何处理这种情形完全由函数决定。例如，&lt;code class=&quot;inline&quot;&gt;slice&lt;/code&gt;的典型实现允许用户省略最后一个参数；下面的定义&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;var slice = function (arr, start, stop) {
  if (typeof stop == &quot;undefined&quot;)
    stop = arr.length - 1;
  var result = [];
  for (var i = 0; i &amp;lt;= stop - start; i++) {
    result[i] = arr[start + i];
  }
  return result;
}&lt;/code&gt;&lt;p&gt;在未给定第三个参数时自动返回到数组结尾的子数组：因此&lt;code class=&quot;inline&quot;&gt;slice([5, 7, 11, 13], 2)&lt;/code&gt;返回&lt;code class=&quot;inline&quot;&gt;[11, 13]&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在Typed JavaScript【注释】中，程序员可以通过为给定参数指定类型&lt;code class=&quot;inline&quot;&gt;U Undefined&lt;/code&gt;来显式地指明函数可以接受更少的参数，此函数的类型如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;∀ t : (Array[t] * Int * (Int U Undefined) -&amp;gt; Array[t])&lt;/code&gt;&lt;blockquote&gt;由Arjun Guha等人在布朗（大学）创建。参见&lt;a href=&quot;http://www.jswebtools.org/&quot;&gt;我们的网站&lt;/a&gt;。&lt;/blockquote&gt;&lt;p&gt;原则上，这意味着表达式&lt;code class=&quot;inline&quot;&gt;stop - start&lt;/code&gt;存在发生类型错误的可能，因为&lt;code class=&quot;inline&quot;&gt;stop&lt;/code&gt;可能不是数。然而，当用户省略该参数时，对&lt;code class=&quot;inline&quot;&gt;stop&lt;/code&gt;的赋值正好将其设为数类型。换句话说，在所有控制路径上，减法发生前&lt;code class=&quot;inline&quot;&gt;stop&lt;/code&gt;都将是数类型，因此该函数能通过类型检查。当然，这要求类型检查器能够对控制流（条件）和状态（赋值）进行推断来确保函数类型正确；而Typed JavaScript可以做到，也因此能允许这样的函数。&lt;/p&gt;&lt;h2&gt;15.3.3.4 设计选择&lt;/h2&gt;&lt;p&gt;拥有联合类型的语言中，通常有&lt;/p&gt;&lt;ul&gt;&lt;li&gt;独立的结构体类型（通常用类表示），而不是带有变体的数据类型。&lt;/li&gt;&lt;li&gt;用于表示特定类型的特殊（ad hoc）结构体集合。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sentinel_value&quot;&gt;哨兵值（sentinel value）&lt;/a&gt;表示失败。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;将这种风格的程序转换成满足类ML类型风格的非常费事。因此，许多改造过来的类型系统引入联合类型来减轻类型化过程的负担。&lt;/p&gt;&lt;p&gt;上述三个属性中，第一个相对中立，但是其它两个需要更多讨论。我们以反序依次解决它们。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先处理哨兵值。很多情况下，哨兵应该被替换为异常，但是在很多语言中，抛出异常的代价巨大。因此开发者倾向于区分真正的异常情况——不应该发生——和正常运行中的预期情况。检查元素是否属于链表发现不存在的情况显然属于后者（如果我们已经知道元素是否存在，这个谓词判断就无需进行）。在后一种情况下，使用哨兵是合理的。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;然而，我们需要认识到，在C程序中，未能检测异常的哨兵值是错误——甚至安全缺陷——的常见原因。这点很容易解决。在C中，哨兵值和普通返回值&lt;b&gt;类型相同&lt;/b&gt;（或者至少等同于类型相同），而且运行时也没有检查。因此哨兵可以被当作合法的值使用，且不会出现类型错误。这就导致哨兵值&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;可以被当作分配数据的地址来使用，从而导致系统崩溃。与之不同，我们的哨兵是真正意义上的新类型，无法用于任何计算。观察到前语言中没有任何函数的输入类型为&lt;code class=&quot;inline&quot;&gt;none&lt;/code&gt;，可以推理出这点。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;先忽略这里贬义的“特殊”一词，对一组结构体进行不同的分组是否是个好主意？实际上，就算在遵循类ML规范的程序中，当程序员希望刻画一个大宇宙的子宇宙时，也会出现这种分组的情形。例如，ML程序员会使用下面的类型&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;(define-type SExp&lt;br&gt;  [numSexp (n : number)]&lt;br&gt;  [strSexp (s : string)]&lt;br&gt;  [listSexp (l : (listof SExp))])&lt;/p&gt;&lt;blockquote&gt;表示s-expression。如果有函数希望操作这些项的某个子集，比如数和数的链表，就必须创建新的类型，然后将值在两种类型之间转换，尽管这两个类型的内部表示完全相同。另一个例子，考虑CPS表达式的集合，这显然是所有可能表达式的一个子集，但如果不得不为其创建新的类型，我们将无法对其使用任何已有的表达式处理程序，比如解释器。&lt;/blockquote&gt;&lt;p&gt;换种说法，联合类型似乎是我们之前见到的ML风格类型系统的合理变种。但是，即使在联合类型中仍有设计选择，它们都有其后果。例如，允许类型系统创建新联合类型吗？允许用户定义（和命名）联合吗？也就是说，允许表达式&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(if (phase-of-the-moon)
    10
    true)&lt;/code&gt;&lt;p&gt;通过类型检查吗（将创建类型&lt;code class=&quot;inline&quot;&gt;(U Number Boolean)&lt;/code&gt;），还是由于其引入了之前未命名并显式标识的类型而将其判定为类型错误？Typed Racket提供的是前者：它将创建真正的临时联合。对于给现有代码引入类型来说，这么做可能更好，因为它更加灵活。但对于写新代码来说，这是否是个好的设计还并不清楚，因为并非程序员期望内的联合会出现，而且无法避免。这给程序语言的设计空间提供了一个未被探索的角落。&lt;/p&gt;&lt;h2&gt;15.3.4 名义类型系统与结构类型系统&lt;/h2&gt;&lt;p&gt;我们最初的类型检查器中，如果两个类型具有相同的结构，则认为它们是相同的。事实上我们根本没有提供类型的命名机制，因此不清楚有何替代方案。&lt;/p&gt;&lt;p&gt;现在考虑Typed Racket。程序员可以写&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type NB1 (U Number Boolean))
(define-type NB2 (U Number Boolean))&lt;/code&gt;&lt;p&gt;然后写&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define: v : NB1 5)&lt;/code&gt;&lt;p&gt;假设还定义了函数&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define: (f [x : NB2]) : NB2 x)&lt;/code&gt;&lt;p&gt;然后用&lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt;调用&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;，即&lt;code class=&quot;inline&quot;&gt;(f v)&lt;/code&gt;：该调用应该通过类型检查吗？&lt;/p&gt;&lt;p&gt;有两种完全合理的解释。一种是说&lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt;被声明为类型&lt;code class=&quot;inline&quot;&gt;NB1&lt;/code&gt;，与&lt;code class=&quot;inline&quot;&gt;NB2&lt;/code&gt;&lt;b&gt;名称&lt;/b&gt;不同，因此应该被当作不同&lt;b&gt;类型&lt;/b&gt;，所以该调用应导致错误。这种系统被称为&lt;b&gt;名义的&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Nominal_type_system&quot;&gt;nominal&lt;/a&gt;），因为类型的名字对于确定类型是否相等极为重要。&lt;/p&gt;&lt;p&gt;与之对应，另一种解释是说因为&lt;code class=&quot;inline&quot;&gt;NB1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;NB2&lt;/code&gt;&lt;b&gt;结构&lt;/b&gt;相同，因此开发者无法写出在这两种类型的值上表现的不同的程序来，所以它们应该被视为相同。【注释】这种类型系统被称为&lt;b&gt;结构的&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Structural_type_system&quot;&gt;structural&lt;/a&gt;），将允许上面的程序通过检查。（Typed Racket遵循结构类型的规范，理由同样是减少导入现有动态类型代码的负担，这些Racket代码通常是以结构解释为模型编写的。事实上，Typed Racket中&lt;code class=&quot;inline&quot;&gt;(f v)&lt;/code&gt;不仅能通过类型检查，而且打印出的返回类型为&lt;code class=&quot;inline&quot;&gt;NB1&lt;/code&gt;，无视&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;返回值的类型注解！）&lt;/p&gt;&lt;blockquote&gt;如果特别小心，你会注意到被认为相同和实际相同之间是有区别的。这里不会涉及该问题，但请考虑编译器作者选择值的表示时其影响是啥，尤其在允许运行时获取值的静态类型的语言中。&lt;/blockquote&gt;&lt;p&gt;名义和结构类型之间的区别在面向对象语言中是最常见的争议，&lt;a href=&quot;https://github.com/lotuc/PLAI-cn/blob/master/chap15.md#1538-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B&quot;&gt;后面&lt;/a&gt;将简要回顾这个问题。然而，这里的重点是要说明这些问题本质上并不关乎“对象”。任何允许命名类型的语言——出于程序员精神健康的需要，也就是所有的语言了——都要应付此问题：命名只是方便起见，还是说所选的名字是被认为是有意义的？选择前者导致结构类型，选择后者导致名义类型。&lt;/p&gt;&lt;h2&gt;15.3.5 交叉类型&lt;/h2&gt;&lt;p&gt;我们刚探索了联合类型，很自然的就会想到有没有&lt;b&gt;交叉&lt;/b&gt;（intersection）类型呢。确实有。&lt;/p&gt;&lt;p&gt;如果联合类型指（该类型的）值属于这个联合中某个类型，交叉类型显然意味着该值属于交叉中的&lt;b&gt;所有&lt;/b&gt;类型：合取，或“且”。这可能看起来很奇怪：值怎么可能属于多种类型呢？&lt;/p&gt;&lt;p&gt;用具体例子回答，考虑&lt;b&gt;重载函数&lt;/b&gt;。例如，某些语言中&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;即可操作数，也能操作字符串；传入两个数它返回数，传入两个字符串它返回字符串。这种语言中，&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;的类型应该是什么呢？不是&lt;code class=&quot;inline&quot;&gt;(number number -&amp;gt; number)&lt;/code&gt;，因为那样它将不能用于字符串；同样的原因，也不是&lt;code class=&quot;inline&quot;&gt;(string string -&amp;gt; string)&lt;/code&gt;。甚至它也不是&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(U (number number -&amp;gt; number)
   (string string -&amp;gt; string))&lt;/code&gt;&lt;p&gt;因为&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;不仅仅是这些函数之一：实际上它（同时）是这两者。我们可以认为其类型是&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((number U string) (number U string) -&amp;gt; (number U string))&lt;/code&gt;&lt;p&gt;这说明它的每个参数和返回值都只能是这两种类型之一，而不同时为两者。但是，这样做会导致精度损失。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;这种类型以何种方式损失精度？&lt;/blockquote&gt;&lt;p&gt;观察到，对于这个类型，&lt;b&gt;所有&lt;/b&gt;函数调用的返回值类型均为&lt;code class=&quot;inline&quot;&gt;(number U string)&lt;/code&gt;。因此，对于每个返回值都必须区分数和字符串，不然我们将得到类型错误。所以，尽管我们知道给定两个数参数将返回数结果，但这种信息在类型系统中丢失了。&lt;/p&gt;&lt;p&gt;更巧妙的是，这个类型允许独立的选择每个参数的类型。因此，根据该类型，&lt;code class=&quot;inline&quot;&gt;(+ 3 &quot;x&quot;)&lt;/code&gt;也是合法的（且其返回值类型为&lt;code class=&quot;inline&quot;&gt;(number U string)&lt;/code&gt;）。但我们描述的加法操作当然没有对这组参数定义过！&lt;/p&gt;&lt;p&gt;因此描述这种加法的更为合适的类型是&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(^ (number number -&amp;gt; number)
   (string string -&amp;gt; string))&lt;/code&gt;&lt;p&gt;这里的&lt;code class=&quot;inline&quot;&gt;∧&lt;/code&gt;让人联想到逻辑上的合取操作符。这允许函数用两个数或者两个字符串进行调用，其它的则不允许。使用两个数调用返回数类型；使用两个字符串调用返回字符串类型；除此之外没有其它合法调用了。这刚好对应于我们期望的重载行为（有时也称为&lt;b&gt;特设多态&lt;/b&gt;(ad hoc polymorphism)）。请注意这只能处理有限数量重载的情况。&lt;/p&gt;&lt;h2&gt;15.3.6 递归类型&lt;/h2&gt;&lt;p&gt;学过联合类型之后，值得讨论一下我们原来遇到过的递归数据类型表达式。如果接受变体作为类型构造器，我们可以将递归类型写作它们的联合吗？例如就&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;来说，能否将它描述成等价于&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((BTmt) U (BTnd number BTnum BTnum))&lt;/code&gt;&lt;p&gt;的类型吗，其中&lt;code class=&quot;inline&quot;&gt;BTmt&lt;/code&gt;是零参数的构造器，而&lt;code class=&quot;inline&quot;&gt;BTnd&lt;/code&gt;是三参数的？不过，这三个参数的类型是什么？按上面所写的类型，&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;要么是类型语言内建的（这不能令人满意），要么是未绑定的。也许我们要的是&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;BTnum = ((BTmt) U (BTnd number BTnum BTnum))&lt;/code&gt;&lt;p&gt;问题是这个方程没有明显解法（还记得&lt;code class=&quot;inline&quot;&gt;ω&lt;/code&gt;吗？）。&lt;/p&gt;&lt;p&gt;这种情况我们讨论&lt;a href=&quot;https://github.com/lotuc/PLAI-cn/blob/master/chap9.md#91-%E9%80%92%E5%BD%92%E4%B8%8E%E5%BE%AA%E7%8E%AF%E6%95%B0%E6%8D%AE&quot;&gt;值的递归&lt;/a&gt;时就熟悉过。那时，我们发明了递归函数构造器（并展示了其实现）来规避这个问题。这里我们同样需要递归类型构造器。按惯例它被称为&lt;code class=&quot;inline&quot;&gt;μ&lt;/code&gt;（希腊字母“缪”）。有了它，我们可以将上面的类型写做&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;μ BTnum : ((BTmt) U (BTnd number BTnum BTnum))&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;μ&lt;/code&gt;是绑定构造；它将&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;绑定到后面写的整个类型上，包括对&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;自身的递归绑定。实践中，整个递归类型就是我们希望得到的称为&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;的类型：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;BTnum = μ BTnum : ((BTmt) U (BTnd number BTnum BTnum))&lt;/code&gt;&lt;p&gt;尽管这看起来像是循环定义，但请注意，右侧的&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;不依赖于等式左侧的那个：即，我们可以将其重写为&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;BTnum = μ T : ((BTmt) U (BTnd number T T))&lt;/code&gt;&lt;p&gt;换句话说，&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;的这个定义可以被认为是语法糖，可以在程序的各个地方替换使用，无需担心无限回归的问题。&lt;/p&gt;&lt;p&gt;语义层面上，对&lt;code class=&quot;inline&quot;&gt;μ&lt;/code&gt;绑定的类型的意义有两种截然不同的思考方式：它们可以被解释为&lt;b&gt;同构递归&lt;/b&gt;（isorecursive）或&lt;b&gt;等价递归&lt;/b&gt;（equirecursive）。然而其中区别很微妙，超出了本章范围。【注释】只需理解递归类型可以被视为等同于它的展开。例如，我们定义数的链表类型为&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;NumL = μ T : ((MtL) U (ConsL number T))&lt;/code&gt;&lt;p&gt;于是有&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;μ T : ((MtL) U (ConsL number T))
= (MtL) U (ConsL number (μ T : ((MtL) U (ConsL number T))))
= (MtL) U (ConsL number (MtL))
        U (ConsL number (ConsL number (μ T : ((MtL) U (ConsL number T)))))&lt;/code&gt;&lt;p&gt;以此类推（同构和等价递归之间的区别正是在相等性的概念上：是定义上的相等性还是同构意义上的）。每一步中，我们将参数&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;替换成整个类型。和值的递归一样，它的意思是需要时我们可以“获得另一个”&lt;code class=&quot;inline&quot;&gt;ConsL&lt;/code&gt;构造。换种说法，链表的&lt;b&gt;类型&lt;/b&gt;可以写成零或任意多元素的联合；这等价于包含零个、一个或任意个元素的&lt;b&gt;类型&lt;/b&gt;；以此类推。任何数的链表都（恰好）符合这些类型。&lt;/p&gt;&lt;blockquote&gt;Pierce的书中对此解释的非常好。&lt;/blockquote&gt;&lt;p&gt;注意到，即使基于对于&lt;code class=&quot;inline&quot;&gt;μ&lt;/code&gt;的这种非正式理解，我们已经可以给&lt;code class=&quot;inline&quot;&gt;ω&lt;/code&gt;进而&lt;code class=&quot;inline&quot;&gt;Ω&lt;/code&gt;提供类型。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;描述&lt;code class=&quot;inline&quot;&gt;ω&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;Ω&lt;/code&gt;的类型。&lt;/blockquote&gt;&lt;h2&gt;15.3.7 子类型&lt;/h2&gt;&lt;p&gt;假设我们有一个典型的二叉树定义；简单起见，我们假设值为数。为了说明问题，我们用Typed Racket写：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#lang typed/racket

(define-struct: mt ())
(define-struct: nd ([v : Number] [l : BT] [r : BT]))
(define-type BT (U mt nd))&lt;/code&gt;&lt;p&gt;考虑二叉树具体的值：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (mt)
- : mt
#&amp;lt;mt&amp;gt;
&amp;gt; (nd 5 (mt) (mt))
- : nd
#&amp;lt;nd&amp;gt;&lt;/code&gt;&lt;p&gt;请注意，每个结构体构造器构造出自己对应类型的值，而不是&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;类型的值。但是考虑&lt;code class=&quot;inline&quot;&gt;(nd 5 (mt) (mt))&lt;/code&gt;：&lt;code class=&quot;inline&quot;&gt;nd&lt;/code&gt;的定义表明其子树必须为&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;类型，但我们可以传给它&lt;code class=&quot;inline&quot;&gt;mt&lt;/code&gt;类型的值。&lt;/p&gt;&lt;p&gt;显然，使用&lt;code class=&quot;inline&quot;&gt;mt&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;nd&lt;/code&gt;来定义&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;并不是巧合。但是，它确实表明在进行类型检查时，不能只检查构造函数的相等性，至少我们目前所做的不够。相反，我们必须检查一种类型“适用于”另一种。这种行为被称为&lt;b&gt;子类型化&lt;/b&gt;（subtyping）。&lt;/p&gt;&lt;p&gt;子类型化的本质是定义一种关系，通常用&lt;code class=&quot;inline&quot;&gt;&amp;lt;:&lt;/code&gt;表示，将一对类型关联起来。在期待类型&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的位置，如果放入类型&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的值也成立，那么我们就称&lt;code class=&quot;inline&quot;&gt;S &amp;lt;: T&lt;/code&gt;：换句话说，子类型化将&lt;b&gt;可替代性&lt;/b&gt;的概念（即，任何期望类型&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的值的地方，都可以被替换成类型为&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的值）形式化。当这种关系成立时，&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;被称作&lt;b&gt;子类型&lt;/b&gt;（subtype），&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;被称作&lt;b&gt;超类型&lt;/b&gt;（supertype）。使用子集去解释这点是很有用的（通常也是准确的）：如果&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的值是&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的子集，那么期望接受&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;值的表达式收到&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;值时不会出问题。&lt;/p&gt;&lt;p&gt;子类型化对类型系统有着深远影响。我们必须审视每一种类型，并理解它和子类型化之间的相互作用。对于基本类型，这通常比较明显：数、字符串等不相交的类型，彼此无关。（存在一些语言，使用某基本类型表示其它的基本类型——例如，某些脚本语言中，数只不过是特殊写法的字符串，还有些语言中，布尔值就是数——这些语言中，基本类型之间也可能存在子类型关系，但是这并不常见。）但是，我们必须考虑子类型化和每个复合类型构造器之间的关系。&lt;/p&gt;&lt;p&gt;事实上，甚至我们关于类型的表述也需要改变。假设我们有个类型为&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的表达式。通常我们会说它产生类型为&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的值。现在，我们需要小心的说，它产出&lt;b&gt;最多为&lt;/b&gt;&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的值，因为它可能只产出&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的某个子类型的值。因此，每个对类型的引用都隐含地涉及可能的子类型引用。为避免烦恼我会控制不这么做，但要小心，忽略这种隐含的解释可能导致推理错误。&lt;/p&gt;&lt;h2&gt;15.3.7.1 联合&lt;/h2&gt;&lt;p&gt;我们来讨论联合和子类型化会发生什么相互作用。显然，每个子联合是整个联合的子类型。在我们所用的例子中，显然每个&lt;code class=&quot;inline&quot;&gt;mt&lt;/code&gt;值都是&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;值；这同样适用于&lt;code class=&quot;inline&quot;&gt;nd&lt;/code&gt;。因而，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;mt &amp;lt;: BT
nd &amp;lt;: BT&lt;/code&gt;&lt;p&gt;于是，&lt;code class=&quot;inline&quot;&gt;(mt)&lt;/code&gt;也是&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;类型的，因此表达式&lt;code class=&quot;inline&quot;&gt;(nd 5 (mt) (mt))&lt;/code&gt;类型正确，就是&lt;code class=&quot;inline&quot;&gt;nd&lt;/code&gt;——因此也是&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;类型。一般来说，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;S &amp;lt;: (S U T)
T &amp;lt;: (S U T)&lt;/code&gt;&lt;p&gt;（我们写了两个看上去差不多的的规则，这是为了明确说明子类型处在联合中的哪“一边”并不重要）。它的意思是，&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的值可以被认为是&lt;code class=&quot;inline&quot;&gt;S U T&lt;/code&gt;的值，因为任何&lt;code class=&quot;inline&quot;&gt;S U T&lt;/code&gt;类型的表达式都确实可以包含&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;类型的值。&lt;/p&gt;&lt;h2&gt;15.3.7.2 交叉&lt;/h2&gt;&lt;p&gt;既然到了这里，我们也简要的讨论一下交叉。正如你可能想象的那样，交叉的行为是对偶的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(S ∧ T) &amp;lt;: S
(S ∧ T) &amp;lt;: T&lt;/code&gt;&lt;p&gt;为了说明这点，使用子集的解释：如果值即是&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;也是&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;，显然，它可以是两者中的任意一个。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;为什么下面两条假设&lt;b&gt;不&lt;/b&gt;成立？&lt;/blockquote&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;(S U T) &amp;lt;: S&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;T &amp;lt;: (S ∧ T)&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第一条不成立是因为类型&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的值是&lt;code class=&quot;inline&quot;&gt;(S U T)&lt;/code&gt;中完全合法的值。例如，数是类型&lt;code class=&quot;inline&quot;&gt;(string U number)&lt;/code&gt;的一员。然而，数不可以在需要类型为&lt;code class=&quot;inline&quot;&gt;string&lt;/code&gt;的时候被使用。&lt;/p&gt;&lt;p&gt;至于第二条，类型&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的值一般来说不是类型&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的值。任何希望类型&lt;code class=&quot;inline&quot;&gt;(S ∧ T)&lt;/code&gt;消费者希望其能够既作为&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;也作为&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，而后一点无法保证。例如对前面重载的&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;来说，如果&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;(number number -&amp;gt; number)&lt;/code&gt;，那么该类型的函数无法对字符串进行处理。&lt;/p&gt;&lt;h2&gt;15.3.7.3 函数&lt;/h2&gt;&lt;p&gt;我们还讨论过一种复合类型：函数。【注释】我们需要决定子类型关系中，任何一个类型为函数时的规则。通常我们认为函数和其它类型不相交，因此我们只需考虑函数类型作函数类型子类型的情况：也既，何时式子&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(S1 -&amp;gt; T1) &amp;lt;: (S2 -&amp;gt; T2)&lt;/code&gt;&lt;p&gt;成立？方便起见，我们称类型&lt;code class=&quot;inline&quot;&gt;(S1 -&amp;gt; T1)&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;f1&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;(S2 -&amp;gt; T2)&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;f2&lt;/code&gt;。问题就变成了，如果表达式的期望类型为&lt;code class=&quot;inline&quot;&gt;f2&lt;/code&gt;，何种情况下给其传递&lt;code class=&quot;inline&quot;&gt;f1&lt;/code&gt;类型的函数是安全的？使用子集合解释来考虑这个问题比较容易。&lt;/p&gt;&lt;blockquote&gt;我们还讨论过参数化数据类型。在本书中，对它们子类型化的探索作为练习留给读者。&lt;/blockquote&gt;&lt;p&gt;考虑&lt;code class=&quot;inline&quot;&gt;f2&lt;/code&gt;类型的使用。它返回值的类型为&lt;code class=&quot;inline&quot;&gt;T2&lt;/code&gt;。因此，函数调用所在的上下文会对&lt;code class=&quot;inline&quot;&gt;T2&lt;/code&gt;类型的值满意。显然，如果&lt;code class=&quot;inline&quot;&gt;T1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;T2&lt;/code&gt;相同，那么这里&lt;code class=&quot;inline&quot;&gt;f2&lt;/code&gt;的使用也能通过类型检查；类似的，如果&lt;code class=&quot;inline&quot;&gt;T1&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;T2&lt;/code&gt;值的一个子集，也是可以的。唯一的问题是，如果&lt;code class=&quot;inline&quot;&gt;T1&lt;/code&gt;的值比&lt;code class=&quot;inline&quot;&gt;T2&lt;/code&gt;多，该上下文将可能遭遇非期望的值，从而导致未定义行为。换句话说，我们需要&lt;code class=&quot;inline&quot;&gt;T1 &amp;lt;: T2&lt;/code&gt;。注意这里包含的“方向”与整个函数类型中的方向相同；这被称为&lt;b&gt;协变&lt;/b&gt;（covariance，两者在相同的方向上变化）。这也许正是你所期望的。&lt;/p&gt;&lt;p&gt;出于同样的原因，你可能认为参数位置也出现协变：即&lt;code class=&quot;inline&quot;&gt;S1 &amp;lt;: S2&lt;/code&gt;。这也符合预期，但它是错的。让我们看看为什么。&lt;/p&gt;&lt;p&gt;调用&lt;code class=&quot;inline&quot;&gt;f2&lt;/code&gt;类型的函数，需要提供类型为&lt;code class=&quot;inline&quot;&gt;S2&lt;/code&gt;的值作参数。假设我们将函数替换为类型&lt;code class=&quot;inline&quot;&gt;f1&lt;/code&gt;的。如果&lt;code class=&quot;inline&quot;&gt;S1 &amp;lt;: S2&lt;/code&gt;，这意味着新函数仅能接受&lt;code class=&quot;inline&quot;&gt;S1&lt;/code&gt;类型的值——这是一个严格子集。这意味着对于某些值——在&lt;code class=&quot;inline&quot;&gt;S2&lt;/code&gt;中但不在&lt;code class=&quot;inline&quot;&gt;S1&lt;/code&gt;中的值——函数调用会提供它们为参数，而换入的函数在它们之上并无定义，这导致未定义的行为。为避免此，需要假定相反的方向：即替代函数应该至少能接收原函数能够接收的那些值。因此我们需要&lt;code class=&quot;inline&quot;&gt;S2 &amp;lt;: S1&lt;/code&gt;，我们说该位置是&lt;b&gt;逆变&lt;/b&gt;（contravariant）的：它和子类型化方向相反。&lt;/p&gt;&lt;p&gt;综合这两个发现，我们得到函数（对于方法也一样）子类型化的规则：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(S2 &amp;lt;: S1) and (T1 &amp;lt;: T2) =&amp;gt; (S1 -&amp;gt; T1) &amp;lt;: (S2 -&amp;gt; T2)&lt;/code&gt;&lt;h2&gt;15.3.7.4 实现子类型&lt;/h2&gt;&lt;p&gt;当然，这些规则假定我们已经修改了类型检查器遵循子类型化的要求。子类型化的本质规则是，如果有表达式&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;，其类型为&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，且&lt;code class=&quot;inline&quot;&gt;S &amp;lt;: T&lt;/code&gt;，那么&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;也具有类型&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;。虽然这听起来很直观，但它也有问题，原因有二：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;到目前为止，我们所有的类型规则都是语法驱动的，这使我们可以编写递归下降的类型检查器。但现在有可一条适用于所有表达式的规则，我们不知道何时应用这条规则了。&lt;/li&gt;&lt;li&gt;可能存在很多级别的子类型。这使得何时“停止”子类型化不再是个显而易见的问题。特别是，原来类型检查会求出表达式的类型，现在表达式可以有很多可能的类型；如果我们返回了“错误”的类型，可能会导致类型错误（因为它不是上下文期望的类型），尽管这时候可能存在其它的类型能够满足上下文需求。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这两个问题指出的是，我们这里给出的关于子类型化的描述根本上来说是&lt;b&gt;声明性的&lt;/b&gt;：我们描述了它是怎样的，但是没有将这种说明转换成算法。对于每个实际的静态类型语言，将其转换成&lt;b&gt;子类型算法&lt;/b&gt;——实现类型检查器的实际算法（理想情况下，该类型检查器仅让所有声明机制下被认为是有效的程序通过类型检测，也即，既可靠又完备）——或多或少是个有趣的问题。&lt;/p&gt;&lt;h2&gt;15.3.8 对象类型&lt;/h2&gt;&lt;p&gt;正如我们&lt;a href=&quot;https://github.com/lotuc/PLAI-cn/blob/master/chap15.md#1534-%E5%90%8D%E4%B9%89%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F&quot;&gt;前面&lt;/a&gt;提到的，对象的类型通常分为两个阵营：名义的和结构的。名义类型大多数程序员通过Java都熟悉了，所以这里不多讨论。对象的结构类型是说，对象的类型本身就是一个结构化的对象，由字段的名字及它们的类型组成。例如，有两个方法——&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;sub1&lt;/code&gt;——的对象，其类型将是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;{add1 : (number -&amp;gt; number), sub1 : (number -&amp;gt; number)}&lt;/code&gt;&lt;p&gt;（为方便引用，我们称这个类型为&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;。）类型检查的做法也很容易预计：对于字段的访问，我们只需确保字段存在，并将解引用表达式类型求为该字段的声明类型；对于方法调用，我们不仅需要确保对应成员存在，还要确保其类型是函数。到目前为止，一切都很简单。&lt;/p&gt;&lt;p&gt;对象类型会因为很多原因而变复杂：&lt;/p&gt;&lt;blockquote&gt;很多书都专注于此问题。尽管有点过时，但是Abadi和Carelli的《A Theory of &lt;br&gt;Objects（对象理论）》仍然很重要。Bruce的《Foundationos of Object-Oriented Languages: Types and Semantics（面向对象语言基础：类型和语义）》更为现代，阐述也更温和。Pierce的书则漂亮的覆盖了所有必要的理论。&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;自引用。&lt;code class=&quot;inline&quot;&gt;self&lt;/code&gt;的类型是什么？它必须和整个对象的类型相同，因为任何可以从“外部”施加到对象上的操作也可以通过&lt;code class=&quot;inline&quot;&gt;self&lt;/code&gt;在“内部”施加。这意味着对象是递归类型。&lt;/li&gt;&lt;li&gt;访问控制：私有（private）、公共（public）和其它限制。这导致对象“外部”和“内部”类型之间的区别。&lt;/li&gt;&lt;li&gt;继承：不仅需要为父对象指定类型，还需要考虑继承路径上哪些东西可见，这和“外部”可见的东西又有区别。&lt;/li&gt;&lt;li&gt;多重继承和子类型之间的相互作用。&lt;/li&gt;&lt;li&gt;像Java这样的语言中，类和接口之间的关系存在运行时成本。&lt;/li&gt;&lt;li&gt;赋值。&lt;/li&gt;&lt;li&gt;类型转换。&lt;/li&gt;&lt;li&gt;横生枝节。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;等等。其中的一些问题会因为名义类型而简化，因为给定类型名我们就可以确定其行为的所有信息（类型声明实际变成了一个字典，从中可以查询关于对象的描述），这也是赞成名义类型的一个论据。&lt;/p&gt;&lt;blockquote&gt;请注意，Java的方法不是构建名义类型系统的唯一方法。之前讨论过，Java的类系统不必要地限制了程序员的表达能力；相应地，Java的名义类型不必要地将类型（接口描述）和实现混为一谈。因此，名义类型系统可以比Java做的好得多。例如，Scala在这个方面就做出了重要的改变。&lt;/blockquote&gt;&lt;p&gt;对这些问题进行充分论述需要更多的篇幅。这里我们只讨论一个有趣的问题。还记得我们说过，子类型化迫使我们考虑每种类型构造器吗？有了对象的结构类型，我们就必须多考虑一种：对象类型构造器。因此我们必须了解它与子类型化之间的相互作用。&lt;/p&gt;&lt;p&gt;在开始之前，先来确保我们理解对象类型到底意味着什么。考虑上面的&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;类型，其中列出了两个方法。什么对象的类型可以是它？显然，恰好拥有这两个方法、且方法的类型符合的对象符合条件。同样明显的是，如果某个对象只包含这两个方法中的一个而不含另一个，不管它还包含有其它什么，都不符合条件。但其中短语“不管它还包含其它什么”是最先要考虑的。如果对象表示的是算术包，除了这两个方法之外，它还包含&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt;呢（所有方法的类型也都正确）？这种情况下的对象当然能提供上面两个方法，因此该算术包确实具有类型&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;。不过将其作为类型&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;使用时，其它方法不可用。&lt;/p&gt;&lt;p&gt;下面我们写下这个包的完整类型，称之为&lt;code class=&quot;inline&quot;&gt;as+*&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;{add1  : (number -&amp;gt; number),
 sub1  : (number -&amp;gt; number),
 +     : (number number -&amp;gt; number),
 *     : (number number -&amp;gt; number)}&lt;/code&gt;&lt;p&gt;前面论证的是，类型&lt;code class=&quot;inline&quot;&gt;as+*&lt;/code&gt;的对象也允许被声明为类型&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;，这意味着它可以放入任何期望&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;类型值的上下文。换句话说，我们刚才的意思其实是&lt;code class=&quot;inline&quot;&gt;as+* &amp;lt;: addsub&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;{add1  : (number -&amp;gt; number),           {add1 : (number -&amp;gt; number),
 sub1  : (number -&amp;gt; number),        &amp;lt;:  sub1 : (number -&amp;gt; number)}
 +     : (number number -&amp;gt; number),
 *     : (number number -&amp;gt; number)}&lt;/code&gt;&lt;p&gt;这可能乍一看令人困惑：我们说过子类型化遵从集合包含关系，因此我们期望小的集合在左侧而大的集合在右侧。可这里，好像“大的类型”（至少在字符数量的意义上是）在左侧而“小的类型”在右侧。&lt;/p&gt;&lt;p&gt;要理解为什么这是正确的，需要建立这样的直觉：“越大”的类型包含的值越少。左侧的每个对象都含有四个方法，而且其中包含了右侧的那两个方法。但是，有很多对象有右侧的两个方法，但是不包含左侧那另外两个方法。如果我将类型看作对可接受值形状的约束的话，“更大”的类型给定了更多的约束，因此会导致更少的值。于是，尽管&lt;b&gt;类型&lt;/b&gt;的大小关系可能看上去不对，但是它们所包含的值的集合的大小关系是正确的。&lt;/p&gt;&lt;p&gt;更一般地，这表明从对象中删除字段就能获得超类型。这被称为&lt;b&gt;宽度子类型化&lt;/b&gt;（width subtyping），因为子类型“更宽”，而我们通过调整对象“宽度”来移动到更上层的类型。即使在Java的名义类型世界中也能看到这点：当沿着继承链上溯时，类中的方法和字段越来越少，直到&lt;code class=&quot;inline&quot;&gt;Object&lt;/code&gt;——所有类的超类型——包含得最少。因此对于Java中的任意类类型&lt;code class=&quot;inline&quot;&gt;C&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;C &amp;lt;: Object&lt;/code&gt;。&lt;/p&gt;&lt;blockquote&gt;有时，&lt;b&gt;缩小&lt;/b&gt;（narrowing）和&lt;b&gt;拓宽&lt;/b&gt;（widening）的使用方式会让人疑惑，它看上去好像用反了一样。拓宽是指从子类型转到超类型，因为它是从一个“较窄”（较小）的集合到一个“较宽”（较大）的集合。这些术语是独立演化而来的，很不幸，并不一致。&lt;/blockquote&gt;&lt;p&gt;正如你可能预计的那样，还有一种重要的子类型化形式，是关于给定成员&lt;b&gt;内部&lt;/b&gt;的。就是说，任何特定的成员都可以归入相应位置的超类型。出于显而易见的原因，这种形式的子类型化被称为&lt;b&gt;深度子类型化&lt;/b&gt;（depth subtyping）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;构造两个深度子类型化的例子。其中一个，给定字段为对象类型，使用宽度子类型化去取该字段的子类型。另一个例子中，给定字段为函数类型。&lt;/blockquote&gt;&lt;p&gt;Java中限制了深度子类型化，它倾向于类型在对象层次结构中保持不变，因为这对传统的赋值操作来说是安全的。&lt;/p&gt;&lt;p&gt;宽度和深度子类型化的结合包含了对象子类型化中大部分最有趣的情形。然而，仅实现这两种子类型化的类型系统不可避免地会招致程序员恼火。其它方便的（而且数学上必须的）规则还包括：改变名称排列顺序的能力、反身性（每个类型是其自己的子类型，因为将子类型关系解释为&lt;code class=&quot;inline&quot;&gt;⊆&lt;/code&gt;更方便）和传递性。像Typed JavaScript这样的语言使用了所有这些特性为程序员提供最大的灵活性。&lt;/p&gt;</description>
<author>MrMathematica</author>
<guid isPermaLink="false">2018-04-02-35198525</guid>
<pubDate>Mon, 02 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>发布Compute.scala，多维数组上的科学计算库</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-01-35183750.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35183750&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同学们，愚人节快乐，&lt;/p&gt;&lt;p&gt;今天我很荣幸向大家介绍&lt;b&gt;Compute.scala&lt;/b&gt;。Compute.scala是个科学计算库，可以利用GPU、CPU和其他设备并行计算多维数组。它是下一版本DeepLearning.scala v3.0的新后端，用来解决我们在DeepLearning.scala v2.0的ND4J后端中遇到的各种性能问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Compute.scala可以把多个操作动态合并成一个核函数。执行复杂计算公式时能比以前大大加速。&lt;/li&gt;&lt;li&gt;Compute.scala可以把内存、显存和其他原生资源管理起来，消耗的资源要比ND4J依赖垃圾收集的做法少得多。&lt;/li&gt;&lt;li&gt;Compute的维度转换操作（比如&lt;code class=&quot;inline&quot;&gt;permute&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;broadcast&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;reshape&lt;/code&gt;）都是视图，不额外占用显存或内存。&lt;/li&gt;&lt;li&gt;Compute的多维数组可以和JVM的集合互相转换，从而可以支持Scala原生的&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;reduce&lt;/code&gt;等集合操作，而且依然可以运行在GPU上。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;性能评测&lt;/h2&gt;&lt;p&gt;我们最近做了一些性能评测，对比Compute.scala和ND4J的性能：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://jmh.morethan.io/?source=https://raw.githubusercontent.com/ThoughtWorksInc/Compute.scala/f4fcd1cd54b9deea8b8234114b2bcdcf8c739038/benchmarks/nvidia-gpu.json&quot;&gt;Compute.scala vs ND4J on a NVIDIA Titan X GPU&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://jmh.morethan.io/?source=https://thoughtworksinc.github.io/Compute.scala/benchmarks/amd-gpu.json&quot;&gt;Compute.scala on a AMD RX480 GPU&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;从性能评测结果看：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Compute.scala支持各个厂商的GPU，ND4J只支持NVIDIA GPU。&lt;/li&gt;&lt;li&gt;在大数组上，Compute.scala比ND4J快。比如把65536×32的矩阵和32×32的矩阵相乘，那么Compute.scala要比ND4J快12倍多。&lt;/li&gt;&lt;li&gt;运行包含多个原子操作的复杂公式，Compute.scala比ND4J快。比如当对32×32×32的数组调用一个&lt;code class=&quot;inline&quot;&gt;tanh&lt;/code&gt;时，Compute.scala只比ND4J快五倍多，但是如果执行的表达式包含了100个&lt;code class=&quot;inline&quot;&gt;tanh&lt;/code&gt;，Compute.scala就比ND4J快三十倍多。&lt;/li&gt;&lt;li&gt;在很小的数组上执行单个简单操作时，ND4J比Compute.scala快。&lt;/li&gt;&lt;li&gt;ND4J的&lt;code class=&quot;inline&quot;&gt;permute&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;broadcast&lt;/code&gt;极慢，大概比Compute.scala慢上百倍，导致我们的卷积评测根本跑不出能看的结果（注：和ND4J同一家作者的Deeplearning4J用了文档上没记载的内部特殊方式使用&lt;code class=&quot;inline&quot;&gt;permute&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;broadcast&lt;/code&gt;，并不像上述评测里这么慢）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;注：这个评测结果并不是愚人节笑话。&lt;/p&gt;&lt;h2&gt;后续工作&lt;/h2&gt;&lt;p&gt;我们刚刚完成Compute.scala的最小可用原型，版本号v0.3.1。Compute.scala的功能仍然有待继续完善，我们将在正式版本发布以前完成以下功能：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;支持单精度浮点数以外的数据类型(&lt;a href=&quot;https://github.com/ThoughtWorksInc/Compute.scala/issues/104&quot;&gt;#104&lt;/a&gt;)&lt;/li&gt;&lt;li&gt;增加更多的OpenCL数学函数(&lt;a href=&quot;https://github.com/ThoughtWorksInc/Compute.scala/issues/101&quot;&gt;#101&lt;/a&gt;)&lt;/li&gt;&lt;li&gt;进一步性能调优(&lt;a href=&quot;https://github.com/ThoughtWorksInc/Compute.scala/labels/performance&quot;&gt;#62, #103&lt;/a&gt;)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;欢迎大家来贡献代码和文档。新贡献者可以从&lt;a href=&quot;https://github.com/ThoughtWorksInc/Compute.scala/labels/good%20first%20issue&quot;&gt;good first issues&lt;/a&gt;开搞。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;相关链接&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/ThoughtWorksInc/Compute.scala&quot;&gt;Compute.scala on Github&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://javadoc.io/page/com.thoughtworks.compute/tensors_2.12/latest/com/thoughtworks/compute/index.html&quot;&gt;Compute API Documentation&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2018-04-01-35183750</guid>
<pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>The C Programming Language：入门</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-01-35179359.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35179359&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
序&lt;br&gt;&lt;br&gt;在本书的开篇，我们首先概要地介绍 C 语言，主要是通过实际的程序引入 C 语言的基本元素，至于其中的具体细节、规则以及一些例外情况，在此暂时不多做讨论。因此，本章不准备完整、详细地讨论 C 语言中的一些技术（当然，这里所举的所有例子都是正确的）。我们是希望读者能尽快地编写出有用的程序，为此，本章将重点介绍一些基本概念，比如变量与 常量、算术运算、控制流、函数、基本输入／输出等。而对于编写较大型程序所涉及到的一 些重要特性，比如指针、结构、C 语言中十分丰富的运算符集合、部分控制流语句以及标准库 等，本章将暂不做讨论。 &lt;br&gt;&lt;br&gt;这种讲解方式也有缺点。应当提请注意的是，在本章的内容中无法找到任何特定语言特
性的完整说明，并且，由于比较简略，可能会使读者产生一些误解；再者，由于所举的例子 并没有用到 C 语言的所有强大功能，因此，这些例子也许并不简洁、精炼。虽然我们已经尽力将这些问题的影响降到最低，但问题肯定还是存在。另一个不足之处在于，本章所讲的某些内容在后续相关章节还必须再次讲述。我们希望这种重复给读者带来的帮助效果远远超过它的负面影响。 &lt;br&gt;&lt;br&gt;无论是利还是弊，一个经验丰富的程序员应该可以从本章介绍的内容中推知他们自己进
行程序设计所需要的一些基本元素。初学者应编写一些类似的小程序作为本章内容的补充练习。无论是经验丰富的程序员还是初学者，都可以把本章作为后续各章详细讲解的内容的框架。 &lt;br&gt;&lt;br&gt;1.1. 入门
&lt;br&gt;&lt;br&gt;学习一门新程序设计语言的惟一途径就是使用它编写程序。对于所有语言的初学者来说，编写的第一个程序几乎都是相同的，即：&lt;br&gt;请打印出下列内容 &lt;br&gt;&lt;br&gt;hello, world &lt;br&gt;&lt;br&gt;尽管这个练习很简单，但对于初学语言的人来说，它仍然可能成为一大障碍，因为要实
现这个目的，我们首先必须编写程序文本，然后成功地运行编译，并加载、运行，最后输出到某个地方。掌握了这些操作细节以后，其它事情就比较容易了。 &lt;br&gt;&lt;br&gt;在 C 语言中，我们可以用下列程序打印出&lt;br&gt;&lt;br&gt;“hello, world”：
&lt;br&gt;#include &amp;lt;stdio.h&amp;gt; 
&lt;br&gt;main() 
&lt;br&gt;{ 
&lt;br&gt; printf(&quot;hello, world\n&quot;); 
&lt;br&gt;} &lt;br&gt;&lt;br&gt;如何运行这个程序取决于所使用的系统。这里举一个特殊的例子。在 UNIX 操作系统中，首先必须在某个文件中建立这个源程序，并且以“.c”作为文件的扩展名，例如 hello.c，然后再通过下列命令进行编译： &lt;br&gt;&lt;br&gt;gcc hello.c &lt;br&gt;&lt;br&gt;如果源程序没有什么错误（例如漏掉字符或拼错字符），编译过程将顺利进行，并生成一个可
执行文件 a.out。然后，我们输入： &lt;br&gt;a.out 
&lt;br&gt;即可运行 a.out，打印出下列信息：
&lt;br&gt;hello, world 
&lt;br&gt;在其它操作系统中，编译、加载、运行等规则会有所不同。
&lt;br&gt;————————————————————————&lt;br&gt;#include &amp;lt;stdio.h&amp;gt; 
   &lt;br&gt; 包含标准库的信息&lt;br&gt;main() 
   &lt;br&gt;   定义名为 main 的函数，它不接受参数值&lt;br&gt;{ 
    &lt;br&gt;   main 函数的语句都被括在花括号中&lt;br&gt; printf(&quot;hello, world\n&quot;); 
&lt;br&gt;   main 函数调用库函数 printf 以显示字符序列&lt;br&gt;}       &lt;br&gt;   \n 代表换行符&lt;br&gt;                           第一个C语言程序&lt;br&gt;————————————————————————&lt;br&gt;&lt;br&gt;下面对程序本身做些说明。一个 C 语言程序，无论其大小如何，都是由函数和变量组成的。函数中包含一些语句，以指定所要执行的计算操作；变量则用于存储计算过程中使用的值。C 语言中的函数类似于 Fortran 语言中的子程序和函数，与 Pascal 语言中的过程和函数也很类似。在本例中，函数的名字为main。通常情况下，函数的命名没有限制，但 main 是一个特殊的函数名——每个程序都从 main 函数的起点开始执行，这意味着每个程序都必须在某个位置包含一个 main 函数。 &lt;br&gt;main 函数通常会调用其它函数来帮助完成某些工作，被调用的函数可以是程序设计人员
&lt;br&gt;自己编写的，也可以来自于函数库。上述程序段中的第一行语句
&lt;br&gt;&lt;br&gt;#include &amp;lt;stdio.h&amp;gt; 
&lt;br&gt;&lt;br&gt;用于告诉编译器在本程序中包含标准输入／输出库的信息。许多 C 语言源程序的开始处都包
含这一行语句。我们将在第 7 章和附录 B 中对标准库进行详细介绍。 &lt;br&gt;&lt;br&gt;函数之间进行数据交换的一种方法是调用函数向被调用函数提供一个值（称为参数）列
&lt;br&gt;表。函数名后面的一对圆括号将参数列表括起来。在本例中，main 函数不需要任何参数，因
此用空参数表()表示。 &lt;br&gt;&lt;br&gt;函数中的语句用一对花括号{}括起来。本例中的 main 函数仅包含下面一条语句：
&lt;br&gt;printf(&quot;hello, world\n&quot;); 
&lt;br&gt;调用函数时，只需要使用函数名加上用圆括号括起来的参数表即可。上面这条语句将&quot;hello, 
&lt;br&gt;world\n&quot;。作为参数调用 printf 函数。printf 是一个用于打印输出的库函数，在此处，它打印双引号中间的字符串。用双引号括起来的字符序列称为字符串或字符串常量，如&quot;hello,world\n&quot;就是一个字符串。目前我们仅使用字符串作为 printf 及其它函数的参数。&lt;br&gt;&lt;br&gt;在 C 语言中，字符序列\n 表示换行符，在打印中遇到它时，输出打印将换行，从下一行
&lt;br&gt;的左端行首开始。如果去掉字符串中的\n（这是个值得一做的练习），即使输出打印完成后也
不会换行。在 printf 函数的参数中，只能用\n 表示换行符。如果用程序的换行代替\n，例如：
&lt;br&gt;&lt;br&gt;printf(&quot;hello, world 
&lt;br&gt;&quot;); 
&lt;br&gt;&lt;br&gt;C 编译器将会产生一条错误信息。
&lt;br&gt;&lt;br&gt;printf 函数永远不会自动换行，这样我们可以多次调用该函数以分阶段得到一个长的输
&lt;br&gt;出行。上面给出的第一个程序也可以改写成下列形式：
&lt;br&gt;&lt;br&gt;#include &amp;lt;stdio.h&amp;gt; 
&lt;br&gt;main() 
&lt;br&gt;{ 
&lt;br&gt; printf(&quot;hello, &quot;); 
&lt;br&gt; printf(&quot;world&quot;); 
&lt;br&gt; printf(&quot;\n&quot;); 
&lt;br&gt;} 
&lt;br&gt;&lt;br&gt;这段程序与前面的程序的输出相同。
&lt;br&gt;请注意，\n 只代表一个字符。类似于\n 的转义字符序列为表示无法输入的字符或不可见
&lt;br&gt;字符提供了一种通用的可扩充的机制。除此之外，C 语言提供的转义字符序列还包括：\t 表
&lt;br&gt;示制表符；\b 表示回退符；\&quot;表示双引号；\\表示反斜杠符本身。2.3 节将给出转义字符序
列的完整列表。&lt;br&gt;&lt;br&gt;练习 1-1&lt;br&gt;在你自己的系统中运行“hello, world”程序。再有意去掉程序中的部分内容，看看会得到什么出错信息。 &lt;br&gt;练习 1-2 &lt;br&gt;做个实验，当 printf 函数的参数字符串中包含\c（其中 c 是上面的转义
字符序列中未曾列出的某一个字符）时，观察一下会出现什么情况。 &lt;br&gt;————————————————————————&lt;br&gt;&lt;br&gt;原作者：&lt;br&gt;Brian W. Kernighan 
&lt;br&gt;Dennis M. Ritchie&lt;br&gt;ヾ(@゜∇゜@)ノ祝米娜桑愚人节快乐~有什么不好的尽管在评论区提出哦~</description>
<author>A.Scarlet</author>
<guid isPermaLink="false">2018-04-01-35179359</guid>
<pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>C宏元编程:编译期LISP解释器（二）列表操作</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-01-35172411.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35172411&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;目录⇣&lt;br&gt;    &lt;a href=&quot;https://zhuanlan.zhihu.com/p/35121316&quot;&gt;（一）总体思路&lt;/a&gt;&lt;br&gt;⇢&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35172411&quot;&gt;（二）列表操作&lt;/a&gt;&lt;br&gt;外部链接⇣&lt;br&gt;这是一个超级神奇的项目&lt;a href=&quot;https://github.com/BlueFlo0d/CSP&quot;&gt;CSP Git Repo&lt;/a&gt; &lt;/blockquote&gt;&lt;blockquote&gt;纯粹用C宏写的LISP解释器！&lt;br&gt;（目前还没有完成，最重要的lambda已经实现了，cond暂时还有问题嵌套会出错x）&lt;br&gt;（想拉一些小伙伴一起玩一起烧脑呀！可惜似乎人类玩家直接看源码大概率大脑爆栈，于是尝试写了一些文章之类。。原始wiki可以戳这里&lt;br&gt;&lt;a href=&quot;https://github.com/BlueFlo0d/CSP/wiki/Implementation-details&quot;&gt;CSP Wiki&lt;/a&gt; &lt;/blockquote&gt;&lt;p&gt;这次要开始分析真正的Interpreter A原语啦！坐稳啦！&lt;/p&gt;&lt;h2&gt;列表结构&lt;/h2&gt;&lt;p&gt;开始分析LISP操作前我们先来看看CSP中列表的表示：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(a) //我是原子
( (a) (b) (c) (d) ) //我是列表&lt;/code&gt;&lt;p&gt;为什么要这样呢，用下面这种方式不会更自然吗：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;a //我才是原子
(a,b,c,d) //我才是列表&lt;/code&gt;&lt;p&gt;首先第一种方式括号更多，更符合LISP书写传统（划掉&lt;/p&gt;&lt;p&gt;最重要的是第一种方式在迭代列表和安全操作上有很多优点，例如迭代列表我们可以这样实现：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define sth(x) dosth(x) sth_y
#define sth_y(x) dosth(x) sth
sth(a)(b)(c)(d) // =&amp;gt; dosth(a) sth_y(b)(c)(d) ... 
// =&amp;gt; dosth(a) dosth(b) ... sth 或 sth_y （最后剩下一个没展开完的）&lt;/code&gt;&lt;p&gt;最后剩下的那个“尾巴”可以用零点构造或者以下方式“吃掉”：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define _sth(list) CAT(sth list,_end)
#define sth_end
#define sth_y_end
_sth((a)(b)(c)(d)) // =&amp;gt; CAT( dosth(a) ... sth,_end) =&amp;gt; dosth(a) ... sth_end =&amp;gt; dosth(a)&lt;/code&gt;&lt;p&gt;不过零点构造技术在柯里化的多元迭代函数上有更多优点，所以CSP中两者皆有采用。&lt;/p&gt;&lt;p&gt;至于安全性，接下来会提到。&lt;/p&gt;&lt;h2&gt;基本操作：CAR&lt;/h2&gt;&lt;p&gt;CAR：取一个列表第一个元素的操作，LISP基本原语之一&lt;/p&gt;&lt;p&gt;以下是朴素的CAR实现：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define CAR(x) (_CAR x ))
#define _CAR(x) x _n(
CAR ( (a) (b) (c) ) //=&amp;gt;(_CAR (a) (b) (c) )) 
//=&amp;gt; (a _n( (b) (c) )) =&amp;gt; (a)&lt;/code&gt;&lt;p&gt;这里让CAR定义式中的_CAR展开出一个_n(（未匹配左括号），和后面CAR中的未匹配右括号配对，构成一个零宏，从而将第一个元素后的内容都吃掉。&lt;/p&gt;&lt;p&gt;看起来很好是吗？不过实际上完全不能用。因为在CPP中，由于似乎无法实现短路的逻辑判断，条件分支中所有的clause都会先求值再遴选，这样这些clause大部分都会接受非法输入。&lt;/p&gt;&lt;p&gt;那么看看上面的CAR接受非法输入会发生什么：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;CAR(a) //=&amp;gt;(_CAR a)) 破坏括号平衡！
CAR() //=&amp;gt;(_CAR )) 破坏括号平衡！&lt;/code&gt;&lt;p&gt;会将整个展开过程破坏掉！所以我们需要在非法输入下安全的CAR宏。&lt;/p&gt;&lt;p&gt;实现如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define COND_EAT(x) COND_EATY
#define COND_EATY(x) COND_EAT
#define COND_EAT_FIRST(x) COND_EATY
#define SAFE_CAR_N(x) (())_n
#define SAFE_CAR_EAT_CAR )SAFE_CAR_N((
#define COND_EATY_SCEND (a)
#define COND_EAT_SCEND (a)
#define SAFE_CAR(a) _E(_e _SAFE_CAR(a))
#define _SAFE_CAR(a)  _e(_n _n()(CAT(SAFE_CAR_EAT,_E(_e CAR(CAT(COND_EAT_FIRST a,_SCEND)))))(CAR(a)))
//                                                        ^ 对于非法输入展开失败，输出 (_CAR ... ))
//                                                 ^ _E(_e ...) （两个单位宏名，一对括号）会吞掉参数的一对括号. =&amp;gt; _CAR )
//                                 ^ 连接成 SAFE_CAR_EAT_CAR =========\
//                                v 非法输入导致最后那个CAR同样展开失败.   |
// =&amp;gt; _e(_n _n() () SAFE_CAR_N(() (_CAR ... )) )                      &amp;lt;==/
// =&amp;gt; _e( (()) )
// =&amp;gt; (()) 
//代入 SAFE_CAR 中=&amp;gt; _E(_e (()) )=&amp;gt;()输出一个合法的空列表！&lt;/code&gt;&lt;p&gt;解释一下。_SAFE_CAR 宏大体分为前面的判断体_n _n()(CAT(SAFE_CAR_EAT,_E(_e CAR(CAT(COND_EAT_FIRST a,_SCEND))))) 和后面的主体(CAR(a))，以及最外面增加一次扫描次数的单位宏。判断体应当在输入非法时吃掉主体，而合法时自身输出空。&lt;/p&gt;&lt;p&gt;首先看到 CAT(COND_EAT_FIRST a,_SCEND)，这个目的是把所有形如(b)((c)(d))...之类的合法a值约化为(a)以方便判断体逻辑（否则可能会有很多嵌套列表，难以操作），而将不合法输入约化为一个不含括号的字符串。&lt;/p&gt;&lt;p&gt;此后交由CAR，对于不合法输入会输出形如(_CAR ...))，吞掉一对括号后与SAFE_CAR_EAT连成SAFE_CAR_EAT_CAR，再展开成熟悉的)SAFE_CAR_N((这种未匹配括号形式影响展开过程（多出一个左括号是为了和后面CAR展开失败输出的多余右括号匹配）。而对于合法输入，则直接被_n _n() (...) 吞掉。&lt;/p&gt;&lt;p&gt;SAFE_CDR采用类似思路实现。&lt;/p&gt;&lt;p&gt;好累啊就主要部分先写这么多吧，接下来稍微扯一下CSP解释器A中怎么处理多元函数的&lt;/p&gt;&lt;h2&gt;CSP解释器A中的柯里化&lt;/h2&gt;&lt;p&gt;之前提过的两个宏交替展开非常好，但似乎无法处理需要两个参数的do_sth。&lt;/p&gt;&lt;p&gt;其实可以通过柯里化解决，不过这样展开次数始终会缺一次所以还是得外置一组单位宏来延迟展开。&lt;/p&gt;&lt;p&gt;柯里化技巧的核心：ZIP宏&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define _be(y) y)
#define ZIP(x)   _n() (x,_be //This _n() delays the expansion of do_sth macro, after _be is expanded. otherwise it will an unmatched bracket error. 
do_sth ZIP(a)(b) =&amp;gt;do_sth _n()(a,_be(b)&lt;/code&gt;&lt;p&gt;如果外面再加一个单位宏强制增加一次扫描，就会变成：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;do_sth (a,b)&lt;/code&gt;&lt;p&gt;这样，一个签名为do_sth(a,b)的二元宏，就可以通过ZIP封装为do_sth ZIP，一个接受一元输入，输出一个一元宏的宏，从而能够处理一个CSP列表的前两项。&lt;/p&gt;&lt;p&gt;在CSP实现中，通常将参数放在待迭代列表前：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(arg)(a)(b)(c)....&lt;/code&gt;&lt;p&gt;do_sth实现为处理(arg,a)，并将arg放在处理结果之后，然后进行递归：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;do_sth (arg)
=&amp;gt; real_do_sth(arg,a) do_sth_y (arg) 
do_sth (arg)(a)(b)(c)
=&amp;gt; real_do_sth(arg,a) do_sth_y (arg) (b)(c)&lt;/code&gt;&lt;p&gt;这样就实现了带参数的迭代列表操作。&lt;/p&gt;</description>
<author>K.Scarlet</author>
<guid isPermaLink="false">2018-04-01-35172411</guid>
<pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>C++函数式实现BST、线段树(单点修改)（1）</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-01-35114696.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35114696&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1942006d5b24fedc190cafc1338070f4_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;偶然看到Common Lisp(&lt;b&gt;CL&lt;/b&gt;)中BST的写法，又联想到了自己写过的单点修改的主席树，觉得这两者几乎差不多，因此拿来分享一下，也顺便应该能解决一下为什么主席树又有一个“函数式版本的线段树”名称&lt;/p&gt;&lt;p&gt;本来打算直接用CL写的......但是想到可能很多人并不熟悉CL，于是就用C++代替了。&lt;/p&gt;&lt;p&gt;目前只打算写单点更新的线段树，而至于区间更新的需要打lazy tag，我需要去学习一下区间更新的主席树再来更新......&lt;/p&gt;&lt;p&gt;本来想完整的写完，但是想到一次性写完可能显得会太长而导致太长不看的可能，所以还是留线段树到下一次吧。&lt;/p&gt;&lt;p&gt;本篇前置知识：BST(Binary Search Tree，二叉搜索树)，C++基本语法&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Part I： 函数式风格几个important properties(此段引用自Land Of Lisp, Ch14, &quot;What is Functional Programming?&quot;)&lt;/p&gt;&lt;ul&gt;&lt;li&gt;只要传入的参数相同，函数总是返回同样的结果。The function always returns the same result, as long as the same arguments are passed into it. &lt;/li&gt;&lt;li&gt;函数不会引用定义在函数外部的变量，除非那个变量是常量。The function never references variables that are defined outside the function, unless we are certain that these variables will remain constant.&lt;/li&gt;&lt;li&gt;函数不会修改变量的值。No variables are modified by the function.&lt;/li&gt;&lt;li&gt;函数除了返回(动词)值以外什么也不干。(原谅本人直译......)The purpose of the function is to do nothing other than to return a result.&lt;/li&gt;&lt;li&gt;函数不会对外界造成任何改变。The function doesn’t do anything that is visible to the outside world, such as pop up a dialog box on the screen or make your computer go &quot;Bing!&quot;&lt;/li&gt;&lt;li&gt;The function doesn&#39;t take information from an outside source, such as&lt;br&gt;the keyboard or the hard drive.&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;p&gt;Part II：函数式的BST实现 &lt;/p&gt;&lt;p&gt;(new完没有delete)&lt;/p&gt;&lt;p&gt;用到的语法知识有：C++ explicit，nullptr，初始化列表，全局变量默认值&lt;/p&gt;&lt;p&gt;BST中节点的定义(注意声明了一个类型为Node*的全局变量root)&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;struct Node{
    int v;
    Node* le,*ri;
    explicit Node(int value=0,Node* lef=nullptr,Node* righ=nullptr)
            :v(value),le(lef),ri(righ){};
}*root;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;BST的插入：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;Node* bst_insert(int value,Node* bst){
    if(bst==nullptr)
        return new Node(value);
    if(value==bst-&amp;gt;v)
        return bst;
    else if(value&amp;lt;bst-&amp;gt;v)
        return new Node(bst-&amp;gt;v,bst_insert(value,bst-&amp;gt;le),bst-&amp;gt;ri);
    else
        return new Node(bst-&amp;gt;v,bst-&amp;gt;le,bst_insert(value,bst-&amp;gt;ri));
}&lt;/code&gt;&lt;p&gt;接下来讲解bst_insert：&lt;/p&gt;&lt;p&gt;（1）此方法接受一个value，即待插入的值，以及一个Node*，代表&lt;b&gt;当前&lt;/b&gt;的bst的root，因此一开始使用时传入root&lt;/p&gt;&lt;p&gt;（2）此方法前两种情况为简单情况，一个是&lt;b&gt;当前&lt;/b&gt;bst为空时，则返回一个新的、值为value的、左右子都为nullptr的节点。另一个是发现待插入的值和当前节点相等时，为避免重复直接返回自己。(其实这一步可以不要，不过，anyway，这反正不是重点......)&lt;/p&gt;&lt;p&gt;（3）第三种情况和第四种情况是对称的，看到第三种情况，是当前插入的值小于&lt;b&gt;当前&lt;/b&gt;bst的root，那么就返回一个新节点，这个新节点的值是&lt;b&gt;当前&lt;/b&gt;bst的root值，左子是在&lt;b&gt;当前&lt;/b&gt;root的左子上调用bst_insert的返回值，右子是&lt;b&gt;当前&lt;/b&gt;root的右子。&lt;/p&gt;&lt;p&gt;（4）第四种情况把上面的“小于”换成大于，“左”换成“右”，“右”换成“左”&lt;/p&gt;&lt;p&gt;画个图理解一下(纯手绘...请将就着看吧)&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-40276c163ce177a0876ca5d82e20c3c1_r.jpg&quot; data-caption=&quot;考虑在该树上插入新元素 9.5&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;651&quot; data-watermark-src=&quot;v2-3d90af0c145d21db9f50fdc41db4e48b&quot;&gt;&lt;p&gt;第一次调用bst_insert为bst_insert(9.5,root)&lt;/p&gt;&lt;p&gt;返回值是new Node(10,bst_insert(9.5,root-&amp;gt;le),root-&amp;gt;ri)&lt;/p&gt;&lt;p&gt;在途中需要求出bst_insert(9.5,root-&amp;gt;le)的值来完成构造函数，因此&lt;/p&gt;&lt;p&gt;第二次调用bst_insert为bst_insert(9.5,root-&amp;gt;le)&lt;/p&gt;&lt;p&gt;返回值是new Node(8,root-&amp;gt;le-&amp;gt;le,bst_insert(9.5,root-&amp;gt;le-&amp;gt;ri))&lt;/p&gt;&lt;p&gt;在途中需要求出bst_insert(9.5,root-&amp;gt;le-&amp;gt;ri)来完成构造函数，因此&lt;/p&gt;&lt;p&gt;第三次调用bst_insert为bst_insert(9.5,root-&amp;gt;le-&amp;gt;ri)&lt;/p&gt;&lt;p&gt;返回值是new Node(9,root-&amp;gt;le-&amp;gt;ri-&amp;gt;le,bst_inseret(9.5,root-&amp;gt;le-&amp;gt;ri-&amp;gt;ri))&lt;/p&gt;&lt;p&gt;在途中需要求出bst_inseret(9.5,root-&amp;gt;le-&amp;gt;ri-&amp;gt;ri)来完成构造函数，因此&lt;/p&gt;&lt;p&gt;第四次调用bst_insert为bst_inseret(9.5,root-&amp;gt;le-&amp;gt;ri-&amp;gt;ri)&lt;/p&gt;&lt;p&gt;但是root-&amp;gt;le-&amp;gt;ri-&amp;gt;ri为nullptr，因此会直接返回Node(9.5)，因此返回过程如下&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-03814a87e336d4e4212d6d4a06ab87f2_r.jpg&quot; data-caption=&quot;途中的次序表示第几次的返回值，黑线表示连接到了原来的节点&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1633&quot; data-watermark-src=&quot;v2-1f9d2e3dc03b5a53f6dc7c2312660ef3&quot;&gt;&lt;p&gt;我们可以发现，插入的返回值就是一条链，代表的是从真正的root节点一直到被插入的地方的链，其余的节点都是连接到的原来的节点上。因此我们只要令root等于第一次调用bst_insert的返回值就OK了。&lt;/p&gt;&lt;p&gt;可以发现，这其中我们并没有对原来bst上进行修改，而是创建了一条新链，而让这条链和之前的bst共用某些节点。(单点更新的主席树！)&lt;/p&gt;&lt;p&gt;这个联系留到下一次再发。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;BST插入的使用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;int main(){
    srand(time(0));
    for(int i=0;i&amp;lt;10;++i)
        root=bst_insert(rand()%100,root);
    dfs(root);//随便遍历一下，表明it works pretty well. 2333333333
    return 0;
}

void dfs(Node* bst){
    if(bst!=nullptr){
        cout&amp;lt;&amp;lt;bst-&amp;gt;v&amp;lt;&amp;lt;&#39; &#39;;
        dfs(bst-&amp;gt;le);dfs(bst-&amp;gt;ri);
    }
}&lt;/code&gt;&lt;hr&gt;&lt;p&gt;Part III：其他&lt;/p&gt;&lt;p&gt;我觉得我应该把函数式删除拿出来写一个番外篇...这毕竟和写作本文的主旨没有关联。&lt;/p&gt;&lt;p&gt;本篇中的BST完整代码:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Hatsunespica/CL/blob/master/Melange/f_bst.cpp&quot;&gt;https://github.com/Hatsunespica/CL/blob/master/Melange/f_bst.cpp&lt;/a&gt;&lt;/p&gt;&lt;p&gt;假如觉得有什么地方写的错误或不好or可以改进的地方，请尽管提出来。&lt;/p&gt;</description>
<author>Spica</author>
<guid isPermaLink="false">2018-04-01-35114696</guid>
<pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>C宏元编程:编译期LISP解释器（一）总体思路</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-30-35121316.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35121316&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一个超级神奇的项目 &lt;a href=&quot;https://github.com/BlueFlo0d/CSP&quot;&gt;CSP GIt Repo&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对！纯粹用C宏-那个只支持字符串替换和粘贴的东西-写的LISP解释器！&lt;/p&gt;&lt;p&gt;（目前还没有完成，最重要的lambda已经实现了，cond暂时还有问题嵌套会出错x）&lt;/p&gt;&lt;p&gt;（想拉一些小伙伴一起玩一起烧脑呀！可惜似乎人类玩家直接看源码大概率大脑爆栈，于是尝试写了一些文章之类。。原始wiki可以戳这里 &lt;a href=&quot;https://github.com/BlueFlo0d/CSP/wiki/Implementation-details&quot;&gt;CSP Wiki&lt;/a&gt;&lt;/p&gt;&lt;p&gt;那么现在就开始玩转（abuse）C宏定义的神奇（ドM）之旅吧！&lt;/p&gt;&lt;h2&gt;总体思路&lt;/h2&gt;&lt;p&gt;C宏定义想必大家都熟悉，姑且展开最天马行空的想象，进行LISP的列表操作（CAR CDR CONS之类）应该是可行的，First-class function某种程度上似乎也可行（传递宏名），比如这个例子：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define E(...) __VA_ARGS__ //单位宏
#define N(...) //零宏
#define __test(something,k,...) k(do something)
#define _test(something,...) __test(something,E)
_test(testit) // =&amp;gt; __test(testit,E) =&amp;gt; E(do testit) =&amp;gt; do testit
_test(E(N,N)) // =&amp;gt; __test(N,N,E) =&amp;gt; N(do N) =&amp;gt;
//_test(E(N,N))的输出消失了！&lt;/code&gt;&lt;p&gt;这个例子中我们看到我们将零宏和单位宏作为参数传入，并使得_test（封装 __test）具有一个零点 E(N,N)。这个技巧（私货！）在CSP的实现中经常用到！记笔记！&lt;/p&gt;&lt;p&gt;但是要实现lambda。。似乎纯粹的C宏很难做到（比如要把参数代入匿名函数体。。咋整啊）。。&lt;/p&gt;&lt;p&gt;不过别忘了神奇的LISP是可以实现自解释的！也就是可以用没有lambda语义的LISP解释器来实现完整的LISP解释器。&lt;/p&gt;&lt;p&gt;CSP的实现就按照了这个思路，首先实现解释器A（其实就是加载了一组实现LISP原语宏的C预处理器），然后再在解释器A上实现完整的LISP自解释器B。以下是自解释器的源码（不是最新的x 最新的在纠结那个有问题的cond）&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;//Line 176, csp.h
#define $zipped_eval(e,a) COND(\
        (ATOM e (EVAL_e $zipped_assoc(e,a)))    \
        (ATOM SAFE_CAR e \
         COND(($eq(SAFE_CAR e (quote))EVAL_e(SAFE_CAR SAFE_CDR e))  \
              ($eq(SAFE_CAR e (atom)) (EVAL_e ATOM\
              DELAY_INT_23($zipped_eval_R)() (SAFE_CAR SAFE_CDR e,a))) \
              ($eq(SAFE_CAR e (eq)) (EVAL_e $eq( DELAY_INT_25($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR e,a) DELAY_INT_25($zipped_eval_R)() \
              (SAFE_CAR SAFE_CDR SAFE_CDR e,a)))) \
              ($eq(SAFE_CAR e (car)) (EVAL_e SAFE_CAR DELAY_INT_23($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR e,a))) \
              ($eq(SAFE_CAR e (cdr)) (EVAL_e SAFE_CDR DELAY_INT_23($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR e,a))) \
              ($eq(SAFE_CAR e (cons)) (EVAL_e CONS DELAY_INT_23($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR e,a) DELAY_INT_23($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR SAFE_CDR e,a))) \
              ((T)(EVAL_e DELAY_INT_23($zipped_eval_R)()\
               (($zipped_assoc(SAFE_CAR e,a) EVAL_e SAFE_CDR e),a))) \
                 )                                                      \
                )                                                       \
        ($eq(SAFE_CAR SAFE_CAR e (lambda))\
        (DELAY_INT_26(EVAL_e_R)() DELAY_INT_23($zipped_eval_R)()(\
        EVAL_e(EVAL_e(EVAL_e(EVAL_e(SAFE_CAR SAFE_CDR SAFE_CDR SAFE_CAR e)))),\
        EVAL_e(APPEND DELAY_INT_13($pair_R)()(EVAL_e(EVAL_e(EVAL_e(SAFE_CAR SAFE_CDR SAFE_CAR e)))\
        (DELAY_INT_19($zipped_evlis_R)()(EVAL_e(_e EVAL_e(SAFE_CDR e)), a)))a)))\
        )                                                               \
)&lt;/code&gt;&lt;p&gt;是不是似曾相识啊23333&lt;/p&gt;&lt;p&gt;典型的自解释器实现。大家注意到这里：&lt;/p&gt;&lt;p&gt;1）有很多SAFE_XXX之类的东西，将来会解释。（C宏处理似乎难以实现短路condition，导致经常会对非法表达式进行求值，这种情况下使用naive的原语宏是会出事的-原地报错／破坏括号平衡-所以必须要很麻烦地一个一个实现为对于非法输入仍能给出合法结果的宏）&lt;/p&gt;&lt;p&gt;2）很多EVAL_e。这是一个单位宏，单位宏和零宏在C宏展开中作用非常大，因为可以用它们微调宏的展开顺序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define _CAT(x,y) x##y
#define CAT(x,y) _CAT(x,y) //典型的连接
//_e是一个单位宏，_n是一个零宏
#define b() )x(
_n(b()) //先展开_n再展开b，什么都没有了x
_e(_n _n()(b())) // =&amp;gt;_n()x() =&amp;gt; x()
//先展开b再展开_n&lt;/code&gt;&lt;p&gt;因为CPP展开_&lt;i&gt;e&lt;/i&gt;时对其括号内字符串调用展开过程（所以单位宏可以用来增加一次展开扫描过程），这个时候b会被展开，但第一个_n后面没有左括号不会展开，所以会先展开中间的_n()，下一次扫描时才第一个_n和左括号连起来被展开。&lt;/p&gt;&lt;p&gt;（是不是有些tricky？这是Lv0啦～等不及的可以自己看一下csp.h 2333如果能全部看懂帮我写文章吧qwq）&lt;/p&gt;&lt;p&gt;3) DELAY_INT_xxx(xxx_R)()(...) 这个是著名的延迟展开技巧，DELAY_INT_xxx定义如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define DELAY_REF(x) x _n()
#define DELAY_REF_2(x) x _n()
#define DELAY_INT_2(x) DELAY_REF(DELAY_REF_2)(x)
#define DELAY_INT_3(x) DELAY_REF(DELAY_INT_2)(x)
#define DELAY_INT_4(x) DELAY_REF(DELAY_INT_3)(x)
#define DELAY_INT_5(x) DELAY_REF(DELAY_INT_4)(x)
...&lt;/code&gt;&lt;p&gt;结合2）容易理解这样 DELAY_INT_n(xxx_R)() 每次扫描n会减一，直到“露出” xxx_R与后面的()结合，习惯上定义：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define xxx_R() xxx&lt;/code&gt;&lt;p&gt;这样xxx就被展开出来与参数列表结合，起到任意调节宏展开顺序的作用。&lt;/p&gt;&lt;p&gt;此外这个还被用于宏的递归。由于蓝色集合的限制，像这样的宏是不能实现递归的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define I_want_recursion(x) do_it(x) I_want_recursion(x)
I_want_recursion(x) //=&amp;gt;do_it(x) I_want_recursion(x)
//CPP认为它属于已经处理过的字符串于是就不会再展开了^
_e(I_want_recursion(x))//=&amp;gt;do_it(x) I_want_recursion(x)
//扫描多少遍都没有用！&lt;/code&gt;&lt;p&gt;但是可以这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define I_want_recursion_R() I_want_recursion
#define I_want_recursion(x) do_it(x) DELAY_REF(I_want_recursion_R)()(x)
I_want_recursion(x) //=&amp;gt;do_it(x) I_want_recursion_R()(x)
_e(I_want_recursion(x)) //=&amp;gt;do_it(x) do_it(x) I_want_recursion_R()(x)
//因为这次I_want_recursion是由I_want_recursion_R()新造出来的token所以可以继续展开下去&lt;/code&gt;&lt;p&gt;不过这样需要在外面套足够多的单位宏来进行足够次数的扫描。。。CSP中有一部分使用零点构造技术更优雅地实现了递归，将来会写的x&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这次就先写这些吧，下次写解释器A的列表操作实现和Currying？&lt;/p&gt;</description>
<author>K.Scarlet</author>
<guid isPermaLink="false">2018-03-30-35121316</guid>
<pubDate>Fri, 30 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Programming Languages: Application and Interpretation【译15中】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-30-35115633.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35115633&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b71b632ed7974538bb2e812bcd20914e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;初翻： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/9bebf466fc2535bec442451dca7cd13a&quot; data-hash=&quot;9bebf466fc2535bec442451dca7cd13a&quot; data-hovercard=&quot;p$b$9bebf466fc2535bec442451dca7cd13a&quot;&gt;@lotuc&lt;/a&gt; &lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;https://lotuc.gitbooks.io/plai-cn/content/&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;15.3 对核心的扩展&lt;/h2&gt;&lt;p&gt;现在我们已经有了基础的静态类型语言，下面探索一下如何将其扩展成为更有用的编程语言。&lt;/p&gt;&lt;h2&gt;15.3.1 显式的参数多态&lt;/h2&gt;&lt;p&gt;&lt;b&gt;下面哪些是相同的？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;(listof string)&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;事实上，上面任何两个都不太一样。但是第一个和第三个非常相似，因为第一个是Java代码而第三个是我们的静态语言代码，而第二个，是C++代码，和其它两个不同。清楚了吗？不清楚？很好，继续往下读！&lt;/p&gt;&lt;h2&gt;15.3.1.1 参数化类型&lt;/h2&gt;&lt;p&gt;我们所使用的编程语言已经展示了参数多态的价值，例如，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;函数的类型可以这样给出：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((&#39;a -&amp;gt; &#39;b) (listof &#39;a) -&amp;gt; (listof &#39;b))&lt;/code&gt;&lt;p&gt;意思是，对于任意类型&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;读入一个从&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;到&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;的函数，一个&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;的链表，生成对应的&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;的链表。这里，&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;不是具体的类型；它们是&lt;b&gt;类型变量&lt;/b&gt;（我们的术语中，这应该被称为“类型标识符”，因为它们在实例化过程中不会变化；但是我们还是使用传统术语）。&lt;/p&gt;&lt;p&gt;可以换种方式理解它：实际上有一族无穷多的这样的&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;函数。例如，其中一个&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;的类型是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((number -&amp;gt; string) (listof number) -&amp;gt; (listof string))&lt;/code&gt;&lt;p&gt;另一个的类型是这样的（没有限制说其中的类型必须是基本类型）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((number -&amp;gt; (number -&amp;gt; number)) (listof number) -&amp;gt; (listof (number -&amp;gt; number)))&lt;/code&gt;&lt;p&gt;还有这样的（也没有限制说&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;必须不同）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((string -&amp;gt; string) (listof string) -&amp;gt; (listof string))&lt;/code&gt;&lt;p&gt;以此类推。由于它们的类型不同，名字也需要不同：&lt;code class=&quot;inline&quot;&gt;map_num_str&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;map_num_num-&amp;gt;num&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;map_str_str&lt;/code&gt;等。但是这会让它们变成不同的函数，于是我们总得使用某个特定&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;，而不是直接使用比较一般的那个。&lt;/p&gt;&lt;p&gt;显然，不可能将所有这些函数放到我们的标准库中：毕竟它们有无穷多个！更好的方式是能按需获取我们需要的函数。我们的命名规则给出了一点提示：&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;接受两个&lt;b&gt;参数&lt;/b&gt;，它们都是&lt;b&gt;类型&lt;/b&gt;。给定了两个类型作为参数，我们可以得到针对特定类型的&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;函数。这种&lt;b&gt;类型的参数化&lt;/b&gt;被称为&lt;b&gt;参数多态&lt;/b&gt;。&lt;/p&gt;&lt;blockquote&gt;注意不要和对象“多态”搞混，后面会讨论它。&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;15.3.1.2 显式声明类型参数&lt;/h2&gt;&lt;p&gt;换句话说，我们相当于说&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;实际上是有四个参数的函数，其中两个是类型，另外两个是实际的值（函数和链表）。在需要显式声明类型的语言中，我们需要写成类似这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (map [a : ???] [b : ???] [f : (a -&amp;gt; b)] [l : (listof a)]) : (listof b)
  ...)&lt;/code&gt;&lt;p&gt;但是这会产生一些问题。首先，&lt;code class=&quot;inline&quot;&gt;???&lt;/code&gt;处应该填什么？它是&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;的类型。但是如果a和b本身将被&lt;b&gt;类型&lt;/b&gt;替换，那么类型的类型是什么？其次，我们真的希望每次调用map的时候传入四个参数吗？再者，我们真的希望在接收任何实际值之前先接收类型参数吗？对于这些问题的答案能延伸出关于多态类型系统巨大的讨论空间，其中的大部分我们这里将&lt;b&gt;不&lt;/b&gt;会涉及。&lt;/p&gt;&lt;blockquote&gt;推荐阅读Pierce的《Types and Programming Languages(类型和编程语言)》，获取易懂、现代的介绍。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;注意到一旦我们引入参数化，很多预期之外的代码都将被参数化。例如，考虑平平无奇的&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;函数的类型。它的类型需要基于链表中值的类型进行参数化（尽管它实际上并不依赖于这些值——稍后会解释这一点），于是每次使用&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;时都需要正确地进行类型实例化。说到这，即使用&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;创建空链表也必须类型实例化！当然，Java和C++程序员应该对这个痛点很熟悉了。&lt;/p&gt;&lt;h2&gt;15.3.1.3 一阶多态&lt;/h2&gt;&lt;p&gt;我们将只讨论这个空间中一个特别有用且易于理解的点上，也即 Standard ML 的类型系统、同时是本书使用的静态类型语言和早期版本的 &lt;br&gt;Haskell 的类型系统，有范型加成的 Java 和 C# 以及引入了模版的C++ &lt;br&gt;也差不多获得了这种类型系统的大部分能力。这类语言定义了被称为&lt;b&gt;谓词&lt;/b&gt;、&lt;b&gt;一阶&lt;/b&gt;或者叫&lt;b&gt;前缀&lt;/b&gt;多态的东西。关于上小节的问题它的答案是不填、没有、是。下面我们来探讨一下。&lt;/p&gt;&lt;p&gt;我们首先将类型的世界分成两组。第一组包含我们目前用到的静态类型语言，另外加上类型变量；它们被称为 &lt;b&gt;monotype（单型）&lt;/b&gt;。第二组包含参数化的类型，被称为 &lt;b&gt;polytype（多型）&lt;/b&gt;；按惯例它们是这样写的：&lt;code class=&quot;inline&quot;&gt;∀&lt;/code&gt;前缀，一组类型变量，再跟一个类型表达式，表达式中可以使用这些类型变量。因此，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;的类型将写作：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;∀ a, b : ((&#39;a -&amp;gt; &#39;b) (listof &#39;a) -&amp;gt; (listof &#39;b))&lt;/code&gt;&lt;p&gt;由于“&lt;code class=&quot;inline&quot;&gt;∀&lt;/code&gt;”是逻辑符号“对于所有的”的意思，于是上面的东西可以读作：“对于所有类型&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;的类型为……”。&lt;/p&gt;&lt;p&gt;在一阶多态（rank-1 polymorphism）中，类型变量只能被&lt;code class=&quot;inline&quot;&gt;monotype&lt;/code&gt;替换。（此外，它们只能被具体类型替换，否则剩下的类型变量将无法被替换掉。）因此，在类型变量参数和常规参数之间我们有了明确的界线。我们不需要为类型变量提供“类型注解”，因为我们知道它们可以是什么。这样得到的语言相对简洁，但仍提供了相当的表达能力。&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;非直谓性&lt;/b&gt;语言（&lt;a href=&quot;https://en.wikipedia.org/wiki/Impredicativity&quot;&gt;Impredicative&lt;/a&gt; language）取消了&lt;code class=&quot;inline&quot;&gt;monotype&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;polytype&lt;/code&gt;的区别，因此类型变量可以使用另一个多态类型实例化。&lt;/blockquote&gt;&lt;p&gt;注意到由于类型变量只能被&lt;code class=&quot;inline&quot;&gt;monotype&lt;/code&gt;替换，他们全相互对立。于是，类型参数可以全被提到参数表的前面。这使我们可以使用形如&lt;code class=&quot;inline&quot;&gt;∀ tv, ... : t&lt;/code&gt;的类型，其中&lt;code class=&quot;inline&quot;&gt;tv&lt;/code&gt;是类型变量，&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;monotype&lt;/code&gt;（其中可以引用这些类型变量）。此语法的意义就在这里，这也是之前称其为前缀多态的原因。而且后面也将看到这对其实现也很有用。&lt;/p&gt;&lt;h2&gt;15.3.1.4 通过去语法糖实现一阶多态解释器&lt;/h2&gt;&lt;p&gt;该特性最简单的实现就是将其视为一种去语法糖的形式：C++ 实际上就是这么做的。（具体来说，因为 C++ 有一个叫做模版的宏系统，所以使用模版，它非常巧合地达成了一阶多态。）举个例子，如果我们有一个语法形式&lt;code class=&quot;inline&quot;&gt;define-poly&lt;/code&gt;，它接收名字、类型变量和表达式。当传入类型的时候，它将表达式中对应类型变量替换为此类型，因此：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-poly (id t) (lambda ([x : t]) : t x))&lt;/code&gt;&lt;p&gt;通过将&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;定义为多态的方式定义了一个恒等（identity）函数：给&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;传入递任意具体类型，就得到一个单参数的类型为&lt;code class=&quot;inline&quot;&gt;(t -&amp;gt; t)&lt;/code&gt;的函数（其中&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;被替换）。我们可以使用各种类型实例化&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define id_num (id number))
(define id_str (id string))&lt;/code&gt;&lt;p&gt;从而获得针对这些类型的恒等函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (id_num 5) 5)
(test (id_str &quot;x&quot;)  &quot;x&quot;)&lt;/code&gt;&lt;p&gt;与之相对，像&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(id_num &quot;x&quot;)
(id_str 5)&lt;/code&gt;&lt;p&gt;这样的表达式将&lt;b&gt;不能通过类型检查&lt;/b&gt;（而不是运行时出错）。&lt;/p&gt;&lt;p&gt;如果你好奇的话，下面给出了实现。简单起见，我们假设只有一个类型参数；很容易使用&lt;code class=&quot;inline&quot;&gt;...&lt;/code&gt;实现多个参数的情形。我们不仅将&lt;code class=&quot;inline&quot;&gt;define-poly&lt;/code&gt;定义为宏，&lt;b&gt;它&lt;/b&gt;还会定义宏：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax define-poly
  (syntax-rules ()
    [(_ (name tyvar) body)
     (define-syntax (name stx)
       (syntax-case stx ()
         [(_ type)
          (with-syntax ([tyvar #&#39;type])
            #&#39;body)]))]))&lt;/code&gt;&lt;p&gt;因此，对于：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-poly (id t) (lambda ([x : t]) : t x))&lt;/code&gt;&lt;p&gt;该语言将创建名为&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的&lt;b&gt;宏&lt;/b&gt;：对应&lt;code class=&quot;inline&quot;&gt;(define-syntax (name ...) ...)&lt;/code&gt;的部分（对于这个例子，&lt;code class=&quot;inline&quot;&gt;name&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;）。&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的一个实例，如&lt;code class=&quot;inline&quot;&gt;(id number)&lt;/code&gt;，将类型变量&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;、宏里面的&lt;code class=&quot;inline&quot;&gt;typvar&lt;/code&gt;替换成给定的类型。因为要规避卫生，我们用&lt;code class=&quot;inline&quot;&gt;with-syntax&lt;/code&gt;来确保所有对于类型变量（typvar）的使用被替换为给定的类型。因此，实际效果是，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define id_num (id number))&lt;/code&gt;&lt;p&gt;被转换成了&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define id_num (lambda ([x : number]) : number x))&lt;/code&gt;&lt;p&gt;然而这种方式有两个重大局限性：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;来试试定义递归的多态函数，比如说&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;。之前我们说过，每个多态值（例如&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;）都需要类型实例化，但是为了简洁起见我们将依赖静态类型语言实现这点，而仅专注于&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;的类型参数。对应代码是：&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;(define-poly (filter t)&lt;br&gt;  (lambda ([f : (t -&amp;gt; boolean)] [l : (listof t)]) : (listof t)&lt;br&gt;    (cond&lt;br&gt;      [(empty? l) empty]&lt;br&gt;      [(cons? l) (if (f (first l))&lt;br&gt;                     (cons (first l)&lt;br&gt;                           ((filter t) f (rest l)))&lt;br&gt;                     ((filter t) f (rest l)))])))&lt;/p&gt;&lt;blockquote&gt;注意到递归的使用&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;时，必须使用恰当的类型对其实例化。&lt;/blockquote&gt;&lt;p&gt;上面的定义完全正确，只有一个问题，当我们尝试使用它时——如：&lt;/p&gt;&lt;p&gt;(define filter_num (filter number))&lt;/p&gt;&lt;blockquote&gt;DrRacket 将不会终止，更准确的说，是宏展开不会终止，因为它将不断的尝试创建&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;&lt;b&gt;代码的副本&lt;/b&gt;。不过如果用下面这种方式定义该函数，展开会终止——&lt;/blockquote&gt;&lt;p&gt;(define-poly (filter2 t)&lt;br&gt;  (letrec ([fltr&lt;br&gt;            (lambda ([f : (t -&amp;gt; boolean)] [l : (listof t)]) : (listof t)&lt;br&gt;              (cond&lt;br&gt;                [(empty? l) empty]&lt;br&gt;                [(cons? l) (if (f (first l))&lt;br&gt;                               (cons (first l) (fltr f (rest l)))&lt;br&gt;                               (fltr f (rest l)))]))])&lt;br&gt;    fltr))&lt;/p&gt;&lt;blockquote&gt;但是这给开发人员徒增了不必要的痛苦。实际上，一些模版展开程序会缓存之前展开的值，避免对于相同的参数反复生成代码。（Racket &lt;br&gt;做不到这点，因为一般来说，宏表达式可以依赖可变变量和值，甚至可以执行输入输出，因此 Racket 无法保证同样的输入表达式总是产生相同输出。）&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;考虑恒等函数的两个实例。我们无法比较&lt;code class=&quot;inline&quot;&gt;id_num&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;id_str&lt;/code&gt;，因为它们类型不同，但即使它们类型相同，使用&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;比较它们也不同：&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;(test (eq? (id number) (id number)) #f)&lt;/p&gt;&lt;blockquote&gt;这是因为对&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;每次实例化都会创建一份新的代码副本。即使使用了上面提到的优化，&lt;b&gt;同一种&lt;/b&gt;类型对应代码只有一份副本，但是不同类型的对应代码体还是会被重新生成【注释】——但这也是没必要的！例如，&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的实现的部分其实没任何东西依赖于参数的类型。实际上，&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;这一族无穷多个的函数可以共享同一个实现。简单的去语法糖策略实现不了这点。&lt;/blockquote&gt;&lt;p&gt;事实上，&lt;code class=&quot;inline&quot;&gt;C++&lt;/code&gt;模版因代码膨胀的问题而臭名昭著，这是原因之一。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;换种说法，基于去语法糖的策略本质上是使用替换的实现方式，它有着和我们之前函数调用时使用替换的方式实现相同的问题。不过，其它情况下，替换策略能达成我们关于程序行为的期望；对于多态也是一样，正如我们将看到的一样。&lt;/p&gt;&lt;p&gt;注意去语法糖策略的一个好处就是它不需要类型检查器“理解”多态。我们的核心语言仍可以是单态的（monomorphic），所有的（一阶）多态完全由宏展开处理。这提供了一种廉价的将多态添加到语言中的策略，但正如C++所示，它也引入了很大的开销。&lt;/p&gt;&lt;p&gt;最后，虽然这里我们只关注了函数，但前面的讨论同样适用于数据结构。&lt;/p&gt;&lt;h2&gt;15.3.1.5 其它实现方式&lt;/h2&gt;&lt;p&gt;有些其他实现策略不会遇到此类问题。这里我们不会深入讲解它们，但是其中一些策略的本质就是上面提到过的“缓存”方法。因为可以确定的是，对于给定的同一组类型参数，应该得到相同的实现代码，不需要对相同的类型参数实例化多次。这避免了无限循环。如果我们检查了使用特定类型实例化的代码一次，后续相同类型参数的实例化结果就无需再进行类型检查（因为它不会发生改变）。此外，我们无需保留实例化后的源码：一旦我们检查了展开后的程序，就可以将其丢弃，运行时也只需要保留一份实例化的副本。这样可以避免上述纯去语法糖策略中讨论过的所有问题，同时保留它的好处。&lt;/p&gt;&lt;p&gt;其实我们有点过分了。静态类型的好处之一就是能选择更精确的运行时表示。例如，静态类型可以告诉我们用的是数是32位的还是64位的甚至1位的（也就是布尔值）。然后编译器可以利用位的布局方式（例如，32个布尔值可以**打包*进一个32位字）为每种表示生成专用代码。因此，在对每种使用的类型进行检查之后，多态实例化程序可以跟踪函数或数据结构使用时用到的特定类型，并将这些信息提供给编译器用于代码生成。这会导致生成相关函数的若干副本，彼此都互不&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;——但这么做有充分的理由，因为它们要执行的操作的确不同，所以这是正确的。&lt;/p&gt;&lt;h2&gt;15.3.1.6 关系型参数&lt;/h2&gt;&lt;p&gt;我们还需解决关于多态的最后一个细节。&lt;/p&gt;&lt;p&gt;早先我们说过像&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;这样的函数不依赖于其参数的具体值。这一点对&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;等也成立。&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;接收一个函数作为参数，当它们要对单个元素进行操作时，实际上使用该函数进行操作，即该函数负责做出如何处理元素的决定；&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;本身只是遵从该函数参数。&lt;/p&gt;&lt;p&gt;“检验”这种情况是否属实的一种方法是，替换不同类型的值链表及对应的函数作为参数。也就是说假设两组值之间有映射关系；我们根据此关系替换链表元素和参数函数。问题是，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;的输出结果是否可以通过该关系预测？如果对于某些输入，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;的输出和关系预测的结果不同，这说明&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;肯定侦测了实际值并根据相关信息做出了处理。但事实上，这不会发生在&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;上，或者说实际上也不会发生在大多标准多态函数上。&lt;/p&gt;&lt;p&gt;遵从这类型关系准则的函数被称为&lt;b&gt;关系型参数&lt;/b&gt;（Relational Parametricity）【注释】。这是类型赋予我们的另一个非常强大的能力，因为它们告诉我们这种多态函数可以执行的操作很受限制：它们可以删除、复制或重新排列元素，但是不能考察这些元素，也不能对它们进行具体操纵。&lt;/p&gt;&lt;blockquote&gt;请参阅Wadler的《Theorems for Free!》和Reynolds的《Types, Abstraction and Parametric Polymorphism》。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;起初这听起来非常令人印象深刻（确实如此！），但细查，你可能会意识到这与经验并不一致。例如，在Java中，多态方法依然可以使用&lt;code class=&quot;inline&quot;&gt;instanceof&lt;/code&gt;在运行时检查、获得特定类型的值，并相应的改变行为。这种方法就不是关系型参数了！【注释】事实上，关系型参数也能被看作是语言弱点的一种表述：它只允许一组有限的操作。（你仍可以检查类型——但不能根据你获取的信息进行相关行动，这样检查就没有意义了。因此运行时系统如果想要模拟关系型参数，必须要移除类似&lt;code class=&quot;inline&quot;&gt;instanceof&lt;/code&gt;及它的替代行为：例如，对值进行加一操作并捕获异常以判断它是数。）然而，这是个非常优雅和令人吃惊的结果，显示了使用丰富类型系统能获得的强大程序推理能力。&lt;/p&gt;&lt;blockquote&gt;网上，你会经常发现这个属性被描述为函数不能检查其参数——这是不正确的。&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;15.3.2 类型推断&lt;/h2&gt;&lt;p&gt;手工书写每处多态类型的实例参数是一个令人沮丧的过程，很多版本的Java和C++用户可以证明这点。想象一下，每次使用&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt;时都需要传入类型参数是个什么场景！我们之所以能够避免这种命运，是因为我们的语言实现了&lt;b&gt;类型推断&lt;/b&gt;。这使我们可以编写定义：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (mapper f l)
  (cond
    [(empty? l) empty]
    [(cons? l) (cons (f (first l)) (mapper f (rest l)))]))&lt;/code&gt;&lt;p&gt;然后编程环境&lt;b&gt;自动&lt;/b&gt;声明&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; mapper
- ((&#39;a -&amp;gt; &#39;b) (listof &#39;a) -&amp;gt; (listof &#39;b))&lt;/code&gt;&lt;p&gt;它不仅是正确的类型，而且是非常一般的类型！从程序结构中派生出这种一般类型的过程感觉几乎就是魔法。我们来揭示其幕后。&lt;/p&gt;&lt;p&gt;首先，我们来了解类型推断做了什么。有些人错误的认为，有类型推断的语言无类型声明，其被类型推断取而代之了。这混淆了多个层面的东西。首先，即使在有类型推断的语言中，程序员仍被允许声明类型（并且为了文档更为清晰，通常会鼓励这样做——就像你之前被鼓励的一样）【注释】。此外，在没有这些声明的情况下，推断的实际&lt;b&gt;含义&lt;/b&gt;并不显明。&lt;/p&gt;&lt;blockquote&gt;有时（类型）推断是不可判定的，这时程序员别无选择只能声明某些类型。最后，显式的书写类型注解能够大大减少难以辨认的错误信息。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;相反，最好将底层语言看作需要完整地显式声明类型的——就如我们刚才研究的多态语言。然后我们说，在&lt;code class=&quot;inline&quot;&gt;:&lt;/code&gt;后类型注解部分可以留空，编程环境中的某个特性会为我们填充这些。（如果走得更远，我们可以丢弃&lt;code class=&quot;inline&quot;&gt;:&lt;/code&gt;及额外的修饰，它们都会被自动插入。因此，类型推断只是为用户提供的一种便利，减轻编写类型注解的负担，而底层的语言仍然是显式声明类型的。&lt;/p&gt;&lt;p&gt;我们怎么考虑类型推断做的是什么呢？假设我们有个表达式（或者程序）&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;，由显式声明类型语言书写：也就是说在任何需要类型注解的地方都有写出。现在假设我们擦除&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;中所有的类型注解，然后使用函数&lt;code class=&quot;inline&quot;&gt;infer&lt;/code&gt;将它们推断回来。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;code class=&quot;inline&quot;&gt;infer&lt;/code&gt;应该有何种属性？&lt;/blockquote&gt;&lt;p&gt;我们可以要求很多东西。其中之一为，它要产生和&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;原来恰好一样的注解。这在很多方面都是有问题的，尤其是当&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;本就不能通过类型检查的情况下，怎么能推断回它们（应该）是什么？你可能觉得这是个学究式的玩笑：毕竟，如果&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;本就不能通过类型检查，如果能在删除其注解之后还能还原回来呢？反正两者都不能通过类型检查，谁在乎啊？&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;这个推理正确吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;假设&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(lambda ([x : number]) : string x)&lt;/code&gt;&lt;p&gt;它显然不能通过类型检查。但是如果我们擦除类型注解——得到&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(lambda (x) x)&lt;/code&gt;&lt;p&gt;——这个函数显然可以合法地添加类型！因此，更合理的需求可以是，如果原始的&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;能通过类型检查，那么对应的使用了推导出的注解的版本也必须能。这种单向的含义的用途体现在两方面：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;它没有说&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;未通过类型检查应该怎样，也即它不会排除前述的类型推断算法，其会将例子中类型错误的恒等函数变成类型正确的。&lt;/li&gt;&lt;li&gt;更重要的是，它向我们保证，使用类型推断将不会使我们失去任何东西：之前能通过类型检测的程序不会被推断后而不能。这意味着我们可以在想要的地方显式添加类型注解，但不会被迫这样做。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;当然，这只在程序推断可判定的情况下才成立。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;我们还可能希望两者类型是相同的，但这不是能做到的：函数&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(lambda ([x : number]) : number x)&lt;/code&gt;&lt;p&gt;类型为&lt;code class=&quot;inline&quot;&gt;(number -&amp;gt; number)&lt;/code&gt;，而擦除类型注解后推导出的类型要一般得多。因此，将这些类型关联并给出类型相等的定义并不简单，尽管如此后面将简要讨论此问题。&lt;/p&gt;&lt;p&gt;有了这些准备，我们下面进入对类型推断机制的研究。最需要注意的地方，前述的简单递归下降的类型检查算法将不再起作用。它之前能起作用，是因为所有函数的边界处都有类型注解，所以我们下降进入函数体，同时用类型环境携带这些注解中包含的信息。没了这些注解，就不知如何递归下降了。&lt;/p&gt;&lt;p&gt;事实上，目前还不清楚哪个方向更合理。像上面&lt;code class=&quot;inline&quot;&gt;mapper&lt;/code&gt;的定义，各代码段之间互相影响。例如，从&lt;code class=&quot;inline&quot;&gt;empty?&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;cons?&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt;对&lt;code class=&quot;inline&quot;&gt;l&lt;/code&gt;的调用都可以看出它是链表。但是是什么的链表呢？从这些操作看不出来。然而，对于其每个（或者应该说，任意）&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;元素调用了&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;这点可以看出，链表成员的类型必须可以被传给&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;。同理，由&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;我们可以知道（&lt;code class=&quot;inline&quot;&gt;mapper&lt;/code&gt;的）返回表达式必须为链表。它的成员类型是什么呢？必须为&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的返回类型。最后，请注意最微妙的地方：当参数链表为空时，我们返回&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;而不是&lt;code class=&quot;inline&quot;&gt;l&lt;/code&gt;（这时我们是知道其被绑定到&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;）。使用前者，返回值的类型可能是任意类型的链表（仅受&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;返回类型的约束）；使用后者，返回的类型就被迫和参数链表的类型相同。&lt;/p&gt;&lt;p&gt;所有这些信息都包含在函数里。但是我们如何系统地提取出这些信息呢，而且使用的算法必须会终止，并满足前面陈述属性？我们分两步来做。首先，根据程序表达式&lt;b&gt;生成&lt;/b&gt;其必须要满足的类型&lt;b&gt;约束&lt;/b&gt;。然后，通过合并散布在函数体各处的约束、识别其中的不一致，最终&lt;b&gt;解决约束&lt;/b&gt;。每一步都相对简单，但是组合起来创造了魔力。&lt;/p&gt;&lt;h2&gt;15.3.2.1 约束生成&lt;/h2&gt;&lt;p&gt;我们最终的目标是给每个类型注解位置填入类型。将会证明，这也等同于找到每个&lt;b&gt;表达式&lt;/b&gt;的类型。简单想想就知道，这本来也是必要的：比如，在不知道函数体类型的情况下，如何能确定函数本身的类型？这也是足够的，因为如果每个表达式的类型都被计算得出，其中必然包括了那些需要被注解的表达式。&lt;/p&gt;&lt;p&gt;首先，我们需要生成（待解决的）约束。这一步会遍历程序源码，为每个表达式生成恰当的约束，最后返回这组约束。为了简单，使用递归下降的方式实现；它最终生成约束的&lt;b&gt;集合&lt;/b&gt;，所以原则上遍历和生成的顺序是无关紧要的——因此我们选择了相对简单的递归下降方式——当然，为了简单起见，我们使用链表表示这个集合。&lt;/p&gt;&lt;p&gt;约束是什么呢？就是关于表达式类型的陈述。此外，虽然变量绑定并不是表达式，但我们仍需计算其类型（因为函数需要参数和返回值类型）。一般来说，对于表达式的类型我们知道些什么呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;它和某些标识符的类型有关。&lt;/li&gt;&lt;li&gt;它和某些其它表达式的类型有关。&lt;/li&gt;&lt;li&gt;它是数。&lt;/li&gt;&lt;li&gt;它是函数，其定义域（domain）和值域（range）类型可能受到进一步的约束。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;因此，我们定义如下两个数据结构：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type Constraints
  [eqCon (lhs : Term) (rhs : Term)])

(define-type Term
  [tExp (e : ExprC)]
  [tVar (s : symbol)]
  [tNum]
  [tArrow (dom : Term) (rng : Term)])&lt;/code&gt;&lt;p&gt;接下来定义约束生成函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen&amp;gt; ::= ;约束生成

    (define (cg [e : ExprC]) : (listof Constraints)
      (type-case ExprC e
        &amp;lt;constr-gen-numC-case&amp;gt;
        &amp;lt;constr-gen-idC-case&amp;gt;
        &amp;lt;constr-gen-plusC/multC-case&amp;gt;
        &amp;lt;constr-gen-appC-case&amp;gt;
        &amp;lt;constr-gen-lamC-case&amp;gt;))&lt;/code&gt;&lt;p&gt;当表达式为数时，唯一能说的是，我们希望该表达式的类型为数类型：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-numC-case&amp;gt; ::=

    [numC (_) (list (eqCon (tExp e) (tNum)))]&lt;/code&gt;&lt;p&gt;听上去很微不足道，但我们不知道的是，其他包含它的表达式是什么。因此，某个更大的表达式可能会与此断言——这个表达式的类型必须是数型——相矛盾，从而导致类型错误。&lt;/p&gt;&lt;p&gt;对于标识符，我们只是简单地说，表达式的类型就是我们所期望该标识符应有的类型：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-idC-case&amp;gt; ::=

    [idC (s) (list (eqCon (tExp e) (tVar s)))]&lt;/code&gt;&lt;p&gt;如果上下文限制了其类型，该表达式的类型将自动受到限制，并且必须与上下文的期望一致。&lt;/p&gt;&lt;p&gt;加法是我们第一个遇到的上下文约束。对于加法表达式，首先需要确保我们生成（并返回）其两个子表达式的约束，而子表达式可以是复杂的。这两个约束中，我们期望什么？需要每个子表达式是数类型的。（如果其中一个子表达式不是数类型的，应该导致类型错误。）最后，我们断言整个表达式的类型为数。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-plusC/multC-case&amp;gt; ::=

    [plusC (l r) (append3 (cg l)
                          (cg r)
                          (list (eqCon (tExp l) (tNum))
                                (eqCon (tExp r) (tNum))
                                (eqCon (tExp e) (tNum))))]&lt;/code&gt;&lt;blockquote&gt;&lt;code class=&quot;inline&quot;&gt;append3&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;append&lt;/code&gt;的三参数版本。&lt;/blockquote&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;multC&lt;/code&gt;的情况与之相同，区别只在名字上。&lt;/p&gt;&lt;p&gt;下面我们来看另外两个有趣的情况，函数声明和调用。两种情况下我们都需要生成和返回子表达式的约束。&lt;/p&gt;&lt;p&gt;在函数定义中，函数的类型是函数（“箭头/arrow”）类型，其参数类型是形参的类型，其返回类型是函数体的类型。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-lamC-case&amp;gt; ::=

    [lamC (a b) (append (cg b)
                        (list (eqCon (tExp e) (tArrow (tVar a) (tExp b)))))]&lt;/code&gt;&lt;p&gt;最终，考虑函数调用。我们不能直接陈述函数调用的类型约束。不过，我们可以说，函数接受的参数类型必须和实际参数的类型相同，并且函数返回的类型就是调用表达式的类型。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-appC-case&amp;gt; ::=

    [appC (f a) (append3 (cg f)
                         (cg a)
                         (list (eqCon (tExp f) (tArrow (tExp a) (tExp e)))))]&lt;/code&gt;&lt;p&gt;完成了！我们已经完成约束的生成；现在只需解出它们。&lt;/p&gt;&lt;h2&gt;15.3.2.2 使用合一求解约束&lt;/h2&gt;&lt;p&gt;求解约束的过程也被称为&lt;b&gt;合一&lt;/b&gt;（unification）。合一器的输入是等式的集合，其中每个等式是变量到项（term）的映射，项的数据类型在上面定义了。注意到一点，我们实际上有&lt;b&gt;两&lt;/b&gt;种变量。&lt;code class=&quot;inline&quot;&gt;tvar&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;tExp&lt;/code&gt;都是“变量”，前者很明显，注意后者同样也是，因为我们需要求解此类表达式的类型。（另一种方式是为每个表达式引入新的类型变量，但我们仍需一种方法确定这些变量与表达式之间的对应关系，而现在这已经能通过对表达式进行&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;操作自动完成了。另外这会产生大得多的约束集，不好进行人工检查。）&lt;/p&gt;&lt;p&gt;就我们的目的而言，合一是为了是生成&lt;b&gt;替换&lt;/b&gt;（substitution），或者说将变量映射为不包含任何变量的项。这听起来应该很耳熟：我们有一组联立方程，其中每个变量都是线性使用的；这种方程组可以使用&lt;b&gt;高斯消元法&lt;/b&gt;求解。该情形中，我们清楚最终可能遇到缺少约束（under-constrained）或过度约束（over-constrained）的情况。这种事情同样也将发生这里。&lt;/p&gt;&lt;p&gt;合一算法会遍历约束集合。由于每个约束有两项，每个项有四种可能的类型，因此有十六种情况需要考虑。幸运的是，我们实际可以用比较少的代码覆盖这十六种情况。&lt;/p&gt;&lt;p&gt;算法从所有约束的集合和空替换开始。每个约束都会被处理一次，并从集合中删除，因此原则上终止判据应该非常简单，但是实际处理起来还有点小麻烦。随着约束被处理，替换集合会逐渐增长。当所有的约束都被处理完后，合一过程返回最后的替换集合。&lt;/p&gt;&lt;p&gt;对于给定的约束，合一器检查等式左边，如果它是变量，那么这时它就可以被消除了，合一器将该变量（等式）的右侧添加到替换中，为了真正完成消除，还需要将替换集中所有该变量的出现替换成该右侧。实践中，实现需要考虑效率；例如，使用可变值表示这些变量可以避免搜索—替换过程。然而我们可能需要进行回溯（我们在后面确实会需要），可变值表示也有缺点。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;注意到上面微妙的错误了吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;这个微妙的错误是，我们说合一器通过替换变量的所有实例来&lt;b&gt;消除&lt;/b&gt;它。不过，我们假设等式右侧不包含该变量的实例。不然的话，我们将得到循环定义，这将使替换变得不可能。出于这个原因，合一器会进行&lt;b&gt;出现检查&lt;/b&gt;（occurs check）：检查某个变量是否出现在等式两侧，如果是，则拒绝合一。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;构造一个其约束会触发出现检查的项。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;还记得&lt;code class=&quot;inline&quot;&gt;ω&lt;/code&gt;吗？&lt;/p&gt;&lt;p&gt;下面考虑合一的实现。惯例使用希腊字母&lt;code class=&quot;inline&quot;&gt;Θ&lt;/code&gt;表示替换。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type-alias Subst (listof Substitution))
(define-type Substitution
  [sub [var : Term] [is : Term]])

(define (unify [cs : (listof Constraints)]) : Subst
  (unify/Θ cs empty))&lt;/code&gt;&lt;p&gt;首先把简单的东西写出来：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ&amp;gt; ::=

    (define (unify/Θ [cs : (listof Constraints)] [Θ : Subst]) : Subst
      (cond
        [(empty? cs) Θ]
        [(cons? cs)
         (let ([l (eqCon-lhs (first cs))]
               [r (eqCon-rhs (first cs))])
           (type-case Term l
             &amp;lt;unify/Θ-tVar-case&amp;gt;
             &amp;lt;unify/Θ-tExp-case&amp;gt;
             &amp;lt;unify/Θ-tNum-case&amp;gt;
             &amp;lt;unify/Θ-tArrow-case&amp;gt;))]))&lt;/code&gt;&lt;p&gt;现在可以实现合一的核心了。我们需要一个辅助函数&lt;code class=&quot;inline&quot;&gt;extend-replace&lt;/code&gt;，其签名为&lt;code class=&quot;inline&quot;&gt;(Term Term Subst -&amp;gt; Subst)&lt;/code&gt;。它将执行出现检查，如果检查得出没有环路，则扩展替换集合，并将替换集合中所有出现的第一个项（第一个参数）替代为第二个项（第二个参数）。同样，我们假设&lt;code class=&quot;inline&quot;&gt;lookup: (Term subst -&amp;gt; (optionof Term))&lt;/code&gt;存在。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;定义&lt;code class=&quot;inline&quot;&gt;extend-replace&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;lookup&lt;/code&gt;。&lt;/blockquote&gt;&lt;p&gt;如果约束等式的左侧是个变量，我们先在替换集合中寻找它。如果存在，我们将当前约束换成新的约束；否则我们扩展替换集合。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ-tVar-case&amp;gt; ::=

    [tVar (s) (type-case (optionof Term) (lookup l Θ)
                [some (bound)
                      (unify/Θ (cons (eqCon bound r)
                                     (rest cs))
                               Θ)]
                [none ()
                      (unify/Θ (rest cs)
                               (extend+replace l r Θ))])]&lt;/code&gt;&lt;p&gt;同样的逻辑也适用于表达式的情况：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ-tExp-case&amp;gt; ::=

    [tExp (e) (type-case (optionof Term) (lookup l Θ)
                [some (bound)
                      (unify/Θ (cons (eqCon bound r)
                                     (rest cs))
                               Θ)]
                [none ()
                      (unify/Θ (rest cs)
                               (extend+replace l r Θ))])]&lt;/code&gt;&lt;p&gt;如果是基本类型，例如数，我们就需要检查等式右边。有四种可能：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果是数，那么该等式声明类型&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;等于&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;，这恒为真。因此我们可以忽略该约束——它没有告诉我们什么有用信息——继续检查剩下的。&lt;br&gt;当然，首先得解释为什么会出现这种约束。显然，我们的约束生成器不会生成这种约束。然而，前面替换集合的扩展会导致这种情况。事实是实践中我们会遇到好几个这种情况。&lt;/li&gt;&lt;li&gt;如果是函数类型，显然存在类型错误，因为数和函数类型不相交。同样，我们不会直接生成这样的约束，一定是由先前的替代产生。&lt;/li&gt;&lt;li&gt;它可能是两种变量类型之一。不过，我们的约束生成器经过了仔细的安排，不会将它们放在右侧。此外，替代过程也不会在右侧引入它们。因此，这两种情况不会发生。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;于是得出这样的代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ-tNum-case&amp;gt; ::=

    [tNum () (type-case Term r
               [tNum () (unify/Θ (rest cs) Θ)]
               [else (error &#39;unify &quot;number and something else&quot;)])]&lt;/code&gt;&lt;p&gt;最后还剩下函数类型。这里的论点几乎和数类型完全一样。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ-tArrow-case&amp;gt; ::=

    [tArrow (d r) (type-case Term r
                    [tArrow (d2 r2)
                            (unify/Θ (cons (eqCon d d2)
                                           (cons (eqCon r r2)
                                                 cs))
                                     Θ)]
                    [else (error &#39;unify &quot;arrow and something else&quot;)])]&lt;/code&gt;&lt;p&gt;请注意，我们并没有严格地缩小约束集合，因此仅通过约束集合的大小不足以判断这个过程会终止。需要同时综合考虑约束集合的大小以及替换的大小（包括其中变量的个数）。&lt;/p&gt;&lt;p&gt;上面的算法非常通用，不仅对数和函数，对于各种类型项也都适用。我们使用数代表各种基础类型；同样，使用函数代表各种构造类型，例如&lt;code class=&quot;inline&quot;&gt;listof&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;vectorof&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这就完成了。合一产生了替换。现在我们可以遍历这些替换，找到程序中所有表达式的类型，然后插入对应的类型注解。有定理（这里不证明）指出，上面过程的成功意味着程序通过了类型检查，因此我们无需对该程序显式地再跑一遍类型检查。&lt;/p&gt;&lt;p&gt;不过请注意，类型错误的性质在这里发生了巨大变化。之前，我们的递归下降算法利用类型环境遍历表达式。类型环境中的绑定是程序员定义的类型，因此可以被当作（期望的）权威的类型&lt;b&gt;规范&lt;/b&gt;（specification）。因此，所有的错误都应归咎于表达式，类型错误的报告很简单（而且很好懂）。然而这里，类型错误&lt;b&gt;无法通知&lt;/b&gt;。合一错误是两个智能算法——约束生成和合一——共同导致的，因此程序员不一定能理解。特别是，由于约束的本质是等式，报告的错误位置和“真实”的错误位置可能相差甚远。因此，生成更好的错误信息仍然是个活跃的研究领域。&lt;/p&gt;&lt;blockquote&gt;实践中，算法会维护涉及到的程序源码的元信息，并可能也会保存合一的历史，以便溯源错误回源程序。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;最后，请记住，约束可能不会精确指明所有变量的类型。如果方程组&lt;b&gt;过度&lt;/b&gt;约束，可能会有冲突，导致类型错误。如果&lt;b&gt;缺少&lt;/b&gt;约束，这意味着我们没有足够的信息对所有表达式做出明确的类型声明。例如，对于表达式&lt;code class=&quot;inline&quot;&gt;(lambda (x) x)&lt;/code&gt;，没有足够的约束指明&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型，从而无法以指明整个表达式的类型。这并非错误；它只是意味着&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;可以是&lt;b&gt;任意&lt;/b&gt;类型。换句话说，该表达式的类型是“&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型-&amp;gt;&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型”，无其它约束。这些欠约束标识符的类型以类型变量的方式展示，于是上面表达式的类型可以表示为&lt;code class=&quot;inline&quot;&gt;(&#39;a -&amp;gt; &#39;a)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;合一算法实际上有个很好的属性：它能自动计算表达式&lt;b&gt;最通用的类型&lt;/b&gt;，也被称为&lt;b&gt;主类型&lt;/b&gt;（principal type）。这就是说，表达式可以有的任何实际类型都可以通过（用实际类型）替换推导出的类型中的类型变量的得到。这是个异乎寻常的结果：没人能生成比前述算法得出的更为一般的类型！&lt;/p&gt;&lt;h2&gt;15.3.2.3 Let-多态&lt;/h2&gt;&lt;p&gt;很不幸，尽管这些类型变量表面上看和我们之前遇到的多态有诸多相似之处，但它们并不同。考虑下面的程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(let ([id (lambda (x) x)])
  (if (id true)
      (id 5)
      (id 6)))&lt;/code&gt;&lt;p&gt;如果加上显式的类型注解，它能通过类型检查：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(if ((id boolean) true)
    ((id number) 5)
    ((id number) 6))&lt;/code&gt;&lt;p&gt;然而，如果使用类型推断，它将不能通过类型检查！因为&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;中的类型&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;——取决于约束处理的顺序——要么和&lt;code class=&quot;inline&quot;&gt;boolean&lt;/code&gt;合一，要么和&lt;code class=&quot;inline&quot;&gt;number&lt;/code&gt;合一。对应的，那时&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的类型要么是&lt;code class=&quot;inline&quot;&gt;(boolean -&amp;gt; boolean)&lt;/code&gt;要么是&lt;code class=&quot;inline&quot;&gt;(number -&amp;gt; number)&lt;/code&gt;。当使用另一个类型调用&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;时，就会发生类型错误！&lt;/p&gt;&lt;p&gt;这是因为我们通过合一推断出来的类型实际并不是&lt;b&gt;多态的&lt;/b&gt;。这点很重要：将其称为类型变量不会使你获得多态!类型变量可以在下次使用时合一，彼时，最终得到的还只是单态函数。而真正的多态只有在能真正进行类型变量&lt;b&gt;实例化&lt;/b&gt;时才会获得。&lt;/p&gt;&lt;p&gt;所以在具有真正多态的语言中，约束生成和合一是不够的。相反，像ML和Haskell这种语言，甚至我们使用的静态类型语言也是，都实现了俗称&lt;b&gt;let-多态&lt;/b&gt;的东西。这种策略中，当包含类型变量的项在词法环境中被绑定时，该类型被自动提升为量化类型。每次使用时，该项被自动实例化。&lt;/p&gt;&lt;p&gt;很多实现策略可以做到这点。最简单（而不令人满意）的方式只需&lt;b&gt;复制&lt;/b&gt;绑定标识符代码的&lt;b&gt;代码&lt;/b&gt;；这样，上面每次&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的使用都会得到自己的&lt;code class=&quot;inline&quot;&gt;(lambda (x) x)&lt;/code&gt;副本，所以每个都有它自己的类型变量。第一个的类型可能是&lt;code class=&quot;inline&quot;&gt;(&#39;a -&amp;gt; &#39;a)&lt;/code&gt;，第二个是&lt;code class=&quot;inline&quot;&gt;(&#39;b -&amp;gt; &#39;b)&lt;/code&gt;，第三个是&lt;code class=&quot;inline&quot;&gt;(&#39;c -&amp;gt; &#39;c)&lt;/code&gt;，等等。这些类型变量互不冲突，因此我们得到多态的效果。显然，这不仅增加了程序的大小，而且在存在递归的情况下也不起作用。然而，这给我们提供了通往更好解决方案的思路：不是复制代码，而是复制&lt;b&gt;类型&lt;/b&gt;。因此在每次使用时，我们创建推导出类型的重命名版本：第一次使用时，id的类型&lt;code class=&quot;inline&quot;&gt;(&#39;a -&amp;gt; &#39;a)&lt;/code&gt;变成了&lt;code class=&quot;inline&quot;&gt;(&#39;b -&amp;gt; &#39;b)&lt;/code&gt;，以此类推，这种方式实现了拷贝代码相同的效果且没有它的包袱。不过，因为这些策略实质都是效仿代码拷贝，因此它们只能在词法环境下工作。&lt;/p&gt;</description>
<author>MrMathematica</author>
<guid isPermaLink="false">2018-03-30-35115633</guid>
<pubDate>Fri, 30 Mar 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
