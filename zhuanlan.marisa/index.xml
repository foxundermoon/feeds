<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Mon, 23 Jul 2018 18:40:37 +0800</lastBuildDate>
<item>
<title>Contravariant Functors</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-07-21-40272611.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40272611&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5c90cc84819d9084f9b13fc09bd6abf2_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;a href=&quot;https://youtu.be/IJ_bVVsQhvc&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;George Wilson - Contravariant Functors: The Other Side of the Coin (youtube)&lt;/a&gt;&lt;p&gt;吃外卖的时候看的, 不长又欢乐的一个 talk.&lt;/p&gt;&lt;p&gt;从 Contravariant 的  Functor 开始介绍它的 Applicative , Alternative 版: Divisible 和 Decidable.&lt;/p&gt;&lt;p&gt;一开始拿 predicate 作为 Contravariant 的例子,  自嘲 so boring 之后换 pretty printer 作为例子最后总结出:&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e31336410b2e758342acc23eaedc4c23_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1396&quot; data-rawheight=&quot;780&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e31336410b2e758342acc23eaedc4c23&quot; data-watermark-src=&quot;v2-b4b6daa28d4c5aaee30d9f7cca8d7d8a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt; Applicative, Alternative 一个比较 practical 的例子是 async 里的 &lt;a href=&quot;https://hackage.haskell.org/package/async/docs/Control-Concurrent-Async.html#t:Concurrently&quot;&gt;Concurrently&lt;/a&gt;, 当 fork 出多个 “线程” 一起计算结果的时候, 所有结果都要就是 applicative, 只需要其中一个就是 alternative (how to combine multiple results). 另外的例子可以看 Parser Combinator (Parser Combinator 真是万能的例子&lt;/p&gt;&lt;p&gt;Contravariant, Divisible, Decidable 的中缀运算符设计得也特别有意思, 就是把&quot;&amp;lt;&amp;gt;&quot;到过来变&quot;&amp;gt;&amp;lt;&quot;, Haskell 里的运算符设计还是有点规律的不是鬼画符  XD&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;BTW, 这个 talk 很好地展现用 Haskell 的语言特性&amp;lt;del&amp;gt;猫论&amp;lt;/del&amp;gt;做抽象吸引我的一面:&lt;/p&gt;&lt;p&gt;type class hierarchy 就是个做抽象跟复用的地图: 当发现一个东西是 Functor 的时候就会想这货有没有可能也是一个 Applicative/Alternative ? 如果是, 这个 “computation”(type class) 在这个 context 下代表什么操作? 更进一步如果是 Applicative 的话, 有没有可能是 Monad? 这个 talk QA部分就有人问是不是 Monad, George 小哥早就准备好了答案 XD.&lt;/p&gt;&lt;p&gt;而且这种抽象和复用不像一些&quot;设计模式&quot;一样, 只能靠例子和自然语言来描述, 它们是有 law 的, talk 里每次提到 law 大家都会欢呼一下 XD&lt;/p&gt;&lt;p&gt;这些抽象的关系有时候就调换个参数(Contravariant), 反转个箭头(monad -&amp;gt; comonad), uncurry 一下 (学 Haskell 真不需要懂多少猫论的, 会看类型签名就好&lt;/p&gt;&lt;p&gt;当然了 &lt;a href=&quot;http://hackage.haskell.org/package/contravariant&quot;&gt;contravariant&lt;/a&gt; 这个库的作者依旧是神奇的 Edward Kmett, 如果想知道更多 Functor 请看依旧是 George Wilson 小哥去年同样在 YOW! Lambda Jam 的 &lt;a href=&quot;https://youtu.be/JUVMiRRq6wU&quot;&gt;The Extended Functor Family&lt;/a&gt;, 当然了里面提到的库都是 Edward Kmett 写的. George Wilson 的 talk 都好赞, 写的库也是.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;(别看到 Haskell 就 BB Monad 了, 还有很多可以 BB 是不是 &lt;/p&gt;</description>
<author>祖与占</author>
<guid isPermaLink="false">2018-07-21-40272611</guid>
<pubDate>Sat, 21 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Safety and Liveness Properties</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-07-15-37864854.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37864854&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在程序运行时, 我们会特别在意程序的一些性质(Program properties), 例如程序正确, 程序停机, 无异常等等. 对于我们关心的程序性质, 将可以分为两类:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;Safety Properties&lt;/b&gt;, 在程序运行中不会进入非预期的状态(如非法调用参数, 数组下标越界等运行错误).&lt;/li&gt;&lt;li&gt;&lt;b&gt;Liveness Properties&lt;/b&gt;, 在程序运行中预期状态一定会到达(如停机, 获取资源请求一定有返回结果等等).&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面将介绍程序性质的拓扑结构, 最后展示对于任意程序性质, 均可将其分解为其Safety分量(safety component)与Liveness分量(liveness component)的交.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义1: 转移系统(transition system)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;转移系统由一个状态集合 &lt;equation&gt;\Sigma&lt;/equation&gt; 与转移关系 &lt;equation&gt;\to\subseteq\Sigma\times\Sigma&lt;/equation&gt; 构成, 形如 &lt;equation&gt;\langle\Sigma,\to\rangle&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;其中状态表示程序执行的当前状态, 一般由当前执行程序位置(指令指针)与程序符号值(内存空间)构成. 转移关系由程序语义定义.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义2: 轨迹(trace)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\Sigma^{*} = \bigcup_{k=0}^{}\Sigma^{k}\\ &amp;amp;\Sigma^{\overrightarrow{*}} = \left\{ \sigma=(\sigma_1\sigma_2\cdots\sigma_k)\in \Sigma^{*}\;|\;\forall i&amp;lt;|\sigma|:\sigma_i \to\sigma_{i+1}\right\} \\ &amp;amp;\Sigma^{\overrightarrow{\omega}} = \left\{ \sigma=(\sigma_1\sigma_2\sigma_3\cdots)\in \Sigma^{\omega}\;|\;\forall i:\sigma_i \to\sigma_{i+1}\right\}\\ &amp;amp;\Sigma^{\overrightarrow{\infty}} = \Sigma^{\overrightarrow{*}}\cup\Sigma^{\overrightarrow{\omega}} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;( &lt;equation&gt;|\sigma|&lt;/equation&gt; 为 &lt;equation&gt;\sigma&lt;/equation&gt; 的长度)&lt;/p&gt;&lt;p&gt;显然 &lt;equation&gt;\Sigma^{\overrightarrow{*}}\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , 其中 &lt;equation&gt;\sigma\in\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 称为trace.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义3: 拼接(concatenation), 前缀(prefix), 后缀(suffix), 拓展(extension)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对于 &lt;equation&gt;u=(u_1\cdots u_n)\in\Sigma^{\overrightarrow{*}}&lt;/equation&gt; , &lt;equation&gt;v=(v_1,v_2\cdots)\in\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , &lt;equation&gt;u_{n}\to v_1&lt;/equation&gt;, 记&lt;equation&gt;uv=(u_1\cdots u_n,v_1,v_2\cdots)&lt;/equation&gt; 为 &lt;equation&gt;u&lt;/equation&gt; 与 &lt;equation&gt;v&lt;/equation&gt; 的拼接.&lt;/p&gt;&lt;p&gt;对于 &lt;equation&gt;U, V\subseteq \Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , 记 &lt;equation&gt;UV=\left\{ uv\;|\;u\in U,v\in V \right\}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;若 &lt;equation&gt;\exists v:uv=w &lt;/equation&gt; 则称 &lt;equation&gt;u&lt;/equation&gt; 为 &lt;equation&gt;w&lt;/equation&gt; 的前缀, &lt;equation&gt;v&lt;/equation&gt; 为 &lt;equation&gt;w&lt;/equation&gt; 的后缀, 记作 &lt;equation&gt;u\preceq w&lt;/equation&gt; , 称 &lt;equation&gt;w&lt;/equation&gt; 为 &lt;equation&gt;u&lt;/equation&gt; 的拓展, 记作 &lt;equation&gt;w\succeq u&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;空串为 &lt;equation&gt;\epsilon&lt;/equation&gt; , 其中有 &lt;equation&gt;|\varepsilon|=0&lt;/equation&gt; , &lt;equation&gt;\epsilon\sigma=\sigma\epsilon=\sigma&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义4: Prefix与Extension Closed&lt;/b&gt;&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; &lt;/p&gt;&lt;ul&gt;&lt;li&gt;若 &lt;equation&gt;\forall u\preceq v\in V&lt;/equation&gt; 有 &lt;equation&gt;u\in V&lt;/equation&gt; , 则称 &lt;equation&gt;V&lt;/equation&gt; 为prefix closed.&lt;/li&gt;&lt;li&gt;若 &lt;equation&gt;\forall w\succeq v\in V&lt;/equation&gt; 有 &lt;equation&gt;w\in V&lt;/equation&gt; , 则称 &lt;equation&gt;V&lt;/equation&gt; 为extension closed.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义5: Limit Closed与Finite Witnesses&lt;/b&gt;&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;若 &lt;equation&gt;\forall w\in \Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , 对于任意有限长度 &lt;equation&gt;u\preceq w&lt;/equation&gt; 均满足 &lt;equation&gt;u\in V&lt;/equation&gt; 那么有 &lt;equation&gt;w\in V&lt;/equation&gt; , 则称 &lt;equation&gt;V&lt;/equation&gt; 为limit closed.&lt;/li&gt;&lt;li&gt;若 &lt;equation&gt;\forall w\in V&lt;/equation&gt; , 存在有限长度 &lt;equation&gt;u\preceq w&lt;/equation&gt; 使得 &lt;equation&gt;u\in V&lt;/equation&gt; , 则称 &lt;equation&gt;V&lt;/equation&gt; 为finite witnesses.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;命题1:&lt;/b&gt; &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 为prefix closed(extension closed)集, 则&lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为extension closed(prefix closed)集.&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;若 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为非extension closed集, 则 &lt;equation&gt;\exists w\succeq v\in \Sigma^{\overrightarrow{\infty}}\setminus V: w\not\in \Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 即 &lt;equation&gt;w\in V&lt;/equation&gt; . 因为 &lt;equation&gt;V&lt;/equation&gt; 为prefix closed, 故 &lt;equation&gt;w\succeq v\in V&lt;/equation&gt; . 矛盾, 故 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为extension closed集.&lt;/p&gt;&lt;p&gt;类似地, 若 &lt;equation&gt;V&lt;/equation&gt; 为extension closed集, 则&lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为prefix closed集.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;命题2:&lt;/b&gt; &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 为limit closed(finite witnesses)集, 则&lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为finite witnesses(limit closed)集.&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;若 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为非finite witnesses集, 则 &lt;equation&gt;\exists w\in \Sigma^{\overrightarrow{\infty}}\setminus V: \forall u\preceq w: u\not\in \Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; ( &lt;equation&gt;u&lt;/equation&gt; 长度有限) 即 &lt;equation&gt;\forall u\preceq w: u\in V&lt;/equation&gt; . 因为 &lt;equation&gt;V&lt;/equation&gt; 为limit closed, 故 &lt;equation&gt;w\in V&lt;/equation&gt; . 矛盾, 故 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为finite witnesses集.&lt;/p&gt;&lt;p&gt;类似地, 若 &lt;equation&gt;V&lt;/equation&gt; 为finite witnesses集, 则&lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为limit closed集.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义6: Topology space on &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; :  &lt;equation&gt;(\Sigma^{\overrightarrow{\infty}}, \tau)&lt;/equation&gt;&lt;/b&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;\tau&lt;/equation&gt; 为开集族(open sets), &lt;equation&gt;\tau = \left\{ W\Sigma^{\overrightarrow{\infty}}\;|\;W\subseteq\Sigma^{\overrightarrow{*}}\right\}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;命题3:&lt;/b&gt; &lt;equation&gt;\tau&lt;/equation&gt; 为开集族&lt;/p&gt;&lt;p&gt;证明: &lt;/p&gt;&lt;p&gt;• &lt;equation&gt;\emptyset=W\Sigma^{\overrightarrow{\infty}}\in\tau&lt;/equation&gt; , 其中 &lt;equation&gt;W=\emptyset&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;• &lt;equation&gt;\Sigma^{\infty}=W\Sigma^{\overrightarrow{\infty}}\in\tau&lt;/equation&gt; , 其中 &lt;equation&gt;W=\{\epsilon\}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;• &lt;equation&gt;W_{\alpha}\subseteq\Sigma^{\overrightarrow{*}}&lt;/equation&gt; , &lt;equation&gt;\alpha\in I&lt;/equation&gt; , 有 &lt;equation&gt;\bigcup_{\alpha\in I}^{}(W_{\alpha}\Sigma^{\overrightarrow{\infty}})=W\Sigma^{\overrightarrow{\infty}}\in\tau&lt;/equation&gt; , 其中 &lt;equation&gt;W=\left( \bigcup_{\alpha\in I}^{}W_{\alpha} \right)\subseteq\Sigma^{\overrightarrow{*}}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;• &lt;equation&gt;U, V\subseteq \Sigma^{\overrightarrow{*}}&lt;/equation&gt; , 定义 &lt;equation&gt;U_{V}=\{u\in U\;|\;\exists v\in V: v\preceq u\}\subseteq U&lt;/equation&gt; , 类似地定义 &lt;equation&gt;V_{U}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;w\in U\Sigma^{\overrightarrow{\infty}}\cap V\Sigma^{\overrightarrow{\infty}}\\ \Leftrightarrow\;&amp;amp;\exists u\in U, v\in V: x, y\in \Sigma^{\overrightarrow{\infty}}, w=ux=vy\\ \Leftrightarrow\;&amp;amp;w\in V_U\Sigma^{\overrightarrow{\infty}}\;\text{or}\;w\in U_V\Sigma^{\overrightarrow{\infty}}\;(u\preceq v\;\text{or}\;v\preceq u) \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;   因此有 &lt;equation&gt;U\Sigma^{\overrightarrow{\infty}} \cap V\Sigma^{\overrightarrow{\infty}}=U_V\Sigma^{\overrightarrow{\infty}} \cup V_U\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , 设 &lt;equation&gt;W=U_V \cup V_U\subseteq\Sigma^{\overrightarrow{*}}&lt;/equation&gt; , 那么&lt;/p&gt;&lt;p&gt;&lt;equation&gt;U\Sigma^{\overrightarrow{\infty}} \cap V\Sigma^{\overrightarrow{\infty}}=W\Sigma^{\overrightarrow{\infty}}\in \tau&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;故 &lt;equation&gt;(\Sigma^{\overrightarrow{\infty}}, \tau)&lt;/equation&gt; 为 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 上的一个拓扑.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;引理1:&lt;/b&gt; &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 为闭集当且仅当:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\forall w\in \Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 若对于任意有限长度 &lt;equation&gt;u\preceq w&lt;/equation&gt; 存在 &lt;equation&gt;v\succeq u&lt;/equation&gt; 使得 &lt;equation&gt;v\in V&lt;/equation&gt; , 那么 &lt;equation&gt;w\in V&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;(\Rightarrow)&lt;/equation&gt; 若 &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 为闭集, 则存在 &lt;equation&gt;U\subseteq\Sigma^{\overrightarrow{*}}&lt;/equation&gt; 满足 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V=U\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , 若 &lt;equation&gt;w\in \Sigma^{\overrightarrow{\infty}}, w\not\in V&lt;/equation&gt; , 那么 &lt;equation&gt;w\in U\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , 存在长度有限前缀 &lt;equation&gt;u\preceq w, u\in U&lt;/equation&gt; , 有 &lt;equation&gt;\forall v\succeq u: v\in U\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 即 &lt;equation&gt;v\not\in V&lt;/equation&gt; , 故逆否命题&lt;equation&gt;(\forall (w\in \Sigma^{\overrightarrow{\infty}}, \text{finite}\;u\preceq w): \exists v\succeq u: v\in V) \to w\in V&lt;/equation&gt; 成立.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;(\Leftarrow)&lt;/equation&gt; 令 &lt;equation&gt;U=\left\{ u\in\Sigma^{\overrightarrow{*}}\;|\; \forall v\succeq u: v\not\in V \right\}&lt;/equation&gt;, 显然 &lt;equation&gt;U\Sigma^{\overrightarrow{\infty}}\subseteq\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; . 若 &lt;equation&gt;w\not\in V&lt;/equation&gt; 则有 &lt;equation&gt;\exists \text{finite}\;u\preceq w: \forall v\succeq u: v\not\in V&lt;/equation&gt; , 那么 &lt;equation&gt;u\in U&lt;/equation&gt; 故 &lt;equation&gt;\exists v:uv=w&lt;/equation&gt; 即 &lt;equation&gt;w\in U\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V\subseteq U\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; . 因此 &lt;equation&gt;U\Sigma^{\overrightarrow{\infty}}=\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为开集, 即 &lt;equation&gt;V&lt;/equation&gt; 为闭集.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;命题4: open and closed set&lt;/b&gt;&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;equation&gt;V&lt;/equation&gt; 为闭集当且仅当 &lt;equation&gt;V&lt;/equation&gt; 为prefix closed与limit closed.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;V&lt;/equation&gt; 为开集当且仅当 &lt;equation&gt;V&lt;/equation&gt; 为extension closed与finite witnesses.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;• &lt;equation&gt;(\Rightarrow)&lt;/equation&gt; 若 &lt;equation&gt;V&lt;/equation&gt; 为闭集, 对于任意 &lt;equation&gt;u\preceq v\in V&lt;/equation&gt; , 设 &lt;equation&gt;u^{&#39;}&lt;/equation&gt; 为 &lt;equation&gt;u&lt;/equation&gt; 的任意有限前缀 &lt;equation&gt;u^{&#39;}\preceq u&lt;/equation&gt; , 有 &lt;equation&gt;v\succeq u \succeq u^{&#39;}&lt;/equation&gt; , 根据引理1得 &lt;equation&gt;u\in V&lt;/equation&gt; 即 &lt;equation&gt;V&lt;/equation&gt; 为prefix closed. &lt;/p&gt;&lt;p&gt;由引理1直接可得 &lt;equation&gt;V&lt;/equation&gt; 为limit closed.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;(\Leftarrow)&lt;/equation&gt; 若 &lt;equation&gt;V&lt;/equation&gt; 为prefix closed与limit closed, 若 &lt;equation&gt;w\not\in V&lt;/equation&gt; 即 &lt;equation&gt;w\in \Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; , 由命题1和命题2得, &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为extension closed与finite witnesses, 由finite witnesses存在有限长度 &lt;equation&gt;u\preceq w&lt;/equation&gt; 使得 &lt;equation&gt;u\in \Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; , 又由extension closed对于任意 &lt;equation&gt;v\succeq u&lt;/equation&gt; 均有 &lt;equation&gt;v\in \Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 即 &lt;equation&gt;v\not\in V&lt;/equation&gt; , 故其逆否命题&lt;equation&gt;(\forall (w\in \Sigma^{\overrightarrow{\infty}}, \text{finite}\;u\preceq w): \exists v\succeq u: v\in V) \to w\in V&lt;/equation&gt; 成立. 由引理1得 &lt;equation&gt;V&lt;/equation&gt; 为闭集.&lt;/p&gt;&lt;p&gt;•   &lt;equation&gt;V&lt;/equation&gt; 为开集当且仅当 &lt;equation&gt;V&lt;/equation&gt; 为extension closed与finite witnesses.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\Leftrightarrow&lt;/equation&gt; &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为prefix closed与limit closed. (命题1和命题2)&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\Leftrightarrow&lt;/equation&gt; &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 为闭集 (proved above)&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\Leftrightarrow&lt;/equation&gt; &lt;equation&gt;V&lt;/equation&gt; 为开集&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;命题5: closure与interior&lt;/b&gt;&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;equation&gt;cl(V)=\left\{ w\in\Sigma^{\overrightarrow{\infty}} \;|\; \forall \text{finite}\;u\preceq w:\exists v\succeq u: v\in V\right\}&lt;/equation&gt;.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;int(V)=\left\{ w\in\Sigma^{\overrightarrow{\infty}} \;|\; \exists \text{finite}\;u\preceq w:\forall v\succeq u: v\in V\right\}&lt;/equation&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;• 令 &lt;equation&gt;C(V)=\left\{ w\in\Sigma^{\overrightarrow{\infty}} \;|\; \forall \text{finite}\;u\preceq w:\exists v\succeq u: v\in V\right\}&lt;/equation&gt; , &lt;equation&gt;\forall w\in \Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 若对于任意有限长度 &lt;equation&gt;u\preceq w&lt;/equation&gt; 存在 &lt;equation&gt;v\succeq u&lt;/equation&gt; 使得 &lt;equation&gt;v\in C(V)&lt;/equation&gt; , 由 &lt;equation&gt;C(V)&lt;/equation&gt; 的定义存在 &lt;equation&gt;v^{&#39;}\succeq u&lt;/equation&gt; 使得 &lt;equation&gt;v^{&#39;}\in V&lt;/equation&gt; , 故 &lt;equation&gt;w\in C(V)&lt;/equation&gt; 由引理1得 &lt;equation&gt;C(V)&lt;/equation&gt; 为闭集.&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;V\subseteq \Gamma \subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , &lt;equation&gt; \Gamma&lt;/equation&gt; 为闭集, 设 &lt;equation&gt;w\in C(V)&lt;/equation&gt; 那么有 &lt;equation&gt;\forall \text{finite}\;u\preceq w:\exists v\succeq u: v\in V \subseteq \Gamma &lt;/equation&gt; , 又由 &lt;equation&gt; \Gamma&lt;/equation&gt; 为闭集, 根据引理1得 &lt;equation&gt;w\in \Gamma&lt;/equation&gt; 即 &lt;equation&gt;C(V)\subseteq\Gamma&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;故 &lt;equation&gt;C(V)&lt;/equation&gt; 为 &lt;equation&gt;V&lt;/equation&gt; 的closure.&lt;/p&gt;&lt;p&gt;• 令 &lt;equation&gt;I(V)=\left\{ w\in\Sigma^{\overrightarrow{\infty}} \;|\; \exists\text{finite}\;u\preceq w:\forall v\succeq u: v\in V\right\}&lt;/equation&gt; , 设 &lt;equation&gt;w\in I(V)&lt;/equation&gt; 那么 &lt;equation&gt;\exists\text{finite}\;u\preceq w:\forall v\succeq u: v\in V&lt;/equation&gt; , 由 &lt;equation&gt;I(V)&lt;/equation&gt; 的定义 &lt;equation&gt;\forall v\succeq u: v\in I(V)&lt;/equation&gt; , 故 &lt;equation&gt;w\in u\Sigma^{\overrightarrow{\infty}}\subseteq I(V)&lt;/equation&gt; 且 &lt;equation&gt;u\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 为开集, &lt;equation&gt;I(V)=\bigcup_{w\in I(V)}^{}u\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 因此 &lt;equation&gt;I(V)&lt;/equation&gt; 为开集.&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;w\in\Delta\subseteq V&lt;/equation&gt; , &lt;equation&gt;\Delta&lt;/equation&gt; 为开集, 故存在 &lt;equation&gt;U \subseteq\Sigma^{\overrightarrow{*}}&lt;/equation&gt; 满足 &lt;equation&gt;w\in U\Sigma^{\overrightarrow{\infty}} \subseteq \Delta&lt;/equation&gt; , 因此 &lt;equation&gt;\exists u\in U: u\preceq w&lt;/equation&gt; , 故 &lt;equation&gt;\forall v\succeq u: v\in U\Sigma^{\overrightarrow{\infty}} \subseteq \Delta\subseteq V&lt;/equation&gt; , 根据 &lt;equation&gt;I(V)&lt;/equation&gt; 定义有 &lt;equation&gt;w\in I(V)&lt;/equation&gt; 即 &lt;equation&gt;\Delta\subseteq I(V)&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;故 &lt;equation&gt;I(V)&lt;/equation&gt; 为 &lt;equation&gt;V&lt;/equation&gt; 的interior.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义7: safety property与liveness property&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;若 &lt;equation&gt;\forall w\in\left(\Sigma^{\overrightarrow{\infty}}\setminus W\right): \exists\text{finite}\;u\preceq w\;\text{s.t.}\;\forall v:uv\in\left(\Sigma^{\overrightarrow{\infty}}\setminus W\right)&lt;/equation&gt; 则称 &lt;equation&gt;W&lt;/equation&gt; 为safety property.&lt;/li&gt;&lt;li&gt;若 &lt;equation&gt;\forall\text{finite}\;u:\exists v\;\text{s.t.}\;uv\in W&lt;/equation&gt; 则称 &lt;equation&gt;W&lt;/equation&gt; 为liveness property.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;注: safety property的含义为若某trace违反safety property则能通过其有限长度的前缀识别. liveness property的含义为对于任意的有限长度的trace, 总存在拓展满足liveness property.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;命题6:&lt;/b&gt; &lt;equation&gt;W&lt;/equation&gt; 为safety property当且仅当 &lt;equation&gt;W&lt;/equation&gt; 为闭集.&lt;/p&gt;&lt;p&gt;证明: &lt;/p&gt;&lt;p&gt;&lt;equation&gt;W&lt;/equation&gt; 为safety property&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\Leftrightarrow \forall w\in\left(\Sigma^{\overrightarrow{\infty}}\setminus W\right): \exists\text{finite}\;u\preceq w\;\text{s.t.}\;\forall v:uv\in\left(\Sigma^{\overrightarrow{\infty}}\setminus W\right)\\ &amp;amp;\Leftrightarrow \left(\forall w\not\in W\right)\to\left(\exists\text{finite}\;u\preceq w\;\text{s.t.}\;\forall u^{&#39;}\succeq u:u^{&#39;}\in\left(\Sigma^{\overrightarrow{\infty}}\setminus W\right)\right)\\ &amp;amp;\Leftrightarrow \left(\forall\text{finite}\;u\preceq w\;\text{s.t.}\;\exists u^{&#39;}\succeq u:u^{&#39;}\in W\right)\to w\in W \quad\text{[contrapositive]}\\ &amp;amp;\Leftrightarrow W\;\text{is closed}\;\quad\text{[lemma 1]}\\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;命题7: &lt;/b&gt;&lt;equation&gt;V&lt;/equation&gt; 为liveness property当且仅当 &lt;equation&gt;V&lt;/equation&gt; 稠密.&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;(\Rightarrow)&lt;/equation&gt; &lt;equation&gt;V&lt;/equation&gt; 为liveness property. 设 &lt;equation&gt;V\subseteq \Gamma&lt;/equation&gt; , &lt;equation&gt;\Gamma&lt;/equation&gt; 为闭集. 若存在 &lt;equation&gt;w\in\Sigma^{\overrightarrow{\infty}}\setminus \Gamma&lt;/equation&gt; 即 &lt;equation&gt;w\not\in\Gamma&lt;/equation&gt; , 由引理1得存在有限长度 &lt;equation&gt;u\preceq w&lt;/equation&gt; 对于任意 &lt;equation&gt;v\succeq u&lt;/equation&gt; 使得 &lt;equation&gt;v\not\in V&lt;/equation&gt; . 又由 &lt;equation&gt;V&lt;/equation&gt; 为liveness property, 故存在 &lt;equation&gt;v\succeq u&lt;/equation&gt; 满足 &lt;equation&gt;v\in V\subseteq \Gamma&lt;/equation&gt; , 矛盾. 故 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus \Gamma=\emptyset&lt;/equation&gt; 即 &lt;equation&gt;\Gamma=\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , &lt;equation&gt;V&lt;/equation&gt; 稠密.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;(\Leftarrow)&lt;/equation&gt; &lt;equation&gt;V&lt;/equation&gt; 稠密. 若 &lt;equation&gt;V&lt;/equation&gt; 不为liveness property, 则存在有限长度 &lt;equation&gt;u&lt;/equation&gt; 使得 &lt;equation&gt;\forall v\succeq u&lt;/equation&gt; 均有 &lt;equation&gt;v\not\in V&lt;/equation&gt; , 因此 &lt;equation&gt;u\Sigma^{\overrightarrow{\infty}}\subseteq\Sigma^{\overrightarrow{\infty}}\setminus V&lt;/equation&gt; 即 &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}\setminus u\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , 又 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus u\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; 为闭集, 而 &lt;equation&gt;V&lt;/equation&gt; 稠密, 故 &lt;equation&gt;\Sigma^{\overrightarrow{\infty}}\setminus u\Sigma^{\overrightarrow{\infty}}=\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; , &lt;equation&gt;u\Sigma^{\overrightarrow{\infty}}=\emptyset&lt;/equation&gt; 即 &lt;equation&gt;u&lt;/equation&gt; 不存在, 矛盾. 故 &lt;equation&gt;V&lt;/equation&gt; 为liveness property.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义8: safety component与liveness component&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;equation&gt;safe(V)=cl(V)&lt;/equation&gt; .&lt;/li&gt;&lt;li&gt;&lt;equation&gt;live(V)=\Sigma^{\overrightarrow{\infty}}\setminus \left( cl(V)\setminus V \right)&lt;/equation&gt; .&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;引理2:&lt;/b&gt; &lt;equation&gt;(X,\tau)&lt;/equation&gt; 为Topology space, &lt;equation&gt;Y\subseteq X&lt;/equation&gt; 则 &lt;equation&gt;X\setminus (cl(Y)\setminus Y)&lt;/equation&gt; 稠密.&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;X\setminus (cl(Y)\setminus Y)\subseteq Z&lt;/equation&gt; , &lt;equation&gt;Z&lt;/equation&gt; 为闭集.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;X\setminus Z \subseteq cl(Y) \setminus Y&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;又由 &lt;equation&gt;Y\subseteq cl(Y)&lt;/equation&gt; 故&lt;/p&gt;&lt;p&gt;&lt;equation&gt;Y\subseteq cl(Y)\setminus(X\setminus Z)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;X\setminus Z&lt;/equation&gt; 为闭集故 &lt;equation&gt;cl(Y)\setminus(X\setminus Z)&lt;/equation&gt; 亦为闭集, 那么有 &lt;equation&gt;cl(Y)\setminus(X\setminus Z) \subseteq cl(Y)&lt;/equation&gt; 即 &lt;equation&gt;X\setminus Z=\emptyset&lt;/equation&gt; ,&lt;equation&gt;Z=X&lt;/equation&gt; . 因此 &lt;equation&gt;X\setminus (cl(Y)\setminus Y)&lt;/equation&gt; 稠密.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;推论1: &lt;/b&gt;&lt;equation&gt;V&lt;/equation&gt; 为safety property当且仅当 &lt;equation&gt;safe(V)=V&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;由命题6得, &lt;equation&gt;V&lt;/equation&gt; 为safety property当且仅当 &lt;equation&gt;V&lt;/equation&gt; 为闭集, 故 &lt;equation&gt;V=cl(V)\overset{\mathrm{def}}{=}safe(V)&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;推论2:&lt;/b&gt; 对于任意 &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt;, &lt;equation&gt;safe(V)&lt;/equation&gt; 为safety property.&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;safe(V)\overset{\mathrm{def}}{=}cl(V)&lt;/equation&gt; 为闭集, 由命题6得, &lt;equation&gt;safe(V)&lt;/equation&gt; 为safety property.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;推论3:&lt;/b&gt; &lt;equation&gt;V&lt;/equation&gt; 为liveness property当且仅当 &lt;equation&gt;live(V)=V&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;由命题7得, &lt;equation&gt;V&lt;/equation&gt; 为liveness property当且仅当 &lt;equation&gt;V&lt;/equation&gt; 稠密, 故 &lt;equation&gt;cl(V)=\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt; &lt;equation&gt;live(V)\overset{\mathrm{def}}{=}\Sigma^{\overrightarrow{\infty}}\setminus \left( cl(V)\setminus V \right)=\Sigma^{\overrightarrow{\infty}}\setminus \left( \Sigma^{\overrightarrow{\infty}}\setminus V \right)=V&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;推论4: &lt;/b&gt;对于任意 &lt;equation&gt;V\subseteq\Sigma^{\overrightarrow{\infty}}&lt;/equation&gt;, &lt;equation&gt;live(V)&lt;/equation&gt; 为liveness property.&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;live(V)\overset{\mathrm{def}}{=}\Sigma^{\overrightarrow{\infty}}\setminus \left( cl(V)\setminus V \right)&lt;/equation&gt; 由引理2得其稠密, 由命题7得, &lt;equation&gt;live(V)&lt;/equation&gt; 为liveness property.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;引理3:&lt;/b&gt; &lt;equation&gt;(X,\tau)&lt;/equation&gt; 为Topology space, &lt;equation&gt;Y\subseteq X&lt;/equation&gt; 则&lt;/p&gt;&lt;p&gt;&lt;equation&gt;Y=cl(Y)\cap(X\setminus (cl(Y)\setminus Y))&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} cl(Y)\cap(X\setminus (cl(Y)\setminus Y))&amp;amp;=(X\cap cl(Y))\setminus ((cl(Y)\setminus Y)\cap cl(Y))\\ &amp;amp;=cl(Y)\setminus (cl(Y)\setminus Y)\\ &amp;amp;=Y \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定理1: property decomposition&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对于任意性质 &lt;equation&gt;P&lt;/equation&gt; , 其均可分解为safety component与liveness component的交.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;P=safe(P)\cap live(P)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} P&amp;amp;=safe(P)\cap live(P)\\ &amp;amp;\overset{\mathrm{def}}{=}cl(P)\cap\left(\Sigma^{\overrightarrow{\infty}}\setminus (cl(P)\setminus P)\right)\\ &amp;amp;=P\quad\text{[lemma 3]} \end{align}&lt;/equation&gt; &lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一个例子: &lt;/p&gt;&lt;p&gt;程序total correctness可以分解为partial correctness(safety component)与termination(liveness component).&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;equation&gt;\Upsilon\subseteq\Sigma&lt;/equation&gt; 为初始状态.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;\Omega\subseteq\Sigma&lt;/equation&gt; 为终止状态.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;\Psi\subseteq\Upsilon\times\Omega&lt;/equation&gt; 为partial correctness relation.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;\Phi\overset{\mathrm{def}}{=}\left\{ (s,s^{&#39;})\;|\;(s\in\Upsilon) \Rightarrow((s\to^{*}s^{&#39;})\wedge (s^{&#39;}\in\Omega)\wedge (s,s^{&#39;})\in\Psi)\right\}&lt;/equation&gt;为total correctness relation.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;partial correctness:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\forall s,s^{&#39;}\in\Sigma:\left((s\to^{*}s^{&#39;})\wedge (s\in\Upsilon)\wedge (s^{&#39;}\in\Omega))\right)\Rightarrow \left( (s,s^{&#39;})\in\Psi \right)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;termination:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\forall \sigma\in\Sigma^{\overrightarrow{*}}:\left( \sigma_0 \in\Upsilon \right)\Rightarrow\left(\exists l=|\sigma|:\sigma_l\in\Omega\right)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;total correctness:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\forall \sigma\in\Sigma^{\overrightarrow{*}}:\left(\exists l=|\sigma|:(\sigma_1,\sigma_l)\in\Phi\right)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\forall \sigma\in\Sigma^{\overrightarrow{*}}:\left( \sigma_0 \in\Upsilon \right)&amp;amp;\text{[initial states]}\\ \Rightarrow\;&amp;amp;\sigma_0 \in\Upsilon\wedge\exists l=|\sigma|:\sigma_l\in\Omega&amp;amp;\text{[termination]}\\ \Rightarrow\;&amp;amp;(\sigma_0, \sigma_l)\in\Psi&amp;amp;\text{[partial correctness]}\\ \Rightarrow\;&amp;amp;(\sigma_0, \sigma_l)\in\Phi&amp;amp;\text{[proving total correctness]}\\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;好久都没写新文章啦, 最近了解了一下程序性质的拓扑结构觉得还蛮有趣的, 所以来写个小文章介绍一下.  有机会将来再深入介绍一下在此之上与Linear temporal logic(LTL)的一些有趣的性质, 在model checking中有着比较多的应用.&lt;/p&gt;&lt;p&gt;谢谢大家的阅读~&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>梨梨喵</author>
<guid isPermaLink="false">2018-07-15-37864854</guid>
<pubDate>Sun, 15 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>tensorflow on idris学习项目</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-07-06-39147186.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/39147186&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;希望在idris中实现安全的深度学习api。目前已经成功调用C api获取tf版本&lt;/p&gt;&lt;a href=&quot;https://github.com/doofin/tensorflow-idris&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-03ab6f034de1e41a73ac9fd84abbf1bf&quot; data-image-width=&quot;420&quot; data-image-height=&quot;420&quot; data-image-size=&quot;ipico&quot;&gt;doofin/tensorflow-idris&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Martin awodey</author>
<guid isPermaLink="false">2018-07-06-39147186</guid>
<pubDate>Fri, 06 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>The combinator of combinator</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-06-18-38200636.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38200636&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;组合子的组合子&lt;/p&gt;&lt;p&gt;大雾~&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;最近把之前写的&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25411428&quot;&gt;Parser combinator&lt;/a&gt;拿了出来, 因为刚好想到一些有趣的东西. 之前的组合子是不能回溯的, 因为所有的组合子的构建是自下而上的, 当前组合子的语法分析只能看到其子组合子的综合属性, 返回一条分支的值之后便不再尝试其他分支. 这会对其表达能力造成一些限制.&lt;/p&gt;&lt;p&gt;一个解决办法是像一般的Parser combinator一样, 传入一个所有的当前分析位置的list, 对每一个位置进行分析, 保存所有分支的结果传出一个新的list.&lt;/p&gt;&lt;p&gt;我使用的是另一种思路, 对组合子的组合函数进行CPS变换, 这样每一个组合子除了能看见子组合子的综合属性还能看见后续的分析结果, 于是分支选择变成了可能, 即是对应与Direct style的回溯.&lt;/p&gt;&lt;p&gt;详细的构造请看文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25411428&quot;&gt;Parser combinator 在C++里的DSL&lt;/a&gt;更新的第4节, 是我新加入哒.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;为什么需要回溯呢? 那当然是我想到了一些好玩的东西啦, 在之前的文章里通过Parser combinator构造了一个小的四则运算计算器, 组合子是:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;ParserCombinator&amp;lt;int&amp;gt; Additive&lt;/code&gt;&lt;p&gt;返回的是表达式的语义值, 一个 &lt;equation&gt;\texttt{int}&lt;/equation&gt; 类型的数值表示算式的值.&lt;/p&gt;&lt;p&gt;于是问题来了, 很自然地会想到一个生成Parser combinator的Parser combinator是什么呢?&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一个典型的最简单的例子, 正则表达式!&lt;/p&gt;&lt;p&gt;对! 又是正则表达式~&lt;/p&gt;&lt;p&gt;理由很简单, 在Chomsky hierarchy里, 正则表达式是Type-3 grammars, 弱于Parser combinator描述的Type-2 grammars上下文无关文法. 显然地, 我们可以使用组合子来构造一个正则表达式的匹配器.&lt;/p&gt;&lt;p&gt;正则表达式的匹配器是一个返回 &lt;equation&gt;\texttt{bool}&lt;/equation&gt; 型的Parser combinator, 返回 &lt;equation&gt;\texttt{true}&lt;/equation&gt; 表示匹配成功.&lt;/p&gt;&lt;p&gt;对于正则表达式的字符匹配:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;ParserCombinator&amp;lt;bool&amp;gt; match;
match = (Token(ch) &amp;gt;&amp;gt; Return(true));&lt;/code&gt;&lt;p&gt;&lt;equation&gt;\texttt{ch}&lt;/equation&gt; 是需要匹配的 &lt;equation&gt;\texttt{char}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;对于正则表达式的连接&lt;equation&gt;\texttt{(+)}&lt;/equation&gt;:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;//ParserCombinator&amp;lt;bool&amp;gt; part_1, part_2;
ParserCombinator&amp;lt;bool&amp;gt; match;
match = part_1 + part_2 &amp;gt;&amp;gt; Return(true);&lt;/code&gt;&lt;p&gt;&lt;equation&gt;\texttt{part_1}&lt;/equation&gt; 和 &lt;equation&gt;\texttt{part_2}&lt;/equation&gt; 是子表达式.&lt;/p&gt;&lt;p&gt;对于正则表达式的分支 &lt;equation&gt;\texttt{(|)}&lt;/equation&gt; :&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;ParserCombinator&amp;lt;bool&amp;gt; match;
match = part_1 | part_2;&lt;/code&gt;&lt;p&gt;&lt;equation&gt;\texttt{part_1}&lt;/equation&gt; 和 &lt;equation&gt;\texttt{part_2}&lt;/equation&gt; 是子表达式.&lt;/p&gt;&lt;p&gt;对于正则表达式的闭包&lt;equation&gt;\texttt{(*)}&lt;/equation&gt;:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;ParserCombinator&amp;lt;bool&amp;gt; match;
match = match + unit &amp;gt;&amp;gt; Return(true) | Epsilon(true);&lt;/code&gt;&lt;p&gt;&lt;equation&gt;\texttt{unit}&lt;/equation&gt; 是子表达式.&lt;/p&gt;&lt;p&gt;有了以上的构造之后可以轻松地写出生成正则表达式组合子:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;ParserCombinator&amp;lt;ParserCombinator&amp;lt;bool&amp;gt;&amp;gt; unit, repeat, connection, branch, regex;

unit = Token([](char ch) { return ch != &#39;(&#39; &amp;amp;&amp;amp; ch != &#39;)&#39; &amp;amp;&amp;amp; ch != &#39;|&#39; &amp;amp;&amp;amp; ch != &#39;+&#39;; }) &amp;gt;&amp;gt;
	[](char ch)
{
	ParserCombinator&amp;lt;bool&amp;gt; match;
	match = (Token(ch) &amp;gt;&amp;gt; Return(true));
	return match;
} | &#39;\\&#39;_T + Token(AnyChar{}) &amp;gt;&amp;gt; [](Placeholder, char ch)
{
	ParserCombinator&amp;lt;bool&amp;gt; match;
	match = (Token(ch) &amp;gt;&amp;gt; Return(true));
	return match;
} | &#39;(&#39;_T + regex + &#39;)&#39;_T &amp;gt;&amp;gt; [](Placeholder, const ParserCombinator&amp;lt;bool&amp;gt;&amp;amp; unit, Placeholder)
{
	return unit;
};

repeat = unit + &#39;*&#39;_T &amp;gt;&amp;gt; [](const ParserCombinator&amp;lt;bool&amp;gt;&amp;amp; unit, Placeholder)
{
	ParserCombinator&amp;lt;bool&amp;gt; match;
	match = match + unit &amp;gt;&amp;gt; Return(true) | Epsilon(true);
	return match;
} | unit;

connection = connection + repeat &amp;gt;&amp;gt;
	[](const ParserCombinator&amp;lt;bool&amp;gt;&amp;amp; part_1, const ParserCombinator&amp;lt;bool&amp;gt;&amp;amp; part_2)
{
	ParserCombinator&amp;lt;bool&amp;gt; match;
	match = part_1 + part_2 &amp;gt;&amp;gt; Return(true);
	return match;
} | repeat;

branch = branch + &#39;|&#39;_T + connection &amp;gt;&amp;gt;
	[](const ParserCombinator&amp;lt;bool&amp;gt;&amp;amp; part_1, Placeholder, const ParserCombinator&amp;lt;bool&amp;gt;&amp;amp; part_2)
{
	ParserCombinator&amp;lt;bool&amp;gt; match;
	match = part_1 | part_2;
	return match;
} | connection;

regex = branch &amp;gt;&amp;gt; [](const ParserCombinator&amp;lt;bool&amp;gt;&amp;amp; match)
{
	ParserCombinator&amp;lt;bool&amp;gt; regex(match);
	regex.ReturnDefaultWhenFail(true);	//return false
	return regex;
};

std::string pattern = &quot;(a|b)*abb&quot;;
std::string match   = &quot;babaababb&quot;;

std::cout &amp;lt;&amp;lt; regex(pattern)(match) &amp;lt;&amp;lt; std::endl;
//print: 1&lt;/code&gt;&lt;p&gt;看到 &lt;equation&gt;\texttt{ParserCombinator&amp;lt;ParserCombinator&amp;lt;bool&amp;gt;&amp;gt;}&lt;/equation&gt; 了嘛, 于是我们在50行内写出了一个正则表达式引擎(特大雾).&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我感觉我都快成正则表达式专业户了(笑~). 其实我是用CPS改写了我的Parser combinator, 更新文章了不过感觉没什么人会看到, 于是来水了一篇文章(抱歉占用了大家宝贵的阅读时间).&lt;/p&gt;&lt;p&gt;继续拓展, 一个能生成生成Parser combinator的Parser combinator的Parser combinator会是什么呢? 这个嘛...嗯...我不知道. 更加地, 一个能生成自生Parser combinator的Parser combinator又会是什么呢(无限嵌套的递归类型, C++也里实现不出来呀哈)?&lt;/p&gt;&lt;p&gt;知道的小伙伴请告诉我&amp;gt;.&amp;lt;&lt;/p&gt;</description>
<author>梨梨喵</author>
<guid isPermaLink="false">2018-06-18-38200636</guid>
<pubDate>Mon, 18 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>PCP Theorem Part 2: Expander Graph</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-06-18-38113778.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38113778&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cfad1bac7ce7f070d2594ae717c075ac_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;上次我们证明了 &lt;equation&gt;\text{GAP-3SAT}_{1,s} \in \mathsf{NP-hard}&lt;/equation&gt; 和 PCP Theorem是等价的。事实上，在Dinur的证明中，她并没有直接证明 &lt;equation&gt;\text{GAP-3SAT}_{1,s} \in \mathsf{NP-hard}&lt;/equation&gt; 而是通过证明&lt;equation&gt;\text{GAP-3COLOR}_{1,s} \in \mathsf{NP-hard}&lt;/equation&gt; 来得到PCP Theorem。我们知道 &lt;equation&gt;\text{3COLOR} \in \text{NP-hard}&lt;/equation&gt; ,那么 &lt;equation&gt;\text{GAP-3COLOR}_{1,1-\frac{1}{m}} \in \mathsf{NP-hard}&lt;/equation&gt; 是显然的（一个无法被3COLOR的图，不管什么染色方案，至少有一条边不满足限制）。Dinur通过巧妙的构造把gap从 &lt;equation&gt;1-\frac{1}{m}&lt;/equation&gt; 放大到一个常数倍来得到这个结果。其中很大部分都是巧妙的利用 expander graph的性质，这篇文章会给大家补充一些expander graph的知识，在Part 3. 我们会正式进入 Dinur的证明。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;扩展图 (Expander Graph)&lt;/h2&gt;&lt;p&gt;扩展图是一种没有瓶颈的图，也就是说这是一种有很强的联通性的图。下面的定义就是根据它的这个性质定义的。&lt;/p&gt;&lt;p&gt;首先我们需要定义一下Edge Expansion（有的中文资料把他翻译成边扩展率）,对于一个图 &lt;equation&gt;G=(V,E)&lt;/equation&gt; 它的Edge Expansion定义如下&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\phi(G)=\min_{S\subseteq V,|S|\leq \frac{|V|}{2}} \frac{|E(S,\bar S)|}{|S|}&lt;/equation&gt;这里 &lt;equation&gt;\bar S=V\setminus S&lt;/equation&gt; ， &lt;equation&gt;E(S,\bar S) = \{(u,v) \in E | u \in S \text{ and }v\in \bar S\}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;我们说一个图的Edge Expansion是至少是一个正的常数的话，那我们称这个图是一个扩展图。事实上，找到一个扩展图并不难：任何一个完全图都是扩展图。然而在这里我们希望能够找到稀疏的扩展图：更加准确得说，我们希望找到一个扩展图而且它的每个点的度数都是一个常数d，对于这样的图，我们把它称为&lt;b&gt;d-正则扩展图&lt;/b&gt;。（我们把每个点度数都为d的图，叫做d-正则图）&lt;/p&gt;&lt;p&gt;为了方便我们后面的证明，下面介绍一些关于谱图论(Spectral Graph Theory)的记号：&lt;/p&gt;&lt;p&gt;对于一个d-正则图 &lt;equation&gt;G&lt;/equation&gt; ,我们用 &lt;equation&gt;A_G&lt;/equation&gt; 来表示 &lt;equation&gt;G&lt;/equation&gt; 所对应的邻接矩阵，因此对于没有边权且有重边的图 &lt;equation&gt;(A_G)_{i,j}&lt;/equation&gt; 表示i, j之间边的数量。因为&lt;equation&gt;A_G&lt;/equation&gt; 是实对称矩阵，所以它一定有 &lt;equation&gt;n &lt;/equation&gt; 个实数特征值，我们把它们标作 &lt;equation&gt;\lambda_1 \geq \lambda_2 \geq \ldots \geq \lambda_n&lt;/equation&gt; 。显然 &lt;equation&gt;\vec{1}&lt;/equation&gt; 是&lt;equation&gt;A_G&lt;/equation&gt;的一个特征向量，并且它的特征值是 &lt;equation&gt;d&lt;/equation&gt; 。我们可以轻易的证明 &lt;equation&gt;d &lt;/equation&gt; 是最大的特征值：&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;我们不妨设 &lt;equation&gt;\vec{x}&lt;/equation&gt; 是最大特征值 &lt;equation&gt;\lambda_1&lt;/equation&gt; 所对应的特征向量，那么我们有 &lt;equation&gt;\[|\lambda_1|x_k = |\sum_{j=1}^n A_{kj}x_j| \leq \sum_{j=1}^n A_{kj}|x_j| \leq \sum_{j=1}^n A_{kj}x_k = x_k \sum_{j=1}^n A_{kj} = dx_k .\]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;所以特征值一定小于等于d。&lt;/p&gt;&lt;p&gt;因为我们知道对于任意一个d-正则图，它最大的特征值总是d，我们更加关心它绝对值第二大的特征值。我们把这个特征值定义为 &lt;equation&gt;\lambda&lt;/equation&gt; ，也就是说 &lt;equation&gt;\lambda = \max_{i&amp;gt;1}\{|\lambda_i|\}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;定义2.1： &lt;/b&gt;对于一个有n个点的d-正则图 G，如果我们有 &lt;equation&gt;\lambda &amp;lt; d&lt;/equation&gt; ，那么我们把他称作 &lt;equation&gt;(n,d,\lambda)-\text{扩展图}&lt;/equation&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;定理2.2 (Cheeger&#39;s inequality)&lt;/b&gt;： &lt;equation&gt;\[\frac{\phi(G)^2}{2d} \leq d-\lambda \leq 2\phi(G)\]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;对于本文来说，我们只关心右边的不等式，所以我们只证明右边的。&lt;/p&gt;&lt;p&gt;证明：假设点集 &lt;equation&gt;S \subseteq V&lt;/equation&gt; 且 &lt;equation&gt;|S| \leq n/2&lt;/equation&gt; ，我们将证明 &lt;equation&gt;\phi(S) \geq (d -\lambda )/2&lt;/equation&gt; 。我们构造一个这样的向量 &lt;equation&gt;\vec{x} = \begin{cases} -|\bar S| &amp;amp; \text{ if } v\in S \\ |S| &amp;amp; \text{ if } v \in \bar S \end{cases}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;那么我们有 &lt;equation&gt;\vec{x}\cdot \vec{1}=\sum x_v=0&lt;/equation&gt; 所以 &lt;equation&gt;\vec{x}\perp\vec{1}&lt;/equation&gt; 。既然 &lt;equation&gt;\vec{x} \perp \vec{1}&lt;/equation&gt;，那么 &lt;equation&gt;\|A_G\vec{x}\| \leq \lambda \|\vec{x}\|&lt;/equation&gt;，因为我们证明了只有 &lt;equation&gt;\vec{1}&lt;/equation&gt; 才可能有比 &lt;equation&gt;\lambda&lt;/equation&gt; 更大的特征值。那么，我们有 &lt;equation&gt;\langle A_G\vec{x},\vec{x}\rangle \leq \|A_G\vec{x}\|\cdot \|\vec{x}\| \leq \lambda\|\vec{x}\|^2&lt;/equation&gt; ，而且 &lt;equation&gt;\|x\|^2=|S||\bar S|^2+|\bar S||S|^2=|S||\bar S|(|S|+|\bar S|)=|S||\bar S|n&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;现在，我们来算一下 &lt;equation&gt;\langle A_G\vec{x},\vec{x}\rangle&lt;/equation&gt; :&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align*} \langle A_G\vec{x},\vec{x}\rangle &amp;amp;= \sum_u x_u \sum_{(u,v)\in E} x_v \\ &amp;amp;= 2 \sum_{(u,v)\in E} x_ux_v \\ &amp;amp;= 2 \sum_{(u,v)\in E(S,S)} x_v + 2 \sum_{(u,v)\in E(\bar S, \bar S)} x_v + 2 \sum_{(u,v)\in E(S,\bar S)} x_v\\ &amp;amp;= (d|S|-|E(S,\bar S)|)|\bar S|^2 + (d|\bar S|-|E(S,\bar S)|)|S|^2 - 2|E(S, \bar S)||S||\bar S|\\ &amp;amp;=d|S||\bar S| n - |E(S,\bar S)|n^2 \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;然后我们知道 &lt;equation&gt;\langle A_G\vec{x},\vec{x}\rangle\leq \lambda\|\vec{x}\|^2&lt;/equation&gt; ,也就是 &lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align*} &amp;amp;d|S||\bar S| n - |E(S,\bar S)|n^2 \leq \lambda |S||\bar S|n \\ &amp;amp;\Rightarrow (d-\lambda)\leq \frac{|E(S,\bar S)|n}{|S||\bar S|} \\ &amp;amp;\Rightarrow \frac{(d-\lambda) |\bar S|}{n}\leq \frac{|E(S,\bar S)|}{|S|} \\ &amp;amp;\Rightarrow \frac{(d-\lambda) |\bar S|}{n}\leq \phi(G) \\ \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;因为 &lt;equation&gt;|S| \leq n/2&lt;/equation&gt; 那么 &lt;equation&gt;|\bar S| &amp;gt; n/2&lt;/equation&gt; ，所以 &lt;equation&gt; \frac{d-\lambda}{2}\leq \frac{(d-\lambda) |\bar S|}{n}\leq \phi(G) &lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;证毕&lt;/p&gt;&lt;p&gt;&lt;b&gt;定理2.3&lt;/b&gt;：如果G是一个d-正则图，H是一个d&#39;-正则图，且G和H的点集相同，那么 &lt;equation&gt;G&#39;=G\cup H=(V,E(G)\cup E(H))&lt;/equation&gt; 是一个(d+d&#39;)-正则图，且满足 &lt;equation&gt;\lambda(G&#39;)\leq \lambda(G)+\lambda(H)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;证明: &lt;/p&gt;&lt;p&gt;假设 &lt;equation&gt;\vec{x}&lt;/equation&gt; 满足 &lt;equation&gt;\|x\|=1&lt;/equation&gt; ， &lt;equation&gt;\vec{x}\perp \vec{1}&lt;/equation&gt; ，且 &lt;equation&gt;\lambda(G&#39;)=\langle A_{G&#39;}\vec{x},\vec{x}\rangle&lt;/equation&gt; 。那么&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align*} \langle A_{G&#39;}\vec{x},\vec{x}\rangle &amp;amp;= \langle A_{G}\vec{x},\vec{x}\rangle + \langle A_{H}\vec{x},\vec{x}\rangle \\ &amp;amp; \leq \lambda(G) + \lambda(H) \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;证毕。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定理2.4&lt;/b&gt;: 我们能找到常数 d 和 &lt;equation&gt;\lambda&lt;/equation&gt; (&lt;equation&gt;\lambda &amp;lt; d&lt;/equation&gt;)，使得对于任意整数 n 我们都能找到一个 &lt;equation&gt;(n,d,\lambda&#39;)-\text{正则图}&lt;/equation&gt;  (&lt;equation&gt;\lambda &#39; &amp;lt; \lambda&lt;/equation&gt; )。&lt;/p&gt;&lt;p&gt;在这里我们会给出这样的例子，但是并不会给出证明。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Gaber-Galil Expanders&lt;/b&gt;: 我们可以构造出有 &lt;equation&gt;n^2&lt;/equation&gt; 个点的拓展图，对于一个点 &lt;equation&gt;v=(x,y)&lt;/equation&gt; ，把它连向下列点 &lt;equation&gt;(x+2y,y),(x,2x+y),(x+2y+1,y),(x,2x+y+1)&lt;/equation&gt;  这里的加法是模n意义下的加法。这是一个8-正则图，且我们能够证明 &lt;equation&gt;\lambda \leq 5\sqrt 2 &amp;lt; 8&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;课后习题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;证明 &lt;equation&gt;\lambda_n=-d&lt;/equation&gt; 当且仅当图 G 是一个二分图。&lt;/li&gt;&lt;li&gt;证明 &lt;equation&gt;\lambda_2 &amp;lt; d&lt;/equation&gt; 当且仅当图 G 是一个联通图。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在下一节中，我们将运用这节关于扩展图的结论来讲解Dinur证明的前两部，并粗略的证明这个方向是可行的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Guanghao Ye</author>
<guid isPermaLink="false">2018-06-18-38113778</guid>
<pubDate>Mon, 18 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>PCP Theorem Part 1: Introduction</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-06-13-37270132.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37270132&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cfad1bac7ce7f070d2594ae717c075ac_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;PCP Theorem的定义&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们先给出一个传统的&lt;b&gt;证明系统&lt;/b&gt; (proof system)的定义：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;我们有一个命题 (statement)&lt;/li&gt;&lt;li&gt;有一个证明者 (prover) 会给出一个证明对上面的命题证明或证否&lt;/li&gt;&lt;li&gt;验证者(verifier)检查上述证明，然后接受或拒绝这个证明&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;The PCP (Probabilistically Checkable Proof) Theorem&lt;/b&gt;: &lt;/p&gt;&lt;p&gt;对于任何一个在NP里面的语言 &lt;equation&gt;L &lt;/equation&gt; ，我们都有一个如下的P.C.P. 系统&lt;/p&gt;&lt;ul&gt;&lt;li&gt;对于一个长为n的输入&lt;/li&gt;&lt;li&gt;然后证明者给出一个多项式长度的证明&lt;/li&gt;&lt;li&gt;验证者生成 &lt;equation&gt;O(\log n)&lt;/equation&gt; 长度的随机串，根据这个随机串在证明里面随机的选 &lt;equation&gt;C&lt;/equation&gt; 个位置。这里的 &lt;equation&gt;C&lt;/equation&gt; 是一个常数。&lt;/li&gt;&lt;li&gt;验证者读取这 &lt;equation&gt;C&lt;/equation&gt; 个位置的内容，然后进行测试来决定接受或拒绝这个证明。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里的验证者要满足如下条件:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;可靠性：对于任何不满足条件的输入，验证者接受它的概率不超过一半&lt;/li&gt;&lt;li&gt;完备性：对于如何满足条件的输入，验证者一定接受它&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;PCP Theorem和 &lt;equation&gt;\textrm{GAP-3SAT} \in \textrm{NP-hard}&lt;/equation&gt; 等价&lt;/h2&gt;&lt;p&gt;&lt;equation&gt;\textrm{GAP-3SAT} _{c, s}(0&amp;lt;s\leq c\leq 1)&lt;/equation&gt; 的定义：给一个有m个子句(clause)的3SAT的表达式，假设我们最多能满足其中的 &lt;equation&gt;k&lt;/equation&gt; 个句子。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果 &lt;equation&gt;k\geq cm&lt;/equation&gt; ，接受这个表达式&lt;/li&gt;&lt;li&gt;如果 &lt;equation&gt;k &amp;lt; sm &lt;/equation&gt; ，拒绝这个表达式&lt;/li&gt;&lt;li&gt;如果 &lt;equation&gt;sm \leq k &amp;lt; cm&lt;/equation&gt; ，我们不在意这种情况，随机选择&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;定理1&lt;/b&gt;. PCP Theorem和 &lt;equation&gt;\textrm{GAP-3SAT}_{1,s} \in \textrm{NP-hard}&lt;/equation&gt; 是等价的&lt;/p&gt;&lt;p&gt;证明:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\Leftarrow&lt;/equation&gt;  假设 &lt;equation&gt;\textrm{GAP-3SAT}_{1,s} \in \textrm{NP-hard}&lt;/equation&gt;。我们这里会证明3COLOR有P.C.P.系统。假设输入是一个有 &lt;equation&gt;n &lt;/equation&gt; 个点的图G。那么验证者首先把这个输入归于到一个有m个子句的 &lt;equation&gt;\textrm{GAP-3SAT}_{1,s}&lt;/equation&gt; 表达式 &lt;equation&gt;\phi&lt;/equation&gt; 。这个时候证明者会被要求给出一个 &lt;equation&gt;\phi&lt;/equation&gt; 的赋值。然后此时证明者，只需要随机选择一个子句，获得对应的三个布尔变量的赋值就好了。这个时候显然 &lt;equation&gt;C=3&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;可靠性 (Soundness)：如果G不能被三染色的话，那么我们有 &lt;equation&gt;\phi&lt;/equation&gt; 满足的子句小于 &lt;equation&gt;sm&lt;/equation&gt; 。那么我们随机选择的子句不满足的概率是 &lt;equation&gt;s&lt;/equation&gt; 。如果这个时候 &lt;equation&gt;s&amp;gt;\frac{1}{2}&lt;/equation&gt; 的话，我们重复 &lt;equation&gt;O(1)&lt;/equation&gt; 次就好了。&lt;/p&gt;&lt;p&gt;完备性 (Completeness)：如果G可以被三染色的话，那么&lt;equation&gt;\phi&lt;/equation&gt; 一定可以全部被满足。所以我们接受的概率是1。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\Rightarrow&lt;/equation&gt; 假设我们有PCP theorem，这个时候我们把3COLOR规约到 &lt;equation&gt;\textrm{GAP-3SAT}_{1,s} &lt;/equation&gt; 来证明 &lt;equation&gt;\textrm{GAP-3SAT}_{1,s} &lt;/equation&gt; 是NP-hard的。首先我们有PCP theorem，那么我们可以得到一个多项式长度的证明，在这里我们会认为证明是对于一个3SAT表达式的赋值。然后，我们用 &lt;equation&gt;O(\log n)&lt;/equation&gt; 长度的随机串生成 &lt;equation&gt;2^{O(\log n)}=\text{poly}(n)=N&lt;/equation&gt; 个随机选择。对于每个这样的选择，我们会生成 &lt;equation&gt;C&lt;/equation&gt;个位置，然后读取这 &lt;equation&gt;C&lt;/equation&gt;个位置的值，把他们标作 &lt;equation&gt;x_1,x_2,\ldots,x_C&lt;/equation&gt; 。我们定义一个布尔函数 &lt;equation&gt;H(x_1,x_2,\ldots,x_C)&lt;/equation&gt; ，当原有的3SAT表达式能在不改变这C个位置的值满足时返回一，否则返回0。因为Cook-Levin Theorem，我们知道我们可以在多项式的时间内生成这个函数对应的3SAT表达式。因为只有 &lt;equation&gt;C&lt;/equation&gt; 个变量，我们不妨假设这个对应3SAT表达式有 &lt;equation&gt;K=2^C\cdot C&lt;/equation&gt; 个子句。然后，我们用 &lt;equation&gt;\land&lt;/equation&gt; 把这 &lt;equation&gt;N&lt;/equation&gt; 个长度为 &lt;equation&gt;K&lt;/equation&gt; 的表达式连接在一起，得到了一个有 &lt;equation&gt;N\cdot K&lt;/equation&gt; 的3SAT表达式 &lt;equation&gt;\phi&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;完备性 (Completeness)：如果原有的输入是可以三染色的话，那么我们一定可以得到完美的证明，或者说一个满足所有子句的赋值。那么我们新的3SAT表达式显然是可以满足所有子句的。&lt;/p&gt;&lt;p&gt;可靠性 (Soundness)：如果原有的输入不是三染色的话，那么根据PCP theorem，我们每次至少有一半的机会得到一个不可满足的3SAT表达式。那么这个3SAT表达式不可满足的时候，它最多有 &lt;equation&gt;K-1=K(1-\frac{1}{K})&lt;/equation&gt; 个可以满足的子句。那么对于 &lt;equation&gt;\phi&lt;/equation&gt; ，我们能够同时满足的不超过 &lt;equation&gt;\frac{N}{2}K(1-\frac{1}{K})+\frac{N}{2}K=NK(1-\frac{1}{2K})=m(1-\frac{1}{2K})&lt;/equation&gt; 。也就是说我们能够得到一个常数 &lt;equation&gt;s=1-\frac{1}{2K}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们后面将通过证明 &lt;equation&gt;\textrm{GAP-3SAT}_{1,s} \in \textrm{NP-hard}&lt;/equation&gt; 来证明PCP theorem。&lt;/p&gt;&lt;p&gt;在下一节中，我们将介绍Expander Graph和它的一些基本定理，来为后面的证明做一些铺垫&amp;gt;_&amp;lt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;P.S. 感觉中文写得很别扭，欢迎大家提出翻译上的建议。如果实在看不懂我在写什么的话，可以和&lt;a href=&quot;https://courses.cs.washington.edu/courses/cse533/05au&quot;&gt;我校05年的Notes&lt;/a&gt;的Lec 1, 2交叉阅读。&lt;/p&gt;</description>
<author>Guanghao Ye</author>
<guid isPermaLink="false">2018-06-13-37270132</guid>
<pubDate>Wed, 13 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Cardano中的半形式化开发方法</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-06-08-37869146.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37869146&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;a href=&quot;https://iohk.io/blog/semi-formal-development-the-cardano-wallet/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-91dbd6bb8b22435eec5028eaca12a2c3&quot; data-image-width=&quot;1053&quot; data-image-height=&quot;592&quot; data-image-size=&quot;180x120&quot;&gt;Semi-Formal Development: The Cardano Wallet&lt;/a&gt;&lt;blockquote&gt;把形式化的建模和QuickCheck的测试结合在一起，是开发高可信软件的一把利刃。 通过对不变量的测试来保证模型的一致性，通过和模型的比对来保证真实实现的正确性。&lt;/blockquote&gt;&lt;p&gt;Well-Typed给IOHK做的咨询工作的一部分，就是和他们一起设计和开发Cardano虚拟货币钱包软件的全新版本。其中一个重要部分就是输出了一份关于钱包的 &lt;a href=&quot;https://cardanodocs.com/files/formal-specification-of-the-cardano-wallet.pdf&quot;&gt;半形式化规范&lt;/a&gt; ， 也就是一个描述钱包运行机制的数学模型以及相关的不变量和定理。&lt;/p&gt;&lt;p&gt;我们把它叫做“半形式化”是因为，虽然它描述了很多钱包的属性，也证明了其中一部分，但并没有证明其所有属性。 不过，就像我们后面会讲到的，我们可以使用 &lt;a href=&quot;http://hackage.haskell.org/package/QuickCheck&quot;&gt;QuickCheck&lt;/a&gt; （译注：一个能自动生成测试数据对属性进行测试的工具） 通过生成反例的方式来测试这些属性。 它不仅能帮助我们开发形式规范本身。如果未来我们真的证明了所有属性的正确性，它也为我们测试真实实现提供重要指导。&lt;/p&gt;&lt;p&gt;本文将向大家介绍这份形式规范，以及它是如何驱动新版本钱包的开发和测试的。 我们会展示了这个形式化开发方法的一部分，让大家大致了解它是什么样的，但不会涉及太多细节。 本文的目的是向大家介绍这套开发方法及其优势, 而不是具体的数学理论。&lt;/p&gt;&lt;blockquote&gt;本文所有图表、不变量、章节编号都来自于 &lt;a href=&quot;https://cardanodocs.com/files/formal-specification-of-the-cardano-wallet.pdf&quot;&gt;1.1版本的规范&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;背景知识：UTxO记账法&lt;/b&gt;&lt;br&gt;正常银行转账交易是从一个账户往另一个账户转移资产，比如张三给李四转账100元。 但是Cardano和比特币这种虚拟货币的交易略有不同。 交易的输出大体上差不多，唯一区别是可以有多个目标账号，比如一笔交易可以同时转70元给李四，30元给王五。 交易的输入就完全不同了，一笔交易的输入不是来自某个账户，而是来自其他交易。 举个例子，我们把这笔“给李四70元给王五30元”的交易叫做t1。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
t1 输入: ...
   输出: 70元给李四, 30元给王五&lt;/code&gt;&lt;p&gt;现在如果李四想给赵六转50元，他可以创建一笔新交易说：用掉交易t1的第一个输出，然后给赵六50元，剩下20元给自己。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
t2 输入: t1的第一个输出
   输出: 50元给赵六, 20元给李四&lt;/code&gt;&lt;p&gt;我们注意到李四需要把20元“找零”转回给自己，因为一个交易输出只能被使用(也就是用作另一笔交易的输入)一次。 这种风格的记账风格就叫做UTxO记账法。UTxO的意思就是未使用的交易输出。&lt;br&gt;而区块链就是许多这种交易组成的一个列表。对应的形式化定义差不多是这样的：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-385e9a3a8afcbc70e354ccb884150264_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;356&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-385e9a3a8afcbc70e354ccb884150264&quot; data-watermark-src=&quot;v2-27b666ed92f78d9db683f5e5b5781a6f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;钱包&lt;/b&gt;&lt;br&gt;虚拟货币的钱包就是一个软件工具，它会监控区块链的状态，跟踪用户的资金（准确的说就是用户的UTxO），也支持往区块链发送新的交易请求。 普通用户主要通过钱包和区块链打交道。至于验证新交易的有效性以及决定是否打包到区块中，这些不是钱包的任务，也就不在本文讨论的范围内了。&lt;br&gt;钱包的形式规范是一个数学抽象，它只关心钱包最核心的功能，忽略无关的细节。在Cardano钱包的基本模型中，我们把钱包状态简化到只包含UTxO以及在途交易(pending transactions)。 这份规范简单到用一张纸就可以写完：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-766bc503452948c5b9e11a2bd3d74511_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;617&quot; data-rawheight=&quot;640&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-766bc503452948c5b9e11a2bd3d74511&quot; data-watermark-src=&quot;v2-6d45dae81f30202678e4f3818db0a7a9&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这个模型很简单，这样才方便进行更深入的研究，也方便提供相关属性的数学证明。 同时又足够精确，可以用来指导钱包的设计，也可以作为单元测试的基础，并驱动真实实现的开发。 他还可以用来研究可能存在的性能问题，以及如何来解决这些问题。&lt;/p&gt;&lt;p&gt;&lt;b&gt;余额&lt;/b&gt;&lt;br&gt;钱包设计中有一些棘手的问题，余额的处理就是其中一个。 你可能觉得在钱包里展示余额应该是一件很简单的事情，但就算在传统银行账户中，也至少存在两种余额。比如张三给李四转100元之后，他的银行账户可能会说：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;你当前余额为1000元&lt;/li&gt;&lt;li&gt;有一笔100元的在途交易，所以你的可用余额为900元&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;和传统银行交易不同，UTxO风格的交易多了一个找零的概念。 这就会产生三个余额的概念。我们还拿前面的t2交易为例，李四的钱包可能会这么汇报他的余额：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;你的可用UTxO为1070元&lt;/li&gt;&lt;li&gt;有一笔在途交易t2，所以你的可用余额为1000元&lt;/li&gt;&lt;li&gt;交易t2会转回20元，所以你的总余额其实是1020元&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;注意t2的找零只有当它被打包进区块链之后才可以使用。&lt;br&gt;目前为止，从钱包设计角度来看，问题还不算复杂，虽然用户界面的展示上可能还需要斟酌一下(要给用户展示哪个余额？)。真正的复杂性来自临时的区块分叉，也就是区块链上对于哪些交易需要被包含进来的分歧（分叉的产生以及如何解决不在本文探讨的范围）。&lt;br&gt;还是继续上面这个例子，假设t2在途，同时又出现了对t1的争议。争议解决后，钱包发现t1不在区块链中了（可能之后还会被重新包含进来）。 这个时候钱包的可用余额还是1000元，但是总余额如果还是1020元是否合理? 毕竟这样的话，总余额就大于可用UTxO了，倒不是说它一定不对，但总觉得不太舒服。&lt;br&gt;所以我们在形式规范中又定义了一个最小余额的概念：账户在各种可能出现的情况下，最小的那个余额。 在这个例子中，就是t1和t2都没有被打包进区块链的情况下，余额最小，为1000元 （注意不可能出现t2生效但t1不生效的情况，因为t2依赖t1）。 这个概念在直觉上似乎可行，但是为了让它更加精确并且可以计算，我们还需要引入另一个概念: ‘“预期UTxO”，也就是钱包期望包含进来但还没有被包含进来的UTxO。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4c4b490444dab11b1a4d6dd21f99bd41_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;357&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-4c4b490444dab11b1a4d6dd21f99bd41&quot; data-watermark-src=&quot;v2-d4096893b8afca0dafb84734f795a8f6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;当然，就算不通过形式化的方法，我们也可以提出最小余额的概念，并且想出对应的算法。但是有这份形式规范可以让我们对这些问题研究地更加透彻，排除掉真实实现过程中周边的细节问题，专注于最核心的概念。&lt;/p&gt;&lt;p&gt;&lt;b&gt;内部一致性：不变量&lt;/b&gt;&lt;br&gt;当我们引入一个像“预期UTxO”这样的新鲜概念的时候，我们怎么知道它是对的？ 其实，既然新概念是我们自己定义的，再问它是否正确没有太大意义，我们应该问的是，它是否有用？&lt;br&gt;回答这个问题的一个办法就是找出不变量。不变量就是永远为真的属性。 比如上面展示的基本模型中就有这样一个不变量：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;不变量3.4 txins pending ⊆ dom utxo&lt;/code&gt;&lt;p&gt;这个不变量是说，在途交易只能使用UTxO中的输出。这一点在直觉上貌似是显然的：钱包不能让用户使用它自己没有的资金。 然而，就像上面展示的，当我们开始考虑临时分叉的时候，这个不变量就不成立了。 李四提交的t2，使用了t1的一个输出，随后t1被回滚，这个时候他就使用了一个不在当前UTxO中的输出了。&lt;br&gt;这个时候我们又需要用上“预期UTxO”的概念了，在完整模型中，这个不变量需要改成这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;不变量7.8 txins pending ⊆ dom (utxo expected)&lt;/code&gt;&lt;p&gt;换句话说，在途交易只能花费UTxO或者预期UTxO。&lt;br&gt;另一个不变量能够帮助我们巩固对“预期UTxO”这个概念的直觉理解： 一个输出不能既在UTxO中也在预期UTxO中。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;不变量7.6 dom utxo 相交 dom expected = ∅&lt;/code&gt;&lt;p&gt;毕竟如果一个预期UTxO出现在当前UTxO里的话就很奇怪了。 列出这样的不变量可以让我们对新概念的直觉理解变得精确， 而证明他们的正确性也能为形式规范的合理性以及内部一致性提供很强的保证。&lt;/p&gt;&lt;p&gt;&lt;b&gt;半形式化开发&lt;/b&gt;&lt;br&gt;形式化地证明上面这样的不变量不光很耗时，还需要专业的数学训练。 如果能够证明他们当然是最完美的，但本文想说的是，尽管我们没有去证明，这个方法依然为我们提供巨大的帮助。 毕竟，我们之所以选择用Haskell编程，就是因为我们可以很容易地在Haskell代码和数学语言之间来回转换。&lt;br&gt;为了把形式规范中的钱包模型翻译成Haskell，我们使用一个在之前文章中介绍过的方法： &lt;a href=&quot;http://www.well-typed.com/blog/2018/03/oop-in-haskell/&quot;&gt;Haskell中的面向对象编程&lt;/a&gt;(我们发明这个方法就是用来干这个的)。下面就是把基本模型翻译到Haskell代码的样子：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;mkWallet :: (Hash h a, Ord a, Buildable st)
         =&amp;gt; Ours a -&amp;gt; Lens&#39; st (State h a) -&amp;gt; WalletConstr h a st
mkWallet ours l self st =
  (mkDefaultWallet (l . statePending) self st) {
      utxo       = st ^. l . stateUtxo
    , ours       = ours
    , applyBlock = \b -&amp;gt; self (st &amp;amp; l %~ applyBlock&#39; ours b)
    }

applyBlock&#39; :: Hash h a
            =&amp;gt; Ours a -&amp;gt; Block h a -&amp;gt; State h a -&amp;gt; State h a
applyBlock&#39; ours b State{..} = State {
    _stateUtxo    = updateUtxo ours b _stateUtxo
  , _statePending = updatePending   b _statePending
  }

updateUtxo :: forall h a. Hash h a
           =&amp;gt; Ours a -&amp;gt; Block h a -&amp;gt; Utxo h a -&amp;gt; Utxo h a
updateUtxo p b = remSpent . addNew
  where
    addNew, remSpent :: Utxo h a -&amp;gt; Utxo h a
    addNew   = utxoUnion (utxoRestrictToOurs p (txOuts b))
    remSpent = utxoRemoveInputs (txIns b)

updatePending :: Hash h a
              =&amp;gt; Block h a -&amp;gt; Pending h a -&amp;gt; Pending h a
updatePending b = Map.filter $ \t -&amp;gt; disjoint (trIns t) (txIns b)&lt;/code&gt;&lt;p&gt;它比形式规范涉及到更多细节；比如它把具体的hash类型和地址类型抽象出去了。虽然它比规范稍微复杂一点，但也很接近了。 它依然是一个模型：没有处理任何网络或者存储方面的问题，可能也不是很高效，等等。也就是说，这个代码还不是真实钱包的设计。 但有这个模型还是有用的，两个原因，一个是我们可以用它来测试真实的钱包，我们会在下一节讨论这个话题； 另一个是我们可以用这个模型来测试不变量。比如下面的代码就是对上面提到的不变量7.8和7.6的Haskell翻译：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pendingInUtxoOrExpected :: WalletInv h a
pendingInUtxoOrExpected l e =
  invariant (l &amp;lt;&amp;gt; &quot;/pendingInUtxoOrExpected&quot;) e $ \w -&amp;gt;
   checkSubsetOf
    (&quot;txins pending&quot;,
      txIns (pending w))
    (&quot;utxo ∪ expected&quot;,
      utxoDomain (utxo w) `Set.union` utxoDomain (expectedUtxo w))

utxoExpectedDisjoint :: WalletInv h a
utxoExpectedDisjoint l e =
  invariant (l &amp;lt;&amp;gt; &quot;/utxoExpectedDisjoint&quot;) e $ \w -&amp;gt;
   checkDisjoint
    (&quot;dom utxo&quot;,
      utxoDomain (utxo w))
    (&quot;dom expected&quot;,
      utxoDomain (expectedUtxo w))&lt;/code&gt;&lt;p&gt;和刚才的钱包实现一样，Haskell代码比对应的形式规范涉及更多细节；比如上面这个代码和形式规范主要区别是可以在不变量不成立时提供详细的错误信息。除此之外，大体上还是对规范的直接翻译。&lt;br&gt;这样做的好处是，我们可以用QuickCheck来测试这些不变量。 我们为钱包生成随机(但有效)的事件（&quot;应用这个区块&quot;，&quot;提交这笔新交易&quot;，&quot;切换到另一个分叉&quot;），然后检查这些不变量在每一个时间点都成立。 比如规范发布第一个版本的时候就有一个低级错误：当钱包收到一个新区块时，它从预期UTxO里把该区块的输入移除了，而不是输出。一个很蠢的错误，但是如果人工审核的话很容易被忽视。 当然，证明的话可以发现这个问题，但是用QuickCheck也可以：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Wallet unit tests
  Test pure wallets
    Using Cardano model FAILED [1]

Failures:

  test/unit/Test/Spec/Models.hs:36:
  1) Wallet unit tests, Test pure wallets, Using Cardano model
       predicate failed on: Invalid [] InvariantViolation {
           name:     full/utxoExpectedDisjoint
         , evidence: NotSubsetOf {
                 dom utxo: ..
               , dom expected: ..
               , dom utxo `intersection` dom expected: ..
             }
         , events:   {
                 state: ..
               , action: ApplyBlock ..
               , state: ..
               , action: NewPending Transaction{ .. }
               , state: ..
               ..
               , action: Rollback
               ..
             }
         }&lt;/code&gt;&lt;p&gt;它不光告诉我们这个不变量不成立了；它还输出了能重现问题的事件序列以及相应的钱包状态（包括所有的中间状态），并且它还显示UTxO和预期UTxO的domain以及他们的交集是什么(他们的交集应该为空，却不为空)。&lt;/p&gt;&lt;p&gt;&lt;b&gt;测试真实的实现&lt;/b&gt;&lt;br&gt;上面说到Haskell对钱包规范的翻译依然是一个模型，其中忽略了大量真实世界的复杂情况，而这些情况是完整的钱包实现必须处理的。 甚至模型中实现的数据类型也是真实版本的简化：交易中没有包含签名，区块只是一个交易列表而不是真实的区块等等。&lt;br&gt;尽管如此，我们还是可以用这个模型实现来测试真实实现。我们可以把简化版的类型转换到真实版本。既然我们已经有了针对简化类型的QuickCheck测试数据生成器，并且我们也已经能够对模型实现进行测试，我们就可以用下图的方式对真实实现进行测试：&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e49e3abe2615f3c7b07cf007c5b6fdaf_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;364&quot; data-rawheight=&quot;128&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e49e3abe2615f3c7b07cf007c5b6fdaf&quot; data-watermark-src=&quot;v2-2c7eae05b244c8e821009930b9afdbb8&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们先用QuickCheck生成器生成简化模型的钱包事件，然后：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在简化类型的测试数据上执行模型实现，然后把结果翻译到真实实现&lt;/li&gt;&lt;li&gt;我们先把测试数据翻译到真实类型，然后执行真实钱包的实现&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们可以比对两条执行路径的结果，如果相同的话，我们就可以认为真实钱包正确地实现了这个模型。 我们在每一步都去验证这一点，加上我们前面保证了模型实现中的不变量在每一步都成立，那么我们就能得出结论：不变量在真实实现中也在每一步都成立。&lt;br&gt;比如，如果真实钱包中有一个bug重复计算了在途交易的找零(比如一笔在途交易使用另一笔在途交易的找零作为输入，这只在分叉的情况下才会出现)，测试用例生成器就会找到一个反例，使得两条执行路径的结果不一致，并且告诉我们导致不一致的具体的钱包事件序列以及相应的钱包状态，以及不一致的具体值。&lt;/p&gt;&lt;p&gt;&lt;b&gt;结论&lt;/b&gt;&lt;br&gt;软件的规范，就算存在，一般也都是些非形式化的文档，使用自然语言描述一下软件预期的功能。 这样的规范不能用来做校验，甚至对测试也用处不大。 另一方面，对所有属性都在数学上加以证明的完整的形式规范，成本很高也很耗时，而且需要相关领域的专家才能搞定。这种做的效果当然是最完美的，但是我们可以有这么一个折中的方案：形式化地描述模型及其属性，然后我们可以用QuickCheck对其属性进行测试。 另外，基于这个模型我们可以对核心功能进行分析，并最终和真实实现进行比对。&lt;br&gt;IOHK对新钱包的开发是开源的，相关代码可以在 &lt;a href=&quot;https://github.com/input-output-hk/cardano-sl/tree/develop/wallet-new&quot;&gt;Github&lt;/a&gt; 上找到。 有趣的是，IOHK最近还招了人去实现Coq版本的钱包规范，这会把整个规范建立在更加坚实的基础之上。当然，这不代表目前的工作就没有意义，虽然这样的话，在模型实现中去测试不变量不再必要，但是有QuickCheck生成器去测试真实实现还是很有价值的。另外，在实际去证明不变量之前先用QuickCheck测试一遍，如果这个不变量确实不成立的话，可以帮助我们提早发现问题，从而节省宝贵的时间。&lt;/p&gt;</description>
<author>黄毅</author>
<guid isPermaLink="false">2018-06-08-37869146</guid>
<pubDate>Fri, 08 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>正则表达式也是可以跑很快哒</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-06-08-37864863.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37864863&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-10a3f5aba455da477af9238bdac697b7_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;亲爱的小伙伴们我又回来写正则表达式的东东啦.&lt;/p&gt;&lt;p&gt;有很多小伙伴觉得正则表达式的执行效率低下, 不如自己写的字符匹配. 其实嘛, 这个问题和引擎的实现关系相当大, 现在的很多通用正则表达式引擎在确保功能性的条件下都是使用NFA引擎, NFA引擎在算法时间复杂度上比DFA引擎要高, 特别是在遇到很多回溯的情况下, 差异尤为显著, 关于NFA引擎的优化就显得十分重要啦. 我在之前的文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32896848&quot;&gt;如何让你的正则表达式拥有更好的性能&lt;/a&gt;里面介绍了一些关于NFA引擎的优化方案, 效果是十分显著哒. 过了一段时间我对我的正则表达式引擎又增加了一些优化流程, 效率更高了. 这里再次拿出来和大家分享.&lt;/p&gt;&lt;p&gt;上一篇文章限制于篇幅没有对优化的流程做很详细的介绍, 只是描述了执行思想, 这里我使用一个具体的例子来为大家讲述我的正则表达式引擎是如何进行静态分析和优化的. &lt;/p&gt;&lt;p&gt;首先呢还是要介绍正则表达式的执行模型, 这个在之前的文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24458116&quot;&gt;正则表达式与AOT编译&lt;/a&gt;和&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32896848&quot;&gt;如何让你的正则表达式拥有更好的性能&lt;/a&gt;里提到过多次啦, 这里对细节不再赘述, 想要了解的小伙伴请看之前的文章吧.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们的执行模型是建立在一个非递归的虚拟机上的. 一个典型的虚拟机有以下几条指令:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;equation&gt;\texttt{match_ch} &lt;/equation&gt; 匹配单个字符, &lt;equation&gt; \texttt{match_range}&lt;/equation&gt; 匹配某个范围的字符(如数字 &lt;equation&gt; \texttt{\d} &lt;/equation&gt; 为 &lt;equation&gt;\texttt{match_range 0, 9}&lt;/equation&gt; )&lt;/li&gt;&lt;li&gt;&lt;equation&gt;\texttt{if_ch}&lt;/equation&gt; 和 &lt;equation&gt;\texttt{if_range} &lt;/equation&gt; 条件分支, 匹配成功或失败时进行跳转, 如 &lt;equation&gt; \texttt{if_ch a, 3, 7} &lt;/equation&gt; 为匹配字符 &lt;equation&gt;\texttt{a} &lt;/equation&gt; 成功跳转至地址 &lt;equation&gt; \texttt{3} &lt;/equation&gt; 否则跳转至地址 &lt;equation&gt; \texttt{7} &lt;/equation&gt; .&lt;/li&gt;&lt;li&gt;&lt;equation&gt;\texttt{split} &lt;/equation&gt; 分裂当前的匹配状态, 使用于分支 &lt;equation&gt; \texttt{a|b} &lt;/equation&gt; , 分裂当前匹配进程, 其中一条进行匹配 &lt;equation&gt;\texttt{a} &lt;/equation&gt; 另一条匹配 &lt;equation&gt; \texttt{b} &lt;/equation&gt; .&lt;/li&gt;&lt;li&gt;&lt;equation&gt;\texttt{split_if_ch} &lt;/equation&gt; 和 &lt;equation&gt;\texttt{split_if_range}&lt;/equation&gt; 条件分裂当前的匹配状态, 匹配成功则进行分裂, 否则直接跳转到后一个地址.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;\texttt{jmp} &lt;/equation&gt; 无条件跳转.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;\texttt{begin, end} &lt;/equation&gt; 匹配锚点, 对应于 &lt;equation&gt; \texttt{^, \$} &lt;/equation&gt; .&lt;/li&gt;&lt;li&gt;&lt;equation&gt;\texttt{inc} &lt;/equation&gt; 向后位移一位, 无条件跳过当前匹配的字符.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;\texttt{accept} &lt;/equation&gt; 匹配成功, &lt;equation&gt;\texttt{halt} &lt;/equation&gt; 匹配失败放弃当前状态.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当然啦, 这个虚拟机模型是为了阐述原理而高度简化的, 不过核心思想是一样哒.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;文章下面使用一个非常典型的正则表达式展示优化过程. IP匹配是正则表达式中比较常见和典型的例子, 表达式为:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{^(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})){3}\$}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这个表达式有点点长, 不过不是很难懂, 我们发现它有四个重复的部分用于匹配0到255的数字, 我们取其中一个进行分析:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2}}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;剩下的部分做一次循环展开后是完全相同的.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;最开始是词法分析, 语法分析, NFA构建和指令生成, 这里不做过多介绍, 我们主要关注的是接下来的优化(想了解的小伙伴可以去看第一篇文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24458116&quot;&gt;正则表达式与AOT编译&lt;/a&gt;).&lt;/p&gt;&lt;p&gt;生成的未优化的指令如下:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split 3, 12}\\ &amp;amp;\texttt{3 match_ch &#39;2&#39;}\\ &amp;amp;\texttt{5 match_ch &#39;5&#39;}\\ &amp;amp;\texttt{7 match_range &#39;0&#39;, &#39;5&#39;}\\ &amp;amp;\texttt{10 jmp 23}\\ &amp;amp;\texttt{12 split 15, 25}\\ &amp;amp;\texttt{15 match_ch &#39;2&#39;}\\ &amp;amp;\texttt{17 match_range 0, 4}\\ &amp;amp;\texttt{20 match_range 0, 9}\\ &amp;amp;\texttt{23 jmp 36}\\ &amp;amp;\texttt{25 split 28, 38}\\ &amp;amp;\texttt{28 match_ch &#39;1&#39;}\\ &amp;amp;\texttt{30 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{33 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{36 jmp 52}\\ &amp;amp;\texttt{38 split 41, 49}\\ &amp;amp;\texttt{41 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{44 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{47 jmp 52}\\ &amp;amp;\texttt{49 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{52 accept} \end{align} &lt;/equation&gt; &lt;/p&gt;&lt;p&gt;接下来开始应用优化&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;跳转合并&lt;/h2&gt;&lt;p&gt;连续的无条件的跳转可以合并为一条跳转指令&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{10 jmp 23}\\ &amp;amp;\texttt{ ...}\\ &amp;amp;\texttt{23 jmp 36}\\ &amp;amp;\texttt{ ...}\\ &amp;amp;\texttt{23 jmp 36}\\ &amp;amp;\texttt{ ...}\\ &amp;amp;\texttt{36 jmp 52}\\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;进行合并后为:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{10 jmp 52}\\ &amp;amp;\texttt{ ...}\\ &amp;amp;\texttt{23 jmp 52}\\ &amp;amp;\texttt{ ...}\\ &amp;amp;\texttt{23 jmp 52}\\ &amp;amp;\texttt{ ...}\\ &amp;amp;\texttt{36 jmp 52}\\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这是一个非常常见的优化啦.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;分支合并&lt;/h2&gt;&lt;p&gt;第一步开始我们发现 &lt;equation&gt;\texttt{25[0-5]|2[0-4][0-9]}&lt;/equation&gt; 中有共同的匹配前缀 &lt;equation&gt;\texttt{2}&lt;/equation&gt; , 将公共表达式提取出来, 即等价于将表达式变换为 &lt;equation&gt;\texttt{2(5[0-5]|[0-4][0-9])}&lt;/equation&gt; , 得到的指令如下:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split 3, 23}\\ &amp;amp;\texttt{3 match_ch &#39;2&#39;}\\ &amp;amp;\texttt{5 split 8, 15}\\ &amp;amp;\texttt{8 match_ch &#39;5&#39;}\\ &amp;amp;\texttt{10 match_range &#39;0&#39;, &#39;5&#39;}\\ &amp;amp;\texttt{13 jmp 50}\\ &amp;amp;\texttt{15 match_range &#39;0&#39;, &#39;4&#39;}\\ &amp;amp;\texttt{18 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{21 jmp 50}\\ &amp;amp;\texttt{23 split 26, 36}\\ &amp;amp;\texttt{26 match_ch &#39;1&#39;}\\ &amp;amp;\texttt{ ...}\\ &amp;amp;\texttt{50 accept}\\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;条件分裂/分支&lt;/h2&gt;&lt;p&gt;我们发现如果使用分支之后第一个字符进行提前匹配, 这样可以减少一些不必要的回溯, 例如在第一个字符为1的情况下没必要进入地址为3的分支对2进行匹配, 可以直接跳转到23, 开启条件分支之后的指令如下&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split_if_ch &#39;2&#39;, 4, 23}\\ &amp;amp;\texttt{4 inc}\\ &amp;amp;\texttt{5 if_ch &#39;5&#39; 9, 15}\\ &amp;amp;\texttt{9 inc}\\ &amp;amp;\texttt{10 match_range &#39;0&#39;, &#39;5&#39;}\\ &amp;amp;\texttt{13 jmp 48}\\ &amp;amp;\texttt{15 match_range &#39;0&#39;, &#39;4&#39;}\\ &amp;amp;\texttt{18 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{21 jmp 48}\\ &amp;amp;\texttt{23 split_if_ch &#39;1&#39;, 27, 36}\\ &amp;amp;\texttt{27 inc}\\ &amp;amp;\texttt{28 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{31 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{34 jmp 48}\\ &amp;amp;\texttt{36 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{39 if_range &#39;0&#39;, &#39;9&#39;, 44, 48}\\ &amp;amp;\texttt{44 inc}\\ &amp;amp;\texttt{48 accept}\\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;注意在例如 &lt;equation&gt;\texttt{0 split_if_ch &#39;2&#39;, 4, 23}&lt;/equation&gt; 匹配成功进入分支之后我们无需再匹配一次 &lt;equation&gt;\texttt{2}&lt;/equation&gt; , 因为由 &lt;equation&gt;\texttt{split_if_ch}&lt;/equation&gt; 的条件知道当前字符 &lt;equation&gt;\texttt{2}&lt;/equation&gt; 一定匹配, 所以将 &lt;equation&gt;\texttt{match_ch &#39;2&#39;}&lt;/equation&gt; 替换为 &lt;equation&gt;\texttt{inc}&lt;/equation&gt; 直接跳过当前字符, 减少一次重复匹配.&lt;/p&gt;&lt;p&gt;在分支9和15上, 即对应表达式 &lt;equation&gt;\texttt{5[0-5]|[0-4][0-9]}&lt;/equation&gt; , 我们知道这两个表达式匹配的第一个字符没有相交, 所以不需要分裂状态, 直接使用条件分支 &lt;equation&gt;\texttt{if_ch &#39;5&#39; 9, 15}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;在分支44和47上, 若匹配 &lt;equation&gt;\texttt{[0-9]}&lt;/equation&gt; 成功后匹配成功, 不需要回溯, 即可使用条件分支.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;分支分析&lt;/h2&gt;&lt;p&gt;在有了条件分裂和分支的信息之后我们可以对连续的条件分裂进行分析, 减少重复匹配.&lt;/p&gt;&lt;p&gt;例如:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split_if_ch &#39;2&#39;, 4, 23}\\ &amp;amp;\texttt{ ...}\\ &amp;amp;\texttt{23 split_if_ch &#39;1&#39;, 27, 36}\\ &amp;amp;\texttt{ ...}\\ &amp;amp;\texttt{36 match_range &#39;0&#39;, &#39;9&#39;}\\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;在这里我们知道如果进入了分支 &lt;equation&gt;\texttt{2}&lt;/equation&gt; 后匹配失败了, 例如匹配 &lt;equation&gt;\texttt{27}&lt;/equation&gt; , 那么回溯之后会到地址23上, 进行匹配 &lt;equation&gt;\texttt{1}&lt;/equation&gt; , 但是我们已经知道第一个字符匹配了 &lt;equation&gt;\texttt{2}&lt;/equation&gt; , 这里的匹配一定会失败, 将直接跳转到地址36, 故可以使用条件分支进行更细致的状态分裂.&lt;/p&gt;&lt;p&gt;变换后的指令如下:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 if_ch &#39;2&#39;, 4, 26}\\ &amp;amp;\texttt{4 split 7, 39}\\ &amp;amp;\texttt{7 inc}\\ &amp;amp;\texttt{8 if_ch &#39;5&#39; 8, 15}\\ &amp;amp;\texttt{12 inc}\\ &amp;amp;\texttt{15 match_range &#39;0&#39;, &#39;5&#39;}\\ &amp;amp;\texttt{16 jmp 21}\\ &amp;amp;\texttt{18 match_range &#39;0&#39;, &#39;4&#39;}\\ &amp;amp;\texttt{21 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{24 jmp 50}\\ &amp;amp;\texttt{26 split_if_ch &#39;1&#39;, 30, 39}\\ &amp;amp;\texttt{30 inc}\\ &amp;amp;\texttt{31 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{34 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{37 jmp 50}\\ &amp;amp;\texttt{39 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{42 if_range &#39;0&#39;, &#39;9&#39;, 47, 48}\\ &amp;amp;\texttt{47 inc}\\ &amp;amp;\texttt{48 accept}\\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;留意对 &lt;equation&gt;\texttt{2}&lt;/equation&gt; 的匹配成功与失败的分支的不同.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;分支延迟&lt;/h2&gt;&lt;p&gt;在上一步分析中我们得到了:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 if_ch &#39;2&#39;, 4, 26}\\ &amp;amp;\texttt{4 split 7, 39}\\ &amp;amp;\texttt{7 inc}\\ &amp;amp;\texttt{ ...}\\ &amp;amp;\texttt{39 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{ ...}\\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;在执行地址4的 &lt;equation&gt;\texttt{split 7, 39}&lt;/equation&gt; 时已经匹配了字符 &lt;equation&gt;\texttt{2}&lt;/equation&gt; 另外一条分支39中立即进行匹配的是&lt;equation&gt;\texttt{[0-9]}&lt;/equation&gt;, 由于 &lt;equation&gt;\texttt{2}&lt;/equation&gt; 是 &lt;equation&gt;\texttt{[0-9]}&lt;/equation&gt; 的子集, 若该分支匹配失败进行回溯, 那么回溯后的 &lt;equation&gt;\texttt{match_range &#39;0&#39;, &#39;9&#39;}&lt;/equation&gt; 将会一定匹配成功, 这时便可将 &lt;equation&gt;\texttt{split}&lt;/equation&gt; 推迟到 &lt;equation&gt;\texttt{inc}&lt;/equation&gt; 之后, 得到的指令如下:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 if_ch &#39;2&#39;, 4, 26}\\ &amp;amp;\texttt{4 inc}\\ &amp;amp;\texttt{5 split 8, 42}\\ &amp;amp;\texttt{8 if_ch &#39;5&#39; 8, 15}\\ &amp;amp;\texttt{12 inc}\\ &amp;amp;\texttt{ ...}\\ &amp;amp;\texttt{39 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{42 if_range &#39;0&#39;, &#39;9&#39;, 44, 48}\\ &amp;amp;\texttt{47 inc}\\ &amp;amp;\texttt{48 accept}\\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt; 在接下来的条件分支 &lt;equation&gt;\texttt{if_ch &#39;5&#39; 8, 15}&lt;/equation&gt; 中, 可以将该分支42推迟进入8和15中, 进一步延迟分支, 对于分支 &lt;equation&gt;\texttt{split_if_ch &#39;1&#39;, 30, 39}&lt;/equation&gt; 亦可进行同样的操作, 得到的指令如下:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{ ...}\\ &amp;amp;\texttt{26 if_ch &#39;1&#39;, 30, 39}\\ &amp;amp;\texttt{30 inc}\\ &amp;amp;\texttt{31 split 31, 42}\\ &amp;amp;\texttt{34 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{37 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{40 jmp 50}\\ &amp;amp;\texttt{42 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{45 if_range &#39;0&#39;, &#39;9&#39;, 44, 48}\\ &amp;amp;\texttt{50 inc}\\ &amp;amp;\texttt{51 accept}\\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;对于 &lt;equation&gt;\texttt{1}&lt;/equation&gt; 和 &lt;equation&gt;\texttt{2}&lt;/equation&gt; 的两条分支仍然可以继续向后推迟分支. 直到无法继续推迟为止, 我们得到了高度优化的指令:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 if_ch &#39;2&#39;, 4, 30}\\ &amp;amp;\texttt{4 inc}\\ &amp;amp;\texttt{5 if_ch &#39;5&#39;, 9, 17}\\ &amp;amp;\texttt{9 inc}\\ &amp;amp;\texttt{10 if_range &#39;0&#39;, &#39;5&#39;, 15, 57}\\ &amp;amp;\texttt{15 inc}\\ &amp;amp;\texttt{16 accept}\\ &amp;amp;\texttt{17 if_range &#39;0&#39;, &#39;4&#39;, 22, 51}\\ &amp;amp;\texttt{22 inc}\\ &amp;amp;\texttt{23 if_range &#39;0&#39;, &#39;9&#39;, 28, 57}\\ &amp;amp;\texttt{28 inc}\\ &amp;amp;\texttt{29 accept}\\ &amp;amp;\texttt{30 if_ch &#39;1&#39;, 34, 48}\\ &amp;amp;\texttt{34 inc}\\ &amp;amp;\texttt{35 if_range &#39;0&#39;, &#39;9&#39;, 40, 57}\\ &amp;amp;\texttt{40 inc}\\ &amp;amp;\texttt{41 if_range &#39;0&#39;, &#39;9&#39;, 46, 57}\\ &amp;amp;\texttt{46 inc}\\ &amp;amp;\texttt{47 accept}\\ &amp;amp;\texttt{48 match_range &#39;0&#39;, &#39;9&#39;}\\ &amp;amp;\texttt{51 if_range &#39;0&#39;, &#39;9&#39;, 56, 57}\\ &amp;amp;\texttt{56 inc}\\ &amp;amp;\texttt{57 accept}\\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这里还有一个小优化就是把直接跳转到 &lt;equation&gt;\texttt{accept}&lt;/equation&gt; 的 &lt;equation&gt;\texttt{jmp}&lt;/equation&gt; 指令全部替换为 &lt;equation&gt;\texttt{accept}&lt;/equation&gt; 这样可以节省一条跳转指令.&lt;/p&gt;&lt;p&gt;注意啦, 优化完成后的指令是不含回退的, 一次性匹配, 效率是非常高的. 另外这一份指令很容易自动翻译成C++代码进行AOT编译进一步提升效率.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;到这里当然少不了的就是benchmark啦, 接下来是激动人心的时刻哈哈哈, 来看看优化后的指令和其他正则表达式库的效率对比吧:&lt;/p&gt;&lt;p&gt;这里我选了PCRE和RE2作为对比:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Test case 
RegExp ^(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})(?:\.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})){3}$
Match 222.34.191.23

My implement
VM:        7.1625 ns
C++ AOT:   1.1776 ns

Comparison
PCRE2:     28.5163 ns
PCRE2 JIT: 4.6530  ns
RE2:       13.7799 ns&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0921073e533644b7310b60d774c11a86_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1036&quot; data-rawheight=&quot;659&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0921073e533644b7310b60d774c11a86&quot; data-watermark-src=&quot;v2-266bd0a5d3800f90d51d0c729775f864&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;可以看到使用C++编译执行是PCRE2 JIT的3倍多的效率, 这份代码的效率已经非常接近甚至可以说等于手工编写的自动机了, 就算是通过VM解释执行的效率也不错, 达到了PCRE2 JIT的64%.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;最后就是C++与VM实现的源码啦: &lt;/p&gt;&lt;p&gt;其中的byte code都是自动生成的.&lt;/p&gt;&lt;p&gt;VM解释执行:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;

#define MINI_REGEX_MAX_STACK_SIZE 256

enum BYTE_CODE : size_t
{
	MATCH_CH,
	MATCH_RANGE,
	IF_CH,
	IF_RANGE,
	INC,
	BEGIN,
	END,
	SPLIT,
	JMP,
	ACCEPT,
	HALT,
};

const std::vector&amp;lt;size_t&amp;gt; byte_code =
{
/*addr_0  */ BEGIN,
/*addr_1  */ IF_CH, &#39;2&#39;, 5, 33,
/*addr_5  */ INC,
/*addr_6  */ IF_CH, &#39;5&#39;, 10, 19,
/*addr_10 */ INC,
/*addr_11 */ IF_RANGE, &#39;0&#39;, &#39;5&#39;, 16, 61,
/*addr_16 */ INC,
/*addr_17 */ JMP, 61,
/*addr_19 */ IF_RANGE, &#39;0&#39;, &#39;4&#39;, 24, 55,
/*addr_24 */ INC,
/*addr_25 */ IF_RANGE, &#39;0&#39;, &#39;9&#39;, 30, 61,
/*addr_30 */ INC,
/*addr_31 */ JMP, 61,
/*addr_33 */ IF_CH, &#39;1&#39;, 37, 52,
/*addr_37 */ INC,
/*addr_38 */ IF_RANGE, &#39;0&#39;, &#39;9&#39;, 43, 61,
/*addr_43 */ INC,
/*addr_44 */ IF_RANGE, &#39;0&#39;, &#39;9&#39;, 49, 61,
/*addr_49 */ INC,
/*addr_50 */ JMP, 61,
/*addr_52 */ MATCH_RANGE, &#39;0&#39;, &#39;9&#39;,
/*addr_55 */ IF_RANGE, &#39;0&#39;, &#39;9&#39;, 60, 61,
/*addr_60 */ INC,
/*addr_61 */ MATCH_CH, &#39;.&#39;,
/*addr_63 */ IF_CH, &#39;2&#39;, 67, 95,
/*addr_67 */ INC,
/*addr_68 */ IF_CH, &#39;5&#39;, 72, 81,
/*addr_72 */ INC,
/*addr_73 */ IF_RANGE, &#39;0&#39;, &#39;5&#39;, 78, 123,
/*addr_78 */ INC,
/*addr_79 */ JMP, 123,
/*addr_81 */ IF_RANGE, &#39;0&#39;, &#39;4&#39;, 86, 117,
/*addr_86 */ INC,
/*addr_87 */ IF_RANGE, &#39;0&#39;, &#39;9&#39;, 92, 123,
/*addr_92 */ INC,
/*addr_93 */ JMP, 123,
/*addr_95 */ IF_CH, &#39;1&#39;, 99, 114,
/*addr_99 */ INC,
/*addr_100*/ IF_RANGE, &#39;0&#39;, &#39;9&#39;, 105, 123,
/*addr_105*/ INC,
/*addr_106*/ IF_RANGE, &#39;0&#39;, &#39;9&#39;, 111, 123,
/*addr_111*/ INC,
/*addr_112*/ JMP, 123,
/*addr_114*/ MATCH_RANGE, &#39;0&#39;, &#39;9&#39;,
/*addr_117*/ IF_RANGE, &#39;0&#39;, &#39;9&#39;, 122, 123,
/*addr_122*/ INC,
/*addr_123*/ MATCH_CH, &#39;.&#39;,
/*addr_125*/ IF_CH, &#39;2&#39;, 129, 157,
/*addr_129*/ INC,
/*addr_130*/ IF_CH, &#39;5&#39;, 134, 143,
/*addr_134*/ INC,
/*addr_135*/ IF_RANGE, &#39;0&#39;, &#39;5&#39;, 140, 185,
/*addr_140*/ INC,
/*addr_141*/ JMP, 185,
/*addr_143*/ IF_RANGE, &#39;0&#39;, &#39;4&#39;, 148, 179,
/*addr_148*/ INC,
/*addr_149*/ IF_RANGE, &#39;0&#39;, &#39;9&#39;, 154, 185,
/*addr_154*/ INC,
/*addr_155*/ JMP, 185,
/*addr_157*/ IF_CH, &#39;1&#39;, 161, 176,
/*addr_161*/ INC,
/*addr_162*/ IF_RANGE, &#39;0&#39;, &#39;9&#39;, 167, 185,
/*addr_167*/ INC,
/*addr_168*/ IF_RANGE, &#39;0&#39;, &#39;9&#39;, 173, 185,
/*addr_173*/ INC,
/*addr_174*/ JMP, 185,
/*addr_176*/ MATCH_RANGE, &#39;0&#39;, &#39;9&#39;,
/*addr_179*/ IF_RANGE, &#39;0&#39;, &#39;9&#39;, 184, 185,
/*addr_184*/ INC,
/*addr_185*/ MATCH_CH, &#39;.&#39;,
/*addr_187*/ IF_CH, &#39;2&#39;, 191, 219,
/*addr_191*/ INC,
/*addr_192*/ IF_CH, &#39;5&#39;, 196, 205,
/*addr_196*/ INC,
/*addr_197*/ IF_RANGE, &#39;0&#39;, &#39;5&#39;, 202, 247,
/*addr_202*/ INC,
/*addr_203*/ JMP, 247,
/*addr_205*/ IF_RANGE, &#39;0&#39;, &#39;4&#39;, 210, 241,
/*addr_210*/ INC,
/*addr_211*/ IF_RANGE, &#39;0&#39;, &#39;9&#39;, 216, 247,
/*addr_216*/ INC,
/*addr_217*/ JMP, 247,
/*addr_219*/ IF_CH, &#39;1&#39;, 223, 238,
/*addr_223*/ INC,
/*addr_224*/ IF_RANGE, &#39;0&#39;, &#39;9&#39;, 229, 247,
/*addr_229*/ INC,
/*addr_230*/ IF_RANGE, &#39;0&#39;, &#39;9&#39;, 235, 247,
/*addr_235*/ INC,
/*addr_236*/ JMP, 247,
/*addr_238*/ MATCH_RANGE, &#39;0&#39;, &#39;9&#39;,
/*addr_241*/ IF_RANGE, &#39;0&#39;, &#39;9&#39;, 246, 247,
/*addr_246*/ INC,
/*addr_247*/ END,
/*addr_248*/ ACCEPT,
};

struct state
{
	size_t IP;
	size_t index;
};

std::vector&amp;lt;state&amp;gt; state_stack;

bool match(const std::string&amp;amp; str)
{
	size_t off = 0;
	while (off &amp;lt; str.length())
	{
		state_stack.clear();
		state_stack.push_back({ 0, off++ });

	fail_loop:;
		while (!state_stack.empty() &amp;amp;&amp;amp; state_stack.size() &amp;lt; MINI_REGEX_MAX_STACK_SIZE)
		{
			auto IP = state_stack.back().IP;
			auto index = state_stack.back().index;
			state_stack.pop_back();

		next_loop:;
			switch (byte_code[IP])
			{
			case BYTE_CODE::MATCH_CH:
				if (index &amp;lt; str.length() &amp;amp;&amp;amp; (str[index] == byte_code[IP + 1]))
				{
					index++;
					IP += 2;
					goto next_loop;
				}
				goto fail_loop;
			case BYTE_CODE::MATCH_RANGE:
				if (index &amp;lt; str.length() &amp;amp;&amp;amp; 
					str[index] &amp;gt;= byte_code[IP + 1] &amp;amp;&amp;amp;
					str[index] &amp;lt;= byte_code[IP + 2])
				{
					index++;
					IP += 3;
					goto next_loop;
				}
				goto fail_loop;
			case BYTE_CODE::IF_CH:
				if (index &amp;lt; str.length() &amp;amp;&amp;amp; str[index] == byte_code[IP + 1])
				{
					IP = byte_code[IP + 2];
					goto next_loop;
				}
				else
				{
					IP = byte_code[IP + 3];
					goto next_loop;
				}
			case BYTE_CODE::IF_RANGE:
				if (index &amp;lt; str.length() &amp;amp;&amp;amp; 
					str[index] &amp;gt;= byte_code[IP + 1] &amp;amp;&amp;amp;
					str[index] &amp;lt;= byte_code[IP + 2])
				{
					IP = byte_code[IP + 3];
					goto next_loop;
				}
				else
				{
					IP = byte_code[IP + 4];
					goto next_loop;
				}
			case BYTE_CODE::INC:
				index++;
				IP++;
				goto next_loop;
			case BYTE_CODE::BEGIN:
				if (index == 0)
				{
					IP++;
					goto next_loop;
				}
				goto fail_loop;
			case BYTE_CODE::END:
				if (index == str.length())
				{
					IP++;
					goto next_loop;
				}
				goto fail_loop;
			case BYTE_CODE::SPLIT:
				state_stack.push_back({ byte_code[IP + 2], index });
				IP = byte_code[IP + 1];
				goto next_loop;
			case BYTE_CODE::JMP:
				IP = byte_code[IP + 1];
				goto next_loop;
			case BYTE_CODE::ACCEPT:
				return true;
			case BYTE_CODE::HALT:
			default:
				return false;
			}
		}
	}
	return false;
}&lt;/code&gt;&lt;p&gt;(这个虚拟机的实现还有优化空间, 例如使用direct threading优化指令分发, 大概还能快10%)&lt;/p&gt;&lt;p&gt;C++编译执行:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;#include &amp;lt;string&amp;gt;

#define MATCH_CH(CH) \
	do { \
		if(!(index &amp;lt; str.length() &amp;amp;&amp;amp; str[index] == CH)) \
			return false; \
		index++; \
	} while(0)

#define MATCH_RANGE(CH1, CH2) \
	do { \
		if(!(index &amp;lt; str.length() &amp;amp;&amp;amp; str[index] &amp;gt;= CH1 &amp;amp;&amp;amp; str[index] &amp;lt;= CH2)) \
			return false; \
		index++; \
	} while(0)

#define IF_CH(CH, THEN, ELSE) \
	do { \
		if(index &amp;gt;= str.length() || str[index] != CH) \
			goto ELSE; \
		else \
			goto THEN; \
	} while(0)

#define IF_RANGE(CH1, CH2, THEN, ELSE) \
	do { \
		if(index &amp;gt;= str.length() || str[index] &amp;lt; CH1 || str[index] &amp;gt; CH2) \
			goto ELSE; \
		else \
			goto THEN; \
	} while(0)

#define JMP(TO) \
	do { \
		goto TO; \
	} while(0)

#define INC() \
	do { \
		index++; \
	} while(0)

#define BEGIN() \
	do { \
		if(index != 0) \
			return false; \
	} while(0)

#define END() \
	do { \
		if(index != str.length()) \
			return false; \
	} while(0)

#define ACCEPT() \
	return true; 

bool match(const std::string&amp;amp; str)
{
	std::string::size_type index = 0;

addr_0  : BEGIN();
addr_1  : IF_CH(&#39;2&#39;, addr_5, addr_33);
addr_5  : INC();
addr_6  : IF_CH(&#39;5&#39;, addr_10, addr_19);
addr_10 : INC();
addr_11 : IF_RANGE(&#39;0&#39;, &#39;5&#39;, addr_16, addr_61);
addr_16 : INC();
addr_17 : JMP(addr_61);
addr_19 : IF_RANGE(&#39;0&#39;, &#39;4&#39;, addr_24, addr_55);
addr_24 : INC();
addr_25 : IF_RANGE(&#39;0&#39;, &#39;9&#39;, addr_30, addr_61);
addr_30 : INC();
addr_31 : JMP(addr_61);
addr_33 : IF_CH(&#39;1&#39;, addr_37, addr_52);
addr_37 : INC();
addr_38 : IF_RANGE(&#39;0&#39;, &#39;9&#39;, addr_43, addr_61);
addr_43 : INC();
addr_44 : IF_RANGE(&#39;0&#39;, &#39;9&#39;, addr_49, addr_61);
addr_49 : INC();
addr_50 : JMP(addr_61);
addr_52 : MATCH_RANGE(&#39;0&#39;, &#39;9&#39;);
addr_55 : IF_RANGE(&#39;0&#39;, &#39;9&#39;, addr_60, addr_61);
addr_60 : INC();
addr_61 : MATCH_CH(&#39;.&#39;);
addr_63 : IF_CH(&#39;2&#39;, addr_67, addr_95);
addr_67 : INC();
addr_68 : IF_CH(&#39;5&#39;, addr_72, addr_81);
addr_72 : INC();
addr_73 : IF_RANGE(&#39;0&#39;, &#39;5&#39;, addr_78, addr_123);
addr_78 : INC();
addr_79 : JMP(addr_123);
addr_81 : IF_RANGE(&#39;0&#39;, &#39;4&#39;, addr_86, addr_117);
addr_86 : INC();
addr_87 : IF_RANGE(&#39;0&#39;, &#39;9&#39;, addr_92, addr_123);
addr_92 : INC();
addr_93 : JMP(addr_123);
addr_95 : IF_CH(&#39;1&#39;, addr_99, addr_114);
addr_99 : INC();
addr_100: IF_RANGE(&#39;0&#39;, &#39;9&#39;, addr_105, addr_123);
addr_105: INC();
addr_106: IF_RANGE(&#39;0&#39;, &#39;9&#39;, addr_111, addr_123);
addr_111: INC();
addr_112: JMP(addr_123);
addr_114: MATCH_RANGE(&#39;0&#39;, &#39;9&#39;);
addr_117: IF_RANGE(&#39;0&#39;, &#39;9&#39;, addr_122, addr_123);
addr_122: INC();
addr_123: MATCH_CH(&#39;.&#39;);
addr_125: IF_CH(&#39;2&#39;, addr_129, addr_157);
addr_129: INC();
addr_130: IF_CH(&#39;5&#39;, addr_134, addr_143);
addr_134: INC();
addr_135: IF_RANGE(&#39;0&#39;, &#39;5&#39;, addr_140, addr_185);
addr_140: INC();
addr_141: JMP(addr_185);
addr_143: IF_RANGE(&#39;0&#39;, &#39;4&#39;, addr_148, addr_179);
addr_148: INC();
addr_149: IF_RANGE(&#39;0&#39;, &#39;9&#39;, addr_154, addr_185);
addr_154: INC();
addr_155: JMP(addr_185);
addr_157: IF_CH(&#39;1&#39;, addr_161, addr_176);
addr_161: INC();
addr_162: IF_RANGE(&#39;0&#39;, &#39;9&#39;, addr_167, addr_185);
addr_167: INC();
addr_168: IF_RANGE(&#39;0&#39;, &#39;9&#39;, addr_173, addr_185);
addr_173: INC();
addr_174: JMP(addr_185);
addr_176: MATCH_RANGE(&#39;0&#39;, &#39;9&#39;);
addr_179: IF_RANGE(&#39;0&#39;, &#39;9&#39;, addr_184, addr_185);
addr_184: INC();
addr_185: MATCH_CH(&#39;.&#39;);
addr_187: IF_CH(&#39;2&#39;, addr_191, addr_219);
addr_191: INC();
addr_192: IF_CH(&#39;5&#39;, addr_196, addr_205);
addr_196: INC();
addr_197: IF_RANGE(&#39;0&#39;, &#39;5&#39;, addr_202, addr_247);
addr_202: INC();
addr_203: JMP(addr_247);
addr_205: IF_RANGE(&#39;0&#39;, &#39;4&#39;, addr_210, addr_241);
addr_210: INC();
addr_211: IF_RANGE(&#39;0&#39;, &#39;9&#39;, addr_216, addr_247);
addr_216: INC();
addr_217: JMP(addr_247);
addr_219: IF_CH(&#39;1&#39;, addr_223, addr_238);
addr_223: INC();
addr_224: IF_RANGE(&#39;0&#39;, &#39;9&#39;, addr_229, addr_247);
addr_229: INC();
addr_230: IF_RANGE(&#39;0&#39;, &#39;9&#39;, addr_235, addr_247);
addr_235: INC();
addr_236: JMP(addr_247);
addr_238: MATCH_RANGE(&#39;0&#39;, &#39;9&#39;);
addr_241: IF_RANGE(&#39;0&#39;, &#39;9&#39;, addr_246, addr_247);
addr_246: INC();
addr_247: END();
addr_248: ACCEPT();
	
	return false;
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;谢谢大家的阅读啦~&lt;/p&gt;&lt;p&gt;代码生成和指令优化器是使用的是我的千雪的生成器和优化器, 其中做了一些小改动.&lt;/p&gt;&lt;p&gt;如果有需要做正则表达式的静态编译的小伙伴欢迎来讨论喔.&lt;/p&gt;</description>
<author>梨梨喵</author>
<guid isPermaLink="false">2018-06-08-37864863</guid>
<pubDate>Fri, 08 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>展望未来</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-06-07-37515535.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37515535&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在我拿起那估计比火箭西决G7三分球命中率还铁的水晶球去预测未来编程语言的走向以前，我想先翻翻我那堆历史书，总结下三条规律。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;0：摩尔定律。GPU，内存，硬盘，网络的指数增长在肉眼可见范围里面还远远没到头。CPU上的增长也还有一段时间 - CPU已经在摩尔定律要凉的论调下已经可持续崩溃式发展了10多年了。如果再假设我们会有基础性进展，这些东西只怕会续命更久。当然，有些常数我们越不过，比如硬盘网络的延迟，还有光速一样，但是没关系。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1：量变引起质变。就如同利威尔阿克曼跟十五米高的进击巨人行动方式有着天壤之别一样，如果一个参数改变了一个数量级，规则跟各种定律都得大改。跟摩尔定律结合起来，这对定律就能多次把不可能化为无聊透顶 - 你手上拿着的手机，在1970年就有原型，而你现在在看着的显示器，在几年前最顶尖的研究所才能量SRI之财力买下几个。时间快进50年，这已经成为人手一抓丢了都不怎么心疼的常见物了。例子远远不止这一个：互联网，个人计算机，甚至计算机，全部都是靠摩尔定律续起来的。软件也是如此 - 打败世界第零的国际象棋AI从‘横竖怎么看反正都不可能’，到‘哈？我手机在这，拿去’之间的差距，除了优化一下暴力搜索以外，就是‘我的硬件快得暴力就能解决问题了’。事实上，暴力搜索已经成为使用计算机的标准操作了 - Intel很早就采用了SAT solver来验证&amp;amp;排电路，Z3出现了10年了，而深度学习需要的计算量一点也不虚这几位。。支撑起这些应用的计算力提升何止兵长变巨人，是成千上百万啊。把现在的计算机跟几十年前的视为同一种东西，比把还在爬的熊孩子跟喷气式飞机对比还离谱，毕竟后者只有100倍速度差。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;2：编译器大法好。Fortran老爹之所以有资格拿图灵奖，是因为天下之间，只有Fortran做出‘跟手写效率在一个数量级的高级编程语言’。在此之前，什么是编程语言？学术界做出的又慢又没用的东西而已。如果我们再把时间往前拨一下，我们甚至可以看到海军准将在跟她上司据理力争‘老大你看，COBOL才不是什么理论上不可能实现的东西，听我说啊’。再启动一下bite the dust呢？我们可以看到老冯在怒斥下属‘你在搞什么，我很angry，怎么可以用汇编器，你浪费了多少CPU cycle你知道吗？’。事实上，在我们黑啥语言效率不如C以前，我们是在黑C效率不如Fortran，Fortran 效率不如汇编，汇编浪费CPU Cycle。这也是为啥我认为计算机科学的理论深度无可比拟 - 计算机实在太难以估摸了，纵使通天彻地如老冯，发明完一套集合论搞量子力学，再转去给计算机发明出一套沿用至今的架构，也无法猜出计算机的最基本用法。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;回到正文。好，我们在开始以前，再看看一个东西：Javascript。我们看看这两个post：&lt;/p&gt;&lt;a href=&quot;https://www.breck-mckye.com/blog/2018/05/why-is-front-end-development-so-unstable/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Why is Front-End Development So Unstable?&lt;/a&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=17191872&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Web frameworks are churn-y because they are incredibly leaky abstractions coveri...&lt;/a&gt;&lt;p&gt;基本上就两个问题。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;0：库太多，不知道用啥&lt;/li&gt;&lt;li&gt;1：Impedance Mismatch。举个例子，当你用LINQ的时候很多不好的事情事情可能发生：你传进LINQ的高阶函数可能无法编译成SQL（用了闭包，或者副作用等），可能无法表示想要的东西（SQL的NULL），可能语义对不上（SQL NULL上的操作不会err而是传递NULL），而最严重的问题是，你要懂SQL。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果我们把上面的三个定律融合一下，这两个问题将不复存在。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;编译器将消除绝大部分的Impedance Mismatch。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们来看看要写出高效，可以处理大量数据的程序，我们需要知道啥：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;分布式计算&lt;/li&gt;&lt;li&gt;数据库&lt;/li&gt;&lt;li&gt;并发编程&lt;/li&gt;&lt;li&gt;GPU&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;而这个Stack里面有什么是必要的？&lt;/p&gt;&lt;p&gt;我们试试看描述每个东西的用途：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;分布式计算保证你的数据有多份储存，提高redundancy，并且提速&lt;/li&gt;&lt;li&gt;数据库效率快，并且保证redundancy&lt;/li&gt;&lt;li&gt;并发编程提高效率&lt;/li&gt;&lt;li&gt;GPU提高效率&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们可以发现，这一切额外的复杂度，其实是为了效率。而既然人类能在写程序的时候推理出如何做这些优化，凭啥编译器推不出来？大不了暴力搜索。靠计算机软件隐藏leaky abstraction又不是没发生过，上古时期码农还得写代码来swap暂时用不上的memory进磁盘呢。&lt;/p&gt;&lt;p&gt;事实上，有些地方，编译器优化就是各种各样暴力搜索，&lt;a href=&quot;https://en.wikipedia.org/wiki/Superoptimization&quot;&gt;Superoptimization - Wikipedia&lt;/a&gt;是， &lt;a href=&quot;https://zhuanlan.zhihu.com/p/37181530&quot;&gt;AutoTVM：让AI来编译优化AI系统底层算子&lt;/a&gt; 是，&lt;a href=&quot;https://facebookresearch.github.io/TensorComprehensions/tutorials/index.html&quot;&gt;Tensor Comprehensions Tutorials&lt;/a&gt; 也是。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://grappa.io/&quot;&gt;自动分布式计算&lt;/a&gt; 有（TensorFlow也应该算），单机并发更不在话下，那还要数据库做啥？数据库的ACID跟recovery，也只是自动分布式计算下的ACID跟recovery，交给自动分布式就好了啊！&lt;/p&gt;&lt;p&gt;当然，如果你眼尖，你会提出一个问题，‘程序的行数，远远比摩尔定律带来的倍数多啊，指数会爆炸啊。’这个问题的答案得益于我们很蠢。笨得一时间只能想起撑死十几个东西。所以我们强迫自己写代码需要写得更模块化，一段代码做一件东西。所以我们抛弃掉goto。&lt;/p&gt;&lt;p&gt;换句话说编译器能对程序一小段一小段的进行推理，最后compose起来。&lt;/p&gt;&lt;p&gt;如果我们激进点，可以假设这个分布式计算网络覆盖了全球，那其实我们就剩下一台计算机了。或者说，到了这个地步，计算机这个词已经过时，我们应该用‘算力’来代表这种无处不在的物体了。至于支付跟安全性问题？我想想。。。区块链？&lt;br&gt;&lt;/p&gt;&lt;p&gt;这还有一个副作用：以后大家写Haskell需要用IO的地方都能去掉一大半了。数据库，并发，网络，通通不需要，连文件也能顺带扫进历史的垃圾桶了‘啥叫读写文件。。。你不能。。用参数吗？’。计算机的三种交互中，计算机&amp;lt;-&amp;gt;计算机会完全消失，计算机&amp;lt;-&amp;gt;人也许会被&lt;a href=&quot;http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability&quot;&gt;Tangible Functional Programming: a modern marriage of usability and composability&lt;/a&gt;代替，那只剩下不常见的计算机&amp;lt;-&amp;gt;机器臂了。The future is superfunctional Aka &lt;a href=&quot;http://conal.net/blog/posts/can-functional-programming-be-liberated-from-the-von-neumann-paradigm&quot;&gt;Can functional programming be liberated from the von Neumann paradigm?&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;既然编译器能做这么多优化，离自动编程还有多远？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;自动编程的尝试有一大堆，Program Synthesis/Genetic Programming/Differentiable Programming等全是。如果限制Domain，也有&lt;a href=&quot;https://cozy.uwplse.org/&quot;&gt;取得不错成绩&lt;/a&gt;的。&lt;/p&gt;&lt;p&gt;这里很重要的一点是，&lt;a href=&quot;https://www.zhihu.com/question/56250357/answer/148934031&quot;&gt;别看到AI，就不成功便成仁，不是没用，就是抢掉我的岗位&lt;/a&gt; - &lt;a href=&quot;https://www.youtube.com/watch?v=er_lLvkklsk&quot;&gt;这些东西完全可以整合进IDE中，提高编程生产力。&lt;/a&gt;&lt;/p&gt;&lt;p&gt;而最近，&lt;a href=&quot;https://blogs.msdn.microsoft.com/visualstudio/2018/05/07/introducing-visual-studio-intellicode/&quot;&gt;微软就在往这个方向前进&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;而我们已经可以在这个5分钟的demo中，看出一下可以怎么extend下去了：最简单的，设一个hotkey，按一下则会选取当前的autocomplete，然后跳到下一个需要写代码的地方（hole）。或者，拿最近历史记录&amp;amp;当前函数名&amp;amp;类型作hint，这样啥也不写也能开始autocomplete。又或者，autocomplete会爬Github，找出最关联的函数，然后给你pull该项目为dependency下来。这样怕啥百万package，我有autocomplete。而这背后需要啥，才能变得实用？啥也不需要，预测准确度一步步提升而已。量变引起质变。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;最后说下我写的时候意料不及的东西&lt;/b&gt;&lt;/p&gt;&lt;p&gt;其实JS这种package management style（相对来说）有点接近&lt;a href=&quot;https://www.zhihu.com/question/266108521&quot;&gt;《Why do we need modules at all?》？&lt;/a&gt; 。当然，没有好的metadata/工具造成的混像我们都看见了。&lt;/p&gt;&lt;p&gt;从另一个角度来看，很巧妙的是，风马牛不相及（Compiler，Pure Function）的东西竟然互相影响了（Autocomplete，Module System）。我认为这是因为一个东西work不work很可能只是有暂时的问题，并不一定是因为从跟不上不可行。而这些问题可能随着某些奇奇怪怪的advance被奇奇怪怪的解决掉。预测未来真难啊。&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2018-06-07-37515535</guid>
<pubDate>Thu, 07 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>第四届函数式编程分享会视频</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-06-04-37649613.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37649613&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;函数式编程入门 (&lt;a href=&quot;http://v.youku.com/v_show/id_XMzY0MTMyODg3Ng==.html&quot;&gt;youku&lt;/a&gt;) by &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0a308ec0bd0ce92754be4e85db62a29a&quot; data-hash=&quot;0a308ec0bd0ce92754be4e85db62a29a&quot; data-hovercard=&quot;p$b$0a308ec0bd0ce92754be4e85db62a29a&quot;&gt;@parker liu&lt;/a&gt; &lt;/li&gt;&lt;li&gt;libuv based IO manager (&lt;a href=&quot;http://v.youku.com/v_show/id_XMzY0MjM3OTU2NA==.html?spm=a2hzp.8253869.0.0&quot;&gt;youku&lt;/a&gt;) by &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/73c168246af1fab79b28736c311466e1&quot; data-hash=&quot;73c168246af1fab79b28736c311466e1&quot; data-hovercard=&quot;p$b$73c168246af1fab79b28736c311466e1&quot;&gt;@韩冬&lt;/a&gt;, 有兴趣可以找他看paper的草稿&lt;/li&gt;&lt;li&gt;HoTT定理证明 (&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37062630&quot;&gt;文章&lt;/a&gt;, &lt;a href=&quot;http://v.youku.com/v_show/id_XMzY0MjY2MTEzMg==.html?spm=a2hzp.8253869.0.0&quot;&gt;youku&lt;/a&gt;) by &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/8e592bf5d153a7c933d8150333b77ef2&quot; data-hash=&quot;8e592bf5d153a7c933d8150333b77ef2&quot; data-hovercard=&quot;p$b$8e592bf5d153a7c933d8150333b77ef2&quot;&gt;@Martin awodey&lt;/a&gt; &lt;/li&gt;&lt;li&gt;范畴上的构造主义 (&lt;a href=&quot;http://v.youku.com/v_show/id_XMzY0MjkxNDU5Ng==.html?spm=a2hzp.8253869.0.0&quot;&gt;下&lt;/a&gt;) by &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0a308ec0bd0ce92754be4e85db62a29a&quot; data-hash=&quot;0a308ec0bd0ce92754be4e85db62a29a&quot; data-hovercard=&quot;p$b$0a308ec0bd0ce92754be4e85db62a29a&quot;&gt;@parker liu&lt;/a&gt; , 上估计还在上传&lt;/li&gt;&lt;li&gt;Haskell 中的类型类实例实现 by &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6676ea444bda2c703add8474963e800a&quot; data-hash=&quot;6676ea444bda2c703add8474963e800a&quot; data-hovercard=&quot;p$b$6676ea444bda2c703add8474963e800a&quot;&gt;@阅千人而惜知己&lt;/a&gt; , 还没上传&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;ppt 都在微信群里, 下不回来了, 各位方便的可以给我个链接&lt;/p&gt;&lt;p&gt;感谢几位的分享 和 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6676ea444bda2c703add8474963e800a&quot; data-hash=&quot;6676ea444bda2c703add8474963e800a&quot; data-hovercard=&quot;p$b$6676ea444bda2c703add8474963e800a&quot;&gt;@阅千人而惜知己&lt;/a&gt; 和 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0a308ec0bd0ce92754be4e85db62a29a&quot; data-hash=&quot;0a308ec0bd0ce92754be4e85db62a29a&quot; data-hovercard=&quot;p$b$0a308ec0bd0ce92754be4e85db62a29a&quot;&gt;@parker liu&lt;/a&gt; 整理视频&lt;/p&gt;</description>
<author>祖与占</author>
<guid isPermaLink="false">2018-06-04-37649613</guid>
<pubDate>Mon, 04 Jun 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
