<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Sat, 03 Mar 2018 13:48:34 +0800</lastBuildDate>
<item>
<title>【综述长文】因果关系是什么？结构因果模型入门</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-02-28-33860572.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33860572&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f8c56dd3e243757fb00744c02ec3cf01_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;i&gt;因果关系是什么？&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;当我们在问「为什么」的时候，我们在问什么？&lt;/i&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;i&gt;Shallow men believe in luck or in circumstance. Strong men believe in cause and effect.&lt;/i&gt; &lt;i&gt;― Ralph Waldo Emerson&lt;/i&gt;&lt;/blockquote&gt;&lt;h2&gt;目录&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;第一章——前言&lt;/b&gt;：用通俗的语言介绍「什么是因果关系？」这一问题的讨论背景，并概括若干个传统的哲学观点，以及和下文的统计因果模型相比，这些传统定义存在的缺陷。&lt;/li&gt;&lt;li&gt;&lt;b&gt;第二章——事件性因果&lt;/b&gt;&lt;/li&gt;&lt;li&gt;2.1. 随机对照试验&lt;/li&gt;&lt;li&gt;2.2. 介入主义的因果观&lt;/li&gt;&lt;li&gt;2.3. 虚拟事实模型（RCM）&lt;/li&gt;&lt;li&gt;2.4. 贝叶斯网络&lt;/li&gt;&lt;li&gt;2.5. 结构方程（SEM）+ 结构因果模型（SCM）&lt;/li&gt;&lt;li&gt;2.6. SCM的反事实推理&lt;/li&gt;&lt;li&gt;&lt;b&gt;第三章——过程性因果&lt;/b&gt;：因果环路图（CLD）与微分方程&lt;/li&gt;&lt;li&gt;&lt;b&gt;第四章——后记&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;除前言外，本文其他部分默认读者已经理解基础概率论（概率、条件概率、贝叶斯定理、随机变量、期望值、相互独立事件）、基础图论（节点、边、有向无环图）、概率图模型初步（贝叶斯网络、d分隔）、统计学基础（随机对照试验）等知识。&lt;/p&gt;&lt;p&gt;另外，本文可以看作Judea Pearl的《Causality》的一篇导读。&lt;/p&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/30f4c8f8f80bd067003f527f67ec43e7&quot; data-hash=&quot;30f4c8f8f80bd067003f527f67ec43e7&quot; data-hovercard=&quot;p$b$30f4c8f8f80bd067003f527f67ec43e7&quot;&gt;@光喻&lt;/a&gt; 。&lt;b&gt;禁止全文转载，大篇幅引用请标注出处并私信告知。&lt;/b&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;一、前言&lt;/h2&gt;&lt;p&gt;因果关系在生活中无处不在。经济、法律、医学、物理、统计、哲学、宗教等众多学科，都与因果的分析密不可分。然而，和其他概念，例如统计的相关性相比，&lt;b&gt;因果（causality）非常难以定义&lt;/b&gt;。利用直觉，我们可以轻易判断日常生活中的因果关系；但是，用清晰、没有歧义的语言准确回答「因果关系是什么？」这个问题，往往超出了常人的能力范围。&lt;/p&gt;&lt;p&gt;（感兴趣的读者，不妨暂停阅读，然后试着给出一个「因果关系」的定义。）&lt;/p&gt;&lt;p&gt;不得不承认，回答这个问题是如此困难，以至于部分哲学家认为，因果关系是不可还原的、最基础的认知公理，无法被用其他方式描述。不过，&lt;b&gt;本文即将描述的众多统计因果模型，将会是针对这一观点的有力反驳。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在知乎上，也有一些对于因果关系的探讨，例如哲学话题下的「&lt;a href=&quot;https://www.zhihu.com/question/20318246&quot;&gt;因果关系是真实存在，还是我们认识世界的一种方法？&lt;/a&gt;」令人遗憾的是，这个问题下的大多数答案，都把重心放在了认知论上，即「如何回应休谟的归纳问题？」以及「我们怎么知道，我们认知的因果关系是可靠的？」大家似乎都默认，「什么是因果关系」是一个琐碎得不需要讨论的前提（但显然并非如此），&lt;b&gt;陷入怀疑论和先验论，从而无法给出一个实用的因果模型&lt;/b&gt;。事实上，&lt;b&gt;因果关系是一个本体论的话题&lt;/b&gt;：我们需要找到一个符合直觉、足够广泛，但也足够具体的&lt;b&gt;定义&lt;/b&gt;来描述因果关系；在此基础之上，我们还需要一套可靠的&lt;b&gt;判定因果的方法&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;常用的统计因果模型都采用了&lt;b&gt;介入主义（interventionism）&lt;/b&gt;的诠释：&lt;b&gt;因果关系的定义依赖于「介入」的概念&lt;/b&gt;；&lt;b&gt;外在的介入是因，产生现象的变化是果&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;在此之前，我们先了解一下其他传统的对于「因果关系」的定义，以及为什么它们不符合直觉。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7c8f73a1d0f267a00f2b4b1c40c45156_r.jpg&quot; data-caption=&quot;大卫·休谟（David Hume）&quot; data-size=&quot;small&quot; data-rawwidth=&quot;757&quot; data-rawheight=&quot;900&quot;&gt;&lt;p&gt;休谟：因果就是「&lt;b&gt;经常性联结&lt;/b&gt;」（constant conjunction）。如果我们观察到，A总是在B之前发生，事件A与事件B始终联结在一起，那么A就导致了B，或者说A是B的原因。&lt;/p&gt;&lt;p&gt;反驳：令A表示公鸡打鸣，令B表示日出。自然条件下，日出之前总有公鸡打鸣，但不会有人认为公鸡打鸣导致了日出。假如我们进行介入，监禁了所有的公鸡，使它们无法打鸣，太阳仍然会照常升起。&lt;/p&gt;&lt;p&gt;在这里，有必要注意一个细节：&lt;/p&gt;&lt;p&gt;大卫·休谟（David Hume，1711年－1776年）。&lt;/p&gt;&lt;p&gt;卡尔·皮尔逊（Karl Pearson，1857年－1936年）。&lt;/p&gt;&lt;p&gt;提出「统计相关性」概念的皮尔逊，比休谟晚出生了一百多年。&lt;/p&gt;&lt;p&gt;&lt;b&gt;我们现在的思维方式，并非是自古以来就存在的：我们眼里理所应当的常识，在古人脑中可能从未出现。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在统计学成为一门严谨的学科、皮尔逊清晰地分离相关性和因果性之前，大多数人都把相关性和因果性混为一谈。即便到了现在，认为相关就代表因果的人也不在少数。&lt;/p&gt;&lt;p&gt;我们没有必要因为休谟的历史地位，就把他下的定义奉为金科玉律。所以，休谟用的经常性联结只能定义相关性，不能定义因果性。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-527cbeca6d5ab2127118ace7d469b087_r.jpg&quot; data-caption=&quot;相关性未必意味着因果性&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;459&quot; data-rawheight=&quot;185&quot;&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;相关性不代表因果性。&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;相关性是对称的，而因果性是不对称的。&lt;/b&gt;如果A是B的原因，那么B是A的结果，但我们绝不会同时说「事件A是事件B的原因，事件A也是事件B的结果」。至于相关性，随机变量X与Y之间的相关性定义为 &lt;equation&gt;\mathrm {corr} (X,Y)={\mathrm {cov} (X,Y) \over \sigma _{X}\sigma _{Y}}={E[(X-\mu _{X})(Y-\mu _{Y})] \over \sigma _{X}\sigma _{Y}}&lt;/equation&gt; ，所以必然有 &lt;equation&gt;\mathrm {corr} (X,Y) = \mathrm {corr} (Y,X)&lt;/equation&gt; 。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;因果关系的不对称性，曾被用于反驳亨佩尔用DN模型定义「科学解释」的做法，但这是属于科学哲学的题外话了。&lt;/p&gt;&lt;p&gt;以上两条直觉，可以反驳以下一系列不使用「介入」概念的因果定义。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;充分因： &lt;equation&gt;A \rightarrow B&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;必然因： &lt;equation&gt;A \leftarrow B&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;朴素的反事实因果： &lt;equation&gt;(A→B)∧(¬A→¬B)&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;加入概率论，用相关性定义因果性。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;一个典型的反例：用事件A表示「冰激凌销量增加」，用B表示「溺水死亡者数量增加」。A与B之间成正相关，但我们都知道，A与B之间不存在因果关系，它们都是由一个共同的因素「夏天」导致的。由此可见，&lt;b&gt;仅仅使用概率统计的工具，并不足以让我们在现实中做出理性的因果推断&lt;/b&gt;。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;INUS条件：原因是&lt;b&gt;I&lt;/b&gt;nsufficient but &lt;b&gt;N&lt;/b&gt;ecessary parts of a condition which is itself &lt;b&gt;U&lt;/b&gt;nnecessary but &lt;b&gt;S&lt;/b&gt;ufficient。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;是INUS条件，但不是原因的例子，并不难构造：闪电、干草堆、消防员玩忽职守、空气干燥都是一场火灾的INUS条件。但是，我们知道闪电和雷声永远符合「如果有闪电，那么必然有雷声」；因此，雷声也是火灾的INUS条件，却不是火灾的原因。&lt;/p&gt;&lt;p&gt;上述一系列模型/定义，都有一个共同的缺陷：给定一个因果关系，这些模型可以完美套用；然而，给定一个此类模型，我们却无法直接确定不同变量之间的因果关系，因为这样的单个模型可以&lt;b&gt;同时描述多种不同的因果、甚至非因果的关系&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;哲学家们看似没有对因果关系提出令人满意的诠释。但是，这至多只是一种流行于哲学爱好者之间的误解。&lt;/b&gt;普通哲学爱好者们在因果关系方面的了解，通常不会超过休谟与康德，能知道刘易斯、必然论、多元主义之类都极为难得。实际上，&lt;b&gt;在统计、经济等领域，已经有大量成熟且投入使用的因果模型，它们准确反映了我们对因果的直觉认识，而且能被精确的数学语言描述。&lt;/b&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;二、事件性因果&lt;/h2&gt;&lt;p&gt;当我们说「A是因，B是对应的果」的时候，A和B可以是什么「东西」？&lt;/p&gt;&lt;p&gt;一般而言，我们认为A和B是某种&lt;b&gt;事件&lt;/b&gt;，而且&lt;b&gt;A必须发生在B之前&lt;/b&gt;。因为「因」必须发生在「果」之前，所以&lt;b&gt;如果A导致了B，那么不可能同时有B导致了A——两个事件无法互为因果&lt;/b&gt;。由此可见，因果关系存在一种&lt;b&gt;不对称性&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;针对「在时间上，因必须先于果」这一条件，哲学家们有过大量的讨论（&lt;a href=&quot;https://plato.stanford.edu/entries/causation-backwards/&quot;&gt;Backward Causation&lt;/a&gt;），其中不少还涉及尖端的量子力学。不过，我们仍然没有理由放弃这一条件。因为，不同的模型有不同的适用范围，而因果模型的适用范围主要是宏观现象、经济、医疗、复杂动力/电路系统，不论微观物理的结论如何，它在已知领域的有效性都不受影响。&lt;/p&gt;&lt;p&gt;有人或许会质疑，为什么两个东西不能互为因果呢？例如，让A1表示草原上羊的数量，让B1表示草原上狼的数量；其他条件不变，狼的增加会导致羊的减少，羊的减少会导致狼的减少，狼的减少会反而导致羊的增加，羊的增加进而导致狼的增加；A1和B1互为因果。&lt;/p&gt;&lt;p&gt;值得注意，A1与B1表示了某种&lt;b&gt;过程&lt;/b&gt;，而不是某些固定时间点上的&lt;b&gt;事件&lt;/b&gt;，所以A1与B1之间完整的因果关系无法用事件性因果表示。所以，对于这种质疑，我有以下几条回应：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;我们可以按照时间顺序，把每个时间点上的A和B拆分为单独的事件，即B1（狼增加）→A1（羊减少）→B2（狼减少）→A2（羊增加）。如此一来，事件性因果也能表达A与B之间的关系。&lt;/li&gt;&lt;li&gt;针对过程性的因果，我们有另一种模型——因果环路图（CLD），将在本文第三章介绍。&lt;/li&gt;&lt;li&gt;&lt;b&gt;过程性因果比事件性因果复杂。&lt;/b&gt;在理解过程性因果模型之前，我们需要先理解更简单的事件性因果模型。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;对于事件性因果，当前最成熟、最广泛的模型是&lt;b&gt;结构因果模型（Structural Causal Model，以下简称SCM）&lt;/b&gt;。SCM结合了结构方程（SEM）、虚拟事实模型（RCM）、概率图模型（主要是贝叶斯网络），并将其应用于因果分析。各类常用因果模型，都可以看作SCM的子类。接下来，我将以RCM、贝叶斯网络、SEM的顺序，按照SCM的发展思路，对其进行详细的介绍。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.1. 随机对照试验&lt;/b&gt;&lt;/p&gt;&lt;p&gt;任何一本初级统计学课本都会提到，基于观测的统计模型无法可靠地识别因果关系。要确定因果关系，必须通过&lt;b&gt;随机对照试验&lt;/b&gt;（Randomized Controlled Trial）。&lt;/p&gt;&lt;p&gt;在一个简单随机对照试验中，试验对象（通常是参加研究的志愿者，下文每一个对象用u表示）会被随机分入两组：&lt;b&gt;实验组&lt;/b&gt;（treatment group，下文用t表示）和&lt;b&gt;对照组&lt;/b&gt;（control group，下文用c表示）。&lt;/p&gt;&lt;p&gt;我们有多种不同的随机分组方式，例如&lt;b&gt;简单随机分组&lt;/b&gt;、&lt;b&gt;随机区组设计&lt;/b&gt;、&lt;b&gt;配对设计&lt;/b&gt;。使用随机区组设计时，研究者会先根据个体的特征（年龄、性别等）将其分入不同的区组，再在每个区组内实施简单随机分组。使用配对设计时，研究者会把在各方面都非常相似的个体（例如双胞胎、不同时间节点的同一个人）配成对，在每一对个体中随机选一个作为实验组，另一个作为对照组。&lt;/p&gt;&lt;p&gt;实验组的对象会接受干预，但对照组的对象不会受到任何干预/介入。在医学实验中，实验组的对象会接受真正的治疗，而对照组的对象只会收到安慰剂。实验结束后，研究者会比较实验组和对照组的结果。&lt;/p&gt;&lt;p&gt;如果我们用Y表示我们感兴趣的结果变量，那么我们可以用以下符号表示随机对照试验的结果：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;equation&gt;Y_c(u)&lt;/equation&gt; 是在对照组条件下，对象u展现出的结果变量Y。&lt;/li&gt;&lt;li&gt;&lt;equation&gt;Y_t(u)&lt;/equation&gt; 是在实验组条件下，对象u展现出的结果变量Y。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在研究中，我们通常会探究 &lt;equation&gt;Y_t(u)&lt;/equation&gt; 是否统计显著地不同于 &lt;equation&gt;Y_c(u)&lt;/equation&gt; 。这一过程涉及较为具体的统计假设检验，与本文的主要内容无关。但是，我们至少可以意识到，&lt;b&gt;t与c的区别是因果关系中的「因」， &lt;equation&gt;Y_t(u)&lt;/equation&gt; 与 &lt;equation&gt;Y_c(u)&lt;/equation&gt; 的区别是因果关系中的「果」&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2. 介入主义的因果观&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在随机对照实验的基础框架上，我们可以建立起一个&lt;b&gt;介入主义（interventionism）&lt;/b&gt;因果观。&lt;/p&gt;&lt;p&gt;一个介入主义的因果模型包括三部分：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;所有的系统 &lt;equation&gt;U&lt;/equation&gt;&lt;/b&gt; ：一个包含所有系统 &lt;equation&gt;u&lt;/equation&gt; 的集合。一个系统 &lt;equation&gt;u&lt;/equation&gt; 我们讨论的对象，可以是人体、机械、星球、化学反应系统、经济实体等。&lt;/li&gt;&lt;li&gt;&lt;b&gt;所有的介入方式 &lt;equation&gt;T&lt;/equation&gt;&lt;/b&gt; ：一个包含所有可能的介入方式 &lt;equation&gt;t&lt;/equation&gt; 的集合。例如，假设我们讨论的系统 &lt;equation&gt;U&lt;/equation&gt; 是一个有两个按钮的黑箱，一个按钮是红色的，另一个按钮是绿色的，那么所有可能的介入方式为 {按红按钮，按绿按钮，两个按钮都按，两个按钮都不按} 。（在这个具体的例子里，根据黑箱的结构不同，可能的介入方式或许不止四种，所以这只是一个经过简化，以便直观理解的模型。）&lt;/li&gt;&lt;li&gt;&lt;b&gt;状态函数 &lt;equation&gt;Y&lt;/equation&gt;&lt;/b&gt; ：输入一个系统 &lt;equation&gt;u&lt;/equation&gt; 和一种介入方式 &lt;equation&gt;t&lt;/equation&gt; ，输出系统的某个状态 &lt;equation&gt;y&lt;/equation&gt; ，写作 &lt;equation&gt;y=Y_t(u)&lt;/equation&gt; 。例如，在一个医疗实验中， &lt;equation&gt;Y&lt;/equation&gt; 可以反映「u（病人甲）在受到干预t（服用降压药）之后的y（血压）」。注意，&lt;b&gt;y不一定要完整描述u的状态的所有部分，只反映几个变量也是可以的&lt;/b&gt;。我们当然可以让y表示某个病人全身所有分子的运动状态，但这类过于复杂的状态函数，往往没有太大的实用价值。可是，在简单电路这样的系统中，完整表达电路每个节点的状态不仅可行，而且有利。因此，在建立因果模型时，我们需要具体问题具体分析，选择一个合适的状态函数。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;值得注意的是，因为「果」的定义涉及到 &lt;equation&gt;Y_t(u)&lt;/equation&gt; 与 &lt;equation&gt;Y_c(u)&lt;/equation&gt; 的区别，而单次介入只说明了t却没有说明c，所以 &lt;b&gt;&lt;equation&gt;T&lt;/equation&gt; 必须包含一种表示「不介入」的介入方式 &lt;equation&gt;c&lt;/equation&gt;&lt;/b&gt; 。也就是说，在一个因果模型中，&lt;b&gt;任何一个系统都必须有一种不受干预的「自然状态」&lt;/b&gt;。如果现实情况过于复杂，很难找到不受干预的自然状态，&lt;b&gt;我们可以把某种介入方式 &lt;equation&gt;c&lt;/equation&gt; 默认为「不介入」&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;因此：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;任意一个介入主义的因果模型，都必须明确指出一种代表「不介入」的介入方式。&lt;/li&gt;&lt;li&gt;当我们在问「为什么发生了现象 &lt;equation&gt;y_1&lt;/equation&gt;」的时候，我们其实在问：「在我对世界建立的因果模型中，自然状态的现象是 &lt;equation&gt;y_0=Y_c(u)&lt;/equation&gt; ，但是我观察到了现象 &lt;equation&gt;y1 \ne y0&lt;/equation&gt; 。于是，我认为实际发生的情况是 &lt;equation&gt;y_1=Y_t(u)&lt;/equation&gt; ，其中 &lt;equation&gt;t \ne c&lt;/equation&gt; 。 &lt;equation&gt;t&lt;/equation&gt; 与 &lt;equation&gt;c&lt;/equation&gt; 之间的区别是什么？」&lt;/li&gt;&lt;li&gt;或者，更简单地说，当我们问「为什么A」的时候，我们往往省略了后半句：「为什么A，而不是B？」&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以知乎搜索「为什么」前几个结果为例，我们可以发现，「默认状态」的思维方式的确无处不在。&lt;/p&gt;&lt;blockquote&gt;例1：&lt;a href=&quot;https://www.zhihu.com/question/58896903&quot;&gt;现在的男生为什么不追女生？&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;默认状态：男生应当追女生。&lt;/p&gt;&lt;blockquote&gt;例2：&lt;a href=&quot;https://www.zhihu.com/question/21128697&quot;&gt;为什么有人会点两百多块一杯的猫屎咖啡？&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;默认状态：一般人不会花两百多块买一杯咖啡。&lt;/p&gt;&lt;p&gt;另一些情形中，两个对话者可能选择了不同的默认状态，便带来了以下的对话：&lt;/p&gt;&lt;p&gt;甲：「你为什么做了A这件事？」（默认「不做A」是自然状态，要求乙为「做A」提供理由）&lt;/p&gt;&lt;p&gt;乙：「为什么不呢？」（默认「做A」是自然状态，把论证的责任转移到甲身上）&lt;/p&gt;&lt;p&gt;在下一部分（2.3），我们将把这一系列直觉发展为正式的虚拟事实模型。&lt;/p&gt;&lt;p&gt;不过，我希望先对&lt;b&gt;格兰杰因果（Granger causality）&lt;/b&gt;做出一些澄清。格兰杰因果的定义：如果得知事件A的发生有助于预测之后的事件B，那么我们说A是B的格兰杰因。然而，格兰杰因果&lt;b&gt;只包含了观测，却没有包含介入&lt;/b&gt;，直接操纵A并不一定能影响B，这与我们日常对因果的直觉不符。所以，格兰杰因果虽然名叫「因果」，却只是一个统计相关性的概念，而非真正的因果概念。在下文中，我不会对格兰杰因果做更多讨论。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3. 虚拟事实模型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;虚拟事实模型&lt;/b&gt;（Rubin Causal Model，简称RCM）由Donald Rubin提出。在RCM中，因果关系「果」的定义是 &lt;equation&gt;\delta(u)=Y_t(u)-Y_c(u)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;在实际生活中，我们考虑的系统往往不止一个——对于某个正在研发的药品，我们最感兴趣的无疑是它在&lt;b&gt;所有目标人群&lt;/b&gt;上的效果，而不仅仅是某个病人甲。继续采用RCM对于因果的定义，那么一个介入「因」对群体内所有个体的「果」是 &lt;equation&gt;E[\delta(u)]=E[Y_t(u)-Y_c(u)]=E[Y_t(u)]-E[Y_c(u)]&lt;/equation&gt; 。（由期望值的线性可得）&lt;/p&gt;&lt;p&gt;在上帝视角下，上述定义并不复杂。即使变量 &lt;equation&gt;y=Y_t(u)&lt;/equation&gt; 不是一个数值变量，我们也可以通过其他方式定义 &lt;equation&gt;\delta(u)&lt;/equation&gt; 。从更广泛的角度考虑，RCM定义中的减法未必是实数域的减法；针对更复杂的变量y（例如张量、概率分布），我们可以采用其他的减法，只要符合数学规范和具体研究需要即可。&lt;/p&gt;&lt;p&gt;可是在实际生活中，我们无法获得完美的信息：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;无法同时知晓 &lt;equation&gt;Y_c(u)&lt;/equation&gt; 与 &lt;equation&gt;Y_t(u)&lt;/equation&gt;&lt;/b&gt; 。由于每个人都是独一无二的，每个时间节点也是独一无二的，所以在受到了一种介入，并表现出新状态之后，这个系统不可能完美恢复到原来的状态，重新接受另一种介入。这种情况被称为「&lt;b&gt;因果推断的根本问题&lt;/b&gt;」（the Fundamental Problem of Causal Inference，以下简称&lt;b&gt;FPCI&lt;/b&gt;）。&lt;/li&gt;&lt;li&gt;&lt;b&gt;无法同时知晓每个个体的情况。&lt;/b&gt;正如在检测手机在极端条件下的质量时，我们不可能去砸坏每一个手机一样，我们只能随机从群体中抽取样本，再利用样本的统计数据推断群体参数。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;「无法同时知晓每个个体」的问题，已经有常规的统计学手段解决。但为了避免FPCI，我们必须对群体参数的分布做出额外的假设，包括但不限于以下的一种或多种：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;个体处理效应稳定假设&lt;/b&gt;（Stable unit treatment value assumption，简称SUTVA）：对于任意个体 &lt;equation&gt;u_1&lt;/equation&gt; 的干预不会影响到另一个任意个体 &lt;equation&gt;u_2&lt;/equation&gt; 的状态。SUTVA使我们可以把样本中每个个体的反应看作独立事件，从而降低了我们需要的样本体积、模型体积和建模时间。&lt;/li&gt;&lt;li&gt;&lt;b&gt;同效果假设&lt;/b&gt;（assumption of constant effect）：&lt;b&gt;对于所有的个体，某种介入方式造成的效果是相同的。&lt;/b&gt;例如，某个降压药对所有人的效果都是降低血压，不会产生增高血压的情况——即使有，也只不过是统计的噪声，可以用大样本、大数定理和中心极限定理消解。于是，我们可以得到 &lt;equation&gt;\hat{\delta}(u)=\bar{Y_t}(u)-\bar{Y_c}(u)&lt;/equation&gt; ，用样本内的平均效果估算这一介入方法对所有个体的因果效果。&lt;/li&gt;&lt;li&gt;&lt;b&gt;同质性假设&lt;/b&gt;（assumption of homogeneity）：&lt;b&gt;对于任意个体 &lt;equation&gt;u_1&lt;/equation&gt; 和 &lt;equation&gt;u_2&lt;/equation&gt; ，以及任意介入方式 &lt;equation&gt;t^*&lt;/equation&gt; ，始终有 &lt;equation&gt;Y_{t^*}(u_1)=Y_{t^*}(u_2)&lt;/equation&gt;&lt;/b&gt; 。&lt;b&gt;同质性假设强于同效果假设。&lt;/b&gt;例如，一个简单的FizzBuzz电脑程序在不同时间点上的性质理应完全相同。虽然在同一时间点上，我们无法同时测试它在不同输入下的输出，但是它在不同时间点上的表现必然相同。如果我们把「不同时间点上的FizzBuzz程序」看作一个群体，那么其中个体「每个时间点上的FizzBuzz程序」均符合同质性假设。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3.1. 虚拟事实模型的不足&lt;/b&gt;&lt;/p&gt;&lt;p&gt;虽然RCM提供了一个可以用数学、统计定义的因果模型，但是它的缺点也很明显：在介入时，我们通常&lt;b&gt;一次只能改变一个变量&lt;/b&gt;，观测的状态也只有一个变量。如果我们增加变量，模型的体积、需要的训练数据、训练时间都将以&lt;b&gt;指数级增长&lt;/b&gt;。在下一部分，我们可以看到，贝叶斯网络先验的条件独立信息可以缓解这一困难。&lt;/p&gt;&lt;p&gt;此外，RCM从自变量的「因」到应变量的「果」的结构&lt;b&gt;几乎完全是个黑箱&lt;/b&gt;，缺乏更清晰的可解释性。因此，单个RCM所能解决的问题也较为有限。相比之下，结构因果模型能为因果律、多变量之间的因果关系提供更详细的解释。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.4. 贝叶斯网络&lt;/b&gt;&lt;/p&gt;&lt;p&gt;贝叶斯网络是一种基于&lt;b&gt;有向无环图（directed acyclic graph，简称DAG）&lt;/b&gt;的概率图模型。虽然贝叶斯网络并不能直接表示因果，只能表示相关，但是它的图结构是SCM的基础。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d9b0f455833ccf4bbf4c94feaca40196_r.jpg&quot; data-caption=&quot;贝叶斯网络示例&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1033&quot; data-rawheight=&quot;875&quot;&gt;&lt;p&gt;在一个贝叶斯网络中，每个节点是一个随机变量，代表一个事件。通常，这个随机变量服从某个离散或连续的分布。一个节点 &lt;equation&gt;X&lt;/equation&gt; 中，储存了给定它的所有父节点 &lt;equation&gt;\mathrm{pa}(X)&lt;/equation&gt; 时 &lt;equation&gt;X&lt;/equation&gt; 的分布，即 &lt;equation&gt;P(X=x|\mathrm{pa}(x))&lt;/equation&gt; 。&lt;equation&gt;\mathrm{pa}(X)&lt;/equation&gt;表示节点X的所有父节点，即所有「拥有直接指向X的有向边」的节点。以上图为例， &lt;equation&gt;\mathrm{pa}(Grade)= \{\textit{Difficulty}, \textit{Intelligence}\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;贝叶斯网络（以及其他所有的概率图模型）相比于原始的联合分布模型，最大的优势在于增加了变量之间&lt;b&gt;条件独立&lt;/b&gt;的先验信息，从而&lt;b&gt;减小了模型的体积，与模型进行推断、学习的时间&lt;/b&gt;。例如，上图共有5个变量，如果用朴素的联合分布模型建模，条件概率表格的体积将会是 &lt;equation&gt;2 \times3\times2\times2\times2=48&lt;/equation&gt; ，而采用贝叶斯网络后，条件概率表格的总体积为 &lt;equation&gt;2 + 2 + 4 \times 2 + 2\times 1 + 3 \times 1 = 17&lt;/equation&gt; 。在小型的网络中，这种简化的效果尚不明显，但在大型网络中，假设每个变量有a种取值，那么联合分布模型的体积将为 &lt;equation&gt;O(a^n)&lt;/equation&gt; ，而一个合适的贝叶斯网络或许能把体积复杂度降低到多项式级别。最极端的情况是朴素贝叶斯，即所有的随机变量均独立，此时模型的体积复杂度为 &lt;equation&gt;O(an)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;条件独立的信息是先验的，它们往往由任务相关的专家提供，而非从数据中学习得到。&lt;/b&gt;这种做法能保证网络结构的可靠。（此处讨论的是parameter learning而非structure learning，网络结构已知而参数未知；对于后者，我们有Chow-Liu算法，但此处不讨论。）之后，我们也会发现，类似的先验因果假设在SCM中有重要地位。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.4.1. d分隔&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-92fbac23e221826585c55d4bddb09255_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;638&quot; data-rawheight=&quot;345&quot;&gt;&lt;p&gt;如图所示，对于一个贝叶斯网络中的三个节点/变量而言，一共有三种基本的结构。两种不同的条件独立假设。用 &lt;equation&gt;X \perp Y&lt;/equation&gt;表示X与Y之间独立：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;cascade&lt;/b&gt;: &lt;equation&gt;A \rightarrow B \rightarrow C&lt;/equation&gt; ，则必有 &lt;equation&gt;(A\perp C)|B&lt;/equation&gt; 以及 &lt;equation&gt;A \not\perp C&lt;/equation&gt; 。&lt;/li&gt;&lt;li&gt;&lt;b&gt;common parent&lt;/b&gt;: &lt;equation&gt;A \leftarrow B \rightarrow C&lt;/equation&gt;，同样有 &lt;equation&gt;(A\perp C)|B&lt;/equation&gt; 以及 &lt;equation&gt;A \not\perp C&lt;/equation&gt; 。&lt;/li&gt;&lt;li&gt;&lt;b&gt;V-structure&lt;/b&gt;: &lt;equation&gt;A \rightarrow B \leftarrow C&lt;/equation&gt; ，必有 &lt;equation&gt;A \perp C&lt;/equation&gt; 与 &lt;equation&gt;(A \not\perp C) | B&lt;/equation&gt; ，与前两种基本结构的条件独立情况不同。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;为了回答「给定一个随机变量的集合Z，随机变量A与B之间是否条件独立」这个问题，我们需要引入d分隔的概念。&lt;b&gt;d分隔（d-separation）&lt;/b&gt;的全名是「有向分隔」（directed separation）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;某个节点集合O能d分隔节点A与节点B，当且仅当：给定O时，A与B之间不存在有效路径（active path）。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对于A与B之间的无向无环路径P，如果P上的每三个连续节点，都符合以下四种情况中的一种，那么P就是一条有效路径：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;X←Y←Z且Y∉O&lt;/li&gt;&lt;li&gt;X→Y→Z且Y∉O&lt;/li&gt;&lt;li&gt;X←Y→Z且Y∉O&lt;/li&gt;&lt;li&gt;X→Y←Z且Y∈O。这种情况被称为&lt;b&gt;伯克森悖论（Berkson&#39;s Paradox）&lt;/b&gt;：当两个独立事件的共同结果被观察到时，这两个独立事件就不再相互独立了。例如，扔两个硬币，硬币A朝上的面和硬币B朝上的面之间，应该是相互独立的；然而，如果我们已知「有一个硬币正面朝上」，那么A与B朝上的面之间就不再相互独立了。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;相应地，&lt;b&gt;如果给定O之后，一条路径P不是一条有效路径&lt;/b&gt;，那么我们称&lt;b&gt;O节点集合 d分隔 了路径P&lt;/b&gt;。d分隔的概念适用于两个节点，也适用于两个节点之间的路径，后者在「后门准则」的定义中非常有用。&lt;/p&gt;&lt;p&gt;如果两个变量没有被d分隔，那么它们之间的状态被称为&lt;b&gt;d联结（d-connection）&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;d分隔能极大简化贝叶斯网络中 &lt;equation&gt;(X\perp Y )| Z&lt;/equation&gt; 等条件独立情况的判定。Pearl将其进一步泛化，提出了&lt;b&gt;拟图（graphoid）&lt;/b&gt;的概念。一个graphoid是一组形如「已知变量Z，则变量X与变量Y相互独立」的陈述，服从以下五条&lt;b&gt;拟图公理&lt;/b&gt;：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-220c102184781b71c753f20ea7e824da_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;901&quot; data-rawheight=&quot;357&quot;&gt;&lt;p&gt;关于graphoid中文翻译的备注：graphoid尚无权威的中文翻译，而且在互联网上几乎没有任何相关的中文材料。我在选择译名时，参考了matroid的翻译。既然matrix是矩阵，而matroid是拟阵，那么graph是图，所以graphoid应该被称为拟图。&lt;/p&gt;&lt;p&gt;拟图的概念只出现在Pearl的著作中。不过，如果我们采用概率论对于「独立事件」的定义，那么我们可以把它们当做定理推导得出，可见概率论的「独立」符合拟图公理体系。当然，intersection的成立需要一个额外条件：针对所有的事件A，如果 &lt;equation&gt;A \ne \emptyset&lt;/equation&gt; ，那么 &lt;equation&gt;P(A)&amp;gt;0&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.4.2. 为什么贝叶斯网络不适合做因果模型？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;有了一个学习完毕的贝叶斯网络后，我们可以用它进行各类推断，主要是概率推断&lt;equation&gt;P(X_i|X_{j_1}, X_{j_2}, X_{j_3}, ..., X_{j_k})&lt;/equation&gt; ：已知 &lt;equation&gt;X_{j_1}, X_{j_2}, X_{j_3}, ..., X_{j_k}&lt;/equation&gt; 等随机变量的值，求另一随机变量 &lt;equation&gt;X_i&lt;/equation&gt; 的条件概率。贝叶斯网络的优越性体现于，&lt;b&gt;即使有大量的缺失、未知变量值，它也能利用边缘化操作，毫无障碍地进行概率推断&lt;/b&gt;。在SCM中，这一功能仍然有相当重要的地位。&lt;/p&gt;&lt;p&gt;如果我们把箭头看作从因指向果，把A→B看作A导致了B，那么贝叶斯网络&lt;b&gt;看起来似乎&lt;/b&gt;能表达因果关系。然而，&lt;b&gt;贝叶斯网络本身无法区分出因果的方向&lt;/b&gt;。例如，A←B←C与A→B→C的因果方向完全相反，但在贝叶斯网络的模型描述下，它们表达的概率分布和条件独立假设完全相同。&lt;/p&gt;&lt;p&gt;此外，概率论「给定/已知随机变量Z」里的&lt;b&gt;「给定/已知」只能用于表达观察，而非介入&lt;/b&gt;。例如，P(下雨|地面是湿的)与P(地面是湿的|下雨)的概率值都很高，其中「给定“地面是湿的”」与「给定“下雨”」&lt;b&gt;都是观察而非介入的结果&lt;/b&gt;。用&lt;b&gt;do(X)表示「介入，使得事件X发生」&lt;/b&gt;，现在考虑另一种情况：P(下雨|do(地面是湿的))。根据直觉，显然P(下雨|do(地面是湿的)) &amp;lt; P(下雨|地面是湿的)，因为把地面弄湿并不能导致下雨。&lt;/p&gt;&lt;p&gt;综上所述，贝叶斯网络虽然十分强大，但无法准确描述因果关系。下文的SEM将主要解决这个问题。在学习贝叶斯网络的过程中，我们也应该尽量避免使用「因果」相关的词语——贝叶斯网络中，A→B未必等同于A导致B。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.5. 结构方程+结构因果模型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;为了表示因果关系，我们需要对贝叶斯网络进行改进。&lt;b&gt;结构方程模型（Structural Equation Model，简称SEM）&lt;/b&gt;在经济与工程领域十分常用。在贝叶斯网络的基础上加入SEM的成分之后，我们就离完善的SCM（结构因果模型）更近了一步。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.5.1. 打破对称性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在贝叶斯网络中，节点 &lt;equation&gt;X&lt;/equation&gt; 的概率分布 &lt;equation&gt;P(X=x|\mathrm{pa}(X))&lt;/equation&gt; 由它的父节点 &lt;equation&gt;\mathrm{pa}(x)&lt;/equation&gt; 决定，记录在一个条件概率表格中。然而，条件概率表格和一些简单的连续概率分布都是&lt;b&gt;可逆&lt;/b&gt;的。例如，对于随机变量 &lt;equation&gt;X&lt;/equation&gt; 和 &lt;equation&gt;Y&lt;/equation&gt; ，如果 &lt;equation&gt;Y=\alpha X + \beta&lt;/equation&gt; ，那么我们可以操纵代数表达式，得到 &lt;equation&gt;X=\frac{Y-\beta}{\alpha}&lt;/equation&gt; 。然而，这种&lt;b&gt;对称性&lt;/b&gt;在因果关系里是&lt;b&gt;不符合直觉&lt;/b&gt;的。对称的代数表达式表明，如果我们改变Y，X就会发生相应的改变；可是，修改温度计的读数并不会改变环境温度，调整闹钟的时针并不会改变真正时间的流动。&lt;/p&gt;&lt;p&gt;因此，在SEM中，我们用&lt;b&gt;函数式&lt;/b&gt;的方程表示某个变量 &lt;equation&gt;X&lt;/equation&gt; ： &lt;equation&gt;X=f_X(\mathrm{pa}(X),\mathrm{u}(X))&lt;/equation&gt; 。其中， &lt;equation&gt;\mathrm{pa}(X)&lt;/equation&gt; 表示X的父节点中的&lt;b&gt;内生变量（endogenous variable）&lt;/b&gt;； &lt;equation&gt;\mathrm{u}(X)&lt;/equation&gt; 表示X的父节点中的&lt;b&gt;外生变量（exogenous variable）&lt;/b&gt;，只有一个。内生变量依赖于其他变量，在SCM中表示为「存在父节点的节点」，即至少有一条边指向该节点；外生变量独立于其他变量，在SCM中表示为「不存在父节点的节点」，即没有边指向该节点。&lt;/p&gt;&lt;p&gt;传统的路径分析研究中， &lt;equation&gt;f_X&lt;/equation&gt; 通常是一个线性函数，因果律的定义也局限与 &lt;equation&gt;Y=\alpha X + \beta&lt;/equation&gt; 中的 &lt;equation&gt;\alpha&lt;/equation&gt; 。但是，在数据越发复杂的现在，我们完全可以采用非线性函数、非参数模型。相对地，「因果」的定义也从路径参数 &lt;equation&gt;\alpha&lt;/equation&gt; 变成了更广义的&lt;b&gt;「变化传递」&lt;/b&gt;，参见前文RCM的部分。作为一个广泛的模型框架，SCM可以产生各式各样的复杂模型。&lt;/p&gt;&lt;p&gt;在最广泛的条件下，函数 &lt;equation&gt;f_X&lt;/equation&gt; 是不可逆的。我们需要把 &lt;equation&gt;X=f_X(\mathrm{pa}(X),\mathrm{u}(X))&lt;/equation&gt; 理解为&lt;b&gt;「（大自然/模型本身）对X的赋值」&lt;/b&gt;，而不仅仅是一个普通的代数等式。SCM要求所有的箭头 &lt;equation&gt;A\to B&lt;/equation&gt; 必须表示「A直接导致B」。所以，在因果推断的过程中，我们必须按照因果箭头的方向进行推理，不能颠倒顺序。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2f59fbad01d5b57d7c151822c14712ac_r.jpg&quot; data-caption=&quot;图1：结构因果模型示意图&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;531&quot; data-rawheight=&quot;138&quot;&gt;&lt;p&gt;如上图所示， &lt;equation&gt;U_X&lt;/equation&gt; 与 &lt;equation&gt;U_Y&lt;/equation&gt; 是外生变量， X与Y是内生变量，X可以导致Y。在图(a)中， &lt;equation&gt;U_X&lt;/equation&gt; 与 &lt;equation&gt;U_Y&lt;/equation&gt; 之间没有边相连，而在图(b)中， &lt;equation&gt;U_X&lt;/equation&gt; 与 &lt;equation&gt;U_Y&lt;/equation&gt; 之间有一条用虚线表示的双向箭头。在SCM里，我们用&lt;b&gt;单向箭头&lt;/b&gt;表达&lt;b&gt;直接的因果关系&lt;/b&gt;，用&lt;b&gt;双向箭头&lt;/b&gt;表明&lt;b&gt;两个外生变量之间可能存在未知的混杂因素&lt;/b&gt;（confounding variable）。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;U_X&lt;/equation&gt; 与 &lt;equation&gt;U_Y&lt;/equation&gt; 等外生变量可以表示「模型没有考虑到的环境噪音」，从而为看似非随机的结构方程模型加入&lt;b&gt;随机的成分&lt;/b&gt;。因此，SEM并非完全确定，它也可以拥有概率、不确定性等特征；SCM比普通的贝叶斯网络更广泛。此外，一个SCM描述了数据的生成原理，而不仅是表面观测到的概率分布，所以SCM比贝叶斯网络更稳定。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.5.2. 介入&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如上文所言，SCM是对于贝叶斯网络的一种泛化。一般的贝叶斯网络可以解答两类问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;条件概率： &lt;equation&gt;P(Y|E=e)&lt;/equation&gt; ，其中Y是我们感兴趣的一组未知变量，E是一组我们&lt;b&gt;观察&lt;/b&gt;到的已知变量，e是我们&lt;b&gt;观察&lt;/b&gt;到的E的值。E可以是空集，代表「我们没有观察到任何变量」。&lt;/li&gt;&lt;li&gt;最大后验概率（MAP）： &lt;equation&gt;\arg\max_{y}{P(Y=y|E=e)}&lt;/equation&gt; ，我们想要找到的是一组最有可能的Y值。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果不考虑算法复杂度，一个能估计条件概率的模型必然能估计MAP，所以下文将只讨论条件概率的情况。&lt;/p&gt;&lt;p&gt;&lt;b&gt;在「观察」的基础上，SCM还能做到「介入」&lt;/b&gt;： &lt;equation&gt;P(Y|E=e, do(X=x))&lt;/equation&gt; 。其中，我们对系统进行介入，迫使一组变量X拥有值x。在X是一个空集的情况下，SCM与普通的贝叶斯网络差别不大。&lt;/p&gt;&lt;p&gt;以下图为例，我将展示SCM实现介入的方法。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bfddee417c2bc99edd58383eae72548c_r.jpg&quot; data-caption=&quot;图2：一个SCM&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;560&quot; data-rawheight=&quot;117&quot;&gt;&lt;p&gt;在这个SCM中，变量X、Y、Z之间的关系可以用以下的结构方程表示：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;equation&gt;Z=f_Z(U_Z)&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;&lt;equation&gt;X=f_X(Z, U_X)&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;&lt;equation&gt;Y=f_Y(X, U_Y)&lt;/equation&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在此模型中，我们假设 &lt;equation&gt;U_X&lt;/equation&gt; 与 &lt;equation&gt;U_Y&lt;/equation&gt; 与 &lt;equation&gt;U_Z&lt;/equation&gt; 这三个外生变量独立。所以，图(a)与图(b)中的 &lt;equation&gt;U_X&lt;/equation&gt; 与 &lt;equation&gt;U_Y&lt;/equation&gt; 与 &lt;equation&gt;U_Z&lt;/equation&gt; 之间均没有边相连。&lt;/p&gt;&lt;p&gt;如图(b)所示，当我们进行介入 &lt;equation&gt;do(X=x_0)&lt;/equation&gt; 时，我们&lt;b&gt;切断了所有指向X的边，并将X赋值为 &lt;equation&gt;x_0&lt;/equation&gt;&lt;/b&gt; 。于是，新的SCM包括了一套新的结构方程：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;equation&gt;Z=f_Z(U_Z)&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;&lt;equation&gt;X=x_0&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;&lt;equation&gt;Y=f_Y(X, U_Y)&lt;/equation&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;b&gt;综上所述，一个SCM（写作&lt;/b&gt; &lt;equation&gt;M_1&lt;/equation&gt; &lt;b&gt;）估计 &lt;equation&gt;P_{M_1}(Y|E=e,do(X=x))&lt;/equation&gt; 的方式为：完成对原有模型 &lt;equation&gt;M_1&lt;/equation&gt; 的介入 &lt;equation&gt;do(X=x)&lt;/equation&gt; 之后，得到一个新的模型&lt;/b&gt; &lt;equation&gt;M_2&lt;/equation&gt; &lt;b&gt;。随后，在 &lt;equation&gt;M_2&lt;/equation&gt; 上估计 &lt;equation&gt;P_{M_2}(Y|E=e)&lt;/equation&gt; 。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;有人可能会产生疑问：「观察和介入，有什么本质区别吗？」&lt;/p&gt;&lt;p&gt;一个日常例子式的回答如下：&lt;/p&gt;&lt;p&gt;用A代表「环境温度」，用B代表「温度计读数」，A与B之间的因果关系为 &lt;equation&gt;A \to B&lt;/equation&gt; 。在默认状态下，温度计不会受到外在干预。因此，&lt;b&gt;观察&lt;/b&gt;到温度计读数升高，我们可以推断出环境温度升高。但是，当我们直接干预温度计时（例如用手握住温度计），我们进行了&lt;b&gt;介入&lt;/b&gt; &lt;equation&gt;do(B=b_1)&lt;/equation&gt; ，使温度计的读数变成了 &lt;equation&gt;b_1&lt;/equation&gt; ；同时，因为是介入而非观察，&lt;b&gt;从A到B的因果箭头被切断了&lt;/b&gt;，我们有 &lt;equation&gt;A\not\to B&lt;/equation&gt; 或 &lt;equation&gt;A \ \ \ \ \ B&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;假设 &lt;equation&gt;b_1&lt;/equation&gt; 是一个较高的温度，那么 &lt;equation&gt;P(A=b_1|B=b_1)&lt;/equation&gt; 代表「在自然状态下，观察到温度计的读数是 &lt;equation&gt;b_1&lt;/equation&gt; 时，实际的环境温度为 &lt;equation&gt;b_1&lt;/equation&gt; 的概率」； &lt;equation&gt;P(A=b_1|do(B=b_1))&lt;/equation&gt; 代表「在外在干预使温度计读数成为 &lt;equation&gt;b_1&lt;/equation&gt; 时，实际的环境温度为 &lt;equation&gt;b_1&lt;/equation&gt; 的概率」。&lt;b&gt;显然， &lt;equation&gt;P(A=b_1|B=b_1) &amp;gt; P(A=b_1|do(B=b_1))&lt;/equation&gt; ，可见观察与介入是两种完全不同的行为。观察不会影响模型的自然状态，但介入会。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.5.3. 因果推断的数学原理&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在这一部分，我将介绍SCM进行因果推断的数学基础。&lt;/p&gt;&lt;p&gt;我们说一个SCM具有&lt;b&gt;马尔可夫性质&lt;/b&gt;，当且仅当&lt;b&gt;这个SCM不包含任何的有向环，且所有外生变量均相互独立&lt;/b&gt;。因为外生变量通常被理解为某种「误差项」或「噪音项」，所以如果某些外生变量之间存在相关性，那么它们之间可能存在&lt;b&gt;混淆变量&lt;/b&gt;。在一个马尔可夫式SCM中，我们可以得到以下的基本定理：&lt;/p&gt;&lt;p&gt;&lt;b&gt;因果马尔可夫条件&lt;/b&gt;： &lt;equation&gt;P(v_1, v_2, ..., v_n)=\prod_{i=1}^{n}P(v_i|\mathrm{pa}(v_i))&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中， &lt;equation&gt;v_i&lt;/equation&gt; 代表我们感兴趣的变量， &lt;equation&gt;\mathrm{pa}(v_i)&lt;/equation&gt; 代表它的父节点中的所有内生变量。利用因果马尔可夫条件，我们可以把一个联合概率分布分解为多个条件概率分布的积。&lt;/p&gt;&lt;p&gt;一个符合因果马尔可夫条件的SCM经过介入之后，仍然符合因果马尔可夫条件，条件概率计算如下：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;P(v_1, v_2, ..., v_n|do(X=x))=\prod_{i=1, v_i\notin X}^{n}P(v_i|\mathrm{pa}(v_i))|_{X=x}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中，X是一系列受到干预的变量，x是X中变量受干预之后的数值。 &lt;equation&gt;P(v_i|\mathrm{pa}(v_i))|_{X=x}&lt;/equation&gt; 表示， &lt;equation&gt;\mathrm{pa}(v_i)&lt;/equation&gt; 里同时也在X里（即在 &lt;equation&gt;\mathrm{pa}(v_i) \cup X&lt;/equation&gt; 中）的变量将被赋值为 &lt;equation&gt;x&lt;/equation&gt; 的对应值。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bfddee417c2bc99edd58383eae72548c_r.jpg&quot; data-caption=&quot;图2&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;560&quot; data-rawheight=&quot;117&quot;&gt;&lt;p&gt;以图2为例，在干预之前， &lt;equation&gt;P(Z, Y, X) = P(Z)P(X|Z)P(Y|X)&lt;/equation&gt; ，而在干预 &lt;equation&gt;do(X=x_1)&lt;/equation&gt; 之后， &lt;equation&gt;P(Z, Y|do(X=x_1)) = P(Z)P(Y|X=x_1)&lt;/equation&gt; 。注意，由于从Z到X的因果箭头已经被切断， &lt;equation&gt;P(Z)=P(Z|do(X=x_1))&lt;/equation&gt; ，因为直接改变X无法影响Z。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在《Causality》中，Pearl证明了一个更广泛的结论：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;P(Y=y|do(X=x))=\sum_t{P(Y=y|T=t,X=x)P(T=t)}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中，每一个t都代表X所有父节点的一种可能取值。由于所有直接指向X的箭头已经被切断，所以自然有 &lt;equation&gt;P(T=t|X=x)=P(T=t)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.5.4. 后门准则（back-door criterion）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;考虑如下图3所示的SCM：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6e12dd916d27ef0130aded624a625500_r.jpg&quot; data-caption=&quot;图3&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;431&quot; data-rawheight=&quot;311&quot;&gt;&lt;p&gt;在SCM中，如果&lt;b&gt;一条无向连接X与Y的路径有一条指向X的箭头&lt;/b&gt;，那么我们把这条路径称为&lt;b&gt;从X到Y的后门路径&lt;/b&gt;。按照正常的因果链，「X导致Y」的结构应该是 &lt;equation&gt;X\to V_1 \to V_2 \to ... \to V_{k-1} \to V_{k} \to Y&lt;/equation&gt; ；然而，如果X与Y之间后门路径存在，那么实际结果中很可能出现虚假的统计相关性。&lt;/p&gt;&lt;p&gt;因此，当一个变量集合S符合以下两个条件时，我们称S符合后门准则：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;S中不包括X的后代。&lt;/li&gt;&lt;li&gt;S能d分隔所有从X到Y的后门路径。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;例如，在图3里， &lt;equation&gt;\{Z_1, Z_2, Z_3\}, \{Z_1, Z_3\}, \{W_1, Z_3\}, \{W_2, Z_3\}&lt;/equation&gt; 等集合都满足后门准则，但 &lt;equation&gt;\{Z_3\}&lt;/equation&gt; 不满足后门准则。&lt;/p&gt;&lt;p&gt;后门准则的重要性在于，它进一步泛化了2.5.3.结尾的公式。如果S满足从X到Y的后门准则，那么，我们可以推导得到：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;P(Y = y|do(X = x), S = s) = P(Y = y|X = x, S = s)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;P(Y = y|do(X = x)) = \sum_s P(Y = y|X = x, S = s)P(S=s)=\sum_s \frac{P(Y = y, X = x, S = s)}{P(X=x, S=s)}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;这极大简化了SCM推导时的运算。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.6. SCM的反事实推理&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;反事实推理（counterfactual inference）&lt;/b&gt;的核心在于：虽然现实情况下 &lt;equation&gt;X=x_1&lt;/equation&gt; ，但是假如&lt;equation&gt;X=x_2&lt;/equation&gt; 的话，Y会怎么样呢？&lt;/p&gt;&lt;p&gt;有些人后悔，「如果我当年……，那么我现在就能……。」这一思维方式就是反事实推理。&lt;/p&gt;&lt;p&gt;反事实推理与FPCI（因果推断的根本问题）息息相关。对于一个已经接受了实验组介入的样本u，我们只能观察到u的 &lt;equation&gt;Y_t(u)&lt;/equation&gt; ，却永远无法观察到 &lt;equation&gt;Y_c(u)&lt;/equation&gt; ，反之亦然。RCM（虚拟事实模型）对反事实推理有一定的描述，但RCM整体不如SCM清晰、明确、易解释。&lt;/p&gt;&lt;p&gt;下面，我将&lt;b&gt;用SCM重新表达2.2部分中提到的介入主义因果观&lt;/b&gt;。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;RCM考虑的对象是一个种群 &lt;equation&gt;U&lt;/equation&gt; 内的所有个体 &lt;equation&gt;u&lt;/equation&gt; 。在很多情形下，同质性假设不成立，每个个体都不尽相同。在SCM中，&lt;b&gt;个体的差异会被误差项 &lt;equation&gt;U_V&lt;/equation&gt; 表示&lt;/b&gt;（外生变量 &lt;equation&gt;U_V&lt;/equation&gt; 会相对应地影响内生变量 &lt;equation&gt;V&lt;/equation&gt; ）。除了 &lt;equation&gt;U_V&lt;/equation&gt; 之外，模型 &lt;equation&gt;M&lt;/equation&gt; 本身所代表的「自然法则」保持不变。&lt;/li&gt;&lt;li&gt;RCM的表达式 &lt;equation&gt;Y_t(u)&lt;/equation&gt; 可以表示为 &lt;equation&gt;M.\mathtt{query}(P(Y|do(T=t), U=u))&lt;/equation&gt; 。即：&lt;b&gt;我们对模型M进行干预，使得变量T赋值为t；同时，我们观察到所有外生变量U的值为u；在此情况下，我们向模型M查询我们感兴趣变量Y的条件概率。&lt;/b&gt;&lt;/li&gt;&lt;li&gt;RCM要求模型拥有一个「不受介入」的默认状态。显然，SCM符合要求：&lt;equation&gt;Y_c(u)=M.\mathtt{query}(P(Y|U=u))&lt;/equation&gt; &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因此，SCM可以回答类似「假如 &lt;equation&gt;X=x_1&lt;/equation&gt; 而非现实中的 &lt;equation&gt;X=x_0&lt;/equation&gt; ，Y的值是什么？」的反事实问题。但是，在现实生活中，由于个体信息 &lt;equation&gt;U=u&lt;/equation&gt; 通常未知，而复杂的非线性结构方程可能会随着U的分布变化而变化，所以反事实推理普遍比较困难。&lt;/p&gt;&lt;p&gt;总而言之，所有RCM均可以用SCM表达，而且SCM的白箱比RCM的黑箱更清晰、更稳定。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;三、过程性因果&lt;/h2&gt;&lt;p&gt;在第二章，我们使用的SCM（结构因果模型）建立在三条基本直觉上：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;因和果都是单独时间点上的单独事件&lt;/li&gt;&lt;li&gt;因在前，果在后&lt;/li&gt;&lt;li&gt;（由1和2可得）两个事件无法互为因果&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;不过，在其他一些情境中，例如掠食者的数量与猎物的数量，两个变量似乎「互为因果」。SCM与贝叶斯网络不允许环路的存在，故无法表示此类直觉上的因果关系。所以，我们需要一个更复杂的因果模型——&lt;b&gt;因果环路图（Causal Loop Diagram，简称CLD）&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;CLD中的变量基于以下的直觉：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;因和果是某种&lt;b&gt;过程&lt;/b&gt;，有一段持续的时间&lt;/li&gt;&lt;li&gt;因和果的持续时间段可以相互重叠&lt;/li&gt;&lt;li&gt;两个过程可以互为因果，甚至一个过程自身也可以形成因果环路&lt;/li&gt;&lt;/ol&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2d54fa8887f3ca929ff3d1aca035c6ff_r.gif&quot; data-caption=&quot;因果环路图：银行存款与利息&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;264&quot; data-rawheight=&quot;308&quot; data-thumbnail=&quot;https://pic4.zhimg.com/v2-2d54fa8887f3ca929ff3d1aca035c6ff_b.jpg&quot;&gt;&lt;p&gt;和SCM相比，CLD尚未有那么严谨、广泛的理论框架。我们可以把CLD理解为一个「从时间标量（实数）到一个SCM集」的函数映射。为了方便建模，所有的变量都是数值变量，而且多个过程变量之间的相互影响往往都是线性的，形如 &lt;equation&gt;Y=\alpha X + \beta&lt;/equation&gt; 。如果 &lt;equation&gt;\alpha = \frac{dY}{dX} &amp;gt; 0&lt;/equation&gt; ，那么我们说从X到Y的链接是&lt;b&gt;正链接&lt;/b&gt;；如果 &lt;equation&gt;\alpha = \frac{dY}{dX} &amp;lt; 0&lt;/equation&gt; ，那么我们说从X到Y的链接是&lt;b&gt;负链接&lt;/b&gt;。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-793e119dfa33cf7b26893a16572c2de6_r.gif&quot; data-caption=&quot;正链接（左）与负链接（右）&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;464&quot; data-rawheight=&quot;236&quot; data-thumbnail=&quot;https://pic3.zhimg.com/v2-793e119dfa33cf7b26893a16572c2de6_b.jpg&quot;&gt;&lt;p&gt;对于&lt;b&gt;因果环路&lt;/b&gt; &lt;equation&gt;A \to B \to A&lt;/equation&gt; ：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果A起初的一点增加（或减少）会通过因果环路，导致A进一步增加（或减少），那么我们称之为&lt;b&gt;强化反馈回路&lt;/b&gt;。&lt;/li&gt;&lt;li&gt;如果A起初的一点增加（或减少）会通过因果环路，反而导致A减少（或增加），从而中和最初的增加（减少），那么我们称之为&lt;b&gt;平衡反馈回路&lt;/b&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;假设A&amp;gt;0且B&amp;gt;0，那么：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果 &lt;equation&gt;A\to B&lt;/equation&gt; 与 &lt;equation&gt;B \to A&lt;/equation&gt; 的链接正负&lt;b&gt;相同&lt;/b&gt;，那么我们通常可以得到一个&lt;b&gt;强化&lt;/b&gt;反馈回路。&lt;/li&gt;&lt;li&gt;如果 &lt;equation&gt;A\to B&lt;/equation&gt; 与 &lt;equation&gt;B \to A&lt;/equation&gt; 的链接正负&lt;b&gt;相反&lt;/b&gt;，那么我们通常可以得到一个&lt;b&gt;平衡&lt;/b&gt;反馈回路。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;更一般地，在一个因果环路图中：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果有&lt;b&gt;偶数个负链接&lt;/b&gt;，那么它是一个&lt;b&gt;强化&lt;/b&gt;反馈回路。&lt;/li&gt;&lt;li&gt;如果有&lt;b&gt;奇数个负链接&lt;/b&gt;，那么它是一个&lt;b&gt;平衡&lt;/b&gt;反馈回路。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;反馈回路的实际意义通常如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;强化&lt;/b&gt;反馈回路通常意味着&lt;b&gt;指数增加、指数衰减&lt;/b&gt;，例如「利滚利」的银行存款与利息、不受限制的人口增长。&lt;/li&gt;&lt;li&gt;&lt;b&gt;平衡&lt;/b&gt;反馈回路通常意味着&lt;b&gt;达到某个平衡状态&lt;/b&gt;，例如洛特卡-沃尔泰拉方程的解。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在未来，一个可能的研究方向是把SCM中较为成熟、广泛的因果推断框架推广到CLD上。研究的重点在于引入非线性、非参数的复杂因果链接。此类研究必然十分困难，但随着电脑计算能力的增强，我们将逐渐有能力构建更复杂的CLD。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;参考资料、拓展阅读：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://ermongroup.github.io/cs228-notes/&quot;&gt;CS228 Notes&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2836213/&quot;&gt;An Introduction to Causal Inference&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://books.google.com/books?id=dOruCwAAQBAJ&amp;amp;printsec=frontcover&amp;amp;source=gbs_ge_summary_r&amp;amp;cad=0#v=onepage&amp;amp;q&amp;amp;f=false&quot;&gt;Probabilistic Graphical Models: Principles and Techniques&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://books.google.com/books?id=LLkhAwAAQBAJ&amp;amp;printsec=frontcover&amp;amp;dq=causality&amp;amp;hl=en&amp;amp;sa=X&amp;amp;ved=0ahUKEwjyxfTFy7XZAhXS2lMKHQTnAcwQ6AEIJjAA#v=onepage&amp;amp;q=causality&amp;amp;f=false&quot;&gt;Causality - Judea Pearl&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://bayes.cs.ucla.edu/LECTURE/lecture_sec1.htm&quot;&gt;The Art and Science of Cause and Effect - Judea Pearl&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;后记&lt;/h2&gt;&lt;p&gt;经过此次文献阅读，我意识到，很多看似困难的哲学问题，或许在其他领域（经济学、人工智能、社会学、统计学、心理学、流行病学等）已经有了足够好的解答。因此，&lt;b&gt;不论我们在学习什么学科，我们都不能被脚下的一亩三分地限制了视野。恰恰相反，我们应该多从不同的学科汲取灵感&lt;/b&gt;，切莫给自己打上「只研究xxxx领域」、故步自封。&lt;/p&gt;&lt;p&gt;同时，我们也应当意识到，&lt;b&gt;学习形而上学等较为抽象、高级的学科时，很容易产生一种虚假的优越感&lt;/b&gt;，认为自己比那些「只知道实际应用的人」高一等，从而忽视了实践的重要性。这种做法是不可取的——例如，我不能因为研究因果关系而忽视数据挖掘调参技巧……总之，&lt;b&gt;仰望星空，脚踏实地&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;如果喜欢的话，不妨点个赞，让更多的人看到；欢迎关注我 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/30f4c8f8f80bd067003f527f67ec43e7&quot; data-hash=&quot;30f4c8f8f80bd067003f527f67ec43e7&quot; data-hovercard=&quot;p$b$30f4c8f8f80bd067003f527f67ec43e7&quot;&gt;@光喻&lt;/a&gt; 和我的专栏&lt;a href=&quot;https://zhuanlan.zhihu.com/tenniel-ai&quot;&gt;光喻的人工智能笔记&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;下半年就要高三了，所以这类长文以后可能会写得比较少……总之先打算多学习、多输入、多提升自己，希望我分享的知识能为大家带来启发和帮助。&lt;/p&gt;&lt;p&gt;这是我第一次写比较深入的综述文章。在网上，我还没有找到能全面介绍统计因果模型的中文材料，所以几乎所有观点都是根据论文和《Causality》书籍原文综合总结得出的，翻译也可能有错漏的地方。如果有什么失误或者解释得不清楚的地方，请在评论区指出，我会及时更新的。&lt;/p&gt;&lt;p&gt;谢谢各位的阅读啦~&lt;/p&gt;&lt;p&gt;(｀・ω・´)&lt;/p&gt;</description>
<author>光喻</author>
<guid isPermaLink="false">2018-02-28-33860572</guid>
<pubDate>Wed, 28 Feb 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Programming Languages: Application and Interpretation【译15上】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-02-18-33865846.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33865846&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b71b632ed7974538bb2e812bcd20914e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;初翻： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/9bebf466fc2535bec442451dca7cd13a&quot; data-hash=&quot;9bebf466fc2535bec442451dca7cd13a&quot; data-hovercard=&quot;p$b$9bebf466fc2535bec442451dca7cd13a&quot;&gt;@lotuc&lt;/a&gt; &lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;https://lotuc.gitbooks.io/plai-cn/content/&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;15 静态地检查程序中的不变量：类型&lt;/h2&gt;&lt;p&gt;当程序变得更大或者更为复杂时，程序员希望能有工具帮助他们描述、验证程序中的&lt;b&gt;不变量&lt;/b&gt;。顾名思义，不变量指的就是关于程序组成元素的那些不会发生改变的陈述。例如，当我们在静态类型语言中写下&lt;code class=&quot;inline&quot;&gt;x : number&lt;/code&gt;时，表示 x 中存放的总是数，程序中依赖 x 的部分都可以认定它是数的这个事实不会改变。我们将会看到，类型只是我们想要陈述的各类不变量中的一种，静态类型检测——一个分支众多的技术家族——也只是用于控制不变量的众多方法中的一个。&lt;/p&gt;&lt;h2&gt;15.1 静态类型规则&lt;/h2&gt;&lt;p&gt;本章我们将专注于&lt;b&gt;静态类型检查&lt;/b&gt;：即在程序执行前检查（声明的）类型。之前使用的静态类型语言已经让我们积攒了一些这种形式程序的经验。我们将探索类型的设计空间及这些设计中的权衡取舍。尽管类型是控制不变量的一种非常强大且有效的方法，最后我们还是会考察一些其它可用的技术。&lt;/p&gt;&lt;p&gt;考虑下面这段静态语言写就的程序：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (f [n : number]) : number
  (+ n 3))

(f &quot;x&quot;)&lt;/code&gt;&lt;p&gt;程序开始执行前我们就会得到一个静态类型错误。使用普通 Racket 写就的同样的程序（去除类型注解）只会在运行时出错：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (f n)
  (+ n 3))

(f &quot;x&quot;)&lt;/code&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;如何判断错误是在程序执行前还是运行时抛出的？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;考虑下面这段 Racket 程序：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define f n
  (+ n 3))&lt;/code&gt;&lt;p&gt;它也是在程序执行前就遇到错误——语法解析错误——终止。尽管我们认为语法解析和类型检查有所不同——通常是因为类型检测是针对已经被解析好的程序做的——但是将语法解析看作一种最简单形式的类型检查也很有用：它（静态地）判定程序是否遵守某个&lt;b&gt;上下文无关&lt;/b&gt;语法。随后，类型检查判定它是否遵守某个&lt;b&gt;上下文相关&lt;/b&gt;（或者一个更丰富的）语法。简而言之，类型检查从某种程度上看是语法解析的泛化，它们都是通过&lt;b&gt;语法&lt;/b&gt;控制程序遵循指定的规则。&lt;/p&gt;&lt;h2&gt;15.2 关于类型的经典看法&lt;/h2&gt;&lt;p&gt;我们先介绍传统的包含类型的核心语言；然后我们将探索其扩展和变种。&lt;/p&gt;&lt;h2&gt;15.2.1 简单的类型检查器&lt;/h2&gt;&lt;p&gt;要定义类型检查器，我们先需要就两件事达成一致：我们静态类型&lt;b&gt;核心&lt;/b&gt;语言的语法，对应的类型的语法。&lt;/p&gt;&lt;p&gt;先回到我们之前实现过的&lt;a href=&quot;https://github.com/lotuc/PLAI-cn/blob/master/chap7.md&quot;&gt;函数作为值&lt;/a&gt;的那一版语言，其中并不包含赋值等其它稍复杂的东西（后面将讲到添加其中的一些）。我们需要为该语言添加类型注解。按惯例，我们不对常量或基本操作（如加法）强加类型注释；相反，我们把类型注释加在函数或方法的边界上。在本章讨论的过程中，我们将探讨为什么这么做。&lt;/p&gt;&lt;p&gt;鉴于此决定，我们静态类型的核心语言变成了：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define-type TyExprC
  [numC (n : number)]
  [idC (s : symbol)]
  [appC (fun : TyExprC) (arg : TyExprC)]
  [plusC (l : TyExprC) (r : TyExprC)]
  [multC (l : TyExprC) (r : TyExprC)]
  [lamC (arg : symbol) (argT : Type) (retT : Type) (body : TyExprC)])&lt;/code&gt;&lt;p&gt;每个函数都添加了其参数及返回值类型的注解。&lt;/p&gt;&lt;p&gt;现在我们需要对类型语言作出选择。我们遵从传统定义，即类型是&lt;b&gt;一组值的集合的抽象&lt;/b&gt;。我们的语言中有两类值：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define-type Value
  [numV (n : number)]
  [closV (arg : symbol) (body : TyExprC) (env : Env)])&lt;/code&gt;&lt;p&gt;因此我们有两种类型：数和函数。&lt;/p&gt;&lt;p&gt;即使数类型也并不那么简单直接：数类型应该记录何种信息？大部分语言中，实际上有&lt;b&gt;很多&lt;/b&gt;数类型，甚至没有哪个类型表示“数”。然而，我们忽略了数的层级结构（译注，第三章），对于我们来说有一种数的类型足矣。这样决定之后，我们是否需要记录&lt;b&gt;哪种&lt;/b&gt;数的信息？ 原则上可以，但这样我们很快就会遇到可判定性问题。&lt;/p&gt;&lt;p&gt;至于函数，我们有更多信息：参数的类型，返回值的类型。我们不妨记录下这些信息，除非事后证实这些信息没有用处。结合这些，我们得出这样的类型的抽象语言：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define-type Type
  [numT]
  [funT (arg : Type) (ret : Type)])&lt;/code&gt;&lt;p&gt;既然已经确定了语言中项和类型的结构，接下来我们来确定语言中哪些算是类型错误（并且，如果程序中不包含这里列出的类型错误，它就会通过类型检查）。显然有三种形式的类型错误：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;的参数不是数，即不是&lt;code class=&quot;inline&quot;&gt;numT&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt;的参数不是数。&lt;/li&gt;&lt;li&gt;函数调用时函数位置的表达式不是函数，即不是&lt;code class=&quot;inline&quot;&gt;funT&lt;/code&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;还有其它形式的类型错误吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;事实上我们遗漏了一个：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;函数调用时实参的类型和函数形参的类型不一致。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们的语言中的所有其他程序似乎都应该通过类型检查。&lt;/p&gt;&lt;p&gt;关于类型检查器的签名，初步设想，它可以接受表达式作为参数，返回布尔值指明该表达式是否通过检查。由于我们知道表达式中包含标识符，所以很显然我们还需要一个&lt;b&gt;类型环境&lt;/b&gt;，它将名字映射到类型，类似于我们之前用到的值环境。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;定义与类型环境相关的数据类型以及函数。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;于是，我们开始写下的程序结构大致是这样：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-take-1&amp;gt; ::=  ;;类型检查，第一次尝试

    (define (tc [expr : TyExprC] [tenv : TyEnv]) : boolean
      (type-case TyExprC expr
        &amp;lt;tc-take-1-numC-case&amp;gt;
        &amp;lt;tc-take-1-idC-case&amp;gt;
        &amp;lt;tc-take-1-appC-case&amp;gt;))&lt;/code&gt;&lt;p&gt;正如上面程序中列出的要处理几种情形所表明的，这种方法行不通。我们很快将知道这是为什么。&lt;/p&gt;&lt;p&gt;首先处理简单的情形：数。单独的一个数能通过类型检查吗？显然可以；它所处的上下文可能想要的不是数类型，但是这种错误应该在其它地方被检查出。因此：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-take-1-numC-case&amp;gt; ::=

    [numC (n) true]&lt;/code&gt;&lt;p&gt;下面处理标识符。如何判断标识符是否通过类型检查呢？同样，就其自身来说，如果是绑定标识符，总是通过检查的；它可能不是上下文要求的那种类型，但是这种错误应该在其它地方检查。因此，我们得出：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-take-1-idC-case&amp;gt; ::=

    [idC (n) (if (lookup n tenv)
                 true
                 (error &#39;tc &quot;not a bound identifier&quot;))]  ;不是绑定标识符&lt;/code&gt;&lt;p&gt;上面的代码你可能感觉不太对：如果标识符未绑定的话，&lt;code class=&quot;inline&quot;&gt;lookup&lt;/code&gt;会抛出异常，因此没必要再去重复处理该情况（事实上，代码永远不会执行到&lt;code class=&quot;inline&quot;&gt;error&lt;/code&gt;调用那个分支）。但是让我们先继续。&lt;/p&gt;&lt;p&gt;下面来处理函数调用。我们应该首先检查函数位置，确定它是个函数，然后确保实际参数的类型和该函数定义时声明的形式参数类型相同。例如，函数可能需要参数是数，但调用给的是个函数，或者反之，在这两种情况下，我们都需要防止错误的函数调用。&lt;/p&gt;&lt;p&gt;代码该怎么写？&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-take-1-appC-case&amp;gt; ::=

    [appC (f a) (let ([ft (tc f tenv)])
                  ...)]&lt;/code&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;tc&lt;/code&gt;的递归调用只能让我们知道函数位置是否通过类型检查。如果它通过了，怎么知道它具体是什么类型的呢？如果是个简单的函数定义的话，我们可以直接从语法上取得其参数和返回值的类型。但是如果是个复杂的表达式，我们就需要一个函数能&lt;b&gt;计算&lt;/b&gt;出表达式类型。当然，只有这个表达式是个类型正确的表达式时，该函数才能返回类型结果；否则的话它将不能得出正确的结果。换句话说，&lt;b&gt;“类型检查”是“类型计算”的一种特殊情形&lt;/b&gt;！因此，我们应该增强&lt;code class=&quot;inline&quot;&gt;tc&lt;/code&gt;的归纳不变量：即，不仅仅返回表达式是否能通过类型检查，而是返回表达式的类型。事实上，只要有返回值，就说明该表达式通过了类型检查；否则它会抛出错误。&lt;/p&gt;&lt;p&gt;下面我们来定义这个更完善的类型“检查器”。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc&amp;gt; ::=

    (define (tc [expr : TyExprC] [tenv : TyEnv]) : Type
      (type-case TyExprC expr
        &amp;lt;tc-numC-case&amp;gt;
        &amp;lt;tc-idC-case&amp;gt;
        &amp;lt;tc-plusC-case&amp;gt;
        &amp;lt;tc-multC-case&amp;gt;
        &amp;lt;tc-appC-case&amp;gt;
        &amp;lt;tc-lamC-case&amp;gt;))&lt;/code&gt;&lt;p&gt;现在填充具体实现。数很简单：它的类型就是数类型。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-numC-case&amp;gt; ::=

    [numC (n) (numT)]&lt;/code&gt;&lt;p&gt;与之相似，标识符的类型从环境中查询得到（如果其未被绑定则会抛出错误）。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-idC-case&amp;gt; ::=

    [idC (n) (lookup n tenv)]&lt;/code&gt;&lt;p&gt;到此，我们可以观察到该类型检查器与解释器之间的一些异同：对于标识符，两者做的事情其实一样（只不过这里返回的是标识符的类型而不是一个实际的值），对于数的情况，这里返回了抽象的“数”而不是具体的数。&lt;/p&gt;&lt;p&gt;下面考虑加法。必须确保其两个子表达式都具有数类型；如果满足该条件，则加法表达式本身返回的是数类型。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-plusC-case&amp;gt; ::=

    [plusC (l r) (let ([lt (tc l tenv)]
                       [rt (tc r tenv)])
                   (if (and (equal? lt (numT))
                            (equal? rt (numT)))
                       (numT)
                       (error &#39;tc &quot;+ not both numbers&quot;)))] ;+不都是数&lt;/code&gt;&lt;p&gt;通常在处理完加法的情形之后，对于乘法我们就一笔带过了，但是这里显式处理一下它还是很有教益的：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-multC-case&amp;gt; ::=

    [multC (l r) (let ([lt (tc l tenv)]
                       [rt (tc r tenv)])
                   (if (and (equal? lt (numT))
                            (equal? rt (numT)))
                       (numT)
                       (error &#39;tc &quot;* not both numbers&quot;)))] ;*不都是数&lt;/code&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;看出其中的区别了吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;是的，基本上&lt;b&gt;完全&lt;/b&gt;没区别！（仅有的区别是在&lt;code class=&quot;inline&quot;&gt;type-case&lt;/code&gt;时使用的分别&lt;code class=&quot;inline&quot;&gt;multC&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;plusC&lt;/code&gt;，以及错误提示信息稍有不同）。这是因为，从（此静态类型语言）类型检查的角度来说，加法和乘法没有区别，更甚，&lt;b&gt;任意&lt;/b&gt;接受两个数作为参数返回一个数的函数都没有区别。&lt;/p&gt;&lt;p&gt;注意到代码解释和类型检查之间另一个不同点。它们的参数都得是数。解释器返回加或者乘它们得到的确切数值，但是类型检查器并不在乎具体的数值：因此该表达式的计算结果（&lt;code class=&quot;inline&quot;&gt;(numT)&lt;/code&gt;）是个常数，两种情形返回都是该常数。&lt;/p&gt;&lt;p&gt;最后还剩下两个难一点的情形：函数调用和函数。我们已经讨论过怎么处理函数调用：计算函数以及参数表达式的值；确保函数表达式为函数类型；检查参数类型和函数形参类型相容。如果这些条件满足，函数调用得到的结果类型就是函数体的类型（因为运行时最终的返回值就是计算函数体得到的值）。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-appC-case&amp;gt; ::=

    [appC (f a) (let ([ft (tc f tenv)]
                      [at (tc a tenv)])
                  (cond
                    [(not (funT? ft))
                     (error &#39;tc &quot;not a function&quot;)] ;不是函数
                    [(not (equal? (funT-arg ft) at))
                     (error &#39;tc &quot;app arg mismatch&quot;)] ;app参数不匹配
                    [else (funT-ret ft)]))]&lt;/code&gt;&lt;p&gt;最后还剩下函数定义。函数有一个形参，函数体中一般会用到；除非它被绑定到环境中，不然函数体应该不太可能通过类型检查。因此我们需要扩展类型环境，添加形参与其类型的绑定，然后在扩展后的环境中检查函数体。最终计算得到的函数体类型必须和函数定义中指定的函数返回值类型相同。如果满足了这些，该函数的类型就是指定参数类型到函数体类型的函数。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;上面说的“不太可能通过类型检查”是什么意思？&lt;br&gt;&lt;/blockquote&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-lamC-case&amp;gt; ::=

    [lamC (a argT retT b)
          (if (equal? (tc b (extend-ty-env (bind a argT) tenv)) retT)
              (funT argT retT)
              (error &#39;tc &quot;lam type mismatch&quot;))] ;λ类型不匹配&lt;/code&gt;&lt;p&gt;注意到解释器与类型检查器另一个有趣的不同点。解释器中，函数调用负责计算参数表达式的值，扩展环境，然后对函数体求值。而这里，函数调用的情形中的确也检查了参数表达式，但是没有涉及到环境的处理，直接返回了函数体的类型，而&lt;b&gt;没有遍历它&lt;/b&gt;。对函数体的遍历检查过程实际是在检查函数&lt;b&gt;定义&lt;/b&gt;的过程中进行的，因此环境也是在这个地方才实际被扩展的。&lt;/p&gt;&lt;h2&gt;15.2.2 条件语句的类型检查&lt;/h2&gt;&lt;p&gt;考虑为上面的语言添加条件语句，即使最简单的 if 表达式都会引入若干设计抉择。这里我们先讨论其中的两个，后面会回过头讨论其中的一个。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;条件表达式的类型应该是什么？某些语言中它必须计算得到布尔值，这种情况下需要为我们的语言添加布尔值类型（这可能是个好主意）。其它语言中，它可以是任意值，某些值被认为是“真值”，其它的则被视为“假值”。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;then-&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;else-&lt;/code&gt;两个分支之间的关系应该是什么呢？一些语言中它们的类型必须相同，因此整个 if 表达式有一个确定无歧义的类型。其它语言中，两个分支可以有不同的类型，这极大地改变了静态类型语言的设计和它的类型检查器，而且也改变了编程语言本身的性质。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;为该静态类型语言添加布尔值。至少需要添加些啥？在典型的语言中还需要加什么？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;为条件语句添加类型规则，其中条件表达式应该计算得到布尔值，且&lt;code class=&quot;inline&quot;&gt;then-&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;else-&lt;/code&gt;分支必须有相同的类型，同时该类型也是整个条件语句的类型。&lt;/blockquote&gt;&lt;h2&gt;15.2.3 代码中的递归&lt;/h2&gt;&lt;p&gt;现在我们已经得到了基本的编程语言，下面为其添加递归。之前我们实现过递归，可以很容易的通过去语法糖实现。这里的情况要更复杂一些。&lt;/p&gt;&lt;h2&gt;15.2.3.1 递归的类型，初次尝试&lt;/h2&gt;&lt;p&gt;首先尝试表示一个简单的递归函数。最简单的当然就是无限循环。我们可以仅使用函数实现无限循环吗？可以：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;((lambda (x) (x x))
 (lambda (x) (x x)))&lt;/code&gt;&lt;p&gt;因为我们的语言中已经支持将函数作为值。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;为什么这会构成无限循环？它是如何巧妙地依赖于函数调用的本质的？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;现在我们的静态类型语言要求我们为所有函数添加类型注解。我们来为该函数添加类型注解。简单起见，假设从现在开始我们写的程序使用的语法是静态类型的表层语法，去语法糖将帮我们将其转换为核心语言。&lt;/p&gt;&lt;p&gt;首先注意到，我们有两个完全一样的表达式，它们互相调用。历史原因，整个表达式被称为Ω（希腊字母大写欧米茄），那两个一样的子表达式被称为ω（希腊字母小写欧米茄）。两个一样的表达式并非得是同种类型的，因为这还依赖于具体使用环境中对于不变量的定义。这个例子中，观察到 x 被绑定到ω，于是ω将出现在在&lt;code class=&quot;inline&quot;&gt;(x x)&lt;/code&gt;式子的第一个和第二个部分。即，确定其中一个表达式的类型，另一个式子的类型也被确定。&lt;/p&gt;&lt;p&gt;那么我们就来尝试计算ω的类型；称该类型为γ。显然它是一个函数类型，而且是单参数的函数，所以它的类型必然是&lt;code class=&quot;inline&quot;&gt;φ -&amp;gt; ψ&lt;/code&gt;这种形式的。该函数的参数是什么类型？就是ω的类型。也即，传入φ的值的类型就是γ。因此，ω的类型是γ，也即&lt;code class=&quot;inline&quot;&gt;φ -&amp;gt; ψ&lt;/code&gt;，展开即&lt;code class=&quot;inline&quot;&gt;(φ -&amp;gt; ψ) -&amp;gt; ψ&lt;/code&gt;，进一步展开得&lt;code class=&quot;inline&quot;&gt;((φ -&amp;gt; ψ) -&amp;gt; ψ) -&amp;gt; ψ&lt;/code&gt;，还可以继续下去。也就是说，该类型不能用有限的字符串写出来！&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;你注意到了我们刚做的的微妙但重要的跳跃吗？&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;15.2.3.2 程序终止&lt;/h2&gt;&lt;p&gt;我们观察到，试图直接地计算Ω的类型，需要先计算γ的类型，这似乎导致了严重的问题。然后我们就得出结论：此类型不能用有限长度的字符串表示，但是这只是直觉的结果，并非证明。更奇怪的事实是：在我们迄今定义的类型系统中，&lt;b&gt;根本无法给出Ω的类型&lt;/b&gt;！&lt;/p&gt;&lt;p&gt;这是一个很强的表述，但事实上我们可以给出更强的描述。我们目前所用的&lt;b&gt;静态类型&lt;/b&gt;语言有一个属性，称为&lt;b&gt;强归一化&lt;/b&gt;（strong normalization）：任何有类型的表达式都会在有限步骤后终止计算。换句话，这个特殊的（奇特的）无限循环程序并不是唯一不可获得类型的程序；&lt;b&gt;任何&lt;/b&gt;无限循环（或潜在存在无限循环）程序都无法求得类型。一个简单的直觉说明可以帮助我们理解，任何类型——必须能被有限长度的字符串表示——只能包含有限个&lt;code class=&quot;inline&quot;&gt;-&amp;gt;&lt;/code&gt;，每次调用会去除一个&lt;code class=&quot;inline&quot;&gt;-&amp;gt;&lt;/code&gt;，因此我们只能进行有限次数的函数调用。&lt;/p&gt;&lt;p&gt;如果我们的程序只允许非转移程序（&lt;a href=&quot;https://en.wikipedia.org/wiki/Straight-line_program&quot;&gt;straight-line program&lt;/a&gt;），这点也无足为奇。但是，我们有条件语句，还有可以当做值任意传递的函数，通过这些我们可以编码得到任何我们想要的数据结构。然而我们仍能得到这个保证！这使得这个结果令人吃惊。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;试着使用函数分别在动态类型和静态类型语言中编码实现列表。你看到了什么？这说明此类型系统对于编码产生了何种影响？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;这个结果展示了某种更深层次的东西。它表明，和你可能相信的——类型系统只是用来避免一些程序 BUG 在运行时才被发现——相反，类型系统可能&lt;b&gt;改变语言的语义&lt;/b&gt;。之前我们一两行就能写出无限循环，现在我们怎么都写不出来。这也表明，类型系统不仅可以建立关于某个特定程序的不变量，还能建立&lt;b&gt;关于语言本身的&lt;/b&gt;不变量。如果我们非常需要确保某个程序将会终止，只要用该语言来写然后交由类型检查器检查通过即可。&lt;/p&gt;&lt;p&gt;一门语言，用其书写的所有程序都将终止，有什么用处？对于通用编程来说，当然没用。但是在很多特殊领域，这是非常有用的保证。例如，你要实现一个复杂的调度算法；你希望知道调度程序保证会终止，以便那些被调度的任务被执行。还有许多其他领域，我们将从这样的保证中受益：路由器中的数据包过滤器；实时事件处理器；设备初始化程序；配置文件；单线程&lt;br&gt; JavaScript 中的回调；甚至编译器或链接器。每种情况下，我们都有一个不成文的期望，即这些程序最终会终止。而现在我们有一个语言能保证这点——且这点是不可测试的。&lt;/p&gt;&lt;blockquote&gt;这不是假想的例子。在Standard ML语言中，链接模块基本上就是使用这种静态类型语言来编写模块链接规范。这意味着开发人员可以编写相当复杂的抽象概念——毕竟可以将函数作为值使用——且同时链接过程被保证会终止，产生最终的程序。&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;15.2.3.3 静态类型的递归&lt;/h2&gt;&lt;p&gt;这就意味着，之前我们可以只通过去语法糖来实现&lt;code class=&quot;inline&quot;&gt;rec&lt;/code&gt;，现在则必须在我们的静态类型语言中显式的实现。简单起见，我们仅考虑&lt;code class=&quot;inline&quot;&gt;rec&lt;/code&gt;的一种特殊形式——它涵盖了常见用法，即递归标识符被绑定到函数。因此，表层语法中，我们可能写出如下的累加函数：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(rec (Σ num (n num)
        (if0 n
             0
             (n + (Σ (n + -1))))) ;译注，原文如此，+应前置
  (Σ 10))&lt;/code&gt;&lt;p&gt;其中，&lt;code class=&quot;inline&quot;&gt;Σ&lt;/code&gt;是函数名，&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;为其参数，&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;为函数参数以及返回值的类型。表达式&lt;code class=&quot;inline&quot;&gt;(Σ 10)&lt;/code&gt;表示使用该函数计算从 10 累加到 0 的和。&lt;/p&gt;&lt;p&gt;如何计算这个表达式的类型？显然，求类型过程中，&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;在函数体中的类型需要绑定（但是在函数调用处就不需要了）；这一点计算函数类型的时候我们就知道了。那么&lt;code class=&quot;inline&quot;&gt;Σ&lt;/code&gt;呢？显然，在检查&lt;code class=&quot;inline&quot;&gt;(Σ 10)&lt;/code&gt;的类型时，它应该在类型环境中被绑定，类型必须为&lt;code class=&quot;inline&quot;&gt;num -&amp;gt; num&lt;/code&gt;。不过，在检查函数体时，它&lt;b&gt;同样&lt;/b&gt;需要被绑定到此类型。（还要注意，函数体返回值的类型需要和事先声明的返回类型相同。）&lt;/p&gt;&lt;p&gt;现在我们可以看到如何打破类型有限性的束缚。程序代码中，我们只能编写包含有限数量&lt;code class=&quot;inline&quot;&gt;-&amp;gt;&lt;/code&gt;的类型。但是，这种递归类型的规则在函数体中引用自身时复制了&lt;code class=&quot;inline&quot;&gt;-&amp;gt;&lt;/code&gt;，从而供应了无穷的函数调用。这是包含无穷箭矢的箭筒。&lt;/p&gt;&lt;p&gt;实现这种规则的代码如下。假设&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;被绑定到函数的名字，&lt;code class=&quot;inline&quot;&gt;aT&lt;/code&gt;是函数参数的类型，&lt;code class=&quot;inline&quot;&gt;rT&lt;/code&gt;为返回类型，&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;是函数体，&lt;code class=&quot;inline&quot;&gt;u&lt;/code&gt;是函数的使用：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;tc-lamC-case&amp;gt; ::=

    [recC (f a aT rT b u)
          (let ([extended-env
                 (extend-ty-env (bind f (funT aT rT)) tenv)])
            (cond
              [(not (equal? rT (tc b
                                   (extend-ty-env
                                    (bind a aT)
                                    extended-env))))
               (error &#39;tc &quot;body return type not correct&quot;)] ;函数体类型错误
              [else (tc u extended-env)]))]&lt;/code&gt;&lt;h2&gt;15.2.4 数据中的递归&lt;/h2&gt;&lt;p&gt;我们已经见识了静态类型的递归程序，但是它还不能使我们创建递归的数据。我们已经有一种递归数据——函数类型——但是这是内建的。现在还没看到如何创建自定义的递归数据类型。&lt;/p&gt;&lt;h2&gt;15.2.4.1 递归数据类型定义&lt;/h2&gt;&lt;p&gt;当我们说允许程序员创建递归数据时，我们实际在同时谈论三种东西：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;创建新的类型&lt;/li&gt;&lt;li&gt;让新类型的实例拥有一个或多个字段&lt;/li&gt;&lt;li&gt;让这些字段中的某些指向同类型的实例&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;实际上，一旦我们允许了第三点，我们就必须再允许一点：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;允许该类型中非递归的基本情况的存在&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这些设计准则的组合产生了通常被称为&lt;b&gt;代数数据类型&lt;/b&gt;（algebraic datatype）的东西，比如我们的静态语言中支持的类型。举个例子，考虑下面这个数二叉树的定义：【注释】&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define-type BTnum
  [BTmt]
  [BTnd (n : number) (l : BTnum) (r : BTnum)])&lt;/code&gt;&lt;blockquote&gt;后面我们会讨论如何参数化类型。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;请注意，如果这个新的数据类型没有名字，&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;，我们将不能在&lt;code class=&quot;inline&quot;&gt;BTnd&lt;/code&gt;中引用回该类型。同样地，如果只允许定义一种&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;构造，那么就无法定义 &lt;code class=&quot;inline&quot;&gt;BTmt&lt;/code&gt;，这会导致递归无法终止。当然，最后我们需要多个字段（如&lt;code class=&quot;inline&quot;&gt;BTnd&lt;/code&gt;中的一样）来构造有用、有趣的数据。换句话说，所有这三种机制被打包在一起，因为它们结合在一起才最有用。（但是，有些语言确实允许定义独立结构体。后文我们将回来讨论这个设计决策对类型系统的影响）。&lt;/p&gt;&lt;p&gt;我们关于递归表示的初步讨论暂告一个段落，但这里有个严重的问题。我们并没有真正解释这个新的数据类型&lt;code class=&quot;inline&quot;&gt;BTum&lt;/code&gt;的来源。因为我们不得不假装它已经在我们的类型检查器中实现了。然而，为每个新的递归类型改变我们的类型检查器有点不切实际——这就好比需要为每个新出现的递归函数去修改解释器！相反，我们需要找到一种方法，使得这种定义成为静态类型语言的固有能力。后面我们会回来讨论这个问题。&lt;/p&gt;&lt;p&gt;这种风格的数据定义有时也被称为&lt;b&gt;乘积的和&lt;/b&gt;，“乘”指代字段组合成不变量的方式：例如，&lt;code class=&quot;inline&quot;&gt;BTnd&lt;/code&gt;的合法值是传递给&lt;code class=&quot;inline&quot;&gt;BTnd&lt;/code&gt;构造器的每个字段合法值的叉乘。“和”是所有这些不变量的总数：任何给定的&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;值是其中之一。（将“乘”想作“且”，“加”想作“或”。）&lt;/p&gt;&lt;h2&gt;15.2.4.2 自定义类型&lt;/h2&gt;&lt;p&gt;想一想，数据结构的定义会产生哪些影响？首先，它引入了新的类型；其次它基于此类型定义若干构造器、谓词和选择器。例如，在上面的例子中，首先引入 &lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;，然后使用它创建以下类型：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;BTmt : -&amp;gt; BTnum
BTnd : number * BTnum * BTnum -&amp;gt; BTnum
BTmt? : BTnum -&amp;gt; boolean
BTnd? : BTnum -&amp;gt; boolean
BTnd-n : BTnum -&amp;gt; number
BTnd-l : BTnum -&amp;gt; BTnum
BTnd-r : BTnum -&amp;gt; BTnum&lt;/code&gt;&lt;p&gt;观察几个显著的事实：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;这里的构造器创建&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;的实例，而不是更具体的东西。稍后我们将讨论这个设计抉择。&lt;/li&gt;&lt;li&gt;这里的谓词函数都接受&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;类型参数，而不是“Any”（任意值）。这是因为类型系统已经可以告诉我们某个值的类型是什么，因此我们只需要区分该类型的不同形式。&lt;/li&gt;&lt;li&gt;选择器只能作用于类型中相关形式的实例——例如，&lt;code class=&quot;inline&quot;&gt;BTnd-n&lt;/code&gt;只对&lt;code class=&quot;inline&quot;&gt;BTnd&lt;/code&gt;的实例有效，对&lt;code class=&quot;inline&quot;&gt;BTmt&lt;/code&gt;的实例则不行——但是由于缺乏合适的静态类型，我们无法在静态类型系统中表示这点。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;递归类型中还有很多值得讨论的东西，我们不久将回到这个话题。&lt;/p&gt;&lt;h2&gt;15.2.4.3 模式匹配和去语法糖&lt;/h2&gt;&lt;p&gt;类型定义的讨论告一段落，剩下要提供的功能就是模式匹配。例如，我们可以这样写：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(type-case BTnum t
    [BTnum () e1]
    [BTnd (nv lt rt) e2])&lt;/code&gt;&lt;p&gt;我们知道，这可以用前述的函数来实现。用 let 就可以模拟此模式匹配所实现的绑定：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(cond
    [(BTmt? t) e1]
    [(BTnd? t) (let ([nv (BTnd-n t)]
                     [lt (BTnd-l t)]
                     [rt (BTnd-r t)]
                 e2)])&lt;/code&gt;&lt;p&gt;总之，它可以通过宏实现，所以模式匹配不需要被添加到核心语言中，直接用去语法糖即可实现。这也意味着一门语言可以有很多不同的模式匹配机制。&lt;/p&gt;&lt;p&gt;不过，这不完全正确。生成上面代码中的&lt;code class=&quot;inline&quot;&gt;cond&lt;/code&gt;表达式时，宏需要通过某种手段知道&lt;code class=&quot;inline&quot;&gt;BTnd&lt;/code&gt;的三个位置选择器分别是&lt;code class=&quot;inline&quot;&gt;BTnd-n&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;BTnd-l&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;BTnd-r&lt;/code&gt;。这些信息在类型定义时显式给出，但是在模式匹配时是隐含的（划重点）。因此，这些信息必须要从类型定义处传过来。因此宏扩展器需要使用类似类型环境的东西完成其任务。&lt;/p&gt;&lt;p&gt;此外，还要注意，例如&lt;code class=&quot;inline&quot;&gt;e1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;e2&lt;/code&gt;这样的表达式无法类型检查——事实上，甚至不能被可靠地识别为表达式——直到宏扩展器完成了&lt;code class=&quot;inline&quot;&gt;type-case&lt;/code&gt;的扩展之后。因此，扩展依赖于类型环境，而类型检查依赖于扩展的结果。换句话说这两者是共生关系，不仅仅是并行运行，而是同步运行。因此，静态类型语言中进行去语法糖操作时，如果语法糖需要对相关类型作出推测，要比动态类型语言中更复杂一些。&lt;/p&gt;&lt;h2&gt;15.2.5 类型、时间和空间&lt;/h2&gt;&lt;p&gt;明显，类型已经赋予了类型安全语言一些性能优势。因为一些本来需要运行时执行的检查（例如，检查加法的两个参数的确是数）现在是静态执行的。在静态类型语言中，类似&lt;code class=&quot;inline&quot;&gt;:number&lt;/code&gt;的注解已经回答了关于某个值是否是特定类型这种问题；无需在运行时再去检查。因此，类型级别的谓词以及程序中对它们的使用将会（并且需要）完全消失。&lt;/p&gt;&lt;p&gt;对于开发者来说这需要付出一些代价，他们必须说服静态类型系统他们的程序不会导致类型错误；由于可判定性的限制，有些可以正确运行的程序也可能与类型系统冲突。不过，类型系统为满足了它要求的程序提供了可观的运行时性能优势。&lt;/p&gt;&lt;p&gt;接下来我们来讨论空间。到目前为止，语言的运行时系统需要对每个值附加存储其类型信息。这也是其实现类型级别谓词如 &lt;code class=&quot;inline&quot;&gt;number?&lt;/code&gt; 的基础，这些谓词既可被开发人员使用也可被语言内部使用。如果不需要这些谓词，那么这些为了实现它们而存储的信息所占据的空间也将不再需要。因此（静态语言）不需要类型标签。&lt;/p&gt;&lt;blockquote&gt;然而，垃圾回收器仍然需要它们，但其他表示法（如BIBOP(译注BIg Bag Of Pages)）能极大减少它们对空间的需求。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;类型变体相关的谓词仍要保留：如上面例子中的&lt;code class=&quot;inline&quot;&gt;BTmt?&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;BTnd?&lt;/code&gt;。它们的调用需要在运行时求值。例如，如前所述，选择器&lt;code class=&quot;inline&quot;&gt;BTnd-n&lt;/code&gt;就需要执行这种检查。当然，进一步的优化是可能的。考虑模式匹配去语法糖后生成的代码：其中的三个选择器就无需执行这些检查，因为只有&lt;code class=&quot;inline&quot;&gt;BTnd?&lt;/code&gt;返回真值时才会执行对应代码片。因此，运行时系统可以给去语法糖层面提供特殊的&lt;b&gt;不安全&lt;/b&gt;（unsafe）指令，也就是不执行类型检查的版本，从而生成如下所示的代码：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(cond
  [(BTmt? t) e1]
  [(BTnd? t) (let ([nv (BTnd-n/no-check t)]
                   [lt (BTnd-l/no-check t)]
                   [rt (BTnd-r/no-check t)])
               e2)])&lt;/code&gt;&lt;p&gt;但最终的结果是，运行时系统仍然需要存储足够的信息来准确回答这些问题。不过，相比于之前需要使用足够的位来区分每种类型及类型变体，现在，由于类型被静态地隔离了，对于没有变体的类型（例如，只有一种类型的字符串），不再需要存储任何变体相关的信息；这意味着运行时系统可以使用所有可用位来存储实际的动态值。&lt;/p&gt;&lt;p&gt;与之相对，如果类型存在变体，运行时系统需要牺牲一些空间用于区分不同变体，不过一个类型中变体的数量显然比&lt;b&gt;所有类型&lt;/b&gt;和其变体的数量要小得多。在上面的例子中，&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;只有两个变体，因此运行时系统只需要使用一个比特来记录某个值是&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;的哪个变体。&lt;/p&gt;&lt;p&gt;特别要注意的是，类型体系的隔离可以防止混淆。如果有两种不同的数据类型，每种都有两种变体，在动态类型的世界中，所有这四种变体都需要有不同的表示法；与之相对，在静态类型的世界中，这些表示法可以跨类型重叠，因为静态类型系统会保证一种类型中的变体和另一种类型中的不被混淆。因此，类型系统对于程序的空间（节约表示所需空间）和时间（消除运行时检查）上都有实打实的性能提升。&lt;/p&gt;&lt;h2&gt;15.2.6 类型和赋值&lt;/h2&gt;&lt;p&gt;我们已经覆盖了核心语言中除赋值之外的大部分基本特性。从某些方面看，类型和赋值之间的相互作用很简单，这是因为在经典环境中，它们根本不相互作用。例如，考虑下面动态类型程序：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(let ([x 10])
  (begin
    (set! x 5)
    (set! x &quot;某物&quot;)))&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的“类型”是什么？它并没有确定的类型，它在一段时间内是数，&lt;b&gt;后来&lt;/b&gt;（注意里面蕴含时间意味）是字符串。我们根本无法给它定类型。一般来说，类型检查是种&lt;b&gt;非时间性的&lt;/b&gt;活动：它只在程序运行之前执行一次，因此必须独立于程序执行的特定顺序。因此，跟踪贮存中的精确值超出了类型检查程序的能力范围。&lt;/p&gt;&lt;p&gt;上面的例子当然可以简单的静态的被理解，不过我们不能被简单的例子误导。考虑下面的程序：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(let ([x 10])
  (if (even? (read-number &quot;输入数字&quot;))
      (set! x 5)
      (set! x &quot;某物&quot;)))&lt;/code&gt;&lt;p&gt;现在，静态检查不可能得到关于&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型的结论，因为只有在运行时我们才能获得用户输入的值。&lt;/p&gt;&lt;p&gt;为了避免这种情况，传统的类型检查器采用了一个简单策略：赋值过程中类型必须&lt;b&gt;保持不变&lt;/b&gt;。也就是说，赋值操作，不论是变量赋值还是结构体赋值，都不能改变被赋值的量的类型。因此，上面的代码在我们当前的语言中将不能通过类型检查。给程序员提供多少灵活性就取决与语言了。例如，如果我们引入更加灵活的类型表示“数或字符串”，上面的例子将能通过类型检查，但是&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型就永远不那么精确，所有使用&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的地方都需要处理这种降低了的精度，后面我们会回到这个问题。&lt;/p&gt;&lt;p&gt;简而言之，在传统的类型系统中赋值相对容易处理，因为它采用了简单的规则，值可以在类型系统指定的限度下进行改变，但是类型不能被改变。在像&lt;code class=&quot;inline&quot;&gt;set!&lt;/code&gt;这种操作的情况下（或者我们的核心语言中的&lt;code class=&quot;inline&quot;&gt;setC&lt;/code&gt;），这意味着赋值的类型必须和变量的类型匹配。在结构体赋值的情况下，例如&lt;code class=&quot;inline&quot;&gt;box&lt;/code&gt;，这意味着赋值的类型必须和&lt;code class=&quot;inline&quot;&gt;box&lt;/code&gt;容器内容的类型匹配。&lt;/p&gt;&lt;h2&gt;15.2.7 中心定理：类型的可靠性&lt;/h2&gt;&lt;p&gt;之前我们说过，一些静态类型语言可以为其书写的程序所能达成某些特性作出很坚实的证明：例如，该语言书写的程序肯定会终止。当然，一般来说，我们无法获得这样的保证（事实上，正是为了能写出无限循环我们才添加的通用递归）。然而，一个有意义的类型系统——事实上，任何值得&lt;b&gt;类型系统&lt;/b&gt;这一高贵头衔的东西【注释】——应该为所有静态类型程序提供某种有意义的保证。这是给程序员的回报：通过给程序加上类型，她可以确保某些不好的事情不会发生。没有类型的话，我们也能找到bug；这是有用的，但它不足以提供构建高级别工具（例如要保证安全性、隐私性或健壮性）的必要基础。&lt;/p&gt;&lt;blockquote&gt;我们一再使用“类型系统”这个术语。类型系统通常是三个组件的组合：类型的语言、类型规则，以及将这些规则应用于程序的算法。我们的讨论中将类型规则放入函数中，因此模糊了第二者和第三者之间的区别，但它们仍然可以在逻辑上加以区分。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;我们可能希望类型系统给我们提供什么样的保证呢？请记住，类型检查器在程序运行前静态地对程序进行检查。这意味着它本质上是对程序行为的&lt;b&gt;预测&lt;/b&gt;：例如，当它指出某个复杂表达式的类型为&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;，它实际是在预测程序运行时，该表达式将产生一个数值。我们怎么知道这个预测是正确的呢，也就是说检查器从不撒谎？每种类型系统都应该附带一个证明这一点的定理。&lt;/p&gt;&lt;p&gt;对于类型系统存疑有一个很好的理由，不是怀疑主义的那种。类型检查器和程序求值器工作方式上有很多不同：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;类型检查器能见到的只有程序文本，求值器运行在真实的存储器上。&lt;/li&gt;&lt;li&gt;类型环境将标识符绑定到类型，求值器的环境则绑定标识符到值或者存储位置。&lt;/li&gt;&lt;li&gt;类型检查器将值的集合（甚至是无限集合）压缩成类型，而求值器处理的是值本身。&lt;/li&gt;&lt;li&gt;类型检查器一定会终止，求值器不一定会。&lt;/li&gt;&lt;li&gt;类型检查器仅需检查表达式一遍，求值器运行时某个表达式的运行次数可能从零次到无穷次。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因此，我们不应假设这两者将始终对应！&lt;/p&gt;&lt;p&gt;对于给定的类型系统，我们希望达到的核心目标是——该类型系统是&lt;b&gt;可靠的&lt;/b&gt;（sound）。它的意思是：给定表达式（或者程序）&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;，类型检查得出其类型为&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;，当我们运行&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;时，假设得到了值&lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt;，那么&lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt;的类型是&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;证明这个定理的标准方法是分两步进行，&lt;b&gt;进展&lt;/b&gt;（progress）和&lt;b&gt;保持&lt;/b&gt;（preservation）。进展的意思是，如果一个表达式能够通过类型检查，那么它应该能进行进一步求值得到新的东西（除非它本身就是值）；保持的意思是，这个求值步骤前后类型不变。如果我们交错进行这些步骤（先进展再保持，不断重复），可以得出一个结论，最终的结果和最初被求值的表达式类型相同，因此类型系统确实是可靠的。&lt;/p&gt;&lt;p&gt;例如，考虑表达式：&lt;code class=&quot;inline&quot;&gt;(+ 5 (* 2 3))&lt;/code&gt;。它的类型为&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;。在一个可靠的类型系统中，进展证明，由于该表达式能通过类型检查，且其当前不是值，它可以进行一步求值——这里它显然可以。进行一步求值之后，它被规约成了&lt;code class=&quot;inline&quot;&gt;(+ 5 6)&lt;/code&gt;。不出所料，正如保持给出的证明，它的类型也为&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;。进展表明它还能进行一步求值，得到&lt;code class=&quot;inline&quot;&gt;11&lt;/code&gt;。保持再次表明它的类型和上一步的表达式类型相同，都为&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;。现在，进展发现我们已经得到最终结果，无后续要进行的求值步骤，该值的类型和最初的表达式类型相同。&lt;/p&gt;&lt;p&gt;但这不是完整的故事。有两点需要说明：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;程序可能不会得出最终的结果，它可能永远循环。这种情况下，该定理严格来说并不适用。但是我们仍能看到，计算得到的中间表达式类型将一直保持不变，因此即使程序没有最终产生一个值，它仍在进行着有意义的计算。&lt;/li&gt;&lt;li&gt;任何特性足够丰富的语言中都存在一些不能静态决定的属性（有些属性也许本来可以，但是语言的设计者决定将其推迟到运行时决定）。当这类属性出错时——比如，数组的索引越界——关于这种程序没有很好的类型可以约束它们。因此，每个类型完备性定理中都隐含了一组已发布的、允许的异常或者可能发生的错误条件。使用该类型系统的开发者隐式的接受了这些条件。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;作为第二点的一个例子，典型的静态类型语言中，都会指明对于向量的寻址、列表的索引等操作可能抛出异常。&lt;/p&gt;&lt;p&gt;后面这个说明好像站不住脚。事实上，我们很容易忘记这其实是一条关于运行时&lt;b&gt;不能&lt;/b&gt;发生的事情的陈述：这一组异常之外的异常将能被证明不会产生。当然，对最开始就设计为静态类型的语言，除了不那么严格的类比外，可能搞不清这组异常具体是什么，因为一开始本就无须定义它们。但是当我们将类型系统添加到已有的语言时——特别是动态类型语言，如Racket或Python——那么这里已经有一组明确定义的异常，类型检查器将会指明其中一些异常（像“函数调用位置不是函数”或者“未找到方法”）不会发生。这就是程序员接纳类型系统语法上限制所得到的回报。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>MrMathematica</author>
<guid isPermaLink="false">2018-02-18-33865846</guid>
<pubDate>Sun, 18 Feb 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>持久化数据结构学习笔记——序列</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-02-18-33859991.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33859991&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-097294ad42f4c76aa3bebf30e8ba09f7_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;本学期正在修读一门数据结构课程，内容是持久化数据结构（Persistent Data Structures）。我感到这门课的内容十分有趣，希望可以写一些笔记记录一下学习过程。笔记的内容将会围绕课程展开，但是其中主要是我自己的一些思考得出的“私货”。&lt;/p&gt;&lt;p&gt;我们日常接触到的数据结构多是可变的（mutable），这意味着对于一个数据结构的更新将会破坏其过去的版本。与之相对应的，持久化数据结构在更新时会创建一个“新”的数据结构，从而与此同时保证对旧有版本的访问与修改。持久化数据结构可以带来许多好处，比如异常安全（Exception Safety）和并发性（Concurrency）。但是，这并不意味着我们必须为此付出很大的代价。实际上，许多持久化数据结构在实现上会更加自然直观，也可以保持很高的效率。&lt;/p&gt;&lt;p&gt;持久化数据结构与不可变性（Immutability）有一些相关性。我们往往会利用不可变性来实现高效率的持久化数据结构。不可变性保证了同一数据结构的不同版本可以共享相同的部分，从而节省达到节省空间的目的。&lt;/p&gt;&lt;p&gt;让我们从最简单的例子开始。&lt;/p&gt;&lt;h2&gt;序列&lt;/h2&gt;&lt;p&gt;序列（Sequence）是一种抽象数据类型（Abstract Data Type）。它由四个函数定义：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;emtpy&lt;/code&gt; 返回一个空序列&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt; 作用在一个序列上，返回其第一个元素&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt; 作用在一个序列上，返回除去其首元素以后的新序列&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; 作用在一个元素和一个序列上，返回一个新的序列，使得 &lt;code class=&quot;inline&quot;&gt;first (cons h t) = h&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;rest (cons h t) = t&lt;/code&gt; 成立&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在OCaml中，上述定义表达如下&lt;/p&gt;&lt;code lang=&quot;ocaml&quot;&gt;module type sequence = sig
    type &#39;a sequence
    val empty : &#39;a sequence
    val first : &#39;a sequence -&amp;gt; &#39;a option
    val rest : &#39;a sequence -&amp;gt; &#39;a sequence option
    val cons : &#39;a -&amp;gt; &#39;a sequence -&amp;gt; &#39;a sequence 
end&lt;/code&gt;&lt;p&gt;在函数式语言中常见的列表（List）就是一个符合本定义的数据结构。值得注意的是列表就是一个持久化数据结构的简单例子。列表是非常高效的，上述函数的时间复杂度均为&lt;equation&gt;O(1)&lt;/equation&gt; ，同时其不可变性保证了高效的内存利用与持久性。&lt;/p&gt;&lt;p&gt;但是，如果我们并不需要频繁使用以上操作，而希望我们的序列有相对高效的随机访问呢？我们在之前的序列定义中添加一个新的接口 &lt;code class=&quot;inline&quot;&gt;index : int -&amp;gt; &#39;a sequence -&amp;gt; &#39;a option&lt;/code&gt; ，作用在一个整数和一个序列上，返回其对应位置的元素。符合我们要求的新的实现可以有相对较慢的 &lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; ，但是需要有比&lt;equation&gt;O(n)&lt;/equation&gt; 更快的 &lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 。一个自然的想法是使用树状的结构代替线性结构提高访问效率。&lt;/p&gt;&lt;h2&gt;第一个尝试&lt;/h2&gt;&lt;p&gt;我们选择使用二叉树来存储（编码？encode?）一个序列结构，这要求我们在序列的位置和二叉树的中存储元素的位置之间建立一个双射。一个比较显而易见的做法是选取一棵深度为&lt;equation&gt;k&lt;/equation&gt; 的满二叉树，用他的所有叶子结点来存储数据。叶子结点从左向右分别标注为 &lt;equation&gt;0&lt;/equation&gt; 至 &lt;equation&gt;2^{k-1}-1&lt;/equation&gt; 。这样我们建立了这棵树的叶子结点和序列中的位置的一一对应。并不令人意外的是，这种对应关系实际上就是 &lt;equation&gt;0&lt;/equation&gt; 至 &lt;equation&gt;2^n-1&lt;/equation&gt; 的自然数的 &lt;equation&gt;n&lt;/equation&gt; 位二进制（高位补全 &lt;equation&gt;0&lt;/equation&gt; ）表示。这一关系给出了一个查找我们的二叉树中的元素的方法：将序列中的位置转换成二进制表示，补齐高位的零，然后从二叉树的根节点开始，按照二进制表示的从高位到低位，逢0向左逢1向右，直至达到叶子结点。&lt;/p&gt;&lt;p&gt;以上思路给出了一个看似可能的实现。但是，这一次尝试中我们只使用了二叉树的叶子结点，造成了空间的浪费。这一点并没有真的影响到我们的实现的空间复杂度。但是，它暴露出了一件更重要的事情：我们的思路引入了不必要的信息，而这是不自然的。&lt;/p&gt;&lt;h2&gt;解决方法&lt;/h2&gt;&lt;p&gt;让我们试着分析一下这件事的原因是什么。我们为了让自然数和它的二进制表示是一一对应，必须限定二进制表示的位数，同时对位数不足的二进制表示补全高位的0。这种关系是我们人为限定的，而我们引入的冗余信息就是对二进制表示的位数的限定，与之相对应的，就是我们只使用了二叉树的叶子结点，而空置了其余节点。那么，解决这个问题的思路似乎明朗了。我们需要找寻一种自然数的表示，它必须是base-2的（只使用两种符号，与二叉树的结构对应），使得他是一种同构计数（Bijective Numeration）。换句话说，我们需要的表示是一个由两种字符 &lt;equation&gt;\{a,b\}&lt;/equation&gt; 构成的任意长度的字符串。我们需要做的就是赋予这些字符串组成的集合 &lt;equation&gt;\{a,b\}^*&lt;/equation&gt; 一个到自然数集的双射。&lt;/p&gt;&lt;p&gt;我们选取 &lt;equation&gt;1&lt;/equation&gt; 和 &lt;equation&gt;2&lt;/equation&gt; 来组成这个字符串。我们用空字符串 &lt;equation&gt;\varepsilon&lt;/equation&gt; 来表示 &lt;equation&gt;0&lt;/equation&gt; ，用 &lt;equation&gt;a_n…a_1a_0&lt;/equation&gt; 表示&lt;equation&gt;\sum_{i=0}^n a_i2^i&lt;/equation&gt;&lt;i&gt;，&lt;/i&gt;其中&lt;equation&gt;a_i\in\{1,2\}&lt;/equation&gt;. 例如：&lt;equation&gt;4&lt;/equation&gt;被表示为&lt;equation&gt;12&lt;/equation&gt;，&lt;equation&gt;7&lt;/equation&gt;被表示为&lt;equation&gt;111&lt;/equation&gt;。容易证明这种表示是一个双射。这是一种常用的计数方法，被称为bijective base-2 numeration。&lt;/p&gt;&lt;p&gt;由此，我们可以得到一个更紧凑的在二叉树中存储序列的方法。将表示序列位置的自然数展开成它的bijective base-2表示（展开方法类似二进制数），然后从树的根节点、二进制表示的最高位开始逢1向左逢2向右直至走完，停止的位置就是在二叉树中应该存放的位置。直观上看，二叉树中的节点被我们从上到下从左到右依次标注。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8cb20f6c28b55ccfb0ec61c8e0b6e34e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1444&quot; data-rawheight=&quot;1444&quot;&gt;&lt;p&gt;如果我们选用这样的结构，&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 的实现是显然的。随着元素增多，这棵树的形态始终是接近满的，这保证了&lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 一定是 &lt;equation&gt;O(\log n)&lt;/equation&gt; 的。但是，似乎并没有一个直观的方法提示我们应该如何高效的实现 &lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt;。究其原因，每当我们插入新元素或者去除旧元素时，树的结构会被破坏，每一个其中的元素的位置都会受到影响。同时，甚至是 &lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 的实现都是不甚自然的，因为我们需要首先展开一个自然数，完整存储这个结果，再从高到低使用。那么，如果我们使用逆序的bijective base-2 numeration呢？&lt;/p&gt;&lt;h2&gt;新的结构 Braun tree&lt;/h2&gt;&lt;p&gt;考虑一个序列 &lt;equation&gt; \varepsilon,1,2,11,12,21,22,…&lt;/equation&gt; 如果把它们当作逆序以后的表示，即 &lt;equation&gt;a_0a_1…a_n&lt;/equation&gt; 表示 &lt;equation&gt;\sum_{i=0}^n a_i2^i&lt;/equation&gt; ，那么这个序列将对应 &lt;equation&gt;0,1,2,3,5,4,6,…&lt;/equation&gt; 用这样的表示来编码二叉树中的位置，我们会得到结构如下的树：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-097294ad42f4c76aa3bebf30e8ba09f7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1588&quot; data-rawheight=&quot;1114&quot;&gt;&lt;p&gt;这样的树被称为Braun tree。这个改变看似只是方便了我们实现&lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt;，但它却具有更大的意义。Braun tree 具有如下的性质：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Braun tree的左支和右支都是Braun tree&lt;/li&gt;&lt;li&gt;Braun tree的左支的元素个数只可能和右支相等或多1&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第二条性质保证了Braun tree总是平衡的的，我们可以高效的访问它的节点。第一条性质保证了我们可以方便地递归实现对于Braun tree的一些操作。同时，我们发现对于任意的&lt;equation&gt;i&lt;/equation&gt;，序数是&lt;equation&gt;2i+1&lt;/equation&gt;的元素和&lt;equation&gt;2i+2&lt;/equation&gt;的元素总是在同一父节点的左右子树中处在同一个位置。这个性质和我们选取的自然数的逆序同构表示是直接相关的。这一性质为我们提供了高效实现 &lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt; 的思路。&lt;/p&gt;&lt;p&gt;当我们想要在Braun tree的根节点增加新元素时，我们新增元素替换了旧的根节点元素。由于上述性质，新的二叉树的右子树将是当前的左子树，新的左子树将是旧的二叉树的右子树增加了旧根节点元素以后的结果。我们可以递归地将根节点替换，将旧元素插入右子树，然后交换左右子树。&lt;/p&gt;&lt;h2&gt;OCaml 实现&lt;/h2&gt;&lt;p&gt;我们按照上述讨论在OCaml中定义Braun tree，并声明它是序列的一种实现：&lt;/p&gt;&lt;code lang=&quot;ocaml&quot;&gt;type &#39;a brt = Empty | Node of &#39;a * &#39;a brt * &#39;a brt
type &#39;a sequence = &#39;a brt&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt; 的实现非常显然，在此不做赘述。&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; 应当对它作用的的Braun tree进行判断，如果为空则返回只有一个节点的树，否则按照我们的讨论返回一个新的树，其根节点是新的元素。&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; 实现如下：&lt;/p&gt;&lt;code lang=&quot;ocaml&quot;&gt;let rec cons x = function
    Empty -&amp;gt; Node (x, Empty, Empty)
  | Node (x&#39;, lt, rt) -&amp;gt; Node (x, cons x&#39; rt, lt)&lt;/code&gt;&lt;p&gt;要实现 &lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt; ，更容易入手的方法是实现&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; 的逆运算&lt;code class=&quot;inline&quot;&gt;uncons&lt;/code&gt;。&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; 作用在一个元素和一棵树上，返回一棵新树。&lt;code class=&quot;inline&quot;&gt;uncons&lt;/code&gt; 则应当作用在一棵树上，“拆解”出它的根节点，并返回根节点元素和一棵由剩余元素组成的树。考虑到&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;的值域中没有&lt;code class=&quot;inline&quot;&gt;Empty&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;uncons&lt;/code&gt; 的返回值应当是一个 &lt;code class=&quot;inline&quot;&gt;option&lt;/code&gt; 类型。因此，&lt;code class=&quot;inline&quot;&gt;uncons&lt;/code&gt; 的类型应当为 &lt;code class=&quot;inline&quot;&gt;&#39;a sequence -&amp;gt; (&#39;a * &#39;a sequence) option&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;由于&lt;code class=&quot;inline&quot;&gt;uncons&lt;/code&gt; 是 &lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;的逆运算，它的实现可以直接得到。对于空的树，我们应当返回&lt;code class=&quot;inline&quot;&gt;None&lt;/code&gt;。而对于非空的树，我们返回的“拆解”下的元素则为当前的根节点。同时我们应当对这棵树的左子树（由旧的树的右子树&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;旧的根节点得到）递归地进行&lt;code class=&quot;inline&quot;&gt;uncons&lt;/code&gt;，如果返回结果是一个元素和一棵树构成的二元组，那么我们返回的树的根节点为递归返回的元素，左右子树分别是当前的右子树和递归返回的树。如果递归返回的结果是&lt;code class=&quot;inline&quot;&gt;None&lt;/code&gt;，返回的树应当为空。在OCaml中实现如下：&lt;/p&gt;&lt;code lang=&quot;ocaml&quot;&gt;let rec uncons = function
    Empty -&amp;gt; None
  | Node (x, lt, rt) -&amp;gt;
     match uncons lt with
       None -&amp;gt; Some (x, Empty)
     | Some (x&#39;, lt&#39;) -&amp;gt; Some (x, Node (x&#39;, rt, lt&#39;))

let rest t = match uncons t with
    None -&amp;gt; None
  | Some (_, t&#39;) -&amp;gt; Some t&#39;&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 我们已经进行了详细的讨论，它的实现在此按下不表。&lt;/p&gt;&lt;h2&gt;分析总结&lt;/h2&gt;&lt;p&gt;上述的实现保证了持久性，同时有相对较高的效率。&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 的时间复杂度均为&lt;equation&gt;O(\log n)&lt;/equation&gt;，同时由于我们的实现是不可变的，新旧版本的树可以共享数据和节点。值得注意的是想要用&lt;equation&gt;n&lt;/equation&gt;个元素创建一棵Braun tree可以在&lt;equation&gt;O(n)&lt;/equation&gt;的时间完成，具体的实现参见文末Okasaki的文章。&lt;/p&gt;&lt;p&gt;Braun tree的序列实现并不是非常的高效，但至少是可用的。同时Braun tree本身是一种在持久化数据结构中时常出现的数据结构，它被用来实现很多复杂的数据结构。除此以外，实际应用中也有和传统的序列（如C++ vector）一样高效的持久化实现，比如Clojure的persistent vector。&lt;/p&gt;&lt;h2&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.eecs.northwestern.edu/~robby/courses/395-495-2013-fall/three-algorithms-on-braun-trees.pdf&quot;&gt;Three Algorithms on Braun Trees by Chris Okasaki&lt;/a&gt;&lt;/p&gt;</description>
<author>廿人口木</author>
<guid isPermaLink="false">2018-02-18-33859991</guid>
<pubDate>Sun, 18 Feb 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>delimited continuations完全攻略</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-02-15-33399006.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33399006&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-eb471c83c20ac7b33a45d0f2bf17a90c_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;宣传一下我的群：Expert Scheme：523791077&lt;/p&gt;&lt;p&gt;&lt;b&gt;Part I ： shift and reset&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;警告：在racket中使用shift/reset，请加上这句：&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(require racket/control)&lt;/code&gt;&lt;p&gt;&lt;b&gt;A. shift和reset的基本规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;要了解shift和reset如何使用，就必须先了解shift和reset的求值规则：&lt;/p&gt;&lt;p&gt;当reset的内部是简单表达式的时候，整个表达式直接返回其值。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (+ 1 2)) =&amp;gt; 3&lt;/code&gt;&lt;p&gt;当reset的内部的shift被求值时，需要注意，返回shift的body。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (+ 1 (shift k 2)))  =&amp;gt; 2&lt;/code&gt;&lt;p&gt;把reset想象成一个整块，shift就是在其中打洞。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(+ 1 hole)&lt;/code&gt;&lt;p&gt;你现在需要一个值把洞填上去，我们可以写一个函数：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (hole) (+ 1 hole))&lt;/code&gt;&lt;p&gt;而shift的第一个标识符k所绑定的值就是这个函数(一般称为continuation，用字母k表示，或者用ctx表示）。&lt;/p&gt;&lt;p&gt;这个表达式：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (+ (shift k (k (k 1))) 1))&lt;/code&gt;&lt;p&gt;我们的k函数应当是（注意，这个例子中的hole与上一个例子的hole位置是不同的）&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (hole) (+ hole 1))&lt;/code&gt;&lt;p&gt;整个表达式应当返回shift的body部分，即：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(k (k 1))&lt;/code&gt;&lt;p&gt;而我们已经知道k的值了，直接带入表达式计算得出3。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;B. 与Arclisp中方括号的关系&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;Since functions of one argument are so often used in Lisp programs,&lt;br&gt;Arc has a special notation for them.  [... _ ...]  is an abbreviation&lt;br&gt;for (fn (_) (... _ ...)).  So our first map example could have been&lt;br&gt;written&lt;br&gt;&lt;br&gt;arc&amp;gt; (map [+ _ 10] &#39;(1 2 3))&lt;br&gt;(11 12 13)&lt;/blockquote&gt;&lt;p&gt;Arclisp允许你在表达式中开洞，这样表达式就成了一个函数。&lt;/p&gt;&lt;p&gt;而reset/shift中也允许你这么做。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (shift k k))  = 
(lambda (x) x) = 
[ _ ] (in Arclisp)&lt;/code&gt;&lt;p&gt;第二个例子：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (+ 1 (* 2 (shift k k))))  =
(lambda (x) (+ 1 (* 2 x)))  =
[+ 1 (* 2 _)] (in Arclisp)&lt;/code&gt;&lt;p&gt;我们发现Arclisp中的_与(shift k k)某种意义上有很大的相似性。&lt;/p&gt;&lt;p&gt;下面是一个更酷的例子：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (+ (shift k1 k1) (shift k2 k2)))&lt;/code&gt;&lt;p&gt;为了区分前后两个k，我将它们分别标记为k1和k2。&lt;/p&gt;&lt;p&gt;很明显k1是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x1)
  (+ x1 (shift k2 k2)))&lt;/code&gt;&lt;p&gt;我们的reset表达式返回了k1。&lt;/p&gt;&lt;p&gt;尝试向k1这个函数中喂一个值2：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(+ 2 (shift k2 k2))&lt;/code&gt;&lt;p&gt;现在你应该感到犯难了，还有一个shift表达式，但是外层已经没有reset了。&lt;/p&gt;&lt;p&gt;于是shift并不知道把k2返回到哪里，也不知道&lt;b&gt;打洞的范围是多大&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;k2是:&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x) x)&lt;/code&gt;&lt;p&gt;还是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x) (+ 2 x))&lt;/code&gt;&lt;p&gt;幸运的是，shift和reset已经帮我们考虑到这个难题了，会帮我们自动地在k1体内加一个reset。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;k1 = (lambda (x1) (reset (+ x1 (shift k2 k2))))&lt;/code&gt;&lt;p&gt;很明显，我们可以直接写出k2 （别弄丢了reset）：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x2) (reset (+ x1 x2)))&lt;/code&gt;&lt;p&gt;综合起来结果就是&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x1)
  (lambda (x2)
    (+ x1 x2)))&lt;/code&gt;&lt;p&gt;因为当reset体内没有shift时，直接返回其值，所以我们可以将两个reset消去。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;请验证 (shift k (k &lt;i&gt;val&lt;/i&gt;))和&lt;i&gt;val&lt;/i&gt;在reset体内是等价的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;C. 重新认识shift/reset&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们从shift里面获得一个k，上一节讨论过这个k应当是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x) (reset expr ...))&lt;/code&gt;&lt;p&gt;考虑下面的表达式：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (shift k (shift k 1)))&lt;/code&gt;&lt;p&gt;结果是1，按照我们原来的规则进行求值：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;=&amp;gt; (shift k 1)&lt;/code&gt;&lt;p&gt;遇到了同样的难题！外层没有reset，肯定是自动帮我们加的:&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;=&amp;gt; (reset (shift k 1))&lt;/code&gt;&lt;p&gt;所以，是时候拓展我们的求值规则了。&lt;/p&gt;&lt;p&gt;(reset val) =&amp;gt; val&lt;br&gt;(reset E[(shift k expr)]) =&amp;gt; (&lt;b&gt;reset&lt;/b&gt; ((lambda (k) expr) (lambda (v) (&lt;b&gt;reset&lt;/b&gt; E[v]))))&lt;br&gt; ; where E has no reset&lt;/p&gt;&lt;p&gt;我将其中需要添加reset的部分用粗体标出。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;D. 与不确定性计算，list monad的关系&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这是一个计算a+b是否等于c的程序，如果等于c，那么输出整个式子：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(let ([a 1])
  (let ([b 1])
    (let ([c 2])
      (when (= (+ a b) c) (printf &quot;~a+~a=~a\n&quot; a b c)))))&lt;/code&gt;&lt;p&gt;可以把他们写成reset/shift的形式：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (let ([a (shift k (k 1))])
         (let ([b (shift k (k 1))])
           (let ([c (shift k (k 2))])
             (when (= (+ a b) c) (printf &quot;~a+~a=~a\n&quot; a b c))))))&lt;/code&gt;&lt;p&gt;两种写法是等价的，现在我们的a，b，c可能是多个不确定的值，也就是要进行多次计算。&lt;/p&gt;&lt;p&gt;我们可以把k想象成填一个值，进行一次计算，于是我们将函数k进行细胞分裂，多次计算。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (let ([a (shift k (k 1) (k 2) (k 3))])
         (let ([b (shift k (k 1) (k 2) (k 3))])
           (let ([c (shift k (k 1)(k 2)(k 3))])
             (when (= (+ a b) c) (printf &quot;~a+~a=~a\n&quot; a b c))))))&lt;/code&gt;&lt;p&gt;返回结果：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;1+1=2
1+2=3
2+1=3&lt;/code&gt;&lt;p&gt;如果你觉得这个例子难以理解，那么下面的呢（输出 123）：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (let ([a (shift k (k 1) (k 2) (k 3))])
         (print a)))&lt;/code&gt;&lt;p&gt;list monad或是list comprehension是一种很好用的计算列表的方法，但是racket中没有do notation，必须用宏来替代。（实际上racket提供了for comprehension作为替代方案，我们这里为了演示reset和shift的作用不考虑。）&lt;/p&gt;&lt;p&gt;但是，我们也可以用reset和shift来直接实现：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define return list)
(define (in-list lst)
  (shift k
         (apply append
                (map k lst))))

(reset (let ([a (in-list &#39;(1 2 3))]
             [b (in-list &#39;(1 2 3))])
         (return (list a b))))&lt;/code&gt;&lt;p&gt;返回结果：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&#39;((1 1) (1 2) (1 3) (2 1) (2 2) (2 3) (3 1) (3 2) (3 3))&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;E. 与状态，state monad的关系&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在一些语言中不支持赋值语句，无法保存状态，可以用state monad来模拟，同样地，state monad也可以用reset和shift模拟。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (get)
  (shift k (lambda (s) ((k s) s))))
(define (put s)
  (shift k (lambda (-s)
             ((k (void)) s))))
(define ((return x) s) x)&lt;/code&gt;&lt;p&gt;下面展现了一个很有意思的例子：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (tick)
  (let ([a (get)])
    (put (+ a 1))))
((reset (tick)
       (tick)
       (tick)
       (return (get))) 0)&lt;/code&gt;&lt;p&gt;试试看用shift和reset是否能实现其他monad。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;F. 与stream，generator的关系&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当我们需要表示无穷时，我们通常借助于stream与generator，而shift/reset与这二者间有着微妙的关系。&lt;/p&gt;&lt;p&gt;我们需要使用define-syntax-rule，不了解的请看：&lt;a href=&quot;http://docs.racket-lang.org/reference/stx-patterns.html?q=define-syntax-rule#%28form._%28%28lib._racket%2Fprivate%2Fmisc..rkt%29._define-syntax-rule%29%29&quot;&gt;12.1 Pattern-Based Syntax Matching&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;看下面的例子：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define s (reset (shift k (stream-cons 1 (k (void))))
                 (shift k (stream-cons 2 (k (void))))
                 (shift k (stream-cons 3 (k (void))))
                 (shift k &#39;())))&lt;/code&gt;&lt;p&gt;这个例子生成了一个内容为1 2 3的stream，而内部的语法却接近generator！&lt;/p&gt;&lt;p&gt;我们可以写宏来让你看的更加清楚：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define-syntax-rule (stream/generate expr ...)
  (reset expr ...))
(define-syntax-rule (stream/yield expr ...)
  (shift k (stream-cons (begin expr ...) (k (void)))))

(define s (stream/generate
           (stream/yield 1)
           (stream/yield 2)
           (stream/yield 3)))

(define (integer-sequences x)
  (stream/generate (stream/yield x)
                   (integer-sequences (+ x 1))))&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;用shift和reset实现generator的任务更为艰巨，我们曾经在&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25749077&quot;&gt;愉悦的scheme之旅（2）--用callcc合成控制流&lt;/a&gt;介绍过用call/cc实现的generator，但是因为有了shift和reset一切都变简单了。&lt;/p&gt;&lt;p&gt;我们需要使用syntax-parameter，不了解的请看&lt;a href=&quot;http://docs.racket-lang.org/reference/stxparam.html?q=syntax-parameter&quot;&gt;12.5 Syntax Parameters&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;完整程序如下：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang racket
(require racket/control racket/stxparam)
(define-syntax-parameter yield 
  (syntax-rules ()
    [(_ expr ...)
     (raise-syntax-error &#39;generator-err
                         &quot;You must use yield in the body of generator&quot;)]))

(define-syntax-rule (generate expr ...)
  (letrec ([state (lambda ()
                 (syntax-parameterize
                     ([yield (syntax-rules ()
                               [(_ expr2 (... ...)) (shift k
                                                           (set! state
                                                                 (lambda () (k (void))))
                                                           (values expr2 (... ...)))])])
                   (reset (begin expr ... (void)))))])
    (lambda ()
      (state)
      )))
(define g (generate (yield 1)
                    (yield 6)
                    (yield 7)
                    (yield 10)))&lt;/code&gt;&lt;p&gt;宏会干扰我们的思考，我们看看展开后是什么样子吧。&lt;/p&gt;&lt;p&gt;racket的macro stepper是宏调试的利器，通过它，我们可以直接看到展开的结果：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(syntax-parameterize
  ((yield
    (syntax-rules ()
      ((_ expr2 ...)
       (shift k (set! state (lambda () (k (void)))) (values expr2 ...))))))
  (reset (begin (yield 1) (yield 6) (yield 7) (yield 10) (void))))&lt;/code&gt;&lt;p&gt;这并不是最终的结果，因为syntax-parameterize没有展开,由于一些限制，我们手动展开一下：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (begin (shift k (set! state (lambda () (k (void)))) (values 1))
                (shift k (set! state (lambda () (k (void)))) (values 6))
                (shift k (set! state (lambda () (k (void)))) (values 7))
                (shift k (set! state (lambda () (k (void)))) (values 10))
                (void)))&lt;/code&gt;&lt;p&gt;现在应该看的很清楚了，第一次调用时返回1，state则变成了：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda () (reset (begin (void)
                         (shift k (set! state (lambda () (k (void)))) (values 6))
                         (shift k (set! state (lambda () (k (void)))) (values 7))
                         (shift k (set! state (lambda () (k (void)))) (values 10))
                         (void))))&lt;/code&gt;&lt;p&gt;剩下的应该不难了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;G.  算法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;考虑函数genlist：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(genlist &#39;(1 2)) =&amp;gt; &#39;((1) (1 2))
(genlist &#39;(1 2 3 4)) =&amp;gt; &#39;((1) (1 2) (1 2 3) (1 2 3 4))&lt;/code&gt;&lt;p&gt;有人会这么做：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (genlist lst)
  (define (genlist lst last)
    (if (null? lst) &#39;()
        (let ([x (append last (list (car lst)))])
          (cons x (genlist (cdr lst) x)))))
  (genlist lst &#39;()))&lt;/code&gt;&lt;p&gt;可惜效率并不高，因为多次向队尾插入数据。&lt;/p&gt;&lt;p&gt;借助CPS，我们可以这么写（其实也可看成difference list）：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (genlist lst)
  (define (genlist lst ctx)
    (if (null? lst)
        (list (ctx &#39;()))
        (cons (ctx (list (car lst)))
              (genlist (cdr lst)
                       (lambda (x) (ctx (cons (car lst) x)))))))
  (if (null? lst)
      &#39;()
      (genlist lst (lambda (x) x))))&lt;/code&gt;&lt;p&gt;考虑lst=&#39;(1 2 3 4)的情况，ctx分别是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;ctx1 = [list* _]
ctx2 = [list* 1 _]
ctx3 = [list* 1 2 _]
ctx4 = [list* 1 2 3 _]&lt;/code&gt;&lt;p&gt;我们可以用shift和reset重写：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (genlist lst)
  (define (genlist lst)
    (if (null? lst)
        (shift k &#39;())
        (shift k
               (cons (k (list (car lst)))
                     (reset (k (cons (car lst)
                                     (genlist (cdr lst)))))))))
  (reset (genlist lst)))&lt;/code&gt;&lt;p&gt;可以自己尝试推倒一下。&lt;/p&gt;&lt;p&gt;shift和reset还能做其他一些算法例如cps变换，anf变换，closure conversion等，这里不再详细介绍。&lt;/p&gt;&lt;p&gt;新手的课后作业：&lt;/p&gt;&lt;p&gt;尝试用shift和reset实现cps变换和anf变换。&lt;/p&gt;&lt;p&gt;老手的课后作业(难度非常大，做好心理准备）：&lt;/p&gt;&lt;p&gt;阅读&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.schemeworkshop.org/2016/scheme16-paper6.pdf&quot;&gt;Deriving Pure, Naturally-Recursive Operations for Processing Tail-Aligned Lists&lt;/a&gt;(SCHEME AND FUNCTIONAL PROGRAMMING WORKSHOP 2016)&lt;/p&gt;&lt;p&gt;并尝试用shift和reset改写其中的算法。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Part II : shift0 and reset0&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;A. 求值规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;直接给出shift0和reset0的求值规则：&lt;/p&gt;&lt;p&gt;(reset0 &lt;i&gt;val&lt;/i&gt;) &lt;a href=&quot;file:///C:/Program%20Files/Racket/doc/reference/if.html?q=shift#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29&quot;&gt;=&amp;gt;&lt;/a&gt; &lt;i&gt;val&lt;/i&gt;&lt;/p&gt;&lt;p&gt;(reset0 &lt;i&gt;E&lt;/i&gt;[(shift0 &lt;i&gt;k&lt;/i&gt; &lt;i&gt;expr&lt;/i&gt;)]) &lt;a href=&quot;file:///C:/Program%20Files/Racket/doc/reference/if.html?q=shift#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29&quot;&gt;=&amp;gt;&lt;/a&gt; ((lambda (&lt;i&gt;k&lt;/i&gt;) &lt;i&gt;expr&lt;/i&gt;) (lambda (&lt;i&gt;v&lt;/i&gt;) (&lt;b&gt;reset0&lt;/b&gt; &lt;i&gt;E&lt;/i&gt;[&lt;i&gt;v&lt;/i&gt;])))&lt;/p&gt;&lt;p&gt;仔细比较与shift和reset的不同，你会发现是不是少了一个reset0，也就是说&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset0 (shift0 k expr)) =&amp;gt; expr&lt;/code&gt;&lt;p&gt;而不是&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (shift k expr)) =&amp;gt; (reset expr)&lt;/code&gt;&lt;p&gt;那么思考下面这段程序，k1和k2分别是什么？&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset0 (+ 1
           (reset0 (+ 2 (shift0 k1 (shift0 k2 3))))))&lt;/code&gt;&lt;p&gt;k1是显而易见的：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x1)
  (reset0 (+ 2 x1)))&lt;/code&gt;&lt;p&gt;根据我们刚才讨论的内容继续求值：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;=&amp;gt; (reset0 (+ 1 (shift0 k2 1)))&lt;/code&gt;&lt;p&gt;然后就能得到k2了&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x2) (reset0 (+ 1 x2)))&lt;/code&gt;&lt;p&gt;这里，我们最先得到的k1，是内层的continuation，而k2，是外层的continuation。&lt;/p&gt;&lt;p&gt;我们可以将他们组合一下，得到整个continuation：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset0 (+ 1 (reset0
              (+ 2 (shift0 k1
                           (shift0 k2 (k2 (k1 3))))))))&lt;/code&gt;&lt;p&gt;这与 (+ 1 (+ 2 3))是等价的。&lt;/p&gt;&lt;p&gt;我们捕获的continuation具有了层次这一概念，接下来我们该利用这一特点搞事了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;B. 括号解析&lt;/b&gt;&lt;/p&gt;&lt;p&gt;下面思考这个问题，给与一个含有左括号的标记&#39;left 和右括号标记的&#39;right的列表，将其转换成有层次的列表。&lt;/p&gt;&lt;p&gt;(parse-parens &#39;(a b left c right)) =&amp;gt; &#39;(a b (c))&lt;/p&gt;&lt;p&gt;(parse-parens &#39;(a left b left c right right d)) =&amp;gt; &#39;(a (b (c)) d)&lt;/p&gt;&lt;p&gt;现在我们考虑解析&#39;(a b left c right)，以continuation的思维来看的话：&lt;/p&gt;&lt;p&gt;符号a ，ctx = (lambda (x) x)&lt;/p&gt;&lt;p&gt;符号b，ctx = (lambda (x) (cons a x))&lt;/p&gt;&lt;p&gt;符号left，ctx = (lambda (x) (list* a b x))&lt;/p&gt;&lt;p&gt;到这里我们就觉得有些困难了，因为left c right是一个整体，我们必须要解析到right才能知道这个整体的内容是&#39;(c)。&lt;/p&gt;&lt;p&gt;我们可以考虑使用双层的continuation：&lt;/p&gt;&lt;p&gt;符号a，ctx-inner = (lambda (x) x) ctx-outer = (lambda (x) x)&lt;/p&gt;&lt;p&gt;符号b，ctx-inner = (lambda (x) x) ctx-outer = (lambda (x) (cons a x))&lt;/p&gt;&lt;p&gt;符号left,ctx-inner = (lambda (x) x) ctx-outer = (lambda (x) (list* a b x))&lt;/p&gt;&lt;p&gt;符号c ,  ctx-inner = (lambda (x) (cons c x)) ctx-outer = (lambda (x) (list* a b x))&lt;/p&gt;&lt;p&gt;符号right , 清空ctx-inner， 结果送入ctx-outer&lt;/p&gt;&lt;p&gt;ctx-inner = (lambda (x) x) ctx-outer = (lambda (x) (list* a b c x))&lt;/p&gt;&lt;p&gt;解析完毕，清空ctx-outer。&lt;/p&gt;&lt;p&gt;解析时ctx-inner负责处理内部，ctx-outer负责解析外部。&lt;/p&gt;&lt;p&gt;当我们的括号的层次不止两层时，我们的ctx也不止两个，无穷无尽的ctx组成了一个ctx栈。&lt;/p&gt;&lt;p&gt;现在，考虑如何用shift0和reset0实现：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (parse-parens lst)
  (define (parse-parens lst)
    (if (null? lst) &#39;()
        (match (car lst)
          [&#39;left (reset0 (parse-parens (cdr lst)))]
          [&#39;right (shift0 k1 (shift0 k2 (reset0 (k2 (cons (k1 &#39;()) (parse-parens (cdr lst)))))))]
          [_ (shift0 k (reset0 (k (cons (car lst) (parse-parens (cdr lst))))))])))
  (reset0 (parse-parens lst)))&lt;/code&gt;&lt;p&gt;每次遇到left时，我们开辟一个新的reset0层，每次遇到right时，我们将该层次闭合。&lt;/p&gt;&lt;p&gt;这是利用同样办法写出来的表达式解析器：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (parse-exp lst)
  (define (parse-exp lst)
    (if (null? lst) (error &quot;No exp&quot;)
        (match lst
          [(list (? number? x)) x]
          [(list (? number? x) (and (or &#39;+ &#39;-) op) rst ...) (shift0 k1
                                                                    (shift0 k2 (shift0 k3
                                                                                       (reset0 
                                                                                        (list op  (k3 (k2 (k1 x))) (reset0
                                                                                                                    (reset0
                                                                                                                     (parse-exp rst))))))))]
          [(list (? number? x) (and (or &#39;* &#39;/) op) rst ...) (shift0
                                                             k1 (shift0 k2
                                                                        (reset0  (list op (k1 (k2 x)) (reset0
                                                                                                       (parse-exp rst))))))]
          [(list (? number? x) (and &#39;^ op) rst ...) (shift0
                                                     k (reset0
                                                        (list op (k x) (parse-exp rst))))]
          )))
  (reset0 (reset0 (reset0 (parse-exp lst)))))&lt;/code&gt;&lt;p&gt;比如1+2*3^6-7*8的层次是：&lt;/p&gt;&lt;p&gt;1 + [ 2 * (3^6) ] - [ 7*8 ]&lt;/p&gt;&lt;p&gt;这就是为什么有三个优先级就需要三个reset0的缘故。&lt;/p&gt;&lt;p&gt;课后作业：&lt;/p&gt;&lt;p&gt;1.可以用shift0和reset0实现shift和reset吗，试试看。&lt;/p&gt;&lt;p&gt;2.这个表达式解析器存在一个缺陷，所有操作符都会视为左结合的，然而：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(parse-exp &#39;(1 ^ 2 ^ 3))  =&amp;gt; &#39;(^ (^ 1 2) 3)&lt;/code&gt;&lt;p&gt;指数运算应当是右结合的，请尝修复这个bug。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>御坂黒子</author>
<guid isPermaLink="false">2018-02-15-33399006</guid>
<pubDate>Thu, 15 Feb 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>【OI】【奇技淫巧】bitset在OI中的应用</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-01-29-33406432.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33406432&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d825293370685bfc6c285d7b2ad50ea1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;震惊，GDKOI2018D1T3竟有bitset水法！&lt;/p&gt;&lt;p&gt;作为一只标准蒟蒻，我在学不会标准正解FFT的情况下然后去学了一下bitset。。。&lt;/p&gt;&lt;p&gt;一般你翻开一个关于介绍bitset的blog，基本画风是这样的：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e433874acf5a3b6b77c4413512410809_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;761&quot;&gt;&lt;p&gt;（来源：&lt;a href=&quot;https://www.cnblogs.com/BaiYiShaoNian/p/4591167.html&quot;&gt;https://www.cnblogs.com/BaiYiShaoNian/p/4591167.html&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;然而作为菜鸡的我一看完就有点懵，不是说bitset可以快速查找某一个元素喵，这些...都是处理二进制的呀。&lt;/p&gt;&lt;p&gt;然后经过我的几次无脑实验我大概就摸清了使用bitset的基本套路：&lt;/p&gt;&lt;p&gt;1、bitset其实是可以看做是&lt;b&gt;一个bool类型的数组&lt;/b&gt;，只不过bitset的一个元素只占1bit的空间，而bool里面则是占1byte，这样就相当于同时减少了时间复杂度和空间复杂度，这也是bitset的优势所在。&lt;/p&gt;&lt;p&gt;2、使用bitset的时候你需要先声明，类似声明vector一样，基本格式：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;#include&amp;lt;bitset&amp;gt;
bitset&amp;lt;10005&amp;gt;a;  //10005是bitset的大小，相当于数组大小，a就相当于一个bool数组。&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;3、前面说了bitset是基本和bool数组的用法一样的，所以其实赋值的时候&lt;b&gt;完全可以这样写&lt;/b&gt;：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;a[0]=1;//等价于写a.set(0);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;4、那么话说回来&lt;b&gt;如何快速查找一个元素是否在集合内&lt;/b&gt;呢，你大可这样写：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;//x为查找元素：
if (f[x]) printf(&quot;Yes\n&quot;); else printf(&quot;No\n&quot;);&lt;/code&gt;&lt;p&gt;有人可能会问了，那这不是bool数组也可以做到吗，其实还是&lt;b&gt;空间&lt;/b&gt;的问题，用bitset可以轻松存10^8个数字并查询，bool空间是它的八倍然后就极有可能MLE~&lt;/p&gt;&lt;p&gt;那我们就来一道水题练练手吧&lt;/p&gt;&lt;a href=&quot;http://poj.org/problem?id=2443&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;2443 -- Set Operation&lt;/a&gt;&lt;p&gt;果然很水对吧（&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;bitset&amp;gt;
using namespace std;
int n,i,j,k,q,x,g,y;
bool fl;
bitset&amp;lt;10005&amp;gt; a[1015];
int main()
{
	scanf(&quot;%d&quot;,&amp;amp;n);
	for (i=1;i&amp;lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;amp;x);
		for (j=1;j&amp;lt;=x;j++)
		{
			scanf(&quot;%d&quot;,&amp;amp;g);
			a[i][g]=1;
		}
	}
	scanf(&quot;%d&quot;,&amp;amp;q);
	for (i=1;i&amp;lt;=q;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;amp;x,&amp;amp;y);
		fl=1;
		for (j=1;j&amp;lt;=n;j++)
			if (a[j][x]&amp;amp;&amp;amp;a[j][y]) {printf(&quot;Yes\n&quot;);fl=0;break;}
		if (fl) printf(&quot;No\n&quot;);
	}
	return 0;
}&lt;/code&gt;&lt;p&gt;Q：有没有好玩一点的题&lt;/p&gt;&lt;p&gt;A：bzoj3687把dp和bitset结合了起来，可惜是一道权限题qwq。有兴趣的可以看hzwer的blog看一下这道题w（http://hzwer.com/3697.html）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>萌萌哒喵酱</author>
<guid isPermaLink="false">2018-01-29-33406432</guid>
<pubDate>Mon, 29 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何让你的正则表达式拥有更好的性能</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-01-13-32896848.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32896848&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-569c3849ef9adeb2f616b0da2e694c31_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;首先呢, 这里要写的不是如何编写高效的正则表达式, 而是正则表达式引擎内部使用的一些编译优化小技巧, 以及探讨这些技巧的适用范围. &lt;/p&gt;&lt;p&gt;这里关注的是通用NFA引擎, 也就是大家平时在各种语言里最常调用的正则表达式库使用的算法. 当然啦, 还有另外一种DFA引擎比如RE2, 由于DFA的限制, 这类引擎非常难甚至不可能实现大部分的拓展(如环视和向后引用).&lt;/p&gt;&lt;p&gt;文章里我将写一些通用的正则表达式引擎技术以及技巧, 在了解了引擎之后相信大家能对正则表达式由更深入的了解同时也能更好地写出更高效的正则表达式. 文章里写的大部分技术来自我的正则表达式引擎项目(各个库的做法会有差异, 不过原则是相通的, 如果对我的正则表达式引擎实现有兴趣请看文章结尾由介绍).&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;要讨论正则表达式引擎, 我们需要一个最基本引擎模型, 为了追求更好的性能, 这里使用的非递归的虚拟机模型, 执行的是由正则表达式编译成的字节码. 一个最基本的正则表达式虚拟机需要以下几种指令:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{MATCH}, \\ &amp;amp;\texttt{SPLIT}, \\ &amp;amp;\texttt{JMP}, \\ &amp;amp;\texttt{ACCEPT} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;例如对于正则表达式 &lt;equation&gt;\texttt{(a|b)*abb}&lt;/equation&gt; 将生成虚拟机指令:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split 1, 6}\\ &amp;amp;\texttt{1 split 2, 4}\\ &amp;amp;\texttt{2 match a}\\ &amp;amp;\texttt{3 jmp 5}\\ &amp;amp;\texttt{4 match b}\\ &amp;amp;\texttt{5 split 1, 6}\\ &amp;amp;\texttt{6 match a}\\ &amp;amp;\texttt{7 match b}\\ &amp;amp;\texttt{8 match b}\\ &amp;amp;\texttt{9 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;虚拟机的实现代码如下:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;enum BYTE_CODE
{
	MATCH,
	SPLIT,
	JMP,
	ACCEPT,
};

bool match_impl(std::string str, std::vector&amp;lt;ptrdiff_t&amp;gt; byte_code, 
	size_t&amp;amp; begin, size_t&amp;amp; end)
{
	struct state
	{
		size_t IP;
		size_t index;
	};

	std::vector&amp;lt;state&amp;gt; state_stack;
	size_t off = 0;

	while (off &amp;lt; str.length())
	{
		state_stack.clear();
		state_stack.push_back({ 0, off++ });

	fail_loop:;
		while (!state_stack.empty())
		{
			auto&amp;amp; state = state_stack.back();
			auto IP = state .IP;
			auto index = state.index;
			state_stack.pop_back();

		next_loop:;
			switch (byte_code[IP])
			{
			case BYTE_CODE::MATCH:
				if (index &amp;lt; str.length() &amp;amp;&amp;amp; (str[index] == byte_code[IP + 1]))
				{
					index++;
					IP += 2;
					goto next_loop;
				}
				goto fail_loop;
			case BYTE_CODE::SPLIT:
				state_stack.push_back({ static_cast&amp;lt;size_t&amp;gt;(IP + byte_code[IP + 2]), index });
				IP += byte_code[IP + 1];
				goto next_loop;
			case BYTE_CODE::JMP:
				IP += byte_code[IP + 1];
				goto next_loop;
			case BYTE_CODE::ACCEPT:
				begin=off; end=index;
				return true;
			default:
				return false;
			}
		}
	}
	return false;
}&lt;/code&gt;&lt;p&gt;这里的虚拟机结构和之前的文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24458116&quot;&gt;正则表达式与AOT编译&lt;/a&gt;里一致.&lt;/p&gt;&lt;p&gt;关于词法分析, 语法分析和指令生成等的细节这里不做更多讨论. 在有了基本的模型之后我们便可以开始讨论如何优化引擎了.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Direct threading&lt;/h2&gt;&lt;p&gt;首先是指令分派的 &lt;equation&gt;\texttt{while-switch}&lt;/equation&gt; 循环, 每执行一条指令需要执行一次 &lt;equation&gt;\texttt{switch}&lt;/equation&gt; , 可以使用GCC的拓展&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html&quot;&gt;Labels as Values&lt;/a&gt;将switch改写为Direct threading分派指令, 减小多余的跳转带来的开销:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;static const void *next_instr[] = { 
	&amp;amp;&amp;amp;byte_code_match,
	&amp;amp;&amp;amp;byte_code_split,
	&amp;amp;&amp;amp;byte_code_jmp,
	&amp;amp;&amp;amp;byte_code_accept,
}

switch (byte_code[IP])  //for initial instruction
{

case BYTE_CODE::MATCH:
{
byte_code_match:
	//code...
}
case BYTE_CODE::SPLIT:
{
byte_code_split:
	//code...
	goto *(next_instr[byte_code[IP]]);
}
case BYTE_CODE::JMP:
{
byte_code_jmp:
	goto *(next_instr[byte_code[byte_code[IP + 1]]]);
}
case BYTE_CODE::ACCEPT:
{
byte_code_accept:
	//code...
	return true;
}

}&lt;/code&gt;&lt;p&gt;更进一步, 可以使用Context Threading with Tiny inlining, 将解释器改写成半JIT形式, 不过使用这类技术需要动态生成native code, 这里不做更多讨论, 有兴趣可以阅读paper: &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.cs.toronto.edu/~matz/pubs/demkea_context.pdf&quot;&gt;Context Threading: A flexible and efficient dispatch technique for virtual machine interpreters [.PDF]&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Memory pool&lt;/h2&gt;&lt;p&gt;在虚拟机中我们使用了一个 &lt;equation&gt;\texttt{vector}&lt;/equation&gt; 来存储每一个状态, 但是 &lt;equation&gt;\texttt{vector}&lt;/equation&gt; 在这里的内存效率不高, 主要原因是不需要随机访问, 只需要访问最顶端的头部元素, 而 &lt;equation&gt;\texttt{vector}&lt;/equation&gt; 随着状态增长发生的内存增长分配和搬移会带来显著的花销. 这个时候改用双向链表会比较合适, 配合内存池进行状态分配以获取更好的内存效率.&lt;/p&gt;&lt;p&gt;实现的思想是保存链表头部指针&lt;/p&gt;&lt;ul&gt;&lt;li&gt;访问头部时直接返回该指针指向的节点中保存的状态&lt;/li&gt;&lt;li&gt;添加新状态时检查头部指针节点的后继节点, 若为空则从内存池分配新节点, 并将头部指针指向该节点.&lt;/li&gt;&lt;li&gt;释放状态时将头部指针移动至其指向节点的前趋节点, 而不是回收该节点的内存.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;内存池的实现策略可以是一个单链表, 每个节点内包含一大块内存, 每次申请从中取出一个地址, 用尽后分配新的节点, 在完成匹配后由内存池统一回收内存. 在内存布局上新的状态储存结构更接近块状链表.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Branch stack&lt;/h2&gt;&lt;p&gt;在正则表达式循环 &lt;equation&gt;\texttt{+, *, ?}&lt;/equation&gt; 中若是出现空匹配将会造成死循环, 避免该情况的方案是在每个状态内设置一个独立的栈(使用栈是为了应对嵌套的循环, 同时这个栈是相当有用的结构, 后续将继续沿用其以支持环视与递归匹配)记录在循环开始时的匹配位置, 在匹配结束时检查是否有变化, 如果没有变换则退出该循环避免死循环.&lt;/p&gt;&lt;p&gt;每个状态的结构如下:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;struct state
{
	size_t IP;
	size_t index;
	state_stack stack;
};&lt;/code&gt;&lt;p&gt;并添加两个新指令 &lt;equation&gt;\texttt{push, repeat}&lt;/equation&gt; 用于循环, 此时正则表达式&lt;equation&gt;\texttt{(a|b)+}&lt;/equation&gt; 将编译成:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 push index}\\ &amp;amp;\texttt{1 split 2, 4}\\ &amp;amp;\texttt{2 match a}\\ &amp;amp;\texttt{3 jmp 5}\\ &amp;amp;\texttt{4 match b}\\ &amp;amp;\texttt{5 repeat 1}\\ &amp;amp;\texttt{6 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;新增加的指令对应的虚拟机代码如下:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;case BYTE_CODE::PUSH_INDEX:
	state.stack.push(index);
	goto next_loop;
case BYTE_CODE::REPEAT:
	if(state.stack.back() != index)
	{
		state_stack.push_back({ static_cast&amp;lt;size_t&amp;gt;(IP + 2]), index, state.stack });
		IP += byte_code[IP + 1];
		goto next_loop;
	}
	else	//exit loop
	{
		IP += 2;
		goto next_loop;
	}&lt;/code&gt;&lt;p&gt;这个时候内存效率问题出现了, 如果我们使用数组或 &lt;equation&gt;\texttt{vector}&lt;/equation&gt; 来实现 &lt;equation&gt;\texttt{state_stack}&lt;/equation&gt; 的话在每次执行 &lt;equation&gt;\texttt{split} &lt;/equation&gt; 时需要将整个栈复制一整遍, 这是不忍直视的效率. 这个时候我们使用惰性求值的策略:&lt;/p&gt;&lt;p&gt;将栈实现为数形结构Branch stack, 即拥有多条分支的栈结构, 将树中.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在每次复制状态时仅仅增加栈顶元素的引用计数. &lt;/li&gt;&lt;li&gt;&lt;equation&gt;\texttt{push}&lt;/equation&gt; 时增长节点.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;\texttt{pop}&lt;/equation&gt; 时检查该节点的引用计数, 若为1则回收节点, 若大于1则减小引用计数, 增加后继节点的引用计数并且栈顶指针向后移动.&lt;/li&gt;&lt;li&gt;修改节点数据时检查引用计数, 若为1则直接在原地修改, 否则分叉该节点, 之后在分叉后的节点上修改数据.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里的分支栈结构比较接近functional programming的immutable data structures的实现.&lt;/p&gt;&lt;p&gt;在拥有栈以后可以用于计数循环的实现, 比如 &lt;equation&gt;\texttt{(a|b){3}}&lt;/equation&gt; 可以在栈上面记录当前的循环次数.&lt;/p&gt;&lt;p&gt;注: 关于避免空循环还有另外一种做法不需要栈(在NFA生成阶段处理掉了), 如果有兴趣的小伙伴请告诉我, 我下次写写.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Loop instruction&lt;/h2&gt;&lt;p&gt;在正则表达式中会经常出现单个字符的循环, 比如 &lt;equation&gt;\texttt{\d}*&lt;/equation&gt; , 对于单个字符, 每一次循环都需要执行一次 &lt;equation&gt;\texttt{match}&lt;/equation&gt; 和一次 &lt;equation&gt;\texttt{repeat}&lt;/equation&gt; , 在匹配失败后还需要Backtracking, 将造成极大的性能损失, 这个时候可以引入一个新的指令 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 用于执行单个字符的循环. &lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{loop}&lt;/equation&gt; 的实现非常简单, 只需要在 &lt;equation&gt;\texttt{match}&lt;/equation&gt; 上套上一层 &lt;equation&gt;\texttt{while}&lt;/equation&gt; 循环即可. 虽然实现简单但是带来的提升却是巨大的.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Memorization&lt;/h2&gt;&lt;p&gt;&lt;equation&gt;\texttt{loop}&lt;/equation&gt; 指令的引入还可以非常容易地实现记忆化, 由于 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 指令是单个字符的循环, 因此在进行状态记忆化时不需要记录下每一次进行匹配的位置, 只需要记录开始循环和结束循环的位置即可. &lt;/p&gt;&lt;p&gt;记忆化在考虑了memory footprint的平衡后, 我个人的建议是仅仅对 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 指令进行单次的记忆化(其余指令的记忆化往往需要记录大量的已匹配位置信息, 重入时亦需要大量的检查, 往往得不偿失).&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{loop}&lt;/equation&gt; 指令的记忆化能有效地优化诸如 &lt;equation&gt;\texttt{a*a*a*b}&lt;/equation&gt; 这样的正则表达式. &lt;/p&gt;&lt;p&gt;另外在递归匹配中也可以使用记忆化来优化同一位置的重入.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;One character Lookahead&lt;/h2&gt;&lt;p&gt;对于循环来说, 每一次循环都需要进行一次状态的保存, 在进行了以上的内存优化后仍然是一个不可忽视的开销, 在循环中可以使用单个字符的向前看来减少这种额外的开销.&lt;/p&gt;&lt;p&gt;举例如下:&lt;/p&gt;&lt;p&gt;对于正则表达式 &lt;equation&gt;\texttt{\d*0\d*}&lt;/equation&gt;匹配中间存在一个字符0的字符串, 在匹配字符串1230321时, 第一个循环 &lt;equation&gt;\texttt{\d*}&lt;/equation&gt; 将在每一个字符串位置进行一次状态保存, 实际上只有在匹配到123这个位置的时候才需要真正的进行状态保存, 其余位置均不需要, 因为仅有123的后继字符0能匹配.&lt;/p&gt;&lt;p&gt;对于循环, 我们可以通过静态分析收集循环之后的可能匹配的字符, 并在每一次循环结束时进行一次预匹配, 若是失败则不保存该状态直接进行下一轮循环.&lt;/p&gt;&lt;p&gt;另外我们可以通过更为精细的静态分析配合 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 指令实现更高的效率, 例如匹配一个合法的Gmail邮箱的正则表达式 &lt;equation&gt;\texttt{[\w.]+@gmail.com}&lt;/equation&gt; 对于循环&lt;equation&gt;\texttt{[\w.]+}&lt;/equation&gt;我们使用 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 的同时可以发现该处的 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 其实不需要进行预查, 因为&lt;equation&gt;\texttt{[\w.]}&lt;/equation&gt;与 &lt;equation&gt;\texttt{@}&lt;/equation&gt; 并不相交, 也就是说 &lt;equation&gt;\texttt{[\w.]}&lt;/equation&gt; 匹配成功则 &lt;equation&gt;\texttt{@}&lt;/equation&gt; 匹配必然不成功, 那么只需要进行简单的 &lt;equation&gt;\texttt{while}&lt;/equation&gt; 循环即可, 直到匹配失败后退出循环进行后续状态的匹配. &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Repetition classification&lt;/h2&gt;&lt;p&gt;对于一般的循环, 我们可以按照其属性分类&lt;/p&gt;&lt;ul&gt;&lt;li&gt;计数循环与非计数循环.&lt;/li&gt;&lt;li&gt;空循环与非空循环.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其中注意到非计数循环与非空循环并不需要在状态的栈上保留信息(非空循环不会陷入死循环), 因此也不需要在循环前执行 &lt;equation&gt;\texttt{push}&lt;/equation&gt; 指令.&lt;/p&gt;&lt;p&gt;计数循环与非计数循环可以在语法分析阶段加以区分, 而空循环与非空循环稍微复杂一点, 需要对正则表达式做静态分析, 在中间阶段生成NFA后从循环的节点开始进行深度优先搜索(DFS)若存在一条路径不匹配任何字符则该循环为空循环, 若不存在这样的路径则意味着该循环内部至少需要匹配一个字符, 即非空循环.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Loop unrolling&lt;/h2&gt;&lt;p&gt;对于循环展开相信大家都不会陌生, 对于计数循环我们可以对其做循环展开, 例如 &lt;equation&gt;\texttt{a{4}}&lt;/equation&gt; 可展开为 &lt;equation&gt;\texttt{aaaa}&lt;/equation&gt; , 展开后不需要循环指令和压栈一个计数.&lt;/p&gt;&lt;p&gt;更进一步地, 循环展开可以配合静态分析进行更多的优化.&lt;/p&gt;&lt;p&gt;其一是可以做字符合并, 为了效率我们可以引入一个新的指令 &lt;equation&gt;\texttt{match stirng}&lt;/equation&gt; , 将 &lt;equation&gt;\texttt{match}&lt;/equation&gt; 拓展为对字符串的匹配, 编译器可以对字符串的比较做更多的优化, 更加地, 例如 &lt;equation&gt;\texttt{aab{4}}&lt;/equation&gt; 可展开为 &lt;equation&gt;\texttt{aabbbb}&lt;/equation&gt; 在有字符串匹配指令下用一条指令 &lt;equation&gt;\texttt{match aabbbb}&lt;/equation&gt; 即可完成匹配.&lt;/p&gt;&lt;p&gt;其二是可以优化掉循环中的捕获组, 这里的优化同样需要进行一些静态分析, 在循环体中有引用的捕获组不可以被删除. 例如 &lt;equation&gt;\texttt{((\d)\2){3}}&lt;/equation&gt; 可展开为 &lt;equation&gt;\texttt{(\d)\2(\d)\2((\d)\2)}&lt;/equation&gt; 注意捕获组1在前两个循环中被删除掉了, 因为该捕获组会被最后一个循环体内的内容覆盖, 因此没必要保存下来.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Merge branches&lt;/h2&gt;&lt;p&gt;对于分支 &lt;equation&gt;\texttt{|}&lt;/equation&gt; 来说, 在遇到单个字符求或的情况下是可以进行合并的, 例如 &lt;equation&gt;\texttt{1|2|3|4|5|6|7|8|9|0}&lt;/equation&gt; 将可以合并成 &lt;equation&gt;\texttt{\d}&lt;/equation&gt; . &lt;/p&gt;&lt;p&gt;该优化的实现并不复杂, 只需要检查每一条分支是否为单字符即可, 若是单字符则进行合并.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Extract the common factor&lt;/h2&gt;&lt;p&gt;另外一类的关于分支的优化是提取公因式, 例如对于匹配数字0-255正则表达式&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2}}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中分支 &lt;equation&gt;\texttt{25[0-5]|2[0-4][0-9]}&lt;/equation&gt; 将可以进行公因式提取变成 &lt;equation&gt;\texttt{2(?:5[0-5]|[0-4][0-9])}&lt;/equation&gt; 注意提取了公因式 &lt;equation&gt;\texttt{2}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;提取公因式的优化原理是推迟分支, 减少重复匹配, 若是匹配失败能更早的Backtracking.&lt;/p&gt;&lt;p&gt;该优化的实现亦并不复杂, 只需要检查每一条分支的前缀即可, 若是相同则进行合并.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Capture group classification&lt;/h2&gt;&lt;p&gt;对于捕获组来说, 可以依据是否在分支内分成两类, 对于不在分支上的捕获组, 我们可以直接使用一个全局数组来保存其捕获结果, 因为其与路径的选取无关, 因此无需保存在状态内. 对于在分支上的捕获组则需要在状态内保存捕获数据. 其中对数组的访问的内存效率是要高于访问状态的, 因此这类优化可以提高内存效率.&lt;/p&gt;&lt;p&gt;该优化的实现并不复杂, 只需要生成NFA后检查捕获组是否在分支内即可. 另外若支持递归匹配还需要考虑该捕获组是否在某个递归模式内, 因为递归模式的分支是隐含在状态内的栈上的.&lt;/p&gt;&lt;p&gt;另外对于在递归模式内的捕获组需要做额外的分析, 例如 &lt;equation&gt;\texttt{^((.)((?1)|)\2)\$}&lt;/equation&gt; , 其中在递归中捕获组3不需要记录, 因为其在递归中没有被引用, 在递归结束后递归体内的所有捕获组将会被清空.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Capture group analysis&lt;/h2&gt;&lt;p&gt;正则表达式里的路径分析的作用类似于常量折叠, 作用与条件表达式上, 对于向后引用也有作用. 原理是检查当前路径下所有必定捕获的捕获组用以确定条件.&lt;/p&gt;&lt;p&gt;举例来说表达式 &lt;equation&gt;\texttt{\1(.)}&lt;/equation&gt; 必定失败, 因为捕获组1在向后引用时未被捕获, 对于这种情况可在路径的字节码最后添加上一个 &lt;equation&gt;\texttt{halt}&lt;/equation&gt; 指令配合下面的Halt path elimination优化使用. &lt;/p&gt;&lt;p&gt;使用全局数组保存捕获结果依赖于此优化, 否则在Backtracking后数组中会留下前一状态的捕获结果, 若正好当前状态在完成捕获前引用了该捕获将会导致意料之外的结果.&lt;/p&gt;&lt;p&gt;另外的一个例子是 &lt;equation&gt;\texttt{(.)(?(1)a|b)}&lt;/equation&gt; 将会被优化成 &lt;equation&gt;\texttt{(.)a}&lt;/equation&gt; 因为在进行条件判断时捕获组1已经完成匹配了, 因此该条件表达式恒真.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Subroutine inline&lt;/h2&gt;&lt;p&gt;在正则表达式中, 对于调用Subroutine可以使用类似于C语言中的inline优化方法把被调用的模式inline到调用处, 优点是消除了一次 &lt;equation&gt;\texttt{call}&lt;/equation&gt; 与 &lt;equation&gt;\texttt{return}&lt;/equation&gt; 同时可以结合上下文环境做例如lookahead分析, Capture group analysis等的优化, 同时也利于Memorization. &lt;/p&gt;&lt;p&gt;举例如下:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{(a+).(?1)}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中 &lt;equation&gt;\texttt{(?1)}&lt;/equation&gt; 调用了模式 &lt;equation&gt;\texttt{a+}&lt;/equation&gt; , 在inline后表达式为 &lt;equation&gt;\texttt{(a+).a+}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;inline是相当常见的优化技术了, 这里不做赘述.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Recursive unfold&lt;/h2&gt;&lt;p&gt;对递归函数就行展开类似于Subroutine inline, 将最底层的递归调用展开, 好处也是于inline类似的. 值得注意的是递归的展开条件更严格, 调用递归模式在自身内只出现一次时进行展开, 否则展开的字节码将呈指数级暴涨.&lt;/p&gt;&lt;p&gt;举例如下, 匹配闭合的大括号:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{\{((?R)|)\}}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中 &lt;equation&gt;\texttt{(?R)}&lt;/equation&gt; 调用了整个模式自身, 在展开一次后表达式为 &lt;equation&gt;\texttt{\{(\{(?:(?R)|)\}|)\}}&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;注意此处展开的捕获组将会被消去(由于其在递归模式中).&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Halt path elimination&lt;/h2&gt;&lt;p&gt;字节码中有一种路径是永远不会成功匹配的, 这个时候可以将其分支削去, 举例来说:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split 1, 3}\\ &amp;amp;\texttt{1 halt}\\ &amp;amp;\texttt{2 match a}\\ &amp;amp;\texttt{3 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中 &lt;equation&gt;\texttt{halt}&lt;/equation&gt; 表示无条件匹配失败, 这时候 &lt;equation&gt;\texttt{split 1, 3}&lt;/equation&gt; 可以削去, 优化后的字节码如下:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 match a}\\ &amp;amp;\texttt{1 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Fold control flow&lt;/h2&gt;&lt;p&gt;这个是非常常见的指令层级的优化了, 举例来说对于表达式 &lt;equation&gt;\texttt{a|b|c}&lt;/equation&gt; , 若不进行分支合并生成的字节码如下:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split 1, 6}\\ &amp;amp;\texttt{1 split 2, 4}\\ &amp;amp;\texttt{2 match a}\\ &amp;amp;\texttt{3 jmp 5}\\ &amp;amp;\texttt{4 match b}\\ &amp;amp;\texttt{5 jmp 7}\\ &amp;amp;\texttt{6 match c}\\ &amp;amp;\texttt{7 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;第三行的 &lt;equation&gt;\texttt{jmp 5}&lt;/equation&gt; 可以优化为 &lt;equation&gt;\texttt{jmp 7}&lt;/equation&gt; . 连续跳转可以合并为单个跳转. 同样地 &lt;equation&gt;\texttt{split}&lt;/equation&gt; 也可以做这样的优化, 例如 &lt;equation&gt;\texttt{a||c}&lt;/equation&gt; 中的&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split 1, 6}\\ &amp;amp;\texttt{1 split 2, 4}\\ &amp;amp;\texttt{2 match a}\\ &amp;amp;\texttt{3 jmp 6}\\ &amp;amp;\texttt{4 jmp 6}\\ &amp;amp;\texttt{5 match c}\\ &amp;amp;\texttt{6 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中第二行 &lt;equation&gt;\texttt{split 2, 4}&lt;/equation&gt; 可以优化为 &lt;equation&gt;\texttt{split 2, 6}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Dead code elimination&lt;/h2&gt;&lt;p&gt;这个也是非常常见的指令层级的优化了, 继续沿用上面的例子&lt;equation&gt;\texttt{a||c}&lt;/equation&gt; , 进一步执行死代码消除后便是:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split 1, 2}\\ &amp;amp;\texttt{1 match a}\\ &amp;amp;\texttt{2 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这个优化实现也很简单, 这里不做赘述.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;JIT/AOT&lt;/h2&gt;&lt;p&gt;请参阅: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/24458116&quot;&gt;正则表达式与AOT编译&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;另外还有一些优化技术比如条件分支, 分支重排, 以及更细致的分支合并与跳转我还没来得及实现与试验, 等以后有机会再向大家做更多的介绍, 另外JIT/AOT还没有真正实现好.&lt;/p&gt;&lt;p&gt;这篇文章主要关注的优化技术, 具体的特性实现没怎么讲, 要是大家有兴趣我再写篇文章慢慢讲, 特别是一下丧心病狂的特性应该怎么做.&lt;/p&gt;&lt;p&gt;以上的所有优化技术均在我的千雪(ちゆき, Chiyuki)正则表达式引擎里实现了, 感兴趣的小伙伴欢迎来看看呀(源码一共有13000多行, 用C++17写哒, 如果需要测试代码或显示字节码的代码请告诉我):&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://hcc.trilines.net/regex/&quot;&gt;Chiyuki Regex&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;千雪支持的特性可以去&lt;a href=&quot;http://hcc.trilines.net/regex/syntax.html&quot;&gt;syntax reference&lt;/a&gt;里看看喔(基本上环视, 捕获/引用, 命名捕获, 条件匹配, 原子组, 递归匹配都支持), 我是将她作为通用引擎设计的, 尽可能多支持一些拓展. 其中由于引擎的设计支持一些非常丧心病狂的特性, 比如无限制的环视, 你甚至可以在环视内部使用嵌套循环与递归. 而且递归也不像PCRE那样是原子性的, 这意味着你可以跨递归层进行匹配. 由于我比较笨, 在这种尤其丧心病狂的特性下想不出什么很好的test case, 又没有别的引擎来做对照, 所以不知道对不对, 有没有bug.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;说了那么多优化, 我想小伙伴们肯定会好奇她的性能怎么样, 网页上的benchmark是很久以前的版本啦, 新的跑得更快一些. 现在的千雪大概跑得比非JIT的PCRE快一点(等我把JIT/AOT做出来再和你比JIT), 比Boost快两点, 将来还会更快哒. 当然啦这只是match的性能. 我没有针对search做特别的优化, 所以search在一些情况下被PCRE吊打了呀哈哈. 等我有空给大家补上新的测试数据(评论区里有3个简单的test cases对比).&lt;/p&gt;&lt;p&gt;她的缺点非常明显, 就是编译性能非常糟糕, 我想大家应该都能想到, 毕竟要跑那么多躺分析, 不过带来的好处也是有哒, 那就是很容易做进一步的去抽象生成native code, 也就是AOT编译啦.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我觉得她还是蛮快的, 当然只是在我的机子上, 所以不知道是不是真的呢?&lt;/p&gt;&lt;p&gt;最后谢谢大家观看喵~&lt;/p&gt;</description>
<author>梨梨喵</author>
<guid isPermaLink="false">2018-01-13-32896848</guid>
<pubDate>Sat, 13 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>一招鲜，吃遍天</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-01-06-32677377.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32677377&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在Haskell等语言中，有datatype generic的概念：对于各种各样的ADT，都可以表示成一系列的Sum type 跟 Product type（因为这是ADT的定义），所以理论上，只要你能处理ADT的通用定义，你就能写一个对所有ADT适用的函数。其实这就是当你写deriving Show/Eq/Ord的时候发生的情况。generic，又称polytypic programming，就是把这理论变成现实的特性。注意这跟type generic是两码事。&lt;/p&gt;&lt;p&gt;这里面的Notable Work包括Scrap Your Boilerplate：把一定的类型信息塞到运行时，（Typable），然后就可以对某个类型做一种东西，而其他类型不变。然后可以写个高阶函数，对该类型做action，其他类型（wrapper，比如list/sum/either/whatever）就默认map进去，这样就可以给[Either [Double] Double]之类的type里面的所有Double翻倍，或者加起来返回。&lt;/p&gt;&lt;p&gt;GHC.generic做的是另外的东西，把一个类型表现成Sum type/Product type/Metadata（我们称作Rep），然后所有ADT都可以转化成这类型。然后加上把某类型变成它Rep的方法，就可以写function on all ADT，然后也可以写deriving等&lt;/p&gt;&lt;p&gt;True Sum Of Product就在GHC.generic上面做了层抽象，不用ADT来表示Rep，而是表示成[[*]] （类型的列表的列表）。然后有多参Product/Sum (可以想象成NProduct :: [*] -&amp;gt; *，其实具体情况复杂点），就可以直接组合/Map/Fold Product/Sum来完成generic programming，而无需在GHC.generic中递归，因为Sum type里面可能有Product type，然后里面再有Sum type。。。而这在True Sum Of Produt中不可能发生&lt;/p&gt;&lt;p&gt;然后还有Generic Generic Programming，因为有很多套Generic Library，每套都不一样，所以就搞出了个东西unify之。。。什么鬼&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;a href=&quot;https://wiki.haskell.org/Research_papers/Generics&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Generic Paper合集&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>脚本少女魔理沙</author>
<guid isPermaLink="false">2018-01-06-32677377</guid>
<pubDate>Sat, 06 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>萌萌的忙忙的小河狸</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-01-05-32664058.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32664058&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3305ab08851a89a08a55df6ecf9f1c42_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;题图出处：&lt;a href=&quot;https://vancoolver.ca/310341&quot;&gt;都怪冬天太长：加拿大“国宝”河狸被卡在栏杆&lt;/a&gt;&lt;/blockquote&gt;&lt;h2&gt;为什么河狸这么萌&lt;/h2&gt;&lt;p&gt;我们不知道为什么河狸这么萌，但是我们更加不知道为什么河狸这么……忙。它太忙了，所以它可能是世界上最忙、最Busiest的……的什么来着？图灵机。函数。Whatever。&lt;/p&gt;&lt;p&gt;Busy Beaver Function，记作BB(n)，是这样子的一个Function。给定输入n，它输出的值是具有n个状态的图灵机，在停机之前所能够在纸带上写下的“1”的最大的个数，并且这些1之间没有任何空隙。还有另外一种定义则直接定义它&lt;b&gt;输出的值代表n个状态的图灵机停机之前所走出的最大步数&lt;/b&gt;。我们先采用采用后者吧。&lt;/p&gt;&lt;p&gt;只有一个状态的图灵机，只会在1步以后停机——或者不停机；于是我们说，BB(1) = 1。两个状态的图灵机呢？4。BB(3) = 21。BB(4) = 107。但是BB(5) &amp;gt;= 47176870……&lt;/p&gt;&lt;h2&gt;累瘫了的小河狸&lt;/h2&gt;&lt;p&gt;具有n个状态的、满足BB(n)的计算条件的图灵机被我在这里叫做河狸机。这只河狸忙到什么程度呢……你可以利用它去&lt;b&gt;判断停机问题&lt;/b&gt;。因为它是所有的图灵机伙伴里面最忙的小河狸，所以不可能有什么图灵机比它还要忙。所以，在一只图灵机旁边放一只有相同状态个数的小河狸机。在小河狸累瘫（停机）以后，如果旁边的图灵机还没有停机的话，那么就表明那只图灵机一定不会停机——因为我们已经知道了n个状态的图灵机如果能够停机的话，那么它最多会走多少步。&lt;/p&gt;&lt;p&gt;再从头到尾看一次。如果我们能够计算BB函数，那么我们就能够判断停机问题。反过来说，计算小河狸的函数是，&lt;/p&gt;&lt;p&gt;不存在的。&lt;/p&gt;&lt;h2&gt;火星人和小河狸&lt;/h2&gt;&lt;p&gt;为什么我们要讨论火星人这种东西……&lt;/p&gt;&lt;p&gt;好吧，我想要问的是，我们现在有这样子的一个问题。我们有这样子的一个函数Mars，如果它知道火星上有火星人的话，那么它就会输出1；但是如果它知道火星上没有火星人的话，那么它就会输出0。问这个问题是不是可以计算的？答案是……可以，但是我们压根就不需要知道火星上有没有火星人。我们知道这个函数Mars只会输出0和1中的其中一个，所以它的语言是&lt;b&gt;有限&lt;/b&gt;的，有限的语言都是可计算的。或者说，一个函数输出的所有可能是有限的，那么它就一定是可计算的（枚举所有的答案即可）；但是一个函数的输出的所有可能如果是一个无限的集合，那么它未必可计算。&lt;/p&gt;&lt;p&gt;以及，Mars(x) or NOT(Mars(x))的值一定是1。如果存在一个判断停机问题的函数HALT的话，HALT(x, a) or NOT(HALT(x, a))的值也一定是1。（为什么我要写成HALT(x, a)而不是HALT(x)？）&lt;/p&gt;&lt;p&gt;那么下面这个呢？&lt;/p&gt;&lt;p&gt;&lt;equation&gt;M_{ar-ver} = \frac{1}{BB(1)} + \frac{1}{BB(2)} + \frac{1}{BB(3)}...&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;为了让“可计算”在这里的定义更明确一点，也因为S是一个实数的缘故。是否存在一个算法，对于输入k，输出一个有理数M&#39;，使得|M - M&#39;| &amp;lt;= 1/k？&lt;/p&gt;&lt;h2&gt;忙忙的小河狸&lt;/h2&gt;&lt;p&gt;在给出这个答案之前，我们先留意一下另外一只小河狸：啃纸带的小河狸。它想要在纸带上留下最多的、连续的1，把纸带给啃得干干净净。这只小河狸太忙了，以至于我们可能还是会惊讶于为什么BB(5)看起来这么大……以及对于更大的n，总觉的那都是那堆数学家无聊蛋疼的产物。。。小河狸是如此地忙，以至于它比任何图灵机都要忙……比任何可计算的函数都要忙……&lt;b&gt;因此不可计算&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;好吧，为什么这样子说？虽然知道了它不可计算，但是为什么它比任何可计算的函数都要忙？&lt;/p&gt;&lt;p&gt;好，那么我们有一个任意的可计算函数f。现在我们要构造另外一个可计算函数：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;g(x) = \sum_{i=1}^{x}[f(i) + i^2]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这个函数显然可计算。&lt;/p&gt;&lt;p&gt;从g(x)的定义，我们立刻有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;g(x) &amp;gt;= f(x)；&lt;/li&gt;&lt;li&gt;g(x) &amp;gt;= x^2；&lt;/li&gt;&lt;li&gt;g(x+1) &amp;gt;= g(x)。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;假设有一台计算函数g的图灵机G，它具有q个状态，并且会让一个写了x+1那么多个1的纸带，变成g(x)+1那么多的纸带。从这个图灵机，我们要构造另外一个图灵机——&lt;/p&gt;&lt;p&gt;&lt;equation&gt;T = P^{x+1}.G.G&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;虽然说定义看起来很奇怪，但是那只是因为我们不知道P^x+1是什么。P^x+1是一个打印机，它可以没有小河狸那么忙，但是它一定要啃够x+1那么多的1（在纸带上留下这么多的一串1，然后停机）。所以上面的T的意思是，&lt;/p&gt;&lt;ul&gt;&lt;li&gt;先用打印机在纸带上留下x+1那么多的1；&lt;/li&gt;&lt;li&gt;然后用一次G，将x+1那么多的1改成g(x)+1那么多的1；&lt;/li&gt;&lt;li&gt;然后再用一次G，将g(x)+1那么多的1改成最后的g(g(x))+1那么多……的1。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;哇，真是多死了。&lt;/p&gt;&lt;p&gt;一个打印机打印x+2个1的话，可以被一个具有x个状态的图灵机构造出来。（为什么？）所以，T的内部状态个数是x+q+q（为什么？）。所以，&lt;/p&gt;&lt;p&gt;&lt;equation&gt;BB(x + 2q) \ge g(g(x)) + 1&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;因为我们构造出来的这个T在纸带上啃了那么多1，所以小河狸一定要比它……不对，至少要比它忙。&lt;/p&gt;&lt;p&gt;但是这有什么问题呢？&lt;/p&gt;&lt;ul&gt;&lt;li&gt;g(x) &amp;gt; x + 2q，因为g(x) &amp;gt;= x^2。&lt;/li&gt;&lt;li&gt;g(x + 2q) &amp;gt;= f(x + 2q)，因为g(x) &amp;gt;= f(x)。&lt;/li&gt;&lt;li&gt;BB(x + 2q) &amp;gt; g(x + 2q)，因为BB(x + 2q) &amp;gt;= g(g(x)) + 1（再具体点？）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;或者说，BB(x + 2q) &amp;gt; f(x + 2q)……或者说BB(x) &amp;gt; f(x)。&lt;/p&gt;&lt;p&gt;所以小河狸比任何图灵机都忙。你们有没有在现实中看到过这么忙的一个小河狸？&lt;/p&gt;&lt;h2&gt;不忙，但是依然萌&lt;/h2&gt;&lt;p&gt;虽然说小河狸是因为忙所以萌，但是卖萌并不需要忙。&lt;/p&gt;&lt;p&gt;花栗鼠(Chipmuck)机是这样子的一只函数：CM(n) = “n个状态的图灵机中可以构成打印机的图灵机数目”，那么虽然说这个函数并不忙，但是依然不可计算。&lt;/p&gt;&lt;p&gt;令BD(n, m)表示“n个状态的、m步内停机的图灵机中可以构成打印机的图灵机数目”（Busy Down），又令&lt;/p&gt;&lt;p&gt;&lt;equation&gt;S_{uper}BB(n) = min_n(CM(n) - BD(n, m) = 0)&lt;/equation&gt; ，或者说，让CM(n) - BD(n, m) = 0的最小的n。首先，BD显然是可计算的（为什么？）；所以如果CM也是可计算的，则SBB也是可计算的。但是SBB不可计算，因为SBB(n) &amp;gt;= BB(n)……等等，这个SBB的定义就是那一只“n个状态内最大的行动步数”的小河狸！真是萌萌哒。&lt;/p&gt;&lt;p&gt;萌性我们证完了，但是花栗鼠并不忙。因为一个具有n个状态的图灵机的数目是有限的，具体地，它的数目是 &lt;equation&gt;(6n)^{2n}&lt;/equation&gt; 。所以我们永远地有， &lt;equation&gt;CM(n) \le (6n)^{2n}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;Super (Super Busy) Beaver&lt;/h2&gt;&lt;p&gt;如果我们已经计算出了BB(1), BB(2), ……BB(n-1)，并且之前提到的S是可计算的，那么下面的这个一定是可计算的：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;M_n = \frac{1}{BB(n)} + \frac{1}{BB(n+1)} + ...&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;因为每一个BB(n)都比BB(n-1)要大，易知M_n是收敛的，也就是说，有界（什么？没学过高数？）。于是我们就也可以计算出1/(M_n)的上界。但是M_n的第一项就是1/BB(n)，并且后面每一项都比前面的一项要小很多，所以如果我们能计算出1/(M_n)的上界，我们就可以计算出1/BB(n)和BB(n)的界……意味着能计算BB(n)。&lt;/p&gt;&lt;p&gt;但是小河狸是不可计算的。&lt;/p&gt;&lt;p&gt;所以BB(n)是不可计算的，所以BB(n-1)是不可计算的，所以……所以我们的前提即便成立，即便我们知道BB(1) = 1，我们也知道，M_n是不可计算的，也知道……M是不可计算的。&lt;/p&gt;&lt;p&gt;所以M也和小河狸一样萌。&lt;/p&gt;&lt;p&gt;于是我们发现了一个很萌的有理数，很多有理数都没有这么萌。&lt;/p&gt;&lt;p&gt;你有见过这么萌的有理数吗？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;参考：&lt;/p&gt;&lt;p&gt;（习题）Scott Aaronson. 《Quantum Computing Since Democritus》&lt;/p&gt;&lt;p&gt;（习题）Michael Sipser. 《计算理论导引》&lt;/p&gt;&lt;p&gt;张鸣华. 《可计算性理论》&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;－－－－－－－－&lt;/p&gt;&lt;p&gt;注：Beaver是Beaver，但是Chipmuck只在这里是Chipmuck。&lt;/p&gt;&lt;p&gt;最后的最后，有人知道为什么我会说g(x)显然可计算嘛？&lt;/p&gt;</description>
<author>钟狸</author>
<guid isPermaLink="false">2018-01-05-32664058</guid>
<pubDate>Fri, 05 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>JavaScript实现ZLOGO: 用语法树实现多层循环</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-01-03-32571516.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32571516&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;照例先上演示弱效果图. 演示地址&lt;a href=&quot;http://codeinchinese.com/%E5%9C%883/%E5%9C%883.html&quot;&gt;照旧&lt;/a&gt;:&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-86c83e8129d192b4f22b8fa8d0ad4b40_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;117&quot; data-rawheight=&quot;117&quot;&gt;&lt;p&gt;代码如下:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;开始
  循环4次
    循环4次
      前进50
      左转90度
    到此为止
  右转90度
  到此为止
结束&lt;/code&gt;&lt;p&gt;如上文&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31870155&quot;&gt;JavaScript实现ZLOGO子集: 测试用例&lt;/a&gt;末尾所言, 此文用Antlr进行代码分析生成语法树. 再通过语法树生成p5js绘制代码.&lt;/p&gt;&lt;p&gt;Antlr支持两种代码分析方法, Visitor(监听者)和Visitor(访问者). SO上的问答&lt;a href=&quot;https://stackoverflow.com/questions/20714492/antlr4-listeners-and-visitors-which-to-implement&quot;&gt;Antlr4 Listeners and Visitors - which to implement?&lt;/a&gt;大致说明了区别. 基于有限的实践, 用Visitor方法生成语法树似乎在实现上更加方便. 尤其相比&lt;a href=&quot;http://ivanyu.me/blog/2014/09/13/creating-a-simple-parser-with-antlr/&quot;&gt;Creating a simple parser with ANTLR&lt;/a&gt;一文中使用监听者+栈来构建语法树.&lt;/p&gt;&lt;p&gt;Antlr生成工具默认不生成Visitor, 添加-visitor参数后可以生成:&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;java -cp &quot;antlr-4.7-complete.jar:$CLASSPATH&quot; org.antlr.v4.Tool -Dlanguage=JavaScript -visitor 圈3.g4&lt;/code&gt;&lt;p&gt;下面是&quot;定制访问器.js&quot;中构建语法树的部分, 看起来比实现前想的简单. 默认生成的&#39;圈3Visitor&#39;中, visitXX方法实现都是&quot;this.visitChildren(ctx)&quot;, 但那样会把所有的子节点返回值放进数组, 形成(至少这里是)多余的层次:&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;定制访问器.prototype.visit程序 = function(上下文) {
  语法树 = {子节点: this.visit(上下文.声明())};
  return 语法树;
};

定制访问器.prototype.visit循环 = function(上下文) {
  return {
    类型: &#39;循环&#39;,
    次数: parseInt(上下文.T数().getText()),
    子节点: this.visit(上下文.声明())};
};

定制访问器.prototype.visit声明 = function(上下文) {
  return this.visit(上下文.getChild(0));
};

定制访问器.prototype.visit转向 = function(上下文) {
  var 方向 = 上下文.T转向().getText();
  var 角度 = parseInt(上下文.T数().getText()) * (方向 === &quot;左&quot; ? 1 : -1);
  return {类型: &#39;转向&#39;, 参数: 角度};
};

定制访问器.prototype.visit前进 = function(上下文) {
  return {类型: &#39;前进&#39;, 参数: parseInt(上下文.T数().getText())};
};&lt;/code&gt;&lt;p&gt;上面的源码生成语法树大致如下所示. 实现上还有很多需要改进的, 比如&#39;前进&#39;和&#39;转向&#39;现在是两种&#39;类型&#39;, 但应该是一种; 根节点类型不应为空; 等等:&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-64cffeb88c144dc65304f5d678d02849_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;412&quot; data-rawheight=&quot;257&quot;&gt;&lt;p&gt;下面是&quot;编译.js&quot;中基于语法树生成指令列表的方法, 之后就与之前一样根据指令列表生成p5js绘制函数(代码也不用修改).&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;function 生成指令序列(节点) {
  var 指令序列 = [];
  // TODO: 根节点类型不应为空
  if (!节点.类型) {
    var 声明节点 = 节点.子节点;
    for (var i = 0; i &amp;lt; 声明节点.length; i++) {
      Array.prototype.push.apply(指令序列, 生成指令序列(声明节点[i]));
    }
  } else if (节点.类型 == &quot;循环&quot;) {
    var 指令序列 = [];
    for (var i = 0; i &amp;lt; 节点.次数; i++) {
      Array.prototype.push.apply(指令序列, 生成指令序列({子节点: 节点.子节点}));
    }
  } // TODO: 修改类型统一为&#39;指令&#39;
  else if (节点.类型 == &quot;前进&quot; || 节点.类型 == &quot;转向&quot;) {
    return [{名称: (节点.类型 == &quot;前进&quot; ? 常量_指令名_前进 : 常量_指令名_转向), 参数: 节点.参数}];
  }
  return 指令序列;
}&lt;/code&gt;&lt;p&gt;修改相应测试用例, 以及清理不再使用的监听器代码后. 代码已从visitor分支(&lt;a href=&quot;https://github.com/program-in-chinese/quan3/tree/visitor&quot;&gt;program-in-chinese/quan3&lt;/a&gt;)合并到master.&lt;/p&gt;</description>
<author>吴烜</author>
<guid isPermaLink="false">2018-01-03-32571516</guid>
<pubDate>Wed, 03 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>从计算复杂度往上往前（和两个没什么卵用的定理）</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-29-32476294.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32476294&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;在P和NP出现之前计算复杂性是怎么度量的？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;SPACE(f(n))，TIME(f(n))……这是在Scott Aaronson在&lt;a href=&quot;https://www.scottaaronson.com/democritus/&quot;&gt;《Quantum Computing Since Democritus》&lt;/a&gt;中PaleoComplexity一章里面所给出的答案。再翻翻其它的书，我们会得到的答案是，P=DTIME(n^c)。EXP=DTIME(2^(n^c))。（DTIME的意思是对于确定性图灵机的时间，Deterministic）NP的定义是“被非确定图灵机（Non-Deterministic）在多项式时间内解决的问题”，所以是NTIME(n^c)。&lt;/p&gt;&lt;p&gt;所以这真的就是Complexity的源头嘛？那么Complexity和Recursion Theory之间的关系究竟是什么呢？&lt;/p&gt;&lt;p&gt;这篇文章很短，因为我看书的速度比我打字的速度要快很多，所以我想偷懒（逃）不想写那么多；以及深觉文笔乏力，光看着一堆证明过程就已经觉得很爽很发光。&lt;/p&gt;&lt;p&gt;怀着很憋屈又很尊敬的心情去读书，书中的定理自然是不止那么多，很想安利人来入坑，对，这篇文章是一篇很憋屈很憋屈的安利文_(:з」∠)_&lt;/p&gt;&lt;p&gt;－－－－－－－－&lt;/p&gt;&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Blum_axioms&quot;&gt;Blum公理&lt;/a&gt;和&lt;a href=&quot;http://port70.net/~nsz/articles/classic/blum_complexity_1976.pdf&quot;&gt;计算复杂性的尺度&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;equation&gt;\{\varphi_i\}&lt;/equation&gt; 是所有的&lt;a href=&quot;https://en.wikipedia.org/wiki/%CE%9C-recursive_function&quot;&gt;递归函数&lt;/a&gt;（以及mu是一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Theory_of_descriptions&quot;&gt;摹状词&lt;/a&gt;）的枚举，其中i是第i个递归函数所对应的编号（对应到图灵机上就是哥德尔编号i所对应的图灵机）， &lt;equation&gt;\{\Phi_i\}&lt;/equation&gt; 是一组递归函数的序列。称 &lt;equation&gt;\Phi&lt;/equation&gt; 是计算复杂性的尺度（意味着计算复杂性尺度也是一个函数），当且仅当以下两个条件被满足：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;equation&gt;\varphi_i(x)&lt;/equation&gt; 有值当且仅当 &lt;equation&gt;\Phi_i(x)&lt;/equation&gt; 有值；&lt;/li&gt;&lt;li&gt;特征函数K是一个完全递归函数： &lt;equation&gt;K(i, x, y) = \begin{equation} \left\{ \begin{array}{lr} 1 &amp;amp; \Phi_i(x) = y,\\ 0 &amp;amp; otherwise(例如无定义) \end{array} \right. \end{equation} &lt;/equation&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所以来看看所谓的&lt;b&gt;时间复杂度&lt;/b&gt;是怎么对应上来的嘛？&lt;/p&gt;&lt;p&gt;&lt;equation&gt;T_i(x) = \begin{equation} \left\{ \begin{array}{lr} y &amp;amp; 多带图灵机\varphi_i(x)有值且计算步数为y,\\ undefined &amp;amp; otherwise \end{array} \right. \end{equation} &lt;/equation&gt; &lt;/p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Multitape_Turing_machine&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Multitape Turing Machine&lt;/a&gt;&lt;blockquote&gt;（问：证明这个“尺度”是一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_function&quot;&gt;完全递归函数&lt;/a&gt;，如果追求更完整的话，证明存在一个K与这个尺度对应）&lt;br&gt;（Extra Credit：证明&lt;b&gt;量子计算机&lt;/b&gt;的时间复杂度类是存在合法尺度的）&lt;/blockquote&gt;&lt;p&gt;那么&lt;b&gt;空间复杂度&lt;/b&gt;呢？&lt;/p&gt;&lt;p&gt;&lt;equation&gt;T_i(x) = \begin{equation} \left\{ \begin{array}{lr} y &amp;amp; 脱线图灵机\varphi_i(x)有值且工作区使用的格子数为y,\\ undefined &amp;amp; otherwise \end{array} \right. \end{equation} &lt;/equation&gt; &lt;/p&gt;&lt;blockquote&gt;（问：同上）&lt;/blockquote&gt;&lt;h2&gt;计算复杂度尺度的一些性质&lt;/h2&gt;&lt;p&gt;&lt;b&gt;为什么“如果计算不会太复杂的话，函数的值就不会太大”&lt;/b&gt;&lt;/p&gt;&lt;p&gt;定理：存在完全递归函数h，使得 &lt;equation&gt;\forall i \ h(x, \Phi_i(x) \ge \varphi_i(x))\ a.e.(almost\ everywhere)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;证明：令&lt;/p&gt;&lt;p&gt;&lt;equation&gt;H(i, x, y) = \begin{equation} \left\{ \begin{array}{lr} \varphi_i(x) &amp;amp; \Phi_i(x) = y\\ 1 &amp;amp; otherwise \end{array} \right. \end{equation} &lt;/equation&gt; ，&lt;/p&gt;&lt;p&gt;又令&lt;/p&gt;&lt;p&gt;&lt;equation&gt;h(x, y) = \mathop{max}_{i \le x}H(i, x, y)&lt;/equation&gt;，&lt;/p&gt;&lt;p&gt;则按照&lt;a href=&quot;https://en.wikipedia.org/wiki/Primitive_recursive_function&quot;&gt;原始递归函数&lt;/a&gt;的定义，这两个函数都是完全递归函数。令 &lt;equation&gt;x \ge i&lt;/equation&gt; 且&lt;equation&gt;\varphi_i(x)&lt;/equation&gt; 定义，则 &lt;equation&gt;h(x, \Phi_i(x)) \ge H(i, x, \Phi_i(x)) = \varphi_i(x)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;为什么“一个算法可以有任意复杂（而非简单）的算法”&lt;/b&gt;&lt;/p&gt;&lt;p&gt;定理：f、h为两个完全递归函数。则存在f的号码（如哥德尔编号或者康托尔的配对编号）使得 &lt;equation&gt;\Phi_j(x) \ge h(x)&lt;/equation&gt; 。f的号码的意思是计算函数f的图灵机。&lt;/p&gt;&lt;p&gt;证明：令&lt;/p&gt;&lt;p&gt;&lt;equation&gt;g(i, x) = \begin{equation} \left\{ \begin{array}{lr} f(x) &amp;amp; \Phi_i(x) &amp;gt; h(x)\\ 1 + \varphi_i(x) &amp;amp; otherwise \end{array} \right. \end{equation} &lt;/equation&gt; ，&lt;/p&gt;&lt;p&gt;则g是递归函数。那么，存在这样的函数q，使得：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{equation} \varphi_{q(i)}(x)\xlongequal{s-m-n定理}g(i, x) \end{equation}&lt;/equation&gt; ；&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Smn_theorem&quot;&gt;s-m-n定理&lt;/a&gt;还有一个名字，叫做参数化定理。接下来，又由&lt;a href=&quot;https://en.wikipedia.org/wiki/Kleene%27s_recursion_theorem&quot;&gt;递归定理&lt;/a&gt;，存在编号j使得 &lt;equation&gt;\varphi_{q(j)}(x)＝\varphi_{j}(x)&lt;/equation&gt; ，所以有&lt;/p&gt;&lt;p&gt;&lt;equation&gt;g(j, x) = \varphi_j(x) \ne 1+\varphi_j(x)&lt;/equation&gt; ，因此不可能有 &lt;equation&gt;\Phi_i(x) \le h(x)&lt;/equation&gt; ，因此j是f的号码。没错，到头回来，又是万恶的&lt;a href=&quot;https://en.wikipedia.org/wiki/Diagonal_method&quot;&gt;对角线&lt;/a&gt;。&lt;/p&gt;&lt;blockquote&gt;为什么两个定理不矛盾&lt;br&gt;（答案：...）&lt;/blockquote&gt;&lt;p&gt;－－－－－－－－&lt;/p&gt;&lt;p&gt;最后，真的以为计算复杂性的源头就到此为止了吗？&lt;/p&gt;&lt;p&gt;或许还会有下次更新以让这篇文章没有那么寒酸。。。&lt;/p&gt;&lt;p&gt;（嗷嗷嗷嗷嗷嗷嗷呜啊_(:з」∠)_）&lt;/p&gt;</description>
<author>钟狸</author>
<guid isPermaLink="false">2017-12-29-32476294</guid>
<pubDate>Fri, 29 Dec 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
