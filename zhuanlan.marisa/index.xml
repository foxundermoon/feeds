<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Thu, 01 Nov 2018 07:17:24 +0800</lastBuildDate>
<item>
<title>Some Pattern on Programming</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-10-28-47852685.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/47852685&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我想说一些旧闻。更准确的说，我收集了很多旧闻，想整理一下，变成一个没那么旧的旧闻。&lt;/p&gt;&lt;p&gt;&lt;b&gt;0：对于很多编程语言，我们真能做到‘给出编程语言X跟Y，给X一步步加功能，修改下原本的功能，最后成为Y’。我们姑且叫这做计算力吧。这方面的Work数不胜数。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对于Effect，我们有：&lt;/p&gt;&lt;p&gt;C is a purely functional language&lt;/p&gt;&lt;p&gt;Dijkstra Monad（被EK吐槽就是hoare monad on continuation）&lt;/p&gt;&lt;p&gt;Lazy Functional State Thread&lt;/p&gt;&lt;p&gt;Lambda The Ultimate Imperative&lt;/p&gt;&lt;p&gt;Gedanken&lt;/p&gt;&lt;p&gt;对于Subtyping，我们有：&lt;/p&gt;&lt;p&gt;The Essence of Algol（这也应该算Effect的，但那边挤满了）&lt;/p&gt;&lt;p&gt;A Semantics of Multiple Inheritance&lt;/p&gt;&lt;p&gt;至于Type？那就更多了&lt;/p&gt;&lt;p&gt;Untyped Program is unityped program&lt;/p&gt;&lt;p&gt;Gradual Typing上的work，不太清楚&lt;/p&gt;&lt;p&gt;Well typed program cant be blamed&lt;/p&gt;&lt;p&gt;Type System as Macro&lt;/p&gt;&lt;p&gt;Semantic上面有Unified Theory of Programming&lt;/p&gt;&lt;p&gt;编译器上面某种意义上也符合这个样子，如Lambda The Ultimate Goto，Compiling With Continuation，就是在给你说‘你看，函数，高阶函数，其实还是goto那一套。’&lt;/p&gt;&lt;p&gt;当然，LTU Goto严格来说不算Compiler，各种东西都算一点，但不放这一个Compiling With Continuation好孤单（&lt;/p&gt;&lt;p&gt;最后，Prolog也能&lt;a href=&quot;https://vanemden.wordpress.com/2016/11/12/the-essence-of-algol/&quot;&gt;这样搞&lt;/a&gt;，Dijkstra老爷子厉害啊，一个小改动（GCL）竟然能影响到这&lt;/p&gt;&lt;p&gt;&lt;b&gt;1：在PL以外，我们也能做到这点，有的时候还能直接unify出以前还没发现的东西&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A Unifying theory of Garbage Collection - 你看看，各种GC算法都是一个路子的&lt;/p&gt;&lt;p&gt;The Periodic Table of Data Structures - 我给你把各种数据结构一家人排得齐齐整整，还给你说你还差啥家人&lt;/p&gt;&lt;p&gt;Demystifying Differentiable Programming - Symbolic Diff = ANF on forward mode, ho reverse mode = CPS fo reverse mode，dual on dual，好漂亮啊&lt;/p&gt;&lt;p&gt;The simple essence of Automatic Differentiation - 跟上面一个样子，Unify各种AD，但是更categorically theoretic&lt;/p&gt;&lt;p&gt;A Discipline of Programming, The Craft of Programming, A Principled Approach to OS，都是教你Stepwise Refinement怎么玩（推算法/写OS），ADOP附加到分布式的伏笔。&lt;/p&gt;&lt;p&gt;A Duality of Sorts，The algebra of programming就是Program Calculation的例子。顺带一提，Program Calculation，Stepwise Refinement，也是刚好对一起啊&lt;/p&gt;&lt;p&gt;Liquid Type，看完给我的感觉就是，I have a Subtyping，I have an Algol W，Uh! Liquid-Type！ &lt;/p&gt;&lt;p&gt;Stackless Scala With Free Monads，从Free搞TCO&lt;/p&gt;&lt;p&gt;最后不得不提Lambda the ultimate opcode，直接从某个Lisp Interpreter给你推出CPU wire！如果你问我我最喜欢那篇paper，以我的性格，估计我会看着这篇跟The essence of Algol，最后说出你们都是我的翅膀这种话吧。&lt;/p&gt;&lt;p&gt;另外一提，&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43163820&quot;&gt;如何制造SCP018&lt;/a&gt; 就是我看完Lambda The Ultimate Opcode，Compiling With Continuation，Stackless Scala With Free Monads，然后想，LTU Opcode能从代码推出wire，我为啥不能反其道而行之，CWC说cont = PC，我就从PC推出cont，再弄出TCO。这操作秀得我自己都好开心，觉得这是最有难度的一篇（其他的收集收集资料谁都能写，就这篇有点original work的样子），然而人民群众不喜欢，正所谓知识越多越反动，orz&lt;/p&gt;&lt;p&gt;差点忘了，CH-XXXXX同构。在这下面我们甚至开始Unify Lazy/Strict了，见Haskell is not not ML。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2：很多时候，我们能发现些Pattern，但我们不知道怎么从一边算到另一边。有的时候甚至不知道怎么用。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;CPU其实就是个Interpreter&lt;/p&gt;&lt;p&gt;SuperScalar那就对应Program Analysis&lt;/p&gt;&lt;p&gt;Binary Translation不就是jit吗，我建议大家把x86 cpu加进list of transpiler里面troll JavaScript weenie（（（&lt;/p&gt;&lt;p&gt;Types As Abstract Interpretations - 字面意义&lt;/p&gt;&lt;p&gt;Your computer is already a distributed system - 字面意义&lt;/p&gt;&lt;p&gt;Algebra, Algebra, Algebra。。。Algebraic Data Type, The Derivative of Regular Type, Partially-Static Data As Free Extension Of Algebras，还有各种算法里面都会有Algebra&lt;/p&gt;&lt;p&gt;DSL, DSL, DSL everywhere - SQL, ASM, BPF，各个都有安全隐患，需要设计防止（SQL injection, page protection, BPF的整个BPF instruction就是安全措施，不然直接ring0跑用户输入asm就行了啊，还要啥BPF instruction自行车）但是转念一想，这不就是在argue for effect system吗？&lt;br&gt; &lt;b&gt;3：还有些。。。insight？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/34819931/answer/482024102&quot;&gt;同时，这些例子都是Abstraction的极优例子&lt;/a&gt;，SQL/ASM抽象得原本领域是啥都不知道。&lt;/p&gt;&lt;p&gt;最后，差点忘了Machine Learning。以前就吐槽过，&lt;a href=&quot;https://www.zhihu.com/question/24975949/answer/370015097&quot;&gt;branch prediction就是mini classifier&lt;/a&gt;，想不到真有人用NN去做branch prediction了，maya。这不说，ML对各种连续的任务最近大发神威啊，Learned Index Structure, Auto TVM, Peloton, Data Calculator，Deep Coder，乃至AlphaGo，最近很流行的做法就是用ML去学概率/Cost，剩下的接着上传统方法（读作爆搜）。&lt;/p&gt;&lt;p&gt;一个Recurrent problem是concurrency - Distributed System，Database，Algorithm， OS，Cache Coherent，甚至钻牛角尖点，我们还可以说metastable态也是concurrency issue - tyranny of the clock。然而我们还是没有解决concurrency的方案&lt;/p&gt;&lt;p&gt;&lt;b&gt;4：有时候还发现更多的fundamental incoherency&lt;/b&gt;&lt;/p&gt;&lt;p&gt;比如说另一篇我很喜欢的paper就是Miscomputation in software: Learning to live with errors，尽管我早读过了，去看那句‘Pupil Omega: Yo, I tell you, errors are fun! ’还是会被吓一跳。。也许Programming is interface能用stepwise refinement说几句，但是live programming。。。Hazel？圆不过去啊&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其实我写这么多，我还是不知道我的中心思想是啥。本文没有中心思想，我也不知道有啥用，我猜我只是想说‘看，我能从一个东西算出另一个，多有趣啊’。也许CHI跟periodic table of datastructure有用，但是剩下的其实都是hindsight。&lt;/p&gt;&lt;p&gt;希望有一天我们能把4/3/2/1都往上移，到最后只剩下0，然后有一天任何一个计算机本科毕业生都能做到‘从继电器开始给你推导出现在的本科CS课程’，那多美妙啊。&lt;/p&gt;&lt;p&gt;Calculemus。如果我漏了啥例子求补充。&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2018-10-28-47852685</guid>
<pubDate>Sun, 28 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>代码编辑器系列 #3 文本的存储 进化篇</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-10-13-46693881.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/46693881&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d695aa142b6fe04d3f6579a57771fa31_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;http://ice1000.org/2018/09/24/CodeEditor4/&quot;&gt;ice1000.org&lt;/a&gt; 这是原文，发表在我的博客。&lt;/p&gt;&lt;p&gt;在&lt;a href=&quot;http://ice1000.org/2018/04/29/CodeEditor2/&quot;&gt;上上篇文章&lt;/a&gt;中我说过，&lt;/p&gt;&lt;blockquote&gt;以后的方向主要是讲 JB 式编辑器的实现&lt;/blockquote&gt;&lt;p&gt;在&lt;a href=&quot;http://ice1000.org/2018/06/05/CodeEditor3/&quot;&gt;上一篇文章&lt;/a&gt;中我又说，&lt;/p&gt;&lt;blockquote&gt;那么这篇文章先说点别的吧&lt;/blockquote&gt;&lt;p&gt;简直是王镜泽定理的完美演绎啊。 为什么我要在半个月来第一篇博客开头说这个呢？因为这次讲的依然不是 JB 式编辑器的实现，真香。&lt;/p&gt;&lt;p&gt;关于上一篇博客在说 gap buffer 的时候提到的数据结构论文 Flexichain，我当时说读下来没学到什么东西。 实际上论文有两篇，内容应该基本上都在另一篇讲实现的里面。这是某活跃于 freenode #lisp 的 CL 厨告诉我的。&lt;/p&gt;&lt;p&gt;在我最近的新项目里，我使用了 Flexichain 论文里提到的 Hemlock 编辑器使用的数据结构 （我的那个使用C++实现，改自一个单独的 Java 项目 &lt;a href=&quot;https://github.com/ice1000/text-sequence&quot;&gt;text-sequence&lt;/a&gt;，前文提到的实验项目也换成了这个项目里的 &lt;code class=&quot;inline&quot;&gt;GapBuffer&lt;/code&gt;）， 这个数据结构在 &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.48.1265&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;piece table 的论文&lt;/a&gt;里有一个类似物叫 Line Span，于是我就直接叫它 &lt;code class=&quot;inline&quot;&gt;LineSpan&lt;/code&gt; 了。&lt;/p&gt;&lt;p&gt;本文包含这篇论文中的大部分知识。&lt;/p&gt;&lt;p&gt;前文说，&lt;/p&gt;&lt;blockquote&gt;由于 Swing 的 API 看起来更低效&lt;/blockquote&gt;&lt;p&gt;其实不是的， Swing 文本编辑器内部实现是一个 &lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/javax/swing/text/GapContent.html&quot;&gt;GapContent&lt;/a&gt;&lt;/code&gt;， 也就是一个过度 OO 设计的 &lt;code class=&quot;inline&quot;&gt;GapBuffer&lt;/code&gt;（可见写 Swing 的人并不是文盲，而且文化程度不低），这比我那时候用的更高效，所以我那时的想法还是太幼稚了。&lt;/p&gt;&lt;p&gt;既然本文是现代篇（对应上一篇的远古篇），那么讲的肯定是现代编辑器使用的数据结构啦。&lt;/p&gt;&lt;p&gt;介绍一个概念 end of line ，通常是 &lt;code class=&quot;inline&quot;&gt;\n&lt;/code&gt; 但考虑到有些情况下还有别的行分隔符就使用了 end of line 代表这个东西。&lt;/p&gt;&lt;h2&gt;Code 早期使用的数据结构&lt;/h2&gt;&lt;p&gt;应该很少有人使用可执行文件的名字来称呼这个全名叫 Visual Studio Code 的编辑器吧，正好可以显得很装逼（逃。 根据黑历史考据，我看到 Code 团队在 &lt;a href=&quot;https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation&quot;&gt;blog&lt;/a&gt; 里自述曾经使用按行存储的策略， 然后他们获得的好处是可以按行运行 Tokenizer ，可以提高代码高亮的性能（意思就是直接不考虑包含 end of line 的 Token ，很符合前端人员的编程思想）。&lt;/p&gt;&lt;p&gt;这历史应该是黑成碳了。根据上面那个链接里的博客来看，他们也没有使用优化 active line 的策略（比如我使用 GapBuffer ）。 不过呢，按行存储可以进行渲染上的优化（因为行可以被视为一个渲染单位，而且在屏幕移动时每行渲染出来的样子是不变的）， 这在某种意义上也是一种好处了（根据一个研究超算的软粉的说法，Visual Studio 会缓存每行的代码渲染后得到的 texture）。&lt;/p&gt;&lt;p&gt;LineSpan 的实现相对 GapBuffer 较为繁琐，它在插入的时候需要检查是否有插入 end of line 来考虑是否要拆掉当前的 active line 、 需要在删除的时候检查是否删除了一个 end of line 来考虑是否要合并当前行和下一行。 好处是，可以对行进行批量操作。&lt;/p&gt;&lt;p&gt;目前我的编辑器也是临时使用的这种数据结构，而且比起他们这个还提高了当前行的编辑效率和获取行的效率。 我原本计划使用一个线段树维护每行的长度的前缀和（之所以没有选择我最喜欢的树状数组，是因为我还需要删点），这样可以获得 &lt;code class=&quot;inline&quot;&gt;O(log(n))&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;getLineInfoAt&lt;/code&gt; 等函数。 但是在后来发现要获取对应行的迭代器还需要对链表进行高效的随机访问（或者存储迭代器到线段树里，但这意义已经没有那么大了，因为要换 Piece Table 实现），我就放弃了。 不过鄙视人家的黑历史也没什么意思，毕竟 Code 除了代码编辑的其他地方做的还是很不错的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;我做了一个 LineSpan 的数据结构可视化（非常妙），上传到了 &lt;a href=&quot;https://www.bilibili.com/video/av32595178/&quot;&gt;bilibili&lt;/a&gt; 和 &lt;a href=&quot;https://youtu.be/GOsf8OdeS08&quot;&gt;YouTube&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;其他杂七杂八的数据结构&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Split-Merge Tree ，保证 Rope 的最小单位 Sequence 在一个长度范围内，超过就拆，小于就合并两个相邻的，是比平衡树更平衡的平衡树&lt;/li&gt;&lt;li&gt;Fixed-Size-Buffer ，扁平版 Split-Merge Tree，你也可以叫它 Split-Merge LinkedList&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;文本序列数据结构的通用性质&lt;/h2&gt;&lt;p&gt;看到这里，我们脑中应该已经有了一个文本序列数据结构的一个通用模型了。 在前文讲 Rope 的时候我曾经提到，它是将最小的文本表示作为了一种抽象结构并使用平衡树组合他们，然后举例了几种可能的实现—— 一个获取文本的函数、字符数组（C 风格字符串）、惰性读取的文件、另一颗平衡树等。 GapBuffer 其实也是一种实现。&lt;/p&gt;&lt;p&gt;我们可以尝试把这种思想套到 LineSpan 上，然后发现也完全适用——它其实只是提出了一种新的最小文本表示的实现—— &lt;code class=&quot;inline&quot;&gt;Line&lt;/code&gt;，并使用链表或者平衡树去组合他们而已。 我们来给这个抽象里的概念起个名字吧。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一个 item 指文本序列的最小单位，通常是 &lt;code class=&quot;inline&quot;&gt;char&lt;/code&gt; 或者 &lt;code class=&quot;inline&quot;&gt;wchar_t&lt;/code&gt;&lt;/li&gt;&lt;li&gt;一个 sequence 指一系列以各种方式组合并在逻辑上是连续的 item ，即刚才提到的抽象结构，比如 &lt;code class=&quot;inline&quot;&gt;LinkedList&amp;lt;Character&amp;gt;&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;std::list&amp;lt;char&amp;gt;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;一个 buffer 指一段在物理上连续的 item ，一般只在实现中涉及&lt;/li&gt;&lt;ul&gt;&lt;li&gt;比如 &lt;code class=&quot;inline&quot;&gt;std::vector&amp;lt;char&amp;gt;::data&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;java.util.ArrayList&amp;lt;Character&amp;gt;&lt;/code&gt; 里面的那个数组&lt;/li&gt;&lt;li&gt;比如 mmap&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一个 item 序列如果同时是 sequence 和 buffer 那么它是一个 span&lt;/li&gt;&lt;ul&gt;&lt;li&gt;比如 &lt;code class=&quot;inline&quot;&gt;java.lang.String&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;std::string&lt;/code&gt;&lt;/li&gt;&lt;li&gt;buffer 中的逻辑连续的一部分可以算作一个 span ，比如 GapBuffer&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一个 descriptor 指描述一段 sequence 的数据结构，比如 LineSpan 中通常需要一个 &lt;code class=&quot;inline&quot;&gt;LineInfo&lt;/code&gt; 来保存 span 的位置、长度，那么这个 &lt;code class=&quot;inline&quot;&gt;LineInfo&lt;/code&gt; 就是一个 descriptor&lt;/li&gt;&lt;ul&gt;&lt;li&gt;descriptor 通常持有一个 sequence 的指针&lt;/li&gt;&lt;li&gt;这个定义和&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.48.1265&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;论文&lt;/a&gt;里说的不太一样，是我觉得更好的定义&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;然后我们来总结一下我们见过的各种东西吧：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;java.lang.Character&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;char&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;wchar_t&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;ImWchar&lt;/code&gt; 是 item&lt;/li&gt;&lt;li&gt;Ruby/Lua/JavaScript/Dart/Perl 等语言中的 &lt;code class=&quot;inline&quot;&gt;string&lt;/code&gt; 是 span&lt;/li&gt;&lt;li&gt;Rope 是一个递归的 sequence （&lt;code class=&quot;inline&quot;&gt;type Rope = BalancedTree (Either Span Rope)&lt;/code&gt;）&lt;/li&gt;&lt;ul&gt;&lt;li&gt;平衡树的 &lt;code class=&quot;inline&quot;&gt;Node&lt;/code&gt; 类可以看作 span 的 descriptor&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;java.lang.StringBuilder&lt;/code&gt; 是一个大 buffer ，最左边那部分是一个 span， descriptor 持有这个 &lt;code class=&quot;inline&quot;&gt;StringBuilder&lt;/code&gt; 要 build 的 &lt;code class=&quot;inline&quot;&gt;String&lt;/code&gt; 的长度&lt;/li&gt;&lt;li&gt;GapBuffer 内部有一个大 buffer ，它由两个中间有一个 gap 的不断变化的 span 组成&lt;/li&gt;&lt;ul&gt;&lt;li&gt;第一个 span 的 descriptor 存储这个 span 的长度，第二个 span 的 descriptor 存储这个 span 在大 buffer 里的的起始点&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;LineSpan 可以看作一个 &lt;code class=&quot;inline&quot;&gt;java.util.LinkedList&amp;lt;java.lang.CharSequence&amp;gt;&lt;/code&gt; 或者 &lt;code class=&quot;inline&quot;&gt;std::list&amp;lt;std::string&amp;gt;&lt;/code&gt; 的封装，属于 sequence&lt;/li&gt;&lt;ul&gt;&lt;li&gt;链表的迭代器就是 descriptor ，里面存的是 sequence ， Code 早期的这些 sequence 全是 span ，我的实现里 active line 是 sequence ，其他行是 span&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;是不是一下子就搞懂这些名词的含义了？下面我们将使用这套名词介绍一个新数据结构。&lt;/p&gt;&lt;h2&gt;Piece Table&lt;/h2&gt;&lt;p&gt;这是我目前觉得最好的文本编辑器存储数据所使用的数据结构。&lt;/p&gt;&lt;p&gt;Piece Table 由一个巨大的、 immutable 的、最好是 lazy 的 buffer （mmap 很适合作为这个 buffer）和一系列指向 span 的 descriptor 组成。 Descriptor 保存两个信息，头指针和长度。这一系列 descriptor 可以由链表保存（实现简单），也可以使用平衡树保存（更高效）。 由于我们不需要修改或者删除这些 descriptor 指向的 span ，我们可以把他们持有的 span 放进一个 buffer ，我们称之为 add buffer ，可以理解为一个 &lt;code class=&quot;inline&quot;&gt;ArrayList&amp;lt;Item&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在创建一个 Piece Table 的时候，我们需要初始化这个巨大的 buffer ，比如文本编辑器打开一个文件的时候就可以使用文件的 mmap 。 此时我们也初始化第一个 descriptor ，头指针指向大 buffer 的开头，长度就是整个 buffer 。&lt;/p&gt;&lt;h2&gt;查询&lt;/h2&gt;&lt;p&gt;如果给定 &lt;code class=&quot;inline&quot;&gt;offset&lt;/code&gt; 要取一个 Item ，就涉及存储 descriptor 的数据结构了—— 链表的话从头开始遍历 descriptor ，找到这个 &lt;code class=&quot;inline&quot;&gt;offset&lt;/code&gt; 所在的 descriptor 然后就可以从 buffer 里取值了，复杂度 &lt;code class=&quot;inline&quot;&gt;O(n)&lt;/code&gt;。 如果是平衡树就可以直接从 &lt;code class=&quot;inline&quot;&gt;offset&lt;/code&gt; 去找，复杂度 &lt;code class=&quot;inline&quot;&gt;O(log(n))&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;插入&lt;/h2&gt;&lt;p&gt;插入任意内容时（假设输入了 &lt;code class=&quot;inline&quot;&gt;offset&lt;/code&gt;（即&lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt;）和 &lt;code class=&quot;inline&quot;&gt;sequence&lt;/code&gt;），类似 LineSpan 插入 end of line 的情况，需要把这个 &lt;code class=&quot;inline&quot;&gt;offset&lt;/code&gt; 所在的那个 descriptor 拆掉，变成两个分别描述原本的 descriptor 在 &lt;code class=&quot;inline&quot;&gt;offset&lt;/code&gt; 前的那一半和后的那一半，然后把 &lt;code class=&quot;inline&quot;&gt;sequence&lt;/code&gt; 添加到 add buffer 的尾部， 然后在刚才这两个 descriptor 的中间插入一个指向这个 &lt;code class=&quot;inline&quot;&gt;sequence&lt;/code&gt; 在 add buffer 中位置的 descriptor 。&lt;/p&gt;&lt;p&gt;举个例子，假设我们有一个文件，里面有 &lt;code class=&quot;inline&quot;&gt;Piece&lt;/code&gt; 这几个字符。我们用它创建一个 Piece Table 后，大 buffer 里就是 &lt;code class=&quot;inline&quot;&gt;Piece&lt;/code&gt; ，长度为 5。 Descriptor 序列是这样的：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-aff8738ffefa9bc905cc7170c57aab5e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;305&quot; data-rawheight=&quot;80&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-aff8738ffefa9bc905cc7170c57aab5e&quot; data-watermark-src=&quot;v2-581d89340a84dabbbc456a3306380204&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们对他进行 &lt;code class=&quot;inline&quot;&gt;insert(1, &quot;Tb&quot;)&lt;/code&gt; ，那么先把 1 这个 &lt;code class=&quot;inline&quot;&gt;offset&lt;/code&gt; 所在的 0 号（查找 descriptor 的方法同查询） descriptor 拆开，原本长度为 5 的变成一个长度为 1 的和一个长度为 4 的：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7ee1f223b5c8a3abd3976c4d41f0ec9a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;307&quot; data-rawheight=&quot;107&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7ee1f223b5c8a3abd3976c4d41f0ec9a&quot; data-watermark-src=&quot;v2-2785f3696d94ccfb3e4b4d72d30c5bb3&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;然后向 add buffer 添加 &lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt; 这两个 Item ，然后在刚才两个 descriptor 中间插入一个新的 descriptor ：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e27847c18603aa4f1e62ccd12d8cc238_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;311&quot; data-rawheight=&quot;151&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e27847c18603aa4f1e62ccd12d8cc238&quot; data-watermark-src=&quot;v2-a505be4ef946b61cc3c4af3114f8b31f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;删除&lt;/h2&gt;&lt;p&gt;查找到 &lt;code class=&quot;inline&quot;&gt;offset&lt;/code&gt; 所在的 descriptor ，拆成两个并让左边那个的长度减一即可。&lt;/p&gt;&lt;h2&gt;Piece Table 的优良性质&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;可持久化数据结构&lt;/li&gt;&lt;li&gt;背后的大 buffer 可以完全 lazy 化，内存中的数据量将会巨小&lt;/li&gt;&lt;li&gt;descriptor 数量少&lt;/li&gt;&lt;li&gt;可以方便地使用平衡树优化&lt;/li&gt;&lt;li&gt;可以被翻译成『坨坨桌子』，很可爱&lt;/li&gt;&lt;li&gt;它可是 Code 使用的数据结构啊，搞懂了之后拿来吹的时候逼格挺高的&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Benchmark&lt;/h2&gt;&lt;p&gt;看论文去。&lt;/p&gt;&lt;p&gt;&amp;lt;end of blog&amp;gt;&lt;/p&gt;</description>
<author>兴趣使然千里冰封</author>
<guid isPermaLink="false">2018-10-13-46693881</guid>
<pubDate>Sat, 13 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>用Control.Dsl代替Monad</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-10-05-46014989.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/46014989&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Control.Dsl&lt;/code&gt;为Haskell提供了一套工具集来创建“可扩展”的领域特定语言，定制DSL&lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块。&lt;/p&gt;&lt;p&gt;DSL &lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块可以包含来自不同作者提供的各种操作。每个操作可以定义为一个GADT，由&lt;code class=&quot;inline&quot;&gt;Dsl&lt;/code&gt;类型类来解释执行，既可以有副作用，也可以是纯函数。&lt;/p&gt;&lt;p&gt;DSL &lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块是个抽象的“脚本”，其依赖的类型类可以自动推断。因此，只要提供不同的类型类实例，数据结构和解释器实现都可以随之改变。&lt;/p&gt;&lt;p&gt;本文剩下部分将会介绍如何用&lt;code class=&quot;inline&quot;&gt;Control.Dsl&lt;/code&gt;创建一门可扩展DSL，以及可以切换的两个解释器。 文中所有代码都基于&lt;code class=&quot;inline&quot;&gt;control-dsl&lt;/code&gt;包，可以在&lt;code class=&quot;inline&quot;&gt;ghci&lt;/code&gt;中运行。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Getting started&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Dsl&lt;/code&gt;类型类提供了&lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;、 &lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;=&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;return&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;fail&lt;/code&gt;等操作，用来代替&lt;code class=&quot;inline&quot;&gt;Monad&lt;/code&gt;中的对应操作。 你可以使用&lt;code class=&quot;inline&quot;&gt;RebindableSyntax&lt;/code&gt;扩展来启用&lt;code class=&quot;inline&quot;&gt;Dsl&lt;/code&gt;版的定制&lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块。 &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :set -XRebindableSyntax
&amp;gt;&amp;gt;&amp;gt; import Prelude hiding ((&amp;gt;&amp;gt;), (&amp;gt;&amp;gt;=), return, fail)
&amp;gt;&amp;gt;&amp;gt; import Control.Dsl&lt;/code&gt;&lt;h2&gt;&lt;b&gt;DSL model&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果你要创建一门DSL来执行控制台的IO操作，你可以以GADT方式定义一些DSL中的基本操作：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; data MaxLengthConfig r a where MaxLengthConfig :: MaxLengthConfig r Int
&amp;gt;&amp;gt;&amp;gt; data GetLine r a where GetLine :: GetLine r String
&amp;gt;&amp;gt;&amp;gt; data PutStrLn r a where PutStrLn :: String -&amp;gt; PutStrLn r ()&lt;/code&gt;&lt;h2&gt;&lt;b&gt;DSL&lt;/b&gt; &lt;b&gt;&lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;&lt;/b&gt;语句块&lt;/h2&gt;&lt;p&gt;以上操作可以用于&lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
dslBlock = do
  maxLength &amp;lt;- MaxLengthConfig
  line1 &amp;lt;- GetLine
  line2 &amp;lt;- GetLine
  when (length line1 + length line2 &amp;gt; maxLength) $ do
    PutStrLn &quot;The input is too long&quot;
    fail &quot;Illegal input&quot;
  PutStrLn (&quot;The input is &quot; ++ line1 ++ &quot; and &quot; ++ line2)
  return ()
:}&lt;/code&gt;&lt;p&gt;以上&lt;code class=&quot;inline&quot;&gt;dslBlock&lt;/code&gt;函数利用刚定义的操作和Control.Dsl内置操作创建了一段DSL抽象脚本。&lt;/p&gt;&lt;p&gt;GADT操作和结果语句（&lt;code class=&quot;inline&quot;&gt;return&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;fail&lt;/code&gt;）都是特设多态的限界continuation（ad-hoc polymorphic delimited continuations），由类型类&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;解释执行。GHC可以把所需的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;类型自动推断出来：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :type dslBlock
dslBlock
  :: (PolyCont (Return IOError) r Void, PolyCont (Return ()) r Void,
      PolyCont MaxLengthConfig r Int, PolyCont GetLine r [Char],
      PolyCont PutStrLn r ()) =&amp;gt;
     r&lt;/code&gt;&lt;h2&gt;&lt;b&gt;创建无副作用解释器&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;只要提供了适用的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt; 实例，&lt;code class=&quot;inline&quot;&gt;r&lt;/code&gt;可以是任意类型。比如：以下代码定义了无副作用的解释器&lt;code class=&quot;inline&quot;&gt;PureInterpreter&lt;/code&gt;以及对应的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;实例：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; type PureInterpreter = Int -&amp;gt; [String] -&amp;gt; Cont [String] IOError&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont MaxLengthConfig PureInterpreter Int where
  runPolyCont MaxLengthConfig = runPolyCont Get
:}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont PutStrLn PureInterpreter () where
  runPolyCont (PutStrLn s) = runPolyCont (Yield s)
:}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont (Return ()) PureInterpreter Void where
  runPolyCont (Return ()) = runPolyCont Empty
:}&lt;/code&gt;&lt;p&gt;以上三个&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;实例简单的转发到Control.Dsl的内置操作上。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont GetLine PureInterpreter String where
  runPolyCont k = runCont $ do
    x : xs &amp;lt;- Get @[String]
    Put xs
    return x
:}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;GetLine&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;实例要稍微复杂一些，实现为一个&lt;code class=&quot;inline&quot;&gt;Cont&lt;/code&gt; ，由若干个内置操作组合而成。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;无副作用地运行DSL&lt;/b&gt;&lt;/h2&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; runPurely = dslBlock :: PureInterpreter
&amp;gt;&amp;gt;&amp;gt; errorHandler e = [&quot;(handled) &quot; ++ show e]&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; runCont (runPurely 80 [&quot;LINE_1&quot;, &quot;LINE_2&quot;]) errorHandler
[&quot;The input is LINE_1 and LINE_2&quot;]&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; longInput = [replicate 40 &#39;*&#39;, replicate 41 &#39;*&#39;]
&amp;gt;&amp;gt;&amp;gt; runCont (runPurely 80 longInput) errorHandler
[&quot;The input is too long&quot;,&quot;(handled) user error (Illegal input)&quot;]&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; runCont (runPurely 80 [&quot;ONE_LINE&quot;]) errorHandler
[&quot;(handled) user error (Pattern match failure in do expression at &amp;lt;interactive&amp;gt;...&quot;]&lt;/code&gt;&lt;h2&gt;&lt;b&gt;创建有副作用的解释器&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;此外，只要提供了有副作用的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;实例，&lt;code class=&quot;inline&quot;&gt;dslBlock&lt;/code&gt;还能以带副作用的方式运行。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; type EffectfulInterpreter = Handle -&amp;gt; IO ()&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont GetLine EffectfulInterpreter String where
  runPolyCont GetLine = runCont $ do
    h &amp;lt;- Get
    line &amp;lt;- Monadic (hGetLine h)
    return line
:}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Monadic&lt;/code&gt;是个内置操作，可以在DSL &lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块执行monad操作，比如IO。其他操作（比如&lt;code class=&quot;inline&quot;&gt;Get&lt;/code&gt;）可以和&lt;code class=&quot;inline&quot;&gt;Monadic&lt;/code&gt;出现在同一个&lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块，而不需要任何monad transformer。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont MaxLengthConfig (IO ()) Int where
  runPolyCont MaxLengthConfig f = f 80
:}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont PutStrLn (IO ()) () where
  runPolyCont (PutStrLn s) = (Prelude.&amp;gt;&amp;gt;=) (putStrLn s)
:}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont (Return IOError) (IO ()) Void where
  runPolyCont (Return e) _ = hPutStrLn stderr (show e)
:}&lt;/code&gt;&lt;h2&gt;&lt;b&gt;以副作用方式运行DSL&lt;/b&gt;&lt;/h2&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; runEffectfully = dslBlock :: EffectfulInterpreter&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
withSystemTempFile &quot;tmp-input-file&quot; $ \_ -&amp;gt; \h -&amp;gt; do
  Monadic $ hPutStrLn h &quot;LINE_1&quot;
  Monadic $ hPutStrLn h &quot;LINE_2&quot;
  Monadic $ hSeek h AbsoluteSeek 0
  runEffectfully h
:}
The input is LINE_1 and LINE_2&lt;/code&gt;&lt;h2&gt;&lt;b&gt;结论&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了如何用&lt;code class=&quot;inline&quot;&gt;Control.Dsl&lt;/code&gt;创建自己的DSL。不同于&lt;code class=&quot;inline&quot;&gt;Monad&lt;/code&gt;，用&lt;code class=&quot;inline&quot;&gt;Control.Dsl&lt;/code&gt;创建的DSL可以扩展。只要创建GADT和对应的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;，就可以为现有的解释器添加新操作。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;相关链接&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Atry/Control.Dsl&quot;&gt;Control.Dsl on Github&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://hackage.haskell.org/package/control-dsl&quot;&gt;control-dsl on Hackage&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2018-10-05-46014989</guid>
<pubDate>Fri, 05 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>SICP习题2.16解题报告</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-10-03-45914836.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45914836&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2e00403771dbac27f351f472f5dbd324_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;SICP：一种数学书，虽然名字里带计算机三个字，但是看这本书的时候基本可以不用电脑&lt;/p&gt;&lt;p&gt;被誉为“只有在校学生才有时间阅读的书”和“抽象训练集中营”&lt;/p&gt;&lt;p&gt;曾用半页来介绍MIT第一任校长的生平（第二章2.2.4节脚注89）&lt;/p&gt;&lt;p&gt;其习题以消磨时间的高效率著称&lt;/p&gt;&lt;p&gt;其中习题2.16附有一句话“警告：这个问题非常难”&lt;/p&gt;&lt;p&gt;于是就有了这个解题报告&lt;/p&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;题目的前半部分（习题2.7-习题2.15）都在描述一种“区间算法”。区间算法定义为对有一定误差的数值的运算，其中区间的运算结果定义为区间可能取值的结果的最大值和最小值。如：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\left[a,b\right]+\left[c,d\right] = \left[a+c,b+d\right]\\ \frac{\left[a,b\right]}{\left[c,d\right]} = \left[\frac{a}{d},\frac{b}{c}\right]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;*和-同理。&lt;/p&gt;&lt;h2&gt;题面&lt;/h2&gt;&lt;p&gt;清秋的早晨，阳光明媚，风和日丽，窗外鸟儿时不时轻鸣两声。突然，电话铃响了。你接起电话，电话那端传来了客户的怒吼，鸟儿吓得扑棱着翅膀飞走了。&lt;/p&gt;&lt;p&gt;众所周知，并联电路的电阻计算公式有两种代数等价的写法，可以写成这样子：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;R_总=\frac{1}{\frac{1}{R_1}+\frac{1}{R_2}}=\frac{R_1R_2}{R_1+R_2}\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;那位客户用你的系统对两个公式都分别写了一份代码。突然，诡异的背景音乐响起，两份代码计算出来的结果区间竟然不一样！&lt;/p&gt;&lt;p&gt;这就是为什么你在这个明媚的秋日不外出散步，而又坐在办公桌前打开代码编辑器的原因。&lt;/p&gt;&lt;p&gt;请给出一个一般性的解释：为什么等价的代数式会给出不同的结果？你能设计一个系统，使之没有这个缺陷吗？或者说这件事根本不可能做到？&lt;/p&gt;&lt;h2&gt;解题报告&lt;/h2&gt;&lt;p&gt;练习2.14要求计算A/A的结果，计算出来之后发现并不是1，而是 &lt;equation&gt;\left[\frac{a}{b},\frac{b}{a}\right]&lt;/equation&gt; 。它离 &lt;equation&gt;\left[1,1\right]&lt;/equation&gt; 很近，但是还差一点。&lt;/p&gt;&lt;p&gt;但是，从代数的角度来说A/A应该为1。&lt;/p&gt;&lt;p&gt;略作思考后就能明白，区间运算的含义是：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\left[a,b\right]\oplus\left[c,d\right] = \left[e,f\right]，当且仅当对于任意x_1\in\left[a,b\right]，x_2\in\left[c,d\right]，x_1\oplus x_2\in\left[e,f\right]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;也就是说，e为所有可能运算结果的最小值，f为所有可能运算结果的最大值&lt;/p&gt;&lt;p&gt;而我们调用过程的时候，过程并不知道区间 &lt;equation&gt;\left[a,b\right]&lt;/equation&gt; 和区间 &lt;equation&gt;\left[a,b\right]&lt;/equation&gt; 是不是同一个变量，他们可能是两个独立变量，只是区间恰好相同。于是过程就假设这是两个独立取值的变量，计算出了区间 &lt;equation&gt;\left[\frac{a}{b},\frac{b}{a}\right]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;那么，如何让区间运算过程知道区间 &lt;equation&gt;\left[a,b\right]&lt;/equation&gt; 和区间 &lt;equation&gt;\left[a,b\right]&lt;/equation&gt; 是不是同一个变量呢？&lt;/p&gt;&lt;h2&gt;解题方法1&lt;/h2&gt;&lt;p&gt;我的第一个想法是给相同的区间附一个相同的符号，让区间运算过程在进行运算前先对符号进行一个符号运算，再根据符号运算结果生成结果区间&lt;/p&gt;&lt;p&gt;但是很显然，Scheme和Common Lisp并没有自带符号运算系统，如果自带了的话我也不知道。如果要自己写一个符号运算系统的话，虽然能做到，但是费时费力费人脑，不像是正解&lt;/p&gt;&lt;p&gt;以及，根据符号生成结果区间的过程可能有点慢，并且需要一张全局哈希表来记录符号和区间的映射（反正我是不想每次调用运算符都得传一个Env）。然而，SICP从第一章到习题2.15，从来没有用到过一句有副作用的语句（输出语句除外），显然这种做法太暴力了&lt;/p&gt;&lt;p&gt;【如果是Mathematica的话我或许会考虑一下&lt;/p&gt;&lt;h2&gt;解题方法2&lt;/h2&gt;&lt;p&gt;（&lt;a href=&quot;https://www.xuebuyuan.com/1470405.html&quot;&gt;来源&lt;/a&gt;）（&lt;a href=&quot;http://www.aichengxu.com/other/7368174.htm&quot;&gt;另一个相似内容（更详细）&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;于是，抱着“反正SICP都警告过了我做不出来也情有可原”的想法去网上找了一下题解&lt;/p&gt;&lt;p&gt;然后看到了这篇&lt;/p&gt;&lt;p&gt;我的思路是在操作符和构造符这一抽象层面上进行构造来解决问题，而这一答案采取的是在操作层面进行构造&lt;/p&gt;&lt;p&gt;答案大致内容是对于一个算式，将n个区间所有 &lt;equation&gt;2^n&lt;/equation&gt; 个取值都列举一遍，求出所有取值所产生的最大值和最小值打包成答案返回。&lt;/p&gt;&lt;p&gt;原答案：&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;(define (calculate f x y)
  (let ((p1 (f (lower-bound x) (lower-bound y)))
        (p2 (f (upper-bound x) (upper-bound y)))
        (p3 (f (lower-bound x) (upper-bound y)))
        (p4 (f (upper-bound x) (lower-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))&lt;/code&gt;&lt;p&gt;抛开 &lt;equation&gt;\Theta(2^n)&lt;/equation&gt; 的恐怖效率不谈，上述代码也是有缺点的。最明显的一个就是它只适用于n=2的情况。然而我们的算式可能有任意n个变量。&lt;/p&gt;&lt;p&gt;如果修改一下代码，用更复杂但更通用的方式实现的话可以对任意n个变量起作用，但是永远甩不开&lt;equation&gt;\Theta(2^n)&lt;/equation&gt; 的恐怖效率。&lt;/p&gt;&lt;h2&gt;解题方法3&lt;/h2&gt;&lt;p&gt;你看着那个&lt;equation&gt;\Theta(2^n)&lt;/equation&gt; 的恐怖算法，觉得一定有更好的解决方案&lt;/p&gt;&lt;p&gt;突然，树上一颗苹果落下砸中你脑袋一样，你想到了另一种方案&lt;/p&gt;&lt;p&gt;区间运算的本质是什么？&lt;/p&gt;&lt;p&gt;结果下界为所有可能运算结果的最小值，上界为所有可能运算结果的最大值&lt;/p&gt;&lt;p&gt;那么如果我给每个区间拉张表，表上随机列出区间内的取值，然后在两个表中间直接暴力算，最后暴力找出最大值和最小值，那不就得到结果区间了吗？比如 &lt;equation&gt;[2,3]\times[4,6] = [8,18]&lt;/equation&gt; ，就可以这样算： &lt;equation&gt;\left\{ 2,3,2,2,3 \right\}\times\left\{4,6,5,5,4\right\} = \left\{8,18,10,10,12\right\}&lt;/equation&gt; ，然后统计最大值和最小值得到 &lt;equation&gt;[8,18]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;如果遇到A/A这种情况，因为同一个变量的随机表都是相同的，随机表中每一项都会变成1，那不就得到 &lt;equation&gt;\left[1,1\right]&lt;/equation&gt; 了吗？&lt;/p&gt;&lt;p&gt;不是很好。如果表与表运算结果中没有&lt;b&gt;真正的&lt;/b&gt;最大值和最小值，那你得出来的就是宽度过小的错误结果。&lt;/p&gt;&lt;p&gt;很简单，强制在表里面随机插几个区间的最大值最小值不行吗？&lt;/p&gt;&lt;p&gt;不。如果数量太少的话两张表的最大值和最小值没法相遇，也得不到精确答案。&lt;/p&gt;&lt;p&gt;那我随机用最大值和最小值将表填满总行了吧。&lt;/p&gt;&lt;p&gt;不完美。这样子很容易撞表，得出过小的区间。&lt;/p&gt;&lt;p&gt;单个表项为实际最大值或最小值的概率为 &lt;equation&gt;\frac{1}{2}&lt;/equation&gt; ，所以设表中有n个项（ &lt;equation&gt;n\gt1&lt;/equation&gt; ），上下界都错误的概率是 &lt;equation&gt;\frac{1}{2^n}&lt;/equation&gt; ，错其中至少一个界的概率为 &lt;equation&gt;\frac{3^n}{4^n}&lt;/equation&gt; ，当n=50的时候，正确的概率为 &lt;equation&gt;99.99994336783435730623753348853\%&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;但是每次进行运算，表中就会出现n/2个无助于运算的“无用项”，但为了确保R1R2/R1=R2，那些无用项不能舍去，也不能重置成有用项。也就是说，长度为1024的表在运算一次过后就只剩512能用，运算大约10次后再继续运算就不可能得到正确结果了。&lt;/p&gt;&lt;p&gt;可以提供一个clear函数，重置表来继续运算。&lt;/p&gt;&lt;p&gt;这样子通过一个表就可以完美支持区间的各种运算了。若运算式中有n个变量且每个变量参与运算的次数为常数，则时间复杂度仅为 &lt;equation&gt;\Theta(n\times l)&lt;/equation&gt; ，其中l为表长。&lt;/p&gt;&lt;p&gt;优点是代码比较容易实现，速度较快，接口比较简单（对下游用户友好）&lt;/p&gt;&lt;p&gt;缺点是运算的正确率不是100%，并且在处理小规模问题的时候常数太大。&lt;/p&gt;&lt;h2&gt;代码-解题方法2&lt;/h2&gt;&lt;p&gt;（对Lisp不熟悉的人可以跳过此段）&lt;/p&gt;&lt;p&gt;对于解题方法2的一个扩展代码&lt;/p&gt;&lt;p&gt;我们希望像这样子计算&lt;/p&gt;&lt;code lang=&quot;scheme&quot;&gt;(calculate ((r1 (make-interval 1 3)) (r2 (make-interval 2 4)))
    (/ (+ r1 r2) (* r1 r2)))&lt;/code&gt;&lt;p&gt;（以下由于SICP里面已经没有涉及到了而且有一定复杂性所以我使用Common Lisp进行讲解，反正Common Lisp和Scheme很像）&lt;/p&gt;&lt;p&gt;这很简单。我们只需要一个宏，将算式展开到一个list中，然后取list的最大值和最小值就是结果。具体求值可以将r1、r2的取值展开到一个let中，在let里面对表达式进行求求值&lt;/p&gt;&lt;p&gt;（Common Lisp代码）&lt;/p&gt;&lt;code lang=&quot;common-lisp&quot;&gt;;;tool with-gensym
(defmacro with-gensym (names &amp;amp;rest body)
  `(let ,(mapcar #&#39;(lambda (n)
		     `(,n (gensym)))
		 names)
     ,@body))

;;tool enumerate
(defun enumerate (symbol-1 symbol-2 num)
  (if (= num 1)
      `((,symbol-1) (,symbol-2))
      (let ((last (enumerate symbol-1 symbol-2 (- num 1))))
	(nconc (mapcar #&#39;(lambda (x) (cons symbol-1 x)) last)
	       (mapcar #&#39;(lambda (x) (cons symbol-2 x)) last)))))

(defmacro calculate (vars body)
  (with-gensym (lst)
    `(let (,lst ,(calc-expander vars body (length vars)))
       (make-interval (min ,lst) (max ,lst)))))

(defun calc-expander (vars body varnum)
  (let ((values (enumerate &#39;lower-bound &#39;upper-bound varnum)))
    `(list ,@(mapcar #&#39;(lambda (value)
			 `(let ,value ,body))
		     (mapcar #&#39;(lambda (enum)
				 (mapcar #&#39;(lambda (f v)
					     `(,(first v) (,f ,(second v))))
					 enum
					 vars))
			     values)))))&lt;/code&gt;&lt;h2&gt;代码-解题方案三&lt;/h2&gt;&lt;p&gt;（Common Lisp，和Scheme相差不远）&lt;/p&gt;&lt;code lang=&quot;common-lisp&quot;&gt;;; tool rand-choice
(defun rand-choice (term1 term2 num &amp;amp;optional res)
  (if (zerop num)
      res
      (if (zerop (random 2))
	  (rand-choice term1 term2 (- num 1) (cons term1 res))
	  (rand-choice term1 term2 (- num 1) (cons term2 res)))))


(defun make-interval (lower upper &amp;amp;optional (table-len 50))
  ;;(define (make-interval lower upper)
  (cons (cons lower upper) (rand-choice lower upper table-len)))

(defun make-interval-by-table (lower upper table)
  (cons (cons lower upper) table))

(defun lower (interval)
  (car (car interval)))

(defun upper (interval)
  (cdr (car interval)))

(defun table (interval)
  (cdr interval))

(defun tabapply (func tab1 tab2)
  (mapcar #&#39;(lambda (x y)
	      (funcall func x y))
	  tab1
	  tab2))

;;抽象壁垒

(defun make-interval-only-by-table (table)
  (make-interval-by-table (apply #&#39;min table)
			  (apply #&#39;max table)
			  table))

(defun interval-func (func interval-1 interval-2)
  (make-interval-only-by-table
   (tabapply func (table interval-1) (table interval-2)))) &lt;/code&gt;&lt;p&gt;（定义出抽象级别更高的interval-func之后很快就能一般化出interval-add等一系列函数）&lt;/p&gt;</description>
<author>木木</author>
<guid isPermaLink="false">2018-10-03-45914836</guid>
<pubDate>Wed, 03 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Resolving Python Symbols</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-10-02-45835774.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45835774&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该文对Python作用域相关知识进行彻底剖析。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Python中的变量符号&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Python的一个变量符号在一个作用域下只有以下中一种形式: &lt;/p&gt;&lt;ul&gt;&lt;li&gt;Local&lt;/li&gt;&lt;li&gt;Free&lt;/li&gt;&lt;li&gt;Cell&lt;/li&gt;&lt;li&gt;Global&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;注: Python解释器允许实现多重作用域&lt;/p&gt;&lt;p&gt;不同形式的符号对数据的存取方式不同。local, cell, free变量被存放在可随机访问的序列结构中，而global变量存于可变的哈希表中。&lt;/p&gt;&lt;p&gt;有一个基本概念 &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_binding&quot;&gt;bound&lt;/a&gt; 用来形容来自非外部的符号, 对于Python我们有&lt;/p&gt;&lt;ul&gt;&lt;li&gt;bound vars = cell vars+ local vars&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;按照概念, global vars应当属于free vars, 但python为了实现可变的全局符号表, 两者被分离开来。可以这样理解: free vars的符号在作用域被定义时即可确定, 而全局符号表可在任意时刻被增减修改。&lt;/p&gt;&lt;h2&gt;free vars可以用如下方式描述:&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;当一个符号无法在当前作用域内被找到，且能够在其上的某一层作用域被找到，以及找到符号的作用域不是全局的, 那么它在当前作用域内表示一个free vars。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;2. 在某个作用域中符号被标记为nonlocal的变量，如果这个作用域不是顶层或者顶层之下一个。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;cell vars可以被如下方式描述:&lt;/h2&gt;&lt;p&gt;当一个变量可以在当前作用域被找到，且在其下的作用域是自由变量。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;则&lt;/p&gt;&lt;h2&gt;local vars可以被如下方式描述&lt;/h2&gt;&lt;p&gt;在当前作用域进入(enter), 不是cell vars, 没有被nonlocal标记的变量。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;例子:&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;x = 1     # x : global
def f(a): # a : local
   b = 1  # b : local
   def g(y):  # g在f中, local;  y在g中, local
      c + y   # c在g中, free
   c = 2      # c在f中, cell
   d = 2      # d在f中, cell
   def h():   
       # d在不h中,但位于h存放free vars的位置
       def i():
          nonlocal d # d在i中, free 
          d = 3
   &lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;求出一个程序中的所有符号及其作用域&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;运算被加载的符号的函数为(&lt;equation&gt;R&lt;/equation&gt; = requires), 被存储的符号(&lt;equation&gt;E &lt;/equation&gt; = entered), 被显式标记为nonlocal的符号(&lt;equation&gt;N &lt;/equation&gt; = explicit_nonlocals)，被显式标记为global的符号( &lt;equation&gt;G&lt;/equation&gt;  = explicit globals)。&lt;/p&gt;&lt;p&gt;记取作用域 &lt;equation&gt;C&lt;/equation&gt; 的多个下层为 &lt;equation&gt;Children\; C&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;取作用域的上层为 &lt;equation&gt;Parent\; C&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;则&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align}  Local\; C  &amp;amp;=  \{ v \in Bound\; C  \;| \; v \not \in Cell\;C\}  \\  Cell\;C     &amp;amp;= \{ v   \in Bound \; C \; | v \in \cup_{C&#39; \in Children\; C} \;  Free \; C&#39; \} \\ Free\; C &amp;amp;=  N\; C \cup (\cup_{i \in Z^+} \{ v \in R \;C\cap Bound\;Parent^i  \;C \}) \\ Bound \; C &amp;amp;= \{ v \in E \; C \;|\; v  \not \in Global\; C, \; v \not \in N\; C \} \\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;计算时，先bound，再free, 后cell, 再local。&lt;/p&gt;&lt;p&gt;实现: &lt;a href=&quot;https://github.com/thautwarm/kizmi/blob/master/kizmi/extended_python/symbol_analyzer.py&quot;&gt;Yet Another Python Python&lt;/a&gt;&lt;/p&gt;&lt;p&gt;效果: (如下图)&lt;/p&gt;&lt;p&gt;用处: 实现原汁原味的Python时，可以预先计算好作用域符号表，将&lt;a href=&quot;https://github.com/python/cpython/blob/master/Python/symtable.c&quot;&gt;https://github.com/python/cpython/blob/master/Python/symtable.c&lt;/a&gt; 大幅简化。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6f74cd2c911b5cd4ee29df4234b7d55c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;933&quot; data-rawheight=&quot;776&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6f74cd2c911b5cd4ee29df4234b7d55c&quot; data-watermark-src=&quot;v2-d45f5dbf97b19fa9a8180a005528987c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;注: 使用pending/future的策略可以不预先计算作用域表，但书写较为麻烦。实现如下:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/thautwarm/reley/blob/master/reley/impl/compiler.py&quot;&gt;Haskell like language in Python&lt;/a&gt;&lt;/p&gt;&lt;p&gt;思路:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;async def emit_stmt(...):
    # 加载名字
    await declared(...)
    # 对内部结构进行编译
    await compiled(...)
    # 对作用域符号表进行修正
    await resolved(...)
    # 后续编译&lt;/code&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>头顶青天红美铃</author>
<guid isPermaLink="false">2018-10-02-45835774</guid>
<pubDate>Tue, 02 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>7天7paper</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-10-01-45815032.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45815032&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各位国庆快乐！&lt;/p&gt;&lt;p&gt;好久都没写东西了，就随便找个借口写点东西吧。&lt;/p&gt;&lt;p&gt;既然国庆放七天，我就随手推荐七篇paper吧，在脑袋里面找出来的，以前可能推荐过，不要见怪。&lt;/p&gt;&lt;p&gt;Generic Deriving of Generic Traversals - 好中规中矩的paper，就是说‘我用generics搞出了scrap your boilerplate without runtime type checking’，没有任何novelty。不过数字好漂亮啊！&lt;/p&gt;&lt;p&gt;Generic Programming of All Kinds - 靠De Bruijn Index跟各种扩展把True Sum of Product搞上gadt/constrainted/rankn等等等等。几天前当 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/2d8f51b6523e01a8529606f466d98198&quot; data-hash=&quot;2d8f51b6523e01a8529606f466d98198&quot; data-hovercard=&quot;p$b$2d8f51b6523e01a8529606f466d98198&quot;&gt;@Felis sapiens&lt;/a&gt; 到西雅图来玩的时候曾经问他‘True Sum of Product跟Scrap Your Boilerplate你选那个’，结果他竟然给我说GHC.Generic！原因是TSOP/SYB等难以搞上复杂一点的类型（GADT/RankN）。现在看到这篇paper，越来越觉得有道理 - 这搞是搞上去了，不过好复杂，说不定反而比Generic用起来更麻烦呢。&lt;/p&gt;&lt;p&gt;Demystifying Differentiable Programming: Shift/Reset the Penultimate Backpropagator - 这是The paper on AD。曾经想过，其实只有两种AD算法，forward跟reverse，其他的一切ad算法都只是这两的变种（numerical ad是forward，但是不用infinitesmall，改某个足够小的值，symbolic也是forward，但是没有cse，同理，把wengert list变成runtime datastructure就是higher order reverse mode），然后写个blog。结果发现，这不就是这篇paper吗。结果竟然被ICFP拒了，什么鬼。&lt;/p&gt;&lt;p&gt;Beautiful differentiation - 这篇paper提出了differentiation tower，一次求出无数个导，挺漂亮的。另外也是conal照常的猫论时间。&lt;/p&gt;&lt;p&gt;Lightweight Static Capabilities - 教你怎么在不玩type level programming的情况下实现某种意义上的dependent type。&lt;/p&gt;&lt;p&gt;Ghosts of Departed Proofs - 上面内篇paper的扩展，变得更general了&lt;/p&gt;&lt;p&gt;Haskell is not not ML - Wadler老爷子说过‘一个idea会被逻辑学家发明一遍，再被计算机科学家发明一遍’。这篇paper给我的感觉是SPJ挥舞着大锤子，在intuitionistic paraconsistent logic上敲了敲，然后duang的一声发现能用来unify strict&amp;amp;lazy language。以前看过para logic的时候，发现这是intuition的dual，但是在PL中完全没找到用途。。。现在竟然被找出来了，v587&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2018-10-01-45815032</guid>
<pubDate>Mon, 01 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>浅谈 编程语言研究 与 程序分析</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-10-01-45208498.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45208498&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-177562a74b47d6e59e518120f85e7ead_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;前言&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在上一篇文章《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43914842&quot;&gt;浅谈国内高校编程语言教育&lt;/a&gt;》（简称《浅教》）中，我提到了国外顶尖大学的编程语言课程大都是由从事&lt;b&gt;编程语言&lt;/b&gt;（Programming Languages简称，&lt;b&gt;PL&lt;/b&gt;）研究的专门人才来讲授的。PL作为软件的核心技术，在软件开发效率、软件可靠性、安全性、性能等方面都提供了根本性的支持。PL是一个已经活跃了50余年的研究领域，作为软件创新的核心动力，如今仍是一个极有生命力且非常活跃的学科。&lt;/p&gt;&lt;p&gt;如《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43914842&quot;&gt;浅教&lt;/a&gt;》所述，在排名领先的世界名校中，但凡有点规模的计算机院系，几乎都会有PL方向的全职教授和研究人员，且越顶尖的大学，PL的研究越受重视。然而我国的情况并非如此，PL这样历史悠久且庞大复杂的学科在中国计算机学会并没有相应的专委（Again，形式化方法专委和软件工程专委无法取代编程语言专委，反之亦然），高校和科研院所也极少有专门注明PL为研究方向的教授和科研人员。因此，我想通过这篇文章向感兴趣的知友们简单介绍一下当前PL研究的整体概况和我所在的研究领域——PL方向下程序分析的研究现状。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;编程语言会议&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;判断一个人的研究领域是否属于PL，最简单的方法就是看他文章发表的会议。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;A级会议&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;国际上编程语言有公认的四大顶会：&lt;b&gt;PLDI&lt;/b&gt;、&lt;b&gt;POPL&lt;/b&gt;、&lt;b&gt;OOPSLA&lt;/b&gt;、&lt;b&gt;ECOOP&lt;/b&gt;。（有点像Security里面的四大顶会Oakland、CCS、Usenix Security、NDSS）。&lt;/p&gt;&lt;p&gt;如果非要细分，PLDI和POPL要比OOPSLA和ECOOP好。这么多年，我通过博士、博后导师们的灌输+开会聊天了解到，欧洲人一般认为ECOOP稍好于OOPSLA（欧洲的PL研究人员特别多，很多知名编程语言的创始人也都来自欧洲如C++, C#, Python, Scala, PHP, ML, Haskell等），而北美人一般认为OOPSLA稍好于ECOOP。说ECOOP稍好的人一般持“OOPSLA由美国ACM主导，有钱有颜（资金和宣传力），且ECOOP（由欧洲AITO主导）被毙掉的文章一般会流向OOPSLA（ECOOP和OOPSLA作为姊妹会议同一年创办且deadline一前一后），所以OOPSLA有更多的submission和随之而来更低的录取率”。&lt;/p&gt;&lt;p&gt;我刚开始读博士时不太懂，单纯地认为录取率低的会议好于录取率高的，后来随着在research上逐渐成熟慢慢了解到一个会议的好坏要看一个领域自己的人对它的认可情况，这个会议的program committee比它的排名、会议规模和录取率更重要（后面也懂得顶会论文数量和citation并不能评价一个人的真正学术水平和影响，这个就不在此展开了）。打一个比方，超级女声和青歌赛，前者报名人数众多1000人（因为名气大能出名，能吼两句的都想试试）且录取率很低（进100，10%），而后者报名人数很少200人（起码都是稍微专业一些的）随之录取率也相对较高（进50，25%），但你不能因为说前者人数更多且竞争更激烈，就觉得进超女决赛的人比进青歌赛决赛的人唱歌更好吧。&lt;/p&gt;&lt;p&gt;近些年，OOPSLA和ECOOP为了扩大PL在应用方面的影响力，也鼓励录取一些偏软件工程（SE）等方面的文章，个人认为在录取的文章中，还是那些偏PL的文章的整体水平更高，因为PL人审PL类文章会更专业且更严格（当然凡事也都有例外，偏PL的文章也有差的而偏SE的文章也有好的）。&lt;/p&gt;&lt;p&gt;实际上还有一个非常好的PL会议，虽然不像ECOOP和OOPSLA那样general，但其名声和质量并不比它们差。这个会议就是&lt;b&gt;ICFP&lt;/b&gt;，是functional programming领域的ECOOP和OOPSLA。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;B级会议&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;继PLDI/POPL/OOPSLA/ECOOP后下一个档次的PL会议是&lt;b&gt;ESOP&lt;/b&gt;（欧洲编程语言会议），这个是“纯”PL的会议（搞纯PL的人认为这个会议相当的好）。在我个人所在的研究领域program analysis（注：它是偏PL的基础分析技术即传统的静态分析，例如pointer/points-to/alias analysis等，而并不是利用这些基础分析技术开发的偏SE应用的software analysis）也有一些和ESOP一个档次的“类”PL会议。&lt;/p&gt;&lt;p&gt;这个档次的“类”PL会议包括静态分析会议&lt;b&gt;SAS&lt;/b&gt;（VMCAI和SAS一个级别，但搞抽象解释的朋友，他们很多都投VMCAI，告诉我他们认为SAS稍好于&lt;b&gt;VMCAI&lt;/b&gt;），软件工程会议&lt;b&gt;ISSTA&lt;/b&gt;（还有一个稍偏PL的SE会议是FSE，但FSE比ISSTA更好些，一般认为非同一级别），编译会议&lt;b&gt;CGO&lt;/b&gt;（CGO和CC一个级别，但近几年CGO要稍好于&lt;b&gt;CC&lt;/b&gt;），再有就是更小众的（在分析领域一般认为虽属同一档次但比前面的会议稍差那么一点的）内存管理会议&lt;b&gt;ISMM&lt;/b&gt;，还有偏嵌入式的&lt;b&gt;LCTES&lt;/b&gt;和&lt;b&gt;EMSOFT&lt;/b&gt;等。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;C级会议&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;再下一个档次的“纯”PL会议是&lt;b&gt;APLAS&lt;/b&gt;，它被认为明显好于同属一个档次的其他“类”PL会议，如&lt;b&gt;SOAP（&lt;/b&gt;是个非常好的workshop有很多不错的分析文章）、&lt;b&gt;SCAM&lt;/b&gt;、&lt;b&gt;SAC&lt;/b&gt;的&lt;b&gt;PL track&lt;/b&gt;（SAC的老牌高质track）等。&lt;/p&gt;&lt;p&gt;最后提一下PL的期刊&lt;b&gt;TOPLAS&lt;/b&gt;，公认为PL最好的期刊，挺难投的（一年貌似就十几篇），它的submission来源主要集中在PL的四大顶会（一般是把会议文章内容扩展30%左右）。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;编程语言都研究些什么&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;PL学科庞大，结构复杂，让我这么个搞PL分析的说清楚整个PL都在研究什么是不可能的（估计这辈子都说不清楚）。但是简介一下概貌还是可以的。我觉得按照如下三个方面对PL的研究进行分类是相对容易理解的。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;纯PL&lt;/b&gt;，即关于PL本身的设计。例如，&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;语言设计和拓展 （language designs and extensions）&lt;/li&gt;&lt;li&gt;类型系统 （type systems）&lt;/li&gt;&lt;li&gt;语言语义和程序逻辑 （language semantics and program logics）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;2. &lt;b&gt;PL支持环境&lt;/b&gt;，即支撑PL的编译和运行系统。例如，&lt;/p&gt;&lt;ul&gt;&lt;li&gt;编译器技术 （optimization, transformation等）&lt;/li&gt;&lt;li&gt;运行时技术（virtual machine, garbage collection等）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;3. &lt;b&gt;PL应用&lt;/b&gt;，即利用PL的语法语义等知识对PL编写的程序展开的一系列应用。例如，&lt;/p&gt;&lt;ul&gt;&lt;li&gt;程序分析（program analysis）&lt;/li&gt;&lt;li&gt;程序验证（program verification）&lt;/li&gt;&lt;li&gt;程序合成（program synthesis）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上述分类只是一个框架，实际上并没有展开，因为它很难展开，太庞杂了。例如，纯PL中的第一条“语言设计和拓展”，就这一点就有各种编程范式，比如，object-oriented, functional, logic, constraint, domain-specific, asynchronized programming等等。因此针对PL的研究内容我就止步于此，大家有一个大致了解就好。&lt;/p&gt;&lt;p&gt;下面我针对上述各PL分类方向的研究现状做一个简单的总结。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1. &lt;/b&gt;纯PL的研究相比于十年前已经安静很多了，但是大家也不要低估研究纯PL的这些人的数量，他们大多分布在世界顶级大学和软件公司，如今各种纯PL技术仍活跃在各大PL舞台，主要是POPL，ECOOP，ICFP和ESOP，PLDI和OOPSLA也有一些。我个人认为纯PL圈子的人有如当年占据计算机领域金字塔尖的那些搞算法、逻辑、复杂性的研究者们，虽然如今力量日渐消退，但我依然认为他们是引领PL乃至软件领域发展的一股中坚力量，值得尊敬。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. &lt;/b&gt;PL支持环境实际上和编译领域、系统领域甚至体系结构都有一些关系。由于上层编程语言本身就是各种类型，那么支持它们的编译和运行时技术更是种类繁多，层出不穷。就凭当今主流的那些编程语言，也可以让这个方向的研究一直持续下去，毕竟使用它们的金主们（各大软件公司）为了它们编写的程序有更好的可靠性和性能也会给这股研究力量多多支持的。此外还有各种编译和系统方面交叉人才的加持，我相信这个方向还会有很多实用的技术被创造出来。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.&lt;/b&gt; PL应用举的这三个例子，如今在PL的热度是一年比一年高，主要原因是如今的软件越来越复杂了，对于可靠性、安全性、性能和编写效率都有新的要求，提出了新的挑战，有很多实际且有趣的问题亟待解决，甚至这些技术的展开和探讨对于编程语言的设计也会有很大的影响。如果你是一个research新人，对PL有点兴趣但不知道研究什么好，我建议你入PL应用的坑，因为我认为它至少在未来五年依然会是一个很活跃的研究方向（原因如上所述）。&lt;/p&gt;&lt;p&gt;接下来，我们来聊聊PL应用中最庞大、最火热的分支之一，程序分析。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;程序分析 &lt;/b&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;程序分析的重要性&lt;/b&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;学术界&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;程序分析可以看成是一个交叉的研究方向，因为你会在PL以外的其它不同计算机领域的会议上看到程序分析的topic。例如，软件工程如FSE, ICSE, ISSTA, ASE等；系统领域如 OSDI, SOSP, ASPLOS, EuroSys, ATC等；安全领域如Oakland, CCS, NDSS, Usenix Security等等。造成这种交叉性质的原因不难理解：程序分析是一种方法技术，目的是分析出程序在可靠性、安全性、性能等各种方面的表现和问题，而各领域的程序都是用编程语言写的，且都或多或少地有上述方面的分析需求，因此不同领域对于程序分析的广泛兴趣便不足为奇。尤其是近些年，程序分析在上述很多会议的Call For Papers里都会被单独列为一项愿意接收的topic，比较火热。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;企业界&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;程序分析不只在学术界占有重要席位，近些年来也越来越受到企业界的青睐，原因我在之前简单提到过，因为当今的软件越来越复杂，在可靠性、安全性、性能等方面提出了新的要求和挑战，这些都是传统技术（如软件测试等）很难驾驭的。据我所知，国际知名的大公司都有专门的程序分析研究或开发组，例如Microsoft，Google，Oracle，Apple，IBM，Facebook、Uber、华为等等。随着人们逐渐意识到程序分析的重要性，专门研发程序分析技术的公司也越来越多，例如Coverity（被收购），GrammaTech，Semmle，SourceBrella（源伞）等。&lt;/p&gt;&lt;p&gt;如上所述，程序分析无论在学术界还是工业界都扮演着重要的角色。程序分析如此重要，它到底是个啥呢？接下来，我们来简单看看什么是程序分析。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;2. &lt;b&gt;什么是程序分析&lt;/b&gt;&lt;/p&gt;&lt;p&gt;程序分析虽有静态动态之分，但从PL的角度我们一般关注的是&lt;b&gt;静态分析&lt;/b&gt;（static analysis）。简单说来，静态分析要回答的问题是&lt;/p&gt;&lt;blockquote&gt;我想知道在任何输入下，整个程序或程序的某一点是否能满足某种条件或特性？&lt;/blockquote&gt;&lt;p&gt;但是，程序的输入可以无穷无尽，程序到达某一点的路径可以根据输入变化莫测、不胜枚举，如何将所有情况都考虑周全最后得出一个正确的（sound）结论呢？为此，我觉得静态分析技术的核心可以围绕两个关键字展开：Abstraction和Over-approximation。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Abstraction&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;程序在动态执行时，有各种不同类型的动态值，例如int类型的 1, -2, 350，String类型的 “a”, &quot;007&quot;, &quot;Hello&quot; 还有各种referenced的concrete object（比如你在一个死循环里放一句new A()你想想运行时会有无数个A类型的concrete object被生成直到吃满你的内存），如果你想用有限的内存资源来分析这些无限的动态值，你首先需要把它们抽象起来，即Abstraction。例如只有一个int类型的抽象值（或一个整数int、一个负数int、一个0，共三个抽象值），一个类型的String值，一个new A()语句只生成一个抽象的对象，即（和上面concrete object对应的）abstract object。怎么抽象是可以调节的，抽象方式不同，静态分析的精度和速度便会不同。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Over-approximation&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;程序在动态执行时，根据输入的不同，可能会走各种不同的路径，随着程序规模和复杂度的增加，这些路径也会无穷无尽，最终不能用有限的空间来枚举每条可能的动态路径下的不同值（路径爆炸），进而也无法知道程序的某一点的值是否还满足某些条件。为了用有限的空间和时间来“枚举”无限路径下的各种可能值，我们需要保守近似over-approximation。如下所示&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;if (e) x = 1 
else x = 0 
@Label A&lt;/code&gt;&lt;p&gt;假设我们想知道程序Label A这一点x的值是什么？想象一下如果我们可以枚举路径，我们可以得到很精确的答案，即在e == true时x = 1 （路径1）；在 e == false时x = 0 （路径2）。然而如果程序很大且复杂，我们没法枚举每一条路径（路径爆炸）下的值。over-approximation是在某些程序位置或区域保守地近似不同执行路径（executions）下的值。如在Label A，我们可以说无论走哪条路，x要么是1要么是0。这是sound（safe）的结论，尽管不精确，但是如果x只要不是负数就可以做某种优化，那么这样的结论就是有用的。对不同路径抽象的粒度是可以调节的，粒度不同（如context, flow, path-sensitivity），静态分析的精度和速度也会不同。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;实际上真正的静态分析要复杂的多，因为它要针对不同编程语言不同语法下的不同语义来合理的抽象近似程序在每一个语句下的动态运行结果（可以想象成静态地抽象一个解释器）。因此静态分析是和编程语言紧密相关的（需要深入准确地了解语言的语法和语义）。如此，我再说&lt;b&gt;程序分析（静态分析）实际上是偏PL的研究方向&lt;/b&gt;你就更容易理解了。&lt;/p&gt;&lt;p&gt;如今，软件工程、系统和安全方向的很多程序分析都是利用基础的静态分析技术和结果，结合程序和问题的特点，进行更high-level的分析，比如查到更有趣的bug和安全漏洞，或更好的帮助优化或理解程序等等。既然基础静态分析和PL联系的这么紧密且如此重要，我觉得有必要再深入地了解一下它。接下来，我要介绍基础静态分析中最核心、最重要的一个分支（之一），也是大家经常在各种程序分析论文和程序分析工具的代码、文档和注释中看到的指针分析（pointer analysis），又名指向分析（points-to analysis）或别名分析（alias analysis）。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;指针分析/指向分析/别名分析（Pointer/Points-To/Alias Analysis）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;提到静态分析，都应该听说过指针分析，这个奇葩研究方向居然延续了近40年而且长盛不衰，至今仍活跃在各大PL相关会议当中。原因很简单，它太重要了。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;什么是指针分析&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;指针分析并不是“分析指针”，如果不好理解，你可以用它的另一个名字“指向分析”来记，顾名思义，给定程序的任何变量或引用p，指向分析在compile-time（静态）回答p都可能指向哪些值（实际上也是回答静态分析的问题）。既然知道了p1和p2都指向什么，如果p1和p2的指向有交集，就说p1和p2互相alias（alias对很多sound的分析是必须的），因此指向分析也叫别名分析即alisas analysis。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;指针分析的重要性&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为什么指针分析如此重要？就像几乎所有指针分析论文中描述的那样，指针分析可以认为几乎是所有静态分析的基础，因为它可以被用来构建全局的程序控制流（Interprocedural control flow graph, ICFG）和方法调用图（call graph），且所有全局的程序静态分析都需要这些基本结构，与指针分析提供的指向信息和别名信息来构建自己更high-level的静态分析。&lt;/p&gt;&lt;p&gt;我上面提到的那些大的软件公司尤其是IBM、Oracle等都有自己专门的指针分析的团队（ &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/487163f4982c221d9e7b085a7c59cd46&quot; data-hash=&quot;487163f4982c221d9e7b085a7c59cd46&quot; data-hovercard=&quot;p$b$487163f4982c221d9e7b085a7c59cd46&quot;&gt;@TwoFrogs&lt;/a&gt; 的源伞公司也是研发指针分析的，国内首屈一指），很多程序分析的开源或商业框架也都是用指针分析搭建起来的。40年来各种PL相关会议上的指针分析论文层出不穷。近十多年来，指针分析的重点也逐渐从以前的C语言侧重到面向对象语言（这个不难理解，毕竟如今的应用软件的主流语言是面向对象），占据了近些年来各大PL相关top会议指针分析topic的更多席位。&lt;/p&gt;&lt;p&gt;既然面向对象（OO）指针分析（主要是Java）在近些年相对更受关注，接下来我们就简单聊聊它的发展进程，我觉得下面的梳理对想入坑或感兴趣的同学会有所帮助。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;OO指针分析的过去和现在&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;OO的指针分析一般以Java为主，现在的很多Android的静态分析技术和工具也都是基于Java指针分析的。接下来，我通过几个关键人物和他们开发的关键技术或工具来帮助梳理Java指针分析的研究进程。故事从枫叶国说起：&lt;/p&gt;&lt;blockquote&gt;加拿大麦吉尔大学的Laurie Hendren教授（早期指针分析领军人物之一）的研究组在1999年以论文的形式发表了Soot，Soot直到今天仍是最流行的针对Java的静态分析器。&lt;br&gt;&lt;br&gt;在2003年，Laurie的学生Ondřej Lhoták在Soot上开发了指针分析Spark，影响力很大。Ondřej Lhoták从2003后继续发力，一直在指针分析的topic发表文章，例如用BDD来实现指针分析，强调context-sensitivity对于Java的重要性等等。Ondřej 现在是加拿大滑铁卢大学的副教授，可以说他是Java指针分析的最核心人物之一。&lt;br&gt;&lt;br&gt;Laurie的另一个学生Eric Bodden（现德国Paderborn大学教授）从大概2012年接管了Soot，并在其上增加了IFDS的实现框架，在近些年开展了一系列针对Java的demand-driven指针分析的研究（注：Eric在分析程序安全性上有一些知名的工作，比如针对Android的taint analysis框架FlowDroid）。&lt;/blockquote&gt;&lt;p&gt;在2009年之前，还有几个人需要提及。&lt;/p&gt;&lt;blockquote&gt;首先是Ana Milonova（现美国伦斯勒理工学院副教授）。Ana是Barbara G. Ryder（早期指针分析的领军人物之一，现弗吉尼亚理工教授）的学生。Ana在2002年提出了object-sensitivity并验证用它作为Java的context会带来更好的分析精度甚至速度。这就打破了一直以来从C语言静态分析那里继承而来的基于callsite的context-sensitivity的局面。这个工作在业内影响力很大，四大Java指针分析框架Doop，Wala，Soot，Chord都有object-sensitivity的实现，因为它是Java指针分析精度提升的必备技术。&lt;br&gt;&lt;br&gt;其次是Mayur Naik（现宾夕法尼亚大学副教授）。Mayur是Alex Aiken（早期的指针/程序分析的重要人物之一，现斯坦福大学教授）的学生，他2006年发表了Chord，起初Chord是为了静态检测Java程序的data race写的，而他检测data race的核心技术就是依赖指针分析，因为Chord本身实现了不同种指针分析算法，如今被认为是Java指针分析的四大框架之一。实际上，Mayur的Chord是基于John Whaley的BDDBDDB框架写的 ，BDDBDDB是2004年发表于PLDI的指针分析工作。John是斯坦福大学Monica S. Lam教授（编译龙书的作者之一，最新版龙书关于静态分析那部分就是Monica写的，她也是早期指针分析的重要人物之一）的学生，John和Monica在90年代末期也做了一系列指针分析工作。但是John最后自己创业，分析工作没有延续。&lt;br&gt;&lt;br&gt;再者是Manu Sridharan（现Uber静态分析团队的leader），他在加州伯克利读博士期间，于2005和2006两年连续发表了针对Java的demand-driven指针分析的工作，业内影响力较大，后续很多demand-driven指针分析工作都受此影响。Manu毕业后去了IBM T. J. Watson研究中心，参与了另一个知名Java指针分析框架Wala的开发，实际上之前IBM的研究人员已经开始了指针分析的研究和Wala的实现。&lt;/blockquote&gt;&lt;p&gt;2009年后Java的指针分析主要有以下几个国际团队在做，&lt;/p&gt;&lt;blockquote&gt;希腊雅典大学的Yannis Smaragdakis教授，&lt;br&gt;澳洲新南威尔士大学的Jingling Xue教授，&lt;br&gt;韩国高丽大学的Hakjoo Oh教授，&lt;br&gt;德国Paderborn大学的Eric Bodden教授，&lt;br&gt;香港科技大学的Charles Zhang教授，&lt;br&gt;澳洲悉尼大学的Bernhard Scholz教授和与其合作的Oracle Lab的程序分析团队，&lt;br&gt;美国宾西法尼亚大学的Mayur Naik教授，&lt;br&gt;加拿大滑铁卢大学的Ondřej Lhoták教授。&lt;/blockquote&gt;&lt;p&gt;注：值得一提的是，以上除了Bodden和Naik教授的团队，其余几个团队也做过或正在做C/C++的指针分析。实际上在我们国内也有做过C/C++的指针分析团队，那就是中科院计算所的冯晓兵教授和李炼研究员。关于C/C++的指针分析如果大家感兴趣可以访问以上几个团队的主页，外加UCSB的Ben Hardekopf教授和印度理工的Uday Khedker教授。&lt;/p&gt;&lt;p&gt;2009年后，Java（或OO）指针分析领域的最核心人物当属雅典大学的Yannis Smaragdakis教授，接下来我们简单了解一下他的工作。&lt;/p&gt;&lt;blockquote&gt;Yannis Smaragdakis教授原来是美国佐治亚理工和马萨诸塞大学的教授，后来在2011年左右回到了希腊的雅典大学任教。他2009年在OOPSLA发表了当今最先进的Java指针分析器Doop，然后持续地在各PL顶级会议POPL，PLDI，OOPSLA，ECOOP发表大量的指针分析文章。我个人认为目前为止Yannis对指针分析最大的贡献有两个，一个就是Doop这个指针分析器本身，另一个是于2011年在POPL发表的一篇文章。这篇文章从新精确地解释了Ana Milanova在2002年提出的object-sensitivity的定义，以消除从02年到11年期间关于object-sensitivity的有分歧的理解：即当context层数大于一层时应该用哪些object来做context。此外这篇文章又提出了一种新的context技术叫type-sensitivity（精度比object-sensitivity稍差但是速度快很多），这对于大程序分析不scalable的问题起到了很好的缓解作用。&lt;/blockquote&gt;&lt;p&gt;2016年以后到今天，Java指针分析的关键人物是我们的一位知友Tian Tan &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/f87c102df451bc1ec42085ea759c82fb&quot; data-hash=&quot;f87c102df451bc1ec42085ea759c82fb&quot; data-hovercard=&quot;p$b$f87c102df451bc1ec42085ea759c82fb&quot;&gt;@甜品专家&lt;/a&gt; （新南威尔士大学Jingling Xue教授的博士，现在是丹麦Aarhus大学Anders Møller教授的博士后）。&lt;/p&gt;&lt;blockquote&gt;Tian在2016发表于SAS的工作改变了20多年来context-sensitivity一直使用连续context元素的局面，巧妙地避开了对分析精度没有用却又影响分析速度的context元素。据我所知，上面提到的Ondřej Lhoták，Yannis Smaragdakis还有Mayur Naik教授在不同场合都对这项工作有很高的评价，此外，上面提到的Hakjoo Oh教授团队在今年的OOPSLA，就是用机器学习的方法尝试了Tian的这个工作。Tian从2017年开始又陆续在PLDI、OOPSLA和FSE等顶会发表了针对Java的一系列指针分析工作，感兴趣的同学可以去他主页看看。&lt;/blockquote&gt;&lt;p&gt;关于Java的指针分析我就说这么多，接下来简单提及一下另一个OO语言JavaScript的指针分析研究团队。值得注意的是，国际上有很多团队做JavaScript的程序分析，但是做JS指针分析这种很基础的并不多。主要有以下几个团队：&lt;/p&gt;&lt;blockquote&gt;丹麦Aarhus大学的Anders Møller教授&lt;br&gt;韩国KAIST的Sukyoung Ryu教授&lt;br&gt;IBM Watson研究中心的Wala分析团队&lt;br&gt;英国帝国理工学院的Benjamin Livshits教授&lt;br&gt;美国弗吉尼亚理工的Barbara G. Ryder教授（不活跃状态）&lt;br&gt;美国加州圣芭芭拉大学的Ben Hardekopf教授（不活跃状态）&lt;/blockquote&gt;&lt;p&gt;在这里我就不对JS的指针分析展开了（它主要的一些技术还是来源于Java的指针分析，但是JS的一些神烦的特性还是让搞JS指针分析的人吃了不少苦），有兴趣的同学可以访问上述团队的主页。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这篇文章从介绍PL会议入手，简单描述了哪些人是从事PL研究的，他们都研究些什么，这些研究的现状怎样。接着，介绍了PL研究的一个重要分支——（基础）程序分析，包括什么是程序分析（主要是静态分析）以及为什么程序分析在今天越来越重要。最后，介绍了程序分析中最核心、最重要的技术（之一）—— 指针分析，包括指针分析的概念、重要性以及它发展的过去和现在。希望这篇科普性的文章让你对PL的研究和程序分析技术都能有所了解。&lt;/p&gt;&lt;p&gt;过去的50多年里，针对PL的research从来没有间断过，也一直保持着生命力，它成就了如今软件的琳琅满目，也影响着未来软件的生产力和创新力。作为信息时代崛起的大国，不应该在如此重要的研究领域掉队，衷心期待我国编程语言领域科研的进步。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;后记&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;终于完成了这两篇关于PL的文章，一篇问教育，一篇道科研。世界上有那么多研究领域，多到你只要能看到这两篇文章，你就已经和PL有着难得的缘分了。无论你是想做一名出色的程序员，还是想成为一名优秀的PL方向的researcher，你都为这份缘分续上了契约，我也和你一样，一直走在履行约定的路上，虽然道阻且长，却也一路风光（太 文 艺 了，对 不 住 了 ）。那么，同道中人，一起加油吧！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;最后，感谢 &lt;a href=&quot;https://zhuanlan.zhihu.com/marisa&quot;&gt;雾雨魔法店&lt;/a&gt; 和店里热爱PL的小伙伴们，非常感谢邀请我来写文章 (((┏(;￣▽￣)┛&lt;/p&gt;&lt;p&gt;祝大家国庆快乐！&lt;/p&gt;</description>
<author>啥玩应啊</author>
<guid isPermaLink="false">2018-10-01-45208498</guid>
<pubDate>Mon, 01 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>浅谈国内高校编程语言教育</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-09-28-43914842.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43914842&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f40e47a835c6d5972970334e11e3f0a1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;开篇&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在知乎上活跃着、潜水着很大一批程序员，有的出于对编程的热爱不断磨练提升自己的编程阶位，有的迫于自身的能力和工作的需要不得不强迫自己加班补课不能掉队，有的一直努力着试图在高薪和兴趣之间牵上一条能够说服自己的线。他们大多低调勤奋，每天在跟代码死磕，拿着相对称心工资的同时也为加班压力烦心无奈，更多的幸福也许来自于每每调试成功或完成任务那一刻的暗自欣喜，悄悄地告诉自己“我还不赖”，默默地激励自己“我可以更好”。这篇文章就是为了这些简单的人——如今和未来的“程序员”们。&lt;/p&gt;&lt;p&gt;我觉得在正文之前，有必要先简单自我介绍一下，以防下面的内容没人看，觉得我在瞎扯（那我就白写了啊(&amp;gt;﹏&amp;lt;)）。我叫啥玩应儿，一个普普通通的海外博士+博后，在编程语言（PL）领域（更细化一点是编程语言的程序分析方向）做过一些微小的工作。这篇文章我用心准备了很多天，因为它有着比较“神圣”的写作动机。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;动机&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;此文的写作动机主要来源于两股力量的碰撞：惋惜和鼓舞。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;惋惜&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我发现在知乎上很多科班出身的计算机或软件专业的大学生对于一些基础的编程语言问题比如“什么是解释器”，“什么是编程语言的语义”，“什么是函数式编程”，“为什么语言会有静态和动态类型”等等很多基础知识并不清楚（更不要提诸如“所有编程语言的核是什么”，“它们如何被一些基本的语言特性组成搭建最终形成自己的语言生态”等更进一步的知识），更令人不安的是很多人认为“我不了解它们并不影响我编程，所以不知道也无所谓”。&lt;/p&gt;&lt;p&gt;想到这里，我的脑海中立刻浮现出我人生中的第一门编程语言课（C语言）当时全国通用的清华大学谭浩强的绿皮《C程序设计》教材，和老师课上不断强调的“变量使用前应该声明”，“循环数组不能越界”，“printf的参数有哪些”.....之后又学了一些编程语言课（Java面向对象编程设计，C++等）。然而一路下来，对于编程语言的理解依然停留在我了解这个语言的语法，熟悉它的开发环境，知道怎么查文档和API使用，也知道怎么用它和一些相关的framework或library完成一些实际的编程任务，然后（心虚地）在简历上写道熟悉某某编程语言。&lt;/p&gt;&lt;p&gt;如今想来，这么多学生不喜欢编程，感觉它难且太复杂，枯燥无味却又不得不死记硬啃，写了那么多代码和作业却依旧感觉距离理解编程语言相距甚远。这哪里是学生的错？在这个年代还拿C语言作为入门编程语言（这本身就是“误国误民”！！！）且一味讲解这些语言的语法细节和如何使用它们实现数据结构和算法，这如何让学生真正地理解编程语言并提起兴趣？我为这么多本可以更喜欢编程的学生和本可以更热衷自己编程工作的程序员感到惋惜甚至不平。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;鼓舞&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我在知乎上同时又发现以 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/227135f01257c4d6bdb21a726ef6d53a&quot; data-hash=&quot;227135f01257c4d6bdb21a726ef6d53a&quot; data-hovercard=&quot;p$b$227135f01257c4d6bdb21a726ef6d53a&quot;&gt;@rainoftime&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/2d8f51b6523e01a8529606f466d98198&quot; data-hash=&quot;2d8f51b6523e01a8529606f466d98198&quot; data-hovercard=&quot;p$b$2d8f51b6523e01a8529606f466d98198&quot;&gt;@Felis sapiens&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0251012c87c2d3f56ac34de7d71cdcbc&quot; data-hash=&quot;0251012c87c2d3f56ac34de7d71cdcbc&quot; data-hovercard=&quot;p$b$0251012c87c2d3f56ac34de7d71cdcbc&quot;&gt;@圆角骑士魔理沙&lt;/a&gt; 等为代表的另一波人。他们是纯粹的编程语言爱好者，经常分享着编程语言很多有趣且有用的知识（据说他们这些志同道合的小伙伴私底下也有编程语言交流群分享知识）。我觉得他们很厉害（也很羡慕，因为他们讨论的很多有用的东西我都不懂甚至之前都没听说过，惭愧惭愧(*+﹏+*)），同时也感受到他们对于自己喜欢的东西的那种难得的专注和纯粹。&lt;/p&gt;&lt;p&gt;这些对兴趣的专注和纯粹本应该是大学生在自己专业上该有的年轻的、百舸争流的样貌，如今却被年薪、房价和社会的物化价值观所左右。如果连我们国家顶尖大学的教育都摆脱不了物欲横流的浮躁，又如何完成国家民族集体人格的进一步塑造？在这种背景下，知乎上的这些编程语言爱好者们的所为有如夏日之凉风，让我意识到咱们国家始终有一群爱学习、爱思考、忠于兴趣的学生。他们的存在激励着我说出今天想说的话，希望让更少的学生被惋惜，让更多的学生受鼓舞。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;为什么编程语言教育在我国不受重视？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如今计算机行业日新月异，随着计算能力的不断提升和信息智能化在各行业的大量普及（当然还有一些大公司在背后搞事情），香饽饽领域如“人工智能”“大数据”等受到了前所未有的瞩目。加之我国现今正在产业升级当中，想要利用国内巨大市场和国人对于新鲜事物特有的包容心态等在所谓“工业革命4.0”的历史进程中弯道超车，把“人工智能”“大数据”“物联网”等计算机&lt;b&gt;应用&lt;/b&gt;学科列为了国家战略规划项目。&lt;/p&gt;&lt;p&gt;这些行业的从业人员也没有让大家失望，很多智能应用确实很大程度上改善了人们的生活体验（我回国手机刷个小黄车都兴奋不已(ｏ￣∇￣)见笑）。然而如此一来，计算机应用学科强大的优势便更容易让人们忽视对计算机基础学科的关注和发展（本来基础学科因为其回报不能被立即“看到”而已经受到了一定的忽视）。这其中最重要的计算机基础学科之一，也是在我国一直被忽视的学科，就是编程语言。&lt;/p&gt;&lt;p&gt;如果说硬件的核心是芯片，软件的核心便是编程语言。前一阵子中兴芯片事件闹得沸沸扬扬，当时我看到报道后既气愤又无奈。其实多少了解到咱们国家对芯片的研究是有投入的，然而由于芯片行业本身研究成本极高且要和各种国际上更重视更有钱的公司机构竞争，创新成本太大。可是编程语言作为软件的重要核心，研究成本照比硬件几乎为零，在我国却一直不被重视，因为很多人对编程语言学科抱有一种误解的态度：&lt;/p&gt;&lt;blockquote&gt;“通用的编程语言全世界就那么几个，该有的都有了，我也会用，有啥可研究的？总不会让我再去设计一个新的编程语言吧？那有啥用？而且也没人用啊！”&lt;/blockquote&gt;&lt;p&gt;如此，编程语言学科的研究很容易受到轻视，研究受到轻视导致了这门学科人才的缺失，&lt;b&gt;Label A&lt;/b&gt;:  人才缺失意味着没有足够专业的人来为其重要性发声（编程语言学科的人才本来就不多），又因为其作为基础学科发展效果不会像应用学科“立竿见影”，国家高等教育决策层便无法主动意识到发展它的必要，因此从决策层便不会发展这一学科并重视、引进相关人才, &lt;b&gt;goto Label A&lt;/b&gt;。无从责备啊╮(╯▽╰)╭&lt;/p&gt;&lt;p&gt;此外，由于编程语言是一门结构性很强、在国外发展了近60年如今仍旧活跃的重要计算机学科，因此绝对不是只要会编程、有博士学位和相关计算机或软件工程背景的人（如懂操作系统、体系结构、数据结构和算法、计算机网络啥的(-ι_- )很熟悉吧）就能教好其课程的专业。如此一来，我们国家缺乏编程语言方向相关的人才，势必造成今天国内高校编程语言教育落后的局面。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;重视编程语言教育真的很重要吗？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;“在X年内，进入世界知名大学行列；在X+Y年内，冲入世界一流大学行列”，这是近几年国内很多高校的通用口号模板。然而我们再来看看真正世界的“知名”“一流”大学（例如Top 100，包括MIT、Stanford、UC Berkeley、CMU、Cornell、UPenn、UW、Harvard、ETH、Oxford、Cambridge等太多名校），你会发现它们之中但凡有点规模的计算机院系，几乎都有编程语言（programmming languages）方向的教授或研究人员，而且往往排名越靠前的大学越重视编程语言，相关科研人员也越多，编程语言课程都是由这些专业人才讲授的。&lt;/p&gt;&lt;p&gt;反之，我国&lt;b&gt;绝大多数&lt;/b&gt;985、211高校无论计算机学院还是软件学院，编程语言方向居然没有全职教授（&lt;b&gt;几乎&lt;/b&gt;是南京大学冯新宇教授一个人为我国大陆高校计算机编程语言方向撑着场面，从顶会论文数量看）。此外，我国计算机学会有那么多计算机方向的专委，就是没有编程语言专委（注，形式化方法专委和软件工程专委根本无法取代编程语言专委，反之亦然）。&lt;/p&gt;&lt;p&gt;这一对比应该很说明问题了：不是我们有问题，就是我们学习的那些世界一流大学有问题。然而我前面也解释过了，于我而言，我国编程语言教育的落后和人才的缺失是个无从责备的问题；换言之，我相信如果咱们高校或教育决策层的领导意识到了这个问题的重要性，是有动力和能力解决它的（毕竟干实事为学生想的领导还是有的）。&lt;/p&gt;&lt;p&gt;刚刚，世界名校们用它们强大的编程语言教授阵容向我们客观地展示了编程语言教育的重要性。接下来，我想从个人和社会两个层面主观地谈谈提高编程语言教育质量的好处。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1. 个人&lt;/b&gt;&lt;/p&gt;&lt;p&gt;编程语言虽然复杂，但是其设计是遵循着一些基本规则的。不同语言的语法语义虽然有所不同，但一些基本的核是相似的（例如基于表达式扩展的语法和对基本数据类型的抽象），编程语言可以顺着这些核一点点展开，根据语言设计的初衷选择合适的编程范式（例如命令式还是函数式还是都要）进而对核进行相应的调整（例如函数本身是不是个基本数据类型），一点点添加需要的规则（例如什么样的scoping，什么样的类型系统）和特性（例如是否支持多线程，支持异步），这些规则特性与编程语言之核的组合，造就了今天编程语言的琳琅满目。&lt;/p&gt;&lt;p&gt;然而，我们如今绝大多数国内的教育不解释这些基本原理和它们与编程语言的本质关系，学生对编程语言缺乏一种抓得住的“全局观”和举一反三的能力，看到的都是被“糖化”后的语法和复杂的语用环境，所以感到语言太复杂、枯燥。如此一来，以下情形便容易解释了。例如，&lt;/p&gt;&lt;ul&gt;&lt;li&gt;你经常对编译器和解释器报出的错毫无头绪；&lt;/li&gt;&lt;li&gt;你无法理解为什么一些framework或library的用法是这样那样的，因此你只能靠着例子和pattern来编程，对于背后被封装和使用的原理一无所知，进而导致了一旦有问题自己便推不出原因，只能找google或有求于同事；&lt;/li&gt;&lt;li&gt;你对于大的任务该用什么样的编程语言或怎样使用其特性无法做出独立的思考，天经地义地觉得这是leader该管的事；&lt;/li&gt;&lt;li&gt;还有太多太多心有余力不足的情况。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因此，对于个人，受到更好的编程语言教育意味着可以更好的理解从语言本身到构建出的复杂软件系统，对于问题的“势”和通过编程手段解决问题的“器”也都会有更好的把握。&lt;/p&gt;&lt;p&gt;编程语言的教育好比是为了构建出每个人编程知识树的主干（这种结构性很强的知识体系是很难通过经验自我摸索的），每遇到新的问题都可以用已有的编程语言知识消化吸收（或在此基础上通过查找资料更容易对其理解），进而每一步编程经历的积累都是给自己的知识树添枝增叶，日积月累，你的程序可以不知觉地写的更快，更简洁易懂，更少错，更安全，也会更容易学习理解新的编程语言和软件框架。&lt;/p&gt;&lt;p&gt;更重要的是其可以帮助个人对编程语言产生更浓厚的兴趣，这对于程序员健康心态的调整很重要：没有兴趣，迫于生活压力各种收罗经验编织履历向别人证明你已走多远；有了兴趣一路打怪升级顺便带带小弟时刻提醒自己还差多远但一切却又怡然自得，事业幸福感油然而生，生活幸福感便交相辉映。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. 社会&lt;/b&gt;&lt;/p&gt;&lt;p&gt;随着社会对于信息化的不断依赖，软件势必走向复杂化，进而对于软件可靠性、高效性、安全性等都提出了新的挑战。这意味着日后对于程序员个人编程能力和素质都会有更高的要求（我后面会在应该如何讲授编程语言课程中简单提到几点）。因此，我国高校在培养软件人才方面应当应势所驱，重视编程语言的教育进而提高未来程序员编程素质、基本功和对待编程的兴趣，这对于整体提高处于信息化中的社会生产力是大有裨益的。随之而来的是软实力的质变，并一定会同时酝酿新技术的革新，因为基数和兴趣都得到提升，概率便不会让创造力失望。&lt;/p&gt;&lt;p&gt;简而言之，更好的编程语言教育可以切实地提高软件生产力，同时培育创新的沃土。例如，在大数据和智能计算的驱动下，很多行业都会利用自己领域内的数据进行一番智能变革（如医疗、城市建设、特种装备等），这给很多软件创新带来新的机遇，我们的程序员应该有能力有信心意识到，他们自己是可以创造或调制适合该行业领域应用的专属编程语言（如DSL），使得行业专家也可以很方便的使用语言编程，满足各种特定的可靠性、性能甚至知识产权等需求。这给新兴软件应用行业的创新提供了丰厚的技术资本，这些应用行业本身又会刺激市场，对计算机行业创新带来新的需求和机遇。&lt;/p&gt;&lt;p&gt;综上所述，重视并提高编程语言教育质量对个人和社会的发展都是大有裨益的。但是如何提高编程语言教育质量呢？最直接有效的方法就是讲授好编程语言课程。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;应该如何讲授编程语言课程？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这是一个引火烧身的问题啊。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先，这个问题没有正确答案，我相信每个人心中都有自己的看法。&lt;/li&gt;&lt;li&gt;其次，我对编程语言的理解和知识的掌握十分有限，我觉得知乎上很多编程语言爱好者还有很多有长时间编程经验的程序员都比我更懂编程语言（更不要提 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/a06cfb38e37dac1658e6457df4d7f032&quot; data-hash=&quot;a06cfb38e37dac1658e6457df4d7f032&quot; data-hovercard=&quot;p$b$a06cfb38e37dac1658e6457df4d7f032&quot;&gt;@RednaxelaFX&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/487163f4982c221d9e7b085a7c59cd46&quot; data-hash=&quot;487163f4982c221d9e7b085a7c59cd46&quot; data-hovercard=&quot;p$b$487163f4982c221d9e7b085a7c59cd46&quot;&gt;@TwoFrogs&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0970f947b898ecc0ec035f9126dd4e08&quot; data-hash=&quot;0970f947b898ecc0ec035f9126dd4e08&quot; data-hovercard=&quot;p$b$0970f947b898ecc0ec035f9126dd4e08&quot;&gt;@vczh&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/745f68a74a02e49711cc097e1855b1e1&quot; data-hash=&quot;745f68a74a02e49711cc097e1855b1e1&quot; data-hovercard=&quot;p$b$745f68a74a02e49711cc097e1855b1e1&quot;&gt;@蓝色&lt;/a&gt; 等这些大牛）。&lt;/li&gt;&lt;li&gt;再次，我本身没有专业的授课经验（只有tutor和偶尔的guest lecturer这种简单的经历），很难切身体会到那种潜在的“知识输出”和学生“知识接收”不对称的问题，但是我也相信，老师是可以通过自己的努力来尽量减小这种不对称的（我不是站着说话腰不疼，因为我以后也是要当老师的，我觉得我愿意在科研压力之外给自己这样的要求，我觉得这是为师者的本分）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以上一番自我觉悟后，我仍想通过结合国内高校编程语言教育的一些实际情况，简单阐述一下关于“应该如何讲授编程语言课程”的几点&lt;b&gt;个人看法&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1. 脉络和整体的把握  &lt;/b&gt;&lt;/p&gt;&lt;p&gt;一个比较好的编程语言课程的脉络可以是从简入深地“成长”一个编程语言。这个“成长”不是基于具体语言的语法和特征的（比如Java的基本数据类型，运算符，变量声明长啥样），而是基于语言的基本概念的。换言之，上一门真正意义的编程语言课（尽管这门课指定了一门需要掌握的具体编程语言），应该主要是为了学习隐藏在这门具体语言背后的、支撑它的编程语言理论知识，而这门具体的语言（它的语法、语义、语用等）是为了理解这些编程语言知识的。&lt;/p&gt;&lt;p&gt;例如，编程语言可以从数据抽象开始，通过表达式（expression）表达基本的“逻辑”和“运算”，引入条件和循环对其“控制”，引入函数对其“封装”，函数的封装需要scoping，函数的调用需要context等概念来支撑；再high-level一点，imperative语言抽象数据，用变量绑定，用状态存储；functional语言既抽象数据又抽象行为，因此可以通过表达式传递“计算”，可以无需状态存储；再high-level一点，object-oriented语言有了状态和行为的统一封装，引入了类和继承等基本概念，而后者又需要overwritten，field hidden等概念支撑等等等等。如此一来，在一点点“成长”讲解这些编程语言知识的同时，用特定的语言的语法、语义来具体解释这些概念和知识。如此，不但能更深刻地掌握一门具体的编程语言，也能帮助了解编程语言设计的整体和核心，这是举一反三的基础，更是兴趣和自信的源泉。&lt;/p&gt;&lt;p&gt;当然，有的老师可能愿意把整个编程语言安排成初级和高级两个课程，在前者中讲授一门具体语言，在后者中专门讲解编程语言的理论知识，这也是一个合理的设计。但我个人更偏好一起来讲，因为理论和实践同时相互刺激能引起更强的求知欲，原因很简单，理论需要实践来解释how，实践需要理论来支撑why，一个学生如果能同时知道why和how，没有理由不愿意了解更多，虽然最后有没有兴趣是学生自己的事，但是是否引导了学生的兴趣是教育的事。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. 讲授被忽略的重要编程语言知识&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如上所述，国内的编程语言课程更侧重针对某一门具体语言的讲解，而缺少对编程语言整体设计的理解和判断。这好比学人体素描不识人体骨骼构成，学中医不讲阴阳，学音乐不知乐理。如此一来，知识的理解受限且无法融会贯通，不可深究亦不能长远。接下来我用两个重要的（但在国内编程语言课中经常被忽略的）编程语言知识点“函数式编程”和“语言的静态动态类型”作为例子简单说明一下。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;函数式编程&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们国内编程语言课程接触到的一般都是命令式语言（imperative）像C、Java、C++等，其中面向对象（object-oriented简称OO）的理论也有所普及。很多人听说过函数式语言（functional）但是并不了解，感觉现在找工作并没有强制要求了解函数式编程，所以觉得不学无所谓。&lt;/p&gt;&lt;p&gt;实际上多少了解一下函数式编程的思维更有助于理解用代码“抽象”和“计算”的概念。例如，如果普通数据value可以抽象，为什么行为（behaviour/action）不能抽象？我们可以把行为（用函数function来表达）看成像数据一样的value（first-class citizens），这样一来传入function的argument既可以是普通value也可以是行为（function）本身（进而引出higher-order function的概念），这使得function可以通过其function参数来“多态”行为，而一次计算任务就可以看成一套“行为”的组合（function的传递和调用），这样在实现一些计算任务时，代码会更简洁，逻辑会更清晰。&lt;/p&gt;&lt;p&gt;如今“函数式编程”被应用在越来越多的主流OO编程语言中。例如编程一霸JavaScript广泛支持了函数式编程机制；企业级代码新秀Scala一直以OO与Functional的“完美”结合标榜自己；就连OO代言人Java在Java 8后也开始通过“糖化”语法来支持函数式编程（如lambda expression）。对于一些纯函数式语言像Haskell，已经成为很多特殊行业（如金融）的宠儿。因此，教一教函数式编程（或思维）对编程语言的理解和实践都是有益的。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;语言的静态动态类型&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;有的时候编程语言可以通过“静态语言”和“动态语言”进行分类，如Scala、Haskell属于前者，JavaScript、Python属于后者。因此，有必要讲讲为什么会有静动之分，为什么不能各自取代对方，这对于理解编程语言的设计初衷和面对不同编程任务如何选择语言，都是有帮助的。&lt;/p&gt;&lt;p&gt;简单而言，静态语言定义变量需要声明类型，调用函数需要匹配类型等，而动态语言一般没有这种类型声明和匹配的约束。前者程序在运行前一般需要编译器静态检查这些约束，而后者程序可以直接在解释器上动态裸奔。各自好处是容易理解的，根据能量守恒原则（胡扯），静态语言需要程序员费时费力照规矩办事，面对复杂系统能大量减少运行时错误，写出的程序也容易理解和便于分析；反之，动态语言解放编程者天性想啥写啥，直接上手直接运行，轻便省力，但更容易导致运行时错误，且代码一般只有自己当天能读懂（o_O）。这也解释了为啥复杂的企业级软件青睐于静态语言，而脚本或轻量级程序一般选可以迅速上手的动态语言。&lt;/p&gt;&lt;p&gt;理解了这些，也就更容易理解为啥有时候编程语言会“动中向静”（JavaScript和TypeScript，动态语言静态化），有时候会“静中有动”（Java和Reflection，静态语言通过metaobject开了个动态的口子），有时候会“静动兼修”（Gradual typing）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;3. 拓展一些常见的编程语言知识&lt;/b&gt;&lt;/p&gt;&lt;p&gt;有的时候拓展讲解一点常见的编程语言知识会更有趣且有启发性。我举两个简单的例子：继承和异常处理（两个都拿常见的Java语言为例吧）。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;继承&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;相信面向对象课程都有针对继承的讲解（毕竟OO三大件是封装、继承、多态），比如Java中的类和父类的继承关系以及继承带来的好处。但是往往我们有一种倾向，就是觉得存在即合理，因此觉得继承一定就是好的，进而通常并不讲解Java中这种基于类的继承的弊端。实际上这种Java基于类的继承方式被很多PL的人吐槽过（当然只吐槽它不好的地方），因为它在很多情况下会造成不必要的冗余和开销（简单说就是你可以和你爹很多基因一样，但是不代表你俩穿的衣服都是一样的）。实际上很多继承关系是可以被更轻量级的composition比如Mixin技术代替的（虽然不像Scala、Ruby等语言在语言层面原生态支持Mixin，Java在Java 8后通过interface default methods也可以间接实现Mixin）。有了这些了解，也可以更容易理解其它继承设计的初衷和意义了，比如JavaScript这种基于prototype的更轻便的继承方式。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;异常处理&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;说到异常处理最直观的感受就是一种编程语言提供的处理错误的机制。很多程序任务都不可避免地要处理各种可预判的错误，例如访问的文件不存在，取值的对象为空等等，在异常处理机制下，错误可以标准化也可以定制化，不同的错误可以根据其类型通过try/catch捕捉处理。实际上，在此基础上如果再拓展讲一点，学生也许能站在更高（更抽象）的层面看到编程语言背后的设计哲学。这一点就是“异常处理”背后体现的“逻辑分流”设计。程序本身有“主体逻辑”（以期待的输入进行任务计算完成输出），然而这一过程不可避免地要处理“错误逻辑”。如何让程序以及编程者的主体逻辑思维不受错误逻辑干扰（代码也会随之简洁易懂）是异常处理机制设计的一个重要初衷。有了上面“逻辑分流”的理解，学生以后看到例如JavaScript的Promise这样的特性（resolve和reject分流），就会更容易理解该特性设计的初衷并愿意在合适的编程场合使用该特性。&lt;/p&gt;&lt;p&gt;以上，我觉得对一些基础知识（如上面讲的“继承”“异常处理”等）拓展地讲解，学生更容易跳出某个语言本身，更容易站在编程语言设计层面上去思考（进而将知识融汇贯通形成自己的知识树），甚至有可能进一步思考各种奇形怪状语言的雏形，这种兴趣的代入和思考的启发应该是教育的重心。我也相信这种“由内而外”的“漫天想象”会带来日后很多有生命的创新。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;4. 对于语义的重视&lt;/b&gt;&lt;/p&gt;&lt;p&gt;编程语言的语义非常重要，学习好语义可以从本质上理解编程语言，因为它在教你运行（该语言写的）程序的解释器是如何思考工作的。大家知道很多通用编程语言有很长的规范来具体地描述语言的语法、语义和特性以及它们应该怎么被使用，很多市面上的编程语言书籍（例如XX程序设计语言，XX handbook，XX in action太多了）也是参考这些规范文档来撰写的。然而无论是官方的规范手册还是书籍都是用自然语言描写的，这就会产生很多歧义和覆盖不到一些特殊情况。这也意味着看书学习一个一个语法特性编程尝试后，也很难对语言有一个整体的了解，对于语言局部的细节也很难有准确的把握。&lt;/p&gt;&lt;p&gt;在这种背景下，编程语言的形式化语义显得尤其重要，它通过一套基于数学的形式化的描述，通过语言的语法定义其相应的语义（注，一般只定义语言的核心部分，因为实际的通用编程语言很复杂，很难形式化准确定义描述所有其特性语义，如此一来整个语言和其使用环境并不能够得到严谨准确地描述和证明，因此可以说如今的编程语言包括编译器和运行环境实际上都会有bug，只是很多都还没有暴露而已）。编程语言领域语义的研究有着较长的历史，很多国外顶级大学的编程语言课程都会有形式化语义的专门讲解，描述语义的方法也有很多（如denotational semantics，operational semantics等）。&lt;/p&gt;&lt;p&gt;然而，尽管编程语言语义很重要，我们国内的编程语言教育几乎忽略了这一块，据我所知，只有北京大学的熊英飞老师和南京大学的冯新宇老师等极少高校编程语言课上会单独讲授包括语义在内的语言理论知识（感谢他们！）&lt;/p&gt;&lt;p&gt;实际上，如果不是单独的程序语言理论课程也不用全面细致地讲解它们（这样会有些枯燥，毕竟我们不是法国人(￣▽￣&quot;)）。例如，如果编程课程选择学习的语言是Java，可以考虑把整个Java的核心部分的语法和语义拿出来，挑选一种语义方法比如operational semantics里的small-step state machine方法来描述并一一讲解语言的每个核心语法和其对应的语义，这样学生在掌握了描述语法、语义方法的同时，也在整体和细节上理解了Java，这非常有益于日后更好地理解编程语言并编写程序。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这篇文章从“写作动机”开始，先后针对“为什么我国不重视编程语言教育”，“好的编程语言教育会对个人和社会带来什么好处”，“应当如何讲授编程语言课程”几个问题逐一阐述了我的个人观点。从来没有花过这么多时间和心思写这种观点性的文章，但是写完又有一种内心的满足，因为如同在文中“写作动机”所述，“希望让更少的学生被惋惜，让更多的学生受鼓舞”，尽管只是编程语言这一小领域，我仍庆幸自己迈出的这一小步。&lt;/p&gt;&lt;p&gt;知乎是一个挺好的地方，虽然如今感受到了更多的浮躁，但仍然能看到人们对于知识的渴望和对于自己进步的渴求，尤其是那些在更新速度极快的计算机领域中的学生和程序员们。鉴于自己在国内受过的编程语言教育和在知乎上看到的形形色色的编程语言问题，我切实地感受到了我国编程语言教育的落后，如文中所述，这对信息时代下的个人和社会的发展都会带来不可估量的损失。&lt;/p&gt;&lt;p&gt;我虽资质平平，但仍想借此文发声：我国高校主管计算机和软件教育的领导们，各计算机学院软件学院的院长们，人工智能、物联网、大数据等计算机应用固然重要，但请不要忽视计算机基础、软件核心“编程语言”的教育和研究，毕竟所有应用软件都是编程语言写的，毕竟如今的计算机行业对程序员的“质”的要求越来越高，毕竟我们有着这么多渴望编程知识和兴趣的准程序员们。期待我国编程语言教育和科研的进步。&lt;/p&gt;&lt;p&gt;此致。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;后记&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;“国内编程语言教育”，即使是“浅谈”，我也觉得这个题目很大。我自知自己对编程语言的理解还很欠火候，也真心觉得编程能力与有很多工作经验的程序员相差甚远，因此每每下笔，都怕是妄谈，也尤为此，对文中每个观点都尽量客观地呈现自己所见所想。我在知乎上虽然是个nobody，但还是希望认可文中一些观点的知友们帮助宣传一下，别让这篇文章沉的那么快，希望能引发软件行业的同学们和程序员的一点思考，也希望能让那些关心学生和计算机教育的相关领导看到，真正帮助改变我国编程语言教育的现状。&lt;/p&gt;&lt;p&gt;最后，这篇文章这么长，能一直看完的人啊，我敬佩你（谢谢你！）ｂ（￣▽￣）ｄ&lt;/p&gt;&lt;hr&gt;&lt;blockquote&gt;这两天在写一篇&lt;b&gt;《浅谈 编程语言研究 与 程序分析》&lt;/b&gt;的文章，过几天会放上来，如果大家感兴趣并且闲着无聊，可以来看看。&lt;/blockquote&gt;&lt;hr&gt;&lt;p&gt;======2018年10月1日更新======&lt;/p&gt;&lt;p&gt;上面提到的文章写好了，在这里&lt;/p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45208498&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-177562a74b47d6e59e518120f85e7ead&quot; data-image-width=&quot;845&quot; data-image-height=&quot;591&quot; data-image-size=&quot;180x120&quot;&gt;啥玩应啊：浅谈 编程语言研究 与 程序分析&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>啥玩应啊</author>
<guid isPermaLink="false">2018-09-28-43914842</guid>
<pubDate>Fri, 28 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Recursion Schemes（四）空间换时间</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-09-24-45249950.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45249950&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e5a2a9858bfa0c0e317c6943a84edb5b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;引言&lt;/h2&gt;&lt;p&gt;我们对于 &lt;i&gt;Bananas, Lenses, Envelopes, and Barbed Wire&lt;/i&gt; 一文中介绍的 Recursion Scheme 的认识已然逐渐明朗，是时候引入一些新的内容了。&lt;a href=&quot;http://cs.ioc.ee/~tarmo/papers/inf99.pdf&quot;&gt;Primitive(Co)Recursion and Course-of-Value (Co)Iteration, Categorically&lt;/a&gt;，原论文完成的 7 年之后，Tarmo Uustalu 和 Varmo Vene 发表了这篇论文，其讨论并且形式化了 apomorphism （我们上一篇中已有所涉及），同时还讨论了两种新的 Recursion Scheme，histomorphism 和 futumorphism。&lt;/p&gt;&lt;p&gt;Primitive(Co)Recursion and Course-of-Value (Co)Iteration, Categorically 同样是一篇充满干货的文章，但由于使用了范畴论的定义，并且沿用了上一篇论文的表示方法，使得文章变得较为晦涩。我们使用 Haskell 来重新讨论一下论文中新的 Recursion Scheme，它们其实只不过是  paramorphisms 和 apomorphism 的变种而已。在实际中，它们提供了更加强大的表达能力以及清晰的语义。正如 Uustalu 和 Vene 所说：&lt;/p&gt;&lt;blockquote&gt; 我们相信那些热爱编程语言以及对于编程语言证明感兴趣的人们会因这些 Scheme 的简洁易懂而从中获益。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;文中代码使用的是 Haskell，其源码可以在&lt;a href=&quot;https://github.com/patrickt/recschemes/blob/master/src/Part4.lhs&quot;&gt;这里&lt;/a&gt;看到。&lt;/p&gt;&lt;h2&gt;前情回顾&lt;/h2&gt;&lt;p&gt;前文中我们定义了 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 一个 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt; 的不动点，具有 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt; 用来构造和析构[1]。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Term f = In { out :: f (Term f) }&lt;/code&gt;&lt;p&gt;我们定义了 Algebra 其应用在 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt; 上，得到单独的值 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Algebra f a = f a -&amp;gt; a&lt;/code&gt;&lt;p&gt;接着我们定义了 catamorphism &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 来自底向上[2]遍历嵌套数据结构。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;cata :: (Functor f) =&amp;gt; Algebra f a -&amp;gt; Term f -&amp;gt; a -- 译者注：原文为 cata :: (Functor f) =&amp;gt; Algebra f a -&amp;gt; a -&amp;gt; Term f，应为笔误
cata f = out &amp;gt;&amp;gt;&amp;gt; fmap (cata f) &amp;gt;&amp;gt;&amp;gt; f&lt;/code&gt;&lt;p&gt;但 catamorphism 有它的局限性，它在求值并向上传递结果的过程中丢失了原数据的信息，为了解决这个问题我们引入了 paramorphism，在传递结果的同时传递原数据的信息：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type RAlgebra f a = f (Term f, a) -&amp;gt; a

para :: Functor f =&amp;gt; RAlgebra f a -&amp;gt; Term f -&amp;gt; a
para f = out &amp;gt;&amp;gt;&amp;gt; fmap (id &amp;amp;&amp;amp;&amp;amp; para f) &amp;gt;&amp;gt;&amp;gt; f&lt;/code&gt;&lt;h2&gt;引入 Histomorphism&lt;/h2&gt;&lt;p&gt;Paramorphism 给了我们看到原数据的能力，但是这往往是不够的，我们有时不光会需要原数据的信息，同时还需要之前的计算结果。一个经典的例子是求斐波那契数列[3]，其常见的求解方法如下：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fib :: Int -&amp;gt; Int  
fib 0 = 0  
fib 1 = 1  
fib n = fib (n-1) + fib (n-2)&lt;/code&gt;&lt;p&gt;如果我们将这个函数表示成 catamorphism，那么虽然 &lt;code class=&quot;inline&quot;&gt;fib(n-1)&lt;/code&gt; 会被记录下来，但是我们需要重新计算一次 &lt;code class=&quot;inline&quot;&gt;fib(n-2)&lt;/code&gt;，这显然不太科学，那么有没有更好的解决方案呢？&lt;/p&gt;&lt;p&gt;熟悉命令式编程的同学可能会考虑把递归转化为迭代，但是这样就引入了可变状态。又或者我们可以引入记忆化搜索，但这样的办法也并不简洁。Uustalu 和 Vene 提出的 histomorphism 就是为了解决这一问题：我们可以记录历史上计算过的信息，这样的递归过程被称为 &lt;a href=&quot;https://en.wikipedia.org/wiki/Course-of-values_recursion&quot;&gt;course-of-value recursion&lt;/a&gt;，即对于当前值得计算依赖于多个历史值。&lt;/p&gt;&lt;p&gt;与其操作 &lt;code class=&quot;inline&quot;&gt;f a&lt;/code&gt;，我们直接定义 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt;，其在保持自己本身结构的同时，记录了 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，我们可以认为这就是 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 带有属性的一个变种：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Attr f a = Attr  
              { attribute :: a
              , hole      :: f (Attr f a)
              }&lt;/code&gt;&lt;p&gt;这个结构可以递归地保持其所有子节点的计算成果，&lt;code class=&quot;inline&quot;&gt;hole&lt;/code&gt; 保持了在 cata 中丢失的数据结构，&lt;code class=&quot;inline&quot;&gt;attribute&lt;/code&gt; 保持了计算的值。&lt;/p&gt;&lt;p&gt;使用 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt; 的结构保持了过去计算的历史（&lt;i&gt;history&lt;/i&gt;[4]），所以在上面定义的结构被称为 &lt;i&gt;histomorphism&lt;/i&gt;，同样地为了定义 histomorphism，我们需要先定义 algebra，一如 F-algebra 之于 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt;，或 R-algebra 之于 &lt;code class=&quot;inline&quot;&gt;para&lt;/code&gt;，定义 &lt;i&gt;CV-algebra&lt;/i&gt;，它表示 course-of-value algebra：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type CVAlgebra f a = f (Attr f a) -&amp;gt; a&lt;/code&gt;&lt;p&gt;其中之前的计算结果在 &lt;code class=&quot;inline&quot;&gt;hole&lt;/code&gt; 中，递归地存储了下来。&lt;/p&gt;&lt;p&gt;我们的 &lt;code class=&quot;inline&quot;&gt;histo&lt;/code&gt; 函数与 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;para&lt;/code&gt; 大体类似，首先解析 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt;，接着使用 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt; 应用到子节点求值，最后使用 CV-algebra 求当前节点值：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;histo :: Functor f =&amp;gt; CVAlgebra f a -&amp;gt; Term f -&amp;gt; a
histo h = out &amp;gt;&amp;gt;&amp;gt; fmap worker &amp;gt;&amp;gt;&amp;gt; h&lt;/code&gt;&lt;p&gt;那么 worker 的类型是什么呢？我们使用 Haskell 的 type hole 功能来检查一下[5]，我们在 worker 前面添加下划线表示一个 type hole，当编译完成的时候，GHC 就会提醒我们所有使用 type hole 的地方类型是什么。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;histo :: Functor f =&amp;gt; CVAlgebra f a -&amp;gt; Term f -&amp;gt; a
histo h = out &amp;gt;&amp;gt;&amp;gt; fmap _worker &amp;gt;&amp;gt;&amp;gt; h&lt;/code&gt;&lt;p&gt;运行 GHC 就可以得到 type hole 的类型信息了：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;/Users/patrick/src/morphisms/src/Main.hs:14:24: error:
    • Found hole: ‘_worker’ with type :: Term f -&amp;gt; Attr f a&lt;/code&gt;&lt;p&gt;这样 &lt;code class=&quot;inline&quot;&gt;Term f&lt;/code&gt; 就变换成了 &lt;code class=&quot;inline&quot;&gt;Attr f a&lt;/code&gt;，则 &lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt; 解析之后的 &lt;code class=&quot;inline&quot;&gt;f Term f&lt;/code&gt; 就变成了 &lt;code class=&quot;inline&quot;&gt;f Attr f a&lt;/code&gt; 正好可以传入 CVAlgebra，得到 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;一个 &lt;code class=&quot;inline&quot;&gt;Attr f a&lt;/code&gt;，包括一个 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 类型，以及一个递归类型 &lt;code class=&quot;inline&quot;&gt;f (Attr f a)&lt;/code&gt;，首先我们搭建 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt; 的框架，输入一个 &lt;code class=&quot;inline&quot;&gt;Term f&lt;/code&gt;，记为 &lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;，返回一个 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt;，包括上述两个部分。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;worker t = Attr _ _&lt;/code&gt;&lt;p&gt;第一个部分 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，可以使用 &lt;code class=&quot;inline&quot;&gt;histo&lt;/code&gt; 得到，这与 catamorphism 非常相似，因为 catamorphism 就是 histomorphism 去除掉历史信息的部分：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;worker t = Attr (histo h t) _&lt;/code&gt;&lt;p&gt;第二个部分需要 &lt;code class=&quot;inline&quot;&gt;f (Attr f a)&lt;/code&gt;，我们可以把 &lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt; 应用到 &lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt; 上，来获得 &lt;code class=&quot;inline&quot;&gt;f (Term f)&lt;/code&gt;，接着因为 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt;，我们可以使用 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;， 所以我们需要一个 &lt;code class=&quot;inline&quot;&gt;Term f -&amp;gt; Attr f a&lt;/code&gt; 类型的函数，而这正是 &lt;code class=&quot;inline&quot;&gt;worker&lt;/code&gt; 本身！&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;worker t = Attr (histo h t) (fmap worker (out t))&lt;/code&gt;&lt;p&gt;这正是 &lt;code class=&quot;inline&quot;&gt;histo&lt;/code&gt; 的有趣之处，同包含 &lt;code class=&quot;inline&quot;&gt;worker&lt;/code&gt;，而它又包含 &lt;code class=&quot;inline&quot;&gt;histo&lt;/code&gt; 这样的二重递归结构，完整代码如下：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;histo :: Functor f =&amp;gt; CVAlgebra f a -&amp;gt; Term f -&amp;gt; a
histo h = out &amp;gt;&amp;gt;&amp;gt; fmap worker &amp;gt;&amp;gt;&amp;gt; h where
    worker t = Attr (histo h t) (fmap worker (out t))&lt;/code&gt;&lt;p&gt;但是，这个写法中子过程的计算不能被很好地共享，每个 &lt;code class=&quot;inline&quot;&gt;worker&lt;/code&gt; 会重新计算，而非复用之前的结果，所以我们需要对代码进行一些改写：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;histo :: Functor f =&amp;gt; CVAlgebra f a -&amp;gt; Term f -&amp;gt; a  
histo h = worker &amp;gt;&amp;gt;&amp;gt; attribute where  
  worker = out &amp;gt;&amp;gt;&amp;gt; fmap worker &amp;gt;&amp;gt;&amp;gt; (h &amp;amp;&amp;amp;&amp;amp; id) &amp;gt;&amp;gt;&amp;gt; mkAttr
  mkAttr (a, b) = Attr a b&lt;/code&gt;&lt;p&gt;我们来分析下上面这段代码的运行原理，&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt; 函数捕捉并保持了 &lt;code class=&quot;inline&quot;&gt;worker&lt;/code&gt; 函数的运行结果，去除掉这一部分，函数完全等价为 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt;，正是保持了这一部分使得我们可以将历史信息保持在 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt; 中，可以认为它的每一步都保存了当前的计算结果的快照。所以通过保持计算结果，我们实际上就实现了一个折叠过程中的缓存。&lt;/p&gt;&lt;p&gt;刚才我们使用斐波那契数列作为 course-of-value 的一个例子，但是这里我们不会使用 &lt;code class=&quot;inline&quot;&gt;histo&lt;/code&gt; 去计算第 n 项的数值（不过这是个不错的习题），我们将解决一个更加有趣一点的问题，histomorphism 将显示出其简洁与强大之处，同类问题也可以很好地泛化。&lt;/p&gt;&lt;h2&gt;硬币找零&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Change-making_problem&quot;&gt;硬币找零问题&lt;/a&gt;是算法领域非常经典的一类问题，经典的版本为给出面值为 &lt;code class=&quot;inline&quot;&gt;N&lt;/code&gt; 的纸币，以及一个可以选用的面值的硬币零钱（1角，5角等）问有多少种找零的方法？最常见的做法为使用动态规划求解，那么如何使用 histomorphism 来解决这一问题呢？&lt;/p&gt;&lt;p&gt;我们首先定义可找的零钱种类：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Cent = Int

coins :: [Cent]  
coins = [50, 25, 10, 5, 1]&lt;/code&gt;&lt;p&gt;接着定义函数 &lt;code class=&quot;inline&quot;&gt;change&lt;/code&gt;，它接受一个数额，并返回可找零钱的方法数：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;change :: Cent -&amp;gt; Int&lt;/code&gt;&lt;p&gt;硬币找零问题实际是&lt;a href=&quot;https://en.wikipedia.org/wiki/Knapsack_problem&quot;&gt;背包问题&lt;/a&gt;的一个特例，本文对算法本身不做过多叙述，大家可以在链接中找到详细说明。如前所述，我们可以使用 histomorphism 来解决这类问题。但是这里的第一个难题就是，我们需要一个可以遍历的数据结构！我们只有自然数，不是链表，不是数组，也不是树，更不是函子，那么怎么在整数上做递归遍历呢？&lt;/p&gt;&lt;p&gt;实际上我们需要将整数以一种不太常见的方式进行定义，每一个整数不是零，就是之前的数字 +1。换句话说，我们需要的是&lt;a href=&quot;https://en.wikipedia.org/wiki/Peano_axioms&quot;&gt;皮亚诺公理&lt;/a&gt;，我们定义 &lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt;[6]：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Nat a  
    = Zero
    | Next a
    deriving Functor&lt;/code&gt;&lt;p&gt;这样我们使用 &lt;code class=&quot;inline&quot;&gt;Term Nat&lt;/code&gt; 就可以表示自然数了：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;one, two, three :: Term Nat
one   = In (Next (In Zero))
two   = In (Next one)
three = In (Next two)&lt;/code&gt;&lt;p&gt;我们也需要定义与 &lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt; 相互转换的辅助函数：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;-- Convert from a natural number to its foldable equivalent, and vice versa.  
expand :: Int -&amp;gt; Term Nat  
expand 0 = In Zero  
expand n = In (Next (expand (n - 1)))

compress :: Nat (Attr Nat a) -&amp;gt; Int  
compress Zero              = 0  
compress (Next (Attr _ x)) = 1 + compress x&lt;/code&gt;&lt;p&gt;下面我们定义 &lt;code class=&quot;inline&quot;&gt;change&lt;/code&gt; 函数，它接受数额 &lt;code class=&quot;inline&quot;&gt;amt&lt;/code&gt;，其中 CVAlgebra 我们定义为 &lt;code class=&quot;inline&quot;&gt;go&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;change :: Cent -&amp;gt; Int  
change amt = histo go (expand amt) where&lt;/code&gt;&lt;p&gt;其中的 &lt;code class=&quot;inline&quot;&gt;go&lt;/code&gt; 函数需要实现的即为算法中递推公式的部分，其定义如下：（译者注，原文中的代码有错误，具体可见&lt;a href=&quot;https://github.com/patrickt/recschemes/issues/1&quot;&gt;这里&lt;/a&gt;的讨论）&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;go :: Nat (Attr Nat Int) -&amp;gt; Int
go Zero = 1
go curr@(Next attr) = let
  given = compress curr
  validCoins = filter (&amp;lt;= given) coins
  in sum (map (lookup attr) validCoins)

lookup :: Attr Nat a -&amp;gt; Int -&amp;gt; a
lookup cache 1 = attribute cache
lookup cache n = lookup inner (n - 1) where (Next inner) = hole cache&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;go Zero = 1&lt;/code&gt;，定义了动态规划的初始状态，首先通过调用 &lt;code class=&quot;inline&quot;&gt;compress&lt;/code&gt; 函数，可以获得当前的递推位置，接着通过 &lt;code class=&quot;inline&quot;&gt;validCoins&lt;/code&gt; 筛选出符合要求的前置状态，通过 &lt;code class=&quot;inline&quot;&gt;lookup&lt;/code&gt; 函数得到这些前置状态的 &lt;code class=&quot;inline&quot;&gt;attribute&lt;/code&gt;，其加和即为结果。&lt;/p&gt;&lt;h2&gt;动态缓存&lt;/h2&gt;&lt;p&gt;注意到 &lt;code class=&quot;inline&quot;&gt;f (Attr f a)&lt;/code&gt; 的缓存形状实际上随着函子 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 的变化而变化，当 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt; 时，&lt;code class=&quot;inline&quot;&gt;Attr Nat a&lt;/code&gt; 实际上同构于 &lt;code class=&quot;inline&quot;&gt;[]&lt;/code&gt;，这也是为什么 &lt;code class=&quot;inline&quot;&gt;lookup&lt;/code&gt; 的实现方式与 &lt;code class=&quot;inline&quot;&gt;!!&lt;/code&gt; 的实现是同构的原因。&lt;/p&gt;&lt;p&gt;而如果我们将函子 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 定为 &lt;code class=&quot;inline&quot;&gt;[]&lt;/code&gt;，那么 &lt;code class=&quot;inline&quot;&gt;Attr [] a&lt;/code&gt; 则同构于多叉树，同理如果 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;Either b&lt;/code&gt; 那么 &lt;code class=&quot;inline&quot;&gt;Attr (Either b) a&lt;/code&gt;，同构于一个终止状态为 &lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt; 的非空列表。&lt;/p&gt;&lt;p&gt;对于任意可折叠的嵌套式结构，&lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt; 会自动生成与之相匹配的缓存，而且是完全自动的，而这也是动态缓存的含义所在。&lt;/p&gt;&lt;h2&gt;替代 Paramorphism&lt;/h2&gt;&lt;p&gt;与之前一样，我们使用 Histomorphism 来替代 Paramorphism。在这之前我们先看一下替代 Catamorphism 的情况，使用 Histomorphism 替代 Catamorphism 非常简单，我们只需要忽视 &lt;code class=&quot;inline&quot;&gt;hole&lt;/code&gt; 里面的值就好了，在传入 F-algebra 之前，CV-algebra 需要做的是使用 &lt;code class=&quot;inline&quot;&gt;attribute&lt;/code&gt; 取值即可：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;cata :: Functor f =&amp;gt; Algebra f a -&amp;gt; Term f -&amp;gt; a  
cata f = histo (fmap attribute &amp;gt;&amp;gt;&amp;gt; f)&lt;/code&gt;&lt;p&gt;与之类似地，我们也可以表达 Paramorphism，我们只需要提取出 &lt;code class=&quot;inline&quot;&gt;hole&lt;/code&gt; 中与 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 有关的部分即可，我们需要将 &lt;code class=&quot;inline&quot;&gt;f (Attr f a)&lt;/code&gt; 转化为 &lt;code class=&quot;inline&quot;&gt;f (Term f, a)&lt;/code&gt;（实际上这也是原论文的语法符号非常怪异的原因之一，在一个真实的语言中实现这些不可避免地需要引入很多这样的语法噪音）：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;para :: Functor f =&amp;gt; RAlgebra f a -&amp;gt; Term f -&amp;gt; a  
para f = histo (fmap worker &amp;gt;&amp;gt;&amp;gt; f) where  
  worker (Attr a h) = (In (fmap (worker &amp;gt;&amp;gt;&amp;gt; fst) h), a)&lt;/code&gt;&lt;h2&gt;伪结语&lt;/h2&gt;&lt;p&gt;由于原文这一章的内容相比于之前章节显著地增多，我决定把原文拆成两部分，在下一部分中，我们会使用翻转箭头的技巧来讨论 Histomorphism 的对偶形式 Futumorphism 并给出例子。心急的朋友可以在&lt;a href=&quot;https://blog.sumtypeofway.com/recursion-schemes-part-iv-time-is-of-the-essence/#fn9&quot;&gt;这里&lt;/a&gt;看到原文。&lt;/p&gt;&lt;p&gt;感谢大家能耐心读到这里！&lt;/p&gt;&lt;p&gt;祝大家中秋快乐！&lt;/p&gt;&lt;p&gt;[1]: Bob Harper，在 &lt;i&gt;Practical Foundations for Programming Languages&lt;/i&gt; 中，曾将这样的操作称为 “rolling” 和 “unrolling”。这也是非常形象的：&lt;code class=&quot;inline&quot;&gt;(f (Term f)) -&amp;gt; f (Term f) -&amp;gt; Term f&lt;/code&gt; 的过程就像是一个平面卷起的样子，而 &lt;code class=&quot;inline&quot;&gt;Term f -&amp;gt; f (Term f) -&amp;gt; f (f (Term f))&lt;/code&gt; 就像是对应的展开的过程。&lt;/p&gt;&lt;p&gt;[2]: Rob Rix 的&lt;a href=&quot;https://twitter.com/rob_rix/status/793430628637274112&quot;&gt;文章&lt;/a&gt;，曾论证过，尽管我们常说 catamorphism 是自底向上的，但这一描述是不够准确的：catamorphism 的 递归过程是自顶向下的，而在求值的部分才是自底向上的&lt;/p&gt;&lt;p&gt;[3]: 令人遗憾的是，在这个经典的例子中，recursion scheme 并不能表现它的威力。相比之下，我们常见的写法会更加简明。所以斐波那契数列或许并不是好的例子，在之后的文章中，我会尽量使用更加有趣优雅的例子，以免给大家留下 recursion scheme 笨重无用且对现实世界毫无价值的错误印象。&lt;/p&gt;&lt;p&gt;[4]: history 的词源相当复杂，主要来自于希腊语 “ἱστορία”，表示已经学到的东西，它还有 “ἱστορέω” 的变形，表示在研究中学习，而这又来自于 “ἵστωρ” ，表示掌握知识或者专家，这也与历史最开始口口相传的情况吻合，而希腊词根 “ἱστο”，则含有网（web）的意思，也与 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt;，保持和生成数据的方式吻合。&lt;/p&gt;&lt;p&gt;[5]: 这一功能借鉴自 Agda 和 Idris。&lt;/p&gt;&lt;p&gt;[6]: 敏锐的读者可能会发现这一定义与 &lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt; 是等价的，这里的定义是为了使用更加符合自然数本质的结构。 &lt;/p&gt;</description>
<author>禾木旁</author>
<guid isPermaLink="false">2018-09-24-45249950</guid>
<pubDate>Mon, 24 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>函数式编程与数字电路</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-09-14-44000409.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/44000409&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前函数式编程应用主要是在编译器（Haskell，ml），以及大数据和分布式系统（Scala），但其实用函数式语言编写硬件逻辑电路也有一段历史了，特别是开源的RISC V 最近让Chisel好好火了一把，这一幕挺像当年的Spark。除了基于Scala的Chisel外，还有一门是基于Haskell的Clash。Chisel是利用macro元编程和Scala原本的编译器，实现了一个可以方便构建RTL的库，而后者的方法更激进，是通过修改Haskell的编译器GHC来直接把Haskell代码转变为RTL。&lt;/p&gt;&lt;p&gt;需要注意的是，虽然他们都是基于非常高层的抽象语言，但是和所谓的High Level Synthesis没什么关系，要实现任何东西都是需要自己在RTL级别进行构建和思考的，编译器并不会变魔术一样帮你实现某些算法，可以把他们看作是某些语法糖，理论上仍然是可以把Verilog再编译回去的，而不像Haskell编译为汇编那样不可逆。&lt;/p&gt;&lt;p&gt;那为啥不老老实实用Verilog？虽然都是RTL，但是他们相当于给Verilog加上了部分元编程的能力，所以最后生成的Verilog代码大小可能会让人惊叹。另一个是模块化，在项目一大以后优势就体现出来了，Scala的Trait，Haskell的Type Class，都能够更好的组织代码。在编辑器方面，Scala有开源免费的Intellij ，用起来是非常爽的，能提升不少战斗力，另外Haskell的VS code也不错。&lt;/p&gt;&lt;p&gt;Chisel和Clash除了语法和实现，感觉差异不是很大，Clash由于是基于Haskell而且严重依赖Type Class，所以学习曲线更加陡峭，不过Chisel深入学习以后也需要了解下Subtyping相关的类型系统知识。定制化方面，Chisel的架构更灵活一些，分离出了一个叫Firrtl的IR，比较容易加入某些中间代码变换。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;关于Chisel对于生产力的提升，可以看看 @&lt;a href=&quot;https://www.zhihu.com/people/xfguo&quot;&gt;郭雄飞&lt;/a&gt; 的回答&lt;/p&gt;&lt;a href=&quot;https://www.zhihu.com/question/58584770/answer/284119982&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-a5b864ff40c14ea5bd899c6072809019&quot; data-image-width=&quot;120&quot; data-image-height=&quot;120&quot; data-image-size=&quot;ipico&quot;&gt;https://www.zhihu.com/question/58584770/answer/284119982&lt;/a&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/58584770/answer/284119982&quot;&gt;郭雄飞：RISC-V开源项目为什么选用chisel这种新的高层次建模语言，而不是SystemVerilog?&lt;/a&gt;&lt;/p&gt;&lt;a href=&quot;https://www.zhihu.com/question/58584770/answer/284119982&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-a5b864ff40c14ea5bd899c6072809019&quot; data-image-width=&quot;120&quot; data-image-height=&quot;120&quot; data-image-size=&quot;ipico&quot;&gt;RISC-V开源项目为什么选用chisel这种新的高层次建模语言，而不是SystemVerilog?&lt;/a&gt;&lt;a href=&quot;https://github.com/freechipsproject/chisel3/wiki&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-3adf1d09765d5840cf68feec5eeda97e&quot; data-image-width=&quot;420&quot; data-image-height=&quot;420&quot; data-image-size=&quot;ipico&quot;&gt;freechipsproject/chisel3&lt;/a&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Martin awodey</author>
<guid isPermaLink="false">2018-09-14-44000409</guid>
<pubDate>Fri, 14 Sep 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
