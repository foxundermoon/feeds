<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Mon, 02 Apr 2018 19:12:35 +0800</lastBuildDate>
<item>
<title>Programming Languages: Application and Interpretation【译15下】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-02-35198525.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35198525&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b71b632ed7974538bb2e812bcd20914e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;初翻： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/9bebf466fc2535bec442451dca7cd13a&quot; data-hash=&quot;9bebf466fc2535bec442451dca7cd13a&quot; data-hovercard=&quot;p$b$9bebf466fc2535bec442451dca7cd13a&quot;&gt;@lotuc&lt;/a&gt; &lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;https://lotuc.gitbooks.io/plai-cn/content/&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;15.3.3 联合类型&lt;/h2&gt;&lt;p&gt;假设我们要建立动物园动物的链表，动物有这些种类：犰狳、红尾蚺等。目前，我们必须创建新的数据类型：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type Animal
  [armadillo (alive? : boolean)] ;犰狳
  [boa (length : number)]) ;蚺&lt;/code&gt;&lt;blockquote&gt;“在德州，马路中间除了黄线和死掉的犰狳什么都没有。” —— Jim Hightower&lt;/blockquote&gt;&lt;p&gt;然后创建它的链表：&lt;code class=&quot;inline&quot;&gt;(listof Animal)&lt;/code&gt;。因此，&lt;code class=&quot;inline&quot;&gt;Animal&lt;/code&gt;类型表示的是&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;的“联合（或称联合体，union）”，不过要创建这种联合的唯一方式是每次都创建新类型：比如要创建动物和植物的联合，就需要：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type LivingThings
  [animal (a : Animal)]
  [plant (p : Plant)])&lt;/code&gt;&lt;p&gt;这样实际的动物现在裹在了更深一“层”。这些类型被称为&lt;b&gt;带标签的联合&lt;/b&gt;（tagged union）或&lt;b&gt;可辨识的联合&lt;/b&gt;（discriminated union），因为我们需要显式引入类似&lt;code class=&quot;inline&quot;&gt;animal&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;plant&lt;/code&gt;的标签（或称&lt;b&gt;辨识符&lt;/b&gt;(discriminator)）来区分它们。相应地，结构体只能通过数据类型声明来定义；要创建只包含一种变体的数据结构，如&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type Constraints
  [eqCon (lhs : Term) (rhs : Term)])&lt;/code&gt;&lt;p&gt;来表示该数据结构，我们需要使用类型&lt;code class=&quot;inline&quot;&gt;Constraints&lt;/code&gt;而不是&lt;code class=&quot;inline&quot;&gt;eqCons&lt;/code&gt;，因为&lt;code class=&quot;inline&quot;&gt;eqCons&lt;/code&gt;不是类型，只是能在运行时区分的类型变体。&lt;/p&gt;&lt;p&gt;无论哪种方式，联合类型的要点是表示析取或“或”。值的类型是联合中某个类型。值通常只能是联合中某个特定的类型，不过这取决于联合类型的精确定义、规范它们的规则等等。&lt;/p&gt;&lt;h2&gt;15.3.3.1 作为类型的结构体&lt;/h2&gt;&lt;p&gt;对此自然的反应可能是，为什么不移除这种限制？为什么不允许每个结构体独立存在，将类型定义为一些结构体的集合？毕竟，不管是C还是Racket，程序员都可以定义独立的结构体，无需使用标签构造函数将它们包裹在其它类型里！例如，Racket里可以写：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(struct armadillo (alive?))
(struct boa (length))&lt;/code&gt;&lt;p&gt;加个注释：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;;; 动物是下面两者之一：
;; - (armadillo &amp;lt;boolean&amp;gt;)
;; - (boa &amp;lt;number&amp;gt;)&lt;/code&gt;&lt;p&gt;但是由于Racket不强制静态类型，这种比较不太清楚。然而，我们可以和 &lt;i&gt;Typed Racket&lt;/i&gt; （内置与DrRacket中的静态类型Racket）相比较。下面是对应的静态类型代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#lang typed/racket
 
(struct: armadillo ([alive? : Boolean]))
(struct: boa ([length : Real])) ;; feet&lt;/code&gt;&lt;p&gt;无需引用&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;就可以定义使用&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;类型值的函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;;; http://en.wikipedia.org/wiki/Boa_constrictor#Size_and_weight
(define: (big-one? [b : boa]) : Boolean
  (&amp;gt; (boa-length b) 8))&lt;/code&gt;&lt;p&gt;事实上，如果调用此函数时传入其它类型，如&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;——&lt;code class=&quot;inline&quot;&gt;(big-one? (armadillo true))&lt;/code&gt;——将发生&lt;b&gt;静态&lt;/b&gt;错误。因为&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;之间的关系等同与数和字符串之间的关系。&lt;/p&gt;&lt;p&gt;当然，我们仍可以定义这些类型的联合：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type Animal (U armadillo boa))&lt;/code&gt;&lt;p&gt;在这之上定义函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define: (safe-to-transport? [a : Animal]) : Boolean
  (cond
    [(boa? a) (not (big-one? a))]
    [(armadillo? a) (armadillo-alive? a)]))&lt;/code&gt;&lt;p&gt;之前我们有&lt;b&gt;一种包含两个变体的类型&lt;/b&gt;，现在则有&lt;b&gt;三种类型&lt;/b&gt;，其中两种类型恰巧能方便的通过联合定义第三种。&lt;/p&gt;&lt;h2&gt;15.3.3.2 无标签联合&lt;/h2&gt;&lt;p&gt;看起来我们好像还需要辨识标签，但并非如此。在支持联合类型的语言中，通常这样获取类型构造器&lt;code class=&quot;inline&quot;&gt;optionof&lt;/code&gt;：将期望的返回类型和用于表示失败或者&lt;code class=&quot;inline&quot;&gt;none&lt;/code&gt;的类型结合起来。例如，下面是&lt;code class=&quot;inline&quot;&gt;(optionof number)&lt;/code&gt;的等价实现：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type MaybeNumber (U Number Boolean))&lt;/code&gt;&lt;p&gt;同时，&lt;code class=&quot;inline&quot;&gt;Boolean&lt;/code&gt;本身也可以是&lt;code class=&quot;inline&quot;&gt;True&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;False&lt;/code&gt;的联合，在Typed Racket中也确实如此。因此，选择（option）类型更为准确的模拟实现应该是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type MaybeNumber (U Number False))&lt;/code&gt;&lt;p&gt;更为一般的，可以定义：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(struct: none ())
(define-type (Maybeof T) (U T none))&lt;/code&gt;&lt;p&gt;由于由于&lt;code class=&quot;inline&quot;&gt;none&lt;/code&gt;是新的、独特的类型，不会和其它类型混淆，因此该定义适用于所有类型。它提供给我们与选择类型相同的好处，且我们的值没有被埋入深一层的&lt;code class=&quot;inline&quot;&gt;some&lt;/code&gt;结构体，而是立即可用。例如&lt;code class=&quot;inline&quot;&gt;member&lt;/code&gt;，其Typed Racket中的类型是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(All (a) (a (Listof a) -&amp;gt; (U False (Listof a))))&lt;/code&gt;&lt;p&gt;如果元素未找到，&lt;code class=&quot;inline&quot;&gt;member&lt;/code&gt;返回&lt;code class=&quot;inline&quot;&gt;false&lt;/code&gt;；否则，它将返回从该元素开始的链表（即，链表的第一个元素是期望的元素）。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (member 2 (list 1 2 3))
&#39;(2 3)&lt;/code&gt;&lt;p&gt;将其转换为使用&lt;code class=&quot;inline&quot;&gt;Maybeof&lt;/code&gt;实现，可以写成：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define: (t) (in-list? [e : t] [l : (Listof t)]) : (Maybeof (Listof t))
  (let ([v [member e l]])
    (if v
        v
        (none))))&lt;/code&gt;&lt;p&gt;如果元素未找到，它将返回值&lt;code class=&quot;inline&quot;&gt;(none)&lt;/code&gt;；如果找到了，仍然是返回链表：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (in-list? 2 (list 1 2 3))
&#39;(2 3)&lt;/code&gt;&lt;p&gt;这样就无需从&lt;code class=&quot;inline&quot;&gt;some&lt;/code&gt;容器中取出链表。&lt;/p&gt;&lt;h2&gt;15.3.3.3 辨识无标签联合&lt;/h2&gt;&lt;p&gt;将值放入联合是一码事；我们还需要考虑如何以类型良好的方式将值从其中取出来。在我们的类ML类型系统中，我们使用程式化的符号——我们的语言中&lt;code class=&quot;inline&quot;&gt;type-case&lt;/code&gt;，ML中的模式匹配——来标识和取出各部分。具体来说，对于代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (safe-to-transport? [a : Animal]) : boolean
  (type-case Animal a
             [armadillo (a?) a?]
             [boa (l) (not (big-one? l))]))&lt;/code&gt;&lt;p&gt;在整个表达式中&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的类型保持一致。标识符&lt;code class=&quot;inline&quot;&gt;a?&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;l&lt;/code&gt;分别被绑定到布尔类型和数类型的值上，&lt;code class=&quot;inline&quot;&gt;big-one?&lt;/code&gt;接收的就是这些类型，而不是&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;。换句话说，&lt;code class=&quot;inline&quot;&gt;big-one?&lt;/code&gt;函数的输入类型不可以是&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;，因为根本没有这样的类型。&lt;/p&gt;&lt;p&gt;反之，使用联合类型的话，我们确实有&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;类型。因此，我们遵守对值进行谓词操作将&lt;b&gt;缩小其类型&lt;/b&gt;的原则。例如，在&lt;code class=&quot;inline&quot;&gt;cond&lt;/code&gt;的子句&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;[(boa? a) (not (big-one? a))]&lt;/code&gt;&lt;p&gt;中，尽管&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的初始类型为&lt;code class=&quot;inline&quot;&gt;Animal&lt;/code&gt;，在通过&lt;code class=&quot;inline&quot;&gt;boa?&lt;/code&gt;测试后，类型检查器会将其类型缩小到&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;的分支，这样&lt;code class=&quot;inline&quot;&gt;big-one?&lt;/code&gt;调用得以通过类型检查。反过来，其在条件表达式剩余部分的类型&lt;b&gt;不是&lt;/b&gt; &lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;——这里，只剩下&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;一种可能。这给类型检查器提出了更高的要求，它需要能测试并识别特定模式（称为&lt;b&gt;条件分割&lt;/b&gt;(if-splitting)）；缺了这种能力就无法使用联合类型编程；当然我们可以只识别类ML系统中能识别的模式，也就是模式匹配、&lt;code class=&quot;inline&quot;&gt;type-case&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;15.3.3.4 改造为静态类型&lt;/h2&gt;&lt;p&gt;毫不奇怪，Typed Racket使用联合类型。当将现有语言改造为静态类型时，它们尤其有用，因为现有语言（如脚本语言中）的程序没有用类ML类型系统的原则来定义。这种类型改造的通用的原则之一是尽可能多地静态捕获动态异常。当然，检查器最终会让一些程序无法通过检查【注释】，但如果它拒绝太多可以无错运行的程序，开发者不太可能采用它。由于这些程序是在没有考虑类型检查的情况下编写的，因此类型检查器需要以更为激进的方式接受该语言中被认为合理的习惯用法。&lt;/p&gt;&lt;blockquote&gt;除非它实现了称为&lt;b&gt;软类型&lt;/b&gt;（soft typing）的有趣想法：不拒绝任何程序，而是提供信息告知程序中无法通过类型检查之处。&lt;/blockquote&gt;&lt;p&gt;考虑下面的JavaScript函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;var slice = function (arr, start, stop) {
  var result = [];
  for (var i = 0; i &amp;lt;= stop - start; i++) {
      result[i] = arr[start + i];
  }
  return result;
}&lt;/code&gt;&lt;p&gt;它读入一个数组和两个索引，返回这两个索引之间的子数组。例如，&lt;code class=&quot;inline&quot;&gt;slice([5, 7, 11, 13], 0, 2)&lt;/code&gt;求得&lt;code class=&quot;inline&quot;&gt;[5, 7, 11]&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在JavaScript中，开发人员在函数调用时可以自由的省略任意或者所有尾部参数。每个被省略的参数都被赋予特定值&lt;code class=&quot;inline&quot;&gt;undefined&lt;/code&gt;，如何处理这种情形完全由函数决定。例如，&lt;code class=&quot;inline&quot;&gt;slice&lt;/code&gt;的典型实现允许用户省略最后一个参数；下面的定义&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;var slice = function (arr, start, stop) {
  if (typeof stop == &quot;undefined&quot;)
    stop = arr.length - 1;
  var result = [];
  for (var i = 0; i &amp;lt;= stop - start; i++) {
    result[i] = arr[start + i];
  }
  return result;
}&lt;/code&gt;&lt;p&gt;在未给定第三个参数时自动返回到数组结尾的子数组：因此&lt;code class=&quot;inline&quot;&gt;slice([5, 7, 11, 13], 2)&lt;/code&gt;返回&lt;code class=&quot;inline&quot;&gt;[11, 13]&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在Typed JavaScript【注释】中，程序员可以通过为给定参数指定类型&lt;code class=&quot;inline&quot;&gt;U Undefined&lt;/code&gt;来显式地指明函数可以接受更少的参数，此函数的类型如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;∀ t : (Array[t] * Int * (Int U Undefined) -&amp;gt; Array[t])&lt;/code&gt;&lt;blockquote&gt;由Arjun Guha等人在布朗（大学）创建。参见&lt;a href=&quot;http://www.jswebtools.org/&quot;&gt;我们的网站&lt;/a&gt;。&lt;/blockquote&gt;&lt;p&gt;原则上，这意味着表达式&lt;code class=&quot;inline&quot;&gt;stop - start&lt;/code&gt;存在发生类型错误的可能，因为&lt;code class=&quot;inline&quot;&gt;stop&lt;/code&gt;可能不是数。然而，当用户省略该参数时，对&lt;code class=&quot;inline&quot;&gt;stop&lt;/code&gt;的赋值正好将其设为数类型。换句话说，在所有控制路径上，减法发生前&lt;code class=&quot;inline&quot;&gt;stop&lt;/code&gt;都将是数类型，因此该函数能通过类型检查。当然，这要求类型检查器能够对控制流（条件）和状态（赋值）进行推断来确保函数类型正确；而Typed JavaScript可以做到，也因此能允许这样的函数。&lt;/p&gt;&lt;h2&gt;15.3.3.4 设计选择&lt;/h2&gt;&lt;p&gt;拥有联合类型的语言中，通常有&lt;/p&gt;&lt;ul&gt;&lt;li&gt;独立的结构体类型（通常用类表示），而不是带有变体的数据类型。&lt;/li&gt;&lt;li&gt;用于表示特定类型的特殊（ad hoc）结构体集合。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sentinel_value&quot;&gt;哨兵值（sentinel value）&lt;/a&gt;表示失败。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;将这种风格的程序转换成满足类ML类型风格的非常费事。因此，许多改造过来的类型系统引入联合类型来减轻类型化过程的负担。&lt;/p&gt;&lt;p&gt;上述三个属性中，第一个相对中立，但是其它两个需要更多讨论。我们以反序依次解决它们。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先处理哨兵值。很多情况下，哨兵应该被替换为异常，但是在很多语言中，抛出异常的代价巨大。因此开发者倾向于区分真正的异常情况——不应该发生——和正常运行中的预期情况。检查元素是否属于链表发现不存在的情况显然属于后者（如果我们已经知道元素是否存在，这个谓词判断就无需进行）。在后一种情况下，使用哨兵是合理的。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;然而，我们需要认识到，在C程序中，未能检测异常的哨兵值是错误——甚至安全缺陷——的常见原因。这点很容易解决。在C中，哨兵值和普通返回值&lt;b&gt;类型相同&lt;/b&gt;（或者至少等同于类型相同），而且运行时也没有检查。因此哨兵可以被当作合法的值使用，且不会出现类型错误。这就导致哨兵值&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;可以被当作分配数据的地址来使用，从而导致系统崩溃。与之不同，我们的哨兵是真正意义上的新类型，无法用于任何计算。观察到前语言中没有任何函数的输入类型为&lt;code class=&quot;inline&quot;&gt;none&lt;/code&gt;，可以推理出这点。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;先忽略这里贬义的“特殊”一词，对一组结构体进行不同的分组是否是个好主意？实际上，就算在遵循类ML规范的程序中，当程序员希望刻画一个大宇宙的子宇宙时，也会出现这种分组的情形。例如，ML程序员会使用下面的类型&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;(define-type SExp&lt;br&gt;  [numSexp (n : number)]&lt;br&gt;  [strSexp (s : string)]&lt;br&gt;  [listSexp (l : (listof SExp))])&lt;/p&gt;&lt;blockquote&gt;表示s-expression。如果有函数希望操作这些项的某个子集，比如数和数的链表，就必须创建新的类型，然后将值在两种类型之间转换，尽管这两个类型的内部表示完全相同。另一个例子，考虑CPS表达式的集合，这显然是所有可能表达式的一个子集，但如果不得不为其创建新的类型，我们将无法对其使用任何已有的表达式处理程序，比如解释器。&lt;/blockquote&gt;&lt;p&gt;换种说法，联合类型似乎是我们之前见到的ML风格类型系统的合理变种。但是，即使在联合类型中仍有设计选择，它们都有其后果。例如，允许类型系统创建新联合类型吗？允许用户定义（和命名）联合吗？也就是说，允许表达式&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(if (phase-of-the-moon)
    10
    true)&lt;/code&gt;&lt;p&gt;通过类型检查吗（将创建类型&lt;code class=&quot;inline&quot;&gt;(U Number Boolean)&lt;/code&gt;），还是由于其引入了之前未命名并显式标识的类型而将其判定为类型错误？Typed Racket提供的是前者：它将创建真正的临时联合。对于给现有代码引入类型来说，这么做可能更好，因为它更加灵活。但对于写新代码来说，这是否是个好的设计还并不清楚，因为并非程序员期望内的联合会出现，而且无法避免。这给程序语言的设计空间提供了一个未被探索的角落。&lt;/p&gt;&lt;h2&gt;15.3.4 名义类型系统与结构类型系统&lt;/h2&gt;&lt;p&gt;我们最初的类型检查器中，如果两个类型具有相同的结构，则认为它们是相同的。事实上我们根本没有提供类型的命名机制，因此不清楚有何替代方案。&lt;/p&gt;&lt;p&gt;现在考虑Typed Racket。程序员可以写&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type NB1 (U Number Boolean))
(define-type NB2 (U Number Boolean))&lt;/code&gt;&lt;p&gt;然后写&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define: v : NB1 5)&lt;/code&gt;&lt;p&gt;假设还定义了函数&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define: (f [x : NB2]) : NB2 x)&lt;/code&gt;&lt;p&gt;然后用&lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt;调用&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;，即&lt;code class=&quot;inline&quot;&gt;(f v)&lt;/code&gt;：该调用应该通过类型检查吗？&lt;/p&gt;&lt;p&gt;有两种完全合理的解释。一种是说&lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt;被声明为类型&lt;code class=&quot;inline&quot;&gt;NB1&lt;/code&gt;，与&lt;code class=&quot;inline&quot;&gt;NB2&lt;/code&gt;&lt;b&gt;名称&lt;/b&gt;不同，因此应该被当作不同&lt;b&gt;类型&lt;/b&gt;，所以该调用应导致错误。这种系统被称为&lt;b&gt;名义的&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Nominal_type_system&quot;&gt;nominal&lt;/a&gt;），因为类型的名字对于确定类型是否相等极为重要。&lt;/p&gt;&lt;p&gt;与之对应，另一种解释是说因为&lt;code class=&quot;inline&quot;&gt;NB1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;NB2&lt;/code&gt;&lt;b&gt;结构&lt;/b&gt;相同，因此开发者无法写出在这两种类型的值上表现的不同的程序来，所以它们应该被视为相同。【注释】这种类型系统被称为&lt;b&gt;结构的&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Structural_type_system&quot;&gt;structural&lt;/a&gt;），将允许上面的程序通过检查。（Typed Racket遵循结构类型的规范，理由同样是减少导入现有动态类型代码的负担，这些Racket代码通常是以结构解释为模型编写的。事实上，Typed Racket中&lt;code class=&quot;inline&quot;&gt;(f v)&lt;/code&gt;不仅能通过类型检查，而且打印出的返回类型为&lt;code class=&quot;inline&quot;&gt;NB1&lt;/code&gt;，无视&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;返回值的类型注解！）&lt;/p&gt;&lt;blockquote&gt;如果特别小心，你会注意到被认为相同和实际相同之间是有区别的。这里不会涉及该问题，但请考虑编译器作者选择值的表示时其影响是啥，尤其在允许运行时获取值的静态类型的语言中。&lt;/blockquote&gt;&lt;p&gt;名义和结构类型之间的区别在面向对象语言中是最常见的争议，&lt;a href=&quot;https://github.com/lotuc/PLAI-cn/blob/master/chap15.md#1538-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B&quot;&gt;后面&lt;/a&gt;将简要回顾这个问题。然而，这里的重点是要说明这些问题本质上并不关乎“对象”。任何允许命名类型的语言——出于程序员精神健康的需要，也就是所有的语言了——都要应付此问题：命名只是方便起见，还是说所选的名字是被认为是有意义的？选择前者导致结构类型，选择后者导致名义类型。&lt;/p&gt;&lt;h2&gt;15.3.5 交叉类型&lt;/h2&gt;&lt;p&gt;我们刚探索了联合类型，很自然的就会想到有没有&lt;b&gt;交叉&lt;/b&gt;（intersection）类型呢。确实有。&lt;/p&gt;&lt;p&gt;如果联合类型指（该类型的）值属于这个联合中某个类型，交叉类型显然意味着该值属于交叉中的&lt;b&gt;所有&lt;/b&gt;类型：合取，或“且”。这可能看起来很奇怪：值怎么可能属于多种类型呢？&lt;/p&gt;&lt;p&gt;用具体例子回答，考虑&lt;b&gt;重载函数&lt;/b&gt;。例如，某些语言中&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;即可操作数，也能操作字符串；传入两个数它返回数，传入两个字符串它返回字符串。这种语言中，&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;的类型应该是什么呢？不是&lt;code class=&quot;inline&quot;&gt;(number number -&amp;gt; number)&lt;/code&gt;，因为那样它将不能用于字符串；同样的原因，也不是&lt;code class=&quot;inline&quot;&gt;(string string -&amp;gt; string)&lt;/code&gt;。甚至它也不是&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(U (number number -&amp;gt; number)
   (string string -&amp;gt; string))&lt;/code&gt;&lt;p&gt;因为&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;不仅仅是这些函数之一：实际上它（同时）是这两者。我们可以认为其类型是&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((number U string) (number U string) -&amp;gt; (number U string))&lt;/code&gt;&lt;p&gt;这说明它的每个参数和返回值都只能是这两种类型之一，而不同时为两者。但是，这样做会导致精度损失。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;这种类型以何种方式损失精度？&lt;/blockquote&gt;&lt;p&gt;观察到，对于这个类型，&lt;b&gt;所有&lt;/b&gt;函数调用的返回值类型均为&lt;code class=&quot;inline&quot;&gt;(number U string)&lt;/code&gt;。因此，对于每个返回值都必须区分数和字符串，不然我们将得到类型错误。所以，尽管我们知道给定两个数参数将返回数结果，但这种信息在类型系统中丢失了。&lt;/p&gt;&lt;p&gt;更巧妙的是，这个类型允许独立的选择每个参数的类型。因此，根据该类型，&lt;code class=&quot;inline&quot;&gt;(+ 3 &quot;x&quot;)&lt;/code&gt;也是合法的（且其返回值类型为&lt;code class=&quot;inline&quot;&gt;(number U string)&lt;/code&gt;）。但我们描述的加法操作当然没有对这组参数定义过！&lt;/p&gt;&lt;p&gt;因此描述这种加法的更为合适的类型是&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(^ (number number -&amp;gt; number)
   (string string -&amp;gt; string))&lt;/code&gt;&lt;p&gt;这里的&lt;code class=&quot;inline&quot;&gt;∧&lt;/code&gt;让人联想到逻辑上的合取操作符。这允许函数用两个数或者两个字符串进行调用，其它的则不允许。使用两个数调用返回数类型；使用两个字符串调用返回字符串类型；除此之外没有其它合法调用了。这刚好对应于我们期望的重载行为（有时也称为&lt;b&gt;特设多态&lt;/b&gt;(ad hoc polymorphism)）。请注意这只能处理有限数量重载的情况。&lt;/p&gt;&lt;h2&gt;15.3.6 递归类型&lt;/h2&gt;&lt;p&gt;学过联合类型之后，值得讨论一下我们原来遇到过的递归数据类型表达式。如果接受变体作为类型构造器，我们可以将递归类型写作它们的联合吗？例如就&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;来说，能否将它描述成等价于&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((BTmt) U (BTnd number BTnum BTnum))&lt;/code&gt;&lt;p&gt;的类型吗，其中&lt;code class=&quot;inline&quot;&gt;BTmt&lt;/code&gt;是零参数的构造器，而&lt;code class=&quot;inline&quot;&gt;BTnd&lt;/code&gt;是三参数的？不过，这三个参数的类型是什么？按上面所写的类型，&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;要么是类型语言内建的（这不能令人满意），要么是未绑定的。也许我们要的是&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;BTnum = ((BTmt) U (BTnd number BTnum BTnum))&lt;/code&gt;&lt;p&gt;问题是这个方程没有明显解法（还记得&lt;code class=&quot;inline&quot;&gt;ω&lt;/code&gt;吗？）。&lt;/p&gt;&lt;p&gt;这种情况我们讨论&lt;a href=&quot;https://github.com/lotuc/PLAI-cn/blob/master/chap9.md#91-%E9%80%92%E5%BD%92%E4%B8%8E%E5%BE%AA%E7%8E%AF%E6%95%B0%E6%8D%AE&quot;&gt;值的递归&lt;/a&gt;时就熟悉过。那时，我们发明了递归函数构造器（并展示了其实现）来规避这个问题。这里我们同样需要递归类型构造器。按惯例它被称为&lt;code class=&quot;inline&quot;&gt;μ&lt;/code&gt;（希腊字母“缪”）。有了它，我们可以将上面的类型写做&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;μ BTnum : ((BTmt) U (BTnd number BTnum BTnum))&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;μ&lt;/code&gt;是绑定构造；它将&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;绑定到后面写的整个类型上，包括对&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;自身的递归绑定。实践中，整个递归类型就是我们希望得到的称为&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;的类型：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;BTnum = μ BTnum : ((BTmt) U (BTnd number BTnum BTnum))&lt;/code&gt;&lt;p&gt;尽管这看起来像是循环定义，但请注意，右侧的&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;不依赖于等式左侧的那个：即，我们可以将其重写为&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;BTnum = μ T : ((BTmt) U (BTnd number T T))&lt;/code&gt;&lt;p&gt;换句话说，&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;的这个定义可以被认为是语法糖，可以在程序的各个地方替换使用，无需担心无限回归的问题。&lt;/p&gt;&lt;p&gt;语义层面上，对&lt;code class=&quot;inline&quot;&gt;μ&lt;/code&gt;绑定的类型的意义有两种截然不同的思考方式：它们可以被解释为&lt;b&gt;同构递归&lt;/b&gt;（isorecursive）或&lt;b&gt;等价递归&lt;/b&gt;（equirecursive）。然而其中区别很微妙，超出了本章范围。【注释】只需理解递归类型可以被视为等同于它的展开。例如，我们定义数的链表类型为&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;NumL = μ T : ((MtL) U (ConsL number T))&lt;/code&gt;&lt;p&gt;于是有&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;μ T : ((MtL) U (ConsL number T))
= (MtL) U (ConsL number (μ T : ((MtL) U (ConsL number T))))
= (MtL) U (ConsL number (MtL))
        U (ConsL number (ConsL number (μ T : ((MtL) U (ConsL number T)))))&lt;/code&gt;&lt;p&gt;以此类推（同构和等价递归之间的区别正是在相等性的概念上：是定义上的相等性还是同构意义上的）。每一步中，我们将参数&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;替换成整个类型。和值的递归一样，它的意思是需要时我们可以“获得另一个”&lt;code class=&quot;inline&quot;&gt;ConsL&lt;/code&gt;构造。换种说法，链表的&lt;b&gt;类型&lt;/b&gt;可以写成零或任意多元素的联合；这等价于包含零个、一个或任意个元素的&lt;b&gt;类型&lt;/b&gt;；以此类推。任何数的链表都（恰好）符合这些类型。&lt;/p&gt;&lt;blockquote&gt;Pierce的书中对此解释的非常好。&lt;/blockquote&gt;&lt;p&gt;注意到，即使基于对于&lt;code class=&quot;inline&quot;&gt;μ&lt;/code&gt;的这种非正式理解，我们已经可以给&lt;code class=&quot;inline&quot;&gt;ω&lt;/code&gt;进而&lt;code class=&quot;inline&quot;&gt;Ω&lt;/code&gt;提供类型。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;描述&lt;code class=&quot;inline&quot;&gt;ω&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;Ω&lt;/code&gt;的类型。&lt;/blockquote&gt;&lt;h2&gt;15.3.7 子类型&lt;/h2&gt;&lt;p&gt;假设我们有一个典型的二叉树定义；简单起见，我们假设值为数。为了说明问题，我们用Typed Racket写：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#lang typed/racket

(define-struct: mt ())
(define-struct: nd ([v : Number] [l : BT] [r : BT]))
(define-type BT (U mt nd))&lt;/code&gt;&lt;p&gt;考虑二叉树具体的值：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (mt)
- : mt
#&amp;lt;mt&amp;gt;
&amp;gt; (nd 5 (mt) (mt))
- : nd
#&amp;lt;nd&amp;gt;&lt;/code&gt;&lt;p&gt;请注意，每个结构体构造器构造出自己对应类型的值，而不是&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;类型的值。但是考虑&lt;code class=&quot;inline&quot;&gt;(nd 5 (mt) (mt))&lt;/code&gt;：&lt;code class=&quot;inline&quot;&gt;nd&lt;/code&gt;的定义表明其子树必须为&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;类型，但我们可以传给它&lt;code class=&quot;inline&quot;&gt;mt&lt;/code&gt;类型的值。&lt;/p&gt;&lt;p&gt;显然，使用&lt;code class=&quot;inline&quot;&gt;mt&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;nd&lt;/code&gt;来定义&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;并不是巧合。但是，它确实表明在进行类型检查时，不能只检查构造函数的相等性，至少我们目前所做的不够。相反，我们必须检查一种类型“适用于”另一种。这种行为被称为&lt;b&gt;子类型化&lt;/b&gt;（subtyping）。&lt;/p&gt;&lt;p&gt;子类型化的本质是定义一种关系，通常用&lt;code class=&quot;inline&quot;&gt;&amp;lt;:&lt;/code&gt;表示，将一对类型关联起来。在期待类型&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的位置，如果放入类型&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的值也成立，那么我们就称&lt;code class=&quot;inline&quot;&gt;S &amp;lt;: T&lt;/code&gt;：换句话说，子类型化将&lt;b&gt;可替代性&lt;/b&gt;的概念（即，任何期望类型&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的值的地方，都可以被替换成类型为&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的值）形式化。当这种关系成立时，&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;被称作&lt;b&gt;子类型&lt;/b&gt;（subtype），&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;被称作&lt;b&gt;超类型&lt;/b&gt;（supertype）。使用子集去解释这点是很有用的（通常也是准确的）：如果&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的值是&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的子集，那么期望接受&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;值的表达式收到&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;值时不会出问题。&lt;/p&gt;&lt;p&gt;子类型化对类型系统有着深远影响。我们必须审视每一种类型，并理解它和子类型化之间的相互作用。对于基本类型，这通常比较明显：数、字符串等不相交的类型，彼此无关。（存在一些语言，使用某基本类型表示其它的基本类型——例如，某些脚本语言中，数只不过是特殊写法的字符串，还有些语言中，布尔值就是数——这些语言中，基本类型之间也可能存在子类型关系，但是这并不常见。）但是，我们必须考虑子类型化和每个复合类型构造器之间的关系。&lt;/p&gt;&lt;p&gt;事实上，甚至我们关于类型的表述也需要改变。假设我们有个类型为&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的表达式。通常我们会说它产生类型为&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的值。现在，我们需要小心的说，它产出&lt;b&gt;最多为&lt;/b&gt;&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的值，因为它可能只产出&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的某个子类型的值。因此，每个对类型的引用都隐含地涉及可能的子类型引用。为避免烦恼我会控制不这么做，但要小心，忽略这种隐含的解释可能导致推理错误。&lt;/p&gt;&lt;h2&gt;15.3.7.1 联合&lt;/h2&gt;&lt;p&gt;我们来讨论联合和子类型化会发生什么相互作用。显然，每个子联合是整个联合的子类型。在我们所用的例子中，显然每个&lt;code class=&quot;inline&quot;&gt;mt&lt;/code&gt;值都是&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;值；这同样适用于&lt;code class=&quot;inline&quot;&gt;nd&lt;/code&gt;。因而，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;mt &amp;lt;: BT
nd &amp;lt;: BT&lt;/code&gt;&lt;p&gt;于是，&lt;code class=&quot;inline&quot;&gt;(mt)&lt;/code&gt;也是&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;类型的，因此表达式&lt;code class=&quot;inline&quot;&gt;(nd 5 (mt) (mt))&lt;/code&gt;类型正确，就是&lt;code class=&quot;inline&quot;&gt;nd&lt;/code&gt;——因此也是&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;类型。一般来说，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;S &amp;lt;: (S U T)
T &amp;lt;: (S U T)&lt;/code&gt;&lt;p&gt;（我们写了两个看上去差不多的的规则，这是为了明确说明子类型处在联合中的哪“一边”并不重要）。它的意思是，&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的值可以被认为是&lt;code class=&quot;inline&quot;&gt;S U T&lt;/code&gt;的值，因为任何&lt;code class=&quot;inline&quot;&gt;S U T&lt;/code&gt;类型的表达式都确实可以包含&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;类型的值。&lt;/p&gt;&lt;h2&gt;15.3.7.2 交叉&lt;/h2&gt;&lt;p&gt;既然到了这里，我们也简要的讨论一下交叉。正如你可能想象的那样，交叉的行为是对偶的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(S ∧ T) &amp;lt;: S
(S ∧ T) &amp;lt;: T&lt;/code&gt;&lt;p&gt;为了说明这点，使用子集的解释：如果值即是&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;也是&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;，显然，它可以是两者中的任意一个。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;为什么下面两条假设&lt;b&gt;不&lt;/b&gt;成立？&lt;/blockquote&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;(S U T) &amp;lt;: S&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;T &amp;lt;: (S ∧ T)&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第一条不成立是因为类型&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的值是&lt;code class=&quot;inline&quot;&gt;(S U T)&lt;/code&gt;中完全合法的值。例如，数是类型&lt;code class=&quot;inline&quot;&gt;(string U number)&lt;/code&gt;的一员。然而，数不可以在需要类型为&lt;code class=&quot;inline&quot;&gt;string&lt;/code&gt;的时候被使用。&lt;/p&gt;&lt;p&gt;至于第二条，类型&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的值一般来说不是类型&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的值。任何希望类型&lt;code class=&quot;inline&quot;&gt;(S ∧ T)&lt;/code&gt;消费者希望其能够既作为&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;也作为&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，而后一点无法保证。例如对前面重载的&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;来说，如果&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;(number number -&amp;gt; number)&lt;/code&gt;，那么该类型的函数无法对字符串进行处理。&lt;/p&gt;&lt;h2&gt;15.3.7.3 函数&lt;/h2&gt;&lt;p&gt;我们还讨论过一种复合类型：函数。【注释】我们需要决定子类型关系中，任何一个类型为函数时的规则。通常我们认为函数和其它类型不相交，因此我们只需考虑函数类型作函数类型子类型的情况：也既，何时式子&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(S1 -&amp;gt; T1) &amp;lt;: (S2 -&amp;gt; T2)&lt;/code&gt;&lt;p&gt;成立？方便起见，我们称类型&lt;code class=&quot;inline&quot;&gt;(S1 -&amp;gt; T1)&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;f1&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;(S2 -&amp;gt; T2)&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;f2&lt;/code&gt;。问题就变成了，如果表达式的期望类型为&lt;code class=&quot;inline&quot;&gt;f2&lt;/code&gt;，何种情况下给其传递&lt;code class=&quot;inline&quot;&gt;f1&lt;/code&gt;类型的函数是安全的？使用子集合解释来考虑这个问题比较容易。&lt;/p&gt;&lt;blockquote&gt;我们还讨论过参数化数据类型。在本书中，对它们子类型化的探索作为练习留给读者。&lt;/blockquote&gt;&lt;p&gt;考虑&lt;code class=&quot;inline&quot;&gt;f2&lt;/code&gt;类型的使用。它返回值的类型为&lt;code class=&quot;inline&quot;&gt;T2&lt;/code&gt;。因此，函数调用所在的上下文会对&lt;code class=&quot;inline&quot;&gt;T2&lt;/code&gt;类型的值满意。显然，如果&lt;code class=&quot;inline&quot;&gt;T1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;T2&lt;/code&gt;相同，那么这里&lt;code class=&quot;inline&quot;&gt;f2&lt;/code&gt;的使用也能通过类型检查；类似的，如果&lt;code class=&quot;inline&quot;&gt;T1&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;T2&lt;/code&gt;值的一个子集，也是可以的。唯一的问题是，如果&lt;code class=&quot;inline&quot;&gt;T1&lt;/code&gt;的值比&lt;code class=&quot;inline&quot;&gt;T2&lt;/code&gt;多，该上下文将可能遭遇非期望的值，从而导致未定义行为。换句话说，我们需要&lt;code class=&quot;inline&quot;&gt;T1 &amp;lt;: T2&lt;/code&gt;。注意这里包含的“方向”与整个函数类型中的方向相同；这被称为&lt;b&gt;协变&lt;/b&gt;（covariance，两者在相同的方向上变化）。这也许正是你所期望的。&lt;/p&gt;&lt;p&gt;出于同样的原因，你可能认为参数位置也出现协变：即&lt;code class=&quot;inline&quot;&gt;S1 &amp;lt;: S2&lt;/code&gt;。这也符合预期，但它是错的。让我们看看为什么。&lt;/p&gt;&lt;p&gt;调用&lt;code class=&quot;inline&quot;&gt;f2&lt;/code&gt;类型的函数，需要提供类型为&lt;code class=&quot;inline&quot;&gt;S2&lt;/code&gt;的值作参数。假设我们将函数替换为类型&lt;code class=&quot;inline&quot;&gt;f1&lt;/code&gt;的。如果&lt;code class=&quot;inline&quot;&gt;S1 &amp;lt;: S2&lt;/code&gt;，这意味着新函数仅能接受&lt;code class=&quot;inline&quot;&gt;S1&lt;/code&gt;类型的值——这是一个严格子集。这意味着对于某些值——在&lt;code class=&quot;inline&quot;&gt;S2&lt;/code&gt;中但不在&lt;code class=&quot;inline&quot;&gt;S1&lt;/code&gt;中的值——函数调用会提供它们为参数，而换入的函数在它们之上并无定义，这导致未定义的行为。为避免此，需要假定相反的方向：即替代函数应该至少能接收原函数能够接收的那些值。因此我们需要&lt;code class=&quot;inline&quot;&gt;S2 &amp;lt;: S1&lt;/code&gt;，我们说该位置是&lt;b&gt;逆变&lt;/b&gt;（contravariant）的：它和子类型化方向相反。&lt;/p&gt;&lt;p&gt;综合这两个发现，我们得到函数（对于方法也一样）子类型化的规则：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(S2 &amp;lt;: S1) and (T1 &amp;lt;: T2) =&amp;gt; (S1 -&amp;gt; T1) &amp;lt;: (S2 -&amp;gt; T2)&lt;/code&gt;&lt;h2&gt;15.3.7.4 实现子类型&lt;/h2&gt;&lt;p&gt;当然，这些规则假定我们已经修改了类型检查器遵循子类型化的要求。子类型化的本质规则是，如果有表达式&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;，其类型为&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，且&lt;code class=&quot;inline&quot;&gt;S &amp;lt;: T&lt;/code&gt;，那么&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;也具有类型&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;。虽然这听起来很直观，但它也有问题，原因有二：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;到目前为止，我们所有的类型规则都是语法驱动的，这使我们可以编写递归下降的类型检查器。但现在有可一条适用于所有表达式的规则，我们不知道何时应用这条规则了。&lt;/li&gt;&lt;li&gt;可能存在很多级别的子类型。这使得何时“停止”子类型化不再是个显而易见的问题。特别是，原来类型检查会求出表达式的类型，现在表达式可以有很多可能的类型；如果我们返回了“错误”的类型，可能会导致类型错误（因为它不是上下文期望的类型），尽管这时候可能存在其它的类型能够满足上下文需求。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这两个问题指出的是，我们这里给出的关于子类型化的描述根本上来说是&lt;b&gt;声明性的&lt;/b&gt;：我们描述了它是怎样的，但是没有将这种说明转换成算法。对于每个实际的静态类型语言，将其转换成&lt;b&gt;子类型算法&lt;/b&gt;——实现类型检查器的实际算法（理想情况下，该类型检查器仅让所有声明机制下被认为是有效的程序通过类型检测，也即，既可靠又完备）——或多或少是个有趣的问题。&lt;/p&gt;&lt;h2&gt;15.3.8 对象类型&lt;/h2&gt;&lt;p&gt;正如我们&lt;a href=&quot;https://github.com/lotuc/PLAI-cn/blob/master/chap15.md#1534-%E5%90%8D%E4%B9%89%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F&quot;&gt;前面&lt;/a&gt;提到的，对象的类型通常分为两个阵营：名义的和结构的。名义类型大多数程序员通过Java都熟悉了，所以这里不多讨论。对象的结构类型是说，对象的类型本身就是一个结构化的对象，由字段的名字及它们的类型组成。例如，有两个方法——&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;sub1&lt;/code&gt;——的对象，其类型将是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;{add1 : (number -&amp;gt; number), sub1 : (number -&amp;gt; number)}&lt;/code&gt;&lt;p&gt;（为方便引用，我们称这个类型为&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;。）类型检查的做法也很容易预计：对于字段的访问，我们只需确保字段存在，并将解引用表达式类型求为该字段的声明类型；对于方法调用，我们不仅需要确保对应成员存在，还要确保其类型是函数。到目前为止，一切都很简单。&lt;/p&gt;&lt;p&gt;对象类型会因为很多原因而变复杂：&lt;/p&gt;&lt;blockquote&gt;很多书都专注于此问题。尽管有点过时，但是Abadi和Carelli的《A Theory of &lt;br&gt;Objects（对象理论）》仍然很重要。Bruce的《Foundationos of Object-Oriented Languages: Types and Semantics（面向对象语言基础：类型和语义）》更为现代，阐述也更温和。Pierce的书则漂亮的覆盖了所有必要的理论。&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;自引用。&lt;code class=&quot;inline&quot;&gt;self&lt;/code&gt;的类型是什么？它必须和整个对象的类型相同，因为任何可以从“外部”施加到对象上的操作也可以通过&lt;code class=&quot;inline&quot;&gt;self&lt;/code&gt;在“内部”施加。这意味着对象是递归类型。&lt;/li&gt;&lt;li&gt;访问控制：私有（private）、公共（public）和其它限制。这导致对象“外部”和“内部”类型之间的区别。&lt;/li&gt;&lt;li&gt;继承：不仅需要为父对象指定类型，还需要考虑继承路径上哪些东西可见，这和“外部”可见的东西又有区别。&lt;/li&gt;&lt;li&gt;多重继承和子类型之间的相互作用。&lt;/li&gt;&lt;li&gt;像Java这样的语言中，类和接口之间的关系存在运行时成本。&lt;/li&gt;&lt;li&gt;赋值。&lt;/li&gt;&lt;li&gt;类型转换。&lt;/li&gt;&lt;li&gt;横生枝节。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;等等。其中的一些问题会因为名义类型而简化，因为给定类型名我们就可以确定其行为的所有信息（类型声明实际变成了一个字典，从中可以查询关于对象的描述），这也是赞成名义类型的一个论据。&lt;/p&gt;&lt;blockquote&gt;请注意，Java的方法不是构建名义类型系统的唯一方法。之前讨论过，Java的类系统不必要地限制了程序员的表达能力；相应地，Java的名义类型不必要地将类型（接口描述）和实现混为一谈。因此，名义类型系统可以比Java做的好得多。例如，Scala在这个方面就做出了重要的改变。&lt;/blockquote&gt;&lt;p&gt;对这些问题进行充分论述需要更多的篇幅。这里我们只讨论一个有趣的问题。还记得我们说过，子类型化迫使我们考虑每种类型构造器吗？有了对象的结构类型，我们就必须多考虑一种：对象类型构造器。因此我们必须了解它与子类型化之间的相互作用。&lt;/p&gt;&lt;p&gt;在开始之前，先来确保我们理解对象类型到底意味着什么。考虑上面的&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;类型，其中列出了两个方法。什么对象的类型可以是它？显然，恰好拥有这两个方法、且方法的类型符合的对象符合条件。同样明显的是，如果某个对象只包含这两个方法中的一个而不含另一个，不管它还包含有其它什么，都不符合条件。但其中短语“不管它还包含其它什么”是最先要考虑的。如果对象表示的是算术包，除了这两个方法之外，它还包含&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt;呢（所有方法的类型也都正确）？这种情况下的对象当然能提供上面两个方法，因此该算术包确实具有类型&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;。不过将其作为类型&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;使用时，其它方法不可用。&lt;/p&gt;&lt;p&gt;下面我们写下这个包的完整类型，称之为&lt;code class=&quot;inline&quot;&gt;as+*&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;{add1  : (number -&amp;gt; number),
 sub1  : (number -&amp;gt; number),
 +     : (number number -&amp;gt; number),
 *     : (number number -&amp;gt; number)}&lt;/code&gt;&lt;p&gt;前面论证的是，类型&lt;code class=&quot;inline&quot;&gt;as+*&lt;/code&gt;的对象也允许被声明为类型&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;，这意味着它可以放入任何期望&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;类型值的上下文。换句话说，我们刚才的意思其实是&lt;code class=&quot;inline&quot;&gt;as+* &amp;lt;: addsub&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;{add1  : (number -&amp;gt; number),           {add1 : (number -&amp;gt; number),
 sub1  : (number -&amp;gt; number),        &amp;lt;:  sub1 : (number -&amp;gt; number)}
 +     : (number number -&amp;gt; number),
 *     : (number number -&amp;gt; number)}&lt;/code&gt;&lt;p&gt;这可能乍一看令人困惑：我们说过子类型化遵从集合包含关系，因此我们期望小的集合在左侧而大的集合在右侧。可这里，好像“大的类型”（至少在字符数量的意义上是）在左侧而“小的类型”在右侧。&lt;/p&gt;&lt;p&gt;要理解为什么这是正确的，需要建立这样的直觉：“越大”的类型包含的值越少。左侧的每个对象都含有四个方法，而且其中包含了右侧的那两个方法。但是，有很多对象有右侧的两个方法，但是不包含左侧那另外两个方法。如果我将类型看作对可接受值形状的约束的话，“更大”的类型给定了更多的约束，因此会导致更少的值。于是，尽管&lt;b&gt;类型&lt;/b&gt;的大小关系可能看上去不对，但是它们所包含的值的集合的大小关系是正确的。&lt;/p&gt;&lt;p&gt;更一般地，这表明从对象中删除字段就能获得超类型。这被称为&lt;b&gt;宽度子类型化&lt;/b&gt;（width subtyping），因为子类型“更宽”，而我们通过调整对象“宽度”来移动到更上层的类型。即使在Java的名义类型世界中也能看到这点：当沿着继承链上溯时，类中的方法和字段越来越少，直到&lt;code class=&quot;inline&quot;&gt;Object&lt;/code&gt;——所有类的超类型——包含得最少。因此对于Java中的任意类类型&lt;code class=&quot;inline&quot;&gt;C&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;C &amp;lt;: Object&lt;/code&gt;。&lt;/p&gt;&lt;blockquote&gt;有时，&lt;b&gt;缩小&lt;/b&gt;（narrowing）和&lt;b&gt;拓宽&lt;/b&gt;（widening）的使用方式会让人疑惑，它看上去好像用反了一样。拓宽是指从子类型转到超类型，因为它是从一个“较窄”（较小）的集合到一个“较宽”（较大）的集合。这些术语是独立演化而来的，很不幸，并不一致。&lt;/blockquote&gt;&lt;p&gt;正如你可能预计的那样，还有一种重要的子类型化形式，是关于给定成员&lt;b&gt;内部&lt;/b&gt;的。就是说，任何特定的成员都可以归入相应位置的超类型。出于显而易见的原因，这种形式的子类型化被称为&lt;b&gt;深度子类型化&lt;/b&gt;（depth subtyping）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;构造两个深度子类型化的例子。其中一个，给定字段为对象类型，使用宽度子类型化去取该字段的子类型。另一个例子中，给定字段为函数类型。&lt;/blockquote&gt;&lt;p&gt;Java中限制了深度子类型化，它倾向于类型在对象层次结构中保持不变，因为这对传统的赋值操作来说是安全的。&lt;/p&gt;&lt;p&gt;宽度和深度子类型化的结合包含了对象子类型化中大部分最有趣的情形。然而，仅实现这两种子类型化的类型系统不可避免地会招致程序员恼火。其它方便的（而且数学上必须的）规则还包括：改变名称排列顺序的能力、反身性（每个类型是其自己的子类型，因为将子类型关系解释为&lt;code class=&quot;inline&quot;&gt;⊆&lt;/code&gt;更方便）和传递性。像Typed JavaScript这样的语言使用了所有这些特性为程序员提供最大的灵活性。&lt;/p&gt;</description>
<author>MrMathematica</author>
<guid isPermaLink="false">2018-04-02-35198525</guid>
<pubDate>Mon, 02 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>发布Compute.scala，多维数组上的科学计算库</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-01-35183750.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35183750&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同学们，愚人节快乐，&lt;/p&gt;&lt;p&gt;今天我很荣幸向大家介绍&lt;b&gt;Compute.scala&lt;/b&gt;。Compute.scala是个科学计算库，可以利用GPU、CPU和其他设备并行计算多维数组。它是下一版本DeepLearning.scala v3.0的新后端，用来解决我们在DeepLearning.scala v2.0的ND4J后端中遇到的各种性能问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Compute.scala可以把多个操作动态合并成一个核函数。执行复杂计算公式时能比以前大大加速。&lt;/li&gt;&lt;li&gt;Compute.scala可以把内存、显存和其他原生资源管理起来，消耗的资源要比ND4J依赖垃圾收集的做法少得多。&lt;/li&gt;&lt;li&gt;Compute的维度转换操作（比如&lt;code class=&quot;inline&quot;&gt;permute&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;broadcast&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;reshape&lt;/code&gt;）都是视图，不额外占用显存或内存。&lt;/li&gt;&lt;li&gt;Compute的多维数组可以和JVM的集合互相转换，从而可以支持Scala原生的&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;reduce&lt;/code&gt;等集合操作，而且依然可以运行在GPU上。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;性能评测&lt;/h2&gt;&lt;p&gt;我们最近做了一些性能评测，对比Compute.scala和ND4J的性能：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://jmh.morethan.io/?source=https://raw.githubusercontent.com/ThoughtWorksInc/Compute.scala/f4fcd1cd54b9deea8b8234114b2bcdcf8c739038/benchmarks/nvidia-gpu.json&quot;&gt;Compute.scala vs ND4J on a NVIDIA Titan X GPU&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://jmh.morethan.io/?source=https://thoughtworksinc.github.io/Compute.scala/benchmarks/amd-gpu.json&quot;&gt;Compute.scala on a AMD RX480 GPU&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;从性能评测结果看：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Compute.scala支持各个厂商的GPU，ND4J只支持NVIDIA GPU。&lt;/li&gt;&lt;li&gt;在大数组上，Compute.scala比ND4J快。比如把65536×32的矩阵和32×32的矩阵相乘，那么Compute.scala要比ND4J快12倍多。&lt;/li&gt;&lt;li&gt;运行包含多个原子操作的复杂公式，Compute.scala比ND4J快。比如当对32×32×32的数组调用一个&lt;code class=&quot;inline&quot;&gt;tanh&lt;/code&gt;时，Compute.scala只比ND4J快五倍多，但是如果执行的表达式包含了100个&lt;code class=&quot;inline&quot;&gt;tanh&lt;/code&gt;，Compute.scala就比ND4J快三十倍多。&lt;/li&gt;&lt;li&gt;在很小的数组上执行单个简单操作时，ND4J比Compute.scala快。&lt;/li&gt;&lt;li&gt;ND4J的&lt;code class=&quot;inline&quot;&gt;permute&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;broadcast&lt;/code&gt;极慢，大概比Compute.scala慢上百倍，导致我们的卷积评测根本跑不出能看的结果（注：和ND4J同一家作者的Deeplearning4J用了文档上没记载的内部特殊方式使用&lt;code class=&quot;inline&quot;&gt;permute&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;broadcast&lt;/code&gt;，并不像上述评测里这么慢）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;注：这个评测结果并不是愚人节笑话。&lt;/p&gt;&lt;h2&gt;后续工作&lt;/h2&gt;&lt;p&gt;我们刚刚完成Compute.scala的最小可用原型，版本号v0.3.1。Compute.scala的功能仍然有待继续完善，我们将在正式版本发布以前完成以下功能：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;支持单精度浮点数以外的数据类型(&lt;a href=&quot;https://github.com/ThoughtWorksInc/Compute.scala/issues/104&quot;&gt;#104&lt;/a&gt;)&lt;/li&gt;&lt;li&gt;增加更多的OpenCL数学函数(&lt;a href=&quot;https://github.com/ThoughtWorksInc/Compute.scala/issues/101&quot;&gt;#101&lt;/a&gt;)&lt;/li&gt;&lt;li&gt;进一步性能调优(&lt;a href=&quot;https://github.com/ThoughtWorksInc/Compute.scala/labels/performance&quot;&gt;#62, #103&lt;/a&gt;)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;欢迎大家来贡献代码和文档。新贡献者可以从&lt;a href=&quot;https://github.com/ThoughtWorksInc/Compute.scala/labels/good%20first%20issue&quot;&gt;good first issues&lt;/a&gt;开搞。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;相关链接&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/ThoughtWorksInc/Compute.scala&quot;&gt;Compute.scala on Github&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://javadoc.io/page/com.thoughtworks.compute/tensors_2.12/latest/com/thoughtworks/compute/index.html&quot;&gt;Compute API Documentation&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2018-04-01-35183750</guid>
<pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>The C Programming Language：入门</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-01-35179359.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35179359&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
序&lt;br&gt;&lt;br&gt;在本书的开篇，我们首先概要地介绍 C 语言，主要是通过实际的程序引入 C 语言的基本元素，至于其中的具体细节、规则以及一些例外情况，在此暂时不多做讨论。因此，本章不准备完整、详细地讨论 C 语言中的一些技术（当然，这里所举的所有例子都是正确的）。我们是希望读者能尽快地编写出有用的程序，为此，本章将重点介绍一些基本概念，比如变量与 常量、算术运算、控制流、函数、基本输入／输出等。而对于编写较大型程序所涉及到的一 些重要特性，比如指针、结构、C 语言中十分丰富的运算符集合、部分控制流语句以及标准库 等，本章将暂不做讨论。 &lt;br&gt;&lt;br&gt;这种讲解方式也有缺点。应当提请注意的是，在本章的内容中无法找到任何特定语言特
性的完整说明，并且，由于比较简略，可能会使读者产生一些误解；再者，由于所举的例子 并没有用到 C 语言的所有强大功能，因此，这些例子也许并不简洁、精炼。虽然我们已经尽力将这些问题的影响降到最低，但问题肯定还是存在。另一个不足之处在于，本章所讲的某些内容在后续相关章节还必须再次讲述。我们希望这种重复给读者带来的帮助效果远远超过它的负面影响。 &lt;br&gt;&lt;br&gt;无论是利还是弊，一个经验丰富的程序员应该可以从本章介绍的内容中推知他们自己进
行程序设计所需要的一些基本元素。初学者应编写一些类似的小程序作为本章内容的补充练习。无论是经验丰富的程序员还是初学者，都可以把本章作为后续各章详细讲解的内容的框架。 &lt;br&gt;&lt;br&gt;1.1. 入门
&lt;br&gt;&lt;br&gt;学习一门新程序设计语言的惟一途径就是使用它编写程序。对于所有语言的初学者来说，编写的第一个程序几乎都是相同的，即：&lt;br&gt;请打印出下列内容 &lt;br&gt;&lt;br&gt;hello, world &lt;br&gt;&lt;br&gt;尽管这个练习很简单，但对于初学语言的人来说，它仍然可能成为一大障碍，因为要实
现这个目的，我们首先必须编写程序文本，然后成功地运行编译，并加载、运行，最后输出到某个地方。掌握了这些操作细节以后，其它事情就比较容易了。 &lt;br&gt;&lt;br&gt;在 C 语言中，我们可以用下列程序打印出&lt;br&gt;&lt;br&gt;“hello, world”：
&lt;br&gt;#include &amp;lt;stdio.h&amp;gt; 
&lt;br&gt;main() 
&lt;br&gt;{ 
&lt;br&gt; printf(&quot;hello, world\n&quot;); 
&lt;br&gt;} &lt;br&gt;&lt;br&gt;如何运行这个程序取决于所使用的系统。这里举一个特殊的例子。在 UNIX 操作系统中，首先必须在某个文件中建立这个源程序，并且以“.c”作为文件的扩展名，例如 hello.c，然后再通过下列命令进行编译： &lt;br&gt;&lt;br&gt;gcc hello.c &lt;br&gt;&lt;br&gt;如果源程序没有什么错误（例如漏掉字符或拼错字符），编译过程将顺利进行，并生成一个可
执行文件 a.out。然后，我们输入： &lt;br&gt;a.out 
&lt;br&gt;即可运行 a.out，打印出下列信息：
&lt;br&gt;hello, world 
&lt;br&gt;在其它操作系统中，编译、加载、运行等规则会有所不同。
&lt;br&gt;————————————————————————&lt;br&gt;#include &amp;lt;stdio.h&amp;gt; 
   &lt;br&gt; 包含标准库的信息&lt;br&gt;main() 
   &lt;br&gt;   定义名为 main 的函数，它不接受参数值&lt;br&gt;{ 
    &lt;br&gt;   main 函数的语句都被括在花括号中&lt;br&gt; printf(&quot;hello, world\n&quot;); 
&lt;br&gt;   main 函数调用库函数 printf 以显示字符序列&lt;br&gt;}       &lt;br&gt;   \n 代表换行符&lt;br&gt;                           第一个C语言程序&lt;br&gt;————————————————————————&lt;br&gt;&lt;br&gt;下面对程序本身做些说明。一个 C 语言程序，无论其大小如何，都是由函数和变量组成的。函数中包含一些语句，以指定所要执行的计算操作；变量则用于存储计算过程中使用的值。C 语言中的函数类似于 Fortran 语言中的子程序和函数，与 Pascal 语言中的过程和函数也很类似。在本例中，函数的名字为main。通常情况下，函数的命名没有限制，但 main 是一个特殊的函数名——每个程序都从 main 函数的起点开始执行，这意味着每个程序都必须在某个位置包含一个 main 函数。 &lt;br&gt;main 函数通常会调用其它函数来帮助完成某些工作，被调用的函数可以是程序设计人员
&lt;br&gt;自己编写的，也可以来自于函数库。上述程序段中的第一行语句
&lt;br&gt;&lt;br&gt;#include &amp;lt;stdio.h&amp;gt; 
&lt;br&gt;&lt;br&gt;用于告诉编译器在本程序中包含标准输入／输出库的信息。许多 C 语言源程序的开始处都包
含这一行语句。我们将在第 7 章和附录 B 中对标准库进行详细介绍。 &lt;br&gt;&lt;br&gt;函数之间进行数据交换的一种方法是调用函数向被调用函数提供一个值（称为参数）列
&lt;br&gt;表。函数名后面的一对圆括号将参数列表括起来。在本例中，main 函数不需要任何参数，因
此用空参数表()表示。 &lt;br&gt;&lt;br&gt;函数中的语句用一对花括号{}括起来。本例中的 main 函数仅包含下面一条语句：
&lt;br&gt;printf(&quot;hello, world\n&quot;); 
&lt;br&gt;调用函数时，只需要使用函数名加上用圆括号括起来的参数表即可。上面这条语句将&quot;hello, 
&lt;br&gt;world\n&quot;。作为参数调用 printf 函数。printf 是一个用于打印输出的库函数，在此处，它打印双引号中间的字符串。用双引号括起来的字符序列称为字符串或字符串常量，如&quot;hello,world\n&quot;就是一个字符串。目前我们仅使用字符串作为 printf 及其它函数的参数。&lt;br&gt;&lt;br&gt;在 C 语言中，字符序列\n 表示换行符，在打印中遇到它时，输出打印将换行，从下一行
&lt;br&gt;的左端行首开始。如果去掉字符串中的\n（这是个值得一做的练习），即使输出打印完成后也
不会换行。在 printf 函数的参数中，只能用\n 表示换行符。如果用程序的换行代替\n，例如：
&lt;br&gt;&lt;br&gt;printf(&quot;hello, world 
&lt;br&gt;&quot;); 
&lt;br&gt;&lt;br&gt;C 编译器将会产生一条错误信息。
&lt;br&gt;&lt;br&gt;printf 函数永远不会自动换行，这样我们可以多次调用该函数以分阶段得到一个长的输
&lt;br&gt;出行。上面给出的第一个程序也可以改写成下列形式：
&lt;br&gt;&lt;br&gt;#include &amp;lt;stdio.h&amp;gt; 
&lt;br&gt;main() 
&lt;br&gt;{ 
&lt;br&gt; printf(&quot;hello, &quot;); 
&lt;br&gt; printf(&quot;world&quot;); 
&lt;br&gt; printf(&quot;\n&quot;); 
&lt;br&gt;} 
&lt;br&gt;&lt;br&gt;这段程序与前面的程序的输出相同。
&lt;br&gt;请注意，\n 只代表一个字符。类似于\n 的转义字符序列为表示无法输入的字符或不可见
&lt;br&gt;字符提供了一种通用的可扩充的机制。除此之外，C 语言提供的转义字符序列还包括：\t 表
&lt;br&gt;示制表符；\b 表示回退符；\&quot;表示双引号；\\表示反斜杠符本身。2.3 节将给出转义字符序
列的完整列表。&lt;br&gt;&lt;br&gt;练习 1-1&lt;br&gt;在你自己的系统中运行“hello, world”程序。再有意去掉程序中的部分内容，看看会得到什么出错信息。 &lt;br&gt;练习 1-2 &lt;br&gt;做个实验，当 printf 函数的参数字符串中包含\c（其中 c 是上面的转义
字符序列中未曾列出的某一个字符）时，观察一下会出现什么情况。 &lt;br&gt;————————————————————————&lt;br&gt;&lt;br&gt;原作者：&lt;br&gt;Brian W. Kernighan 
&lt;br&gt;Dennis M. Ritchie&lt;br&gt;ヾ(@゜∇゜@)ノ祝米娜桑愚人节快乐~有什么不好的尽管在评论区提出哦~</description>
<author>A.Scarlet</author>
<guid isPermaLink="false">2018-04-01-35179359</guid>
<pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>C宏元编程:编译期LISP解释器（二）列表操作</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-01-35172411.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35172411&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;目录⇣&lt;br&gt;    &lt;a href=&quot;https://zhuanlan.zhihu.com/p/35121316&quot;&gt;（一）总体思路&lt;/a&gt;&lt;br&gt;⇢&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35172411&quot;&gt;（二）列表操作&lt;/a&gt;&lt;br&gt;外部链接⇣&lt;br&gt;这是一个超级神奇的项目&lt;a href=&quot;https://github.com/BlueFlo0d/CSP&quot;&gt;CSP Git Repo&lt;/a&gt; &lt;/blockquote&gt;&lt;blockquote&gt;纯粹用C宏写的LISP解释器！&lt;br&gt;（目前还没有完成，最重要的lambda已经实现了，cond暂时还有问题嵌套会出错x）&lt;br&gt;（想拉一些小伙伴一起玩一起烧脑呀！可惜似乎人类玩家直接看源码大概率大脑爆栈，于是尝试写了一些文章之类。。原始wiki可以戳这里&lt;br&gt;&lt;a href=&quot;https://github.com/BlueFlo0d/CSP/wiki/Implementation-details&quot;&gt;CSP Wiki&lt;/a&gt; &lt;/blockquote&gt;&lt;p&gt;这次要开始分析真正的Interpreter A原语啦！坐稳啦！&lt;/p&gt;&lt;h2&gt;列表结构&lt;/h2&gt;&lt;p&gt;开始分析LISP操作前我们先来看看CSP中列表的表示：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(a) //我是原子
( (a) (b) (c) (d) ) //我是列表&lt;/code&gt;&lt;p&gt;为什么要这样呢，用下面这种方式不会更自然吗：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;a //我才是原子
(a,b,c,d) //我才是列表&lt;/code&gt;&lt;p&gt;首先第一种方式括号更多，更符合LISP书写传统（划掉&lt;/p&gt;&lt;p&gt;最重要的是第一种方式在迭代列表和安全操作上有很多优点，例如迭代列表我们可以这样实现：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define sth(x) dosth(x) sth_y
#define sth_y(x) dosth(x) sth
sth(a)(b)(c)(d) // =&amp;gt; dosth(a) sth_y(b)(c)(d) ... 
// =&amp;gt; dosth(a) dosth(b) ... sth 或 sth_y （最后剩下一个没展开完的）&lt;/code&gt;&lt;p&gt;最后剩下的那个“尾巴”可以用零点构造或者以下方式“吃掉”：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define _sth(list) CAT(sth list,_end)
#define sth_end
#define sth_y_end
_sth((a)(b)(c)(d)) // =&amp;gt; CAT( dosth(a) ... sth,_end) =&amp;gt; dosth(a) ... sth_end =&amp;gt; dosth(a)&lt;/code&gt;&lt;p&gt;不过零点构造技术在柯里化的多元迭代函数上有更多优点，所以CSP中两者皆有采用。&lt;/p&gt;&lt;p&gt;至于安全性，接下来会提到。&lt;/p&gt;&lt;h2&gt;基本操作：CAR&lt;/h2&gt;&lt;p&gt;CAR：取一个列表第一个元素的操作，LISP基本原语之一&lt;/p&gt;&lt;p&gt;以下是朴素的CAR实现：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define CAR(x) (_CAR x ))
#define _CAR(x) x _n(
CAR ( (a) (b) (c) ) //=&amp;gt;(_CAR (a) (b) (c) )) 
//=&amp;gt; (a _n( (b) (c) )) =&amp;gt; (a)&lt;/code&gt;&lt;p&gt;这里让CAR定义式中的_CAR展开出一个_n(（未匹配左括号），和后面CAR中的未匹配右括号配对，构成一个零宏，从而将第一个元素后的内容都吃掉。&lt;/p&gt;&lt;p&gt;看起来很好是吗？不过实际上完全不能用。因为在CPP中，由于似乎无法实现短路的逻辑判断，条件分支中所有的clause都会先求值再遴选，这样这些clause大部分都会接受非法输入。&lt;/p&gt;&lt;p&gt;那么看看上面的CAR接受非法输入会发生什么：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;CAR(a) //=&amp;gt;(_CAR a)) 破坏括号平衡！
CAR() //=&amp;gt;(_CAR )) 破坏括号平衡！&lt;/code&gt;&lt;p&gt;会将整个展开过程破坏掉！所以我们需要在非法输入下安全的CAR宏。&lt;/p&gt;&lt;p&gt;实现如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define COND_EAT(x) COND_EATY
#define COND_EATY(x) COND_EAT
#define COND_EAT_FIRST(x) COND_EATY
#define SAFE_CAR_N(x) (())_n
#define SAFE_CAR_EAT_CAR )SAFE_CAR_N((
#define COND_EATY_SCEND (a)
#define COND_EAT_SCEND (a)
#define SAFE_CAR(a) _E(_e _SAFE_CAR(a))
#define _SAFE_CAR(a)  _e(_n _n()(CAT(SAFE_CAR_EAT,_E(_e CAR(CAT(COND_EAT_FIRST a,_SCEND)))))(CAR(a)))
//                                                        ^ 对于非法输入展开失败，输出 (_CAR ... ))
//                                                 ^ _E(_e ...) （两个单位宏名，一对括号）会吞掉参数的一对括号. =&amp;gt; _CAR )
//                                 ^ 连接成 SAFE_CAR_EAT_CAR =========\
//                                v 非法输入导致最后那个CAR同样展开失败.   |
// =&amp;gt; _e(_n _n() () SAFE_CAR_N(() (_CAR ... )) )                      &amp;lt;==/
// =&amp;gt; _e( (()) )
// =&amp;gt; (()) 
//代入 SAFE_CAR 中=&amp;gt; _E(_e (()) )=&amp;gt;()输出一个合法的空列表！&lt;/code&gt;&lt;p&gt;解释一下。_SAFE_CAR 宏大体分为前面的判断体_n _n()(CAT(SAFE_CAR_EAT,_E(_e CAR(CAT(COND_EAT_FIRST a,_SCEND))))) 和后面的主体(CAR(a))，以及最外面增加一次扫描次数的单位宏。判断体应当在输入非法时吃掉主体，而合法时自身输出空。&lt;/p&gt;&lt;p&gt;首先看到 CAT(COND_EAT_FIRST a,_SCEND)，这个目的是把所有形如(b)((c)(d))...之类的合法a值约化为(a)以方便判断体逻辑（否则可能会有很多嵌套列表，难以操作），而将不合法输入约化为一个不含括号的字符串。&lt;/p&gt;&lt;p&gt;此后交由CAR，对于不合法输入会输出形如(_CAR ...))，吞掉一对括号后与SAFE_CAR_EAT连成SAFE_CAR_EAT_CAR，再展开成熟悉的)SAFE_CAR_N((这种未匹配括号形式影响展开过程（多出一个左括号是为了和后面CAR展开失败输出的多余右括号匹配）。而对于合法输入，则直接被_n _n() (...) 吞掉。&lt;/p&gt;&lt;p&gt;SAFE_CDR采用类似思路实现。&lt;/p&gt;&lt;p&gt;好累啊就主要部分先写这么多吧，接下来稍微扯一下CSP解释器A中怎么处理多元函数的&lt;/p&gt;&lt;h2&gt;CSP解释器A中的柯里化&lt;/h2&gt;&lt;p&gt;之前提过的两个宏交替展开非常好，但似乎无法处理需要两个参数的do_sth。&lt;/p&gt;&lt;p&gt;其实可以通过柯里化解决，不过这样展开次数始终会缺一次所以还是得外置一组单位宏来延迟展开。&lt;/p&gt;&lt;p&gt;柯里化技巧的核心：ZIP宏&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define _be(y) y)
#define ZIP(x)   _n() (x,_be //This _n() delays the expansion of do_sth macro, after _be is expanded. otherwise it will an unmatched bracket error. 
do_sth ZIP(a)(b) =&amp;gt;do_sth _n()(a,_be(b)&lt;/code&gt;&lt;p&gt;如果外面再加一个单位宏强制增加一次扫描，就会变成：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;do_sth (a,b)&lt;/code&gt;&lt;p&gt;这样，一个签名为do_sth(a,b)的二元宏，就可以通过ZIP封装为do_sth ZIP，一个接受一元输入，输出一个一元宏的宏，从而能够处理一个CSP列表的前两项。&lt;/p&gt;&lt;p&gt;在CSP实现中，通常将参数放在待迭代列表前：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(arg)(a)(b)(c)....&lt;/code&gt;&lt;p&gt;do_sth实现为处理(arg,a)，并将arg放在处理结果之后，然后进行递归：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;do_sth (arg)
=&amp;gt; real_do_sth(arg,a) do_sth_y (arg) 
do_sth (arg)(a)(b)(c)
=&amp;gt; real_do_sth(arg,a) do_sth_y (arg) (b)(c)&lt;/code&gt;&lt;p&gt;这样就实现了带参数的迭代列表操作。&lt;/p&gt;</description>
<author>K.Scarlet</author>
<guid isPermaLink="false">2018-04-01-35172411</guid>
<pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>C++函数式实现BST、线段树(单点修改)（1）</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-01-35114696.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35114696&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1942006d5b24fedc190cafc1338070f4_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;偶然看到Common Lisp(&lt;b&gt;CL&lt;/b&gt;)中BST的写法，又联想到了自己写过的单点修改的主席树，觉得这两者几乎差不多，因此拿来分享一下，也顺便应该能解决一下为什么主席树又有一个“函数式版本的线段树”名称&lt;/p&gt;&lt;p&gt;本来打算直接用CL写的......但是想到可能很多人并不熟悉CL，于是就用C++代替了。&lt;/p&gt;&lt;p&gt;目前只打算写单点更新的线段树，而至于区间更新的需要打lazy tag，我需要去学习一下区间更新的主席树再来更新......&lt;/p&gt;&lt;p&gt;本来想完整的写完，但是想到一次性写完可能显得会太长而导致太长不看的可能，所以还是留线段树到下一次吧。&lt;/p&gt;&lt;p&gt;本篇前置知识：BST(Binary Search Tree，二叉搜索树)，C++基本语法&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Part I： 函数式风格几个important properties(此段引用自Land Of Lisp, Ch14, &quot;What is Functional Programming?&quot;)&lt;/p&gt;&lt;ul&gt;&lt;li&gt;只要传入的参数相同，函数总是返回同样的结果。The function always returns the same result, as long as the same arguments are passed into it. &lt;/li&gt;&lt;li&gt;函数不会引用定义在函数外部的变量，除非那个变量是常量。The function never references variables that are defined outside the function, unless we are certain that these variables will remain constant.&lt;/li&gt;&lt;li&gt;函数不会修改变量的值。No variables are modified by the function.&lt;/li&gt;&lt;li&gt;函数除了返回(动词)值以外什么也不干。(原谅本人直译......)The purpose of the function is to do nothing other than to return a result.&lt;/li&gt;&lt;li&gt;函数不会对外界造成任何改变。The function doesn’t do anything that is visible to the outside world, such as pop up a dialog box on the screen or make your computer go &quot;Bing!&quot;&lt;/li&gt;&lt;li&gt;The function doesn&#39;t take information from an outside source, such as&lt;br&gt;the keyboard or the hard drive.&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;p&gt;Part II：函数式的BST实现 &lt;/p&gt;&lt;p&gt;(new完没有delete)&lt;/p&gt;&lt;p&gt;用到的语法知识有：C++ explicit，nullptr，初始化列表，全局变量默认值&lt;/p&gt;&lt;p&gt;BST中节点的定义(注意声明了一个类型为Node*的全局变量root)&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;struct Node{
    int v;
    Node* le,*ri;
    explicit Node(int value=0,Node* lef=nullptr,Node* righ=nullptr)
            :v(value),le(lef),ri(righ){};
}*root;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;BST的插入：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;Node* bst_insert(int value,Node* bst){
    if(bst==nullptr)
        return new Node(value);
    if(value==bst-&amp;gt;v)
        return bst;
    else if(value&amp;lt;bst-&amp;gt;v)
        return new Node(bst-&amp;gt;v,bst_insert(value,bst-&amp;gt;le),bst-&amp;gt;ri);
    else
        return new Node(bst-&amp;gt;v,bst-&amp;gt;le,bst_insert(value,bst-&amp;gt;ri));
}&lt;/code&gt;&lt;p&gt;接下来讲解bst_insert：&lt;/p&gt;&lt;p&gt;（1）此方法接受一个value，即待插入的值，以及一个Node*，代表&lt;b&gt;当前&lt;/b&gt;的bst的root，因此一开始使用时传入root&lt;/p&gt;&lt;p&gt;（2）此方法前两种情况为简单情况，一个是&lt;b&gt;当前&lt;/b&gt;bst为空时，则返回一个新的、值为value的、左右子都为nullptr的节点。另一个是发现待插入的值和当前节点相等时，为避免重复直接返回自己。(其实这一步可以不要，不过，anyway，这反正不是重点......)&lt;/p&gt;&lt;p&gt;（3）第三种情况和第四种情况是对称的，看到第三种情况，是当前插入的值小于&lt;b&gt;当前&lt;/b&gt;bst的root，那么就返回一个新节点，这个新节点的值是&lt;b&gt;当前&lt;/b&gt;bst的root值，左子是在&lt;b&gt;当前&lt;/b&gt;root的左子上调用bst_insert的返回值，右子是&lt;b&gt;当前&lt;/b&gt;root的右子。&lt;/p&gt;&lt;p&gt;（4）第四种情况把上面的“小于”换成大于，“左”换成“右”，“右”换成“左”&lt;/p&gt;&lt;p&gt;画个图理解一下(纯手绘...请将就着看吧)&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-40276c163ce177a0876ca5d82e20c3c1_r.jpg&quot; data-caption=&quot;考虑在该树上插入新元素 9.5&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;651&quot; data-watermark-src=&quot;v2-3d90af0c145d21db9f50fdc41db4e48b&quot;&gt;&lt;p&gt;第一次调用bst_insert为bst_insert(9.5,root)&lt;/p&gt;&lt;p&gt;返回值是new Node(10,bst_insert(9.5,root-&amp;gt;le),root-&amp;gt;ri)&lt;/p&gt;&lt;p&gt;在途中需要求出bst_insert(9.5,root-&amp;gt;le)的值来完成构造函数，因此&lt;/p&gt;&lt;p&gt;第二次调用bst_insert为bst_insert(9.5,root-&amp;gt;le)&lt;/p&gt;&lt;p&gt;返回值是new Node(8,root-&amp;gt;le-&amp;gt;le,bst_insert(9.5,root-&amp;gt;le-&amp;gt;ri))&lt;/p&gt;&lt;p&gt;在途中需要求出bst_insert(9.5,root-&amp;gt;le-&amp;gt;ri)来完成构造函数，因此&lt;/p&gt;&lt;p&gt;第三次调用bst_insert为bst_insert(9.5,root-&amp;gt;le-&amp;gt;ri)&lt;/p&gt;&lt;p&gt;返回值是new Node(9,root-&amp;gt;le-&amp;gt;ri-&amp;gt;le,bst_inseret(9.5,root-&amp;gt;le-&amp;gt;ri-&amp;gt;ri))&lt;/p&gt;&lt;p&gt;在途中需要求出bst_inseret(9.5,root-&amp;gt;le-&amp;gt;ri-&amp;gt;ri)来完成构造函数，因此&lt;/p&gt;&lt;p&gt;第四次调用bst_insert为bst_inseret(9.5,root-&amp;gt;le-&amp;gt;ri-&amp;gt;ri)&lt;/p&gt;&lt;p&gt;但是root-&amp;gt;le-&amp;gt;ri-&amp;gt;ri为nullptr，因此会直接返回Node(9.5)，因此返回过程如下&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-03814a87e336d4e4212d6d4a06ab87f2_r.jpg&quot; data-caption=&quot;途中的次序表示第几次的返回值，黑线表示连接到了原来的节点&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1633&quot; data-watermark-src=&quot;v2-1f9d2e3dc03b5a53f6dc7c2312660ef3&quot;&gt;&lt;p&gt;我们可以发现，插入的返回值就是一条链，代表的是从真正的root节点一直到被插入的地方的链，其余的节点都是连接到的原来的节点上。因此我们只要令root等于第一次调用bst_insert的返回值就OK了。&lt;/p&gt;&lt;p&gt;可以发现，这其中我们并没有对原来bst上进行修改，而是创建了一条新链，而让这条链和之前的bst共用某些节点。(单点更新的主席树！)&lt;/p&gt;&lt;p&gt;这个联系留到下一次再发。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;BST插入的使用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;int main(){
    srand(time(0));
    for(int i=0;i&amp;lt;10;++i)
        root=bst_insert(rand()%100,root);
    dfs(root);//随便遍历一下，表明it works pretty well. 2333333333
    return 0;
}

void dfs(Node* bst){
    if(bst!=nullptr){
        cout&amp;lt;&amp;lt;bst-&amp;gt;v&amp;lt;&amp;lt;&#39; &#39;;
        dfs(bst-&amp;gt;le);dfs(bst-&amp;gt;ri);
    }
}&lt;/code&gt;&lt;hr&gt;&lt;p&gt;Part III：其他&lt;/p&gt;&lt;p&gt;我觉得我应该把函数式删除拿出来写一个番外篇...这毕竟和写作本文的主旨没有关联。&lt;/p&gt;&lt;p&gt;本篇中的BST完整代码:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Hatsunespica/CL/blob/master/Melange/f_bst.cpp&quot;&gt;https://github.com/Hatsunespica/CL/blob/master/Melange/f_bst.cpp&lt;/a&gt;&lt;/p&gt;&lt;p&gt;假如觉得有什么地方写的错误或不好or可以改进的地方，请尽管提出来。&lt;/p&gt;</description>
<author>Spica</author>
<guid isPermaLink="false">2018-04-01-35114696</guid>
<pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>C宏元编程:编译期LISP解释器（一）总体思路</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-30-35121316.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35121316&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一个超级神奇的项目 &lt;a href=&quot;https://github.com/BlueFlo0d/CSP&quot;&gt;CSP GIt Repo&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对！纯粹用C宏-那个只支持字符串替换和粘贴的东西-写的LISP解释器！&lt;/p&gt;&lt;p&gt;（目前还没有完成，最重要的lambda已经实现了，cond暂时还有问题嵌套会出错x）&lt;/p&gt;&lt;p&gt;（想拉一些小伙伴一起玩一起烧脑呀！可惜似乎人类玩家直接看源码大概率大脑爆栈，于是尝试写了一些文章之类。。原始wiki可以戳这里 &lt;a href=&quot;https://github.com/BlueFlo0d/CSP/wiki/Implementation-details&quot;&gt;CSP Wiki&lt;/a&gt;&lt;/p&gt;&lt;p&gt;那么现在就开始玩转（abuse）C宏定义的神奇（ドM）之旅吧！&lt;/p&gt;&lt;h2&gt;总体思路&lt;/h2&gt;&lt;p&gt;C宏定义想必大家都熟悉，姑且展开最天马行空的想象，进行LISP的列表操作（CAR CDR CONS之类）应该是可行的，First-class function某种程度上似乎也可行（传递宏名），比如这个例子：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define E(...) __VA_ARGS__ //单位宏
#define N(...) //零宏
#define __test(something,k,...) k(do something)
#define _test(something,...) __test(something,E)
_test(testit) // =&amp;gt; __test(testit,E) =&amp;gt; E(do testit) =&amp;gt; do testit
_test(E(N,N)) // =&amp;gt; __test(N,N,E) =&amp;gt; N(do N) =&amp;gt;
//_test(E(N,N))的输出消失了！&lt;/code&gt;&lt;p&gt;这个例子中我们看到我们将零宏和单位宏作为参数传入，并使得_test（封装 __test）具有一个零点 E(N,N)。这个技巧（私货！）在CSP的实现中经常用到！记笔记！&lt;/p&gt;&lt;p&gt;但是要实现lambda。。似乎纯粹的C宏很难做到（比如要把参数代入匿名函数体。。咋整啊）。。&lt;/p&gt;&lt;p&gt;不过别忘了神奇的LISP是可以实现自解释的！也就是可以用没有lambda语义的LISP解释器来实现完整的LISP解释器。&lt;/p&gt;&lt;p&gt;CSP的实现就按照了这个思路，首先实现解释器A（其实就是加载了一组实现LISP原语宏的C预处理器），然后再在解释器A上实现完整的LISP自解释器B。以下是自解释器的源码（不是最新的x 最新的在纠结那个有问题的cond）&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;//Line 176, csp.h
#define $zipped_eval(e,a) COND(\
        (ATOM e (EVAL_e $zipped_assoc(e,a)))    \
        (ATOM SAFE_CAR e \
         COND(($eq(SAFE_CAR e (quote))EVAL_e(SAFE_CAR SAFE_CDR e))  \
              ($eq(SAFE_CAR e (atom)) (EVAL_e ATOM\
              DELAY_INT_23($zipped_eval_R)() (SAFE_CAR SAFE_CDR e,a))) \
              ($eq(SAFE_CAR e (eq)) (EVAL_e $eq( DELAY_INT_25($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR e,a) DELAY_INT_25($zipped_eval_R)() \
              (SAFE_CAR SAFE_CDR SAFE_CDR e,a)))) \
              ($eq(SAFE_CAR e (car)) (EVAL_e SAFE_CAR DELAY_INT_23($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR e,a))) \
              ($eq(SAFE_CAR e (cdr)) (EVAL_e SAFE_CDR DELAY_INT_23($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR e,a))) \
              ($eq(SAFE_CAR e (cons)) (EVAL_e CONS DELAY_INT_23($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR e,a) DELAY_INT_23($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR SAFE_CDR e,a))) \
              ((T)(EVAL_e DELAY_INT_23($zipped_eval_R)()\
               (($zipped_assoc(SAFE_CAR e,a) EVAL_e SAFE_CDR e),a))) \
                 )                                                      \
                )                                                       \
        ($eq(SAFE_CAR SAFE_CAR e (lambda))\
        (DELAY_INT_26(EVAL_e_R)() DELAY_INT_23($zipped_eval_R)()(\
        EVAL_e(EVAL_e(EVAL_e(EVAL_e(SAFE_CAR SAFE_CDR SAFE_CDR SAFE_CAR e)))),\
        EVAL_e(APPEND DELAY_INT_13($pair_R)()(EVAL_e(EVAL_e(EVAL_e(SAFE_CAR SAFE_CDR SAFE_CAR e)))\
        (DELAY_INT_19($zipped_evlis_R)()(EVAL_e(_e EVAL_e(SAFE_CDR e)), a)))a)))\
        )                                                               \
)&lt;/code&gt;&lt;p&gt;是不是似曾相识啊23333&lt;/p&gt;&lt;p&gt;典型的自解释器实现。大家注意到这里：&lt;/p&gt;&lt;p&gt;1）有很多SAFE_XXX之类的东西，将来会解释。（C宏处理似乎难以实现短路condition，导致经常会对非法表达式进行求值，这种情况下使用naive的原语宏是会出事的-原地报错／破坏括号平衡-所以必须要很麻烦地一个一个实现为对于非法输入仍能给出合法结果的宏）&lt;/p&gt;&lt;p&gt;2）很多EVAL_e。这是一个单位宏，单位宏和零宏在C宏展开中作用非常大，因为可以用它们微调宏的展开顺序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define _CAT(x,y) x##y
#define CAT(x,y) _CAT(x,y) //典型的连接
//_e是一个单位宏，_n是一个零宏
#define b() )x(
_n(b()) //先展开_n再展开b，什么都没有了x
_e(_n _n()(b())) // =&amp;gt;_n()x() =&amp;gt; x()
//先展开b再展开_n&lt;/code&gt;&lt;p&gt;因为CPP展开_&lt;i&gt;e&lt;/i&gt;时对其括号内字符串调用展开过程（所以单位宏可以用来增加一次展开扫描过程），这个时候b会被展开，但第一个_n后面没有左括号不会展开，所以会先展开中间的_n()，下一次扫描时才第一个_n和左括号连起来被展开。&lt;/p&gt;&lt;p&gt;（是不是有些tricky？这是Lv0啦～等不及的可以自己看一下csp.h 2333如果能全部看懂帮我写文章吧qwq）&lt;/p&gt;&lt;p&gt;3) DELAY_INT_xxx(xxx_R)()(...) 这个是著名的延迟展开技巧，DELAY_INT_xxx定义如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define DELAY_REF(x) x _n()
#define DELAY_REF_2(x) x _n()
#define DELAY_INT_2(x) DELAY_REF(DELAY_REF_2)(x)
#define DELAY_INT_3(x) DELAY_REF(DELAY_INT_2)(x)
#define DELAY_INT_4(x) DELAY_REF(DELAY_INT_3)(x)
#define DELAY_INT_5(x) DELAY_REF(DELAY_INT_4)(x)
...&lt;/code&gt;&lt;p&gt;结合2）容易理解这样 DELAY_INT_n(xxx_R)() 每次扫描n会减一，直到“露出” xxx_R与后面的()结合，习惯上定义：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define xxx_R() xxx&lt;/code&gt;&lt;p&gt;这样xxx就被展开出来与参数列表结合，起到任意调节宏展开顺序的作用。&lt;/p&gt;&lt;p&gt;此外这个还被用于宏的递归。由于蓝色集合的限制，像这样的宏是不能实现递归的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define I_want_recursion(x) do_it(x) I_want_recursion(x)
I_want_recursion(x) //=&amp;gt;do_it(x) I_want_recursion(x)
//CPP认为它属于已经处理过的字符串于是就不会再展开了^
_e(I_want_recursion(x))//=&amp;gt;do_it(x) I_want_recursion(x)
//扫描多少遍都没有用！&lt;/code&gt;&lt;p&gt;但是可以这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define I_want_recursion_R() I_want_recursion
#define I_want_recursion(x) do_it(x) DELAY_REF(I_want_recursion_R)()(x)
I_want_recursion(x) //=&amp;gt;do_it(x) I_want_recursion_R()(x)
_e(I_want_recursion(x)) //=&amp;gt;do_it(x) do_it(x) I_want_recursion_R()(x)
//因为这次I_want_recursion是由I_want_recursion_R()新造出来的token所以可以继续展开下去&lt;/code&gt;&lt;p&gt;不过这样需要在外面套足够多的单位宏来进行足够次数的扫描。。。CSP中有一部分使用零点构造技术更优雅地实现了递归，将来会写的x&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这次就先写这些吧，下次写解释器A的列表操作实现和Currying？&lt;/p&gt;</description>
<author>K.Scarlet</author>
<guid isPermaLink="false">2018-03-30-35121316</guid>
<pubDate>Fri, 30 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Programming Languages: Application and Interpretation【译15中】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-30-35115633.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35115633&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b71b632ed7974538bb2e812bcd20914e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;初翻： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/9bebf466fc2535bec442451dca7cd13a&quot; data-hash=&quot;9bebf466fc2535bec442451dca7cd13a&quot; data-hovercard=&quot;p$b$9bebf466fc2535bec442451dca7cd13a&quot;&gt;@lotuc&lt;/a&gt; &lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;https://lotuc.gitbooks.io/plai-cn/content/&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;15.3 对核心的扩展&lt;/h2&gt;&lt;p&gt;现在我们已经有了基础的静态类型语言，下面探索一下如何将其扩展成为更有用的编程语言。&lt;/p&gt;&lt;h2&gt;15.3.1 显式的参数多态&lt;/h2&gt;&lt;p&gt;&lt;b&gt;下面哪些是相同的？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;(listof string)&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;事实上，上面任何两个都不太一样。但是第一个和第三个非常相似，因为第一个是Java代码而第三个是我们的静态语言代码，而第二个，是C++代码，和其它两个不同。清楚了吗？不清楚？很好，继续往下读！&lt;/p&gt;&lt;h2&gt;15.3.1.1 参数化类型&lt;/h2&gt;&lt;p&gt;我们所使用的编程语言已经展示了参数多态的价值，例如，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;函数的类型可以这样给出：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((&#39;a -&amp;gt; &#39;b) (listof &#39;a) -&amp;gt; (listof &#39;b))&lt;/code&gt;&lt;p&gt;意思是，对于任意类型&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;读入一个从&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;到&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;的函数，一个&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;的链表，生成对应的&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;的链表。这里，&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;不是具体的类型；它们是&lt;b&gt;类型变量&lt;/b&gt;（我们的术语中，这应该被称为“类型标识符”，因为它们在实例化过程中不会变化；但是我们还是使用传统术语）。&lt;/p&gt;&lt;p&gt;可以换种方式理解它：实际上有一族无穷多的这样的&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;函数。例如，其中一个&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;的类型是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((number -&amp;gt; string) (listof number) -&amp;gt; (listof string))&lt;/code&gt;&lt;p&gt;另一个的类型是这样的（没有限制说其中的类型必须是基本类型）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((number -&amp;gt; (number -&amp;gt; number)) (listof number) -&amp;gt; (listof (number -&amp;gt; number)))&lt;/code&gt;&lt;p&gt;还有这样的（也没有限制说&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;必须不同）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((string -&amp;gt; string) (listof string) -&amp;gt; (listof string))&lt;/code&gt;&lt;p&gt;以此类推。由于它们的类型不同，名字也需要不同：&lt;code class=&quot;inline&quot;&gt;map_num_str&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;map_num_num-&amp;gt;num&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;map_str_str&lt;/code&gt;等。但是这会让它们变成不同的函数，于是我们总得使用某个特定&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;，而不是直接使用比较一般的那个。&lt;/p&gt;&lt;p&gt;显然，不可能将所有这些函数放到我们的标准库中：毕竟它们有无穷多个！更好的方式是能按需获取我们需要的函数。我们的命名规则给出了一点提示：&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;接受两个&lt;b&gt;参数&lt;/b&gt;，它们都是&lt;b&gt;类型&lt;/b&gt;。给定了两个类型作为参数，我们可以得到针对特定类型的&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;函数。这种&lt;b&gt;类型的参数化&lt;/b&gt;被称为&lt;b&gt;参数多态&lt;/b&gt;。&lt;/p&gt;&lt;blockquote&gt;注意不要和对象“多态”搞混，后面会讨论它。&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;15.3.1.2 显式声明类型参数&lt;/h2&gt;&lt;p&gt;换句话说，我们相当于说&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;实际上是有四个参数的函数，其中两个是类型，另外两个是实际的值（函数和链表）。在需要显式声明类型的语言中，我们需要写成类似这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (map [a : ???] [b : ???] [f : (a -&amp;gt; b)] [l : (listof a)]) : (listof b)
  ...)&lt;/code&gt;&lt;p&gt;但是这会产生一些问题。首先，&lt;code class=&quot;inline&quot;&gt;???&lt;/code&gt;处应该填什么？它是&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;的类型。但是如果a和b本身将被&lt;b&gt;类型&lt;/b&gt;替换，那么类型的类型是什么？其次，我们真的希望每次调用map的时候传入四个参数吗？再者，我们真的希望在接收任何实际值之前先接收类型参数吗？对于这些问题的答案能延伸出关于多态类型系统巨大的讨论空间，其中的大部分我们这里将&lt;b&gt;不&lt;/b&gt;会涉及。&lt;/p&gt;&lt;blockquote&gt;推荐阅读Pierce的《Types and Programming Languages(类型和编程语言)》，获取易懂、现代的介绍。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;注意到一旦我们引入参数化，很多预期之外的代码都将被参数化。例如，考虑平平无奇的&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;函数的类型。它的类型需要基于链表中值的类型进行参数化（尽管它实际上并不依赖于这些值——稍后会解释这一点），于是每次使用&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;时都需要正确地进行类型实例化。说到这，即使用&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;创建空链表也必须类型实例化！当然，Java和C++程序员应该对这个痛点很熟悉了。&lt;/p&gt;&lt;h2&gt;15.3.1.3 一阶多态&lt;/h2&gt;&lt;p&gt;我们将只讨论这个空间中一个特别有用且易于理解的点上，也即 Standard ML 的类型系统、同时是本书使用的静态类型语言和早期版本的 &lt;br&gt;Haskell 的类型系统，有范型加成的 Java 和 C# 以及引入了模版的C++ &lt;br&gt;也差不多获得了这种类型系统的大部分能力。这类语言定义了被称为&lt;b&gt;谓词&lt;/b&gt;、&lt;b&gt;一阶&lt;/b&gt;或者叫&lt;b&gt;前缀&lt;/b&gt;多态的东西。关于上小节的问题它的答案是不填、没有、是。下面我们来探讨一下。&lt;/p&gt;&lt;p&gt;我们首先将类型的世界分成两组。第一组包含我们目前用到的静态类型语言，另外加上类型变量；它们被称为 &lt;b&gt;monotype（单型）&lt;/b&gt;。第二组包含参数化的类型，被称为 &lt;b&gt;polytype（多型）&lt;/b&gt;；按惯例它们是这样写的：&lt;code class=&quot;inline&quot;&gt;∀&lt;/code&gt;前缀，一组类型变量，再跟一个类型表达式，表达式中可以使用这些类型变量。因此，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;的类型将写作：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;∀ a, b : ((&#39;a -&amp;gt; &#39;b) (listof &#39;a) -&amp;gt; (listof &#39;b))&lt;/code&gt;&lt;p&gt;由于“&lt;code class=&quot;inline&quot;&gt;∀&lt;/code&gt;”是逻辑符号“对于所有的”的意思，于是上面的东西可以读作：“对于所有类型&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;的类型为……”。&lt;/p&gt;&lt;p&gt;在一阶多态（rank-1 polymorphism）中，类型变量只能被&lt;code class=&quot;inline&quot;&gt;monotype&lt;/code&gt;替换。（此外，它们只能被具体类型替换，否则剩下的类型变量将无法被替换掉。）因此，在类型变量参数和常规参数之间我们有了明确的界线。我们不需要为类型变量提供“类型注解”，因为我们知道它们可以是什么。这样得到的语言相对简洁，但仍提供了相当的表达能力。&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;非直谓性&lt;/b&gt;语言（&lt;a href=&quot;https://en.wikipedia.org/wiki/Impredicativity&quot;&gt;Impredicative&lt;/a&gt; language）取消了&lt;code class=&quot;inline&quot;&gt;monotype&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;polytype&lt;/code&gt;的区别，因此类型变量可以使用另一个多态类型实例化。&lt;/blockquote&gt;&lt;p&gt;注意到由于类型变量只能被&lt;code class=&quot;inline&quot;&gt;monotype&lt;/code&gt;替换，他们全相互对立。于是，类型参数可以全被提到参数表的前面。这使我们可以使用形如&lt;code class=&quot;inline&quot;&gt;∀ tv, ... : t&lt;/code&gt;的类型，其中&lt;code class=&quot;inline&quot;&gt;tv&lt;/code&gt;是类型变量，&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;monotype&lt;/code&gt;（其中可以引用这些类型变量）。此语法的意义就在这里，这也是之前称其为前缀多态的原因。而且后面也将看到这对其实现也很有用。&lt;/p&gt;&lt;h2&gt;15.3.1.4 通过去语法糖实现一阶多态解释器&lt;/h2&gt;&lt;p&gt;该特性最简单的实现就是将其视为一种去语法糖的形式：C++ 实际上就是这么做的。（具体来说，因为 C++ 有一个叫做模版的宏系统，所以使用模版，它非常巧合地达成了一阶多态。）举个例子，如果我们有一个语法形式&lt;code class=&quot;inline&quot;&gt;define-poly&lt;/code&gt;，它接收名字、类型变量和表达式。当传入类型的时候，它将表达式中对应类型变量替换为此类型，因此：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-poly (id t) (lambda ([x : t]) : t x))&lt;/code&gt;&lt;p&gt;通过将&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;定义为多态的方式定义了一个恒等（identity）函数：给&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;传入递任意具体类型，就得到一个单参数的类型为&lt;code class=&quot;inline&quot;&gt;(t -&amp;gt; t)&lt;/code&gt;的函数（其中&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;被替换）。我们可以使用各种类型实例化&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define id_num (id number))
(define id_str (id string))&lt;/code&gt;&lt;p&gt;从而获得针对这些类型的恒等函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (id_num 5) 5)
(test (id_str &quot;x&quot;)  &quot;x&quot;)&lt;/code&gt;&lt;p&gt;与之相对，像&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(id_num &quot;x&quot;)
(id_str 5)&lt;/code&gt;&lt;p&gt;这样的表达式将&lt;b&gt;不能通过类型检查&lt;/b&gt;（而不是运行时出错）。&lt;/p&gt;&lt;p&gt;如果你好奇的话，下面给出了实现。简单起见，我们假设只有一个类型参数；很容易使用&lt;code class=&quot;inline&quot;&gt;...&lt;/code&gt;实现多个参数的情形。我们不仅将&lt;code class=&quot;inline&quot;&gt;define-poly&lt;/code&gt;定义为宏，&lt;b&gt;它&lt;/b&gt;还会定义宏：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax define-poly
  (syntax-rules ()
    [(_ (name tyvar) body)
     (define-syntax (name stx)
       (syntax-case stx ()
         [(_ type)
          (with-syntax ([tyvar #&#39;type])
            #&#39;body)]))]))&lt;/code&gt;&lt;p&gt;因此，对于：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-poly (id t) (lambda ([x : t]) : t x))&lt;/code&gt;&lt;p&gt;该语言将创建名为&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的&lt;b&gt;宏&lt;/b&gt;：对应&lt;code class=&quot;inline&quot;&gt;(define-syntax (name ...) ...)&lt;/code&gt;的部分（对于这个例子，&lt;code class=&quot;inline&quot;&gt;name&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;）。&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的一个实例，如&lt;code class=&quot;inline&quot;&gt;(id number)&lt;/code&gt;，将类型变量&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;、宏里面的&lt;code class=&quot;inline&quot;&gt;typvar&lt;/code&gt;替换成给定的类型。因为要规避卫生，我们用&lt;code class=&quot;inline&quot;&gt;with-syntax&lt;/code&gt;来确保所有对于类型变量（typvar）的使用被替换为给定的类型。因此，实际效果是，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define id_num (id number))&lt;/code&gt;&lt;p&gt;被转换成了&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define id_num (lambda ([x : number]) : number x))&lt;/code&gt;&lt;p&gt;然而这种方式有两个重大局限性：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;来试试定义递归的多态函数，比如说&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;。之前我们说过，每个多态值（例如&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;）都需要类型实例化，但是为了简洁起见我们将依赖静态类型语言实现这点，而仅专注于&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;的类型参数。对应代码是：&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;(define-poly (filter t)&lt;br&gt;  (lambda ([f : (t -&amp;gt; boolean)] [l : (listof t)]) : (listof t)&lt;br&gt;    (cond&lt;br&gt;      [(empty? l) empty]&lt;br&gt;      [(cons? l) (if (f (first l))&lt;br&gt;                     (cons (first l)&lt;br&gt;                           ((filter t) f (rest l)))&lt;br&gt;                     ((filter t) f (rest l)))])))&lt;/p&gt;&lt;blockquote&gt;注意到递归的使用&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;时，必须使用恰当的类型对其实例化。&lt;/blockquote&gt;&lt;p&gt;上面的定义完全正确，只有一个问题，当我们尝试使用它时——如：&lt;/p&gt;&lt;p&gt;(define filter_num (filter number))&lt;/p&gt;&lt;blockquote&gt;DrRacket 将不会终止，更准确的说，是宏展开不会终止，因为它将不断的尝试创建&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;&lt;b&gt;代码的副本&lt;/b&gt;。不过如果用下面这种方式定义该函数，展开会终止——&lt;/blockquote&gt;&lt;p&gt;(define-poly (filter2 t)&lt;br&gt;  (letrec ([fltr&lt;br&gt;            (lambda ([f : (t -&amp;gt; boolean)] [l : (listof t)]) : (listof t)&lt;br&gt;              (cond&lt;br&gt;                [(empty? l) empty]&lt;br&gt;                [(cons? l) (if (f (first l))&lt;br&gt;                               (cons (first l) (fltr f (rest l)))&lt;br&gt;                               (fltr f (rest l)))]))])&lt;br&gt;    fltr))&lt;/p&gt;&lt;blockquote&gt;但是这给开发人员徒增了不必要的痛苦。实际上，一些模版展开程序会缓存之前展开的值，避免对于相同的参数反复生成代码。（Racket &lt;br&gt;做不到这点，因为一般来说，宏表达式可以依赖可变变量和值，甚至可以执行输入输出，因此 Racket 无法保证同样的输入表达式总是产生相同输出。）&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;考虑恒等函数的两个实例。我们无法比较&lt;code class=&quot;inline&quot;&gt;id_num&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;id_str&lt;/code&gt;，因为它们类型不同，但即使它们类型相同，使用&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;比较它们也不同：&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;(test (eq? (id number) (id number)) #f)&lt;/p&gt;&lt;blockquote&gt;这是因为对&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;每次实例化都会创建一份新的代码副本。即使使用了上面提到的优化，&lt;b&gt;同一种&lt;/b&gt;类型对应代码只有一份副本，但是不同类型的对应代码体还是会被重新生成【注释】——但这也是没必要的！例如，&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的实现的部分其实没任何东西依赖于参数的类型。实际上，&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;这一族无穷多个的函数可以共享同一个实现。简单的去语法糖策略实现不了这点。&lt;/blockquote&gt;&lt;p&gt;事实上，&lt;code class=&quot;inline&quot;&gt;C++&lt;/code&gt;模版因代码膨胀的问题而臭名昭著，这是原因之一。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;换种说法，基于去语法糖的策略本质上是使用替换的实现方式，它有着和我们之前函数调用时使用替换的方式实现相同的问题。不过，其它情况下，替换策略能达成我们关于程序行为的期望；对于多态也是一样，正如我们将看到的一样。&lt;/p&gt;&lt;p&gt;注意去语法糖策略的一个好处就是它不需要类型检查器“理解”多态。我们的核心语言仍可以是单态的（monomorphic），所有的（一阶）多态完全由宏展开处理。这提供了一种廉价的将多态添加到语言中的策略，但正如C++所示，它也引入了很大的开销。&lt;/p&gt;&lt;p&gt;最后，虽然这里我们只关注了函数，但前面的讨论同样适用于数据结构。&lt;/p&gt;&lt;h2&gt;15.3.1.5 其它实现方式&lt;/h2&gt;&lt;p&gt;有些其他实现策略不会遇到此类问题。这里我们不会深入讲解它们，但是其中一些策略的本质就是上面提到过的“缓存”方法。因为可以确定的是，对于给定的同一组类型参数，应该得到相同的实现代码，不需要对相同的类型参数实例化多次。这避免了无限循环。如果我们检查了使用特定类型实例化的代码一次，后续相同类型参数的实例化结果就无需再进行类型检查（因为它不会发生改变）。此外，我们无需保留实例化后的源码：一旦我们检查了展开后的程序，就可以将其丢弃，运行时也只需要保留一份实例化的副本。这样可以避免上述纯去语法糖策略中讨论过的所有问题，同时保留它的好处。&lt;/p&gt;&lt;p&gt;其实我们有点过分了。静态类型的好处之一就是能选择更精确的运行时表示。例如，静态类型可以告诉我们用的是数是32位的还是64位的甚至1位的（也就是布尔值）。然后编译器可以利用位的布局方式（例如，32个布尔值可以**打包*进一个32位字）为每种表示生成专用代码。因此，在对每种使用的类型进行检查之后，多态实例化程序可以跟踪函数或数据结构使用时用到的特定类型，并将这些信息提供给编译器用于代码生成。这会导致生成相关函数的若干副本，彼此都互不&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;——但这么做有充分的理由，因为它们要执行的操作的确不同，所以这是正确的。&lt;/p&gt;&lt;h2&gt;15.3.1.6 关系型参数&lt;/h2&gt;&lt;p&gt;我们还需解决关于多态的最后一个细节。&lt;/p&gt;&lt;p&gt;早先我们说过像&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;这样的函数不依赖于其参数的具体值。这一点对&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;等也成立。&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;接收一个函数作为参数，当它们要对单个元素进行操作时，实际上使用该函数进行操作，即该函数负责做出如何处理元素的决定；&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;本身只是遵从该函数参数。&lt;/p&gt;&lt;p&gt;“检验”这种情况是否属实的一种方法是，替换不同类型的值链表及对应的函数作为参数。也就是说假设两组值之间有映射关系；我们根据此关系替换链表元素和参数函数。问题是，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;的输出结果是否可以通过该关系预测？如果对于某些输入，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;的输出和关系预测的结果不同，这说明&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;肯定侦测了实际值并根据相关信息做出了处理。但事实上，这不会发生在&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;上，或者说实际上也不会发生在大多标准多态函数上。&lt;/p&gt;&lt;p&gt;遵从这类型关系准则的函数被称为&lt;b&gt;关系型参数&lt;/b&gt;（Relational Parametricity）【注释】。这是类型赋予我们的另一个非常强大的能力，因为它们告诉我们这种多态函数可以执行的操作很受限制：它们可以删除、复制或重新排列元素，但是不能考察这些元素，也不能对它们进行具体操纵。&lt;/p&gt;&lt;blockquote&gt;请参阅Wadler的《Theorems for Free!》和Reynolds的《Types, Abstraction and Parametric Polymorphism》。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;起初这听起来非常令人印象深刻（确实如此！），但细查，你可能会意识到这与经验并不一致。例如，在Java中，多态方法依然可以使用&lt;code class=&quot;inline&quot;&gt;instanceof&lt;/code&gt;在运行时检查、获得特定类型的值，并相应的改变行为。这种方法就不是关系型参数了！【注释】事实上，关系型参数也能被看作是语言弱点的一种表述：它只允许一组有限的操作。（你仍可以检查类型——但不能根据你获取的信息进行相关行动，这样检查就没有意义了。因此运行时系统如果想要模拟关系型参数，必须要移除类似&lt;code class=&quot;inline&quot;&gt;instanceof&lt;/code&gt;及它的替代行为：例如，对值进行加一操作并捕获异常以判断它是数。）然而，这是个非常优雅和令人吃惊的结果，显示了使用丰富类型系统能获得的强大程序推理能力。&lt;/p&gt;&lt;blockquote&gt;网上，你会经常发现这个属性被描述为函数不能检查其参数——这是不正确的。&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;15.3.2 类型推断&lt;/h2&gt;&lt;p&gt;手工书写每处多态类型的实例参数是一个令人沮丧的过程，很多版本的Java和C++用户可以证明这点。想象一下，每次使用&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt;时都需要传入类型参数是个什么场景！我们之所以能够避免这种命运，是因为我们的语言实现了&lt;b&gt;类型推断&lt;/b&gt;。这使我们可以编写定义：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (mapper f l)
  (cond
    [(empty? l) empty]
    [(cons? l) (cons (f (first l)) (mapper f (rest l)))]))&lt;/code&gt;&lt;p&gt;然后编程环境&lt;b&gt;自动&lt;/b&gt;声明&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; mapper
- ((&#39;a -&amp;gt; &#39;b) (listof &#39;a) -&amp;gt; (listof &#39;b))&lt;/code&gt;&lt;p&gt;它不仅是正确的类型，而且是非常一般的类型！从程序结构中派生出这种一般类型的过程感觉几乎就是魔法。我们来揭示其幕后。&lt;/p&gt;&lt;p&gt;首先，我们来了解类型推断做了什么。有些人错误的认为，有类型推断的语言无类型声明，其被类型推断取而代之了。这混淆了多个层面的东西。首先，即使在有类型推断的语言中，程序员仍被允许声明类型（并且为了文档更为清晰，通常会鼓励这样做——就像你之前被鼓励的一样）【注释】。此外，在没有这些声明的情况下，推断的实际&lt;b&gt;含义&lt;/b&gt;并不显明。&lt;/p&gt;&lt;blockquote&gt;有时（类型）推断是不可判定的，这时程序员别无选择只能声明某些类型。最后，显式的书写类型注解能够大大减少难以辨认的错误信息。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;相反，最好将底层语言看作需要完整地显式声明类型的——就如我们刚才研究的多态语言。然后我们说，在&lt;code class=&quot;inline&quot;&gt;:&lt;/code&gt;后类型注解部分可以留空，编程环境中的某个特性会为我们填充这些。（如果走得更远，我们可以丢弃&lt;code class=&quot;inline&quot;&gt;:&lt;/code&gt;及额外的修饰，它们都会被自动插入。因此，类型推断只是为用户提供的一种便利，减轻编写类型注解的负担，而底层的语言仍然是显式声明类型的。&lt;/p&gt;&lt;p&gt;我们怎么考虑类型推断做的是什么呢？假设我们有个表达式（或者程序）&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;，由显式声明类型语言书写：也就是说在任何需要类型注解的地方都有写出。现在假设我们擦除&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;中所有的类型注解，然后使用函数&lt;code class=&quot;inline&quot;&gt;infer&lt;/code&gt;将它们推断回来。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;code class=&quot;inline&quot;&gt;infer&lt;/code&gt;应该有何种属性？&lt;/blockquote&gt;&lt;p&gt;我们可以要求很多东西。其中之一为，它要产生和&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;原来恰好一样的注解。这在很多方面都是有问题的，尤其是当&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;本就不能通过类型检查的情况下，怎么能推断回它们（应该）是什么？你可能觉得这是个学究式的玩笑：毕竟，如果&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;本就不能通过类型检查，如果能在删除其注解之后还能还原回来呢？反正两者都不能通过类型检查，谁在乎啊？&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;这个推理正确吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;假设&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(lambda ([x : number]) : string x)&lt;/code&gt;&lt;p&gt;它显然不能通过类型检查。但是如果我们擦除类型注解——得到&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(lambda (x) x)&lt;/code&gt;&lt;p&gt;——这个函数显然可以合法地添加类型！因此，更合理的需求可以是，如果原始的&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;能通过类型检查，那么对应的使用了推导出的注解的版本也必须能。这种单向的含义的用途体现在两方面：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;它没有说&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;未通过类型检查应该怎样，也即它不会排除前述的类型推断算法，其会将例子中类型错误的恒等函数变成类型正确的。&lt;/li&gt;&lt;li&gt;更重要的是，它向我们保证，使用类型推断将不会使我们失去任何东西：之前能通过类型检测的程序不会被推断后而不能。这意味着我们可以在想要的地方显式添加类型注解，但不会被迫这样做。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;当然，这只在程序推断可判定的情况下才成立。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;我们还可能希望两者类型是相同的，但这不是能做到的：函数&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(lambda ([x : number]) : number x)&lt;/code&gt;&lt;p&gt;类型为&lt;code class=&quot;inline&quot;&gt;(number -&amp;gt; number)&lt;/code&gt;，而擦除类型注解后推导出的类型要一般得多。因此，将这些类型关联并给出类型相等的定义并不简单，尽管如此后面将简要讨论此问题。&lt;/p&gt;&lt;p&gt;有了这些准备，我们下面进入对类型推断机制的研究。最需要注意的地方，前述的简单递归下降的类型检查算法将不再起作用。它之前能起作用，是因为所有函数的边界处都有类型注解，所以我们下降进入函数体，同时用类型环境携带这些注解中包含的信息。没了这些注解，就不知如何递归下降了。&lt;/p&gt;&lt;p&gt;事实上，目前还不清楚哪个方向更合理。像上面&lt;code class=&quot;inline&quot;&gt;mapper&lt;/code&gt;的定义，各代码段之间互相影响。例如，从&lt;code class=&quot;inline&quot;&gt;empty?&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;cons?&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt;对&lt;code class=&quot;inline&quot;&gt;l&lt;/code&gt;的调用都可以看出它是链表。但是是什么的链表呢？从这些操作看不出来。然而，对于其每个（或者应该说，任意）&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;元素调用了&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;这点可以看出，链表成员的类型必须可以被传给&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;。同理，由&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;我们可以知道（&lt;code class=&quot;inline&quot;&gt;mapper&lt;/code&gt;的）返回表达式必须为链表。它的成员类型是什么呢？必须为&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的返回类型。最后，请注意最微妙的地方：当参数链表为空时，我们返回&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;而不是&lt;code class=&quot;inline&quot;&gt;l&lt;/code&gt;（这时我们是知道其被绑定到&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;）。使用前者，返回值的类型可能是任意类型的链表（仅受&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;返回类型的约束）；使用后者，返回的类型就被迫和参数链表的类型相同。&lt;/p&gt;&lt;p&gt;所有这些信息都包含在函数里。但是我们如何系统地提取出这些信息呢，而且使用的算法必须会终止，并满足前面陈述属性？我们分两步来做。首先，根据程序表达式&lt;b&gt;生成&lt;/b&gt;其必须要满足的类型&lt;b&gt;约束&lt;/b&gt;。然后，通过合并散布在函数体各处的约束、识别其中的不一致，最终&lt;b&gt;解决约束&lt;/b&gt;。每一步都相对简单，但是组合起来创造了魔力。&lt;/p&gt;&lt;h2&gt;15.3.2.1 约束生成&lt;/h2&gt;&lt;p&gt;我们最终的目标是给每个类型注解位置填入类型。将会证明，这也等同于找到每个&lt;b&gt;表达式&lt;/b&gt;的类型。简单想想就知道，这本来也是必要的：比如，在不知道函数体类型的情况下，如何能确定函数本身的类型？这也是足够的，因为如果每个表达式的类型都被计算得出，其中必然包括了那些需要被注解的表达式。&lt;/p&gt;&lt;p&gt;首先，我们需要生成（待解决的）约束。这一步会遍历程序源码，为每个表达式生成恰当的约束，最后返回这组约束。为了简单，使用递归下降的方式实现；它最终生成约束的&lt;b&gt;集合&lt;/b&gt;，所以原则上遍历和生成的顺序是无关紧要的——因此我们选择了相对简单的递归下降方式——当然，为了简单起见，我们使用链表表示这个集合。&lt;/p&gt;&lt;p&gt;约束是什么呢？就是关于表达式类型的陈述。此外，虽然变量绑定并不是表达式，但我们仍需计算其类型（因为函数需要参数和返回值类型）。一般来说，对于表达式的类型我们知道些什么呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;它和某些标识符的类型有关。&lt;/li&gt;&lt;li&gt;它和某些其它表达式的类型有关。&lt;/li&gt;&lt;li&gt;它是数。&lt;/li&gt;&lt;li&gt;它是函数，其定义域（domain）和值域（range）类型可能受到进一步的约束。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;因此，我们定义如下两个数据结构：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type Constraints
  [eqCon (lhs : Term) (rhs : Term)])

(define-type Term
  [tExp (e : ExprC)]
  [tVar (s : symbol)]
  [tNum]
  [tArrow (dom : Term) (rng : Term)])&lt;/code&gt;&lt;p&gt;接下来定义约束生成函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen&amp;gt; ::= ;约束生成

    (define (cg [e : ExprC]) : (listof Constraints)
      (type-case ExprC e
        &amp;lt;constr-gen-numC-case&amp;gt;
        &amp;lt;constr-gen-idC-case&amp;gt;
        &amp;lt;constr-gen-plusC/multC-case&amp;gt;
        &amp;lt;constr-gen-appC-case&amp;gt;
        &amp;lt;constr-gen-lamC-case&amp;gt;))&lt;/code&gt;&lt;p&gt;当表达式为数时，唯一能说的是，我们希望该表达式的类型为数类型：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-numC-case&amp;gt; ::=

    [numC (_) (list (eqCon (tExp e) (tNum)))]&lt;/code&gt;&lt;p&gt;听上去很微不足道，但我们不知道的是，其他包含它的表达式是什么。因此，某个更大的表达式可能会与此断言——这个表达式的类型必须是数型——相矛盾，从而导致类型错误。&lt;/p&gt;&lt;p&gt;对于标识符，我们只是简单地说，表达式的类型就是我们所期望该标识符应有的类型：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-idC-case&amp;gt; ::=

    [idC (s) (list (eqCon (tExp e) (tVar s)))]&lt;/code&gt;&lt;p&gt;如果上下文限制了其类型，该表达式的类型将自动受到限制，并且必须与上下文的期望一致。&lt;/p&gt;&lt;p&gt;加法是我们第一个遇到的上下文约束。对于加法表达式，首先需要确保我们生成（并返回）其两个子表达式的约束，而子表达式可以是复杂的。这两个约束中，我们期望什么？需要每个子表达式是数类型的。（如果其中一个子表达式不是数类型的，应该导致类型错误。）最后，我们断言整个表达式的类型为数。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-plusC/multC-case&amp;gt; ::=

    [plusC (l r) (append3 (cg l)
                          (cg r)
                          (list (eqCon (tExp l) (tNum))
                                (eqCon (tExp r) (tNum))
                                (eqCon (tExp e) (tNum))))]&lt;/code&gt;&lt;blockquote&gt;&lt;code class=&quot;inline&quot;&gt;append3&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;append&lt;/code&gt;的三参数版本。&lt;/blockquote&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;multC&lt;/code&gt;的情况与之相同，区别只在名字上。&lt;/p&gt;&lt;p&gt;下面我们来看另外两个有趣的情况，函数声明和调用。两种情况下我们都需要生成和返回子表达式的约束。&lt;/p&gt;&lt;p&gt;在函数定义中，函数的类型是函数（“箭头/arrow”）类型，其参数类型是形参的类型，其返回类型是函数体的类型。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-lamC-case&amp;gt; ::=

    [lamC (a b) (append (cg b)
                        (list (eqCon (tExp e) (tArrow (tVar a) (tExp b)))))]&lt;/code&gt;&lt;p&gt;最终，考虑函数调用。我们不能直接陈述函数调用的类型约束。不过，我们可以说，函数接受的参数类型必须和实际参数的类型相同，并且函数返回的类型就是调用表达式的类型。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-appC-case&amp;gt; ::=

    [appC (f a) (append3 (cg f)
                         (cg a)
                         (list (eqCon (tExp f) (tArrow (tExp a) (tExp e)))))]&lt;/code&gt;&lt;p&gt;完成了！我们已经完成约束的生成；现在只需解出它们。&lt;/p&gt;&lt;h2&gt;15.3.2.2 使用合一求解约束&lt;/h2&gt;&lt;p&gt;求解约束的过程也被称为&lt;b&gt;合一&lt;/b&gt;（unification）。合一器的输入是等式的集合，其中每个等式是变量到项（term）的映射，项的数据类型在上面定义了。注意到一点，我们实际上有&lt;b&gt;两&lt;/b&gt;种变量。&lt;code class=&quot;inline&quot;&gt;tvar&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;tExp&lt;/code&gt;都是“变量”，前者很明显，注意后者同样也是，因为我们需要求解此类表达式的类型。（另一种方式是为每个表达式引入新的类型变量，但我们仍需一种方法确定这些变量与表达式之间的对应关系，而现在这已经能通过对表达式进行&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;操作自动完成了。另外这会产生大得多的约束集，不好进行人工检查。）&lt;/p&gt;&lt;p&gt;就我们的目的而言，合一是为了是生成&lt;b&gt;替换&lt;/b&gt;（substitution），或者说将变量映射为不包含任何变量的项。这听起来应该很耳熟：我们有一组联立方程，其中每个变量都是线性使用的；这种方程组可以使用&lt;b&gt;高斯消元法&lt;/b&gt;求解。该情形中，我们清楚最终可能遇到缺少约束（under-constrained）或过度约束（over-constrained）的情况。这种事情同样也将发生这里。&lt;/p&gt;&lt;p&gt;合一算法会遍历约束集合。由于每个约束有两项，每个项有四种可能的类型，因此有十六种情况需要考虑。幸运的是，我们实际可以用比较少的代码覆盖这十六种情况。&lt;/p&gt;&lt;p&gt;算法从所有约束的集合和空替换开始。每个约束都会被处理一次，并从集合中删除，因此原则上终止判据应该非常简单，但是实际处理起来还有点小麻烦。随着约束被处理，替换集合会逐渐增长。当所有的约束都被处理完后，合一过程返回最后的替换集合。&lt;/p&gt;&lt;p&gt;对于给定的约束，合一器检查等式左边，如果它是变量，那么这时它就可以被消除了，合一器将该变量（等式）的右侧添加到替换中，为了真正完成消除，还需要将替换集中所有该变量的出现替换成该右侧。实践中，实现需要考虑效率；例如，使用可变值表示这些变量可以避免搜索—替换过程。然而我们可能需要进行回溯（我们在后面确实会需要），可变值表示也有缺点。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;注意到上面微妙的错误了吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;这个微妙的错误是，我们说合一器通过替换变量的所有实例来&lt;b&gt;消除&lt;/b&gt;它。不过，我们假设等式右侧不包含该变量的实例。不然的话，我们将得到循环定义，这将使替换变得不可能。出于这个原因，合一器会进行&lt;b&gt;出现检查&lt;/b&gt;（occurs check）：检查某个变量是否出现在等式两侧，如果是，则拒绝合一。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;构造一个其约束会触发出现检查的项。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;还记得&lt;code class=&quot;inline&quot;&gt;ω&lt;/code&gt;吗？&lt;/p&gt;&lt;p&gt;下面考虑合一的实现。惯例使用希腊字母&lt;code class=&quot;inline&quot;&gt;Θ&lt;/code&gt;表示替换。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type-alias Subst (listof Substitution))
(define-type Substitution
  [sub [var : Term] [is : Term]])

(define (unify [cs : (listof Constraints)]) : Subst
  (unify/Θ cs empty))&lt;/code&gt;&lt;p&gt;首先把简单的东西写出来：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ&amp;gt; ::=

    (define (unify/Θ [cs : (listof Constraints)] [Θ : Subst]) : Subst
      (cond
        [(empty? cs) Θ]
        [(cons? cs)
         (let ([l (eqCon-lhs (first cs))]
               [r (eqCon-rhs (first cs))])
           (type-case Term l
             &amp;lt;unify/Θ-tVar-case&amp;gt;
             &amp;lt;unify/Θ-tExp-case&amp;gt;
             &amp;lt;unify/Θ-tNum-case&amp;gt;
             &amp;lt;unify/Θ-tArrow-case&amp;gt;))]))&lt;/code&gt;&lt;p&gt;现在可以实现合一的核心了。我们需要一个辅助函数&lt;code class=&quot;inline&quot;&gt;extend-replace&lt;/code&gt;，其签名为&lt;code class=&quot;inline&quot;&gt;(Term Term Subst -&amp;gt; Subst)&lt;/code&gt;。它将执行出现检查，如果检查得出没有环路，则扩展替换集合，并将替换集合中所有出现的第一个项（第一个参数）替代为第二个项（第二个参数）。同样，我们假设&lt;code class=&quot;inline&quot;&gt;lookup: (Term subst -&amp;gt; (optionof Term))&lt;/code&gt;存在。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;定义&lt;code class=&quot;inline&quot;&gt;extend-replace&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;lookup&lt;/code&gt;。&lt;/blockquote&gt;&lt;p&gt;如果约束等式的左侧是个变量，我们先在替换集合中寻找它。如果存在，我们将当前约束换成新的约束；否则我们扩展替换集合。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ-tVar-case&amp;gt; ::=

    [tVar (s) (type-case (optionof Term) (lookup l Θ)
                [some (bound)
                      (unify/Θ (cons (eqCon bound r)
                                     (rest cs))
                               Θ)]
                [none ()
                      (unify/Θ (rest cs)
                               (extend+replace l r Θ))])]&lt;/code&gt;&lt;p&gt;同样的逻辑也适用于表达式的情况：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ-tExp-case&amp;gt; ::=

    [tExp (e) (type-case (optionof Term) (lookup l Θ)
                [some (bound)
                      (unify/Θ (cons (eqCon bound r)
                                     (rest cs))
                               Θ)]
                [none ()
                      (unify/Θ (rest cs)
                               (extend+replace l r Θ))])]&lt;/code&gt;&lt;p&gt;如果是基本类型，例如数，我们就需要检查等式右边。有四种可能：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果是数，那么该等式声明类型&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;等于&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;，这恒为真。因此我们可以忽略该约束——它没有告诉我们什么有用信息——继续检查剩下的。&lt;br&gt;当然，首先得解释为什么会出现这种约束。显然，我们的约束生成器不会生成这种约束。然而，前面替换集合的扩展会导致这种情况。事实是实践中我们会遇到好几个这种情况。&lt;/li&gt;&lt;li&gt;如果是函数类型，显然存在类型错误，因为数和函数类型不相交。同样，我们不会直接生成这样的约束，一定是由先前的替代产生。&lt;/li&gt;&lt;li&gt;它可能是两种变量类型之一。不过，我们的约束生成器经过了仔细的安排，不会将它们放在右侧。此外，替代过程也不会在右侧引入它们。因此，这两种情况不会发生。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;于是得出这样的代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ-tNum-case&amp;gt; ::=

    [tNum () (type-case Term r
               [tNum () (unify/Θ (rest cs) Θ)]
               [else (error &#39;unify &quot;number and something else&quot;)])]&lt;/code&gt;&lt;p&gt;最后还剩下函数类型。这里的论点几乎和数类型完全一样。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ-tArrow-case&amp;gt; ::=

    [tArrow (d r) (type-case Term r
                    [tArrow (d2 r2)
                            (unify/Θ (cons (eqCon d d2)
                                           (cons (eqCon r r2)
                                                 cs))
                                     Θ)]
                    [else (error &#39;unify &quot;arrow and something else&quot;)])]&lt;/code&gt;&lt;p&gt;请注意，我们并没有严格地缩小约束集合，因此仅通过约束集合的大小不足以判断这个过程会终止。需要同时综合考虑约束集合的大小以及替换的大小（包括其中变量的个数）。&lt;/p&gt;&lt;p&gt;上面的算法非常通用，不仅对数和函数，对于各种类型项也都适用。我们使用数代表各种基础类型；同样，使用函数代表各种构造类型，例如&lt;code class=&quot;inline&quot;&gt;listof&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;vectorof&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这就完成了。合一产生了替换。现在我们可以遍历这些替换，找到程序中所有表达式的类型，然后插入对应的类型注解。有定理（这里不证明）指出，上面过程的成功意味着程序通过了类型检查，因此我们无需对该程序显式地再跑一遍类型检查。&lt;/p&gt;&lt;p&gt;不过请注意，类型错误的性质在这里发生了巨大变化。之前，我们的递归下降算法利用类型环境遍历表达式。类型环境中的绑定是程序员定义的类型，因此可以被当作（期望的）权威的类型&lt;b&gt;规范&lt;/b&gt;（specification）。因此，所有的错误都应归咎于表达式，类型错误的报告很简单（而且很好懂）。然而这里，类型错误&lt;b&gt;无法通知&lt;/b&gt;。合一错误是两个智能算法——约束生成和合一——共同导致的，因此程序员不一定能理解。特别是，由于约束的本质是等式，报告的错误位置和“真实”的错误位置可能相差甚远。因此，生成更好的错误信息仍然是个活跃的研究领域。&lt;/p&gt;&lt;blockquote&gt;实践中，算法会维护涉及到的程序源码的元信息，并可能也会保存合一的历史，以便溯源错误回源程序。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;最后，请记住，约束可能不会精确指明所有变量的类型。如果方程组&lt;b&gt;过度&lt;/b&gt;约束，可能会有冲突，导致类型错误。如果&lt;b&gt;缺少&lt;/b&gt;约束，这意味着我们没有足够的信息对所有表达式做出明确的类型声明。例如，对于表达式&lt;code class=&quot;inline&quot;&gt;(lambda (x) x)&lt;/code&gt;，没有足够的约束指明&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型，从而无法以指明整个表达式的类型。这并非错误；它只是意味着&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;可以是&lt;b&gt;任意&lt;/b&gt;类型。换句话说，该表达式的类型是“&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型-&amp;gt;&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型”，无其它约束。这些欠约束标识符的类型以类型变量的方式展示，于是上面表达式的类型可以表示为&lt;code class=&quot;inline&quot;&gt;(&#39;a -&amp;gt; &#39;a)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;合一算法实际上有个很好的属性：它能自动计算表达式&lt;b&gt;最通用的类型&lt;/b&gt;，也被称为&lt;b&gt;主类型&lt;/b&gt;（principal type）。这就是说，表达式可以有的任何实际类型都可以通过（用实际类型）替换推导出的类型中的类型变量的得到。这是个异乎寻常的结果：没人能生成比前述算法得出的更为一般的类型！&lt;/p&gt;&lt;h2&gt;15.3.2.3 Let-多态&lt;/h2&gt;&lt;p&gt;很不幸，尽管这些类型变量表面上看和我们之前遇到的多态有诸多相似之处，但它们并不同。考虑下面的程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(let ([id (lambda (x) x)])
  (if (id true)
      (id 5)
      (id 6)))&lt;/code&gt;&lt;p&gt;如果加上显式的类型注解，它能通过类型检查：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(if ((id boolean) true)
    ((id number) 5)
    ((id number) 6))&lt;/code&gt;&lt;p&gt;然而，如果使用类型推断，它将不能通过类型检查！因为&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;中的类型&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;——取决于约束处理的顺序——要么和&lt;code class=&quot;inline&quot;&gt;boolean&lt;/code&gt;合一，要么和&lt;code class=&quot;inline&quot;&gt;number&lt;/code&gt;合一。对应的，那时&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的类型要么是&lt;code class=&quot;inline&quot;&gt;(boolean -&amp;gt; boolean)&lt;/code&gt;要么是&lt;code class=&quot;inline&quot;&gt;(number -&amp;gt; number)&lt;/code&gt;。当使用另一个类型调用&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;时，就会发生类型错误！&lt;/p&gt;&lt;p&gt;这是因为我们通过合一推断出来的类型实际并不是&lt;b&gt;多态的&lt;/b&gt;。这点很重要：将其称为类型变量不会使你获得多态!类型变量可以在下次使用时合一，彼时，最终得到的还只是单态函数。而真正的多态只有在能真正进行类型变量&lt;b&gt;实例化&lt;/b&gt;时才会获得。&lt;/p&gt;&lt;p&gt;所以在具有真正多态的语言中，约束生成和合一是不够的。相反，像ML和Haskell这种语言，甚至我们使用的静态类型语言也是，都实现了俗称&lt;b&gt;let-多态&lt;/b&gt;的东西。这种策略中，当包含类型变量的项在词法环境中被绑定时，该类型被自动提升为量化类型。每次使用时，该项被自动实例化。&lt;/p&gt;&lt;p&gt;很多实现策略可以做到这点。最简单（而不令人满意）的方式只需&lt;b&gt;复制&lt;/b&gt;绑定标识符代码的&lt;b&gt;代码&lt;/b&gt;；这样，上面每次&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的使用都会得到自己的&lt;code class=&quot;inline&quot;&gt;(lambda (x) x)&lt;/code&gt;副本，所以每个都有它自己的类型变量。第一个的类型可能是&lt;code class=&quot;inline&quot;&gt;(&#39;a -&amp;gt; &#39;a)&lt;/code&gt;，第二个是&lt;code class=&quot;inline&quot;&gt;(&#39;b -&amp;gt; &#39;b)&lt;/code&gt;，第三个是&lt;code class=&quot;inline&quot;&gt;(&#39;c -&amp;gt; &#39;c)&lt;/code&gt;，等等。这些类型变量互不冲突，因此我们得到多态的效果。显然，这不仅增加了程序的大小，而且在存在递归的情况下也不起作用。然而，这给我们提供了通往更好解决方案的思路：不是复制代码，而是复制&lt;b&gt;类型&lt;/b&gt;。因此在每次使用时，我们创建推导出类型的重命名版本：第一次使用时，id的类型&lt;code class=&quot;inline&quot;&gt;(&#39;a -&amp;gt; &#39;a)&lt;/code&gt;变成了&lt;code class=&quot;inline&quot;&gt;(&#39;b -&amp;gt; &#39;b)&lt;/code&gt;，以此类推，这种方式实现了拷贝代码相同的效果且没有它的包袱。不过，因为这些策略实质都是效仿代码拷贝，因此它们只能在词法环境下工作。&lt;/p&gt;</description>
<author>MrMathematica</author>
<guid isPermaLink="false">2018-03-30-35115633</guid>
<pubDate>Fri, 30 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Java and Scala’s Type Systems are Unsound</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-30-35055185.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35055185&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d7db8335a8c05f576678c6d1e81f5b2c_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;Java and scala&#39;s type systems are unsound: the existential crisis of null pointers, OOPSLA 2016&lt;/p&gt;&lt;p&gt;作者：Nada Amin, Ross Tate&lt;/p&gt;&lt;a href=&quot;https://dl.acm.org/citation.cfm?id=2984004&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-de6f855e8c8fd69721e406b388e10b4b&quot; data-image-width=&quot;132&quot; data-image-height=&quot;171&quot; data-image-size=&quot;120x160&quot;&gt;Java and scala&#39;s type systems are unsound: the existential crisis of null pointers&lt;/a&gt;&lt;p&gt;Paper: &lt;a href=&quot;https://raw.githubusercontent.com/namin/unsound/master/doc/unsound-oopsla16.pdf&quot;&gt;https://raw.githubusercontent.com/namin/unsound/master/doc/unsound-oopsla16.pdf&lt;/a&gt;&lt;/p&gt;&lt;p&gt;摘要：&lt;/p&gt;&lt;blockquote&gt;We present short programs that demonstrate the unsoundness of Java and Scala&#39;s current type systems. In particular, these programs provide parametrically polymorphic functions that can turn any type into any type without (down)casting. Fortunately, parametric polymorphism was not integrated into the Java Virtual Machine (JVM), so these examples do not demonstrate any unsoundness of the JVM. Nonetheless, we discuss broader implications of these findings on the field of programming languages.&lt;/blockquote&gt;&lt;p&gt;本文作者展示了一些Java和Scala类型系统unsound的问题。&lt;/p&gt;&lt;p&gt;Java和Scala的类型系统使用了参数化多态（parametric polymorphism），因此允许带参数的函数根据参数来实现类型转换。作者同时指出因为JVM没有引入参数化多态，JVM不受此影响。最后，作者揭示了这样的问题在程序语言的设计上有着更大的影响。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;2004年，Java 5 引入了泛型（generics）——参数化多态；同年Scala发布，发布了path-dependent type的特性。在发布之初，二者的类型系统都是unsound的。尽管诸多PL研究者对于Java的类型系统进行研究，并将其形式化，作者还是发现了Java类型系统unsound的地方。&lt;/p&gt;&lt;p&gt;作者指出，诸多研究者在研究一门复杂的语言的时候，选择使用一些简化的模型来进行抽象，并验证这个模型的某个核心功能，却忽视了不同的特性交织在一起的时候产生的效果。本文所发现的unsound的例子则是多个特性进行叠加之后的结果。&lt;/p&gt;&lt;p&gt;先上例子：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;class Unsound {
  static class Constrain&amp;lt;A, B extends A&amp;gt; {}
  static class Bind&amp;lt;A&amp;gt; {
    &amp;lt;B extends A&amp;gt;
    A upcast(Constrain&amp;lt;A,B&amp;gt; constrain, B b) {
      return b;
    }
  }
  static &amp;lt;T,U&amp;gt; U coerce(T t) {
    Constrain&amp;lt;U,? super T&amp;gt; constrain = null;
    Bind&amp;lt;U&amp;gt; bind = new Bind&amp;lt;U&amp;gt;();
    return bind.upcast(constrain, t);
  } 
  public static void main(String[] args) {
    String zero = Unsound.&amp;lt;Integer,String&amp;gt;coerce(0);
  }
}&lt;/code&gt;&lt;p&gt;Java 8运行结果（&lt;code class=&quot;inline&quot;&gt;ClassCastException&lt;/code&gt;）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ javac -version
javac 1.8.0_151
$ javac Unsound.java
$ java Unsound
Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String
	at Unsound.main(Unsound.java:15)&lt;/code&gt;&lt;p&gt;Java 9运行结果（无法编译）：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;$ javac -version
javac 9.0.1
$ javac Unsound.java
Unsound.java:12: error: method upcast in class Bind&amp;lt;A&amp;gt; cannot be applied to given types;
    return bind.upcast(constrain, t);
               ^
  required: Constrain&amp;lt;U,B&amp;gt;,B
  found: Constrain&amp;lt;U,CAP#1&amp;gt;,T
  reason: inference variable B has incompatible bounds
    upper bounds: U
    lower bounds: T
  where U,T,B,A are type-variables:
    U extends Object declared in method &amp;lt;T,U&amp;gt;coerce(T)
    T extends Object declared in method &amp;lt;T,U&amp;gt;coerce(T)
    B extends U declared in method &amp;lt;B&amp;gt;upcast(Constrain&amp;lt;A,B&amp;gt;,B)
    A extends Object declared in class Bind
  where CAP#1 is a fresh type-variable:
    CAP#1 extends U super: T from capture of ? super T
1 error&lt;/code&gt;&lt;p&gt;（传送门：&lt;a href=&quot;http://io.livecode.ch/learn/namin/unsound&quot;&gt;The Unsound Playground&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;由于笔者不会写Scala（捂脸），所以就主要讨论Java部分了。等什么时候学会了Scala再来补一下Scala部分吧（flag）。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;我们跟着作者的思路来重现这个例子的构建过程。&lt;/p&gt;&lt;p&gt;首先我们需要编写一个程序实现两个类之类的任意转换。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;class A {}
class B {}
class Unsound {
  &amp;lt;V, W&amp;gt; V magic(W w) {
    // TODO
  }
  public static void main(String[] args) {
    Unsound u = new Unsound();
    A surprise = u.&amp;lt;A, B&amp;gt;magic(new B()); // 把B转换到A
  }
}&lt;/code&gt;&lt;p&gt;在&lt;code class=&quot;inline&quot;&gt;magic&lt;/code&gt;方法里，我们需要一个&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;的实例，但我们只有一个&lt;code class=&quot;inline&quot;&gt;W&lt;/code&gt;的实例，显然我们没有办法完成给定的任务。但是我们可以使用通配符给类型进行限制，然后进行安全的向上类型转换（upcast）。&lt;/p&gt;&lt;p&gt;因此，我们引入&lt;code class=&quot;inline&quot;&gt;Constrain&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;Bind&lt;/code&gt;两个类来帮我们完成任务。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;class Constrain&amp;lt;X, Y extends X&amp;gt; {}
class Bind&amp;lt;Z&amp;gt; {
  &amp;lt;U extends Z&amp;gt; Z
  upcast(Constrain&amp;lt;Z, U&amp;gt; constrain, U u) { return u; }
}&lt;/code&gt;&lt;p&gt;注意此处两个类通配符的限制：在&lt;code class=&quot;inline&quot;&gt;Constrain&lt;/code&gt;类中，&lt;code class=&quot;inline&quot;&gt;Y&lt;/code&gt;需要是&lt;code class=&quot;inline&quot;&gt;X&lt;/code&gt;的子类。在&lt;code class=&quot;inline&quot;&gt;Bind&lt;/code&gt;类中，我们可以通过&lt;code class=&quot;inline&quot;&gt;Constrain&lt;/code&gt;类将&lt;code class=&quot;inline&quot;&gt;U&lt;/code&gt;类的实例安全的向上转换到Z类。&lt;/p&gt;&lt;p&gt;那么，我们可以用上面的两个类来实现我们的&lt;code class=&quot;inline&quot;&gt;magic&lt;/code&gt;方法。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;V, W&amp;gt; V magic(W w) {
  Constrain&amp;lt;???&amp;gt; constrain = ???; //TODO
  Bind&amp;lt;V&amp;gt; bind = new Bind&amp;lt;V&amp;gt;();
  return bind.upcast(constrain, w);
}&lt;/code&gt;&lt;p&gt;通过找到一个合适的&lt;code class=&quot;inline&quot;&gt;Constrain&lt;/code&gt;类实例和参数，我们可以通过&lt;code class=&quot;inline&quot;&gt;Bind&lt;/code&gt;类将&lt;code class=&quot;inline&quot;&gt;W&lt;/code&gt;类向上转换到&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;类，那么剩下要做的就是找出合适的参数了。&lt;/p&gt;&lt;p&gt;我们假定&lt;code class=&quot;inline&quot;&gt;Constrain&lt;/code&gt;类的参数为&lt;code class=&quot;inline&quot;&gt;&amp;lt;T1, T2&amp;gt;&lt;/code&gt;，值为&lt;code class=&quot;inline&quot;&gt;val&lt;/code&gt;。那么我们需要寻找的则是使下列条件满足的实例：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Constrain&amp;lt;T1, T2&amp;gt;&lt;/code&gt; 是一个合法的类型&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;bind.upcast&lt;/code&gt;可以通过类型检查&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;val&lt;/code&gt;满足&lt;code class=&quot;inline&quot;&gt;Constrain&amp;lt;T1, T2&amp;gt;&lt;/code&gt;的类型限制&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们选择&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Constrain&amp;lt;V, ? super W&amp;gt; constrain = null;&lt;/code&gt;&lt;p&gt;来满足上述要求。&lt;/p&gt;&lt;p&gt;首先，&lt;code class=&quot;inline&quot;&gt;Constrain&amp;lt;V, ? super W&amp;gt;&lt;/code&gt; 是一个合法的类型，这个类型中使用了一个带下界的通配符。通过&lt;code class=&quot;inline&quot;&gt;? super W&lt;/code&gt;，我们得知通配符类型是&lt;code class=&quot;inline&quot;&gt;W&lt;/code&gt;的母类；又因为定义中要求的&lt;code class=&quot;inline&quot;&gt;Y extends X&lt;/code&gt;，所以通配符类型是&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;的子类。在检查类型是否合法时，并不会检查是否有类型实例能满足给定的限制，因此使用通配符可以让我们避免给定一个满足限制的实例。&lt;/p&gt;&lt;p&gt;我们其次考虑&lt;code class=&quot;inline&quot;&gt;bind.upcast&lt;/code&gt;。我们显式地定义了&lt;code class=&quot;inline&quot;&gt;Bind&lt;/code&gt;类的类型参数为&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;，因此假设&lt;code class=&quot;inline&quot;&gt;Constrain&lt;/code&gt;的类型参数为&lt;code class=&quot;inline&quot;&gt;&amp;lt;V, Z&amp;gt;&lt;/code&gt;，其中&lt;code class=&quot;inline&quot;&gt;Z&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;的子类，那么正如前文中所说的做法，我们就可以使用&lt;code class=&quot;inline&quot;&gt;bind.upcast&lt;/code&gt;来将&lt;code class=&quot;inline&quot;&gt;Z&lt;/code&gt;的值向上转换至&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;。但是，我们注意到此处&lt;code class=&quot;inline&quot;&gt;Constrain&lt;/code&gt;的类型中带有一个通配符，因此类型系统必须推导一个类型来实现我们定义的上述限制。&lt;/p&gt;&lt;p&gt;类型系统的推导过程由收集所有对于类型的假设和必需的要求开始，其次试图找到一个满足限制的类型。&lt;/p&gt;&lt;p&gt;我们假设需要推导的通配符类型为&lt;code class=&quot;inline&quot;&gt;X&lt;/code&gt;。从上文我们得知，&lt;code class=&quot;inline&quot;&gt;X&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;W&lt;/code&gt;的母类，是&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;的子类。&lt;/p&gt;&lt;p&gt;在定义中，&lt;code class=&quot;inline&quot;&gt;bind.upcast&lt;/code&gt;的第一个参数的类型为&lt;code class=&quot;inline&quot;&gt;Constrain&amp;lt;V, U&amp;gt;&lt;/code&gt;（显式指定了&lt;code class=&quot;inline&quot;&gt;Z&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;），实际类型为&lt;code class=&quot;inline&quot;&gt;Constrain&amp;lt;V, X&amp;gt;&lt;/code&gt;。第二个参数的类型为&lt;code class=&quot;inline&quot;&gt;U&lt;/code&gt;，实际类型为&lt;code class=&quot;inline&quot;&gt;W&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我们可以得出以下限制：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;U&lt;/code&gt; = &lt;code class=&quot;inline&quot;&gt;X&lt;/code&gt; -  通过归一&lt;code class=&quot;inline&quot;&gt;Constrain&amp;lt;V, U&amp;gt;&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;Constrain&amp;lt;V, X&amp;gt;&lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;W&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;U&lt;/code&gt;的子类  -  通过第二个参数的类型，&lt;code class=&quot;inline&quot;&gt;w&lt;/code&gt;必须可以被转换到&lt;code class=&quot;inline&quot;&gt;U&lt;/code&gt;类&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;U&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;的子类  -  函数定义中&lt;code class=&quot;inline&quot;&gt;U extends Z&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;Z&lt;/code&gt;被显式指定为&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;因为有限制（1）的存在，我们将限制（2）（3）中的U替换成X。在类型推导中，通配符给定的限制并不是限制，而是假设。因此限制（2）（3）可以被通配符类型来满足，所以&lt;code class=&quot;inline&quot;&gt;bind.upcast&lt;/code&gt;可以通过类型检查。&lt;/p&gt;&lt;p&gt;另外需要注意的是，尽管Java的类型参数推导是不可决定的（undecidable），Java 8的编译器成功地编译了上面的代码，而Java 9却无法编译。作者提到了类型推导是不确定的（non-deterministic），并认为Java 9先考虑了限制（2）（3）。由于子类关系是传递性的，那么&lt;code class=&quot;inline&quot;&gt;W&lt;/code&gt;必须是&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;的子类，而这个关系是不满足的，因此发生了编译错误。作者后续给出了其他Java 9的例子，可以通过编译，但是在运行时会抛出异常。（传送门里有其他例子）&lt;/p&gt;&lt;p&gt;第三步，则是找到一个合适的值。如果说我们没有办法提供一个&lt;code class=&quot;inline&quot;&gt;constrain&lt;/code&gt;的值，那么上面的例子就没有办法实现我们需要的功能。但是我们需要注意到，假设我们需要给定这个值，我们必须要找到一个类型来满足通配符中所要求的子类关系（即通配符中的类型是&lt;code class=&quot;inline&quot;&gt;W&lt;/code&gt;的母类，是&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;的子类），可这是没有办法做到的。幸运的是/不幸的是，在Java里，&lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt; 可以做任何引用类型的值。在这一步，我们就可以跳过寻找通配符类型的过程，但仍然通过类型检查。&lt;/p&gt;&lt;p&gt;至此，我们成功的构造了在Java类型系统容许下的任意类型之间的相互转换。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;作者分三方面来阐述这个例子带来的启示：&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）荒谬的类型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;假设我们拥有一个类型&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;是Top type的supertype，亦是Bottom type的subtype，那么我们即可通过此类型&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;来实现任何类型之间的转换，如：&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;String&lt;/code&gt; &amp;lt;: &lt;code class=&quot;inline&quot;&gt;Top&lt;/code&gt; &amp;lt;: &lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt; &amp;lt;: &lt;code class=&quot;inline&quot;&gt;Bottom&lt;/code&gt; &amp;lt;: &lt;code class=&quot;inline&quot;&gt;Integer&lt;/code&gt;&lt;/p&gt;&lt;p&gt;然而作者指出，使用算法来鉴别荒谬的类型是非常困难的。由于subtyping需要算法来实现，而类型验证亦需要算法实现。要成功地识别出荒谬的类型，二者之间会存在一些需要解决的循环依赖，给实现增加难度。 &lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）&lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt; —— the billion dollar mistake&lt;/b&gt;&lt;/p&gt;&lt;p&gt;作者指出了&lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt;在类型系统的中潜在的危害性。随着类型系统的逐步成熟，&lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt;的存在会给设计者带来更多需要考虑的地方。在本文中的例子里，我们通过&lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt;来跳过重要的推导步骤，实现任意类型之间的转换。在Java中&lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt;可以表示任何引用类型的值，在设计类型规则的时候，需要在此加以注意。 &lt;/p&gt;&lt;p&gt;&lt;b&gt;（3）没有预见的特性交互&lt;/b&gt;&lt;/p&gt;&lt;p&gt;作者指出了对于一门被众多人使用、特性丰富的语言，研究者很难做到将每个功能都正规化，然后将其验证。因此诸多研究者把Java的语言的核心部分形式化，并逐步迭代加入新的特性。但是在将Java语言取核心部分最小化成形式语言的过程中，会不会遗漏一些特性，使其与其他特性交互时，产生没有预见的效果。作者在此段从方法、验证、价值观和审阅、发表流程的角度来反思PL社群在这个方面需要额外注意的地方。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;参考资料：&lt;br&gt;&lt;a href=&quot;https://dev.to/rosstate/java-is-unsound-the-industry-perspective&quot;&gt;Java is Unsound: The Industry Perspective&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Lecture Notes of &lt;i&gt;Advanced Issues in Object-Oriented Programming&lt;/i&gt; by Sophia Drossopoulou&lt;/p&gt;&lt;hr&gt;&lt;p&gt;写在最后的话：&lt;/p&gt;&lt;p&gt;试着做一个类似于morning paper的读paper个人专栏，然而试了以后发现很艰难，花了挺长时间的。希望会是一个比较好的尝试，会有人来读我的个人专栏。欢迎评论留言讨论。不定期更新。下一篇paper暂时考虑写关于session type相关的内容。&lt;/p&gt;</description>
<author>由里子</author>
<guid isPermaLink="false">2018-03-30-35055185</guid>
<pubDate>Fri, 30 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Idris 教程中文版正式发布</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-28-35015527.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35015527&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c5246a546163f0bbfd814b28a1dcf606_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;经过一个月（并不）紧张的翻译和校对，&lt;a href=&quot;http://idris-zh.readthedocs.io/zh_CN/latest/tutorial/index.html&quot;&gt;Idris 教程&lt;/a&gt; 正式发布。 自此，官方文档的翻译暂时告一段落。&lt;a href=&quot;http://idris-zh.readthedocs.io/zh_CN/latest/st/index.html&quot;&gt;ST 教程&lt;/a&gt; 的翻译仍在进行中。&lt;/p&gt;&lt;p&gt;官方文档中还有 FAQ、Effect 教程、定理证明和语言参考尚未翻译，然而咱目前又有了别的计划（没错 Idris-zh 又坑了），于是甩锅给社区自然发展好了= =||&lt;/p&gt;&lt;p&gt;Idris 虽然非常漂亮，然而发展还不成熟，缺少一些常用的库和工具。目前她还十分小众，因此 Type-Driven Development with Idris 中文版的引进估计是不可能了。官方教程涉及的点较少，有些不够深入，对初学者也不如这本书友好。因此有条件和能力的读者建议读一下这本书。&lt;/p&gt;&lt;p&gt;如果你有兴趣继续参与翻译，欢迎直接戳咱，随时恭候~！&lt;/p&gt;</description>
<author>Oling Cat</author>
<guid isPermaLink="false">2018-03-28-35015527</guid>
<pubDate>Wed, 28 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（九）：Let polymorphism</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-26-34915143.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34915143&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d8893deacbd14601cc4881797561323d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;500&quot;&gt;&lt;h2&gt;&lt;b&gt;类型变量&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;到目前为止，我们遇到的每一个 &lt;equation&gt;\lambda&lt;/equation&gt; 项都有唯一确定的类型，&lt;br&gt;因为，项的类型都被显式的注释在了它的后面。&lt;br&gt;例如，我们可以定义一个恒等函数 &lt;equation&gt;id=\lambda x:Nat.~x:Nat\to Nat&lt;/equation&gt; ，&lt;br&gt;则 &lt;equation&gt;id&lt;/equation&gt; 的类型就是固定的， &lt;equation&gt;Nat\to Nat&lt;/equation&gt; ，而 &lt;equation&gt;id~true&lt;/equation&gt; 就不是良类型的。&lt;/p&gt;&lt;p&gt;为每一个类型的恒等函数都定义各自的版本，是非常繁琐的，&lt;br&gt;因此，一个自然的想法是，我们能否让 &lt;equation&gt;id&lt;/equation&gt; 的类型&lt;b&gt;参数化&lt;/b&gt;，&lt;br&gt;让它在不同的上下文中，实例化为不同的具体类型。&lt;br&gt;例如， &lt;equation&gt;id=\lambda x:X.~x:X\to X&lt;/equation&gt; ，其中 &lt;equation&gt;X&lt;/equation&gt; 是&lt;b&gt;类型参量&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;类型代换&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;类型代换&lt;/b&gt; &lt;equation&gt;\sigma&lt;/equation&gt; ，指的是一个从类型变量到类型的有限映射。&lt;br&gt;例如， &lt;equation&gt;\sigma=[X\mapsto T,Y\mapsto U]&lt;/equation&gt; ，会将类型变量 &lt;equation&gt;X,Y&lt;/equation&gt; 分别代换为 &lt;equation&gt;T,U&lt;/equation&gt; 。&lt;br&gt;其中， &lt;equation&gt;X,Y&lt;/equation&gt; 称为代换 &lt;equation&gt;\sigma&lt;/equation&gt; 的&lt;b&gt;定义域&lt;/b&gt;，记为 &lt;equation&gt;dom(\sigma)&lt;/equation&gt; ，&lt;br&gt;而 &lt;equation&gt;T,U&lt;/equation&gt; 称为代换 &lt;equation&gt;\sigma&lt;/equation&gt; 的&lt;b&gt;值域&lt;/b&gt;，记为 &lt;equation&gt;range(\sigma)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;值得一提的是，所有的代换都是同时进行的， &lt;equation&gt;\sigma=[X\mapsto Bool,Y\mapsto X\to X]&lt;/equation&gt; ，&lt;br&gt;是将 &lt;equation&gt;X&lt;/equation&gt; 映射成 &lt;equation&gt;Bool&lt;/equation&gt; ，将 &lt;equation&gt;Y&lt;/equation&gt; 映射成 &lt;equation&gt;X\to X&lt;/equation&gt; ，而不是 &lt;equation&gt;Bool\to Bool&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;代换&lt;/b&gt;可以用下面的方式来定义，&lt;br&gt;（1） &lt;equation&gt;\sigma(X)=X&lt;/equation&gt; ，如果 &lt;equation&gt;X\notin dom(\sigma)&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\sigma(X)=T&lt;/equation&gt; ，如果 &lt;equation&gt;(X\mapsto T)\in\sigma&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;\sigma(Nat)=Nat&lt;/equation&gt; ， &lt;equation&gt;\sigma(Bool)=Bool&lt;/equation&gt; &lt;br&gt;（4） &lt;equation&gt;\sigma(T_1\to T_2)=\sigma T_1\to\sigma T_2&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;对于类型上下文 &lt;equation&gt;\Gamma=\{x_1:T_1,\cdots,x_n:T_n\}&lt;/equation&gt; 来说， &lt;equation&gt;\sigma\Gamma=\{x_1:\sigma T_1,\cdots,x_n:\sigma T_n\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;类型代换的一个重要特性是它保留了类型声明的有效性，&lt;br&gt;如果包含类型变量的项是良类型的，那么它的所有代换实例也都是良类型的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;类型推断&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-691c692ba80fac2d4b7d02741c0a3da2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;753&quot; data-rawheight=&quot;496&quot;&gt;&lt;p&gt;在类型上下文 &lt;equation&gt;\Gamma&lt;/equation&gt; 中，对于包含类型变量的项 &lt;equation&gt;t&lt;/equation&gt; ，我们通常会提出两个问题，&lt;/p&gt;&lt;p&gt;（1）它的所有代换实例，是否都是良类型的？&lt;br&gt;即，是否 &lt;equation&gt;\forall\sigma\exists T,\sigma\Gamma\vdash\sigma t:T&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;（2）是否存在良类型的代换实例？&lt;br&gt;即，是否 &lt;equation&gt;\exists\sigma\exists T,\sigma\Gamma\vdash\sigma t:T&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;对于第一个问题，将引出&lt;b&gt;参数化多态&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Parametric_polymorphism&quot;&gt;parametric polymorphism&lt;/a&gt;），&lt;br&gt;例如， &lt;equation&gt;\lambda f:X\to X.\lambda a:X.f(f(a))&lt;/equation&gt; ，它的类型为 &lt;equation&gt;(X\to X)\to X\to X&lt;/equation&gt; ，&lt;br&gt;无论用什么具体类型 &lt;equation&gt;T&lt;/equation&gt; 来代换 &lt;equation&gt;X&lt;/equation&gt; ，代换实例都是良类型的。&lt;/p&gt;&lt;p&gt;对于第二个问题，原始的项可能不是良类型的，&lt;br&gt;但是可以选择合适的类型代换使之实例化为良类型的项。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\lambda f:Y.\lambda a:X.f(f(a))&lt;/equation&gt; ，是不可类型化的，&lt;br&gt;但是如果用 &lt;equation&gt;Nat\to Nat&lt;/equation&gt; 代换 &lt;equation&gt;Y&lt;/equation&gt; ，用 &lt;equation&gt;Nat&lt;/equation&gt; 代换 &lt;equation&gt;X&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\sigma=[X\mapsto Nat,Y\mapsto Nat\to Nat]&lt;/equation&gt; ，&lt;br&gt;就可以得到， &lt;equation&gt;\lambda f:Nat\to Nat.\lambda a:Nat.f(f(a))&lt;/equation&gt; ，&lt;br&gt;可类型化为 &lt;equation&gt;(Nat\to Nat)\to Nat\to Nat&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;或者，取 &lt;equation&gt;\sigma&#39;=[Y\mapsto X\to X]&lt;/equation&gt; ，结果也能得到一个良类型的项，尽管仍包含变量。&lt;/p&gt;&lt;p&gt;在寻找类型变量有效实例的过程中，出现了&lt;b&gt;类型推断&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Type_inference&quot;&gt;type inference&lt;/a&gt;）的概念。&lt;br&gt;意味着由编译器来帮助推断 &lt;equation&gt;\lambda&lt;/equation&gt; 项的具体类型，&lt;br&gt;在&lt;a href=&quot;https://en.wikipedia.org/wiki/ML_(programming_language)&quot;&gt;ML&lt;/a&gt;语言中，程序员可以忽略所有的类型注释——隐式类型（&lt;a href=&quot;http://wiki.c2.com/?ImplicitTyping&quot;&gt;implicit typing&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;在进行推断的时候，对每一个原始的 &lt;equation&gt;\lambda&lt;/equation&gt; 抽象 &lt;equation&gt;\lambda x.t&lt;/equation&gt; ，&lt;br&gt;都用新的类型变量进行注释，写成 &lt;equation&gt;\lambda x:X.t&lt;/equation&gt; ，&lt;br&gt;然后采取特定的类型推导算法，找到使项通过类型检查的一个最一般化的解。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;\Gamma&lt;/equation&gt; 为类型上下文， &lt;equation&gt;t&lt;/equation&gt; 为项，&lt;br&gt; &lt;equation&gt;(\Gamma,t)&lt;/equation&gt; 的&lt;b&gt;解&lt;/b&gt;，是指这样的一个序对 &lt;equation&gt;(\sigma,T)&lt;/equation&gt; ，使得 &lt;equation&gt;\sigma\Gamma\vdash\sigma t:T&lt;/equation&gt; 成立。&lt;/p&gt;&lt;p&gt;例如，设 &lt;equation&gt;\Gamma=f:X,a:Y&lt;/equation&gt; ， &lt;equation&gt;t=f~a&lt;/equation&gt; ，则&lt;br&gt; &lt;equation&gt;(\sigma=[X\mapsto Y\to Nat],Nat)&lt;/equation&gt; ， &lt;equation&gt;(\sigma=[X\mapsto Y\to Z],Z)&lt;/equation&gt; ，都是 &lt;equation&gt;(\Gamma,t)&lt;/equation&gt; 的解。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;基于约束的类型化&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-281fd8e3781690168c07b31e22bc9325_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;333&quot; data-rawheight=&quot;109&quot;&gt;&lt;p&gt;&lt;b&gt;（1）约束集&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在实际情况中， &lt;equation&gt;(\Gamma,t)&lt;/equation&gt; 的解，并不一定满足其他类型表达式的约束条件，&lt;br&gt;所以，我们寻找的是满足这些约束条件的特解。&lt;/p&gt;&lt;p&gt;所谓&lt;b&gt;约束条件&lt;/b&gt;，实际上指的是约束集 &lt;equation&gt;C&lt;/equation&gt; ，&lt;br&gt;它由一些包含类型参量的项的等式构成， &lt;equation&gt;\{S_i=T_i|i\in l..n\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果一个代换 &lt;equation&gt;\sigma&lt;/equation&gt; 的代换实例， &lt;equation&gt;\sigma S&lt;/equation&gt; 和 &lt;equation&gt;\sigma T&lt;/equation&gt; 相同，则称该代换&lt;b&gt;合一&lt;/b&gt;（unify）了等式 &lt;equation&gt;S=T&lt;/equation&gt; 。&lt;br&gt;如果 &lt;equation&gt;\sigma&lt;/equation&gt; 能合一 &lt;equation&gt;C&lt;/equation&gt; 中的所有等式，则称 &lt;equation&gt;\sigma&lt;/equation&gt; 能&lt;b&gt;合一&lt;/b&gt;（unify）或满足（satisfy） &lt;equation&gt;C&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们用 &lt;equation&gt;\Gamma\vdash t:T|_\chi C&lt;/equation&gt; ，来表示约束集 &lt;equation&gt;C&lt;/equation&gt; 满足时，项 &lt;equation&gt;t&lt;/equation&gt; 在 &lt;equation&gt;\Gamma&lt;/equation&gt; 下的类型为 &lt;equation&gt;T&lt;/equation&gt; ，&lt;br&gt;其中 &lt;equation&gt;\chi&lt;/equation&gt; 为约束集中，所有类型变量的集合，有时为了讨论方便可以省略它。&lt;/p&gt;&lt;p&gt;例如，对于项 &lt;equation&gt;t=\lambda x:X\to Y.x~0&lt;/equation&gt; ，&lt;br&gt;约束集可以写为 &lt;equation&gt;\{Nat\to Z=X\to Y\}&lt;/equation&gt; ，则 &lt;equation&gt;t&lt;/equation&gt; 类型为 &lt;equation&gt;(X\to Y)\to Z&lt;/equation&gt; 。（算法略）&lt;br&gt;而代换 &lt;equation&gt;\sigma=[X\mapsto Nat,Z\mapsto Bool,Y\mapsto Bool]&lt;/equation&gt; ，使得等式 &lt;equation&gt;Nat\to Z=X\to Y&lt;/equation&gt; 成立，&lt;br&gt;所以，我们推断出了 &lt;equation&gt;(Nat\to Bool)\to Bool&lt;/equation&gt; 是项 &lt;equation&gt;t&lt;/equation&gt; 的一个可能类型。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）约束集的解&lt;/b&gt;&lt;/p&gt;&lt;p&gt;约束集的解一般不是唯一的，所以一个关键问题是如何确定一个“最好”的解。&lt;/p&gt;&lt;p&gt;我们称代换 &lt;equation&gt;\sigma&lt;/equation&gt; 比 &lt;equation&gt;\sigma&#39;&lt;/equation&gt; &lt;b&gt;更具一般性&lt;/b&gt;（more general），如果 &lt;equation&gt;\sigma&#39;=\gamma\circ\sigma&lt;/equation&gt; ，记为 &lt;equation&gt;\sigma\sqsubseteq\sigma&#39;&lt;/equation&gt; ，&lt;br&gt;其中， &lt;equation&gt;\gamma&lt;/equation&gt; 为一个代换， &lt;equation&gt;\gamma\circ\sigma&lt;/equation&gt; 表示代换的复合， &lt;equation&gt;(\gamma\circ\sigma)S=\gamma(\sigma S)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;约束集 &lt;equation&gt;C&lt;/equation&gt; 的&lt;b&gt;主合一子&lt;/b&gt;（principal unifier）指的是代换 &lt;equation&gt;\sigma&lt;/equation&gt; ，&lt;br&gt;它能满足 &lt;equation&gt;C&lt;/equation&gt; ，且对于所有满足 &lt;equation&gt;C&lt;/equation&gt; 的代换 &lt;equation&gt;\sigma&#39;&lt;/equation&gt; ，都有 &lt;equation&gt;\sigma\sqsubseteq\sigma&#39;&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;(\Gamma,t,S,C)&lt;/equation&gt; 的解 &lt;equation&gt;(\sigma,T)&lt;/equation&gt; ，对于任何其他解 &lt;equation&gt;(\sigma&#39;,T&#39;)&lt;/equation&gt; ，都有 &lt;equation&gt;\sigma\sqsubseteq\sigma&#39;&lt;/equation&gt; ，&lt;br&gt;则称 &lt;equation&gt;(\sigma,T)&lt;/equation&gt; 是一个&lt;b&gt;主解&lt;/b&gt;（principal solution），称 &lt;equation&gt;T&lt;/equation&gt;  为 &lt;equation&gt;t&lt;/equation&gt; 的&lt;b&gt;主类型&lt;/b&gt;（principal type）。&lt;br&gt;可以证明，如果 &lt;equation&gt;(\Gamma,t,S,C)&lt;/equation&gt; 有解，则它必有一个主解。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;let多态&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-98db611b8facd70dd4be4eebdc7e1212_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;633&quot; data-rawheight=&quot;357&quot;&gt;&lt;p&gt;&lt;b&gt;多态&lt;/b&gt;（polymorphism）指的是单独一段程序能在不同的上下文中实例化为不同的类型。&lt;br&gt;其中let多态，是由let表达式引入的多态性。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）单态性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;假设我们定义了一个 &lt;equation&gt;double&lt;/equation&gt; 函数，它能将一个函数对参数应用两次，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:Nat\to Nat.\lambda a:Nat.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~double~(\lambda x:Nat.succ~x)~1&lt;/equation&gt; &lt;br&gt;此时， &lt;equation&gt;double&lt;/equation&gt; 的类型为 &lt;equation&gt;(Nat\to Nat)\to Nat\to Nat&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果我们想将 &lt;equation&gt;double&lt;/equation&gt; 应用于其他类型，就必须重写一个新的 &lt;equation&gt;double&#39;&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;let~double&#39;=\lambda f:Bool\to Bool.\lambda a:Bool.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~double&#39;~(\lambda x:Bool.x)~true&lt;/equation&gt; &lt;br&gt;此时 &lt;equation&gt;double&#39;&lt;/equation&gt; 的类型为 &lt;equation&gt;(Bool\to Bool)\to Bool\to Bool&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们不能让一个 &lt;equation&gt;double&lt;/equation&gt; 函数，既能用于 &lt;equation&gt;Nat&lt;/equation&gt; 类型，又能用于 &lt;equation&gt;Bool&lt;/equation&gt; 类型。&lt;br&gt;即使在 &lt;equation&gt;double&lt;/equation&gt; 中用类型变量也没有用，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in~\cdots&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;例如，如果写，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~let~a=double~(\lambda x:Nat.succ~x)~1~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~~~~~let~b=double~(\lambda x:Bool.x)~true~in~\cdots&lt;/equation&gt; &lt;br&gt;则在 &lt;equation&gt;a&lt;/equation&gt; 定义中使用 &lt;equation&gt;double&lt;/equation&gt; ，会产生一个约束 &lt;equation&gt;X\to X=Nat\to Nat&lt;/equation&gt; ，&lt;br&gt;而在 &lt;equation&gt;b&lt;/equation&gt; 定义中使用 &lt;equation&gt;double&lt;/equation&gt; ，则会产生约束 &lt;equation&gt;X\to X=Bool\to Bool&lt;/equation&gt; ，&lt;br&gt;这样会使类型变量 &lt;equation&gt;X&lt;/equation&gt; 的求解发生矛盾，导致整个程序不可类型化。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）多态性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;let多态所做的事情，就是打破这个限制，&lt;br&gt;让类型参量 &lt;equation&gt;X&lt;/equation&gt; 在上述不同的上下文中，可以分别实例化为 &lt;equation&gt;Nat&lt;/equation&gt; 和 &lt;equation&gt;Bool&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;这需要改变与let表达式相关的类型推导规则，在第七篇中，我们提到过，&lt;br&gt; &lt;equation&gt;\frac{\Gamma\vdash t_1:T_1~~~~\Gamma,x:T_1\vdash t_2:T_2}{\Gamma\vdash let~x:T_1=t_1~in~t_2:T_2}&lt;/equation&gt; &lt;br&gt;它会首先计算 &lt;equation&gt;T_1&lt;/equation&gt; 作为 &lt;equation&gt;x&lt;/equation&gt; 的类型，然后再用 &lt;equation&gt;x&lt;/equation&gt; 来确定 &lt;equation&gt;T_2&lt;/equation&gt; 的类型。&lt;br&gt;此时，let表达式 &lt;equation&gt;let~x=t_1:T_1~in~t_2&lt;/equation&gt; ，可以看做 &lt;equation&gt;(\lambda x:T_1.t_2)t_1&lt;/equation&gt; 的简写。&lt;/p&gt;&lt;p&gt;为了引入多态性，我们需要对上述类型推导规则进行修改，&lt;br&gt; &lt;equation&gt;\frac{\Gamma\vdash[x\mapsto t_1]t_2:T_2}{\Gamma\vdash let~x=t_1~in~t_2:T_2}&lt;/equation&gt; &lt;br&gt;它表示，先将 &lt;equation&gt;t_2&lt;/equation&gt; 中的 &lt;equation&gt;x&lt;/equation&gt; 用 &lt;equation&gt;t_1&lt;/equation&gt; 代换掉，然后再确定 &lt;equation&gt;t_2&lt;/equation&gt; 的类型。&lt;/p&gt;&lt;p&gt;这样的话，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~let~a=double~(\lambda x:Nat.succ~x)~1~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~~~~~let~b=double~(\lambda x:Bool.x)~true~in~\cdots&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;就相当于，&lt;br&gt; &lt;equation&gt;let~a=\lambda f:X\to X.\lambda a:X.f(f(a))~(\lambda x:Nat.succ~x)~1~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~let~b=\lambda f:Y\to Y.\lambda a:Y.f(f(a))~(\lambda x:Bool.x)~true~in~\cdots&lt;/equation&gt; &lt;br&gt;通过let多态，产生了 &lt;equation&gt;double&lt;/equation&gt; 的两个&lt;b&gt;副本&lt;/b&gt;，并为之分配了不同的类型参量。&lt;/p&gt;&lt;p&gt;此时，let表达式 &lt;equation&gt;let~x=t_1~in~t_2&lt;/equation&gt; ，可以看做 &lt;equation&gt;[x\mapsto t_1]t_2&lt;/equation&gt; 的简写。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Let-polymorphism&quot;&gt;Hindley–Milner type system&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1761910/&quot;&gt;Types and programming languages&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.haskell.org/definition/haskell2010.pdf&quot;&gt;Haskell 2010 Language Report&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-26-34915143</guid>
<pubDate>Mon, 26 Mar 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
