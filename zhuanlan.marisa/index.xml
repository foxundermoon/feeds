<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Fri, 08 Jun 2018 17:35:38 +0800</lastBuildDate>
<item>
<title>展望未来</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-06-07-37515535.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37515535&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在我拿起那估计比火箭西决G7三分球命中率还铁的水晶球去预测未来编程语言的走向以前，我想先翻翻我那堆历史书，总结下三条规律。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;0：摩尔定律。GPU，内存，硬盘，网络的指数增长在肉眼可见范围里面还远远没到头。CPU上的增长也还有一段时间 - CPU已经在摩尔定律要凉的论调下已经可持续崩溃式发展了10多年了。如果再假设我们会有基础性进展，这些东西只怕会续命更久。当然，有些常数我们越不过，比如硬盘网络的延迟，还有光速一样，但是没关系。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1：量变引起质变。就如同利威尔阿克曼跟十五米高的进击巨人行动方式有着天壤之别一样，如果一个参数改变了一个数量级，规则跟各种定律都得大改。跟摩尔定律结合起来，这对定律就能多次把不可能化为无聊透顶 - 你手上拿着的手机，在1970年就有原型，而你现在在看着的显示器，在几年前最顶尖的研究所才能量SRI之财力买下几个。时间快进50年，这已经成为人手一抓丢了都不怎么心疼的常见物了。例子远远不止这一个：互联网，个人计算机，甚至计算机，全部都是靠摩尔定律续起来的。软件也是如此 - 打败世界第零的国际象棋AI从‘横竖怎么看反正都不可能’，到‘哈？我手机在这，拿去’之间的差距，除了优化一下暴力搜索以外，就是‘我的硬件快得暴力就能解决问题了’。事实上，暴力搜索已经成为使用计算机的标准操作了 - Intel很早就采用了SAT solver来验证&amp;amp;排电路，Z3出现了10年了，而深度学习需要的计算量一点也不虚这几位。。支撑起这些应用的计算力提升何止兵长变巨人，是成千上百万啊。把现在的计算机跟几十年前的视为同一种东西，比把还在爬的熊孩子跟喷气式飞机对比还离谱，毕竟后者只有100倍速度差。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;2：编译器大法好。Fortran老爹之所以有资格拿图灵奖，是因为天下之间，只有Fortran做出‘跟手写效率在一个数量级的高级编程语言’。在此之前，什么是编程语言？学术界做出的又慢又没用的东西而已。如果我们再把时间往前拨一下，我们甚至可以看到海军准将在跟她上司据理力争‘老大你看，COBOL才不是什么理论上不可能实现的东西，听我说啊’。再启动一下bite the dust呢？我们可以看到老冯在怒斥下属‘你在搞什么，我很angry，怎么可以用汇编器，你浪费了多少CPU cycle你知道吗？’。事实上，在我们黑啥语言效率不如C以前，我们是在黑C效率不如Fortran，Fortran 效率不如汇编，汇编浪费CPU Cycle。这也是为啥我认为计算机科学的理论深度无可比拟 - 计算机实在太难以估摸了，纵使通天彻地如老冯，发明完一套集合论搞量子力学，再转去给计算机发明出一套沿用至今的架构，也无法猜出计算机的最基本用法。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;回到正文。好，我们在开始以前，再看看一个东西：Javascript。我们看看这两个post：&lt;/p&gt;&lt;a href=&quot;https://www.breck-mckye.com/blog/2018/05/why-is-front-end-development-so-unstable/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Why is Front-End Development So Unstable?&lt;/a&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=17191872&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Web frameworks are churn-y because they are incredibly leaky abstractions coveri...&lt;/a&gt;&lt;p&gt;基本上就两个问题。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;0：库太多，不知道用啥&lt;/li&gt;&lt;li&gt;1：Impedance Mismatch。举个例子，当你用LINQ的时候很多不好的事情事情可能发生：你传进LINQ的高阶函数可能无法编译成SQL（用了闭包，或者副作用等），可能无法表示想要的东西（SQL的NULL），可能语义对不上（SQL NULL上的操作不会err而是传递NULL），而最严重的问题是，你要懂SQL。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果我们把上面的三个定律融合一下，这两个问题将不复存在。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;编译器将消除绝大部分的Impedance Mismatch。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们来看看要写出高效，可以处理大量数据的程序，我们需要知道啥：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;分布式计算&lt;/li&gt;&lt;li&gt;数据库&lt;/li&gt;&lt;li&gt;并发编程&lt;/li&gt;&lt;li&gt;GPU&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;而这个Stack里面有什么是必要的？&lt;/p&gt;&lt;p&gt;我们试试看描述每个东西的用途：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;分布式计算保证你的数据有多份储存，提高redundancy，并且提速&lt;/li&gt;&lt;li&gt;数据库效率快，并且保证redundancy&lt;/li&gt;&lt;li&gt;并发编程提高效率&lt;/li&gt;&lt;li&gt;GPU提高效率&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们可以发现，这一切额外的复杂度，其实是为了效率。而既然人类能在写程序的时候推理出如何做这些优化，凭啥编译器推不出来？大不了暴力搜索。靠计算机软件隐藏leaky abstraction又不是没发生过，上古时期码农还得写代码来swap暂时用不上的memory进磁盘呢。&lt;/p&gt;&lt;p&gt;事实上，有些地方，编译器优化就是各种各样暴力搜索，&lt;a href=&quot;https://en.wikipedia.org/wiki/Superoptimization&quot;&gt;Superoptimization - Wikipedia&lt;/a&gt;是， &lt;a href=&quot;https://zhuanlan.zhihu.com/p/37181530&quot;&gt;AutoTVM：让AI来编译优化AI系统底层算子&lt;/a&gt; 是，&lt;a href=&quot;https://facebookresearch.github.io/TensorComprehensions/tutorials/index.html&quot;&gt;Tensor Comprehensions Tutorials&lt;/a&gt; 也是。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://grappa.io/&quot;&gt;自动分布式计算&lt;/a&gt; 有（TensorFlow也应该算），单机并发更不在话下，那还要数据库做啥？数据库的ACID跟recovery，也只是自动分布式计算下的ACID跟recovery，交给自动分布式就好了啊！&lt;/p&gt;&lt;p&gt;当然，如果你眼尖，你会提出一个问题，‘程序的行数，远远比摩尔定律带来的倍数多啊，指数会爆炸啊。’这个问题的答案得益于我们很蠢。笨得一时间只能想起撑死十几个东西。所以我们强迫自己写代码需要写得更模块化，一段代码做一件东西。所以我们抛弃掉goto。&lt;/p&gt;&lt;p&gt;换句话说编译器能对程序一小段一小段的进行推理，最后compose起来。&lt;/p&gt;&lt;p&gt;如果我们激进点，可以假设这个分布式计算网络覆盖了全球，那其实我们就剩下一台计算机了。或者说，到了这个地步，计算机这个词已经过时，我们应该用‘算力’来代表这种无处不在的物体了。至于支付跟安全性问题？我想想。。。区块链？&lt;br&gt;&lt;/p&gt;&lt;p&gt;这还有一个副作用：以后大家写Haskell需要用IO的地方都能去掉一大半了。数据库，并发，网络，通通不需要，连文件也能顺带扫进历史的垃圾桶了‘啥叫读写文件。。。你不能。。用参数吗？’。计算机的三种交互中，计算机&amp;lt;-&amp;gt;计算机会完全消失，计算机&amp;lt;-&amp;gt;人也许会被&lt;a href=&quot;http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability&quot;&gt;Tangible Functional Programming: a modern marriage of usability and composability&lt;/a&gt;代替，那只剩下不常见的计算机&amp;lt;-&amp;gt;机器臂了。The future is superfunctional Aka &lt;a href=&quot;http://conal.net/blog/posts/can-functional-programming-be-liberated-from-the-von-neumann-paradigm&quot;&gt;Can functional programming be liberated from the von Neumann paradigm?&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;既然编译器能做这么多优化，离自动编程还有多远？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;自动编程的尝试有一大堆，Program Synthesis/Genetic Programming/Differentiable Programming等全是。如果限制Domain，也有&lt;a href=&quot;https://cozy.uwplse.org/&quot;&gt;取得不错成绩&lt;/a&gt;的。&lt;/p&gt;&lt;p&gt;这里很重要的一点是，&lt;a href=&quot;https://www.zhihu.com/question/56250357/answer/148934031&quot;&gt;别看到AI，就不成功便成仁，不是没用，就是抢掉我的岗位&lt;/a&gt; - &lt;a href=&quot;https://www.youtube.com/watch?v=er_lLvkklsk&quot;&gt;这些东西完全可以整合进IDE中，提高编程生产力。&lt;/a&gt;&lt;/p&gt;&lt;p&gt;而最近，&lt;a href=&quot;https://blogs.msdn.microsoft.com/visualstudio/2018/05/07/introducing-visual-studio-intellicode/&quot;&gt;微软就在往这个方向前进&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;而我们已经可以在这个5分钟的demo中，看出一下可以怎么extend下去了：最简单的，设一个hotkey，按一下则会选取当前的autocomplete，然后跳到下一个需要写代码的地方（hole）。或者，拿最近历史记录&amp;amp;当前函数名&amp;amp;类型作hint，这样啥也不写也能开始autocomplete。又或者，autocomplete会爬Github，找出最关联的函数，然后给你pull该项目为dependency下来。这样怕啥百万package，我有autocomplete。而这背后需要啥，才能变得实用？啥也不需要，预测准确度一步步提升而已。量变引起质变。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;最后说下我写的时候意料不及的东西&lt;/b&gt;&lt;/p&gt;&lt;p&gt;其实JS这种package management style（相对来说）有点接近&lt;a href=&quot;https://www.zhihu.com/question/266108521&quot;&gt;《Why do we need modules at all?》？&lt;/a&gt; 。当然，没有好的metadata/工具造成的混像我们都看见了。&lt;/p&gt;&lt;p&gt;从另一个角度来看，很巧妙的是，风马牛不相及（Compiler，Pure Function）的东西竟然互相影响了（Autocomplete，Module System）。我认为这是因为一个东西work不work很可能只是有暂时的问题，并不一定是因为从跟不上不可行。而这些问题可能随着某些奇奇怪怪的advance被奇奇怪怪的解决掉。预测未来真难啊。&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2018-06-07-37515535</guid>
<pubDate>Thu, 07 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>第四届函数式编程分享会视频</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-06-04-37649613.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37649613&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;函数式编程入门 (&lt;a href=&quot;http://v.youku.com/v_show/id_XMzY0MTMyODg3Ng==.html&quot;&gt;youku&lt;/a&gt;) by &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0a308ec0bd0ce92754be4e85db62a29a&quot; data-hash=&quot;0a308ec0bd0ce92754be4e85db62a29a&quot; data-hovercard=&quot;p$b$0a308ec0bd0ce92754be4e85db62a29a&quot;&gt;@parker liu&lt;/a&gt; &lt;/li&gt;&lt;li&gt;libuv based IO manager (&lt;a href=&quot;http://v.youku.com/v_show/id_XMzY0MjM3OTU2NA==.html?spm=a2hzp.8253869.0.0&quot;&gt;youku&lt;/a&gt;) by &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/73c168246af1fab79b28736c311466e1&quot; data-hash=&quot;73c168246af1fab79b28736c311466e1&quot; data-hovercard=&quot;p$b$73c168246af1fab79b28736c311466e1&quot;&gt;@韩冬&lt;/a&gt;, 有兴趣可以找他看paper的草稿&lt;/li&gt;&lt;li&gt;HoTT定理证明 (&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37062630&quot;&gt;文章&lt;/a&gt;, &lt;a href=&quot;http://v.youku.com/v_show/id_XMzY0MjY2MTEzMg==.html?spm=a2hzp.8253869.0.0&quot;&gt;youku&lt;/a&gt;) by &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/8e592bf5d153a7c933d8150333b77ef2&quot; data-hash=&quot;8e592bf5d153a7c933d8150333b77ef2&quot; data-hovercard=&quot;p$b$8e592bf5d153a7c933d8150333b77ef2&quot;&gt;@Martin awodey&lt;/a&gt; &lt;/li&gt;&lt;li&gt;范畴上的构造主义 (&lt;a href=&quot;http://v.youku.com/v_show/id_XMzY0MjkxNDU5Ng==.html?spm=a2hzp.8253869.0.0&quot;&gt;下&lt;/a&gt;) by &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0a308ec0bd0ce92754be4e85db62a29a&quot; data-hash=&quot;0a308ec0bd0ce92754be4e85db62a29a&quot; data-hovercard=&quot;p$b$0a308ec0bd0ce92754be4e85db62a29a&quot;&gt;@parker liu&lt;/a&gt; , 上估计还在上传&lt;/li&gt;&lt;li&gt;Haskell 中的类型类实例实现 by &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6676ea444bda2c703add8474963e800a&quot; data-hash=&quot;6676ea444bda2c703add8474963e800a&quot; data-hovercard=&quot;p$b$6676ea444bda2c703add8474963e800a&quot;&gt;@阅千人而惜知己&lt;/a&gt; , 还没上传&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;ppt 都在微信群里, 下不回来了, 各位方便的可以给我个链接&lt;/p&gt;&lt;p&gt;感谢几位的分享 和 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6676ea444bda2c703add8474963e800a&quot; data-hash=&quot;6676ea444bda2c703add8474963e800a&quot; data-hovercard=&quot;p$b$6676ea444bda2c703add8474963e800a&quot;&gt;@阅千人而惜知己&lt;/a&gt; 和 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0a308ec0bd0ce92754be4e85db62a29a&quot; data-hash=&quot;0a308ec0bd0ce92754be4e85db62a29a&quot; data-hovercard=&quot;p$b$0a308ec0bd0ce92754be4e85db62a29a&quot;&gt;@parker liu&lt;/a&gt; 整理视频&lt;/p&gt;</description>
<author>祖与占</author>
<guid isPermaLink="false">2018-06-04-37649613</guid>
<pubDate>Mon, 04 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>PCP Theorem 序0</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-05-22-37132427.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37132427&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cfad1bac7ce7f070d2594ae717c075ac_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;这学期上了一下学校的计算复杂度理论（Computational Complexity）。由于课上只剩下了6个人，所以James决定取消Final，然后让我们六个人一起讲一遍PCP (Probabilistic Checkable Proof) Theorem的证明 ( Irit Dinur 的版本） 我决定把它整理一下，然后挂在这里。&lt;/p&gt;&lt;p&gt;阅读本系列文章，需要一些关于复杂度理论的基础知识，虽然我感觉PCP theorem本身也算基础知识XD.&lt;/p&gt;&lt;p&gt;我估计文章会分为如下几个部分：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;PCP Theorem的介绍 &lt;/li&gt;&lt;li&gt;PCP Theorem 和 &lt;equation&gt;\textrm{GAP-3SAT} \in \textrm{NP-hard}&lt;/equation&gt; 的等价&lt;/li&gt;&lt;li&gt;Expander 图的介绍以及它的基本定理&lt;/li&gt;&lt;li&gt;Irit Dinur 证明的概述&lt;/li&gt;&lt;li&gt;Constraint Graph和Degree Reduction&lt;/li&gt;&lt;li&gt;Gap Amplification&lt;/li&gt;&lt;li&gt;字母表规约 (Alphabet Reduction)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;本文基本上会按照&lt;a href=&quot;https://courses.cs.washington.edu/courses/cse533/05au/&quot;&gt;我校05年Venkatesan Guruswami 和 Ryan O&#39;Donnell的notes&lt;/a&gt;的顺序来讲。&lt;/p&gt;&lt;p&gt;欢迎大家提出任何证明和翻译上的问题。 &lt;/p&gt;&lt;p&gt;P.S. &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0251012c87c2d3f56ac34de7d71cdcbc&quot; data-hash=&quot;0251012c87c2d3f56ac34de7d71cdcbc&quot; data-hovercard=&quot;p$b$0251012c87c2d3f56ac34de7d71cdcbc&quot;&gt;@圆角骑士魔理沙&lt;/a&gt; 也在课上！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Guanghao Ye</author>
<guid isPermaLink="false">2018-05-22-37132427</guid>
<pubDate>Tue, 22 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>520究极进化 - 心跳心跳大作战</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-05-21-37098961.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37098961&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大家520快乐！祝各位都能跟心仪的另一半进行crossover，产生fitness更高的后代哦~&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;蛤？你没有另一半？没关系，小编发现了一个库，用了这个库，你就能跟心仪的数据结构进行交合了哦~ 更厉害的是，交合对象跟你种类不一样也可以呢。甚至，多p交合也是小事一桩哦~ 你还在等什么，快来implement你内心深处的privateの梦吧！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;a href=&quot;http://okmij.org/ftp/Haskell/extensible/#crossover&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;http://okmij.org/ftp/Haskell/extensible/#crossover&lt;/a&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Extensible Effect旨在解决一个问题：如何Extensible的添加新Effect（这不废话吗）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们的老朋友Data Type A La Carte酱尽管对Extensible挺能干的，但在这其实挺苦手的 - DTALC并不能Extensible的改变返回值，而每次新增Effect都需要这样做。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在Generic Crossover中，Oleg用Extensible Effect实现了一个State，一个Coroutine，然后就可以用两个effect来（加上SYB）作任意crossover&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32677377&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;圆角骑士魔理沙：一招鲜，吃遍天&lt;/a&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;里面Session Type作法也很漂亮 - 更准确的说，看OK大法（final tagless，eff）的时候都会觉得像他那样做是正当作法，很trivial/natural，但是往往他本人也要一段时间才找得出来（可以看看eff的前身，当时还依赖奇奇怪怪的Request）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;顺带一提，我很喜欢PL的原因是，概念是高度Composable的，新的概念往往可以用毫不相干的旧概念实现 - Generic Crossover用了Eff跟SYB，SYB自身又依赖于Typing Dynamic Typing这种做法，更极端的情况我觉得可以看EK这个comment：&lt;/p&gt;&lt;a href=&quot;https://www.reddit.com/r/haskell/comments/387ex0/are_extensible_effects_a_complete_replacement_for/crt1pzm/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;https://www.reddit.com/r/haskell/comments/387ex0/are_extensible_effects_a_complete_replacement_for/crt1pzm/&lt;/a&gt;&lt;p&gt;更具体讲，一半lambda the ultimate一半growing a language呢。&lt;/p&gt;&lt;a href=&quot;http://library.readscheme.org/page1.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;http://library.readscheme.org/page1.html&lt;/a&gt;&lt;a href=&quot;https://www.cs.virginia.edu/~evans/cs655/readings/steele.pdf&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;https://www.cs.virginia.edu/~evans/cs655/readings/steele.pdf&lt;/a&gt;&lt;p&gt;另：The Reluctant Heroes莫名的好听&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;另另：知乎你们搞什么鬼，NLP做得这么烂，默认文章问题有生物学就算了，蔡英文跟马英九什么鬼，好歹要加入用户历史数据作prior啊&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2018-05-21-37098961</guid>
<pubDate>Mon, 21 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Homotopy type theory univalence 简明入门(4th深圳函数式聚会)</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-05-20-37062630.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37062630&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在昨天的聚会中（不少大佬坐飞机从北上赶来！），我讲了如何在Adga中使用Homotopy type theory进行定理证明。本来以为这么冷门的东西没人关注，没想到讲完大家还问了不少问题。这里我把昨天讲的整理一下可以让更多人看到（ppt写得太潦草就不放啦）&lt;/p&gt;&lt;p&gt;代码在这里：&lt;a href=&quot;https://github.com/doofin/hott-examples&quot;&gt;doofin/hott-examples&lt;/a&gt;&lt;/p&gt;&lt;p&gt;其中用到的一个关键而trival的函数是transport，给定任意的depentent type B（B也可以是常数类型）和(p : x == y)，输出一个B x → B y 的函数。也就是说我有一个定理B x是关于x的，又有一个x == y 的证明p，就可以把这个定理transport 从而证明了B y&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;data _==_ {i} {A : Type i} (a : A) : A → Type i where
  idp : a == a

ap : ∀ {i j} {A : Type i} {B : Type j} (f : A → B) {x y : A}
  → (x == y → f x == f y)
ap f idp = idp

coe : ∀ {i} {A B : Type i} (p : A == B) → A → B
coe idp x = x

transport : ∀ {i j} {A : Type i} (B : A → Type j) {x y : A} (p : x == y)
  → (B x → B y)
transport B p = coe (ap B p)
&lt;/code&gt;&lt;p&gt;这比较容易理解，因为x==y,所以关于x的定理自然可以转到y上。但是因为identity type (_ &lt;i&gt;== _&lt;/i&gt;) 的唯一构造器是idp : a == a ，所以这并没有任何用处，唯一能证明的就是因为x==x 所以B x -&amp;gt; B x.&lt;/p&gt;&lt;p&gt;这时我们自然会想到，难道给出x 和 y 的同构函数对 f : x-&amp;gt; y , g: y -&amp;gt; x , 以及它们互逆的证明不行吗？这是可以的，但是无法利用这个非常generic 的函数transport，我们对于每个定理B x都需要手动地插入f , g .&lt;/p&gt;&lt;p&gt;这时就要用到大名鼎鼎的univalence了。&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;postulate  -- Univalence axiom
  ua : ∀ {i} {A B : Type i} → (A ≃ B) → A == B
&lt;/code&gt;&lt;p&gt;对于 同构类型(A ≃ B)，它能构造identity type.在agda里边是一条postulate，也就是如果你使用了ua然后编译为程序是无法运行的，因为只给出了类型而没有给出term.&lt;/p&gt;&lt;p&gt;有了ua以后就简单了，只需要把同构扔进ua，再transport一下，我们就得到了一个非常generic 的函数：B x -&amp;gt; B y &lt;/p&gt;&lt;p&gt;下面是更加具体的例子，用来处理两个同构的自然数：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;doubleN : ℕ -&amp;gt; ℕ -- C n
doubleN = nind z (\ _ n -&amp;gt; s (s n))

n2n&#39; : ℕ -&amp;gt; ℕ&#39;
n2n&#39; = nind z&#39; (\ _ n&#39; -&amp;gt; s&#39; n&#39;)

n&#39;2n : ℕ&#39; -&amp;gt; ℕ
n&#39;2n =  n&#39;ind z (\ _ n&#39; -&amp;gt; s  n&#39;)

-- ap :  x == y -&amp;gt; f x == f y
-- transport : ∀ {i j} {A : Type i} (B : A → Type j) {x y : A} (p : x == y)
--  → (B x → B y)
n~n&#39; : is-equiv n2n&#39; -- simple version
n~n&#39; = is-eq
  n2n&#39; --  (f : A → B)
  n&#39;2n --  (g : B → A)
  (n&#39;ind {λ x → n2n&#39; (n&#39;2n x) == x} idp (λ _ x=&#39;=y → ap s&#39; x=&#39;=y )) -- (f-g : (b : B) → f (g b) == b) ,idp :0==0
  (nind {λ x → n&#39;2n (n2n&#39; x) == x} idp (λ _ x==y → ap s x==y ))
 -- (g-f : (a : A) → g (f a) == a)
doubleN&#39; : ℕ&#39; -&amp;gt; ℕ&#39; -- double from univalence . transport:  a~b -&amp;gt; pa -&amp;gt; pb
doubleN&#39; = transport ( λ a → a → a) (ua (n2n&#39; , n~n&#39;)) (doubleN) -- P , n == n&#39; , double n -&amp;gt; double n&#39;
-- define + with recursor for natural number,2 
-- using currying,the type A is ℕ

doubleN&#39;nouniv : ℕ&#39; -&amp;gt; ℕ&#39;
doubleN&#39;nouniv n&#39; = n2n&#39; (doubleN (n&#39;2n n&#39;))
&lt;/code&gt;&lt;h2&gt;这里可能还体现不出威力，但是如果要证明的是关于更复杂结构的定理比如：&lt;/h2&gt;&lt;code lang=&quot;agda&quot;&gt;record IsSemigroup (∙ : Op₂ A) : Set (a ⊔ ℓ) where
  field
    isEquivalence : IsEquivalence _≈_
    assoc         : Associative ∙
    ∙-cong        : Congruent₂ ∙

  setoid : Setoid a ℓ
  setoid = record { isEquivalence = isEquivalence }

  open IsEquivalence isEquivalence public
&lt;/code&gt;&lt;p&gt;这时有univalence 就确实能省很多功夫了，下次我会尝试给出更好的例子。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;使用HoTT库进行定理证明还有个好处是只需要函数式编程就够了，应该不再需要学rewrite，dependent之类dependent type 语言特有的一些复杂特性()。&lt;/p&gt;&lt;p&gt;如果还想知道如何证明Univalence(也就是让其能够计算)，可以研究一下&lt;a href=&quot;https://github.com/mortberg/cubicaltt&quot;&gt;mortberg/cubicaltt&lt;/a&gt;，cubical type theory 是一个比较热门的方向。&lt;/p&gt;</description>
<author>Martin awodey</author>
<guid isPermaLink="false">2018-05-20-37062630</guid>
<pubDate>Sun, 20 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>后浪</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-05-18-37007550.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37007550&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近跟人聊天，他说物理学停歇不前，那像二战的黄金时代，产生了相对论跟量子力学。于是，我想起了去年刚学历史没多久的自己。。当时我觉得CS的黄金时代 - 1960~80已经过去，互联网，OS，GUI，Computer Architecture，等等，全部出自那个时代，而我们只是想方设法去monetize这些。唉。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现在看来，实在是有失偏颇。&lt;/p&gt;&lt;p&gt;要对历史/当下做评价的最主要的问题是，credit assignment实在太难做。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;举个例子，大家是如何看待区块链的？&lt;/p&gt;&lt;p&gt;我曾经问过我的PHD同事/朋友，他们的答案，除了一个就是搞区块链的，通通是‘敬而远之/bubble/pyramid scheme’。&lt;/p&gt;&lt;p&gt;而这的核心，是因为区块链‘没有现实价值’。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;而1970年代的Xerox高层是怎么评价Xerox PARC的？&lt;/p&gt;&lt;p&gt;‘没有用’‘白花钱’。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;看出问题了吗？如果我们真穿越回1970，说不定我们会感叹着真是一代不如一代，老冯搞出了老冯架构，IBM搞出了计算机架构，海軍准將弄出了COBOL，一推人搞出了Algol，我们就有些民科般乱搞的人。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;而他们也情有可原 - 1960~70出现了PC&amp;amp;GUI&amp;amp;Tablet/Smart Phone的概念，一直到90才步入大众（phone得到2010），而70年同时的出现的internet呢？Amazon在dot com bubble受到的影响一直到2010才恢复过来，这整整隔了40年。从一个东西被发明，到走到现实，往往需要很久的时间去降低成本/建立中层建筑/寻找应用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;而区块链只出现了10年，根据历史的发展，很可能30年后才兑现 - 现在评论区块链有没有用，实在太早。&lt;/p&gt;&lt;p&gt;但是，如果最近各个还在发展中的idea（block chain/deep learning/quantum computing），真在几十年后被发现是www级别的idea呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那我们这就不止是第二春 - 黄金时代只是现在这时代的前传。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;甚至，还有个更基本的问题 - internet固然是伟大的发明，bob taylor 当初也没有预料到会有 search engine存在啊。这credit多少得给Parc/Bob，多少Google？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那，什么时代是最好的时代？&lt;/p&gt;&lt;blockquote&gt;　　杨过问道：“郭伯伯，你说襄阳守得住吗？”郭靖沉吟良久，手指西方郁郁苍苍的丘陵树木，说道：“襄阳古往今来最了不起的人物，自然是诸葛亮。此去以西二十里的隆中，便是他当年耕田隐居的地方。诸葛亮治国安民的才略，我们粗人也懂不了。他曾说只知道‘鞠躬尽瘁，死而後已’，至於最後成功失败，他也看不透了。我与你郭伯母谈论襄阳守得住、守不住，谈到後来，也总只是‘鞠躬尽瘁，死而後已’这八个字。”&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我认为，学历史，是为了抓住&amp;amp;复现各种机会，而不是去怀古伤今或者轻议冢中人 - 那实在是太难了，谋事在人，成事在天就好。&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2018-05-18-37007550</guid>
<pubDate>Fri, 18 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>活化石</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-05-04-36427205.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36427205&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近计算机架构课组织了一次去&lt;a href=&quot;https://livingcomputers.org/&quot;&gt;Living Computers - Home&lt;/a&gt;的春游（误？），可惜迷路了，导致来晚，只看到一小半。&lt;/p&gt;&lt;p&gt;很好的一点是里面的计算机都是可远观而亦可亵玩 - 事实上我们的作业就是随便找台计算机在上面编程。&lt;/p&gt;&lt;p&gt;对于喜欢计算机历史的人来说很爽啊 - 从书上看着各种电脑各种OS是一码事，真正的看到，然后摸，还能用，感觉完全不一样。&lt;/p&gt;&lt;p&gt;尤其是还有Xerox Alto。还有个巨大的装着Smalltalk的盘盘。把老娘的爪爪放在圆圆的Smalltalk上然后插进Xerox Alto真是满足死我了。可惜不知道为啥Smalltalk跑不起来 - 放太久了？&lt;/p&gt;&lt;p&gt;信仰++++。&lt;/p&gt;&lt;p&gt;然后Digi-Comp（见&lt;a href=&quot;https://www.youtube.com/watch?v=_tZdE-3nR3w&quot;&gt;https://www.youtube.com/watch?v=_tZdE-3nR3w&lt;/a&gt;）也很好玩。&lt;/p&gt;&lt;p&gt;另：某Lisp厨失望了 - 没有Lisp Machine。&lt;/p&gt;&lt;p&gt;另另：有辛去的话，推荐下Pecos Pit Bar-B-Que，好好吃，实习以后大半年都没吃到这么辣的东西辣，sad&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2018-05-04-36427205</guid>
<pubDate>Fri, 04 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>第四届函数式编程分享会</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-05-01-36308855.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36308855&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;报名地址: &lt;a href=&quot;https://jinshuju.net/f/9a72wh&quot;&gt;深圳函数式编程聚会&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;计划暂定&lt;/b&gt;于2018年5月19日早9:30，于深圳福田区嘉里建设广场3栋39层（嘉石大岩资本）&lt;/p&gt;&lt;p&gt;分享函数式编程的经验，也可以微博关注@&lt;a href=&quot;http://weibo.com/u/2709495807?source=webim&quot;&gt;Haskell中文&lt;/a&gt; &lt;a href=&quot;http://weibo.com/u/1914643755?refer_flag=1005055010_&quot;&gt;@阅千人而惜知己&lt;/a&gt; &lt;a href=&quot;https://weibo.com/notyy?topnav=1&amp;amp;wvr=6&amp;amp;topsug=1&quot;&gt;@大魔头&lt;/a&gt;，如有任何疑问可以加入QQ群72874436讨论。&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6676ea444bda2c703add8474963e800a&quot; data-hash=&quot;6676ea444bda2c703add8474963e800a&quot; data-hovercard=&quot;p$b$6676ea444bda2c703add8474963e800a&quot;&gt;@阅千人而惜知己&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0a308ec0bd0ce92754be4e85db62a29a&quot; data-hash=&quot;0a308ec0bd0ce92754be4e85db62a29a&quot; data-hovercard=&quot;p$b$0a308ec0bd0ce92754be4e85db62a29a&quot;&gt;@parker liu&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/73c168246af1fab79b28736c311466e1&quot; data-hash=&quot;73c168246af1fab79b28736c311466e1&quot; data-hovercard=&quot;p$b$73c168246af1fab79b28736c311466e1&quot;&gt;@韩冬&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/2d8f51b6523e01a8529606f466d98198&quot; data-hash=&quot;2d8f51b6523e01a8529606f466d98198&quot; data-hovercard=&quot;p$b$2d8f51b6523e01a8529606f466d98198&quot;&gt;@Felis sapiens&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/4cf2f4dca8e0339f5c2a460ecb62db39&quot; data-hash=&quot;4cf2f4dca8e0339f5c2a460ecb62db39&quot; data-hovercard=&quot;p$b$4cf2f4dca8e0339f5c2a460ecb62db39&quot;&gt;@大魔头-诺铁&lt;/a&gt; &lt;/p&gt;&lt;p&gt;如果条件允许的话&lt;b&gt;可能&lt;/b&gt;会有直播&lt;/p&gt;&lt;p&gt;微信群二维码(知乎会自动转链接): &lt;/p&gt;&lt;a href=&quot;https://ibb.co/iJCteS&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Wechat IMG2&lt;/a&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我写的往届的一些记录:&lt;/p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26722010&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;祖与占：上海2017年函数式编程分享会视频&lt;/a&gt;&lt;a href=&quot;https://www.zhihu.com/question/59391737/answer/164874243&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;参加 2017 年函数式编程聚会是什么感受?&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20831552&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;祖与占：第2届函数式编程分享随便记&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>祖与占</author>
<guid isPermaLink="false">2018-05-01-36308855</guid>
<pubDate>Tue, 01 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>lambda演算与数据类型</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-25-36081360.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36081360&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fc94609d676b4704ccfce8b67fd56e62_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在大多数编程语言里面，数据类型和函数都是不同的，但它们又有种种关联。我们可以说函数是一种数据类型，换句话说就是first class function。通过pattern match我们可以拿到ADT（代数数据类型）的各个constructor的argument。再用Idris举个例子：&lt;/p&gt;&lt;code lang=&quot;idris&quot;&gt;data Maybe : (a : Type) -&amp;gt; Type where
    Nothing : Maybe a
    Just : (x : a) -&amp;gt; Maybe a&lt;/code&gt;&lt;p&gt;我们定义了2个函数：Nothing和Just，这两个function都用于构造数据类型Maybe，所以他们的返回值的类型是Maybe，我们把这两个函数称之为constructor。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;前置知识&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;对函数式编程及相关编程语言的了解&lt;/li&gt;&lt;li&gt;对Lambda演算的基本知识&lt;/li&gt;&lt;li&gt;ADT（代数数据类型）的基本知识&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;数据类型与函数&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在lambda calculus中，一切都是函数。我们通过：variable、abstraction、application来组成lambda的term。一般通过对lambda term应用normal order reduction来对lambda term进行求值。&lt;/p&gt;&lt;p&gt;既然函数可以是一种数据类型，数据类型可不可以用函数来表示呢？当然可以。例如在lambda演算中通常表示自然数的方式，或者说church number则是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;zero := λf.λx.x;
succ := λn.λf.λx.f (n f x);&lt;/code&gt;&lt;p&gt;如果不熟悉church encoding的自然数可以在维基百科中了解：&lt;/p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Lambda_calculus&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;https://en.wikipedia.org/wiki/Lambda_calculus&lt;/a&gt;&lt;p&gt;我们有多种方式将数据类型encode到lambda calculus中，如church number：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;0 := λf.λx.x;
1 := λf.λx.f x;
2 := λf.λx.f (f x);&lt;/code&gt;&lt;p&gt;则是通过将参数f递归的应用在x上来encode自然数的。&lt;/p&gt;&lt;p&gt;而peano number，或者也可以说是scott encoding的自然数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;zero := λz.λs.z;
succ := λn.λz.λs.s n;

0 := λz.λs.z;
1 := λz.λs.s (λz.λs.z);
2 := λz.λs.s (λz.λs.s (λz.λs.z));&lt;/code&gt;&lt;p&gt;则是将数据类型的constructor定义出来，并encode每个constructor的pattern match函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;数据类型的表示&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们可以通过将数据类型相关的一种operator进行encode，来将数据类型表示到lambda calculus中。例如上文自然数的例子，Church encoding是将”递归的把函数f应用n次到x上(f^n)“这种operator进行encode。Scott encoding则是将pattern match这种operator进行encoding。&lt;/p&gt;&lt;p&gt;一个operator就是一个函数，在Church encoding的自然数中，递归的把函数f应用n次到x上的function是trivial的，而pattern match则不是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;funcPow := λf.λx.λn.n f x;
matchNat := λz.λs.λn.n (λm.m (λu.λg.g (λf.λx.x)) (λg.λu.λh.h (λf.λx.f (g f x)))) (λx.λu.x) z s;&lt;/code&gt;&lt;p&gt;而用Scott encoding的peano number中，pattern match是trivial的，而funcPow则不是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;funcPow := λf.λx.λn.n x ((λg.(λy.g (y y)) (λy.g (y y))) (λg.λh.f (h x g)));
matchNat := λz.λs.λn.n z s;&lt;/code&gt;&lt;p&gt;不单单是自然数，其他数据类型也可以用类似的方法进行encode。例如对于List，我们可以将其按fold right进行encode，或者按pattern match进行encode等。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Scott encoding&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在上文中多次提到了scott encoding、pattern match这两个名词。具体来说，对于ADT（也就是有多个constructor，每个constructor有任意argument，或者说product的sum）来说，可能最简单、最直观的encode数据类型的方法就是将pattern match进行encode了，scott encoding就是指的这种encode数据类型的方法。&lt;/p&gt;&lt;p&gt;具体对于有n个constructor的ADT，对于第x个constructor，有m个argument，用如下方法进行encode：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;CtorX := λA_1 A_2 ... A_m.λC_1 C_2 ... C_n.C_x A_1 A_2 ... A_m;&lt;/code&gt;&lt;p&gt;这样就可以对直观的对不同的case进行pattern match了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Encoding of list&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文中提到过对list进行encode的2种方法，关于其他的encode方法，可以参考维基百科：&lt;/p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Church_encoding#List_encodings&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;https://en.wikipedia.org/wiki/Church_encoding#List_encodings&lt;/a&gt;&lt;p&gt;这里我们使用Scott encoding来encode list，定义list(pattern match)、nil(constructor)、cons(constructor)、length、null、append、foldr、foldl函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;list := λn.λc.λl.l n c;

nil := λn.λc.n;
cons := λh.λt.λn.λc.c h t;

length := λl.l zero (λh.λt.succ (length t));
null := λl.l true (λh.λt.false);
append := λl.λm.l m (λh.λt.cons h (append t m));
foldr := λf.λx.λl.l x (λh.λt.f h (foldr f x t));
foldl := λf.λx.λl.l x (λh.λt.foldl f (f x h) t);&lt;/code&gt;&lt;p&gt;每个函数的定义都比较直观，就不详细描述了。对于引用了其他函数的情况可以直接代换，也可以将其当作free variable，并使用abstraction将其捕获，通过application传入其定义，例如对于null：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;null := (λtrue.λfalse.λl.l true (λh.λt.false)) (λt.λf.t) (λt.λf.f);&lt;/code&gt;&lt;p&gt;需要注意的是length、append、foldr、foldl都在定义中引用了自身，也就是使用了递归。对于这种情况，需要使用不动点算子：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fix := λf.(λx.f (x x)) (λx.f (x x));&lt;/code&gt;&lt;p&gt;将其转化为：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;length := fix (λlength.λl.l zero (λh.λt.succ (length t)));
append := fix (λappend.λl.λm.l m (λh.λt.cons h (append t m)));
foldr := fix (λfoldr.λf.λx.λl.l x (λh.λt.f h (foldr f x t)));
foldl := fix (λfoldl.λf.λx.λl.l x (λh.λt.foldl f (f x h) t));&lt;/code&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了如何在lambda calculus中处理数据类型，和各种encoding之间的关系。&lt;/p&gt;&lt;p&gt;这里打个广告，写这篇文章的起因是最近在用scala写一个个人项目，lambda calculus的REPL。在设计标准库的时候涉及到了一些与本文相关的知识。已经实现了tokenizer、parser、beta reducer、eta converter、pretty printer等模块，单纯调用API来处理lambda term是没有问题了。目前正在设计核心的REPL的Extension API、library的dependencies管理、lam文件（library的源文件）的语法、标准库等。如果有兴趣参与开发，欢迎联系我！&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/yuxuanchiadm/lamcalcj&quot;&gt;https://github.com/yuxuanchiadm/lamcalcj&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Lambda_calculus&quot;&gt;Lambda calculus&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Church_encoding&quot;&gt;Church encoding&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding&quot;&gt;Mogensen–Scott encoding&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>不可构造的雨轩菌</author>
<guid isPermaLink="false">2018-04-25-36081360</guid>
<pubDate>Wed, 25 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>一款能设置你的DrRacket背景的IDE插件</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-23-36027427.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36027427&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e7f5beb3b56104a4ee29bcd37d7e8c1c_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;安装方式（两种）：&lt;/p&gt;&lt;p&gt;1.进入终端，输入下面的命令：&lt;/p&gt;&lt;p&gt;raco pkg install DrRacketTheme&lt;/p&gt;&lt;p&gt;在不同操作系统上可能有所不同，如果没有成功，请尝试先进入racket安装目录下然后在运行这条命令。&lt;/p&gt;&lt;p&gt;2.打开DrRacket，打开File菜单下的Package Manager，切换到Available from Catalog选项卡，点击Update Package List按钮，稍等片刻，然后在Filter文本框中输入DrRacketTheme，点击Install按钮。&lt;/p&gt;&lt;p&gt;设置的时候请点击View菜单下的Set Background，选择需要作为背景的图片。&lt;/p&gt;&lt;p&gt;Set Background Alignment能够设置图片的对齐方式。&lt;/p&gt;&lt;p&gt;希望这款插件能够帮助到正在学习racket或是scheme的人。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>御坂黒子</author>
<guid isPermaLink="false">2018-04-23-36027427</guid>
<pubDate>Mon, 23 Apr 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
