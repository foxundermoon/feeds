<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Sat, 15 Sep 2018 18:22:39 +0800</lastBuildDate>
<item>
<title>函数式编程与数字电路</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-09-14-44000409.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/44000409&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前函数式编程应用主要是在编译器（Haskell，ml），以及大数据和分布式系统（Scala），但其实用函数式语言编写硬件逻辑电路也有一段历史了，特别是开源的RISC V 最近让Chisel好好火了一把，这一幕挺像当年的Spark。除了基于Scala的Chisel外，还有一门是基于Haskell的Clash。Chisel是利用macro元编程和Scala原本的编译器，实现了一个可以方便构建RTL的库，而后者的方法更激进，是通过修改Haskell的编译器GHC来直接把Haskell代码转变为RTL。&lt;/p&gt;&lt;p&gt;需要注意的是，虽然他们都是基于非常高层的抽象语言，但是和所谓的High Level Synthesis没什么关系，要实现任何东西都是需要自己在RTL级别进行构建和思考的，编译器并不会变魔术一样帮你实现某些算法，可以把他们看作是某些语法糖，理论上仍然是可以把Verilog再编译回去的，而不像Haskell编译为汇编那样不可逆。&lt;/p&gt;&lt;p&gt;那为啥不老老实实用Verilog？虽然都是RTL，但是他们相当于给Verilog加上了部分元编程的能力，所以最后生成的Verilog代码大小可能会让人惊叹。另一个是模块化，在项目一大以后优势就体现出来了，Scala的Trait，Haskell的Type Class，都能够更好的组织代码。在编辑器方面，Scala有开源免费的Intellij ，用起来是非常爽的，能提升不少战斗力，另外Haskell的VS code也不错。&lt;/p&gt;&lt;p&gt;Chisel和Clash除了语法和实现，感觉差异不是很大，Clash由于是基于Haskell而且严重依赖Type Class，所以学习曲线更加陡峭，不过Chisel深入学习以后也需要了解下Subtyping相关的类型系统知识。定制化方面，Chisel的架构更灵活一些，分离出了一个叫Firrtl的IR，比较容易加入某些中间代码变换。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;关于Chisel对于生产力的提升，可以看看 @&lt;a href=&quot;https://www.zhihu.com/people/xfguo&quot;&gt;郭雄飞&lt;/a&gt; 的回答&lt;/p&gt;&lt;a href=&quot;https://www.zhihu.com/question/58584770/answer/284119982&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-a5b864ff40c14ea5bd899c6072809019&quot; data-image-width=&quot;120&quot; data-image-height=&quot;120&quot; data-image-size=&quot;ipico&quot;&gt;https://www.zhihu.com/question/58584770/answer/284119982&lt;/a&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/58584770/answer/284119982&quot;&gt;郭雄飞：RISC-V开源项目为什么选用chisel这种新的高层次建模语言，而不是SystemVerilog?&lt;/a&gt;&lt;/p&gt;&lt;a href=&quot;https://www.zhihu.com/question/58584770/answer/284119982&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-a5b864ff40c14ea5bd899c6072809019&quot; data-image-width=&quot;120&quot; data-image-height=&quot;120&quot; data-image-size=&quot;ipico&quot;&gt;RISC-V开源项目为什么选用chisel这种新的高层次建模语言，而不是SystemVerilog?&lt;/a&gt;&lt;a href=&quot;https://github.com/freechipsproject/chisel3/wiki&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-3adf1d09765d5840cf68feec5eeda97e&quot; data-image-width=&quot;420&quot; data-image-height=&quot;420&quot; data-image-size=&quot;ipico&quot;&gt;freechipsproject/chisel3&lt;/a&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Martin awodey</author>
<guid isPermaLink="false">2018-09-14-44000409</guid>
<pubDate>Fri, 14 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Recursion Schemes（三）基于上下文的折叠</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-09-02-43560128.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43560128&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e5a2a9858bfa0c0e317c6943a84edb5b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;前情回顾&lt;/h2&gt;&lt;p&gt;在上一篇文章中，我们定义了 catamorphism，一种一般性的遍历嵌套数据结构的手段，但是这一方法有它的局限性，本章中我们将讨论这些局限，并介绍更强力的遍历手段 paramorphism&lt;/p&gt;&lt;p&gt;如前所述，本文的代码可以在&lt;a href=&quot;https://github.com/patrickt/recschemes/blob/master/src/Part3.hs&quot;&gt;这里&lt;/a&gt;找到。&lt;/p&gt;&lt;p&gt;在过去的两篇文章中，我们定义了 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 来表示函子 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 的不动点，并使用 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Out&lt;/code&gt; 来作为构造和析构函数，从而使 &lt;code class=&quot;inline&quot;&gt;Term f&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;f (Term f)&lt;/code&gt; 相互联系了起来：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Term f = In { out :: f (Term f) }&lt;/code&gt;&lt;p&gt;接着利用 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt; 的递归特性，我们定义了可以在 &lt;code class=&quot;inline&quot;&gt;Term f&lt;/code&gt; 上进行变换的 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;bottomUp :: Functor a =&amp;gt; (Term a -&amp;gt; Term a) -&amp;gt; Term a -&amp;gt; Term a  
bottomUp fn =  
  out                    -- 1) 解析结构
  &amp;gt;&amp;gt;&amp;gt; fmap (bottomUp fn) -- 2) 递归
  &amp;gt;&amp;gt;&amp;gt; In                 -- 3) 构造结构
  &amp;gt;&amp;gt;&amp;gt; fn                 -- 4) 应用&lt;/code&gt;&lt;p&gt;当我们不考虑重新构造结构的部分以后，我们得到了 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt;，可以使 &lt;code class=&quot;inline&quot;&gt;Term f&lt;/code&gt; 变成某种累加值 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，使用 &lt;code class=&quot;inline&quot;&gt;Algebra&lt;/code&gt; 将 &lt;code class=&quot;inline&quot;&gt;f a&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 联系了起来：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Algebra f a = f a -&amp;gt; a

cata :: (Functor f) =&amp;gt; Algebra f a -&amp;gt; Term f -&amp;gt; a  
cata fn =  
    out                -- 1) 解析结构
    &amp;gt;&amp;gt;&amp;gt; fmap (cata fn) -- 2) 递归
    &amp;gt;&amp;gt;&amp;gt; fn             -- 3) 应用&lt;/code&gt;&lt;h2&gt;Paramorphism&lt;/h2&gt;&lt;p&gt;Catamorphism 相当简单优雅，但往往在现实中并不实用，因为在遍历过程中，它丢失了原有结构与上下文信息，比如在上一章中文档生成的例子里，我们只能对当前节点生成文档，因为其它所有子节点已经变成了文档的一部分。&lt;/p&gt;&lt;p&gt;这在我们需要上下文信息来进行判断的场景中会变得非常麻烦，比如我希望在函数无参数时，文档以特殊格式显示该函数，那么我必须重新解析文档来获取之前关于函数参数的信息，这显然非常笨拙。&lt;/p&gt;&lt;p&gt;一个显然更优雅的解法就是在 &lt;code class=&quot;inline&quot;&gt;Algebra&lt;/code&gt; 生成最终结果的时候，我们能同时保留原始的上下文信息，&lt;code class=&quot;inline&quot;&gt;Algebra&lt;/code&gt; 的输入是 &lt;code class=&quot;inline&quot;&gt;f a&lt;/code&gt; 如果我们能保持原有的结构 &lt;code class=&quot;inline&quot;&gt;Term f&lt;/code&gt;，同时也能拿到当前的结果 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，并以两者一同作为输入：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;f (Term f, a) -&amp;gt; a&lt;/code&gt;&lt;p&gt;我们把这样的结构定义为 &lt;code class=&quot;inline&quot;&gt;R-algebra&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type RAlgebra f a = f (Term f, a) -&amp;gt; a&lt;/code&gt;&lt;p&gt;与之对应的，使用 &lt;code class=&quot;inline&quot;&gt;R-algebra&lt;/code&gt; 来进行数据结构遍历的机制被称为 &lt;i&gt;paramorphism&lt;/i&gt;，同样从词源的角度分析，paramorphism 的词缀 &lt;i&gt;para&lt;/i&gt; 实际上与 &lt;i&gt;parallel&lt;/i&gt; 的相同——来自于希腊语 παρά，代表“旁边”，“临近”，“一旁”的含义[1]。除去可以看到当前位置的上下文，paramorphism 和 catamorphism 实际上非常相似。&lt;/p&gt;&lt;p&gt;下面我们来看下 paramorphism 的具体实现，我们不能再直接地使用 &lt;code class=&quot;inline&quot;&gt;fmap para&lt;/code&gt; 我们的函数返回了一个元组，我们需要解析并递归其中的表达式，同时保持原来的结构，为止我们定义了一个附属函数 &lt;code class=&quot;inline&quot;&gt;fanout&lt;/code&gt;，它接受一个 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 并且返回递归结果和 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 本身。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;para :: (Functor f) =&amp;gt; RAlgebra f a -&amp;gt; Term f -&amp;gt; a  
para rAlg = out &amp;gt;&amp;gt;&amp;gt; fmap fanout &amp;gt;&amp;gt;&amp;gt; rAlg  
    where fanout :: Term f -&amp;gt; (Term f, a)
          fanout t = (t, para rAlg t)&lt;/code&gt;&lt;p&gt;就这么简单！这就是 paramorphism 的经典定义，我们现在可以在保持原有的信息和结构的同时，获得我们想要的结果。其实 Haskell 甚至可以给出更优雅的实现，使用 &lt;code class=&quot;inline&quot;&gt;Control.Arrow&lt;/code&gt; 提供的 &lt;code class=&quot;inline&quot;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; 组合子，它接收两个函数 &lt;code class=&quot;inline&quot;&gt;foo&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;bar&lt;/code&gt;[2]，并且返回一个函数，它的输入是 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，返回是 &lt;code class=&quot;inline&quot;&gt;(foo a, bar a)&lt;/code&gt; 的元组。它将两个函数的输出进行了组合。&lt;/p&gt;&lt;p&gt;所以我们的 &lt;code class=&quot;inline&quot;&gt;fanout&lt;/code&gt; 可以构造为：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fanout = id &amp;amp;&amp;amp;&amp;amp; para f&lt;/code&gt;&lt;p&gt;所以原代码可以改写为：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;para&#39; :: Functor f =&amp;gt; RAlgebra f a -&amp;gt; Term f -&amp;gt; a  
para&#39; f = out &amp;gt;&amp;gt;&amp;gt; fmap (id &amp;amp;&amp;amp;&amp;amp; para&#39; f) &amp;gt;&amp;gt;&amp;gt; f&lt;/code&gt;&lt;p&gt;是不是简洁了许多？&lt;/p&gt;&lt;h2&gt;替代 Catamorphism&lt;/h2&gt;&lt;p&gt;实际上我们之前到 &lt;code class=&quot;inline&quot;&gt;RAlgebra&lt;/code&gt; 中元组的定义也不无改进空间，我们可以将它使用函数重写：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type RAlgebra&#39; f a = Term f -&amp;gt; f a -&amp;gt; a&lt;/code&gt;&lt;p&gt;那么随之我们对 &lt;code class=&quot;inline&quot;&gt;para&lt;/code&gt; 的定义也需要随之修改：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;-- &amp;amp; 函数的作用是逆序函数的调用顺序，  
-- 与 $ 操作符类似，不过执行的顺序相反
para&#39;&#39; :: Functor f =&amp;gt; RAlgebra&#39; f a -&amp;gt; Term f -&amp;gt; a  
para&#39;&#39; alg t = out t &amp;amp; fmap (para&#39;&#39; alg) &amp;amp; alg t&lt;/code&gt;&lt;p&gt;正如 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt; 可以用 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 表达，&lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 也可以用 &lt;code class=&quot;inline&quot;&gt;qara&lt;/code&gt; 来表达，我们只需要忽略掉额外传入的 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 即可，我们使用 Haskell 提供的 &lt;code class=&quot;inline&quot;&gt;const&lt;/code&gt; 函数即可（即 K-组合子）：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;cata&#39; :: Functor f =&amp;gt; Algebra f a -&amp;gt; Term f -&amp;gt; a  
cata&#39; f = para&#39;&#39; (const f)&lt;/code&gt;&lt;p&gt;这正是 Recursion Scheme 的优美之处，我们不断引入新的更强大的构造结构，而旧的总能被新的所表达。&lt;/p&gt;&lt;h2&gt;举个例子&lt;/h2&gt;&lt;p&gt;对于 &lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt; 函数来说，直接返回它的参数，我们可以等价地用 &lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt; 来替换 &lt;code class=&quot;inline&quot;&gt;id(x)&lt;/code&gt; 我们来考虑一个我们前文提到的的文档生成器，出于某些原因[3]，我们希望在文档中进行这个优化。&lt;/p&gt;&lt;p&gt;我们需要检查每个函数调用，通过判断函数名是否为 &lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt; 来决定是否直接返回参数，这正是使用 paramorphism 的地方，我们这里使用的语法树与之前的一样：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fastPretty :: RAlgebra&#39; Expr Doc

-- 除了 Call 节点的定义，其他部分与之前的定义均相同
fastPretty _ (Literal i) = P.int i  
fastPretty _ (Ident s)   = P.text s  

-- Call 节点正是我们感兴趣的部分，我们会检查它的第一个参数是否为 id，如果是的话，我们只返回参数部分

fastPretty (In Call { func = &quot;id&quot; })  
           Call {args = [theArg]} = theArg
fastPretty _ (Call f as)     = f &amp;lt;&amp;gt; P.parens (P.cat (P.punctuate &quot;, &quot; as))  
-- The other cases are the same as `prettyPrint` in the last installment.&lt;/code&gt;&lt;p&gt;当我们在遍历结构时需要上下文，那么 Paramorphism 就会变成一个不错的选择。&lt;/p&gt;&lt;h2&gt;Apomorphism&lt;/h2&gt;&lt;p&gt;在上一篇文章中，我们通过翻转箭头的技巧实现了 &lt;code class=&quot;inline&quot;&gt;ana&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 的对偶：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;cata f = out &amp;gt;&amp;gt;&amp;gt; fmap (cata f) &amp;gt;&amp;gt;&amp;gt; f

ana f = In &amp;lt;&amp;lt;&amp;lt; fmap (ana f) &amp;lt;&amp;lt;&amp;lt; f&lt;/code&gt;&lt;p&gt;而 &lt;code class=&quot;inline&quot;&gt;ana&lt;/code&gt; 的参数就被表示为 &lt;code class=&quot;inline&quot;&gt;Coalgebra&lt;/code&gt;，作为 &lt;code class=&quot;inline&quot;&gt;Algebra&lt;/code&gt; 的对偶：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Coalgebra f a = a -&amp;gt; f a

ana f :: (Functor f) =&amp;gt; Coalgebra f a -&amp;gt; a -&amp;gt; Term f&lt;/code&gt;&lt;p&gt;同理，我们也会看到 paramorphism 的对偶，&lt;i&gt;apomorphism&lt;/i&gt;，apo 的词缀来源于希腊语，ἀπο，代表“远离”或“分离”的意思，如在 “apogee” （月球位于远地点）或 “apostasy”（背教，变节），所以我们来看看 R-algebra 的对偶是怎样的。我们先翻转箭头看看：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Nope = a -&amp;gt; f (Term f, a)&lt;/code&gt;&lt;p&gt;不对！我们这里必须将 &lt;code class=&quot;inline&quot;&gt;RAlgebra&lt;/code&gt; 中所有的构造部分都进行翻转，我们确实可以翻转函数的方向，但注意，我们还有元组，那么一个元组的对偶是什么呢？&lt;/p&gt;&lt;p&gt;元组包含它的所有子元素，什么它的对偶就是只包含其中一个元素亦即：&lt;code class=&quot;inline&quot;&gt;Either&lt;/code&gt;，所以对于一个同时包含 &lt;code class=&quot;inline&quot;&gt;Term f&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 的元组我们使用 &lt;code class=&quot;inline&quot;&gt;Either&lt;/code&gt; 来表示它的对偶：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type RCoalgebra f a = a -&amp;gt; f (Either (Term f) a)&lt;/code&gt;&lt;p&gt;好吧，那么这在实践中的含义是什么呢？这表示我们可以在展开的过程中进行计算，如果我们返回了 &lt;code class=&quot;inline&quot;&gt;Left&lt;/code&gt; 其中包含一个 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt;，那么 apomorphism 会结束并返回一个叶子节点，单如果我们决定返回 &lt;code class=&quot;inline&quot;&gt;Right&lt;/code&gt; 其中包含一个 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，那么展开就会继续下去，我们可以根据参数的情况来决定之后展开的操作，所以就不需要考虑 &lt;code class=&quot;inline&quot;&gt;break&lt;/code&gt; 或异常处理了。&lt;/p&gt;&lt;p&gt;同样地使用翻转箭头的技巧，我们来看看 &lt;code class=&quot;inline&quot;&gt;para&lt;/code&gt; 的对偶 &lt;code class=&quot;inline&quot;&gt;apo&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;para&#39; :: Functor f =&amp;gt; RAlgebra f a -&amp;gt; Term f -&amp;gt; a  
para&#39; f = out &amp;gt;&amp;gt;&amp;gt; fmap fanout &amp;gt;&amp;gt;&amp;gt; f where fanout = id &amp;amp;&amp;amp;&amp;amp; para&#39; f

apo f :: Functor f =&amp;gt; RCoalgebra f a -&amp;gt; a -&amp;gt; Term f  
apo f = In &amp;lt;&amp;lt;&amp;lt; fmap fanin &amp;lt;&amp;lt;&amp;lt; f where fanin = ???&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;fanin&lt;/code&gt; 的实现并不显然，我们可以先从类型上入手来看看：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fanin :: Either (Term f) a -&amp;gt; Term f&lt;/code&gt;&lt;p&gt;对于 &lt;code class=&quot;inline&quot;&gt;Left&lt;/code&gt; 我们使用 &lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt; 函数就好了，而对于 &lt;code class=&quot;inline&quot;&gt;Right&lt;/code&gt; 我们则需要正常的递归下去，那么我们需要 Haskell 的 &lt;code class=&quot;inline&quot;&gt;either&lt;/code&gt; 函数，它接受两个函数，并根据 Either 的左右值应用对应的函数，并返回相应的结果：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;apo :: Functor f =&amp;gt; RCoalgebra f a -&amp;gt; a -&amp;gt; Term f  
apo f = In &amp;lt;&amp;lt;&amp;lt; fmap fanin &amp;lt;&amp;lt;&amp;lt; f where fanin = either id (apo f)&lt;/code&gt;&lt;p&gt;类似地，我们可以使用 &lt;code class=&quot;inline&quot;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; 的对偶函数 &lt;code class=&quot;inline&quot;&gt;|||&lt;/code&gt; 来重写 &lt;code class=&quot;inline&quot;&gt;fanin&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; 使用所有传入的函数，而 &lt;code class=&quot;inline&quot;&gt;|||&lt;/code&gt; 只使用其中一个。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;apo :: Functor f =&amp;gt; RCoalgebra f a -&amp;gt; a -&amp;gt; Term f  
apo f = In &amp;lt;&amp;lt;&amp;lt; fmap (id ||| apo f) &amp;lt;&amp;lt;&amp;lt; f&lt;/code&gt;&lt;h2&gt;结语&lt;/h2&gt;&lt;p&gt;如果读者们坚持读到了这里，那么你对 Recursion Scheme 已经有了相当的了解了，下一章中，我们将会讨论 futumorphism 和 histomorphism，并且展示其中强大的结构（以及一些迷之词缀）&lt;/p&gt;&lt;p&gt;感谢 Rob Rix, Colin Barrett，和 Manuel Chakravarty 对本文的指导和建议。 &lt;/p&gt;&lt;h2&gt;译者的话&lt;/h2&gt;&lt;p&gt;欢迎大家关注我的专栏&lt;a href=&quot;https://zhuanlan.zhihu.com/catclaw&quot;&gt;猫爪&lt;/a&gt;，这个系列的文章我会更新完成（当然是不定期的=w=），之后应该也会发一些看到的有趣的 FP 类知识，基本上会是 Haskell 的，具体方向还没想好，大家有什么想法和建议也可以私信提出来讨论。&lt;/p&gt;&lt;p&gt;谢谢大家！&lt;/p&gt;&lt;p&gt;[1]:现代英语中常用 “para” 词缀表示 “虚假的”，“不正常的” 等含义（如 “parapsychology” 或 “paresthesia”）——这是从“旁边”的含义中引申而来的，在 paramorphism 一词中，并没有不正常或是低劣的含义。&lt;/p&gt;&lt;p&gt;[2]:实际上，这里的函数应该是指 &lt;code class=&quot;inline&quot;&gt;Category&lt;/code&gt;，不过函数 &lt;code class=&quot;inline&quot;&gt;-&amp;gt;&lt;/code&gt; 就是一种 &lt;code class=&quot;inline&quot;&gt;Category&lt;/code&gt;。（译者注：如果读者有 monad 的既视感，那么恭喜你，这种的直觉说是对的，可以阅读 &lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Arrow_tutorial&quot;&gt;Arrows&lt;/a&gt; 以了解更多）&lt;/p&gt;&lt;p&gt;[3]:实际上这样的优化步骤不应该出现在生成文档这样的场景下，而是在编译优化或者其他中间结果生成这样的时候，这里使用文档生成的例子，只是为了方便说明。&lt;/p&gt;</description>
<author>禾木旁</author>
<guid isPermaLink="false">2018-09-02-43560128</guid>
<pubDate>Sun, 02 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Python 实现阴阳谜题（Yin Yang Puzzle）</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-08-29-43207643.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43207643&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-51d5125f46b7553c669a0878c104eb41_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;搜了一圈&lt;b&gt;竟然没有&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;就是这个众所周知的把 call/cc 玩出花来的。&lt;/p&gt;&lt;a href=&quot;https://www.zhihu.com/question/27683900&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;e95c1c2b95f924056dca52e6b7a9bf01&quot; data-image-width=&quot;1241&quot; data-image-height=&quot;1376&quot; data-image-size=&quot;ipico&quot;&gt;如何实现 Call / CC 或者阴阳谜题（Yin Yang Puzzle）？&lt;/a&gt;&lt;p&gt;创造宇宙这种事，没有 call/cc 可以每次新建一个 generator 啊。&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;def puzzle():
    def yin(yin):
        yield &#39;@&#39;
        def yang(yang):
            yield &#39;*&#39;
            yield from yin(yang)
        yield from yang(yang)
    yield from yin(yin)

for x, _ in zip(puzzle(), range(256)):
    print(x, end=&#39;&#39;)
print()&lt;/code&gt;&lt;p&gt;输出&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;@*@**@***@****@*****@******@*******@********@*********@**********@***********@************@*************@**************@***************@****************@*****************@******************@*******************@********************@*********************@***&lt;/code&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>HOOCCOOH</author>
<guid isPermaLink="false">2018-08-29-43207643</guid>
<pubDate>Wed, 29 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>一个现代的parser generator框架应该是什么样的</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-08-29-43206998.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43206998&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-04f502b196883798b6fcc7f8f94c59aa_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;8102年，在编译前端这个方面，原始的气息还没有远离我们。&lt;br&gt; 对于某种并非常用格式的字符串，我们想要解析它们，通常会确实地花费一些心思。 在&lt;a href=&quot;https://en.wikipedia.org/wiki/Comparison_of_parser_generators&quot;&gt;这方面的工具&lt;/a&gt;中，我们耳熟能详的东西有&lt;a href=&quot;http://www.antlr.org/&quot;&gt;Antlr4&lt;/a&gt;, &lt;a href=&quot;http://dinosaur.compilertools.net/&quot;&gt;Lex &amp;amp; Yacc&lt;/a&gt;, 各种&lt;a href=&quot;https://en.wikipedia.org/wiki/Parser_combinator&quot;&gt;ParserC&lt;/a&gt;的实现。在我开始敲码的这几年，也出现了&lt;a href=&quot;http://www.lihaoyi.com/fastparse/&quot;&gt;Fastparse&lt;/a&gt;这样的框架。&lt;/p&gt;&lt;p&gt;我们来看一些parse二元&lt;code class=&quot;inline&quot;&gt;+/-&lt;/code&gt;运算的例子:&lt;br&gt; &lt;code class=&quot;inline&quot;&gt;Antlr4&lt;/code&gt;(ruby片段), 来自&lt;a href=&quot;https://github.com/Antlr/grammars-v4/blob/master/ruby/Corundum.g4&quot;&gt;这里&lt;/a&gt;:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;dynamic_result : 
               | &amp;lt;此处省略...&amp;gt;
               | dynamic_result op=( PLUS | MINUS ) int_result
               | int_result op=( PLUS | MINUS ) dynamic_result
               | dynamic_result op=( PLUS | MINUS )  float_result
               | float_result op=( PLUS | MINUS )  dynamic_result
               | dynamic_result op=( PLUS | MINUS ) dynamic_result
               | &amp;lt;此处省略...&amp;gt;
               ;&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;cpython自己实现的pgen&lt;/code&gt;(cpython片段), 来自&lt;a href=&quot;https://github.com/python/cpython/blob/master/Grammar/Grammar&quot;&gt;这里&lt;/a&gt;:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;arith_expr: term ((&#39;+&#39;|&#39;-&#39;) term)*&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Lex &amp;amp;&amp;amp; Yacc&lt;/code&gt;, 来自&lt;a href=&quot;https://www.ibm.com/developerworks/aix/tutorials/au-lexyacc/index.html&quot;&gt;这里&lt;/a&gt;:&lt;/p&gt;&lt;code lang=&quot;antlr&quot;&gt;addexpr: NUMBER PLUSTOKEN NUMBER 
         { 
             printf(&quot;%f\n&quot;,($1+$3));
         }
         | NUMBER MINUSTOKEN NUMBER 
         { 
             printf(&quot;%f\n&quot;,($1-$3));
         }
         ;&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Fastparse&lt;/code&gt;, 来自&lt;a href=&quot;http://www.lihaoyi.com/fastparse&quot;&gt;这里&lt;/a&gt;:&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;val addSub: P[Int] = P( divMul ~ (CharIn(&quot;+-&quot;).! ~/ divMul).rep ).map(eval)&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;nom(parserc for Rust)&lt;/code&gt;(片段), 来自&lt;a href=&quot;https://stevedonovan.github.io/rust-gentle-intro/nom-intro.html&quot;&gt;这里&lt;/a&gt;:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;named!(expr&amp;lt;&amp;amp;str,f64&amp;gt;, do_parse!(
        init: term &amp;gt;&amp;gt;
        res: fold_many0!(
            tuple!(
                alt!(tag_s!(&quot;+&quot;) | tag_s!(&quot;-&quot;)),
                term
            ),
            init,
            |acc, v:(_,f64)| {
                if v.0 == &quot;+&quot; {acc + v.1} else {acc - v.1}
            }
        )
        &amp;gt;&amp;gt; (res)
    ));&lt;/code&gt;&lt;p&gt;经过对上述代码的预览，以及简要地查看相关链接，我们能够了解一点它们的差异。&lt;/p&gt;&lt;p&gt;我不太清楚人们在看到它们之后会如何选择，什么是加分项，什么可能会被diss。这种时候，我总会怀着这样一种考虑进行选择: &lt;/p&gt;&lt;p&gt;&lt;b&gt;功能是否完备正交，约定是否简洁必要&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;但说实在的，在&lt;b&gt;功能完备&lt;/b&gt;这个方面，人们可能就会出现分歧，例如有人认为, parser就按照文法定义(如果有的话)生成s-expression好了，一个列表头部有一个tag, 用以唯一识别node的结构，其余的都是子结构; 有的人又会觉得, 我就是要从一堆字符串里面parse出来一个结构体又有什么问题。更多的，有些parser框架还不支持left recur(比如cpython那个pgen)，也有人写的框架需要&lt;a href=&quot;https://www.zhihu.com/question/266250146/answer/306132266&quot;&gt;把左递归explicitly标记出来&lt;/a&gt;, 有的框架则默认处理了。&lt;/p&gt;&lt;p&gt;这时总得有自己的判断，这也是文章的观点:&lt;/p&gt;&lt;h2&gt;功能完备正交&lt;/h2&gt;&lt;h2&gt;功能1: AST的重写&lt;/h2&gt;&lt;p&gt;比方说重写ast这件事，cpython自己实现那玩意儿是没有的，Antlr可以轻松实现同为ast结构的重写，但是形成特定的数据结构，Antlr和yacc能以极其扭曲复杂的方式给出相应的笨重实现(而且这在使用中是极其常见的)，而这一切对于&lt;code class=&quot;inline&quot;&gt;fastparse&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;nom&lt;/code&gt;这种parser combinator基本是算是稀松平常。&lt;/p&gt;&lt;p&gt;一些相关事件如下:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Antlr/Antlr4/issues/1732&quot;&gt;Antlr4 issue1732&lt;/a&gt;&lt;br&gt; &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.quora.com/What-are-the-steps-to-use-antlr-to-create-an-abstract-syntax-tree-of-Java-source-code-and-then-walk-the-tree&quot;&gt;Antlr: about ast rewriting&lt;/a&gt;&lt;br&gt; &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;AST的重写有一些非常重大的意义，这个意义和我们需要结构体，而不是把其field数据存放到不同类型的数组中一样。请耐心看下面这个事情。&lt;/p&gt;&lt;p&gt;合格的文法书写者总会写出这样一种文法，使得parsing后一阶段需要处理的数据结构与这种文法保持着结构上的一致。&lt;/p&gt;&lt;p&gt;例如(因为非技术原因，我会尽量使用python写例子):&lt;/p&gt;&lt;p&gt;文法:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Add ::= Expr &#39;+&#39; Expr
# 一个二元运算的ast表示
class Add(Expr):
    left: Expr
    right: Expr&lt;/code&gt;&lt;p&gt;而仅仅是parse一段符合&lt;code class=&quot;inline&quot;&gt;Expr &#39;+&#39; Expr&lt;/code&gt;的文法，你的parse结果很可能是这样的:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;[Expr([Token(...)]), Token(+), Expr([Token(...)])]&lt;/code&gt;&lt;p&gt;拿到这样原始的ast，虽说确实可以进行下一步的工作，但说真的，操作这样的ast可读性太差了，&lt;b&gt;&quot;你在一段sexpr里取第三个位置，鬼知道你取的是什么&quot;&lt;/b&gt;，而且类型也没有，不安全，不可维护。&lt;/p&gt;&lt;p&gt;我经历过这样的时期，你可以观光一下，我是如何用这样的ast造出一门门语言的。。 &lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/thautwarm/Rem&quot;&gt;功能缺失的EBNFParser&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/thautwarm/Rem&quot;&gt;Rem语言&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这个时候，我认为需要这样一种功能:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Add ::= left=Expr &#39;+&#39; right=Expr 
    -&amp;gt;  Add(left, right)&lt;/code&gt;&lt;p&gt;有一件非常有意思的事情是，如果你的文法中，除开辅助的语法结构，如果每一个都写了这样的重写规则，你会发现你似乎可以直接把你parse后的东西交给编译器的后端, 比如下面这样一段可能不严谨但比较形象的叙述:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;parse数字出来了一个叫Number的结构体，里面包了一个数字&lt;/li&gt;&lt;li&gt;parse加法出来了一个叫Add的结构体，里面左右分别是Number实例&lt;/li&gt;&lt;li&gt;parse lambda表达式出来了一个叫Lambda的结构体，里面的body属性正好是之前parse出来那个Add实例  &lt;/li&gt;&lt;li&gt;以此类推...&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于经常使用ADT的人，我觉得还有必要说一下，在这样的重写功能下，你直接得到了一棵&lt;code class=&quot;inline&quot;&gt;data/type&lt;/code&gt;定义的语法树，而你所做的不过是仅仅写了一段文法。&lt;/p&gt;&lt;p&gt;关于语法树重写有更多基于易用性的简化，如果有兴趣请与我直接讨论。&lt;/p&gt;&lt;h2&gt;功能2: 额外的Parsing约束条件&lt;/h2&gt;&lt;p&gt;就是说Parsing guard.&lt;/p&gt;&lt;p&gt;比如，我们都知道，一段xml或者其derivative总是以&lt;code class=&quot;inline&quot;&gt;&amp;lt;xxx&amp;gt;&lt;/code&gt;开头，然后以&lt;code class=&quot;inline&quot;&gt;&amp;lt;/xxx&amp;gt;&lt;/code&gt;结尾。这里是一个状态相关的要素，并非所有parser都能对xml的parsing是否成功做出判断。&lt;/p&gt;&lt;p&gt;我在昨年的某一天产生了这样一个想法，它重重地敲击着我的神经，呼唤着我的实现:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;xml = &#39;&amp;lt;&#39; tag1 = tagName &#39;&amp;gt;&#39; 
       ...省略
       &#39;&amp;lt;&#39; &#39;/&#39; tag2 = tagName &#39;&amp;gt;&#39;
       with tag1 == tag2&lt;/code&gt;&lt;p&gt;我设计了&lt;code class=&quot;inline&quot;&gt;with&lt;/code&gt;子句，让一个&lt;b&gt;有名字的parser&lt;/b&gt;成功parse后，还需要对捕捉到的tag1和tag2进行相等比较，如果表达式为假，则parse失败。&lt;/p&gt;&lt;p&gt;同样的，还有一个&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;子句，用于刚刚进入某个&lt;b&gt;有名字的parser&lt;/b&gt;时，进行的预先判断，如果判断为假，则该parser失败。&lt;/p&gt;&lt;p&gt;在我的方法下，这个&lt;b&gt;有名字的parser&lt;/b&gt;对于context sensitive的文法处理是一个比较重要的概念，但是这个是&lt;a href=&quot;https://github.com/thautwarm/RBNF&quot;&gt;私货&lt;/a&gt;，有兴趣请直接与我细聊。&lt;/p&gt;&lt;p&gt;通过这些额外的parsing约束条件，我们可以轻易实现很多复杂的功能。人们总喜欢通过构造context sensitive的tokenizers来实现缩进，可是这并不是唯一的方式，甚至不是好的方式，如果有兴趣不妨看一下&lt;a href=&quot;https://github.com/thautwarm/merlin/blob/master/rml/rml/rml.rbnf&quot;&gt;我是如何实现一个类ocaml语言的缩进的&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;功能3: 左递归的支持&lt;/h2&gt;&lt;p&gt;无论是显式表明左递归，还是不需要额外约定直接处理，我认为左递归的支持是必要的。上升到用户层面，且不说不是所有人都关心各种各样的左递归消除方式，即使了解且熟悉，让用户使用你的服务时需要为之付出精力，怎么想也是一种缺憾。&lt;br&gt; 当然从根本上讲，左递归所代表的左结合的关系，在数据结构中不可避免。  &lt;/p&gt;&lt;h2&gt;关于功能的完备正交 &amp;amp; 关于parser的抽象&lt;/h2&gt;&lt;p&gt;在parser本身的功能上, 我认为，如果拥有上述三种功能，那么几乎可以解决任何parsing问题，不仅仅是缩进这种小菜, 还可以&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30279723&quot;&gt;各减平均各自乘相加除以项数开方&lt;/a&gt;, 根据用户自定义的词语，动态的生成新的parser，不再需要空格分隔关键字这些操作。&lt;br&gt; &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/thautwarm/RBNF/blob/master/demos/calc-for-rbnf/calc-immediately.rbnf&quot;&gt;parser写完，解释器即写完&lt;/a&gt;&lt;br&gt; &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;总之要什么有什么，确实就是这么为所欲为。&lt;/p&gt;&lt;p&gt;但关于正交的问题，则需要说得多一点了。&lt;/p&gt;&lt;p&gt;既然完备，既然正交，那么核心里就必然有一些基本的东西来生成所有可能的构造。&lt;/p&gt;&lt;p&gt;我们写后端都知道讲language constructs, 而写前端，如果是上下文无关语法，我们有前人们给好的BNF和EBNF，其语法结构对应了一套正交完备的、描述context free的语法功能，由于这些语法结构可以直接和不同的parser combinator一一对应，所以我们可以知道, 严格按照BNF/EBNF语法结构实现的parserc框架可以正交地表达出完备的、受限于context free情境下的parsing能力。&lt;/p&gt;&lt;p&gt;P.S : 有些版本的EBNF中可能存在一些不正交的功能(例如A ::= [B] C和 A ::= B C | C等价)，这是为了使用上的便利性。因为并没有带来超过一只手的新约定，学习曲线和遗忘曲线依然令人满意。&lt;/p&gt;&lt;p&gt;而给EBNF添加之前讲到的&lt;b&gt;语法树重写&lt;/b&gt;以及&lt;b&gt;额外的Parsing约束条件&lt;/b&gt;(parsing guard)之后，这个&lt;b&gt;扩展的扩展BNF&lt;/b&gt;就成为能轻松描述诸多context sensitive cases的强大范式，而它的language constructs，满打满算，好像也才是个位数。&lt;/p&gt;&lt;code lang=&quot;fsharp&quot;&gt;type Rewrite = ...
type Guard   = ...

type EEBNFParser = 
(** &#39;&amp;lt;token&amp;gt;&#39; *)
| Literal of string
(** A ::= a b c d e*)
| And     of EEBNFParser list
(** A ::= a | b | c | d*)
| Or      of EEBNFParser list
(** A ::= a{1, 10} *)
| Rep     of at_least: int * at_most: int * EEBNFParser
(** A ::= b=B c=C D E *)
| Bind    of name: string * EEBNFParser
(** A ::= ... // 语法树重写、parsing guard
          when ...
          with ...
          rewrite ...
 *)
| Named   of name: string * EEBNFParser * Rwrite * Guard&lt;/code&gt;&lt;p&gt;看清楚了，&lt;b&gt;context sensitive的parser只要5种基本结构&lt;/b&gt;, 左递归的实现则涉及具体parser算法的问题。 更多的，这里的parser不再是一个type constructor，如果你脑子里仍然装有&lt;code class=&quot;inline&quot;&gt;&#39;t Parser&lt;/code&gt;把tokenizers转换成&lt;code class=&quot;inline&quot;&gt;&#39;t&lt;/code&gt;或是&lt;code class=&quot;inline&quot;&gt;&#39;t AST&lt;/code&gt;类型，不妨看一下我&lt;a href=&quot;https://github.com/thautwarm/Ruiko.fs/tree/master/RBNF/Core&quot;&gt;对parser的定义和其parse所得对象的一种解耦&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;以上，是我对于一个现代parser generator框架的抽象核心的导出。&lt;/p&gt;&lt;h2&gt;约定简洁必要&lt;/h2&gt;&lt;p&gt;这个时候，往前翻一翻rust的&lt;code class=&quot;inline&quot;&gt;nom&lt;/code&gt;的示例代码，以及doc里&lt;a href=&quot;https://docs.rs/nom/4.0.0/nom/#modules&quot;&gt;这一大堆API&lt;/a&gt;, 是什么考虑让设计者们抛弃parserc的紧凑优美，达到这样一种神奇的现状?&lt;/p&gt;&lt;p&gt;个人看法 ———— 我觉得这exactly就是&lt;code class=&quot;inline&quot;&gt;overdeveloped&lt;/code&gt;。该rewrite就rewrite，不用自己搞一套。如无必要，勿增实体。&lt;/p&gt;&lt;p&gt;从之前我说的那个功能完备正交的核心走过来，我有理由认为绝大多数的parser框架都极度冗长，Antlr 和 lex&amp;amp;yacc要实现rewrite和parsing guard简直就像原始人在玩泥巴，需要手写一坨坨巨长的、需要遵守一堆conventions的嵌入代码，  &lt;/p&gt;&lt;p&gt;&lt;b&gt;没有快速实践想法的repl之类的东西&lt;/b&gt;(我知道Antlr有一个&lt;a href=&quot;https://stackoverflow.com/questions/24766006/getting-Antlr-to-generate-a-script-interpreter&quot;&gt;这个&lt;/a&gt;, 但是对着dsl/esdl的文件直接执行的，目前不存在的。 &lt;b&gt;私货&lt;/b&gt;: &lt;code class=&quot;inline&quot;&gt;rbnf run &amp;lt;script&amp;gt;&lt;/code&gt;了解一下),&lt;/p&gt;&lt;p&gt;&lt;b&gt;甚至lexer居然还不是自动生成的&lt;/b&gt; ———— 这样的直接结果是因为需要用户手写lexer又要引入一堆conventions。同时，由于&lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/337676/what-is-the-procedure-that-is-followed-when-writing-a-lexer-based-upon-a-grammar&quot;&gt;一套文法的定义已然可以蕴含对应的lexer&lt;/a&gt;，你再让用户手写，令人窒息何如！&lt;/p&gt;&lt;p&gt;如此看来，除了fastparse简直没有一个能看。&lt;/p&gt;&lt;p&gt;fastparse的话, 基本上很符合之前那个5个基本constructs的核心，API比起核心也就是多搞了一些糖。&lt;/p&gt;&lt;p&gt;若真非要我挑好多刺，我觉得有点迫真。但并不是没有，&quot;鬼画桃符&quot;可以黑一个。&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;val option = P( &quot;c&quot;.? ~ &quot;a&quot;.rep(sep=&quot;b&quot;).! ~ End)
val captureRep = P( &quot;a&quot;.!.rep ~ &quot;b&quot; ~ End)&lt;/code&gt;&lt;p&gt;虽然这并不是大问题, 你稍微认真看还是相当可读的，况且向scala这种语言要求颜值是不是有点精分?&lt;/p&gt;&lt;p&gt;更多地，对于real world来说，Repeat有sep这个玩意儿真的蛮方便的，我觉得比较惊艳的一个特性还有&lt;a href=&quot;http://www.lihaoyi.com/fastparse/#Opaque&quot;&gt;Opaque&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;以上并没有非常详细地说明&lt;b&gt;约定简洁必要&lt;/b&gt;这个主题，因为本身API的简洁必要已经是非常明确的概念:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;必要: 保证功能完整&lt;/li&gt;&lt;li&gt;简洁: 这个结构被使用起来轻量，可读性较高&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在这个section的最后，我提一个事情。 一个半月前我基本实现了一个sql(这个就不能放链接了因为是工作相关)，照着&lt;a href=&quot;https://github.com/apache/spark/blob/master/sql/catalyst/src/main/Antlr4/org/apache/spark/sql/catalyst/parser/SqlBase.g4&quot;&gt;Antlr 1094行ebnf的sparksql&lt;/a&gt;改，然后简化为350行，且直接生成极其high level的tagged union(python里我不好意思说这是ADT)。那几天看g4不知道恶心了多少次。&lt;/p&gt;&lt;h2&gt;其他重要的特性&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;模块化与代码复用&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;parser generator使用某种dsl刻画，那么应该使用模块的方式进行管理，并且这种模块的语法还应该对不同后端做出合理描述。&lt;/p&gt;&lt;p&gt;这里不上一下私货的话，实在没什么别的替代品。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;# bnf源码的模块，不同后端可以复用
import std.common.[Number Space]

# `[python] import` 引导python specific的模块，用以构造rewrite和parsing guard。
# 不同后端不复用
[python] import functools.[reduce]
[python] import operator.[add sub mul truediv floordiv mod]&lt;/code&gt;&lt;ul&gt;&lt;li&gt;parser可持久化&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;也许由于巨量的编译前优化，构造某些parser相对缓慢，但应该容许构造完毕后能dump到存储单元，并以二进制方式进行快速的load。&lt;/p&gt;&lt;p&gt;可持久化并非总是为了性能，如果load持久化的parser对象不需要原parser generator库的依赖，也会是一个巨大的优势。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Automatically lexer&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;之前已经有提到，我认为这也是现代parser generator的一种标志。&lt;/p&gt;&lt;p&gt;当lexer可以被文法决定时，用户不应该再被要求书写它。&lt;/p&gt;&lt;h2&gt;最后&lt;/h2&gt;&lt;ul&gt;&lt;li&gt; 私货&lt;br&gt; 以上一切，在&lt;a href=&quot;https://github.com/thautwarm/RBNF&quot;&gt;RBNF&lt;/a&gt;中&lt;b&gt;高度完成&lt;/b&gt;。&lt;br&gt; 之前 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0251012c87c2d3f56ac34de7d71cdcbc&quot; data-hash=&quot;0251012c87c2d3f56ac34de7d71cdcbc&quot; data-hovercard=&quot;p$b$0251012c87c2d3f56ac34de7d71cdcbc&quot;&gt;@圆角骑士魔理沙&lt;/a&gt;  给我说了一个东西，从一个写好的AST自动生成一个Parser。&lt;br&gt; 然而我都有这个东西了，还要啥自行车...(雾:&lt;br&gt; &lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;text&quot;&gt;// 定义文法; 事实上还有embedded python的方式，和写AST差不多。
A :: = B C as c D as d

// 不仅生成了parser, 还帮我自动定义了AST =_=

type AST = A | C | D | ...
type A = {
    c : C
    d : D
} 
type C = ...
...
//然后parse一下符合文法的字符串，就是那套ADT了。&lt;/code&gt;&lt;ul&gt;&lt;li&gt; 错误定位怎么做&lt;br&gt; 首先，tokenizer里面要包含lineno(行号), colno(列号), filename(可选，如果你的语言没有source code inline的话是不需要的)。&lt;br&gt; 然后AST可以都增加lineno, colno, filename三个属性。 当然对于AST错误定位，更好的办法是下面这段代码所示。详见&lt;a href=&quot;https://github.com/thautwarm/LLAST/tree/master/LLAST/LLVM&quot;&gt;LLAST&lt;/a&gt;.&lt;br&gt; &lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;fsharp&quot;&gt;type location = {
(**
for location resolving in exception reporting.
*)
    filename: string
    lineno  : int
    colno   : int
}
type AST = 
    | ...
    | Locate of location * AST&lt;/code&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>NightyNight</author>
<guid isPermaLink="false">2018-08-29-43206998</guid>
<pubDate>Wed, 29 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何制造SCP018</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-08-28-43163820.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43163820&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;什么是Tail Call？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Tail Call（尾调用）指，我们调用一个函数后，立刻返回。&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;def triple(x): # 返回的不是函数
    return x * 3

def is_tail_call(x): # 是尾调用，因为我们调用后就返回了
    return triple(x)

def not_tail_call(x): # 不是尾调用，因为我们调用完还要1 + result
    return 1 + triple(x)

def half_tail_call(x): # 外面的是尾调用，里面的不是
    return triple(triple(x))&lt;/code&gt;&lt;p&gt;在以上例子中，is_tail_call的triple，跟half_tail_call的外面的triple，是tail call。&lt;/p&gt;&lt;p&gt;&lt;b&gt;为什么Tail Call很重要？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;因为Tail Call提供了很好的优化。&lt;/p&gt;&lt;p&gt;假设我们是register machine，return address存在一个register里面，如果我们tail call，我们需要：把argument放对位置，然后goto function就可以了！&lt;/p&gt;&lt;p&gt;如果是non tail call，我们需要把argument放对位置，保存旧的return address（比如说塞上stack），设定return address为下一行，goto function，把旧的return address restore掉，然后该干啥干啥。&lt;/p&gt;&lt;p&gt;这样，我们额外的多做了一push一pop，space &amp;amp; time overhead一下子上来了，怪不得60~70年代的人不肯用函数。。&lt;/p&gt;&lt;p&gt;当我们递归的时候，不做这个优化导致了big O上的空间差距 - 一个要不停的push stack，一个说，stack是啥？&lt;/p&gt;&lt;p&gt;另一点是，当递归的时候，argument的位置是对的，‘放对位置’这一步就没有了，于是就成为了一个goto self - 也就是loop。&lt;/p&gt;&lt;p&gt;尾递归优化，其实就是Tail Call Optimization在taill call self下的优化。（见&lt;a href=&quot;https://dspace.mit.edu/handle/1721.1/5753&quot;&gt;Debunking the &#39;Expensive Procedure Call&#39; Myth, or, Procedure Call Implementations Considered Harmful, or, Lambda: The Ultimate GOTO&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;如果你会continuation，Tail Call说的就是，当你call进去的continuation，跟你自己的cont是eta equivalent时，直接传就好了。&lt;/p&gt;&lt;p&gt;Continuation某种程度下对应返回地址，所以这也是说，如果没有必要，不需要动返回地址。&lt;/p&gt;&lt;p&gt;&lt;b&gt;但是：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;很不幸的，有些解释器/编译器不做tail call optimization。这代表上面写递归函数，会占用大量空间。怎么办？&lt;/p&gt;&lt;p&gt; 假设我们是C语言。&lt;/p&gt;&lt;p&gt;那很简单，直接inline asm啊！啥地方要tail call，直接inline一个goto过去，一切解决。&lt;/p&gt;&lt;p&gt;当然，inline asm没多少语言支持 - 连C也要开编译器扩展才行。&lt;/p&gt;&lt;p&gt;&lt;b&gt;那，我们在程序里面模拟一个program counter，不就一切OK了吗？&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;# 转换：
# 在函数头插入global pc
# 所有尾调用变成pc = ...
# 改用eval

pc = None # program counter

def eval(f):
    global pc
    pc = f
    while True:
        pc()

cnt = 0
def naive_rec():
    global cnt
    print(cnt)
    cnt += 1
    naive_rec()
    
# naive_rec() # 错误：达到最深递归层次

cnt = 0
def rec():
    global pc
    global cnt
    print(cnt)
    cnt += 1
    pc = rec

# eval(rec) # 远远超过了递归限制！&lt;/code&gt;&lt;p&gt;好像可以呢！&lt;/p&gt;&lt;p&gt;&lt;b&gt;但是函数参数是不是要像register那样手动设置？那样实在太丑了。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;幸好，python有closure，我们放进closure里面就行了。&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;# 转换：
# 尾调用变lambda
# eval加上lambda

pc = None # program counter

def eval(f):
    global pc
    pc = f
    while True:
        pc()

def naive_rec_arg(cnt):
    print(cnt)
    naive_rec_arg(cnt + 1)

# naive_rec_arg(0) # 毫无意外，同一错误

def rec_arg(cnt):
    global pc
    print(cnt)
    pc = lambda: rec_arg(cnt + 1)

# eval(lambda: rec_arg(0)) # 再一次超越极限！&lt;/code&gt;&lt;p&gt;一切都好。但是，函数有输入，当然也有输出，现在怎么办？&lt;/p&gt;&lt;p&gt;要注意的是，我们不能用全局变量来模拟。&lt;/p&gt;&lt;p&gt;原因很简单，eval是个死循环，永远不返回，就算返回值assign到某全局变量，我们也不能让当前函数调用完，让调用者使用返回结果。&lt;/p&gt;&lt;p&gt;怎么办？&lt;/p&gt;&lt;p&gt;&lt;b&gt;既然核心问题是eval，我们使得eval不是死循环就可以了啊！&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;# 转换：
# 对尾调用，pc = lambda: ... 跟上 return None
# 对普通返回，pc = None 跟上 return ...
# 函数尾：pc = None

pc = None # program counter

def eval(f):
    global pc
    old_pc = pc # 如果eval里面用eval怎么办？保存老pc就OK
    pc = f
    result = None
    while pc:
        result = pc()
    pc = old_pc
    return result

def naive_is_even_0(x):
    if x &amp;gt; 1:
        return naive_is_even_1(x - 2)
    if x == 1: # 故意这样写，测试early return正确性
        return False
    else:
        return True # 通过互递归提高难度

def naive_is_even_1(x):
    return naive_is_even_0(x)

assert not naive_is_even_0(123)
# assert not naive_is_even_0(2345) # 又是你

def is_even_0(x):
    global pc
    if x &amp;gt; 1:
        pc = lambda: is_even_1(x - 2)
        return None # 没有这行会接着运行！
    if x == 1:
        pc = None
        return False
    else:
        pc = None
        return True
    pc = None # 这很二，但是我们希望转换越简单越好！

def is_even_1(x):
    global pc
    pc = lambda: is_even_0(x)
    return None
    pc = None

assert not eval(lambda: is_even_0(2345)) # 过！&lt;/code&gt;&lt;p&gt;很好。但是我们看一下，这代码很危险！&lt;/p&gt;&lt;p&gt;很简单，我们要先set pc，然后再return一些东西。&lt;/p&gt;&lt;p&gt;但是，如果我们手滑了一下，忘了set pc，会怎么样？&lt;/p&gt;&lt;p&gt;这样，我们就会进入死循环，而得益于我们的优化，我们甚至不能stack overflow来表示无限递归了！&lt;/p&gt;&lt;p&gt;我们也希望，pc set成lambda的时候，返回值是None：那时，返回值是被无视的，但是限制返回为None能更早暴露程序的问题。&lt;/p&gt;&lt;p&gt;我们希望，有一个python表达式，SetFunAndReturnNone，来保证set pc后才能return。&lt;/p&gt;&lt;p&gt;同理，如果有个python表达式，SetNoneAndReturnVal，保证set None后会返回一个值（没有返回的就返回None，表示没忘）也好，这样能确定程序员在用pc修改器的时候，不会忘记设返回值。&lt;/p&gt;&lt;p&gt;python没有这两个表达式，但是还好，这两个表达式都是会返回一个值的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;既然eval已经在操控pc了，我们可以让他担任更多解释器的工作：我们可以定义代表这两表达式的class，pc的返回值只能是这两表达式（如果忘记设定，导致pc返回None，算作错误，因为这情况下pc也会忘记更新了）&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;# 转换：
# 去掉global pc
# pc = lambda:... 接 return None 改写成 return SetFunAndReturnNone(...)
# pc = None 接 return ... 改写成 return SetNoneAndReturnVal(...)
# 行尾插入SetNoneAndReturnVal(None)

class SetFunAndReturnNone:
    def __init__(self, f):
        self.f = f

class SetNoneAndReturnVal:
    def __init__(self, x):
        self.x = x

pc = None # program counter

def eval(f):
    global pc
    old_pc = pc # 如果eval里面用eval怎么办？保存老pc就OK
    pc = f
    result = None
    while pc:
        command = pc()
        if isinstance(command, SetFunAndReturnNone):
            pc = command.f
            result = None
        else:
            assert isinstance(command, SetNoneAndReturnVal)
            pc = None
            result = command.x
    pc = old_pc
    return result

def is_even_0(x):
    if x &amp;gt; 1:
        return SetFunAndReturnNone(lambda: is_even_1(x - 2))
    if x == 1:
        return SetNoneAndReturnVal(False)
    else:
        return SetNoneAndReturnVal(True)
    return SetNoneAndReturnVal(None)

def is_even_1(x):
    return SetFunAndReturnNone(lambda: is_even_0(x))
    return SetNoneAndReturnVal(None)

assert not eval(lambda: is_even_0(2345)) # 过!&lt;/code&gt;&lt;p&gt;我们现在架构的改动已经做完了。但是，还能优化下这个文件。&lt;/p&gt;&lt;p&gt;最基本的，pc只有eval在用了，能搬进去，也不用担心重入的问题了，因为每个eval的调用都会有自己的pc&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;def eval(f):
    pc = f # program counter
    result = None
    while pc:
        command = pc()
        if isinstance(command, SetFunAndReturnNone):
            pc = command.f
            result = None
        else:
            assert isinstance(command, SetNoneAndReturnVal)
            pc = None
            result = command.x
    return result&lt;/code&gt;&lt;p&gt;pc = None的时候能直接返回，不需要在while里面：&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;def eval(f):
    pc = f # program counter
    result = None
    while pc:
        command = pc()
        if isinstance(command, SetFunAndReturnNone):
            pc = command.f
            result = None
        else:
            assert isinstance(command, SetNoneAndReturnVal)
            return command.x
    return result&lt;/code&gt;&lt;p&gt;result可以去掉了，因为只会assign成None&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;def eval(f):
    pc = f # program counter
    while pc:
        command = pc()
        if isinstance(command, SetFunAndReturnNone):
            pc = command.f
        else:
            assert isinstance(command, SetNoneAndReturnVal)
            return command.x&lt;/code&gt;&lt;p&gt;如果我们假设SetFunAndReturnNone.f不会是None，f也不是None，pc在循环中不会变成None。我们就能直接while True:&lt;/p&gt;&lt;p&gt;我们也假设f不会是None - 我们的所有代码都不会传个None进去&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;def eval(f):
    pc = f # program counter
    while True:
        command = pc()
        if isinstance(command, SetFunAndReturnNone):
            pc = command.f
        else:
            assert isinstance(command, SetNoneAndReturnVal)
            return command.x&lt;/code&gt;&lt;p&gt;这两个class名字好长。。。而且pc已经是内部实现了，我们不应该暴露出来。&lt;/p&gt;&lt;p&gt;&lt;b&gt;我们重命名SetFunAndReturnNone做More（需要更多计算），同样的，重命名SetNoneAndReturnVal为Done（搞定）。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们最后，再优化一下使用代码，去掉不需要的return。&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;class More:
    def __init__(self, f):
        self.f = f

class Done:
    def __init__(self, x):
        self.x = x

def eval(f):
    pc = f # program counter
    while True:
        command = pc()
        if isinstance(command, More):
            pc = command.f
        else:
            assert isinstance(command, Done)
            return command.x

def is_even_0(x):
    if x &amp;gt; 1:
        return More(lambda: is_even_1(x - 2))
    if x == 1:
        return Done(False)
    else:
        return Done(True)

def is_even_1(x):
    return More(lambda: is_even_0(x))

assert not eval(lambda: is_even_0(2345)) # pass!&lt;/code&gt;&lt;p&gt;大功告成。&lt;/p&gt;&lt;p&gt;&lt;b&gt;我们最后，跟小杰站着世界树之巅，看看我们实现了什么，顺带找找爸爸：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当我们eval的时候，我们会先调用pc。&lt;/p&gt;&lt;p&gt;然后，我们会push一个stack frame。&lt;/p&gt;&lt;p&gt;当tail call出现的时候，与其去apply之（并且把这个stack frame也push进去），我们直接返回！&lt;/p&gt;&lt;p&gt;这样，我们当前的stack frame就会pop掉。&lt;/p&gt;&lt;p&gt;pop掉后，我们又立刻进入该 call，再push一个frame。&lt;/p&gt;&lt;p&gt;我们的frame数量，就会这样0-1-0-1-0-1，循环往复。故此，这个方法叫做trampoline。&lt;/p&gt;&lt;p&gt;如果你觉得trampoline很有趣，我推荐去看&lt;a href=&quot;http://blog.higher-order.com/assets/trampolines.pdf&quot;&gt;http://blog.higher-order.com/assets/trampolines.pdf&lt;/a&gt;，简单又漂亮的一篇paper。&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2018-08-28-43163820</guid>
<pubDate>Tue, 28 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>流派未月亭</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-08-25-42907876.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/42907876&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近在群聊的时候，我们聊到了一个观点。&lt;/p&gt;&lt;blockquote&gt;亚里士多德时代的科学不可能容许黑魔法，因为亚式科学的核心是 - 用直觉观察事物，得出物体的本质。黑魔法这种反常识的东西，只可能在可证伪科学体系下出现 - 这不你看，js就是现代产物（&lt;/blockquote&gt;&lt;p&gt;我的一个写C++的朋友趁机黑一把：‘函数式编程也是现代产物’。&lt;/p&gt;&lt;p&gt;我想了想，拿出了收藏已久的&lt;a href=&quot;https://www.cs.cmu.edu/afs/cs/user/jcr/ftp/craftprog.pdf&quot;&gt;The Craft Of Programming&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;为什么呢？很简单：这本书是本Gateway Drug。 &lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a6f91f83fbb9ad20bbd88dbeff3c2246_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;606&quot; data-rawheight=&quot;159&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a6f91f83fbb9ad20bbd88dbeff3c2246&quot; data-watermark-src=&quot;v2-0b27d064b8f96ebbba48ab1f344a7d95&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这是第13页。很简单的Imperative程序，跟FP的学院派黑魔法正好形成鲜明对比。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-12897343dc623708ef0e3baeaacb2e5c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;572&quot; data-rawheight=&quot;558&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-12897343dc623708ef0e3baeaacb2e5c&quot; data-watermark-src=&quot;v2-8b897928d73c06061471502af771f0fd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt; 17页开始教你怎么自顶向下写程序，很稳啊，一步一步来。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ec1da727cbed33194c1dcf956574a065_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;342&quot; data-rawheight=&quot;294&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ec1da727cbed33194c1dcf956574a065&quot; data-watermark-src=&quot;v2-b70613069a801a7890fd82ae7798ef09&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;22页。给出程序的时候还加入了大量assertion，保证出错能debug到问题的那一行，很健壮啊。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e6e92596fb0edff44266b977f2e4b4fe_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;225&quot; data-rawheight=&quot;119&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e6e92596fb0edff44266b977f2e4b4fe&quot; data-watermark-src=&quot;v2-38cf2e8b6b44ef835eefd2f5099af2e3&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这本书有400多页，太长了，我得加快进度。跳到了第44页，好像还行啊，这在说，假设满足P下运行程序S1，会满足Q，满足Q下运行S2，会满足R，满足P下运行S1后接S2会满足R。&lt;/p&gt;&lt;p&gt;直觉上还挺好理解的。。。不过为啥越来越学院派了？&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0e2eb6001dfe7078a383cef844baf06f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;580&quot; data-rawheight=&quot;337&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0e2eb6001dfe7078a383cef844baf06f&quot; data-watermark-src=&quot;v2-bfbaba520935e68b00f393345903f836&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;89页。我是在上逻辑学课程吗？&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-20b415f4d60199cfe83766a67c889614_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;576&quot; data-rawheight=&quot;125&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-20b415f4d60199cfe83766a67c889614&quot; data-watermark-src=&quot;v2-17ef2df3fb36e55813f0b7766634aa70&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5dd69b10c6216c7ae8326334f0845238_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;586&quot; data-rawheight=&quot;531&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5dd69b10c6216c7ae8326334f0845238&quot; data-watermark-src=&quot;v2-d8a5731a3abf34d92d27360e364e64a2&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;95 97页。函数出来情有可原，为啥出现了交换图？喵喵喵？&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5b94467a1f5107867e2c6ed39f72c369_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;576&quot; data-rawheight=&quot;507&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5b94467a1f5107867e2c6ed39f72c369&quot; data-watermark-src=&quot;v2-92d5c1eadb6d13c87662348be254ab60&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;159页。be。。beta reduction？&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-483b490a1388279d886c91656e8a58a8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;519&quot; data-rawheight=&quot;137&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-483b490a1388279d886c91656e8a58a8&quot; data-watermark-src=&quot;v2-4e042498b38972fd6ee490e0789abca0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;178页。有高阶函数已经算不了啥了。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5a7a07bda1db16942b0563a56cf69cae_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;598&quot; data-rawheight=&quot;370&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5a7a07bda1db16942b0563a56cf69cae&quot; data-watermark-src=&quot;v2-8ddc90bcfecac1a9d85fe0c94875b945&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;206页。Environment跟Denotational Semantic都出来了。&lt;/p&gt;&lt;p&gt;到了这一步我们有啥？&lt;/p&gt;&lt;p&gt;program calculation（stepwise refinement)&lt;/p&gt;&lt;p&gt;equivalence law&lt;/p&gt;&lt;p&gt;type derivation&lt;/p&gt;&lt;p&gt;simply typed lambda calculus&lt;/p&gt;&lt;p&gt;environment&lt;/p&gt;&lt;p&gt;denotational semantic&lt;/p&gt;&lt;p&gt;这跟SML还差啥？&lt;/p&gt;&lt;p&gt;HM？（我们可以写generic program，这些program等价于inline，然后因为是inline，所以有equivalence constraint。用这些constraint可以导致不需要写类型，可以去推导）&lt;/p&gt;&lt;p&gt;ADT？（其实这门语言是Algol W，已经有ADT了）&lt;/p&gt;&lt;p&gt;First Class Reference？（且不说Reference怎么算作函数式特性，这本书作者，John Reynold的Essence of Algol里面就很好的引入了Reference。）&lt;/p&gt;&lt;p&gt;Garbage Collection?（试想象下C程序员指着Java程序员说你丫太学院派了）&lt;/p&gt;&lt;p&gt;&lt;b&gt;所以说，你看看，Imperative Programming跟Functional Programming有啥本质区别呢？这些特性，每一个的加入都如此理所当然，但是那一步才算是一个‘函数式编程语言’？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们早就过了亚里士多德时代，发现了世界并没有这么多‘本质’。无论是那种语言，都是一步步从已有语言摸索出来的，只要你跟着，每次都学一个最小改动，到最后，你也会发现‘就这回事啊’。Lambda Cube是如此，&lt;a href=&quot;https://vanemden.wordpress.com/2016/11/12/the-essence-of-algol/&quot;&gt;Algol到Prolog是如此&lt;/a&gt;，&lt;a href=&quot;http://profs.sci.univr.it/~merro/files/harper.pdf&quot;&gt;Algol到Haskell更是如此&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;既然编程语言之间并没有本质差别，那，什么是编程的流派？什么是面向对象/函数式/过程式？编译语言/解释语言/机器语言/电路描述语言？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;答：流派未月亭。没有打错。没有发疯。&lt;/p&gt;&lt;p&gt;&lt;br&gt; 在起初，John Mccarthy没搞懂Lambda Calculus，导致JMC Lisp并不对应Lambda Calculus，连Lexical Scope都没有。Lexical Scope是Algol加入的，而编程语言跟Lambda Calculus的对应是Landin发现的。但这不是跟ISWIM对应，是跟Algol！OOP的元老之一，Luca，做过ML Module的奠基性工作，另一个元老，Alan Kay，借助了FExpr（MACLISP）的概念。Backus写出了Fortran后广播了不朽的&#39;Can Programming be liberated from Von Neumann Style?&#39;。借鉴了OO的Actor跟Algol的Scope的Guy Steel，又写出了Scheme，之后本人更是投身于Java跟Fortress这两门OO语言。而Algol，则受到了JMC吹枕边风，加入了if else expression跟recursion。&lt;b&gt;The craft of programming并不是偶然，而是必然：所有流派都在诞生之初互相纠缠，至今从未分开&lt;/b&gt; - 这不你看，ICFP还会接OO paper，OOPSLA不也一样，更不用说Scala这种融合两种范式的语言（当然，这样的work历史上屡见不鲜。）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;另，各种编程语言之间，只要发展到了一定地步，就可以用库实现各种feature。Scheme有lambda the ultimate imperative/goto，说只需要lambda就能实现assignment/dynamic scope/while/goto，Haskell有lazy functional state thread有typing dynamic typing有final tagless，要状态要动态类型要封装要可扩展性都可以自己随手实现，smalltalk能用object代表conditional，scala能用object代表module。OCaml也实现了effect system，发现go full circle，跟Haskell用monad表示的extensible effect殊途同归。而Haskell中通过first class Typeclass（Constraint，Dict）跟Constraint上定义subtyping typeclass，再加上Existential Type，就能随意控制扩展性 - 我就玩过这样的trick刚好3次。只要语言支持一定的功能，什么范式都能加进去。&lt;b&gt;所以你看，所有主流语言都是多’范式‘的。到了这种地步，何必继续拘泥于这种划分？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;编译语言/解释语言等更是虚妄，要知道，一个scheme就可以编译成机器码/有直接吃scheme表达式的机器/还有把scheme 程序弄成电路的尝试。连system verilog都有class了，这等划分的意义可在？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果我想写得好听点，我可以说，因为绝大部分语言都有多种范式，范式定义永不明确，是由很多更小的，正交的feature一个个组成的，所以我们应该求同存异，抛弃各种范式的偏见，就跟过去跟现在一样继续互相学习。。。但是我不。&lt;/p&gt;&lt;p&gt;因为流派未月亭。&lt;/p&gt;&lt;p&gt;这就是编程的本质，编程的流派，编程的范式。流派未月亭。&lt;/p&gt;&lt;p&gt;就是如此荒谬，毫无意义。&lt;/p&gt;&lt;p&gt;只要我们一天还在用着‘范式’去讨论编程语言，我们就会永远陷入这种情况：&lt;/p&gt;&lt;a href=&quot;https://www.zhihu.com/question/27468564&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;如何通俗易懂地举例说明“面向对象”和“面向过程”有什么区别？&lt;/a&gt;&lt;a href=&quot;https://www.zhihu.com/question/19728806&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;面向对象编程是否是从根本上反模块化且反并行的？为什么？&lt;/a&gt;&lt;a href=&quot;https://www.zhihu.com/question/20275578&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;面向对象编程的弊端是什么？&lt;/a&gt;&lt;a href=&quot;https://www.zhihu.com/question/27468564&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;如何通俗易懂地举例说明“面向对象”和“面向过程”有什么区别？&lt;/a&gt;&lt;p&gt;&lt;b&gt;永远。大家只是互相竖起远离实际的符号，互相实施稻草人謬誤。&lt;/b&gt;Ad hoc polymorphism跟module成为OO的专利（而前者在Algol 68就有了，后者pascal的作者也加入了modula里面）。而需要描述OO缺点的时候，则去称之为‘反模块化’。structural programming最初是为了解决complexity产生的，却称为会造成杂乱的代码。而函数式编程？大家都默认了ref，effect跟extensibility solution（final, row polymorphism, tagless）的不存在。。。&lt;/p&gt;&lt;p&gt;为什么我们不能改变一下呢？比如说，谈论subtyping，我们这样做：&lt;/p&gt;&lt;a href=&quot;https://www.zhihu.com/question/289974125&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;子类型（subtyping）是不是错误（ill-defined）的东西？&lt;/a&gt;&lt;a href=&quot;https://www.zhihu.com/question/57486254&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;subtyping和inheritance的区别是什么？&lt;/a&gt;&lt;a href=&quot;https://www.zhihu.com/question/53870767&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;程序语言设计界是否开始认为 Subtyping 是 Anti-pattern？&lt;/a&gt;&lt;p&gt;谈论mutability的时候，我们聊gedanken里面的三种variable设计：&lt;/p&gt;&lt;p&gt;假设声明了struct Point { int x, int y }，&lt;/p&gt;&lt;p&gt;0：identifier就是指针，所有Point的x跟y都共享，毫无意义（只有snobol这样做）&lt;/p&gt;&lt;p&gt;1：identifier绑定上指针，每一个Point内的x y都是可变的，无法控制mutability（C，Java）&lt;/p&gt;&lt;p&gt;2：identifier绑定上Value，然后有指针类型/值。如果需要任何的可变性，用Point*，然后update x通过构造新的point。然后通过sharing跟编译手段降低开销。（SML，OCaml，Haskell）&lt;/p&gt;&lt;p&gt;又或者，我们也可以谈论各种effect system（MTL，State，ST，IO，Extensible，跟语言内建的effect system）来讨论mutability。。。而不是，谈论到mutability，就只会&#39;immutability是大势所趋，implicit parallelism大法好&#39;，又或者&#39;immutable不符合计算机基本模型&#39;等myth。&lt;/p&gt;&lt;p&gt;&lt;b&gt;这样有啥坏处呢？为啥我们不这样做？我不知道。&lt;/b&gt;也许，这样我们就不能喊些看上去很酷的名字，就跟圣斗士不能喊天马流星拳一样。&lt;/p&gt;&lt;p&gt;唉。&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2018-08-25-42907876</guid>
<pubDate>Sat, 25 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>编程语言方向北美/欧洲相关的学校</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-08-19-42436557.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/42436557&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;偏analysis/ verification/ synthesis/ type等&lt;/p&gt;&lt;p&gt;北美：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;MIT: Armando Solar-Lezama, Martin Rinard, Adam Chlipala, etc&lt;/li&gt;&lt;li&gt;UW: Rastislav Bodik，Michael Ernst，Zachary Tatlock，Dan Grossman，Emina Torlak&lt;/li&gt;&lt;li&gt;CMU: Robert Harper, Edmund Clarke, Frank Pfenning, Karl Crary, Jan Hoffmann,  	Jonathan Aldrich, etc&lt;/li&gt;&lt;li&gt;Cornell: Dexter Kozen, Andrew Myers, Greg Morrisett,  Nate Foster,  etc.&lt;/li&gt;&lt;li&gt;UCSD: Ranjit Jhala&lt;/li&gt;&lt;li&gt;UCSC: Cormac Flanagan&lt;/li&gt;&lt;li&gt;UCSB:  Ben Hardekopf&lt;/li&gt;&lt;li&gt;UCLA: Jens Palsberg, Harry Xu&lt;/li&gt;&lt;li&gt;Tufts: Kathleen Fisher&lt;/li&gt;&lt;li&gt;Yale: Shao Zhong&lt;/li&gt;&lt;li&gt;NYU : Patrick Cousot, Thomas Wies&lt;/li&gt;&lt;li&gt;UT Austin: Isil Dillig, Kathryn S McKinley, Calvin Lin&lt;/li&gt;&lt;li&gt;Upenn: Benjamin Pirece, Rajeev Alur, Mayur Naik, Stephanie Weirich, etc&lt;/li&gt;&lt;li&gt;PSU: Danfeng Zhang&lt;/li&gt;&lt;li&gt;UIUC: Grigore Rosu, P. Madhusudan&lt;/li&gt;&lt;li&gt;Stanford: Zohar Manna, Alex Aiken, Clark Barrett, etc&lt;/li&gt;&lt;li&gt;WISC: Tom Reps, Somesh Jha, Ben Liblit, Aws Albarghouthi, Loris D&#39;Antoni&lt;/li&gt;&lt;li&gt;UMD: Jeff Foster，Mike Hick&lt;/li&gt;&lt;li&gt;Princeton :  Andrew Appel, Aarti Gupta, David Walker, Zak Kincard, etc&lt;/li&gt;&lt;li&gt;Purdue：Suresh Jagannathan&lt;/li&gt;&lt;li&gt;Northeast: Jan Vitek, Matt Felleisen, Frank Tip, Amal Ahmed ...&lt;/li&gt;&lt;li&gt;Utah: Matt Flatt&lt;/li&gt;&lt;li&gt;Harward：Stephen Chong&lt;/li&gt;&lt;li&gt;Rice: Swarat Chaudhuri&lt;/li&gt;&lt;li&gt;CU Boulder: Bor-Yuh Evan Chang, Sriram Sankaranarayanan&lt;/li&gt;&lt;li&gt;Microsoft Research Redmond: Tom Ball, Patrice Godefroid, Sumit Gulwani, Shuvendu Lahiri, Ken McMillan, Shaz Qadeer, Nikojaj Bjorner, Leonardo de Moura&lt;/li&gt;&lt;li&gt;SRI International: Susmit Jha, Natarajan Shankar&lt;/li&gt;&lt;li&gt;U Waterloo: Arie Gurfinkel, Ondrej Lhoták, Vijay Ganesh&lt;/li&gt;&lt;li&gt;UT： Azadeh Farzan&lt;/li&gt;&lt;li&gt;McGill: Brigitte Pientka&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;欧洲：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;MPI-SWS: Derek Dreyer, Rupak Majumdar, Viktor Vafeiadis&lt;/li&gt;&lt;li&gt;TU Munich: Javier Esparza, ‎Helmut Seidl&lt;/li&gt;&lt;li&gt;U of Freiburg: Peter Thiemann, Andreas Podelksi&lt;/li&gt;&lt;li&gt;LMU Munich: Dirk Beyer&lt;/li&gt;&lt;li&gt;IMEDA: Gilles Barthe, Roberto Giacobazzi&lt;/li&gt;&lt;li&gt;Oxford: Jeremy Gibbons, Samson Abramsky, Stefan Kiefer, Daniel Kroening, Luke Ong&lt;/li&gt;&lt;li&gt;Edinburgh: Gorden Plotkin, Andrew Gordon&lt;/li&gt;&lt;li&gt;Cambridge: Andrew Pitts, Alan Mycroft&lt;/li&gt;&lt;li&gt;UCL: Alexandra Silva, James Brotherston, Byron Cook&lt;/li&gt;&lt;li&gt;U of Kent: Andy King&lt;/li&gt;&lt;li&gt;EPFL: Martin Ordersky, Viktor Kuncak&lt;/li&gt;&lt;li&gt;ETH: Martin Vechev, Peter Muller&lt;/li&gt;&lt;li&gt;Arahus: Anders Møller,  Lars Birkedal&lt;/li&gt;&lt;li&gt;Arthens: Yannis Smaragdakis&lt;/li&gt;&lt;li&gt;Chalmers: Laura Kovács, Thierry Coquand&lt;/li&gt;&lt;li&gt;INRIA: Xavier Leroy&lt;/li&gt;&lt;li&gt;CNRS: Antoine Mine&lt;/li&gt;&lt;li&gt;Tel Aviv: Mooly Sagiv, Ori Lahav&lt;/li&gt;&lt;li&gt;Technion: Evan Yahav&lt;/li&gt;&lt;/ul&gt;</description>
<author>rainoftime</author>
<guid isPermaLink="false">2018-08-19-42436557</guid>
<pubDate>Sun, 19 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Recursion Schemes（二）Morphism军团</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-08-18-42352830.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/42352830&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0fc7e6a4d32be72240441e4a84bde5c4_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;引言&lt;/h2&gt;&lt;p&gt;上一章中，我们讨论了如何表示和遍历一个嵌套结构体，而这只是 &lt;a href=&quot;http://maartenfokkinga.github.io/utwente/mmf91m.pdf&quot;&gt;Programming with Bananas, Lenses, Envelopes, and Barbed Wire&lt;/a&gt; 一文的冰山一角而已，本章我们将讨论两种简单的 Recursion Scheme 以及它们的关系[1]。&lt;/p&gt;&lt;p&gt;首先我们沿用上一章中使用的语法树，文章中的所有代码实现可以在&lt;a href=&quot;https://github.com/patrickt/recschemes/blob/master/src/Part2.hs&quot;&gt;这里&lt;/a&gt;找到。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;{-# LANGUAGE DeriveFunctor #-}

data Expr a  
  = Literal { intVal :: Int }
  | Ident   { name :: String  }
  | Index   { target :: a, idx :: a }
  | Unary   { op :: String, target :: a }
  | Binary  { lhs :: a, op :: String, rhs :: a }
  | Call    { func :: a, args :: [a] }
  | Paren   { target :: a }
  deriving (Show, Eq, Functor)&lt;/code&gt;&lt;p&gt;表达式有两种叶子节点形式 &lt;code class=&quot;inline&quot;&gt;Literal&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Ident&lt;/code&gt; 同时包含函数的声明和调用，一元和二元运算等[2]。我们使用 &lt;code class=&quot;inline&quot;&gt;DeriveFunctor&lt;/code&gt; 使 GHC 帮助我们推导定义了 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt; 会递归地将函数 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 应用到子表达式上，直到叶节点为止。&lt;/p&gt;&lt;p&gt;上一章中，我们将叶子节点的表达式记为 &lt;code class=&quot;inline&quot;&gt;Expr ()&lt;/code&gt;，而包含一层的子表达式的表达式记为 &lt;code class=&quot;inline&quot;&gt;Expr (Expr ())&lt;/code&gt;, 以此类推。但 Haskell 并不支持无限类型，所以我们使用一个最小不动点组合子 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 通过 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Out&lt;/code&gt; 完成构造和解析。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Term f = In { out :: f (Term f) }&lt;/code&gt;&lt;p&gt;从而我们可以使用 &lt;code class=&quot;inline&quot;&gt;Term Expr&lt;/code&gt; 用 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 来构造任意嵌套多层的数据结构[3]：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;ten, add, call :: Term Expr  
ten  = In (Literal { intVal = 10 })  
add  = In (Ident { name = &quot;add&quot; })  
call = In (Call { func = add, args = [ten, ten]}) -- add(10, 10)&lt;/code&gt;&lt;p&gt;接着使用 &lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 操作符我们形象地表达了自底向上遍历任何实现了 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt; 的类型的操作。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;bottomUp :: Functor a =&amp;gt; (Term a -&amp;gt; Term a) -&amp;gt; Term a -&amp;gt; Term a  
bottomUp fn =  
  out                    -- 1) 将 `Term a` 解析为 `a (Term a)`
  &amp;gt;&amp;gt;&amp;gt; fmap (bottomUp fn) -- 2) 递归地对子项应用 fn
  &amp;gt;&amp;gt;&amp;gt; In                 -- 3) 将 `a (Term a)` 封装回 `Term a`
  &amp;gt;&amp;gt;&amp;gt; fn                 -- 4) 对 `Term a` 应用 fn&lt;/code&gt;&lt;p&gt;虽然这一过程十分优雅，但是其表达能力还是很弱的，比如说 &lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt; 的输入输出都必须为 &lt;code class=&quot;inline&quot;&gt;Term f&lt;/code&gt; 我们不能使用 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt; 来做表达式计数（ &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt;  转换为 &lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt;），或者将其转换为一个 DOM 树（ &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt;  转换为 &lt;code class=&quot;inline&quot;&gt;Node&lt;/code&gt;），或者将它打印出来（ &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt;  转换为 &lt;code class=&quot;inline&quot;&gt;Doc&lt;/code&gt;）等操作。&lt;/p&gt;&lt;p&gt;这是由于上面第三步 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 的输出是 &lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt; 的输入，而 &lt;code class=&quot;inline&quot;&gt;fmap (bottomUp fn)&lt;/code&gt; 的输出又是 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 的输入，这导致了 &lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt; 的输入和输出值必须是 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt;。如果我们去除 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt;，那么这样还能通过类型检查吗？&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;mystery fn =  
  out                   -- 1) 解析 Term
  &amp;gt;&amp;gt;&amp;gt; fmap (mystery fn) -- 2) 递归应用 `fn`
  &amp;gt;&amp;gt;&amp;gt; fn                -- 3) 应用 `fn`&lt;/code&gt;&lt;p&gt;竟然可以的！我们是用 &lt;code class=&quot;inline&quot;&gt;ghci&lt;/code&gt; 来看下类型：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;λ&amp;gt; :t mystery  
mystery :: Functor f =&amp;gt; (f a -&amp;gt; a) -&amp;gt; Term f -&amp;gt; a&lt;/code&gt;&lt;p&gt;好吧，这又是什么鬼？&lt;/p&gt;&lt;h2&gt;Algebra&lt;/h2&gt;&lt;p&gt;我们仔细观察一下它的参数&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;Functor f =&amp;gt; (f a -&amp;gt; a)&lt;/code&gt;&lt;p&gt;它是一个函数，接受一个装在容器[4] &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 中的类型 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 并返回类型 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 如果我们想做节点计数，显然 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 应该是一个 &lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt; 类型，而 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 则是 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 类型。于是我们有：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;countNodes :: Expr Int -&amp;gt; Int&lt;/code&gt;&lt;p&gt;我们在转换的过程中，使用 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 捕捉了其本身需要的属性信息，并依据递归结构向上传递，这意味着对于 &lt;code class=&quot;inline&quot;&gt;countNodes&lt;/code&gt; 这样的函数，我们只需要在子表达式的基础上加 1 即可：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;countNodes (Unary _ arg)         = arg + 1  
countNodes (Binary left _ right) = left + right + 1  
countNodes (Call fn args)        = fn + sum args + 1  
countNodes (Index it idx)        = it + idx + 1  
countNodes (Paren arg)           = arg + 1&lt;/code&gt;&lt;p&gt;而对于递归出口的叶子节点，我们只需要简单返回 1 即可：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;countNodes (Literal _) = 1  
countNodes (Ident   _) = 1&lt;/code&gt;&lt;p&gt;如果我们对 &lt;code class=&quot;inline&quot;&gt;add(10, 10)&lt;/code&gt; 使用 &lt;code class=&quot;inline&quot;&gt;mystery countNodes&lt;/code&gt; 应该得到 4，那么结果如何呢？&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;λ&amp;gt; mystery countNodes call  
4&lt;/code&gt;&lt;p&gt;确实得到了期望的结果。&lt;/p&gt;&lt;p&gt;注意 &lt;code class=&quot;inline&quot;&gt;mystery&lt;/code&gt; 中的 &lt;code class=&quot;inline&quot;&gt;fmap (mystery fn)&lt;/code&gt; 正是这个语句对所有的子表达式完成了递归操作，同时在叶子节点时达到了递归出口，并开始将原结构体内的数据转化为新计算得出的属性，并向上传递。所以通过 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt; 以及表达式定义，我们就非常简单地实现了对一个嵌套数据结构的操作。&lt;/p&gt;&lt;p&gt;由于 &lt;code class=&quot;inline&quot;&gt;f a -&amp;gt; a&lt;/code&gt; 这一操作的普遍性，我们命名：  &lt;code class=&quot;inline&quot;&gt;Haskell  type Algebra f a = f a -&amp;gt; a&lt;/code&gt;&lt;/p&gt;&lt;p&gt;所以我们重写一下 &lt;code class=&quot;inline&quot;&gt;countNodes&lt;/code&gt; 函数：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;countNodes :: Algebra Expr Int&lt;/code&gt;&lt;p&gt;这里我们使用的 “Algebra” 并不是一般意义上代数的意思，从词源学的角度上分析，它来自阿拉伯语的词根，   ，代表重组，团聚，整修的意思，正如 Algebra 函数将一个个在容器中的 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 即 &lt;code class=&quot;inline&quot;&gt;f a&lt;/code&gt; “重组”为一个单一累积的 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;Catamorphism&lt;/h2&gt;&lt;p&gt;我们使用 Algebra 重新一下 &lt;code class=&quot;inline&quot;&gt;mystery&lt;/code&gt; 函数：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;mystery :: (Functor f) =&amp;gt; Algebra f a -&amp;gt; Term f -&amp;gt; a&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;mystery&lt;/code&gt; 实际上就是 &lt;i&gt;catamorphism&lt;/i&gt;，简称为 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;cata :: (Functor f) =&amp;gt; Algebra f a -&amp;gt; Term f -&amp;gt; a  
cata f = out &amp;gt;&amp;gt;&amp;gt; fmap (cata f) &amp;gt;&amp;gt;&amp;gt; f&lt;/code&gt;&lt;p&gt;“cata” 作为 “catamorphism” 的前缀，表达的意义和在 “catastrophe”，“catabolism”，“catalyst” 中一样，它来源于希腊语 κατα，代表向下，向里，解析等意思。正如 catastrophe 代表不幸摧毁了事物，而 catabolism 表示肌肉纤维分解，catamorphism 表示了 Algebra 将一堆容器中值摧毁，变成了一个单一的值。&lt;/p&gt;&lt;p&gt;考虑 &lt;code class=&quot;inline&quot;&gt;foldr&lt;/code&gt; 操作，实际上 &lt;code class=&quot;inline&quot;&gt;foldr&lt;/code&gt; 就是一个限制在列表上的 catamorphism，这是因为 &lt;code class=&quot;inline&quot;&gt;[]&lt;/code&gt; 就是一个实例化了的 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt;，换句话说，catamorphism 可以被认为是 &lt;code class=&quot;inline&quot;&gt;foldr&lt;/code&gt; 操作在其它 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt; 上的泛化  [5]，它们都不需要写任何遍历规则，同时保持着类型安全。&lt;/p&gt;&lt;p&gt;我们再来看一个文档展示的例子，一个文档实际上是一个 从 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 到 &lt;code class=&quot;inline&quot;&gt;Doc&lt;/code&gt; 的 Algebra，其中 &lt;code class=&quot;inline&quot;&gt;Doc&lt;/code&gt; 在 &lt;a href=&quot;https://hackage.haskell.org/package/pretty-1.1.1.0/docs/Text-PrettyPrint.html&quot;&gt;Text.PrettyPrint&lt;/a&gt; 模块中定义。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;import Text.PrettyPrint (Doc)  
import qualified Text.PrettyPrint as P

prettyPrint :: Algebra Expr Doc&lt;/code&gt;&lt;p&gt;这里 Algebra 需要定义如何将一个子表达式已经是 &lt;code class=&quot;inline&quot;&gt;Doc&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 变成 &lt;code class=&quot;inline&quot;&gt;Doc&lt;/code&gt;，首先是叶子节点：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;prettyPrint (Literal i) = P.int i  
prettyPrint (Ident s) = P.text s&lt;/code&gt;&lt;p&gt;向上递归的部分也同样整洁：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;-- f(a,b...)  
prettyPrint (Call f as)     = f &amp;lt;&amp;gt; P.parens (P.cat (P.punctuate &quot;, &quot; as))  
-- a[b]
prettyPrint (Index it idx)  = it &amp;lt;&amp;gt; P.brackets idx  
-- op x
prettyPrint (Unary op it)   = P.text op &amp;lt;&amp;gt; it  
-- lhs op rhs
prettyPrint (Binary l op r) = l &amp;lt;&amp;gt; P.text op &amp;lt;&amp;gt; r  
-- (op)
prettyPrint (Paren exp)     = P.parens exp&lt;/code&gt;&lt;p&gt;我们将 &lt;code class=&quot;inline&quot;&gt;prettyPrint&lt;/code&gt; 应用到 &lt;code class=&quot;inline&quot;&gt;call&lt;/code&gt; 上：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;λ&amp;gt; cata prettyPrint call  
add(10,10)&lt;/code&gt;&lt;p&gt;最后一个例子是我们将使用 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 来表示 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt; 实际上，对于 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 来说，&lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt; 只需要我们先对输入应用 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 即可：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;bottomUp f = cata (In &amp;gt;&amp;gt;&amp;gt; f)&lt;/code&gt;&lt;h2&gt;Anamorphism&lt;/h2&gt;&lt;p&gt;上一篇专栏中，我们使用了“翻转箭头”的技巧构造了 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt; 的对偶方法 &lt;code class=&quot;inline&quot;&gt;topDown&lt;/code&gt;，我们将 &lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 翻转为 &lt;code class=&quot;inline&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; 将 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt; 互换了位置：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;bottomUp f = out &amp;gt;&amp;gt;&amp;gt; fmap (bottomUp f) &amp;gt;&amp;gt;&amp;gt; In  &amp;gt;&amp;gt;&amp;gt; f  
topDown  f = In  &amp;lt;&amp;lt;&amp;lt; fmap (topDown  f) &amp;lt;&amp;lt;&amp;lt; out &amp;lt;&amp;lt;&amp;lt; f&lt;/code&gt;&lt;p&gt;如果我们将同样的技巧应用在 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 上，会发生什么呢？&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;cata f = out &amp;gt;&amp;gt;&amp;gt; fmap (cata f) &amp;gt;&amp;gt;&amp;gt; f

-- 翻转箭头： &amp;gt;&amp;gt;&amp;gt; 变为 &amp;lt;&amp;lt;&amp;lt;， out 变为 In

what f = In &amp;lt;&amp;lt;&amp;lt; fmap (what f) &amp;lt;&amp;lt;&amp;lt; f&lt;/code&gt;&lt;p&gt;你的直觉是正确的，这是一个合法的函数，那么它的类型是什么呢？&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;what :: (Functor f) =&amp;gt; (a -&amp;gt; f a) -&amp;gt; a -&amp;gt; Term f&lt;/code&gt;&lt;p&gt;正如自底向下和自顶向上这组对偶关系一样，我们得到了 fold 操作的对偶形式 unfold 的泛化形式。我们仔细看一下第一个参数：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;Functor f =&amp;gt; (a -&amp;gt; f a)&lt;/code&gt;&lt;p&gt;完全就是 Algebra 的对偶形式，我们将它称为 Coalgebra。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Coalgebra f a = a -&amp;gt; f a&lt;/code&gt;&lt;p&gt;同理，&lt;code class=&quot;inline&quot;&gt;what&lt;/code&gt; 被称为 anamorphism，其中的 “ana” 前缀正是 “cata” 的反义词，代表构建的意义，正如 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 泛化了 &lt;code class=&quot;inline&quot;&gt;fold&lt;/code&gt; 操作，&lt;code class=&quot;inline&quot;&gt;ana&lt;/code&gt; 泛化了 &lt;code class=&quot;inline&quot;&gt;unfold&lt;/code&gt; 操作。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;ana :: (Functor f) =&amp;gt; Coalgebra f a -&amp;gt; a -&amp;gt; Term f  
ana f = In &amp;lt;&amp;lt;&amp;lt; fmap (ana f) &amp;lt;&amp;lt;&amp;lt; f&lt;/code&gt;&lt;p&gt;如果说 Algebra 带有重组，团聚的意味，那么 Coalgebra 就是拆解，分解的意思。它利用一个单一的值 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，构建容器 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;，如果 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 是 &lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt;，那么就可以构建一个含有或不含有值的容器，如果是 &lt;code class=&quot;inline&quot;&gt;[]&lt;/code&gt;，那么就会构建一个可能为空的列表。（对于那些敏锐的类型专家来说，你们可能已经发现了 &lt;code class=&quot;inline&quot;&gt;Algebra&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Coalgebra&lt;/code&gt; 实际上和 &lt;code class=&quot;inline&quot;&gt;Pointed&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Copointed&lt;/code&gt; 非常相似）&lt;/p&gt;&lt;h2&gt;并没有很难，对吧？&lt;/h2&gt;&lt;p&gt;我要感谢 Rob Rix 对我的支持。&lt;/p&gt;&lt;p&gt;同样欢迎大家给我任何评论，不论是意见或者建议。&lt;/p&gt;&lt;p&gt;下一章中，我们将讨论 catamorphism 的局限性，并介绍更加泛化的 paramorphism 和 apomorphism。&lt;/p&gt;&lt;h2&gt;译者后记&lt;/h2&gt;&lt;p&gt;本章的原文链接 &lt;a href=&quot;https://blog.sumtypeofway.com/recursion-schemes-part-2/#fnref5&quot;&gt;Recursion Schemes, Part II: A Mob of Morphisms&lt;/a&gt;，自本章开始，我尝试在翻译时对原文进行了一些精简，以使文章聚焦在干货部分，而且更加贴合中文习惯。同样有什么翻译上的意见或建议可以给我留言，如果有哪里翻译不到位或者文章本身不明白的地方也欢迎给我留言，大家一起讨论。&lt;/p&gt;&lt;p&gt;谢谢大家的耐心阅读！&lt;/p&gt;&lt;p&gt;[1]: 原论文的前2页内容。&lt;/p&gt;&lt;p&gt;[2]: 换句话说，&lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 定义了类型类 &lt;code class=&quot;inline&quot;&gt;* -&amp;gt; *&lt;/code&gt;。 &lt;/p&gt;&lt;p&gt;[3]: &lt;a href=&quot;https://hackage.haskell.org/package/compdata&quot;&gt;compdata&lt;/a&gt; 等函数包实际上提供了隐藏 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 构造器的方法，给定 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 的定义，我们可以使用 &lt;code class=&quot;inline&quot;&gt;smartConstructors&lt;/code&gt; 来生成 &lt;code class=&quot;inline&quot;&gt;iLiteral&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;iIdent&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;iUnary&lt;/code&gt; 等方法。每一个提供了不动点组合子 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 与对应 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 构造器的组合函数。 &lt;/p&gt;&lt;p&gt;[4]: 一些咬文嚼字的读者可能会注意到“容器”这个词其实并不贴切，函子其实具有更宽泛的范围，实际上 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 是一个 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 的可计算上下文，这里我们姑且称为“容器”。 &lt;/p&gt;&lt;p&gt;[5]: 可能有些好奇的读者会问，如果说 catamorphism 是 &lt;code class=&quot;inline&quot;&gt;foldr&lt;/code&gt; 的一种泛化，那么 &lt;code class=&quot;inline&quot;&gt;foldl&lt;/code&gt; 相应的泛化是什么呢？这个问题很有趣，因为实际上 &lt;code class=&quot;inline&quot;&gt;foldl&lt;/code&gt; 可以被 &lt;code class=&quot;inline&quot;&gt;foldr&lt;/code&gt; 表示，参见 &lt;a href=&quot;http://okmij.org/ftp/Haskell/AlgorithmsH1.html#foldl&quot;&gt;Oleg demonstrates&lt;/a&gt;。 &lt;/p&gt;</description>
<author>禾木旁</author>
<guid isPermaLink="false">2018-08-18-42352830</guid>
<pubDate>Sat, 18 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Recursion Schemes（一）新手入门</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-08-10-41754330.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41754330&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e5a2a9858bfa0c0e317c6943a84edb5b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;序章&lt;/h2&gt;&lt;p&gt;时间回到1991年，Erik Meijer， Maarten Fokkinga， 和 Ross Paterson 发表了一篇论文，&lt;a href=&quot;http://maartenfokkinga.github.io/utwente/mmf91m.pdf&quot;&gt;Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire&lt;/a&gt; 这篇论文在即使在今天看来仍是函数式编程领域的经典之作。尽管在函数式编程社区之外，这篇论文并不广为人知，但它的贡献仍然是巨大的：作者使用范畴论表达了一组被称为 Recursion Schemes 的简洁组合子。使用这组组合子，可以自动化地完成嵌套式数据结构的递归遍历。尽管 Recursion Schemes 的提出早于 Erik Meijer 等人的工作，这篇文章将范畴论中的强大抽象能力应用于遍历数据结构这一主题——这正是范畴论如何使我们日常编程任务变得简洁而富有秩序的一个有力例证。&lt;/p&gt;&lt;p&gt;嵌套式数据结构几乎出现在每一个编程领域中，从3D绘图到文件系统，遍历这样的数据结构是非常常见的，常见到程序员们几乎感知不到他们做了这件事。因此，泛化递归和遍历这一动作几乎立即就可以为真实世界带来好处：使用新的泛化的遍历模式取代掉那些旧的依赖于类型的遍历函数。而且通过将如何遍历数据和如何使用数据解耦，可以减轻程序员们的对代码的理解负担，而更专注于如何使用数据这一核心行为。无论怎样的数据结构，链表，目录树，控制流图还是数据库表项，使用 Recursion Schemes 都可以准确有序地遍历它们。而且 Recursion Schemes 并不依赖与编程语言或编程环境——任何将函数作为一等公民的语言都可以使用 Recursion Schemes，例如 Clojure 的 &lt;a href=&quot;http://richhickey.github.io/clojure/clojure.walk-api.html&quot;&gt;clojure.walk&lt;/a&gt; API 就广泛使用了 Recursion Schemes 来遍历 s-expression 和 map。&lt;/p&gt;&lt;p&gt;实际上 Meijer 等人的工作非常成功，以至于基本上可以说函数式编程缺少 Recursion Schemes 就等于在命令式编程中使用 &lt;code class=&quot;inline&quot;&gt;goto&lt;/code&gt;。仅管这里引用 Djikstra 写给 ACM 的&lt;a href=&quot;http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html&quot;&gt;那封广为人知的信&lt;/a&gt;不免有些陈词滥调，但是这个比喻是恰当的：只使用 &lt;code class=&quot;inline&quot;&gt;for&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;while&lt;/code&gt; 而不使用 &lt;code class=&quot;inline&quot;&gt;goto&lt;/code&gt; 使得命令式语言的控制流和谐简洁，对于函数式语言，使用 Recursion Schemes 而非为对数据结构手写递归计算，带来了相似的效果。这一见解非常深刻，以至于我要再重复一遍：&lt;i&gt;Recursion Schemes 之于函数式编程范式，就如同 &lt;code class=&quot;inline&quot;&gt;for&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;while&lt;/code&gt; 之于命令式编程范式。&lt;/i&gt;&lt;/p&gt;&lt;p&gt;尽管 &lt;i&gt;Bananas, Lenses, Envelopes and Barbed Wire&lt;/i&gt; 论文发表时间远早于 Haskell 语言的诞生时间，本文仍选择使用 Haskell 作为编程语言来展示文中背后的想法[1]。如果你并不十分熟悉 Haskell， &lt;i&gt;&lt;b&gt;别慌：&lt;/b&gt;&lt;/i&gt; 理解本文的思想不需要您成为一个 Haskell 专家。我实际上只用到了 Haskell 的&lt;a href=&quot;http://cheatsheet.codeslower.com/CheatSheet.pdf&quot;&gt;语法&lt;/a&gt;以及 &lt;a href=&quot;http://learnyouahaskell.com/making-our-own-types-and-typeclasses&quot;&gt;algebraic data types&lt;/a&gt;。我会使用一些语法特性来更好地展示 Recursion Schemes 背后的思想，在我使用这些语法特性的时候，我都会解释一下它们的作用。如果您之前完全没有 Haskell 的使用经验，或许阅读 &lt;a href=&quot;http://learnyouahaskell.com/&quot;&gt;Learn You a Haskell&lt;/a&gt; 的前几章的内容有助于您理解本文。&lt;/p&gt;&lt;p&gt;本文的例子会从一个简单的类型完备的语法树的定义开始，接着我会展示在这样一颗语法树上进行泛化遍历和修改树结构是相当困难的。接着我们会使用 Haskell 的语法特性以及强大的 parameterized data types 来重新定义语法树，而就在我们使用常见的 Haskell 语法一步步定义和描述递归模式的过程中，Recursion Schemes 自然而然地就会被导出。&lt;/p&gt;&lt;p&gt;如果你对本文中使用的代码感兴趣，你可以在这个 &lt;a href=&quot;https://github.com/patrickt/recschemes/blob/master/src/Part1.hs&quot;&gt;Github 仓库&lt;/a&gt; 中找到对应的代码。代码中还包括一组单元测试以用来验证代码的正确性。&lt;/p&gt;&lt;h2&gt;递归的语法树&lt;/h2&gt;&lt;p&gt;我们首先来看一下在 Haskell 中使用 algebraic datatype 来最简单地表达一个语法树应该怎样做。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Lit  
  = StrLit String
  | IntLit Int
  | Ident String
  deriving (Show, Eq)

data Expr  
  = Index Expr Expr
  | Call Expr [Expr]
  | Unary String Expr
  | Binary Expr String Expr
  | Paren Expr
  | Literal Lit
  deriving (Show, Eq)

data Stmt  
  = Break 
  | Continue
  | Empty
  | IfElse Expr [Stmt] [Stmt]
  | Return (Maybe Expr)
  | While Expr [Stmt]
  | Expression Expr
  deriving (Show, Eq)&lt;/code&gt;&lt;p&gt;可以看到这已经是一个相当不错的语法树了：它简单直白，可以直接应用在一些语法树解析库上，例如 &lt;a href=&quot;http://hackage.haskell.org/package/attoparsec&quot;&gt;attoparsec&lt;/a&gt; 或 &lt;a href=&quot;http://tanakh.github.io/Peggy/&quot;&gt;Peggy&lt;/a&gt;。然而为这样的一棵语法树写一个操作子节点和子表达式的函数是一件非常乏味的工作。下面是一个例子，flatten 函数接受一棵语法树，并递归地删除其所有的代表括号的 &lt;code class=&quot;inline&quot;&gt;Paren&lt;/code&gt; 节点：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;-- this would turn the expression  
--    (((anArray[(10)])))
-- into
--    anArray[10]

flatten :: Expr -&amp;gt; Expr  
-- base case: do nothing to literals
flatten (Literal i) = Literal i

-- this is the important case: we shed the Paren constructor and just 
-- apply `flatten` to its contents
flatten (Paren e) = flatten e

-- all the other cases preserve their constructors and just apply 
-- the flatten function to their children that are of type `Expr`.
flatten (Index e i)     = Index (flatten e) (flatten i)  
flatten (Call e args)   = Call (flatten e) (map flatten args)  
flatten (Unary op arg)  = Unary op (flatten arg)  
flatten (Binary l op r) = Binary (flatten l) op (flatten r)&lt;/code&gt;&lt;p&gt;可以看到这段代码难以忍受地丑陋，并且难以维护。6行代码中的4行代码实际上在完成一件非常无聊但又不得不做的工作，确保 &lt;code class=&quot;inline&quot;&gt;flatten&lt;/code&gt; 函数在可以正确地在子表达式下递归下去。这样的代码不仅书写十分无趣，而且之后对&lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt;的任何改变（例如增加了新的域或语法关键字）都必须修改这个函数。（我把这种递归行为称为&lt;i&gt;显式递归&lt;/i&gt;，以与 Recursion Schemes 提供的&lt;i&gt;隐式递归&lt;/i&gt;进行区别）而且，这样的定义方式极易出错——显式递归引入的语法噪音使得检查是否有子表达式遗漏变得非常困难。而这样的疏漏就有可能引入灾难性的 bug。&lt;/p&gt;&lt;p&gt;我们可以使用 &lt;code class=&quot;inline&quot;&gt;apply&lt;/code&gt; 函数为这段混乱的代码带来些许秩序，它接受一个以 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 为参数的函数 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 并应用这个函数操作 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 和它所有的子表达式：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;applyExpr :: (Expr -&amp;gt; Expr) -&amp;gt; Expr -&amp;gt; Expr  
-- base case: applyExpr is the identity function on constants
applyExpr f (Literal i) = Literal i

-- recursive cases: apply f to each subexpression
applyExpr f (Paren p) = Paren (f p)  
applyExpr f (Index e i) = Index (f e) (f i)  
applyExpr f (Call e args) = Call (f e) (map f args)  
applyExpr f (Unary op arg) = Unary op (f arg)  
applyExpr f (Binary l op r) = Binary (f l) op (f r)&lt;/code&gt;&lt;p&gt;通过隔离递归这一操作，我们可以将 &lt;code class=&quot;inline&quot;&gt;flatten&lt;/code&gt; 函数从6行减为2行，在 &lt;code class=&quot;inline&quot;&gt;flatten&lt;/code&gt; 函数内部，我们只需要关注 &lt;code class=&quot;inline&quot;&gt;Paren&lt;/code&gt; 节点即可，而将其他节点上的递归操作交给 &lt;code class=&quot;inline&quot;&gt;applyExpr&lt;/code&gt; 函数即可：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;flatten (Paren e) = flatten e  
flatten x = applyExpr flatten x&lt;/code&gt;&lt;p&gt;这使得我们可以非常方便地书写和维护一段代码了。&lt;code class=&quot;inline&quot;&gt;apply&lt;/code&gt; 函数将负责所有平凡情况的处理，并且完成在子表达式上的递归，而我们写的函数只需要负责那些我们感兴趣的部分即可，例如，处理 &lt;code class=&quot;inline&quot;&gt;Paren&lt;/code&gt; 节点，&lt;i&gt;酷！&lt;/i&gt;&lt;/p&gt;&lt;p&gt;但我们暂且不要高兴得太早，实际上我们并没有杜绝模板文件，这里仍有出现 bug 的可能：&lt;code class=&quot;inline&quot;&gt;applyExpr&lt;/code&gt; 仅仅只是隔离了模板与内容，每当我们定义了新的语法或类型，我们都需要重写 &lt;code class=&quot;inline&quot;&gt;applyExpr&lt;/code&gt; 函数。但实际上一个异常聪明的编译器，例如 GHC，可以帮助我们完成这件事。不过首先我们需要对 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 数据类型进行适当的修改，以使其具有更加泛化的表达能力。&lt;/p&gt;&lt;h2&gt;参数化类型&lt;/h2&gt;&lt;code lang=&quot;haskell&quot;&gt;data Expr a  
  = Index a a
  | Call a [a]
  | Unary String a
  | Binary a String a
  | Paren a
  | Literal Lit
  deriving (Show, Eq)&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 的新定义与我们之前的完全相同，除了我们加入了一个类型变量 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 并且用它将所有递归出现的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 替换掉。换句话来说，我们对 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 的子表达式完成了&lt;i&gt;参数化&lt;/i&gt;。因此我们也需要修改 &lt;code class=&quot;inline&quot;&gt;applyExpr&lt;/code&gt;：我们向下层的函数类型不再是 &lt;code class=&quot;inline&quot;&gt;Expr -&amp;gt; Expr&lt;/code&gt; 而变为了 &lt;code class=&quot;inline&quot;&gt;a -&amp;gt; a&lt;/code&gt;：实际上我们甚至可以定义为 &lt;code class=&quot;inline&quot;&gt;a -&amp;gt; b&lt;/code&gt;，这样输入函数就具备了改变底层 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 的底层子表达式的能力。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;apply :: (a -&amp;gt; b) -&amp;gt; Expr a -&amp;gt; Expr b&lt;/code&gt;&lt;p&gt;敏锐的读者已经察觉到了这个函数与内置与 &lt;code class=&quot;inline&quot;&gt;list&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt; 函数多么相似：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;-- `map` takes a function (a -&amp;gt; b) and makes it operate on lists containing &#39;a&#39;s  
map :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]&lt;/code&gt;&lt;p&gt;这并不是一个巧合，实际上 &lt;code class=&quot;inline&quot;&gt;apply&lt;/code&gt; 函数就是和 &lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt; 同构的——你可以将这两个函数都看作将函数 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 提升并应用于更大的数据类型上，这个更大的数据类型可以是 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 也可以是列表(&lt;code class=&quot;inline&quot;&gt;[]&lt;/code&gt;)。而这种映射的模式实际上在 Haskell 中十分常见，以至于它的泛化版本正是 Haskell 中的一个核心概念：类型类 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt; 代表了所有的能提供类似映射功能的函数，称作 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;[2]:&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class Functor f where  
  fmap :: Functor f =&amp;gt; (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&lt;/code&gt;&lt;p&gt;无数的类型——列表，树，可选值（&lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt;），IO 操作，甚至于函数本身，都实现了 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt; 类型类。实际上由于这个函数如此常见，而实现 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt; 又非常直白，GHC 提供了一个内置的机制来帮你实现 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;：我们只需要将 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt; 加入 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 的推导声明中，就跟 &lt;code class=&quot;inline&quot;&gt;Show&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Eq&lt;/code&gt; 一样：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;{-# LANGUAGE DeriveFunctor #-}

data Expr a  
  = Index a a
  | Call [a]
  | Unary String a
  | Binary a String a
  | Paren a
  | Literal Lit
  deriving (Show, Eq, Functor) -- fmap for free&lt;/code&gt;&lt;p&gt;甚至于说，你可以导出 &lt;code class=&quot;inline&quot;&gt;Foldable&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Traversable&lt;/code&gt; 这些类型类，这为我们访问和遍历 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 提供了丰富的手段，在我们为 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;Foldable&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Traversable&lt;/code&gt; 所提供的丰富功能震惊时，也必须要注意到，现在的参数化版本 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 其实和我们之前的版本并不完全一样！&lt;/p&gt;&lt;p&gt;我们之前版本的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 因为在子节点上是递归的，所以我们可以表达任意嵌套的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt;，但我们的新版本定义做不到这一点。一个任意嵌套的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt;，我们在叶子节点使用 &lt;code class=&quot;inline&quot;&gt;Lit&lt;/code&gt; :&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Expr Lit&lt;/code&gt; 表示一个没有子表达式的表达式&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Expr (Expr Lit)&lt;/code&gt; 表示一个含有一层子表达式的表达式&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Expr (Expr (Expr Lit))&lt;/code&gt; 表示一个含有两层的，以此类推&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为了使我们的参数化版本定义的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 具备这种特性，我们需要一种类型，这种类型可以在当我们确定 &lt;code class=&quot;inline&quot;&gt;Expr a&lt;/code&gt; 中的 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 类型时，得到一个嵌套任意多层 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 子表达式的类型。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type NestedExpr = Expr (Expr (Expr (Expr …)))&lt;/code&gt;&lt;p&gt;为了得到这种类型，我们需要一些技巧，使我们可以用有限长的语句，构造任意多层嵌套类型的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;不动点&lt;/h2&gt;&lt;p&gt;考虑一个 Y-组合子，给定一个输入为一个参数的函数 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;y(f)&lt;/code&gt; 实际上就表示了不断将 f 应用在自己本身上：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;y(f) = f(f(f(f(f ...))))&lt;/code&gt;&lt;p&gt;敏锐的读者们想必已经察觉 &lt;code class=&quot;inline&quot;&gt;y(f)&lt;/code&gt; 的形式与我们所需要的 &lt;code class=&quot;inline&quot;&gt;NestedExpr&lt;/code&gt; 的形式非常相似，如果我们把一个 Y-组合子整合进类型系统的话，我们就可以描述 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 不断应用于自己这样的形式了，而整合的过程只需保持与在值域上作用于函数的 Y-组合子的同构即可。这样我们就可以描述任意嵌套的表达式 &lt;code class=&quot;inline&quot;&gt;Expr a&lt;/code&gt; 了，其中 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 代表任意嵌套的表达式 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Y t = t (t (t (t (t ...))))&lt;/code&gt;&lt;p&gt;实际上这就是不动点[3]的定义：我们称 &lt;code class=&quot;inline&quot;&gt;y(f)&lt;/code&gt; 是函数 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 的一个不动点，而 &lt;code class=&quot;inline&quot;&gt;Y Expr&lt;/code&gt; 就是函子 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 的一个&lt;i&gt;不动点&lt;/i&gt;。而关键性的一点在于，我们可以在类型系统中构建 Y-组合子，这样就可以表示 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 和其子表达式间相似这一本质特征。&lt;/p&gt;&lt;p&gt;我们需要一个类型 &lt;code class=&quot;inline&quot;&gt;Y&lt;/code&gt;，它接受另一个类型 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;，它将 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 应用到类型为 (Y f) 的子节点上，我们定义这样的 &lt;code class=&quot;inline&quot;&gt;Y&lt;/code&gt; 类型为 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt;，而它的构造函数为 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt;，表示我们将一层的递归变成了固定形式，接着我们定义 &lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt; 函数来辅助解析 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Term f = In (f (Term f))

out :: Term f -&amp;gt; f (Term f)  
out (In t) = t&lt;/code&gt;&lt;p&gt;接着我们非常自然地应用 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 到 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 上：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;Term Expr = In (Expr (Term Expr))

out :: Term Expr -&amp;gt; Expr (Term Expr)&lt;/code&gt;&lt;p&gt;从这个定义我们可以看到，给定一个 &lt;code class=&quot;inline&quot;&gt;Term Expr&lt;/code&gt;，我们可以使用 &lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt; 函数将其转化为一个 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 表达式，而它的子表达式是 &lt;code class=&quot;inline&quot;&gt;Term Expr&lt;/code&gt;。这表示我们对一个 &lt;code class=&quot;inline&quot;&gt;Term Expr&lt;/code&gt; 连续应用 &lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt; 函数就可以把它解析成&lt;i&gt;任意嵌套&lt;/i&gt;的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt;：&lt;code class=&quot;inline&quot;&gt;Term Expr&lt;/code&gt; 可以变成 &lt;code class=&quot;inline&quot;&gt;Expr (Term Expr)&lt;/code&gt; 接着变为 &lt;code class=&quot;inline&quot;&gt;Expr (Expr (Term Expr))&lt;/code&gt;，以此类推。这种使用函子不动点来定义递归类型的风格，正是一个 &lt;i&gt;codata&lt;/i&gt; 的例子，完整地讨论 codata 理论（还有 codata 的各种变种）已经超出了本文的范围。感兴趣的话，&lt;a href=&quot;http://www.tac-tics.net/data-vs-codata&quot;&gt;这里&lt;/a&gt;有一个非常详尽的介绍。&lt;/p&gt;&lt;h2&gt;泛化遍历&lt;/h2&gt;&lt;p&gt;在本章，我们将为使用不动点和函子来定义我们的数据结构打下基础。&lt;/p&gt;&lt;p&gt;考虑一个自底向上的遍历过程，我们用伪码来看看一个函子的不动点遍历需要具备哪些功能：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;我们使用 ƒ 自底向上地遍历一个 Term
  1. 解析 Term 以访问它的所有孩子
  2. 使用 ƒ 递归地应用于 Term 的每一个孩子
  3. 重新封装好 Term
  4. 应用 ƒ 到 Term 上&lt;/code&gt;&lt;p&gt;我们定义函数 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt; 来总结刚才伪码所做的过程。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;bottomUp :: Functor a =&amp;gt; (Term a -&amp;gt; Term a) -&amp;gt; Term a -&amp;gt; Term a&lt;/code&gt;&lt;p&gt;给定一个从 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 到 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 的函数 &lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt;，我们先用 &lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt; 函数对 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 解包，接着使用  &lt;code class=&quot;inline&quot;&gt;fmap (bottomUp fn)&lt;/code&gt; 来递归遍历它的每一个子节点，接着使用 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 重新封装，最后只需要应用 &lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt; 得到最后结果即可。其中 &lt;code class=&quot;inline&quot;&gt;fmap bottomUp&lt;/code&gt; 的调用完成了函数中最重要的类型提升部分：它使用函子完成了对所有子节点的递归遍历。&lt;/p&gt;&lt;p&gt;我不会分别定义 &lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt; 的参数和 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 的参数，取而代之的是我准备直接定义 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt; 函数，直接把 &lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;fmap bottomUp&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt; 组合起来。这里会用到在 &lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/Control.Arrow&quot;&gt;Control.Arrow&lt;/a&gt;&lt;/code&gt; 中的 &lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 操作符，从左向右结合，&lt;code class=&quot;inline&quot;&gt;f &amp;gt;&amp;gt;&amp;gt; g x&lt;/code&gt; 等价于 &lt;code class=&quot;inline&quot;&gt;g(f(x))&lt;/code&gt;。这个风格稍显古怪，实际上自右向左的结合 &lt;code class=&quot;inline&quot;&gt;.&lt;/code&gt; 更加常见，这里我们使用这个风格是因为这样我们将对于函数间的调用顺序有一个清晰的可视化，而这一顺序之后会变得十分重要。&lt;/p&gt;&lt;p&gt;现在我们按自左向右的顺序使用 &lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 操作符将函数拼接起来：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;bottomUp fn =  
  out                    -- 1) unpack
  &amp;gt;&amp;gt;&amp;gt; fmap (bottomUp fn) -- 2) recurse
  &amp;gt;&amp;gt;&amp;gt; In                 -- 3) repack
  &amp;gt;&amp;gt;&amp;gt; fn                 -- 4) apply&lt;/code&gt;&lt;p&gt;于是，我们的第一个 Recursion Schemes 函数出现了！我们可以使用 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt; 函数完成了一个类型安全并且支持泛型的组合子，使其可以递归地对任何函子进行变换：比如我们的 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt;，或者列表，多叉树，或任何其他结构。老实说，这非常酷！我们再一次重写之前的 &lt;code class=&quot;inline&quot;&gt;flatten&lt;/code&gt; 函数，以使它支持嵌套了任意多层 &lt;code class=&quot;inline&quot;&gt;Expr&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt;:&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;flattenTerm :: Term Expr -&amp;gt; Term Expr  
flattenTerm (In (Paren e)) = e  -- remove all Parens  
flattenTerm other = other       -- do nothing otherwise

flatten :: Term Expr -&amp;gt; Term Expr  
flatten = bottomUp flattenTerm&lt;/code&gt;&lt;p&gt;我们的上一个使用 &lt;code class=&quot;inline&quot;&gt;apply&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;flatten&lt;/code&gt; 版本不可谓不简洁，但是新的版本更加优雅：我们的 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt; 函数使用 Recusion Scheme 使我们彻底规避了定义递归形式。我们可以专注于 &lt;code class=&quot;inline&quot;&gt;flatten&lt;/code&gt; 函数的行为本身——从语法树中去除所有的括号节点——而完成这一函数也仅仅只需 2 行。而且使用 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;flattenTerm&lt;/code&gt; 比显式的定义整个递归函数更加简明清晰。相比于我们之前版本的 &lt;code class=&quot;inline&quot;&gt;flatten&lt;/code&gt;，我们已经获得了不小的进展，我想不到比这更简洁的表达方式编码方式了。&lt;/p&gt;&lt;p&gt;但是我们还是不要就此止步为好，让我们考虑一下自底向上遍历的天然对偶形式，自顶向下遍历一个 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;我们使用 ƒ 自顶向下地遍历一个 Term
  1. 应用 ƒ 到 Term
  2. 解析 Term 以访问它的所有孩子
  3. 使用 ƒ 递归地应用于 Term 的每一个孩子
  4. 重新封装好 Term&lt;/code&gt;&lt;p&gt;注意到这些指令与自底向上遍历的指令惊人地相似，只需要我们逆序整个流程，并把解析和封装交换下位置，二者就完全相同了，而美妙的是：我们的代码也可以这样做。代码中我们只需要将自左向右的操作符 &lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 替换为自右向左的操作符 &lt;code class=&quot;inline&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;[4]，并把 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Out&lt;/code&gt; 交换位置就可以了！&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;topDown, bottomUp :: Functor f =&amp;gt; (Term f -&amp;gt; Term f) -&amp;gt; Term f -&amp;gt; Term f

topDown f  = In &amp;lt;&amp;lt;&amp;lt; fmap (topDown f) &amp;lt;&amp;lt;&amp;lt; out &amp;lt;&amp;lt;&amp;lt; f 

bottomUp f = out &amp;gt;&amp;gt;&amp;gt; fmap (bottomUp f) &amp;gt;&amp;gt;&amp;gt; In &amp;gt;&amp;gt;&amp;gt; f&lt;/code&gt;&lt;p&gt;我们通过“反转箭头”就完成了自顶向下自底向上这一组对偶概念的表达，同时保持类型安全并不失一般性，而且这些概又可由 Haskell 的两大核心概念函子和不动点自然导出，还有什么比这更激动人心呢？&lt;/p&gt;&lt;h2&gt;结语&lt;/h2&gt;&lt;p&gt;自顶向下和自底向上是 Recursion Schemes 中最为简单的一组。我们只是接触到了 &lt;i&gt;Bananas, Lenses, Envelopes and Barbed Wire&lt;/i&gt; 论文的一些初级应用。在下一篇介绍中，我会谈谈 Recursion Schemes 的另外两个变种以及如何让 Recursion Schemes 更加泛化。&lt;/p&gt;&lt;p&gt;我要感谢所有阅读这篇文章的人，特别是 Nate Soares 和 Manuel Chakravarty，我还要感谢 Colin Barrett，与我熬夜讨论文章的细节，如果你有任何关于本文的评论或疑问，可以在 &lt;a href=&quot;https://twitter.com/importantshock&quot;&gt;Twitter&lt;/a&gt; 上找到我。&lt;/p&gt;&lt;p&gt;下一章我们将定义并讨论 catamorphisms 和 anamorphisms。&lt;/p&gt;&lt;h2&gt;译者后记&lt;/h2&gt;&lt;p&gt;译者也是还在 Haskell 学习中，本来是在读 &lt;a href=&quot;https://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383&quot;&gt;Pearls Functional Algorithm Design&lt;/a&gt;，一不留神就掉进了 Recursion Schemes 的坑里，目前来看坑也是有越开越大的趋势。本文翻译自 &lt;a href=&quot;https://blog.sumtypeofway.com/&quot;&gt;Adventures in Uncertainty&lt;/a&gt; 博客，关于一些术语和技术的翻译可能不够准确，原文的神韵也多有折扣，恳请大家指正。阅读的过程中如果遇到什么问题，也欢迎与我交流讨论。&lt;/p&gt;&lt;p&gt;最后再次感谢大家的阅读！&lt;/p&gt;&lt;p&gt;[1]:实际上在 &lt;i&gt;Bananas, Lenses, Envelopes and Barbed Wire&lt;/i&gt; 一文中，Meijer 等人并没有使用任何一种特定的编程语言，而是使用了一套由 &lt;a href=&quot;http://en.wikipedia.org/wiki/Bird%E2%80%93Meertens_Formalism&quot;&gt;Bird-Meertens formalism&lt;/a&gt; 导出的符号。（Bird-Meertens formalism 是一套基于 Recursion Schemes 的程序构造演算系统，Meijer 的博士论文就是在讨论一套使用 Bird-Meertens formalis 的编译器规范）这套演算系统也被称为 “Squiggol”，这是源于它扭曲的符号记法。尽管记法本身十分详尽，单其中的一些描述符号如“香蕉括号”（形如&lt;code class=&quot;inline&quot;&gt;(||)&lt;/code&gt;）和 “凹透镜”（形如&lt;code class=&quot;inline&quot;&gt;[()]&lt;/code&gt;）仍令人倍感困惑。&lt;/p&gt;&lt;p&gt;[2]:你或许会好奇既然 &lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt; 只是 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt; 的一个特化，那么为什么 Haskell 提供了 &lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt; 两个函数，而这正是 Haskell 社区的一个核心论点。正如 &lt;a href=&quot;http://www.haskell.org/haskellwiki/Typeclassopedia#Instances&quot;&gt;Typeclassopedia&lt;/a&gt; 的作者 Brent Yorgey 所说：“对于一个 Haskell 的初学者，当错误的使用 &lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt; 函数时，他显然更想看到一个关于列表的错误，而非一个关于函子的错误”。&lt;/p&gt;&lt;p&gt;[3]:完整地讨论不动点的优雅与重要显然超出了本文的范围，对此感兴趣的读者可以阅读 Raymond Smullyan 的一篇精彩教材 &lt;a href=&quot;http://www.amazon.com/To-Mock-Mockingbird-Other-Puzzles/dp/0192801422&quot;&gt;Mock a Mockingbird&lt;/a&gt; 或是阅读 Reginald Braithwaite 的 &lt;a href=&quot;https://github.com/raganwald/combinators.info&quot;&gt;combinators.info&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;[4]:即为 Haskell 中的 &lt;code class=&quot;inline&quot;&gt;.&lt;/code&gt; 操作符。&lt;/p&gt;</description>
<author>禾木旁</author>
<guid isPermaLink="false">2018-08-10-41754330</guid>
<pubDate>Fri, 10 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>从 Haskell 到 WebAssembly（2）</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-08-10-41377372.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41377372&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5eb1e96120e1c903ae939425f3d2b173_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;GHC 的编译管线和插件机制&lt;/h2&gt;&lt;p&gt;上期讲了 WebAssembly 跑起来和写起来是什么感觉。这期讲讲怎么把 Haskell 代码变成 WebAssembly 代码。首先要设法从 GHC 的编译管线里面把某个 IR 捞出来（而且要 in-memory 的形式，要是 dump 到文本再解析那就实在太。。）&lt;/p&gt;&lt;p&gt;这里我们先只关心单个 Haskell module 的 pipeline。在 GHC 进程启动以后，首先会解析 major mode，如果 major mode 对应 &quot;ghc --make&quot; 或者 &quot;ghc -c&quot; 等编译 Haskell 代码的模式，经过依赖分析以后，会对每一个 Haskell module 启动一个 pipeline，相关代码在 GHC API 的 DriverPipeline 模块中。&lt;/p&gt;&lt;p&gt;在 pipeline 中，Haskell 源代码经过预处理器展开 CPP 宏以后，经历的中间表示有：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Parsed module。保留了所有的源代码语法特性的 AST。&lt;/li&gt;&lt;li&gt;Renamed module。解析所有 identifier 的作用域，诸如 lambda 参数之类的 identifier 重命名到全局唯一，从模块导出的 identifier 带上模块前缀。从这一步开始，GHC 要求跑一个模块的 pipeline 之前，其依赖模块的 pipeline 必须已经跑过，并且成功通过类型检查，将相关信息存入其 interface file 以供查询。&lt;/li&gt;&lt;li&gt;Typechecked module。类型检查过的模块。类型检查一通过，可以生成 interface file 了，其他依赖该模块的模块在编译时需要查询 interface file 里面的各种信息。值得一提的是，前面这几个中间表示共用一套 AST，至于如何区分诸如 identifier 等细节的类型差异？依靠 Trees that Grow 设计模式。&lt;/li&gt;&lt;li&gt;Core。这是一个极小的带类型 lambda calculus，基于某个 System F 变种。大多数优化都是在 Core 上跑的带类型优化。Core 是有形式化 spec，并且保证 Core 类型不出错，运行时就不会 segfault 的（前提是如果你不用 FFI 之类的作死）&lt;/li&gt;&lt;li&gt;STG。这是一个经过 ANF 变换，term 形状受限的另一个极小 lambda calculus，在 STG 中，所有的 thunk allocation 和 evaluation 的时机直接由 term 的形状决定。大多数 Haskell to JavaScript 编译器（haste 和 ghcjs）选择用 STG 作为编译到 JavaScript 的中间表示。&lt;/li&gt;&lt;li&gt;Cmm。一个长得勉强有点像 C（毕竟叫 C-minus-minus）的玩意，作为各种不同平台代码生成器共用的中间表示，设计目的是“平台无关汇编”。当然，GHC 的年代比 LLVM 年代早多了所以用这个，要是 LLVM 火了以后再开坑，估计就直接用 LLVM IR 了。&lt;/li&gt;&lt;li&gt;默认的汇编后端，生成 gcc 能识别的 .asm 文本，然后 gcc 编译成 .o 文件。LLVM 后端会生成 LLVM IR 文本，调用 llc/opt 编译。C 后端直接生成 C 代码编译。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们要从 Haskell 编译到 WebAssembly，自然要挑一个接近底层的 IR，这里我们选择 Cmm，从 Cmm 开始做代码生成，大致相当于开发一个新架构的原生后端。（选其他的也不是不行，我跟同事讨论时开玩笑说能不能做个新后端把 x64 assembly 编译到 WebAssembly，他说你还是直接用 Emscripten 编译个 qemu 算了。。）&lt;/p&gt;&lt;p&gt;接下来的任务是：设法劫持正常的 GHC pipeline，加载我们自定义的逻辑，获得 in-memory IR 并进行我们自己的代码生成。如果你是个想要写函数式编译器来玩玩的萌新，觉得拿 GHC 搞有戏的话，听我一句劝，转去弄 Idris 后端还来得及。还不听劝？好吧，你大致会经历几个阶段：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;看了一些 GHC API 的文档和博客啥的，觉得有搞头。写了一个能编译单个 .hs 的 demo。&lt;/li&gt;&lt;li&gt;能编译自己的 .hs 模块了，这很 OK，然后你如果想成为新世界的卡密，不对，写面向新架构的编译器的话，你需要把整个 Haskell 标准库，连带整个运行时都能编译过去。这个过程叫“booting”。但是你的小儿科 demo 没有办法编译标准库，因为标准库的编译流程相当复杂，一堆涉及 autoconf，sed 之类的乱七八糟的脚本。。。&lt;/li&gt;&lt;li&gt;经过 n 个小时以后，你发现 ezyang 的某篇 &lt;a href=&quot;http://blog.ezyang.com/2017/02/how-to-integrate-ghc-api-programs-with-cabal/&quot;&gt;blog&lt;/a&gt; 提到，GHC 有个叫 &lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/extending_ghc.html#frontend-plugins&quot;&gt;frontend plugin&lt;/a&gt; 的机制，可以用来制造一个 ghc wrapper，这个 ghc wrapper 用于替代正常的 ghc，执行自定义逻辑。很好，你写了一个 ghc frontend plugin，然后额外花了 n 个小时，处理诸如 cabal/stack 支持、package database 相关参数等琐碎问题，总算能把 ghc wrapper 跑起来了。&lt;/li&gt;&lt;li&gt;ghc wrapper 里面可以实现自定义逻辑，但是手头还是没有结构化的 IR，咋整？如果需要的是 Typechecked module 或者 Core 那都比较好办，不过 STG 和 Cmm 是没有暴露出相关表示的，在 pipeline 里面一个 doCodegen 一把梭，直接从 desugared Core 搞到汇编了。你又花了 n 小时，找到了 GHC 的 Hooks 机制，可以用来对 GHC 运行中的一些函数下钩子，其中有个 runPhaseHook 可以把整个 pipeline 换掉！你有了一个大胆的想法。&lt;/li&gt;&lt;li&gt;又过了 n 小时，你的自定义 pipeline 上线了，可喜可贺。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;总的来说，为了最大化与 Cabal 的兼容性，我们需要假装自己是 ghc，也完成 ghc 本身的编译任务生成 native code，但是可以夹带私货干点别的（配置和输入输出不能污染 process args/stdout 什么的，但是可以用环境变量）。&lt;/p&gt;&lt;p&gt;跟 GHC API 打交道相当不愉快，you&#39;ve been warned。不过我靠对 Haskell 的爱扛下来了。&lt;/p&gt;&lt;h2&gt;ghc-toolkit：Haskell to X 编译器的可重用框架&lt;/h2&gt;&lt;p&gt;跟 GHC API 打过交道以后，一个自然的想法就是能不能做个框架封装一下所有这些 hacks，这样一来我做 Haskell to X 的编译器时用框架就不用管太多了。所以 asterius 项目的一个子库就是 ghc-toolkit，实现了这个封装。&lt;/p&gt;&lt;p&gt;使用 ghc-toolkit 大致只需要关心以下几个东西：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data HaskellIR = HaskellIR
  { parsed :: HsParsedModule
  , typeChecked :: TcGblEnv
  , core :: CgGuts
  , stg :: [StgTopBinding]
  , cmm :: [CmmDecl]
  , cmmRaw :: [RawCmmDecl]
  }

data CmmIR = CmmIR
  { cmm :: [CmmDecl]
  , cmmRaw :: [RawCmmDecl]
  }

data Compiler = Compiler
  { patch :: ModSummary -&amp;gt; HsParsedModule -&amp;gt; Hsc HsParsedModule
  , withHaskellIR :: ModSummary -&amp;gt; HaskellIR -&amp;gt; CompPipeline ()
  , withCmmIR :: CmmIR -&amp;gt; CompPipeline ()
  , finalize :: Ghc ()
  }

makeFrontendPlugin :: Ghc Compiler -&amp;gt; FrontendPlugin

data FakeGHCOptions = FakeGHCOptions
  { ghc, ghcLibDir :: FilePath
  , frontendPlugin :: GHC.FrontendPlugin
  }

fakeGHCMain :: FakeGHCOptions -&amp;gt; IO ()&lt;/code&gt;&lt;p&gt;解释一下。前面两个数据类型是 GHC 在编译 .hs/.cmm 时分别会获得的 IR 的集合。假如想要写一个基于 GHC 的 Haskell to X 编译器，那么把自定义的逻辑放在 Compiler 类型里面就行了——Hsc、CompPipeline、Ghc 等这几个不同 GHC phase 对应的 monad 都是 MonadIO instance，所以也支持插入任意副作用（比如读写你自己的 object file 之类的玩意）。每当 GHC 对一个模块启动 pipeline 时，会触发 withHaskellIR/withCmmIR 回调函数，执行你自己自定义的逻辑，其中你可以拿到当前模块的模块信息以及各种 IR。&lt;/p&gt;&lt;p&gt;为了把 Compiler 类型用起来，首先用 makeFrontendPlugin，可以把 Compiler 转换成一个 GHC 的 frontend plugin（Compiler 是在 Ghc monad 里面初始化的，按前面说的，初始化的逻辑也可以带副作用，而所有模块编译完以后的 finalizer 也可以插进去）。这个 frontend plugin 可以用 GHC 的 --frontend 机制动态加载，也可以通过 fakeGHCMain 直接生成一个假的 ghc wrapper executable，这个 ghc wrapper executable 的行为大多数时候和 ghc 一致，不过用 --make 编译 Haskell 模块时，会自动加载 Compiler 中的各种回调函数。&lt;/p&gt;&lt;p&gt;简而言之，使用 ghc-toolkit，用上面的机制搞出一个假的 ghc，然后编译标准库或者自己的模块时，用这个假的 ghc 直接代替 ghc，即可把自己的 Haskell 编译器给跑起来了。可喜可贺。&lt;/p&gt;&lt;p&gt;最后值得一提的是，Compiler 里面额外提供了一个 patch 回调函数，这个玩意可以用来重写 parsed IR（实现重写其他 IR 的回调函数很容易，但是其他 IR 很容易改坏了，自己改要么把 GHC 给 crash 掉，要么编译出什么不可名状的玩意）。这个重写机制可以拿来做很多很有意思的事，比如给所有函数打个 INLINEABLE 标记，让 GHC 自动变成全局优化编译器（逃。GHC 8.6 已经加了 source plugin 功能，可以用 GHC Plugin 重写 parsed/renamed/typechecked IR，原理和这个基本上一样。&lt;/p&gt;&lt;p&gt;这期先讲这么多。感觉都是 GHC 相关的 hack，下一期就有 WebAssembly 了。&lt;/p&gt;</description>
<author>Felis sapiens</author>
<guid isPermaLink="false">2018-08-10-41377372</guid>
<pubDate>Fri, 10 Aug 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
