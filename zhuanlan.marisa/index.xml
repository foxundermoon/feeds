<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Sun, 01 Apr 2018 23:05:37 +0800</lastBuildDate>
<item>
<title>The C Programming Language：入门</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-01-35179359.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35179359&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
序&lt;br&gt;&lt;br&gt;在本书的开篇，我们首先概要地介绍 C 语言，主要是通过实际的程序引入 C 语言的基本元素，至于其中的具体细节、规则以及一些例外情况，在此暂时不多做讨论。因此，本章不准备完整、详细地讨论 C 语言中的一些技术（当然，这里所举的所有例子都是正确的）。我们是希望读者能尽快地编写出有用的程序，为此，本章将重点介绍一些基本概念，比如变量与 常量、算术运算、控制流、函数、基本输入／输出等。而对于编写较大型程序所涉及到的一 些重要特性，比如指针、结构、C 语言中十分丰富的运算符集合、部分控制流语句以及标准库 等，本章将暂不做讨论。 &lt;br&gt;&lt;br&gt;这种讲解方式也有缺点。应当提请注意的是，在本章的内容中无法找到任何特定语言特
性的完整说明，并且，由于比较简略，可能会使读者产生一些误解；再者，由于所举的例子 并没有用到 C 语言的所有强大功能，因此，这些例子也许并不简洁、精炼。虽然我们已经尽力将这些问题的影响降到最低，但问题肯定还是存在。另一个不足之处在于，本章所讲的某些内容在后续相关章节还必须再次讲述。我们希望这种重复给读者带来的帮助效果远远超过它的负面影响。 &lt;br&gt;&lt;br&gt;无论是利还是弊，一个经验丰富的程序员应该可以从本章介绍的内容中推知他们自己进
行程序设计所需要的一些基本元素。初学者应编写一些类似的小程序作为本章内容的补充练习。无论是经验丰富的程序员还是初学者，都可以把本章作为后续各章详细讲解的内容的框架。 &lt;br&gt;&lt;br&gt;1.1. 入门
&lt;br&gt;&lt;br&gt;学习一门新程序设计语言的惟一途径就是使用它编写程序。对于所有语言的初学者来说，编写的第一个程序几乎都是相同的，即：&lt;br&gt;请打印出下列内容 &lt;br&gt;&lt;br&gt;hello, world &lt;br&gt;&lt;br&gt;尽管这个练习很简单，但对于初学语言的人来说，它仍然可能成为一大障碍，因为要实
现这个目的，我们首先必须编写程序文本，然后成功地运行编译，并加载、运行，最后输出到某个地方。掌握了这些操作细节以后，其它事情就比较容易了。 &lt;br&gt;&lt;br&gt;在 C 语言中，我们可以用下列程序打印出&lt;br&gt;&lt;br&gt;“hello, world”：
&lt;br&gt;#include &amp;lt;stdio.h&amp;gt; 
&lt;br&gt;main() 
&lt;br&gt;{ 
&lt;br&gt; printf(&quot;hello, world\n&quot;); 
&lt;br&gt;} &lt;br&gt;&lt;br&gt;如何运行这个程序取决于所使用的系统。这里举一个特殊的例子。在 UNIX 操作系统中，首先必须在某个文件中建立这个源程序，并且以“.c”作为文件的扩展名，例如 hello.c，然后再通过下列命令进行编译： &lt;br&gt;&lt;br&gt;gcc hello.c &lt;br&gt;&lt;br&gt;如果源程序没有什么错误（例如漏掉字符或拼错字符），编译过程将顺利进行，并生成一个可
执行文件 a.out。然后，我们输入： &lt;br&gt;a.out 
&lt;br&gt;即可运行 a.out，打印出下列信息：
&lt;br&gt;hello, world 
&lt;br&gt;在其它操作系统中，编译、加载、运行等规则会有所不同。
&lt;br&gt;————————————————————————&lt;br&gt;#include &amp;lt;stdio.h&amp;gt; 
   &lt;br&gt; 包含标准库的信息&lt;br&gt;main() 
   &lt;br&gt;   定义名为 main 的函数，它不接受参数值&lt;br&gt;{ 
    &lt;br&gt;   main 函数的语句都被括在花括号中&lt;br&gt; printf(&quot;hello, world\n&quot;); 
&lt;br&gt;   main 函数调用库函数 printf 以显示字符序列&lt;br&gt;}       &lt;br&gt;   \n 代表换行符&lt;br&gt;                           第一个C语言程序&lt;br&gt;————————————————————————&lt;br&gt;&lt;br&gt;下面对程序本身做些说明。一个 C 语言程序，无论其大小如何，都是由函数和变量组成的。函数中包含一些语句，以指定所要执行的计算操作；变量则用于存储计算过程中使用的值。C 语言中的函数类似于 Fortran 语言中的子程序和函数，与 Pascal 语言中的过程和函数也很类似。在本例中，函数的名字为main。通常情况下，函数的命名没有限制，但 main 是一个特殊的函数名——每个程序都从 main 函数的起点开始执行，这意味着每个程序都必须在某个位置包含一个 main 函数。 &lt;br&gt;main 函数通常会调用其它函数来帮助完成某些工作，被调用的函数可以是程序设计人员
&lt;br&gt;自己编写的，也可以来自于函数库。上述程序段中的第一行语句
&lt;br&gt;&lt;br&gt;#include &amp;lt;stdio.h&amp;gt; 
&lt;br&gt;&lt;br&gt;用于告诉编译器在本程序中包含标准输入／输出库的信息。许多 C 语言源程序的开始处都包
含这一行语句。我们将在第 7 章和附录 B 中对标准库进行详细介绍。 &lt;br&gt;&lt;br&gt;函数之间进行数据交换的一种方法是调用函数向被调用函数提供一个值（称为参数）列
&lt;br&gt;表。函数名后面的一对圆括号将参数列表括起来。在本例中，main 函数不需要任何参数，因
此用空参数表()表示。 &lt;br&gt;&lt;br&gt;函数中的语句用一对花括号{}括起来。本例中的 main 函数仅包含下面一条语句：
&lt;br&gt;printf(&quot;hello, world\n&quot;); 
&lt;br&gt;调用函数时，只需要使用函数名加上用圆括号括起来的参数表即可。上面这条语句将&quot;hello, 
&lt;br&gt;world\n&quot;。作为参数调用 printf 函数。printf 是一个用于打印输出的库函数，在此处，它打印双引号中间的字符串。用双引号括起来的字符序列称为字符串或字符串常量，如&quot;hello,world\n&quot;就是一个字符串。目前我们仅使用字符串作为 printf 及其它函数的参数。&lt;br&gt;&lt;br&gt;在 C 语言中，字符序列\n 表示换行符，在打印中遇到它时，输出打印将换行，从下一行
&lt;br&gt;的左端行首开始。如果去掉字符串中的\n（这是个值得一做的练习），即使输出打印完成后也
不会换行。在 printf 函数的参数中，只能用\n 表示换行符。如果用程序的换行代替\n，例如：
&lt;br&gt;&lt;br&gt;printf(&quot;hello, world 
&lt;br&gt;&quot;); 
&lt;br&gt;&lt;br&gt;C 编译器将会产生一条错误信息。
&lt;br&gt;&lt;br&gt;printf 函数永远不会自动换行，这样我们可以多次调用该函数以分阶段得到一个长的输
&lt;br&gt;出行。上面给出的第一个程序也可以改写成下列形式：
&lt;br&gt;&lt;br&gt;#include &amp;lt;stdio.h&amp;gt; 
&lt;br&gt;main() 
&lt;br&gt;{ 
&lt;br&gt; printf(&quot;hello, &quot;); 
&lt;br&gt; printf(&quot;world&quot;); 
&lt;br&gt; printf(&quot;\n&quot;); 
&lt;br&gt;} 
&lt;br&gt;&lt;br&gt;这段程序与前面的程序的输出相同。
&lt;br&gt;请注意，\n 只代表一个字符。类似于\n 的转义字符序列为表示无法输入的字符或不可见
&lt;br&gt;字符提供了一种通用的可扩充的机制。除此之外，C 语言提供的转义字符序列还包括：\t 表
&lt;br&gt;示制表符；\b 表示回退符；\&quot;表示双引号；\\表示反斜杠符本身。2.3 节将给出转义字符序
列的完整列表。&lt;br&gt;&lt;br&gt;练习 1-1&lt;br&gt;在你自己的系统中运行“hello, world”程序。再有意去掉程序中的部分内容，看看会得到什么出错信息。 &lt;br&gt;练习 1-2 &lt;br&gt;做个实验，当 printf 函数的参数字符串中包含\c（其中 c 是上面的转义
字符序列中未曾列出的某一个字符）时，观察一下会出现什么情况。 &lt;br&gt;————————————————————————&lt;br&gt;&lt;br&gt;原作者：&lt;br&gt;Brian W. Kernighan 
&lt;br&gt;Dennis M. Ritchie&lt;br&gt;ヾ(@゜∇゜@)ノ祝米娜桑愚人节快乐~有什么不好的尽管在评论区提出哦~</description>
<author>A.Scarlet</author>
<guid isPermaLink="false">2018-04-01-35179359</guid>
<pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>C宏元编程:编译期LISP解释器（二）列表操作</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-01-35172411.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35172411&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;目录⇣&lt;br&gt;    &lt;a href=&quot;https://zhuanlan.zhihu.com/p/35121316&quot;&gt;（一）总体思路&lt;/a&gt;&lt;br&gt;⇢&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35172411&quot;&gt;（二）列表操作&lt;/a&gt;&lt;br&gt;外部链接⇣&lt;br&gt;这是一个超级神奇的项目&lt;a href=&quot;https://github.com/BlueFlo0d/CSP&quot;&gt;CSP Git Repo&lt;/a&gt; &lt;/blockquote&gt;&lt;blockquote&gt;纯粹用C宏写的LISP解释器！&lt;br&gt;（目前还没有完成，最重要的lambda已经实现了，cond暂时还有问题嵌套会出错x）&lt;br&gt;（想拉一些小伙伴一起玩一起烧脑呀！可惜似乎人类玩家直接看源码大概率大脑爆栈，于是尝试写了一些文章之类。。原始wiki可以戳这里&lt;br&gt;&lt;a href=&quot;https://github.com/BlueFlo0d/CSP/wiki/Implementation-details&quot;&gt;CSP Wiki&lt;/a&gt; &lt;/blockquote&gt;&lt;p&gt;这次要开始分析真正的Interpreter A原语啦！坐稳啦！&lt;/p&gt;&lt;h2&gt;列表结构&lt;/h2&gt;&lt;p&gt;开始分析LISP操作前我们先来看看CSP中列表的表示：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(a) //我是原子
( (a) (b) (c) (d) ) //我是列表&lt;/code&gt;&lt;p&gt;为什么要这样呢，用下面这种方式不会更自然吗：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;a //我才是原子
(a,b,c,d) //我才是列表&lt;/code&gt;&lt;p&gt;首先第一种方式括号更多，更符合LISP书写传统（划掉&lt;/p&gt;&lt;p&gt;最重要的是第一种方式在迭代列表和安全操作上有很多优点，例如迭代列表我们可以这样实现：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define sth(x) dosth(x) sth_y
#define sth_y(x) dosth(x) sth
sth(a)(b)(c)(d) // =&amp;gt; dosth(a) sth_y(b)(c)(d) ... 
// =&amp;gt; dosth(a) dosth(b) ... sth 或 sth_y （最后剩下一个没展开完的）&lt;/code&gt;&lt;p&gt;最后剩下的那个“尾巴”可以用零点构造或者以下方式“吃掉”：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define _sth(list) CAT(sth list,_end)
#define sth_end
#define sth_y_end
_sth((a)(b)(c)(d)) // =&amp;gt; CAT( dosth(a) ... sth,_end) =&amp;gt; dosth(a) ... sth_end =&amp;gt; dosth(a)&lt;/code&gt;&lt;p&gt;不过零点构造技术在柯里化的多元迭代函数上有更多优点，所以CSP中两者皆有采用。&lt;/p&gt;&lt;p&gt;至于安全性，接下来会提到。&lt;/p&gt;&lt;h2&gt;基本操作：CAR&lt;/h2&gt;&lt;p&gt;CAR：取一个列表第一个元素的操作，LISP基本原语之一&lt;/p&gt;&lt;p&gt;以下是朴素的CAR实现：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define CAR(x) (_CAR x ))
#define _CAR(x) x _n(
CAR ( (a) (b) (c) ) //=&amp;gt;(_CAR (a) (b) (c) )) 
//=&amp;gt; (a _n( (b) (c) )) =&amp;gt; (a)&lt;/code&gt;&lt;p&gt;这里让CAR定义式中的_CAR展开出一个_n(（未匹配左括号），和后面CAR中的未匹配右括号配对，构成一个零宏，从而将第一个元素后的内容都吃掉。&lt;/p&gt;&lt;p&gt;看起来很好是吗？不过实际上完全不能用。因为在CPP中，由于似乎无法实现短路的逻辑判断，条件分支中所有的clause都会先求值再遴选，这样这些clause大部分都会接受非法输入。&lt;/p&gt;&lt;p&gt;那么看看上面的CAR接受非法输入会发生什么：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;CAR(a) //=&amp;gt;(_CAR a)) 破坏括号平衡！
CAR() //=&amp;gt;(_CAR )) 破坏括号平衡！&lt;/code&gt;&lt;p&gt;会将整个展开过程破坏掉！所以我们需要在非法输入下安全的CAR宏。&lt;/p&gt;&lt;p&gt;实现如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define COND_EAT(x) COND_EATY
#define COND_EATY(x) COND_EAT
#define COND_EAT_FIRST(x) COND_EATY
#define SAFE_CAR_N(x) (())_n
#define SAFE_CAR_EAT_CAR )SAFE_CAR_N((
#define COND_EATY_SCEND (a)
#define COND_EAT_SCEND (a)
#define SAFE_CAR(a) _E(_e _SAFE_CAR(a))
#define _SAFE_CAR(a)  _e(_n _n()(CAT(SAFE_CAR_EAT,_E(_e CAR(CAT(COND_EAT_FIRST a,_SCEND)))))(CAR(a)))
//                                                        ^ 对于非法输入展开失败，输出 (_CAR ... ))
//                                                 ^ _E(_e ...) （两个单位宏名，一对括号）会吞掉参数的一对括号. =&amp;gt; _CAR )
//                                 ^ 连接成 SAFE_CAR_EAT_CAR =========\
//                                v 非法输入导致最后那个CAR同样展开失败.   |
// =&amp;gt; _e(_n _n() () SAFE_CAR_N(() (_CAR ... )) )                      &amp;lt;==/
// =&amp;gt; _e( (()) )
// =&amp;gt; (()) 
//代入 SAFE_CAR 中=&amp;gt; _E(_e (()) )=&amp;gt;()输出一个合法的空列表！&lt;/code&gt;&lt;p&gt;解释一下。_SAFE_CAR 宏大体分为前面的判断体_n _n()(CAT(SAFE_CAR_EAT,_E(_e CAR(CAT(COND_EAT_FIRST a,_SCEND))))) 和后面的主体(CAR(a))，以及最外面增加一次扫描次数的单位宏。判断体应当在输入非法时吃掉主体，而合法时自身输出空。&lt;/p&gt;&lt;p&gt;首先看到 CAT(COND_EAT_FIRST a,_SCEND)，这个目的是把所有形如(b)((c)(d))...之类的合法a值约化为(a)以方便判断体逻辑（否则可能会有很多嵌套列表，难以操作），而将不合法输入约化为一个不含括号的字符串。&lt;/p&gt;&lt;p&gt;此后交由CAR，对于不合法输入会输出形如(_CAR ...))，吞掉一对括号后与SAFE_CAR_EAT连成SAFE_CAR_EAT_CAR，再展开成熟悉的)SAFE_CAR_N((这种未匹配括号形式影响展开过程（多出一个左括号是为了和后面CAR展开失败输出的多余右括号匹配）。而对于合法输入，则直接被_n _n() (...) 吞掉。&lt;/p&gt;&lt;p&gt;SAFE_CDR采用类似思路实现。&lt;/p&gt;&lt;p&gt;好累啊就主要部分先写这么多吧，接下来稍微扯一下CSP解释器A中怎么处理多元函数的&lt;/p&gt;&lt;h2&gt;CSP解释器A中的柯里化&lt;/h2&gt;&lt;p&gt;之前提过的两个宏交替展开非常好，但似乎无法处理需要两个参数的do_sth。&lt;/p&gt;&lt;p&gt;其实可以通过柯里化解决，不过这样展开次数始终会缺一次所以还是得外置一组单位宏来延迟展开。&lt;/p&gt;&lt;p&gt;柯里化技巧的核心：ZIP宏&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define _be(y) y)
#define ZIP(x)   _n() (x,_be //This _n() delays the expansion of do_sth macro, after _be is expanded. otherwise it will an unmatched bracket error. 
do_sth ZIP(a)(b) =&amp;gt;do_sth _n()(a,_be(b)&lt;/code&gt;&lt;p&gt;如果外面再加一个单位宏强制增加一次扫描，就会变成：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;do_sth (a,b)&lt;/code&gt;&lt;p&gt;这样，一个签名为do_sth(a,b)的二元宏，就可以通过ZIP封装为do_sth ZIP，一个接受一元输入，输出一个一元宏的宏，从而能够处理一个CSP列表的前两项。&lt;/p&gt;&lt;p&gt;在CSP实现中，通常将参数放在待迭代列表前：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(arg)(a)(b)(c)....&lt;/code&gt;&lt;p&gt;do_sth实现为处理(arg,a)，并将arg放在处理结果之后，然后进行递归：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;do_sth (arg)
=&amp;gt; real_do_sth(arg,a) do_sth_y (arg) 
do_sth (arg)(a)(b)(c)
=&amp;gt; real_do_sth(arg,a) do_sth_y (arg) (b)(c)&lt;/code&gt;&lt;p&gt;这样就实现了带参数的迭代列表操作。&lt;/p&gt;</description>
<author>K.Scarlet</author>
<guid isPermaLink="false">2018-04-01-35172411</guid>
<pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>C宏元编程:编译期LISP解释器（一）总体思路</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-30-35121316.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35121316&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一个超级神奇的项目 &lt;a href=&quot;https://github.com/BlueFlo0d/CSP&quot;&gt;CSP GIt Repo&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对！纯粹用C宏-那个只支持字符串替换和粘贴的东西-写的LISP解释器！&lt;/p&gt;&lt;p&gt;（目前还没有完成，最重要的lambda已经实现了，cond暂时还有问题嵌套会出错x）&lt;/p&gt;&lt;p&gt;（想拉一些小伙伴一起玩一起烧脑呀！可惜似乎人类玩家直接看源码大概率大脑爆栈，于是尝试写了一些文章之类。。原始wiki可以戳这里 &lt;a href=&quot;https://github.com/BlueFlo0d/CSP/wiki/Implementation-details&quot;&gt;CSP Wiki&lt;/a&gt;&lt;/p&gt;&lt;p&gt;那么现在就开始玩转（abuse）C宏定义的神奇（ドM）之旅吧！&lt;/p&gt;&lt;h2&gt;总体思路&lt;/h2&gt;&lt;p&gt;C宏定义想必大家都熟悉，姑且展开最天马行空的想象，进行LISP的列表操作（CAR CDR CONS之类）应该是可行的，First-class function某种程度上似乎也可行（传递宏名），比如这个例子：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define E(...) __VA_ARGS__ //单位宏
#define N(...) //零宏
#define __test(something,k,...) k(do something)
#define _test(something,...) __test(something,E)
_test(testit) // =&amp;gt; __test(testit,E) =&amp;gt; E(do testit) =&amp;gt; do testit
_test(E(N,N)) // =&amp;gt; __test(N,N,E) =&amp;gt; N(do N) =&amp;gt;
//_test(E(N,N))的输出消失了！&lt;/code&gt;&lt;p&gt;这个例子中我们看到我们将零宏和单位宏作为参数传入，并使得_test（封装 __test）具有一个零点 E(N,N)。这个技巧（私货！）在CSP的实现中经常用到！记笔记！&lt;/p&gt;&lt;p&gt;但是要实现lambda。。似乎纯粹的C宏很难做到（比如要把参数代入匿名函数体。。咋整啊）。。&lt;/p&gt;&lt;p&gt;不过别忘了神奇的LISP是可以实现自解释的！也就是可以用没有lambda语义的LISP解释器来实现完整的LISP解释器。&lt;/p&gt;&lt;p&gt;CSP的实现就按照了这个思路，首先实现解释器A（其实就是加载了一组实现LISP原语宏的C预处理器），然后再在解释器A上实现完整的LISP自解释器B。以下是自解释器的源码（不是最新的x 最新的在纠结那个有问题的cond）&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;//Line 176, csp.h
#define $zipped_eval(e,a) COND(\
        (ATOM e (EVAL_e $zipped_assoc(e,a)))    \
        (ATOM SAFE_CAR e \
         COND(($eq(SAFE_CAR e (quote))EVAL_e(SAFE_CAR SAFE_CDR e))  \
              ($eq(SAFE_CAR e (atom)) (EVAL_e ATOM\
              DELAY_INT_23($zipped_eval_R)() (SAFE_CAR SAFE_CDR e,a))) \
              ($eq(SAFE_CAR e (eq)) (EVAL_e $eq( DELAY_INT_25($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR e,a) DELAY_INT_25($zipped_eval_R)() \
              (SAFE_CAR SAFE_CDR SAFE_CDR e,a)))) \
              ($eq(SAFE_CAR e (car)) (EVAL_e SAFE_CAR DELAY_INT_23($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR e,a))) \
              ($eq(SAFE_CAR e (cdr)) (EVAL_e SAFE_CDR DELAY_INT_23($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR e,a))) \
              ($eq(SAFE_CAR e (cons)) (EVAL_e CONS DELAY_INT_23($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR e,a) DELAY_INT_23($zipped_eval_R)()\
              (SAFE_CAR SAFE_CDR SAFE_CDR e,a))) \
              ((T)(EVAL_e DELAY_INT_23($zipped_eval_R)()\
               (($zipped_assoc(SAFE_CAR e,a) EVAL_e SAFE_CDR e),a))) \
                 )                                                      \
                )                                                       \
        ($eq(SAFE_CAR SAFE_CAR e (lambda))\
        (DELAY_INT_26(EVAL_e_R)() DELAY_INT_23($zipped_eval_R)()(\
        EVAL_e(EVAL_e(EVAL_e(EVAL_e(SAFE_CAR SAFE_CDR SAFE_CDR SAFE_CAR e)))),\
        EVAL_e(APPEND DELAY_INT_13($pair_R)()(EVAL_e(EVAL_e(EVAL_e(SAFE_CAR SAFE_CDR SAFE_CAR e)))\
        (DELAY_INT_19($zipped_evlis_R)()(EVAL_e(_e EVAL_e(SAFE_CDR e)), a)))a)))\
        )                                                               \
)&lt;/code&gt;&lt;p&gt;是不是似曾相识啊23333&lt;/p&gt;&lt;p&gt;典型的自解释器实现。大家注意到这里：&lt;/p&gt;&lt;p&gt;1）有很多SAFE_XXX之类的东西，将来会解释。（C宏处理似乎难以实现短路condition，导致经常会对非法表达式进行求值，这种情况下使用naive的原语宏是会出事的-原地报错／破坏括号平衡-所以必须要很麻烦地一个一个实现为对于非法输入仍能给出合法结果的宏）&lt;/p&gt;&lt;p&gt;2）很多EVAL_e。这是一个单位宏，单位宏和零宏在C宏展开中作用非常大，因为可以用它们微调宏的展开顺序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define _CAT(x,y) x##y
#define CAT(x,y) _CAT(x,y) //典型的连接
//_e是一个单位宏，_n是一个零宏
#define b() )x(
_n(b()) //先展开_n再展开b，什么都没有了x
_e(_n _n()(b())) // =&amp;gt;_n()x() =&amp;gt; x()
//先展开b再展开_n&lt;/code&gt;&lt;p&gt;因为CPP展开_&lt;i&gt;e&lt;/i&gt;时对其括号内字符串调用展开过程（所以单位宏可以用来增加一次展开扫描过程），这个时候b会被展开，但第一个_n后面没有左括号不会展开，所以会先展开中间的_n()，下一次扫描时才第一个_n和左括号连起来被展开。&lt;/p&gt;&lt;p&gt;（是不是有些tricky？这是Lv0啦～等不及的可以自己看一下csp.h 2333如果能全部看懂帮我写文章吧qwq）&lt;/p&gt;&lt;p&gt;3) DELAY_INT_xxx(xxx_R)()(...) 这个是著名的延迟展开技巧，DELAY_INT_xxx定义如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define DELAY_REF(x) x _n()
#define DELAY_REF_2(x) x _n()
#define DELAY_INT_2(x) DELAY_REF(DELAY_REF_2)(x)
#define DELAY_INT_3(x) DELAY_REF(DELAY_INT_2)(x)
#define DELAY_INT_4(x) DELAY_REF(DELAY_INT_3)(x)
#define DELAY_INT_5(x) DELAY_REF(DELAY_INT_4)(x)
...&lt;/code&gt;&lt;p&gt;结合2）容易理解这样 DELAY_INT_n(xxx_R)() 每次扫描n会减一，直到“露出” xxx_R与后面的()结合，习惯上定义：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define xxx_R() xxx&lt;/code&gt;&lt;p&gt;这样xxx就被展开出来与参数列表结合，起到任意调节宏展开顺序的作用。&lt;/p&gt;&lt;p&gt;此外这个还被用于宏的递归。由于蓝色集合的限制，像这样的宏是不能实现递归的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define I_want_recursion(x) do_it(x) I_want_recursion(x)
I_want_recursion(x) //=&amp;gt;do_it(x) I_want_recursion(x)
//CPP认为它属于已经处理过的字符串于是就不会再展开了^
_e(I_want_recursion(x))//=&amp;gt;do_it(x) I_want_recursion(x)
//扫描多少遍都没有用！&lt;/code&gt;&lt;p&gt;但是可以这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define I_want_recursion_R() I_want_recursion
#define I_want_recursion(x) do_it(x) DELAY_REF(I_want_recursion_R)()(x)
I_want_recursion(x) //=&amp;gt;do_it(x) I_want_recursion_R()(x)
_e(I_want_recursion(x)) //=&amp;gt;do_it(x) do_it(x) I_want_recursion_R()(x)
//因为这次I_want_recursion是由I_want_recursion_R()新造出来的token所以可以继续展开下去&lt;/code&gt;&lt;p&gt;不过这样需要在外面套足够多的单位宏来进行足够次数的扫描。。。CSP中有一部分使用零点构造技术更优雅地实现了递归，将来会写的x&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这次就先写这些吧，下次写解释器A的列表操作实现和Currying？&lt;/p&gt;</description>
<author>K.Scarlet</author>
<guid isPermaLink="false">2018-03-30-35121316</guid>
<pubDate>Fri, 30 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Programming Languages: Application and Interpretation【译15中】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-30-35115633.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35115633&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b71b632ed7974538bb2e812bcd20914e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;初翻： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/9bebf466fc2535bec442451dca7cd13a&quot; data-hash=&quot;9bebf466fc2535bec442451dca7cd13a&quot; data-hovercard=&quot;p$b$9bebf466fc2535bec442451dca7cd13a&quot;&gt;@lotuc&lt;/a&gt; &lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;https://lotuc.gitbooks.io/plai-cn/content/&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;15.3 对核心的扩展&lt;/h2&gt;&lt;p&gt;现在我们已经有了基础的静态类型语言，下面探索一下如何将其扩展成为更有用的编程语言。&lt;/p&gt;&lt;h2&gt;15.3.1 显式的参数多态&lt;/h2&gt;&lt;p&gt;&lt;b&gt;下面哪些是相同的？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;(listof string)&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;事实上，上面任何两个都不太一样。但是第一个和第三个非常相似，因为第一个是Java代码而第三个是我们的静态语言代码，而第二个，是C++代码，和其它两个不同。清楚了吗？不清楚？很好，继续往下读！&lt;/p&gt;&lt;h2&gt;15.3.1.1 参数化类型&lt;/h2&gt;&lt;p&gt;我们所使用的编程语言已经展示了参数多态的价值，例如，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;函数的类型可以这样给出：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((&#39;a -&amp;gt; &#39;b) (listof &#39;a) -&amp;gt; (listof &#39;b))&lt;/code&gt;&lt;p&gt;意思是，对于任意类型&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;读入一个从&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;到&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;的函数，一个&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;的链表，生成对应的&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;的链表。这里，&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;不是具体的类型；它们是&lt;b&gt;类型变量&lt;/b&gt;（我们的术语中，这应该被称为“类型标识符”，因为它们在实例化过程中不会变化；但是我们还是使用传统术语）。&lt;/p&gt;&lt;p&gt;可以换种方式理解它：实际上有一族无穷多的这样的&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;函数。例如，其中一个&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;的类型是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((number -&amp;gt; string) (listof number) -&amp;gt; (listof string))&lt;/code&gt;&lt;p&gt;另一个的类型是这样的（没有限制说其中的类型必须是基本类型）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((number -&amp;gt; (number -&amp;gt; number)) (listof number) -&amp;gt; (listof (number -&amp;gt; number)))&lt;/code&gt;&lt;p&gt;还有这样的（也没有限制说&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;必须不同）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((string -&amp;gt; string) (listof string) -&amp;gt; (listof string))&lt;/code&gt;&lt;p&gt;以此类推。由于它们的类型不同，名字也需要不同：&lt;code class=&quot;inline&quot;&gt;map_num_str&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;map_num_num-&amp;gt;num&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;map_str_str&lt;/code&gt;等。但是这会让它们变成不同的函数，于是我们总得使用某个特定&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;，而不是直接使用比较一般的那个。&lt;/p&gt;&lt;p&gt;显然，不可能将所有这些函数放到我们的标准库中：毕竟它们有无穷多个！更好的方式是能按需获取我们需要的函数。我们的命名规则给出了一点提示：&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;接受两个&lt;b&gt;参数&lt;/b&gt;，它们都是&lt;b&gt;类型&lt;/b&gt;。给定了两个类型作为参数，我们可以得到针对特定类型的&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;函数。这种&lt;b&gt;类型的参数化&lt;/b&gt;被称为&lt;b&gt;参数多态&lt;/b&gt;。&lt;/p&gt;&lt;blockquote&gt;注意不要和对象“多态”搞混，后面会讨论它。&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;15.3.1.2 显式声明类型参数&lt;/h2&gt;&lt;p&gt;换句话说，我们相当于说&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;实际上是有四个参数的函数，其中两个是类型，另外两个是实际的值（函数和链表）。在需要显式声明类型的语言中，我们需要写成类似这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (map [a : ???] [b : ???] [f : (a -&amp;gt; b)] [l : (listof a)]) : (listof b)
  ...)&lt;/code&gt;&lt;p&gt;但是这会产生一些问题。首先，&lt;code class=&quot;inline&quot;&gt;???&lt;/code&gt;处应该填什么？它是&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;的类型。但是如果a和b本身将被&lt;b&gt;类型&lt;/b&gt;替换，那么类型的类型是什么？其次，我们真的希望每次调用map的时候传入四个参数吗？再者，我们真的希望在接收任何实际值之前先接收类型参数吗？对于这些问题的答案能延伸出关于多态类型系统巨大的讨论空间，其中的大部分我们这里将&lt;b&gt;不&lt;/b&gt;会涉及。&lt;/p&gt;&lt;blockquote&gt;推荐阅读Pierce的《Types and Programming Languages(类型和编程语言)》，获取易懂、现代的介绍。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;注意到一旦我们引入参数化，很多预期之外的代码都将被参数化。例如，考虑平平无奇的&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;函数的类型。它的类型需要基于链表中值的类型进行参数化（尽管它实际上并不依赖于这些值——稍后会解释这一点），于是每次使用&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;时都需要正确地进行类型实例化。说到这，即使用&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;创建空链表也必须类型实例化！当然，Java和C++程序员应该对这个痛点很熟悉了。&lt;/p&gt;&lt;h2&gt;15.3.1.3 一阶多态&lt;/h2&gt;&lt;p&gt;我们将只讨论这个空间中一个特别有用且易于理解的点上，也即 Standard ML 的类型系统、同时是本书使用的静态类型语言和早期版本的 &lt;br&gt;Haskell 的类型系统，有范型加成的 Java 和 C# 以及引入了模版的C++ &lt;br&gt;也差不多获得了这种类型系统的大部分能力。这类语言定义了被称为&lt;b&gt;谓词&lt;/b&gt;、&lt;b&gt;一阶&lt;/b&gt;或者叫&lt;b&gt;前缀&lt;/b&gt;多态的东西。关于上小节的问题它的答案是不填、没有、是。下面我们来探讨一下。&lt;/p&gt;&lt;p&gt;我们首先将类型的世界分成两组。第一组包含我们目前用到的静态类型语言，另外加上类型变量；它们被称为 &lt;b&gt;monotype（单型）&lt;/b&gt;。第二组包含参数化的类型，被称为 &lt;b&gt;polytype（多型）&lt;/b&gt;；按惯例它们是这样写的：&lt;code class=&quot;inline&quot;&gt;∀&lt;/code&gt;前缀，一组类型变量，再跟一个类型表达式，表达式中可以使用这些类型变量。因此，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;的类型将写作：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;∀ a, b : ((&#39;a -&amp;gt; &#39;b) (listof &#39;a) -&amp;gt; (listof &#39;b))&lt;/code&gt;&lt;p&gt;由于“&lt;code class=&quot;inline&quot;&gt;∀&lt;/code&gt;”是逻辑符号“对于所有的”的意思，于是上面的东西可以读作：“对于所有类型&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;的类型为……”。&lt;/p&gt;&lt;p&gt;在一阶多态（rank-1 polymorphism）中，类型变量只能被&lt;code class=&quot;inline&quot;&gt;monotype&lt;/code&gt;替换。（此外，它们只能被具体类型替换，否则剩下的类型变量将无法被替换掉。）因此，在类型变量参数和常规参数之间我们有了明确的界线。我们不需要为类型变量提供“类型注解”，因为我们知道它们可以是什么。这样得到的语言相对简洁，但仍提供了相当的表达能力。&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;非直谓性&lt;/b&gt;语言（&lt;a href=&quot;https://en.wikipedia.org/wiki/Impredicativity&quot;&gt;Impredicative&lt;/a&gt; language）取消了&lt;code class=&quot;inline&quot;&gt;monotype&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;polytype&lt;/code&gt;的区别，因此类型变量可以使用另一个多态类型实例化。&lt;/blockquote&gt;&lt;p&gt;注意到由于类型变量只能被&lt;code class=&quot;inline&quot;&gt;monotype&lt;/code&gt;替换，他们全相互对立。于是，类型参数可以全被提到参数表的前面。这使我们可以使用形如&lt;code class=&quot;inline&quot;&gt;∀ tv, ... : t&lt;/code&gt;的类型，其中&lt;code class=&quot;inline&quot;&gt;tv&lt;/code&gt;是类型变量，&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;monotype&lt;/code&gt;（其中可以引用这些类型变量）。此语法的意义就在这里，这也是之前称其为前缀多态的原因。而且后面也将看到这对其实现也很有用。&lt;/p&gt;&lt;h2&gt;15.3.1.4 通过去语法糖实现一阶多态解释器&lt;/h2&gt;&lt;p&gt;该特性最简单的实现就是将其视为一种去语法糖的形式：C++ 实际上就是这么做的。（具体来说，因为 C++ 有一个叫做模版的宏系统，所以使用模版，它非常巧合地达成了一阶多态。）举个例子，如果我们有一个语法形式&lt;code class=&quot;inline&quot;&gt;define-poly&lt;/code&gt;，它接收名字、类型变量和表达式。当传入类型的时候，它将表达式中对应类型变量替换为此类型，因此：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-poly (id t) (lambda ([x : t]) : t x))&lt;/code&gt;&lt;p&gt;通过将&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;定义为多态的方式定义了一个恒等（identity）函数：给&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;传入递任意具体类型，就得到一个单参数的类型为&lt;code class=&quot;inline&quot;&gt;(t -&amp;gt; t)&lt;/code&gt;的函数（其中&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;被替换）。我们可以使用各种类型实例化&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define id_num (id number))
(define id_str (id string))&lt;/code&gt;&lt;p&gt;从而获得针对这些类型的恒等函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (id_num 5) 5)
(test (id_str &quot;x&quot;)  &quot;x&quot;)&lt;/code&gt;&lt;p&gt;与之相对，像&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(id_num &quot;x&quot;)
(id_str 5)&lt;/code&gt;&lt;p&gt;这样的表达式将&lt;b&gt;不能通过类型检查&lt;/b&gt;（而不是运行时出错）。&lt;/p&gt;&lt;p&gt;如果你好奇的话，下面给出了实现。简单起见，我们假设只有一个类型参数；很容易使用&lt;code class=&quot;inline&quot;&gt;...&lt;/code&gt;实现多个参数的情形。我们不仅将&lt;code class=&quot;inline&quot;&gt;define-poly&lt;/code&gt;定义为宏，&lt;b&gt;它&lt;/b&gt;还会定义宏：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax define-poly
  (syntax-rules ()
    [(_ (name tyvar) body)
     (define-syntax (name stx)
       (syntax-case stx ()
         [(_ type)
          (with-syntax ([tyvar #&#39;type])
            #&#39;body)]))]))&lt;/code&gt;&lt;p&gt;因此，对于：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-poly (id t) (lambda ([x : t]) : t x))&lt;/code&gt;&lt;p&gt;该语言将创建名为&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的&lt;b&gt;宏&lt;/b&gt;：对应&lt;code class=&quot;inline&quot;&gt;(define-syntax (name ...) ...)&lt;/code&gt;的部分（对于这个例子，&lt;code class=&quot;inline&quot;&gt;name&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;）。&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的一个实例，如&lt;code class=&quot;inline&quot;&gt;(id number)&lt;/code&gt;，将类型变量&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;、宏里面的&lt;code class=&quot;inline&quot;&gt;typvar&lt;/code&gt;替换成给定的类型。因为要规避卫生，我们用&lt;code class=&quot;inline&quot;&gt;with-syntax&lt;/code&gt;来确保所有对于类型变量（typvar）的使用被替换为给定的类型。因此，实际效果是，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define id_num (id number))&lt;/code&gt;&lt;p&gt;被转换成了&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define id_num (lambda ([x : number]) : number x))&lt;/code&gt;&lt;p&gt;然而这种方式有两个重大局限性：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;来试试定义递归的多态函数，比如说&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;。之前我们说过，每个多态值（例如&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;）都需要类型实例化，但是为了简洁起见我们将依赖静态类型语言实现这点，而仅专注于&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;的类型参数。对应代码是：&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;(define-poly (filter t)&lt;br&gt;  (lambda ([f : (t -&amp;gt; boolean)] [l : (listof t)]) : (listof t)&lt;br&gt;    (cond&lt;br&gt;      [(empty? l) empty]&lt;br&gt;      [(cons? l) (if (f (first l))&lt;br&gt;                     (cons (first l)&lt;br&gt;                           ((filter t) f (rest l)))&lt;br&gt;                     ((filter t) f (rest l)))])))&lt;/p&gt;&lt;blockquote&gt;注意到递归的使用&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;时，必须使用恰当的类型对其实例化。&lt;/blockquote&gt;&lt;p&gt;上面的定义完全正确，只有一个问题，当我们尝试使用它时——如：&lt;/p&gt;&lt;p&gt;(define filter_num (filter number))&lt;/p&gt;&lt;blockquote&gt;DrRacket 将不会终止，更准确的说，是宏展开不会终止，因为它将不断的尝试创建&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;&lt;b&gt;代码的副本&lt;/b&gt;。不过如果用下面这种方式定义该函数，展开会终止——&lt;/blockquote&gt;&lt;p&gt;(define-poly (filter2 t)&lt;br&gt;  (letrec ([fltr&lt;br&gt;            (lambda ([f : (t -&amp;gt; boolean)] [l : (listof t)]) : (listof t)&lt;br&gt;              (cond&lt;br&gt;                [(empty? l) empty]&lt;br&gt;                [(cons? l) (if (f (first l))&lt;br&gt;                               (cons (first l) (fltr f (rest l)))&lt;br&gt;                               (fltr f (rest l)))]))])&lt;br&gt;    fltr))&lt;/p&gt;&lt;blockquote&gt;但是这给开发人员徒增了不必要的痛苦。实际上，一些模版展开程序会缓存之前展开的值，避免对于相同的参数反复生成代码。（Racket &lt;br&gt;做不到这点，因为一般来说，宏表达式可以依赖可变变量和值，甚至可以执行输入输出，因此 Racket 无法保证同样的输入表达式总是产生相同输出。）&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;考虑恒等函数的两个实例。我们无法比较&lt;code class=&quot;inline&quot;&gt;id_num&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;id_str&lt;/code&gt;，因为它们类型不同，但即使它们类型相同，使用&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;比较它们也不同：&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;(test (eq? (id number) (id number)) #f)&lt;/p&gt;&lt;blockquote&gt;这是因为对&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;每次实例化都会创建一份新的代码副本。即使使用了上面提到的优化，&lt;b&gt;同一种&lt;/b&gt;类型对应代码只有一份副本，但是不同类型的对应代码体还是会被重新生成【注释】——但这也是没必要的！例如，&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的实现的部分其实没任何东西依赖于参数的类型。实际上，&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;这一族无穷多个的函数可以共享同一个实现。简单的去语法糖策略实现不了这点。&lt;/blockquote&gt;&lt;p&gt;事实上，&lt;code class=&quot;inline&quot;&gt;C++&lt;/code&gt;模版因代码膨胀的问题而臭名昭著，这是原因之一。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;换种说法，基于去语法糖的策略本质上是使用替换的实现方式，它有着和我们之前函数调用时使用替换的方式实现相同的问题。不过，其它情况下，替换策略能达成我们关于程序行为的期望；对于多态也是一样，正如我们将看到的一样。&lt;/p&gt;&lt;p&gt;注意去语法糖策略的一个好处就是它不需要类型检查器“理解”多态。我们的核心语言仍可以是单态的（monomorphic），所有的（一阶）多态完全由宏展开处理。这提供了一种廉价的将多态添加到语言中的策略，但正如C++所示，它也引入了很大的开销。&lt;/p&gt;&lt;p&gt;最后，虽然这里我们只关注了函数，但前面的讨论同样适用于数据结构。&lt;/p&gt;&lt;h2&gt;15.3.1.5 其它实现方式&lt;/h2&gt;&lt;p&gt;有些其他实现策略不会遇到此类问题。这里我们不会深入讲解它们，但是其中一些策略的本质就是上面提到过的“缓存”方法。因为可以确定的是，对于给定的同一组类型参数，应该得到相同的实现代码，不需要对相同的类型参数实例化多次。这避免了无限循环。如果我们检查了使用特定类型实例化的代码一次，后续相同类型参数的实例化结果就无需再进行类型检查（因为它不会发生改变）。此外，我们无需保留实例化后的源码：一旦我们检查了展开后的程序，就可以将其丢弃，运行时也只需要保留一份实例化的副本。这样可以避免上述纯去语法糖策略中讨论过的所有问题，同时保留它的好处。&lt;/p&gt;&lt;p&gt;其实我们有点过分了。静态类型的好处之一就是能选择更精确的运行时表示。例如，静态类型可以告诉我们用的是数是32位的还是64位的甚至1位的（也就是布尔值）。然后编译器可以利用位的布局方式（例如，32个布尔值可以**打包*进一个32位字）为每种表示生成专用代码。因此，在对每种使用的类型进行检查之后，多态实例化程序可以跟踪函数或数据结构使用时用到的特定类型，并将这些信息提供给编译器用于代码生成。这会导致生成相关函数的若干副本，彼此都互不&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;——但这么做有充分的理由，因为它们要执行的操作的确不同，所以这是正确的。&lt;/p&gt;&lt;h2&gt;15.3.1.6 关系型参数&lt;/h2&gt;&lt;p&gt;我们还需解决关于多态的最后一个细节。&lt;/p&gt;&lt;p&gt;早先我们说过像&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;这样的函数不依赖于其参数的具体值。这一点对&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;等也成立。&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;接收一个函数作为参数，当它们要对单个元素进行操作时，实际上使用该函数进行操作，即该函数负责做出如何处理元素的决定；&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;本身只是遵从该函数参数。&lt;/p&gt;&lt;p&gt;“检验”这种情况是否属实的一种方法是，替换不同类型的值链表及对应的函数作为参数。也就是说假设两组值之间有映射关系；我们根据此关系替换链表元素和参数函数。问题是，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;filter&lt;/code&gt;的输出结果是否可以通过该关系预测？如果对于某些输入，&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;的输出和关系预测的结果不同，这说明&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;肯定侦测了实际值并根据相关信息做出了处理。但事实上，这不会发生在&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;上，或者说实际上也不会发生在大多标准多态函数上。&lt;/p&gt;&lt;p&gt;遵从这类型关系准则的函数被称为&lt;b&gt;关系型参数&lt;/b&gt;（Relational Parametricity）【注释】。这是类型赋予我们的另一个非常强大的能力，因为它们告诉我们这种多态函数可以执行的操作很受限制：它们可以删除、复制或重新排列元素，但是不能考察这些元素，也不能对它们进行具体操纵。&lt;/p&gt;&lt;blockquote&gt;请参阅Wadler的《Theorems for Free!》和Reynolds的《Types, Abstraction and Parametric Polymorphism》。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;起初这听起来非常令人印象深刻（确实如此！），但细查，你可能会意识到这与经验并不一致。例如，在Java中，多态方法依然可以使用&lt;code class=&quot;inline&quot;&gt;instanceof&lt;/code&gt;在运行时检查、获得特定类型的值，并相应的改变行为。这种方法就不是关系型参数了！【注释】事实上，关系型参数也能被看作是语言弱点的一种表述：它只允许一组有限的操作。（你仍可以检查类型——但不能根据你获取的信息进行相关行动，这样检查就没有意义了。因此运行时系统如果想要模拟关系型参数，必须要移除类似&lt;code class=&quot;inline&quot;&gt;instanceof&lt;/code&gt;及它的替代行为：例如，对值进行加一操作并捕获异常以判断它是数。）然而，这是个非常优雅和令人吃惊的结果，显示了使用丰富类型系统能获得的强大程序推理能力。&lt;/p&gt;&lt;blockquote&gt;网上，你会经常发现这个属性被描述为函数不能检查其参数——这是不正确的。&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;15.3.2 类型推断&lt;/h2&gt;&lt;p&gt;手工书写每处多态类型的实例参数是一个令人沮丧的过程，很多版本的Java和C++用户可以证明这点。想象一下，每次使用&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt;时都需要传入类型参数是个什么场景！我们之所以能够避免这种命运，是因为我们的语言实现了&lt;b&gt;类型推断&lt;/b&gt;。这使我们可以编写定义：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (mapper f l)
  (cond
    [(empty? l) empty]
    [(cons? l) (cons (f (first l)) (mapper f (rest l)))]))&lt;/code&gt;&lt;p&gt;然后编程环境&lt;b&gt;自动&lt;/b&gt;声明&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; mapper
- ((&#39;a -&amp;gt; &#39;b) (listof &#39;a) -&amp;gt; (listof &#39;b))&lt;/code&gt;&lt;p&gt;它不仅是正确的类型，而且是非常一般的类型！从程序结构中派生出这种一般类型的过程感觉几乎就是魔法。我们来揭示其幕后。&lt;/p&gt;&lt;p&gt;首先，我们来了解类型推断做了什么。有些人错误的认为，有类型推断的语言无类型声明，其被类型推断取而代之了。这混淆了多个层面的东西。首先，即使在有类型推断的语言中，程序员仍被允许声明类型（并且为了文档更为清晰，通常会鼓励这样做——就像你之前被鼓励的一样）【注释】。此外，在没有这些声明的情况下，推断的实际&lt;b&gt;含义&lt;/b&gt;并不显明。&lt;/p&gt;&lt;blockquote&gt;有时（类型）推断是不可判定的，这时程序员别无选择只能声明某些类型。最后，显式的书写类型注解能够大大减少难以辨认的错误信息。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;相反，最好将底层语言看作需要完整地显式声明类型的——就如我们刚才研究的多态语言。然后我们说，在&lt;code class=&quot;inline&quot;&gt;:&lt;/code&gt;后类型注解部分可以留空，编程环境中的某个特性会为我们填充这些。（如果走得更远，我们可以丢弃&lt;code class=&quot;inline&quot;&gt;:&lt;/code&gt;及额外的修饰，它们都会被自动插入。因此，类型推断只是为用户提供的一种便利，减轻编写类型注解的负担，而底层的语言仍然是显式声明类型的。&lt;/p&gt;&lt;p&gt;我们怎么考虑类型推断做的是什么呢？假设我们有个表达式（或者程序）&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;，由显式声明类型语言书写：也就是说在任何需要类型注解的地方都有写出。现在假设我们擦除&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;中所有的类型注解，然后使用函数&lt;code class=&quot;inline&quot;&gt;infer&lt;/code&gt;将它们推断回来。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;code class=&quot;inline&quot;&gt;infer&lt;/code&gt;应该有何种属性？&lt;/blockquote&gt;&lt;p&gt;我们可以要求很多东西。其中之一为，它要产生和&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;原来恰好一样的注解。这在很多方面都是有问题的，尤其是当&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;本就不能通过类型检查的情况下，怎么能推断回它们（应该）是什么？你可能觉得这是个学究式的玩笑：毕竟，如果&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;本就不能通过类型检查，如果能在删除其注解之后还能还原回来呢？反正两者都不能通过类型检查，谁在乎啊？&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;这个推理正确吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;假设&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(lambda ([x : number]) : string x)&lt;/code&gt;&lt;p&gt;它显然不能通过类型检查。但是如果我们擦除类型注解——得到&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(lambda (x) x)&lt;/code&gt;&lt;p&gt;——这个函数显然可以合法地添加类型！因此，更合理的需求可以是，如果原始的&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;能通过类型检查，那么对应的使用了推导出的注解的版本也必须能。这种单向的含义的用途体现在两方面：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;它没有说&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;未通过类型检查应该怎样，也即它不会排除前述的类型推断算法，其会将例子中类型错误的恒等函数变成类型正确的。&lt;/li&gt;&lt;li&gt;更重要的是，它向我们保证，使用类型推断将不会使我们失去任何东西：之前能通过类型检测的程序不会被推断后而不能。这意味着我们可以在想要的地方显式添加类型注解，但不会被迫这样做。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;当然，这只在程序推断可判定的情况下才成立。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;我们还可能希望两者类型是相同的，但这不是能做到的：函数&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(lambda ([x : number]) : number x)&lt;/code&gt;&lt;p&gt;类型为&lt;code class=&quot;inline&quot;&gt;(number -&amp;gt; number)&lt;/code&gt;，而擦除类型注解后推导出的类型要一般得多。因此，将这些类型关联并给出类型相等的定义并不简单，尽管如此后面将简要讨论此问题。&lt;/p&gt;&lt;p&gt;有了这些准备，我们下面进入对类型推断机制的研究。最需要注意的地方，前述的简单递归下降的类型检查算法将不再起作用。它之前能起作用，是因为所有函数的边界处都有类型注解，所以我们下降进入函数体，同时用类型环境携带这些注解中包含的信息。没了这些注解，就不知如何递归下降了。&lt;/p&gt;&lt;p&gt;事实上，目前还不清楚哪个方向更合理。像上面&lt;code class=&quot;inline&quot;&gt;mapper&lt;/code&gt;的定义，各代码段之间互相影响。例如，从&lt;code class=&quot;inline&quot;&gt;empty?&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;cons?&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt;对&lt;code class=&quot;inline&quot;&gt;l&lt;/code&gt;的调用都可以看出它是链表。但是是什么的链表呢？从这些操作看不出来。然而，对于其每个（或者应该说，任意）&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;元素调用了&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;这点可以看出，链表成员的类型必须可以被传给&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;。同理，由&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;我们可以知道（&lt;code class=&quot;inline&quot;&gt;mapper&lt;/code&gt;的）返回表达式必须为链表。它的成员类型是什么呢？必须为&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的返回类型。最后，请注意最微妙的地方：当参数链表为空时，我们返回&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;而不是&lt;code class=&quot;inline&quot;&gt;l&lt;/code&gt;（这时我们是知道其被绑定到&lt;code class=&quot;inline&quot;&gt;empty&lt;/code&gt;）。使用前者，返回值的类型可能是任意类型的链表（仅受&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;返回类型的约束）；使用后者，返回的类型就被迫和参数链表的类型相同。&lt;/p&gt;&lt;p&gt;所有这些信息都包含在函数里。但是我们如何系统地提取出这些信息呢，而且使用的算法必须会终止，并满足前面陈述属性？我们分两步来做。首先，根据程序表达式&lt;b&gt;生成&lt;/b&gt;其必须要满足的类型&lt;b&gt;约束&lt;/b&gt;。然后，通过合并散布在函数体各处的约束、识别其中的不一致，最终&lt;b&gt;解决约束&lt;/b&gt;。每一步都相对简单，但是组合起来创造了魔力。&lt;/p&gt;&lt;h2&gt;15.3.2.1 约束生成&lt;/h2&gt;&lt;p&gt;我们最终的目标是给每个类型注解位置填入类型。将会证明，这也等同于找到每个&lt;b&gt;表达式&lt;/b&gt;的类型。简单想想就知道，这本来也是必要的：比如，在不知道函数体类型的情况下，如何能确定函数本身的类型？这也是足够的，因为如果每个表达式的类型都被计算得出，其中必然包括了那些需要被注解的表达式。&lt;/p&gt;&lt;p&gt;首先，我们需要生成（待解决的）约束。这一步会遍历程序源码，为每个表达式生成恰当的约束，最后返回这组约束。为了简单，使用递归下降的方式实现；它最终生成约束的&lt;b&gt;集合&lt;/b&gt;，所以原则上遍历和生成的顺序是无关紧要的——因此我们选择了相对简单的递归下降方式——当然，为了简单起见，我们使用链表表示这个集合。&lt;/p&gt;&lt;p&gt;约束是什么呢？就是关于表达式类型的陈述。此外，虽然变量绑定并不是表达式，但我们仍需计算其类型（因为函数需要参数和返回值类型）。一般来说，对于表达式的类型我们知道些什么呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;它和某些标识符的类型有关。&lt;/li&gt;&lt;li&gt;它和某些其它表达式的类型有关。&lt;/li&gt;&lt;li&gt;它是数。&lt;/li&gt;&lt;li&gt;它是函数，其定义域（domain）和值域（range）类型可能受到进一步的约束。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;因此，我们定义如下两个数据结构：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type Constraints
  [eqCon (lhs : Term) (rhs : Term)])

(define-type Term
  [tExp (e : ExprC)]
  [tVar (s : symbol)]
  [tNum]
  [tArrow (dom : Term) (rng : Term)])&lt;/code&gt;&lt;p&gt;接下来定义约束生成函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen&amp;gt; ::= ;约束生成

    (define (cg [e : ExprC]) : (listof Constraints)
      (type-case ExprC e
        &amp;lt;constr-gen-numC-case&amp;gt;
        &amp;lt;constr-gen-idC-case&amp;gt;
        &amp;lt;constr-gen-plusC/multC-case&amp;gt;
        &amp;lt;constr-gen-appC-case&amp;gt;
        &amp;lt;constr-gen-lamC-case&amp;gt;))&lt;/code&gt;&lt;p&gt;当表达式为数时，唯一能说的是，我们希望该表达式的类型为数类型：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-numC-case&amp;gt; ::=

    [numC (_) (list (eqCon (tExp e) (tNum)))]&lt;/code&gt;&lt;p&gt;听上去很微不足道，但我们不知道的是，其他包含它的表达式是什么。因此，某个更大的表达式可能会与此断言——这个表达式的类型必须是数型——相矛盾，从而导致类型错误。&lt;/p&gt;&lt;p&gt;对于标识符，我们只是简单地说，表达式的类型就是我们所期望该标识符应有的类型：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-idC-case&amp;gt; ::=

    [idC (s) (list (eqCon (tExp e) (tVar s)))]&lt;/code&gt;&lt;p&gt;如果上下文限制了其类型，该表达式的类型将自动受到限制，并且必须与上下文的期望一致。&lt;/p&gt;&lt;p&gt;加法是我们第一个遇到的上下文约束。对于加法表达式，首先需要确保我们生成（并返回）其两个子表达式的约束，而子表达式可以是复杂的。这两个约束中，我们期望什么？需要每个子表达式是数类型的。（如果其中一个子表达式不是数类型的，应该导致类型错误。）最后，我们断言整个表达式的类型为数。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-plusC/multC-case&amp;gt; ::=

    [plusC (l r) (append3 (cg l)
                          (cg r)
                          (list (eqCon (tExp l) (tNum))
                                (eqCon (tExp r) (tNum))
                                (eqCon (tExp e) (tNum))))]&lt;/code&gt;&lt;blockquote&gt;&lt;code class=&quot;inline&quot;&gt;append3&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;append&lt;/code&gt;的三参数版本。&lt;/blockquote&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;multC&lt;/code&gt;的情况与之相同，区别只在名字上。&lt;/p&gt;&lt;p&gt;下面我们来看另外两个有趣的情况，函数声明和调用。两种情况下我们都需要生成和返回子表达式的约束。&lt;/p&gt;&lt;p&gt;在函数定义中，函数的类型是函数（“箭头/arrow”）类型，其参数类型是形参的类型，其返回类型是函数体的类型。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-lamC-case&amp;gt; ::=

    [lamC (a b) (append (cg b)
                        (list (eqCon (tExp e) (tArrow (tVar a) (tExp b)))))]&lt;/code&gt;&lt;p&gt;最终，考虑函数调用。我们不能直接陈述函数调用的类型约束。不过，我们可以说，函数接受的参数类型必须和实际参数的类型相同，并且函数返回的类型就是调用表达式的类型。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;constr-gen-appC-case&amp;gt; ::=

    [appC (f a) (append3 (cg f)
                         (cg a)
                         (list (eqCon (tExp f) (tArrow (tExp a) (tExp e)))))]&lt;/code&gt;&lt;p&gt;完成了！我们已经完成约束的生成；现在只需解出它们。&lt;/p&gt;&lt;h2&gt;15.3.2.2 使用合一求解约束&lt;/h2&gt;&lt;p&gt;求解约束的过程也被称为&lt;b&gt;合一&lt;/b&gt;（unification）。合一器的输入是等式的集合，其中每个等式是变量到项（term）的映射，项的数据类型在上面定义了。注意到一点，我们实际上有&lt;b&gt;两&lt;/b&gt;种变量。&lt;code class=&quot;inline&quot;&gt;tvar&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;tExp&lt;/code&gt;都是“变量”，前者很明显，注意后者同样也是，因为我们需要求解此类表达式的类型。（另一种方式是为每个表达式引入新的类型变量，但我们仍需一种方法确定这些变量与表达式之间的对应关系，而现在这已经能通过对表达式进行&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;操作自动完成了。另外这会产生大得多的约束集，不好进行人工检查。）&lt;/p&gt;&lt;p&gt;就我们的目的而言，合一是为了是生成&lt;b&gt;替换&lt;/b&gt;（substitution），或者说将变量映射为不包含任何变量的项。这听起来应该很耳熟：我们有一组联立方程，其中每个变量都是线性使用的；这种方程组可以使用&lt;b&gt;高斯消元法&lt;/b&gt;求解。该情形中，我们清楚最终可能遇到缺少约束（under-constrained）或过度约束（over-constrained）的情况。这种事情同样也将发生这里。&lt;/p&gt;&lt;p&gt;合一算法会遍历约束集合。由于每个约束有两项，每个项有四种可能的类型，因此有十六种情况需要考虑。幸运的是，我们实际可以用比较少的代码覆盖这十六种情况。&lt;/p&gt;&lt;p&gt;算法从所有约束的集合和空替换开始。每个约束都会被处理一次，并从集合中删除，因此原则上终止判据应该非常简单，但是实际处理起来还有点小麻烦。随着约束被处理，替换集合会逐渐增长。当所有的约束都被处理完后，合一过程返回最后的替换集合。&lt;/p&gt;&lt;p&gt;对于给定的约束，合一器检查等式左边，如果它是变量，那么这时它就可以被消除了，合一器将该变量（等式）的右侧添加到替换中，为了真正完成消除，还需要将替换集中所有该变量的出现替换成该右侧。实践中，实现需要考虑效率；例如，使用可变值表示这些变量可以避免搜索—替换过程。然而我们可能需要进行回溯（我们在后面确实会需要），可变值表示也有缺点。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;注意到上面微妙的错误了吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;这个微妙的错误是，我们说合一器通过替换变量的所有实例来&lt;b&gt;消除&lt;/b&gt;它。不过，我们假设等式右侧不包含该变量的实例。不然的话，我们将得到循环定义，这将使替换变得不可能。出于这个原因，合一器会进行&lt;b&gt;出现检查&lt;/b&gt;（occurs check）：检查某个变量是否出现在等式两侧，如果是，则拒绝合一。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;构造一个其约束会触发出现检查的项。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;还记得&lt;code class=&quot;inline&quot;&gt;ω&lt;/code&gt;吗？&lt;/p&gt;&lt;p&gt;下面考虑合一的实现。惯例使用希腊字母&lt;code class=&quot;inline&quot;&gt;Θ&lt;/code&gt;表示替换。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type-alias Subst (listof Substitution))
(define-type Substitution
  [sub [var : Term] [is : Term]])

(define (unify [cs : (listof Constraints)]) : Subst
  (unify/Θ cs empty))&lt;/code&gt;&lt;p&gt;首先把简单的东西写出来：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ&amp;gt; ::=

    (define (unify/Θ [cs : (listof Constraints)] [Θ : Subst]) : Subst
      (cond
        [(empty? cs) Θ]
        [(cons? cs)
         (let ([l (eqCon-lhs (first cs))]
               [r (eqCon-rhs (first cs))])
           (type-case Term l
             &amp;lt;unify/Θ-tVar-case&amp;gt;
             &amp;lt;unify/Θ-tExp-case&amp;gt;
             &amp;lt;unify/Θ-tNum-case&amp;gt;
             &amp;lt;unify/Θ-tArrow-case&amp;gt;))]))&lt;/code&gt;&lt;p&gt;现在可以实现合一的核心了。我们需要一个辅助函数&lt;code class=&quot;inline&quot;&gt;extend-replace&lt;/code&gt;，其签名为&lt;code class=&quot;inline&quot;&gt;(Term Term Subst -&amp;gt; Subst)&lt;/code&gt;。它将执行出现检查，如果检查得出没有环路，则扩展替换集合，并将替换集合中所有出现的第一个项（第一个参数）替代为第二个项（第二个参数）。同样，我们假设&lt;code class=&quot;inline&quot;&gt;lookup: (Term subst -&amp;gt; (optionof Term))&lt;/code&gt;存在。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;定义&lt;code class=&quot;inline&quot;&gt;extend-replace&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;lookup&lt;/code&gt;。&lt;/blockquote&gt;&lt;p&gt;如果约束等式的左侧是个变量，我们先在替换集合中寻找它。如果存在，我们将当前约束换成新的约束；否则我们扩展替换集合。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ-tVar-case&amp;gt; ::=

    [tVar (s) (type-case (optionof Term) (lookup l Θ)
                [some (bound)
                      (unify/Θ (cons (eqCon bound r)
                                     (rest cs))
                               Θ)]
                [none ()
                      (unify/Θ (rest cs)
                               (extend+replace l r Θ))])]&lt;/code&gt;&lt;p&gt;同样的逻辑也适用于表达式的情况：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ-tExp-case&amp;gt; ::=

    [tExp (e) (type-case (optionof Term) (lookup l Θ)
                [some (bound)
                      (unify/Θ (cons (eqCon bound r)
                                     (rest cs))
                               Θ)]
                [none ()
                      (unify/Θ (rest cs)
                               (extend+replace l r Θ))])]&lt;/code&gt;&lt;p&gt;如果是基本类型，例如数，我们就需要检查等式右边。有四种可能：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果是数，那么该等式声明类型&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;等于&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;，这恒为真。因此我们可以忽略该约束——它没有告诉我们什么有用信息——继续检查剩下的。&lt;br&gt;当然，首先得解释为什么会出现这种约束。显然，我们的约束生成器不会生成这种约束。然而，前面替换集合的扩展会导致这种情况。事实是实践中我们会遇到好几个这种情况。&lt;/li&gt;&lt;li&gt;如果是函数类型，显然存在类型错误，因为数和函数类型不相交。同样，我们不会直接生成这样的约束，一定是由先前的替代产生。&lt;/li&gt;&lt;li&gt;它可能是两种变量类型之一。不过，我们的约束生成器经过了仔细的安排，不会将它们放在右侧。此外，替代过程也不会在右侧引入它们。因此，这两种情况不会发生。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;于是得出这样的代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ-tNum-case&amp;gt; ::=

    [tNum () (type-case Term r
               [tNum () (unify/Θ (rest cs) Θ)]
               [else (error &#39;unify &quot;number and something else&quot;)])]&lt;/code&gt;&lt;p&gt;最后还剩下函数类型。这里的论点几乎和数类型完全一样。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;unify/Θ-tArrow-case&amp;gt; ::=

    [tArrow (d r) (type-case Term r
                    [tArrow (d2 r2)
                            (unify/Θ (cons (eqCon d d2)
                                           (cons (eqCon r r2)
                                                 cs))
                                     Θ)]
                    [else (error &#39;unify &quot;arrow and something else&quot;)])]&lt;/code&gt;&lt;p&gt;请注意，我们并没有严格地缩小约束集合，因此仅通过约束集合的大小不足以判断这个过程会终止。需要同时综合考虑约束集合的大小以及替换的大小（包括其中变量的个数）。&lt;/p&gt;&lt;p&gt;上面的算法非常通用，不仅对数和函数，对于各种类型项也都适用。我们使用数代表各种基础类型；同样，使用函数代表各种构造类型，例如&lt;code class=&quot;inline&quot;&gt;listof&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;vectorof&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这就完成了。合一产生了替换。现在我们可以遍历这些替换，找到程序中所有表达式的类型，然后插入对应的类型注解。有定理（这里不证明）指出，上面过程的成功意味着程序通过了类型检查，因此我们无需对该程序显式地再跑一遍类型检查。&lt;/p&gt;&lt;p&gt;不过请注意，类型错误的性质在这里发生了巨大变化。之前，我们的递归下降算法利用类型环境遍历表达式。类型环境中的绑定是程序员定义的类型，因此可以被当作（期望的）权威的类型&lt;b&gt;规范&lt;/b&gt;（specification）。因此，所有的错误都应归咎于表达式，类型错误的报告很简单（而且很好懂）。然而这里，类型错误&lt;b&gt;无法通知&lt;/b&gt;。合一错误是两个智能算法——约束生成和合一——共同导致的，因此程序员不一定能理解。特别是，由于约束的本质是等式，报告的错误位置和“真实”的错误位置可能相差甚远。因此，生成更好的错误信息仍然是个活跃的研究领域。&lt;/p&gt;&lt;blockquote&gt;实践中，算法会维护涉及到的程序源码的元信息，并可能也会保存合一的历史，以便溯源错误回源程序。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;最后，请记住，约束可能不会精确指明所有变量的类型。如果方程组&lt;b&gt;过度&lt;/b&gt;约束，可能会有冲突，导致类型错误。如果&lt;b&gt;缺少&lt;/b&gt;约束，这意味着我们没有足够的信息对所有表达式做出明确的类型声明。例如，对于表达式&lt;code class=&quot;inline&quot;&gt;(lambda (x) x)&lt;/code&gt;，没有足够的约束指明&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型，从而无法以指明整个表达式的类型。这并非错误；它只是意味着&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;可以是&lt;b&gt;任意&lt;/b&gt;类型。换句话说，该表达式的类型是“&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型-&amp;gt;&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型”，无其它约束。这些欠约束标识符的类型以类型变量的方式展示，于是上面表达式的类型可以表示为&lt;code class=&quot;inline&quot;&gt;(&#39;a -&amp;gt; &#39;a)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;合一算法实际上有个很好的属性：它能自动计算表达式&lt;b&gt;最通用的类型&lt;/b&gt;，也被称为&lt;b&gt;主类型&lt;/b&gt;（principal type）。这就是说，表达式可以有的任何实际类型都可以通过（用实际类型）替换推导出的类型中的类型变量的得到。这是个异乎寻常的结果：没人能生成比前述算法得出的更为一般的类型！&lt;/p&gt;&lt;h2&gt;15.3.2.3 Let-多态&lt;/h2&gt;&lt;p&gt;很不幸，尽管这些类型变量表面上看和我们之前遇到的多态有诸多相似之处，但它们并不同。考虑下面的程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(let ([id (lambda (x) x)])
  (if (id true)
      (id 5)
      (id 6)))&lt;/code&gt;&lt;p&gt;如果加上显式的类型注解，它能通过类型检查：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(if ((id boolean) true)
    ((id number) 5)
    ((id number) 6))&lt;/code&gt;&lt;p&gt;然而，如果使用类型推断，它将不能通过类型检查！因为&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;中的类型&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;——取决于约束处理的顺序——要么和&lt;code class=&quot;inline&quot;&gt;boolean&lt;/code&gt;合一，要么和&lt;code class=&quot;inline&quot;&gt;number&lt;/code&gt;合一。对应的，那时&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的类型要么是&lt;code class=&quot;inline&quot;&gt;(boolean -&amp;gt; boolean)&lt;/code&gt;要么是&lt;code class=&quot;inline&quot;&gt;(number -&amp;gt; number)&lt;/code&gt;。当使用另一个类型调用&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;时，就会发生类型错误！&lt;/p&gt;&lt;p&gt;这是因为我们通过合一推断出来的类型实际并不是&lt;b&gt;多态的&lt;/b&gt;。这点很重要：将其称为类型变量不会使你获得多态!类型变量可以在下次使用时合一，彼时，最终得到的还只是单态函数。而真正的多态只有在能真正进行类型变量&lt;b&gt;实例化&lt;/b&gt;时才会获得。&lt;/p&gt;&lt;p&gt;所以在具有真正多态的语言中，约束生成和合一是不够的。相反，像ML和Haskell这种语言，甚至我们使用的静态类型语言也是，都实现了俗称&lt;b&gt;let-多态&lt;/b&gt;的东西。这种策略中，当包含类型变量的项在词法环境中被绑定时，该类型被自动提升为量化类型。每次使用时，该项被自动实例化。&lt;/p&gt;&lt;p&gt;很多实现策略可以做到这点。最简单（而不令人满意）的方式只需&lt;b&gt;复制&lt;/b&gt;绑定标识符代码的&lt;b&gt;代码&lt;/b&gt;；这样，上面每次&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;的使用都会得到自己的&lt;code class=&quot;inline&quot;&gt;(lambda (x) x)&lt;/code&gt;副本，所以每个都有它自己的类型变量。第一个的类型可能是&lt;code class=&quot;inline&quot;&gt;(&#39;a -&amp;gt; &#39;a)&lt;/code&gt;，第二个是&lt;code class=&quot;inline&quot;&gt;(&#39;b -&amp;gt; &#39;b)&lt;/code&gt;，第三个是&lt;code class=&quot;inline&quot;&gt;(&#39;c -&amp;gt; &#39;c)&lt;/code&gt;，等等。这些类型变量互不冲突，因此我们得到多态的效果。显然，这不仅增加了程序的大小，而且在存在递归的情况下也不起作用。然而，这给我们提供了通往更好解决方案的思路：不是复制代码，而是复制&lt;b&gt;类型&lt;/b&gt;。因此在每次使用时，我们创建推导出类型的重命名版本：第一次使用时，id的类型&lt;code class=&quot;inline&quot;&gt;(&#39;a -&amp;gt; &#39;a)&lt;/code&gt;变成了&lt;code class=&quot;inline&quot;&gt;(&#39;b -&amp;gt; &#39;b)&lt;/code&gt;，以此类推，这种方式实现了拷贝代码相同的效果且没有它的包袱。不过，因为这些策略实质都是效仿代码拷贝，因此它们只能在词法环境下工作。&lt;/p&gt;</description>
<author>MrMathematica</author>
<guid isPermaLink="false">2018-03-30-35115633</guid>
<pubDate>Fri, 30 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Java and Scala’s Type Systems are Unsound</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-30-35055185.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35055185&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d7db8335a8c05f576678c6d1e81f5b2c_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;Java and scala&#39;s type systems are unsound: the existential crisis of null pointers, OOPSLA 2016&lt;/p&gt;&lt;p&gt;作者：Nada Amin, Ross Tate&lt;/p&gt;&lt;a href=&quot;https://dl.acm.org/citation.cfm?id=2984004&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-de6f855e8c8fd69721e406b388e10b4b&quot; data-image-width=&quot;132&quot; data-image-height=&quot;171&quot; data-image-size=&quot;120x160&quot;&gt;Java and scala&#39;s type systems are unsound: the existential crisis of null pointers&lt;/a&gt;&lt;p&gt;Paper: &lt;a href=&quot;https://raw.githubusercontent.com/namin/unsound/master/doc/unsound-oopsla16.pdf&quot;&gt;https://raw.githubusercontent.com/namin/unsound/master/doc/unsound-oopsla16.pdf&lt;/a&gt;&lt;/p&gt;&lt;p&gt;摘要：&lt;/p&gt;&lt;blockquote&gt;We present short programs that demonstrate the unsoundness of Java and Scala&#39;s current type systems. In particular, these programs provide parametrically polymorphic functions that can turn any type into any type without (down)casting. Fortunately, parametric polymorphism was not integrated into the Java Virtual Machine (JVM), so these examples do not demonstrate any unsoundness of the JVM. Nonetheless, we discuss broader implications of these findings on the field of programming languages.&lt;/blockquote&gt;&lt;p&gt;本文作者展示了一些Java和Scala类型系统unsound的问题。&lt;/p&gt;&lt;p&gt;Java和Scala的类型系统使用了参数化多态（parametric polymorphism），因此允许带参数的函数根据参数来实现类型转换。作者同时指出因为JVM没有引入参数化多态，JVM不受此影响。最后，作者揭示了这样的问题在程序语言的设计上有着更大的影响。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;2004年，Java 5 引入了泛型（generics）——参数化多态；同年Scala发布，发布了path-dependent type的特性。在发布之初，二者的类型系统都是unsound的。尽管诸多PL研究者对于Java的类型系统进行研究，并将其形式化，作者还是发现了Java类型系统unsound的地方。&lt;/p&gt;&lt;p&gt;作者指出，诸多研究者在研究一门复杂的语言的时候，选择使用一些简化的模型来进行抽象，并验证这个模型的某个核心功能，却忽视了不同的特性交织在一起的时候产生的效果。本文所发现的unsound的例子则是多个特性进行叠加之后的结果。&lt;/p&gt;&lt;p&gt;先上例子：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;class Unsound {
  static class Constrain&amp;lt;A, B extends A&amp;gt; {}
  static class Bind&amp;lt;A&amp;gt; {
    &amp;lt;B extends A&amp;gt;
    A upcast(Constrain&amp;lt;A,B&amp;gt; constrain, B b) {
      return b;
    }
  }
  static &amp;lt;T,U&amp;gt; U coerce(T t) {
    Constrain&amp;lt;U,? super T&amp;gt; constrain = null;
    Bind&amp;lt;U&amp;gt; bind = new Bind&amp;lt;U&amp;gt;();
    return bind.upcast(constrain, t);
  } 
  public static void main(String[] args) {
    String zero = Unsound.&amp;lt;Integer,String&amp;gt;coerce(0);
  }
}&lt;/code&gt;&lt;p&gt;Java 8运行结果（&lt;code class=&quot;inline&quot;&gt;ClassCastException&lt;/code&gt;）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ javac -version
javac 1.8.0_151
$ javac Unsound.java
$ java Unsound
Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String
	at Unsound.main(Unsound.java:15)&lt;/code&gt;&lt;p&gt;Java 9运行结果（无法编译）：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;$ javac -version
javac 9.0.1
$ javac Unsound.java
Unsound.java:12: error: method upcast in class Bind&amp;lt;A&amp;gt; cannot be applied to given types;
    return bind.upcast(constrain, t);
               ^
  required: Constrain&amp;lt;U,B&amp;gt;,B
  found: Constrain&amp;lt;U,CAP#1&amp;gt;,T
  reason: inference variable B has incompatible bounds
    upper bounds: U
    lower bounds: T
  where U,T,B,A are type-variables:
    U extends Object declared in method &amp;lt;T,U&amp;gt;coerce(T)
    T extends Object declared in method &amp;lt;T,U&amp;gt;coerce(T)
    B extends U declared in method &amp;lt;B&amp;gt;upcast(Constrain&amp;lt;A,B&amp;gt;,B)
    A extends Object declared in class Bind
  where CAP#1 is a fresh type-variable:
    CAP#1 extends U super: T from capture of ? super T
1 error&lt;/code&gt;&lt;p&gt;（传送门：&lt;a href=&quot;http://io.livecode.ch/learn/namin/unsound&quot;&gt;The Unsound Playground&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;由于笔者不会写Scala（捂脸），所以就主要讨论Java部分了。等什么时候学会了Scala再来补一下Scala部分吧（flag）。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;我们跟着作者的思路来重现这个例子的构建过程。&lt;/p&gt;&lt;p&gt;首先我们需要编写一个程序实现两个类之类的任意转换。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;class A {}
class B {}
class Unsound {
  &amp;lt;V, W&amp;gt; V magic(W w) {
    // TODO
  }
  public static void main(String[] args) {
    Unsound u = new Unsound();
    A surprise = u.&amp;lt;A, B&amp;gt;magic(new B()); // 把B转换到A
  }
}&lt;/code&gt;&lt;p&gt;在&lt;code class=&quot;inline&quot;&gt;magic&lt;/code&gt;方法里，我们需要一个&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;的实例，但我们只有一个&lt;code class=&quot;inline&quot;&gt;W&lt;/code&gt;的实例，显然我们没有办法完成给定的任务。但是我们可以使用通配符给类型进行限制，然后进行安全的向上类型转换（upcast）。&lt;/p&gt;&lt;p&gt;因此，我们引入&lt;code class=&quot;inline&quot;&gt;Constrain&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;Bind&lt;/code&gt;两个类来帮我们完成任务。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;class Constrain&amp;lt;X, Y extends X&amp;gt; {}
class Bind&amp;lt;Z&amp;gt; {
  &amp;lt;U extends Z&amp;gt; Z
  upcast(Constrain&amp;lt;Z, U&amp;gt; constrain, U u) { return u; }
}&lt;/code&gt;&lt;p&gt;注意此处两个类通配符的限制：在&lt;code class=&quot;inline&quot;&gt;Constrain&lt;/code&gt;类中，&lt;code class=&quot;inline&quot;&gt;Y&lt;/code&gt;需要是&lt;code class=&quot;inline&quot;&gt;X&lt;/code&gt;的子类。在&lt;code class=&quot;inline&quot;&gt;Bind&lt;/code&gt;类中，我们可以通过&lt;code class=&quot;inline&quot;&gt;Constrain&lt;/code&gt;类将&lt;code class=&quot;inline&quot;&gt;U&lt;/code&gt;类的实例安全的向上转换到Z类。&lt;/p&gt;&lt;p&gt;那么，我们可以用上面的两个类来实现我们的&lt;code class=&quot;inline&quot;&gt;magic&lt;/code&gt;方法。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;V, W&amp;gt; V magic(W w) {
  Constrain&amp;lt;???&amp;gt; constrain = ???; //TODO
  Bind&amp;lt;V&amp;gt; bind = new Bind&amp;lt;V&amp;gt;();
  return bind.upcast(constrain, w);
}&lt;/code&gt;&lt;p&gt;通过找到一个合适的&lt;code class=&quot;inline&quot;&gt;Constrain&lt;/code&gt;类实例和参数，我们可以通过&lt;code class=&quot;inline&quot;&gt;Bind&lt;/code&gt;类将&lt;code class=&quot;inline&quot;&gt;W&lt;/code&gt;类向上转换到&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;类，那么剩下要做的就是找出合适的参数了。&lt;/p&gt;&lt;p&gt;我们假定&lt;code class=&quot;inline&quot;&gt;Constrain&lt;/code&gt;类的参数为&lt;code class=&quot;inline&quot;&gt;&amp;lt;T1, T2&amp;gt;&lt;/code&gt;，值为&lt;code class=&quot;inline&quot;&gt;val&lt;/code&gt;。那么我们需要寻找的则是使下列条件满足的实例：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Constrain&amp;lt;T1, T2&amp;gt;&lt;/code&gt; 是一个合法的类型&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;bind.upcast&lt;/code&gt;可以通过类型检查&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;val&lt;/code&gt;满足&lt;code class=&quot;inline&quot;&gt;Constrain&amp;lt;T1, T2&amp;gt;&lt;/code&gt;的类型限制&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们选择&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Constrain&amp;lt;V, ? super W&amp;gt; constrain = null;&lt;/code&gt;&lt;p&gt;来满足上述要求。&lt;/p&gt;&lt;p&gt;首先，&lt;code class=&quot;inline&quot;&gt;Constrain&amp;lt;V, ? super W&amp;gt;&lt;/code&gt; 是一个合法的类型，这个类型中使用了一个带下界的通配符。通过&lt;code class=&quot;inline&quot;&gt;? super W&lt;/code&gt;，我们得知通配符类型是&lt;code class=&quot;inline&quot;&gt;W&lt;/code&gt;的母类；又因为定义中要求的&lt;code class=&quot;inline&quot;&gt;Y extends X&lt;/code&gt;，所以通配符类型是&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;的子类。在检查类型是否合法时，并不会检查是否有类型实例能满足给定的限制，因此使用通配符可以让我们避免给定一个满足限制的实例。&lt;/p&gt;&lt;p&gt;我们其次考虑&lt;code class=&quot;inline&quot;&gt;bind.upcast&lt;/code&gt;。我们显式地定义了&lt;code class=&quot;inline&quot;&gt;Bind&lt;/code&gt;类的类型参数为&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;，因此假设&lt;code class=&quot;inline&quot;&gt;Constrain&lt;/code&gt;的类型参数为&lt;code class=&quot;inline&quot;&gt;&amp;lt;V, Z&amp;gt;&lt;/code&gt;，其中&lt;code class=&quot;inline&quot;&gt;Z&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;的子类，那么正如前文中所说的做法，我们就可以使用&lt;code class=&quot;inline&quot;&gt;bind.upcast&lt;/code&gt;来将&lt;code class=&quot;inline&quot;&gt;Z&lt;/code&gt;的值向上转换至&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;。但是，我们注意到此处&lt;code class=&quot;inline&quot;&gt;Constrain&lt;/code&gt;的类型中带有一个通配符，因此类型系统必须推导一个类型来实现我们定义的上述限制。&lt;/p&gt;&lt;p&gt;类型系统的推导过程由收集所有对于类型的假设和必需的要求开始，其次试图找到一个满足限制的类型。&lt;/p&gt;&lt;p&gt;我们假设需要推导的通配符类型为&lt;code class=&quot;inline&quot;&gt;X&lt;/code&gt;。从上文我们得知，&lt;code class=&quot;inline&quot;&gt;X&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;W&lt;/code&gt;的母类，是&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;的子类。&lt;/p&gt;&lt;p&gt;在定义中，&lt;code class=&quot;inline&quot;&gt;bind.upcast&lt;/code&gt;的第一个参数的类型为&lt;code class=&quot;inline&quot;&gt;Constrain&amp;lt;V, U&amp;gt;&lt;/code&gt;（显式指定了&lt;code class=&quot;inline&quot;&gt;Z&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;），实际类型为&lt;code class=&quot;inline&quot;&gt;Constrain&amp;lt;V, X&amp;gt;&lt;/code&gt;。第二个参数的类型为&lt;code class=&quot;inline&quot;&gt;U&lt;/code&gt;，实际类型为&lt;code class=&quot;inline&quot;&gt;W&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我们可以得出以下限制：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;U&lt;/code&gt; = &lt;code class=&quot;inline&quot;&gt;X&lt;/code&gt; -  通过归一&lt;code class=&quot;inline&quot;&gt;Constrain&amp;lt;V, U&amp;gt;&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;Constrain&amp;lt;V, X&amp;gt;&lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;W&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;U&lt;/code&gt;的子类  -  通过第二个参数的类型，&lt;code class=&quot;inline&quot;&gt;w&lt;/code&gt;必须可以被转换到&lt;code class=&quot;inline&quot;&gt;U&lt;/code&gt;类&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;U&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;的子类  -  函数定义中&lt;code class=&quot;inline&quot;&gt;U extends Z&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;Z&lt;/code&gt;被显式指定为&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;因为有限制（1）的存在，我们将限制（2）（3）中的U替换成X。在类型推导中，通配符给定的限制并不是限制，而是假设。因此限制（2）（3）可以被通配符类型来满足，所以&lt;code class=&quot;inline&quot;&gt;bind.upcast&lt;/code&gt;可以通过类型检查。&lt;/p&gt;&lt;p&gt;另外需要注意的是，尽管Java的类型参数推导是不可决定的（undecidable），Java 8的编译器成功地编译了上面的代码，而Java 9却无法编译。作者提到了类型推导是不确定的（non-deterministic），并认为Java 9先考虑了限制（2）（3）。由于子类关系是传递性的，那么&lt;code class=&quot;inline&quot;&gt;W&lt;/code&gt;必须是&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;的子类，而这个关系是不满足的，因此发生了编译错误。作者后续给出了其他Java 9的例子，可以通过编译，但是在运行时会抛出异常。（传送门里有其他例子）&lt;/p&gt;&lt;p&gt;第三步，则是找到一个合适的值。如果说我们没有办法提供一个&lt;code class=&quot;inline&quot;&gt;constrain&lt;/code&gt;的值，那么上面的例子就没有办法实现我们需要的功能。但是我们需要注意到，假设我们需要给定这个值，我们必须要找到一个类型来满足通配符中所要求的子类关系（即通配符中的类型是&lt;code class=&quot;inline&quot;&gt;W&lt;/code&gt;的母类，是&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;的子类），可这是没有办法做到的。幸运的是/不幸的是，在Java里，&lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt; 可以做任何引用类型的值。在这一步，我们就可以跳过寻找通配符类型的过程，但仍然通过类型检查。&lt;/p&gt;&lt;p&gt;至此，我们成功的构造了在Java类型系统容许下的任意类型之间的相互转换。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;作者分三方面来阐述这个例子带来的启示：&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）荒谬的类型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;假设我们拥有一个类型&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;是Top type的supertype，亦是Bottom type的subtype，那么我们即可通过此类型&lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt;来实现任何类型之间的转换，如：&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;String&lt;/code&gt; &amp;lt;: &lt;code class=&quot;inline&quot;&gt;Top&lt;/code&gt; &amp;lt;: &lt;code class=&quot;inline&quot;&gt;V&lt;/code&gt; &amp;lt;: &lt;code class=&quot;inline&quot;&gt;Bottom&lt;/code&gt; &amp;lt;: &lt;code class=&quot;inline&quot;&gt;Integer&lt;/code&gt;&lt;/p&gt;&lt;p&gt;然而作者指出，使用算法来鉴别荒谬的类型是非常困难的。由于subtyping需要算法来实现，而类型验证亦需要算法实现。要成功地识别出荒谬的类型，二者之间会存在一些需要解决的循环依赖，给实现增加难度。 &lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）&lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt; —— the billion dollar mistake&lt;/b&gt;&lt;/p&gt;&lt;p&gt;作者指出了&lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt;在类型系统的中潜在的危害性。随着类型系统的逐步成熟，&lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt;的存在会给设计者带来更多需要考虑的地方。在本文中的例子里，我们通过&lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt;来跳过重要的推导步骤，实现任意类型之间的转换。在Java中&lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt;可以表示任何引用类型的值，在设计类型规则的时候，需要在此加以注意。 &lt;/p&gt;&lt;p&gt;&lt;b&gt;（3）没有预见的特性交互&lt;/b&gt;&lt;/p&gt;&lt;p&gt;作者指出了对于一门被众多人使用、特性丰富的语言，研究者很难做到将每个功能都正规化，然后将其验证。因此诸多研究者把Java的语言的核心部分形式化，并逐步迭代加入新的特性。但是在将Java语言取核心部分最小化成形式语言的过程中，会不会遗漏一些特性，使其与其他特性交互时，产生没有预见的效果。作者在此段从方法、验证、价值观和审阅、发表流程的角度来反思PL社群在这个方面需要额外注意的地方。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;参考资料：&lt;br&gt;&lt;a href=&quot;https://dev.to/rosstate/java-is-unsound-the-industry-perspective&quot;&gt;Java is Unsound: The Industry Perspective&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Lecture Notes of &lt;i&gt;Advanced Issues in Object-Oriented Programming&lt;/i&gt; by Sophia Drossopoulou&lt;/p&gt;&lt;hr&gt;&lt;p&gt;写在最后的话：&lt;/p&gt;&lt;p&gt;试着做一个类似于morning paper的读paper个人专栏，然而试了以后发现很艰难，花了挺长时间的。希望会是一个比较好的尝试，会有人来读我的个人专栏。欢迎评论留言讨论。不定期更新。下一篇paper暂时考虑写关于session type相关的内容。&lt;/p&gt;</description>
<author>由里子</author>
<guid isPermaLink="false">2018-03-30-35055185</guid>
<pubDate>Fri, 30 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Idris 教程中文版正式发布</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-28-35015527.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35015527&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c5246a546163f0bbfd814b28a1dcf606_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;经过一个月（并不）紧张的翻译和校对，&lt;a href=&quot;http://idris-zh.readthedocs.io/zh_CN/latest/tutorial/index.html&quot;&gt;Idris 教程&lt;/a&gt; 正式发布。 自此，官方文档的翻译暂时告一段落。&lt;a href=&quot;http://idris-zh.readthedocs.io/zh_CN/latest/st/index.html&quot;&gt;ST 教程&lt;/a&gt; 的翻译仍在进行中。&lt;/p&gt;&lt;p&gt;官方文档中还有 FAQ、Effect 教程、定理证明和语言参考尚未翻译，然而咱目前又有了别的计划（没错 Idris-zh 又坑了），于是甩锅给社区自然发展好了= =||&lt;/p&gt;&lt;p&gt;Idris 虽然非常漂亮，然而发展还不成熟，缺少一些常用的库和工具。目前她还十分小众，因此 Type-Driven Development with Idris 中文版的引进估计是不可能了。官方教程涉及的点较少，有些不够深入，对初学者也不如这本书友好。因此有条件和能力的读者建议读一下这本书。&lt;/p&gt;&lt;p&gt;如果你有兴趣继续参与翻译，欢迎直接戳咱，随时恭候~！&lt;/p&gt;</description>
<author>Oling Cat</author>
<guid isPermaLink="false">2018-03-28-35015527</guid>
<pubDate>Wed, 28 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（九）：Let polymorphism</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-26-34915143.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34915143&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d8893deacbd14601cc4881797561323d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;500&quot;&gt;&lt;h2&gt;&lt;b&gt;类型变量&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;到目前为止，我们遇到的每一个 &lt;equation&gt;\lambda&lt;/equation&gt; 项都有唯一确定的类型，&lt;br&gt;因为，项的类型都被显式的注释在了它的后面。&lt;br&gt;例如，我们可以定义一个恒等函数 &lt;equation&gt;id=\lambda x:Nat.~x:Nat\to Nat&lt;/equation&gt; ，&lt;br&gt;则 &lt;equation&gt;id&lt;/equation&gt; 的类型就是固定的， &lt;equation&gt;Nat\to Nat&lt;/equation&gt; ，而 &lt;equation&gt;id~true&lt;/equation&gt; 就不是良类型的。&lt;/p&gt;&lt;p&gt;为每一个类型的恒等函数都定义各自的版本，是非常繁琐的，&lt;br&gt;因此，一个自然的想法是，我们能否让 &lt;equation&gt;id&lt;/equation&gt; 的类型&lt;b&gt;参数化&lt;/b&gt;，&lt;br&gt;让它在不同的上下文中，实例化为不同的具体类型。&lt;br&gt;例如， &lt;equation&gt;id=\lambda x:X.~x:X\to X&lt;/equation&gt; ，其中 &lt;equation&gt;X&lt;/equation&gt; 是&lt;b&gt;类型参量&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;类型代换&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;类型代换&lt;/b&gt; &lt;equation&gt;\sigma&lt;/equation&gt; ，指的是一个从类型变量到类型的有限映射。&lt;br&gt;例如， &lt;equation&gt;\sigma=[X\mapsto T,Y\mapsto U]&lt;/equation&gt; ，会将类型变量 &lt;equation&gt;X,Y&lt;/equation&gt; 分别代换为 &lt;equation&gt;T,U&lt;/equation&gt; 。&lt;br&gt;其中， &lt;equation&gt;X,Y&lt;/equation&gt; 称为代换 &lt;equation&gt;\sigma&lt;/equation&gt; 的&lt;b&gt;定义域&lt;/b&gt;，记为 &lt;equation&gt;dom(\sigma)&lt;/equation&gt; ，&lt;br&gt;而 &lt;equation&gt;T,U&lt;/equation&gt; 称为代换 &lt;equation&gt;\sigma&lt;/equation&gt; 的&lt;b&gt;值域&lt;/b&gt;，记为 &lt;equation&gt;range(\sigma)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;值得一提的是，所有的代换都是同时进行的， &lt;equation&gt;\sigma=[X\mapsto Bool,Y\mapsto X\to X]&lt;/equation&gt; ，&lt;br&gt;是将 &lt;equation&gt;X&lt;/equation&gt; 映射成 &lt;equation&gt;Bool&lt;/equation&gt; ，将 &lt;equation&gt;Y&lt;/equation&gt; 映射成 &lt;equation&gt;X\to X&lt;/equation&gt; ，而不是 &lt;equation&gt;Bool\to Bool&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;代换&lt;/b&gt;可以用下面的方式来定义，&lt;br&gt;（1） &lt;equation&gt;\sigma(X)=X&lt;/equation&gt; ，如果 &lt;equation&gt;X\notin dom(\sigma)&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\sigma(X)=T&lt;/equation&gt; ，如果 &lt;equation&gt;(X\mapsto T)\in\sigma&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;\sigma(Nat)=Nat&lt;/equation&gt; ， &lt;equation&gt;\sigma(Bool)=Bool&lt;/equation&gt; &lt;br&gt;（4） &lt;equation&gt;\sigma(T_1\to T_2)=\sigma T_1\to\sigma T_2&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;对于类型上下文 &lt;equation&gt;\Gamma=\{x_1:T_1,\cdots,x_n:T_n\}&lt;/equation&gt; 来说， &lt;equation&gt;\sigma\Gamma=\{x_1:\sigma T_1,\cdots,x_n:\sigma T_n\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;类型代换的一个重要特性是它保留了类型声明的有效性，&lt;br&gt;如果包含类型变量的项是良类型的，那么它的所有代换实例也都是良类型的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;类型推断&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-691c692ba80fac2d4b7d02741c0a3da2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;753&quot; data-rawheight=&quot;496&quot;&gt;&lt;p&gt;在类型上下文 &lt;equation&gt;\Gamma&lt;/equation&gt; 中，对于包含类型变量的项 &lt;equation&gt;t&lt;/equation&gt; ，我们通常会提出两个问题，&lt;/p&gt;&lt;p&gt;（1）它的所有代换实例，是否都是良类型的？&lt;br&gt;即，是否 &lt;equation&gt;\forall\sigma\exists T,\sigma\Gamma\vdash\sigma t:T&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;（2）是否存在良类型的代换实例？&lt;br&gt;即，是否 &lt;equation&gt;\exists\sigma\exists T,\sigma\Gamma\vdash\sigma t:T&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;对于第一个问题，将引出&lt;b&gt;参数化多态&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Parametric_polymorphism&quot;&gt;parametric polymorphism&lt;/a&gt;），&lt;br&gt;例如， &lt;equation&gt;\lambda f:X\to X.\lambda a:X.f(f(a))&lt;/equation&gt; ，它的类型为 &lt;equation&gt;(X\to X)\to X\to X&lt;/equation&gt; ，&lt;br&gt;无论用什么具体类型 &lt;equation&gt;T&lt;/equation&gt; 来代换 &lt;equation&gt;X&lt;/equation&gt; ，代换实例都是良类型的。&lt;/p&gt;&lt;p&gt;对于第二个问题，原始的项可能不是良类型的，&lt;br&gt;但是可以选择合适的类型代换使之实例化为良类型的项。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\lambda f:Y.\lambda a:X.f(f(a))&lt;/equation&gt; ，是不可类型化的，&lt;br&gt;但是如果用 &lt;equation&gt;Nat\to Nat&lt;/equation&gt; 代换 &lt;equation&gt;Y&lt;/equation&gt; ，用 &lt;equation&gt;Nat&lt;/equation&gt; 代换 &lt;equation&gt;X&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\sigma=[X\mapsto Nat,Y\mapsto Nat\to Nat]&lt;/equation&gt; ，&lt;br&gt;就可以得到， &lt;equation&gt;\lambda f:Nat\to Nat.\lambda a:Nat.f(f(a))&lt;/equation&gt; ，&lt;br&gt;可类型化为 &lt;equation&gt;(Nat\to Nat)\to Nat\to Nat&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;或者，取 &lt;equation&gt;\sigma&#39;=[Y\mapsto X\to X]&lt;/equation&gt; ，结果也能得到一个良类型的项，尽管仍包含变量。&lt;/p&gt;&lt;p&gt;在寻找类型变量有效实例的过程中，出现了&lt;b&gt;类型推断&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Type_inference&quot;&gt;type inference&lt;/a&gt;）的概念。&lt;br&gt;意味着由编译器来帮助推断 &lt;equation&gt;\lambda&lt;/equation&gt; 项的具体类型，&lt;br&gt;在&lt;a href=&quot;https://en.wikipedia.org/wiki/ML_(programming_language)&quot;&gt;ML&lt;/a&gt;语言中，程序员可以忽略所有的类型注释——隐式类型（&lt;a href=&quot;http://wiki.c2.com/?ImplicitTyping&quot;&gt;implicit typing&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;在进行推断的时候，对每一个原始的 &lt;equation&gt;\lambda&lt;/equation&gt; 抽象 &lt;equation&gt;\lambda x.t&lt;/equation&gt; ，&lt;br&gt;都用新的类型变量进行注释，写成 &lt;equation&gt;\lambda x:X.t&lt;/equation&gt; ，&lt;br&gt;然后采取特定的类型推导算法，找到使项通过类型检查的一个最一般化的解。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;\Gamma&lt;/equation&gt; 为类型上下文， &lt;equation&gt;t&lt;/equation&gt; 为项，&lt;br&gt; &lt;equation&gt;(\Gamma,t)&lt;/equation&gt; 的&lt;b&gt;解&lt;/b&gt;，是指这样的一个序对 &lt;equation&gt;(\sigma,T)&lt;/equation&gt; ，使得 &lt;equation&gt;\sigma\Gamma\vdash\sigma t:T&lt;/equation&gt; 成立。&lt;/p&gt;&lt;p&gt;例如，设 &lt;equation&gt;\Gamma=f:X,a:Y&lt;/equation&gt; ， &lt;equation&gt;t=f~a&lt;/equation&gt; ，则&lt;br&gt; &lt;equation&gt;(\sigma=[X\mapsto Y\to Nat],Nat)&lt;/equation&gt; ， &lt;equation&gt;(\sigma=[X\mapsto Y\to Z],Z)&lt;/equation&gt; ，都是 &lt;equation&gt;(\Gamma,t)&lt;/equation&gt; 的解。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;基于约束的类型化&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-281fd8e3781690168c07b31e22bc9325_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;333&quot; data-rawheight=&quot;109&quot;&gt;&lt;p&gt;&lt;b&gt;（1）约束集&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在实际情况中， &lt;equation&gt;(\Gamma,t)&lt;/equation&gt; 的解，并不一定满足其他类型表达式的约束条件，&lt;br&gt;所以，我们寻找的是满足这些约束条件的特解。&lt;/p&gt;&lt;p&gt;所谓&lt;b&gt;约束条件&lt;/b&gt;，实际上指的是约束集 &lt;equation&gt;C&lt;/equation&gt; ，&lt;br&gt;它由一些包含类型参量的项的等式构成， &lt;equation&gt;\{S_i=T_i|i\in l..n\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果一个代换 &lt;equation&gt;\sigma&lt;/equation&gt; 的代换实例， &lt;equation&gt;\sigma S&lt;/equation&gt; 和 &lt;equation&gt;\sigma T&lt;/equation&gt; 相同，则称该代换&lt;b&gt;合一&lt;/b&gt;（unify）了等式 &lt;equation&gt;S=T&lt;/equation&gt; 。&lt;br&gt;如果 &lt;equation&gt;\sigma&lt;/equation&gt; 能合一 &lt;equation&gt;C&lt;/equation&gt; 中的所有等式，则称 &lt;equation&gt;\sigma&lt;/equation&gt; 能&lt;b&gt;合一&lt;/b&gt;（unify）或满足（satisfy） &lt;equation&gt;C&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们用 &lt;equation&gt;\Gamma\vdash t:T|_\chi C&lt;/equation&gt; ，来表示约束集 &lt;equation&gt;C&lt;/equation&gt; 满足时，项 &lt;equation&gt;t&lt;/equation&gt; 在 &lt;equation&gt;\Gamma&lt;/equation&gt; 下的类型为 &lt;equation&gt;T&lt;/equation&gt; ，&lt;br&gt;其中 &lt;equation&gt;\chi&lt;/equation&gt; 为约束集中，所有类型变量的集合，有时为了讨论方便可以省略它。&lt;/p&gt;&lt;p&gt;例如，对于项 &lt;equation&gt;t=\lambda x:X\to Y.x~0&lt;/equation&gt; ，&lt;br&gt;约束集可以写为 &lt;equation&gt;\{Nat\to Z=X\to Y\}&lt;/equation&gt; ，则 &lt;equation&gt;t&lt;/equation&gt; 类型为 &lt;equation&gt;(X\to Y)\to Z&lt;/equation&gt; 。（算法略）&lt;br&gt;而代换 &lt;equation&gt;\sigma=[X\mapsto Nat,Z\mapsto Bool,Y\mapsto Bool]&lt;/equation&gt; ，使得等式 &lt;equation&gt;Nat\to Z=X\to Y&lt;/equation&gt; 成立，&lt;br&gt;所以，我们推断出了 &lt;equation&gt;(Nat\to Bool)\to Bool&lt;/equation&gt; 是项 &lt;equation&gt;t&lt;/equation&gt; 的一个可能类型。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）约束集的解&lt;/b&gt;&lt;/p&gt;&lt;p&gt;约束集的解一般不是唯一的，所以一个关键问题是如何确定一个“最好”的解。&lt;/p&gt;&lt;p&gt;我们称代换 &lt;equation&gt;\sigma&lt;/equation&gt; 比 &lt;equation&gt;\sigma&#39;&lt;/equation&gt; &lt;b&gt;更具一般性&lt;/b&gt;（more general），如果 &lt;equation&gt;\sigma&#39;=\gamma\circ\sigma&lt;/equation&gt; ，记为 &lt;equation&gt;\sigma\sqsubseteq\sigma&#39;&lt;/equation&gt; ，&lt;br&gt;其中， &lt;equation&gt;\gamma&lt;/equation&gt; 为一个代换， &lt;equation&gt;\gamma\circ\sigma&lt;/equation&gt; 表示代换的复合， &lt;equation&gt;(\gamma\circ\sigma)S=\gamma(\sigma S)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;约束集 &lt;equation&gt;C&lt;/equation&gt; 的&lt;b&gt;主合一子&lt;/b&gt;（principal unifier）指的是代换 &lt;equation&gt;\sigma&lt;/equation&gt; ，&lt;br&gt;它能满足 &lt;equation&gt;C&lt;/equation&gt; ，且对于所有满足 &lt;equation&gt;C&lt;/equation&gt; 的代换 &lt;equation&gt;\sigma&#39;&lt;/equation&gt; ，都有 &lt;equation&gt;\sigma\sqsubseteq\sigma&#39;&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;(\Gamma,t,S,C)&lt;/equation&gt; 的解 &lt;equation&gt;(\sigma,T)&lt;/equation&gt; ，对于任何其他解 &lt;equation&gt;(\sigma&#39;,T&#39;)&lt;/equation&gt; ，都有 &lt;equation&gt;\sigma\sqsubseteq\sigma&#39;&lt;/equation&gt; ，&lt;br&gt;则称 &lt;equation&gt;(\sigma,T)&lt;/equation&gt; 是一个&lt;b&gt;主解&lt;/b&gt;（principal solution），称 &lt;equation&gt;T&lt;/equation&gt;  为 &lt;equation&gt;t&lt;/equation&gt; 的&lt;b&gt;主类型&lt;/b&gt;（principal type）。&lt;br&gt;可以证明，如果 &lt;equation&gt;(\Gamma,t,S,C)&lt;/equation&gt; 有解，则它必有一个主解。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;let多态&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-98db611b8facd70dd4be4eebdc7e1212_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;633&quot; data-rawheight=&quot;357&quot;&gt;&lt;p&gt;&lt;b&gt;多态&lt;/b&gt;（polymorphism）指的是单独一段程序能在不同的上下文中实例化为不同的类型。&lt;br&gt;其中let多态，是由let表达式引入的多态性。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）单态性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;假设我们定义了一个 &lt;equation&gt;double&lt;/equation&gt; 函数，它能将一个函数对参数应用两次，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:Nat\to Nat.\lambda a:Nat.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~double~(\lambda x:Nat.succ~x)~1&lt;/equation&gt; &lt;br&gt;此时， &lt;equation&gt;double&lt;/equation&gt; 的类型为 &lt;equation&gt;(Nat\to Nat)\to Nat\to Nat&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果我们想将 &lt;equation&gt;double&lt;/equation&gt; 应用于其他类型，就必须重写一个新的 &lt;equation&gt;double&#39;&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;let~double&#39;=\lambda f:Bool\to Bool.\lambda a:Bool.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~double&#39;~(\lambda x:Bool.x)~true&lt;/equation&gt; &lt;br&gt;此时 &lt;equation&gt;double&#39;&lt;/equation&gt; 的类型为 &lt;equation&gt;(Bool\to Bool)\to Bool\to Bool&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们不能让一个 &lt;equation&gt;double&lt;/equation&gt; 函数，既能用于 &lt;equation&gt;Nat&lt;/equation&gt; 类型，又能用于 &lt;equation&gt;Bool&lt;/equation&gt; 类型。&lt;br&gt;即使在 &lt;equation&gt;double&lt;/equation&gt; 中用类型变量也没有用，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in~\cdots&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;例如，如果写，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~let~a=double~(\lambda x:Nat.succ~x)~1~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~~~~~let~b=double~(\lambda x:Bool.x)~true~in~\cdots&lt;/equation&gt; &lt;br&gt;则在 &lt;equation&gt;a&lt;/equation&gt; 定义中使用 &lt;equation&gt;double&lt;/equation&gt; ，会产生一个约束 &lt;equation&gt;X\to X=Nat\to Nat&lt;/equation&gt; ，&lt;br&gt;而在 &lt;equation&gt;b&lt;/equation&gt; 定义中使用 &lt;equation&gt;double&lt;/equation&gt; ，则会产生约束 &lt;equation&gt;X\to X=Bool\to Bool&lt;/equation&gt; ，&lt;br&gt;这样会使类型变量 &lt;equation&gt;X&lt;/equation&gt; 的求解发生矛盾，导致整个程序不可类型化。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）多态性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;let多态所做的事情，就是打破这个限制，&lt;br&gt;让类型参量 &lt;equation&gt;X&lt;/equation&gt; 在上述不同的上下文中，可以分别实例化为 &lt;equation&gt;Nat&lt;/equation&gt; 和 &lt;equation&gt;Bool&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;这需要改变与let表达式相关的类型推导规则，在第七篇中，我们提到过，&lt;br&gt; &lt;equation&gt;\frac{\Gamma\vdash t_1:T_1~~~~\Gamma,x:T_1\vdash t_2:T_2}{\Gamma\vdash let~x:T_1=t_1~in~t_2:T_2}&lt;/equation&gt; &lt;br&gt;它会首先计算 &lt;equation&gt;T_1&lt;/equation&gt; 作为 &lt;equation&gt;x&lt;/equation&gt; 的类型，然后再用 &lt;equation&gt;x&lt;/equation&gt; 来确定 &lt;equation&gt;T_2&lt;/equation&gt; 的类型。&lt;br&gt;此时，let表达式 &lt;equation&gt;let~x=t_1:T_1~in~t_2&lt;/equation&gt; ，可以看做 &lt;equation&gt;(\lambda x:T_1.t_2)t_1&lt;/equation&gt; 的简写。&lt;/p&gt;&lt;p&gt;为了引入多态性，我们需要对上述类型推导规则进行修改，&lt;br&gt; &lt;equation&gt;\frac{\Gamma\vdash[x\mapsto t_1]t_2:T_2}{\Gamma\vdash let~x=t_1~in~t_2:T_2}&lt;/equation&gt; &lt;br&gt;它表示，先将 &lt;equation&gt;t_2&lt;/equation&gt; 中的 &lt;equation&gt;x&lt;/equation&gt; 用 &lt;equation&gt;t_1&lt;/equation&gt; 代换掉，然后再确定 &lt;equation&gt;t_2&lt;/equation&gt; 的类型。&lt;/p&gt;&lt;p&gt;这样的话，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~let~a=double~(\lambda x:Nat.succ~x)~1~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~~~~~let~b=double~(\lambda x:Bool.x)~true~in~\cdots&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;就相当于，&lt;br&gt; &lt;equation&gt;let~a=\lambda f:X\to X.\lambda a:X.f(f(a))~(\lambda x:Nat.succ~x)~1~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~let~b=\lambda f:Y\to Y.\lambda a:Y.f(f(a))~(\lambda x:Bool.x)~true~in~\cdots&lt;/equation&gt; &lt;br&gt;通过let多态，产生了 &lt;equation&gt;double&lt;/equation&gt; 的两个&lt;b&gt;副本&lt;/b&gt;，并为之分配了不同的类型参量。&lt;/p&gt;&lt;p&gt;此时，let表达式 &lt;equation&gt;let~x=t_1~in~t_2&lt;/equation&gt; ，可以看做 &lt;equation&gt;[x\mapsto t_1]t_2&lt;/equation&gt; 的简写。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Let-polymorphism&quot;&gt;Hindley–Milner type system&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1761910/&quot;&gt;Types and programming languages&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.haskell.org/definition/haskell2010.pdf&quot;&gt;Haskell 2010 Language Report&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-26-34915143</guid>
<pubDate>Mon, 26 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（六）：最多有多少个程序</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-14-34484014.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34484014&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上一篇中，我们通过引入极小化算子定义了递归函数，&lt;br&gt;使用递归函数，我们又定义了递归集与递归可枚举集，&lt;br&gt;本文我们要讨论，为什么递归可枚举集是“可枚举”的，以及什么是可计算函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;可计算性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a4af83dc0f3607efe72758004eb1e9f5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;429&quot;&gt;&lt;p&gt;我们听说过，现代计算机在计算能力上是与图灵机等价的，&lt;br&gt;什么叫做计算能力呢？&lt;br&gt;它指的是图灵机可计算的函数集，与现代计算机可计算的函数集是相等的。&lt;/p&gt;&lt;p&gt;为了简单起见，我们不去讨论图灵机，而是从现代计算机直接说起，&lt;br&gt;设 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 是一段程序， &lt;equation&gt;n&lt;/equation&gt; 是一个正整数，&lt;br&gt;我们称数论函数 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 为&lt;b&gt;程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 所计算的&lt;/b&gt; &lt;equation&gt;n&lt;/equation&gt; 元部分函数，&lt;br&gt;如果对于相同的输入，&lt;br&gt;要么：（1）程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的计算可以终止，此时计算结果等于 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 的相应函数值；&lt;br&gt;要么：（2）程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的计算不能终止，此时 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 无定义。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;f(x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 是一个部分函数，&lt;br&gt;如果存在程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 可计算 &lt;equation&gt;f&lt;/equation&gt; ，则称 &lt;equation&gt;f&lt;/equation&gt; 是&lt;b&gt;部分可计算的&lt;/b&gt;。&lt;br&gt;如果一个函数，既是部分可计算的，又是全函数，则称这个函数是&lt;b&gt;可计算的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;可以证明，所有的原始递归函数和递归函数都是部分可计算的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;通用程序&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们使用现代计算机进行编程的时候，并不是直接把程序的输入传给程序，&lt;br&gt;而是将程序本身以及它的输入，传给计算机，最后由计算机得到计算结果，&lt;br&gt;像这种接受任何程序和它的输入作为自己的输入，返回程序执行结果的程序，称为&lt;b&gt;通用程序&lt;/b&gt;。&lt;br&gt;为此，通用程序需要把输入的程序进行&lt;b&gt;编码&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;常用的编码方法，涉及&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%85%8D%E5%AF%B9%E5%87%BD%E6%95%B0&quot;&gt;配对函数&lt;/a&gt;和&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E6%95%B0&quot;&gt;哥德尔编码&lt;/a&gt;。&lt;br&gt;为了不引入太多的复杂性，我们可以将程序的编码理解为存储程序的二进制数据，&lt;br&gt;不同的程序会有不同的二进制表示，每一个二进制表示可以对应一段程序&lt;br&gt;（虽然可能不合法）。&lt;/p&gt;&lt;p&gt;哥德尔编码做的事情就是将程序和自然数集一一对应起来。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9a7c9ce767daf3bef81c5e3e7d5c152e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;565&quot;&gt;&lt;p&gt;因此，所有程序的个数是&lt;b&gt;可数的&lt;/b&gt;，而这些程序可计算的函数个数也一定是可数的，&lt;br&gt;它们可能是全函数，也可能是部分函数。&lt;br&gt;（其中，“可数”指的是可数集，&lt;b&gt;可数集&lt;/b&gt;是与自然数集之间存在一一映射的集合。&lt;/p&gt;&lt;p&gt;然而，自然数集上的函数全体并不可数，（证略&lt;br&gt;所以肯定存在程序不可计算的函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;集合个数的可枚举性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-216f0ef423d8f37598db6eee7ed05452_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;389&quot; data-rawheight=&quot;182&quot;&gt;&lt;p&gt;程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 所计算的函数，我们可以记为 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; ，&lt;br&gt;由此，我们可以定义通用程序 &lt;equation&gt;\Phi&lt;/equation&gt; ，则有，&lt;br&gt; &lt;equation&gt;\Phi (x_1,x_2,\cdots ,x_n,y)=\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; &lt;br&gt;其中， &lt;equation&gt;y&lt;/equation&gt; 是程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的编码。&lt;/p&gt;&lt;p&gt;因为，所有的程序与自然数集一一对应，&lt;br&gt;所以， &lt;equation&gt;\Phi (x_1,x_2,\cdots ,x_n,0),\Phi (x_1,x_2,\cdots ,x_n,1),\cdots&lt;/equation&gt; &lt;b&gt;枚举了所有的 &lt;equation&gt;n&lt;/equation&gt; 元可计算函数。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们定义 &lt;equation&gt;W_y=\lbrace x\in N|\Phi(x,y)\downarrow \rbrace&lt;/equation&gt; ，&lt;br&gt;根据递归可枚举集的定义，每一个 &lt;equation&gt;W_y&lt;/equation&gt; 是一个递归可枚举集。&lt;/p&gt;&lt;p&gt;又因为 &lt;equation&gt;\Phi(x,0),\Phi(x,1),\cdots&lt;/equation&gt; 枚举了所有的可计算函数，&lt;br&gt;而上一篇中我们看到，递归可枚举集是由部分递归函数（即，可计算函数）定义的，&lt;br&gt;一个部分递归函数确定出一个递归可枚举集，&lt;br&gt;所以， &lt;equation&gt;W_0,W_1,\cdots&lt;/equation&gt; &lt;b&gt;枚举了所有的递归可枚举集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;因此，集合 &lt;equation&gt;B&lt;/equation&gt; 是递归可枚举的，当且仅当存在 &lt;equation&gt;y\in N&lt;/equation&gt; ，使得 &lt;equation&gt;B=W_y&lt;/equation&gt; ，&lt;br&gt;称为&lt;b&gt;枚举定理&lt;/b&gt;，这就是“枚举”的含义。&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;K=\lbrace n\in N|n\in W_n\rbrace&lt;/equation&gt; ，&lt;br&gt;则 &lt;equation&gt;K&lt;/equation&gt; 是递归可枚举的，但不是递归的，（证略&lt;br&gt;因此， &lt;equation&gt;\bar{K}&lt;/equation&gt; 不是递归可枚举的，否则 &lt;equation&gt;K&lt;/equation&gt; 就是递归集了。&lt;br&gt;（根据，集合 &lt;equation&gt;B&lt;/equation&gt; 是递归的当且仅当 &lt;equation&gt;B&lt;/equation&gt; 和 &lt;equation&gt;\bar{B}&lt;/equation&gt; 是递归可枚举的，见上一篇&lt;/p&gt;&lt;p&gt;因此，我们找到了一个非递归的递归可枚举集 &lt;equation&gt;K&lt;/equation&gt; ，&lt;br&gt;以及一个非递归可枚举集 &lt;equation&gt;\bar{K}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;停机问题&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2649469b93d96783266c38873773ab78_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;374&quot; data-rawheight=&quot;234&quot;&gt;&lt;p&gt;任给一个程序和一个自然数，问该程序对这个自然数输入的计算是否停止，&lt;br&gt;这个问题称为&lt;b&gt;停机问题&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;我们可以用谓词 &lt;equation&gt;H(x,y)&lt;/equation&gt; 描述这个问题，&lt;br&gt; &lt;equation&gt;H(x,y)&lt;/equation&gt; ，表示以 &lt;equation&gt;y&lt;/equation&gt; 为代码的程序对输入 &lt;equation&gt;x&lt;/equation&gt; 的计算最终停止。&lt;br&gt;那么， &lt;equation&gt;H(x,y)&lt;/equation&gt; 是不可计算的，即，不存在一个程序来计算 &lt;equation&gt;H(x,y)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们来证明一下，假设有一个程序可以计算 &lt;equation&gt;H(x,y)&lt;/equation&gt; ，&lt;br&gt;那么我们就能用它来构造一个新程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; ，它的输入是 &lt;equation&gt;x&lt;/equation&gt; ，&lt;br&gt;这段程序当 &lt;equation&gt;H(x,x)&lt;/equation&gt; 为真时，计算不停止，而当 &lt;equation&gt;H(x,x)&lt;/equation&gt; 为假时，计算停止。&lt;/p&gt;&lt;p&gt;程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 也可以进行编码，假设为 &lt;equation&gt;y_0&lt;/equation&gt; ，现在我们来判断 &lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 为真，意味着编码为 &lt;equation&gt;y_0&lt;/equation&gt; 的程序以 &lt;equation&gt;y_0&lt;/equation&gt; 作为输入最终停止，&lt;br&gt;即程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; ，输入为 &lt;equation&gt;y_0&lt;/equation&gt; 时，最终停止，&lt;br&gt;可是根据 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的定义，此时 &lt;equation&gt;H(x,x)=H(y_0,y_0)&lt;/equation&gt; 为假才会停止，矛盾。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 为假，意味着编码为 &lt;equation&gt;y_0&lt;/equation&gt; 的程序以 &lt;equation&gt;y_0&lt;/equation&gt; 作为参数最终不会停止，&lt;br&gt;即程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; ，输入为 &lt;equation&gt;y_0&lt;/equation&gt; 时，最终不停止，&lt;br&gt;可是根据 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的定义，此时 &lt;equation&gt;H(x,x)=H(y_0,y_0)&lt;/equation&gt; 为真才不会停止，矛盾。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 不能为真也不能为假，矛盾，&lt;br&gt;因此，计算 &lt;equation&gt;H(x,y)&lt;/equation&gt; 的程序&lt;b&gt;不存在&lt;/b&gt;，我们也无法用它来构造程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;可判定性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2b6940df2115ed418d982f28f5263301_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;380&quot;&gt;&lt;p&gt;&lt;b&gt;可判定性问题&lt;/b&gt;，指的是一个询问真或者假的问题是否可以被回答。&lt;br&gt;如果我们总能回答出这个问题是真或者是假，就称该问题是&lt;b&gt;可判定的&lt;/b&gt;，&lt;br&gt;如果我们只能当问题为真的时候确定为真，为假的时候所进行的计算可能不会终止，&lt;br&gt;那么就称该问题是&lt;b&gt;半可判定的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;某元素是否属于一个递归集，是可判定的，&lt;br&gt;某元素是否属于一个递归可枚举集，是半可判定的。&lt;/p&gt;&lt;p&gt;因为，递归集是使用一个递归的全函数定义的，&lt;br&gt;而递归可枚举集是使用第一个部分递归函数定义的，&lt;br&gt;我们无法判断某个部分递归函数，在接受某参数时，是没有定义，还是计算尚未停止。&lt;br&gt;即，判断元素是否属于某递归可枚举集的程序可能永不停机&lt;b&gt;。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了函数的可计算性，通用程序，以及最多有多少个程序，&lt;br&gt;还了解了停机问题和可判定性问题。&lt;/p&gt;&lt;p&gt;这些都是可计算性理论的基础，我们清晰的看到了人类的计算能力，&lt;br&gt;以及用递归所能计算的函数范围，后文中我们开始讨论不动点理论，&lt;br&gt;这同样是一个有趣的话题。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;附&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;配对函数和哥德尔数，是对数偶和有穷数列的一种编码方式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）配对函数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;\langle x,y\rangle=2^x(2y+1)-1&lt;/equation&gt; ，称 &lt;equation&gt;\langle x,y\rangle&lt;/equation&gt; 为&lt;b&gt;配对函数&lt;/b&gt;，它是一个原始递归函数。&lt;/p&gt;&lt;p&gt;任给一个数 &lt;equation&gt;z&lt;/equation&gt; ，存在唯一的一对数 &lt;equation&gt;x&lt;/equation&gt; 和 &lt;equation&gt;y&lt;/equation&gt; ，使得 &lt;equation&gt;\langle x,y\rangle =z&lt;/equation&gt; 。&lt;br&gt; &lt;equation&gt;x&lt;/equation&gt; 是 &lt;equation&gt;z+1&lt;/equation&gt; 含有因子 &lt;equation&gt;2&lt;/equation&gt; 的个数，即使得 &lt;equation&gt;2^t|(z+1)&lt;/equation&gt; 的 &lt;equation&gt;t&lt;/equation&gt; 的最大值。&lt;br&gt; &lt;equation&gt;(z+1)/2^x&lt;/equation&gt; 必为奇数， &lt;equation&gt;y&lt;/equation&gt; 是 &lt;equation&gt;2y+1=(z+1)/2^x&lt;/equation&gt; 的唯一解。&lt;/p&gt;&lt;p&gt;一般的，记 &lt;equation&gt;l(z)=x&lt;/equation&gt; ， &lt;equation&gt;r(z)=y&lt;/equation&gt; ，则 &lt;equation&gt;l(z)&lt;/equation&gt; 和 &lt;equation&gt;r(z)&lt;/equation&gt; 也是原始递归函数。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）哥德尔数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;记 &lt;equation&gt;[a_1,a_2,\cdots ,a_n]=\prod_{i=1}^{n}p_i^{a_i}&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;[a_1,a_2,\cdots ,a_n]&lt;/equation&gt; 称为有穷数列 &lt;equation&gt;(a_1,a_2,\cdots ,a_n)&lt;/equation&gt; 的哥德尔数，其中， &lt;equation&gt;p_i&lt;/equation&gt; 是第 &lt;equation&gt;i&lt;/equation&gt; 个素数。&lt;/p&gt;&lt;p&gt;例如，[ &lt;equation&gt;[2,0,1,3]=2^2\cdot 3^0\cdot 5^1\cdot 7^3=6860&lt;/equation&gt; 。&lt;br&gt;对于每一个固定的 &lt;equation&gt;n&lt;/equation&gt; ， &lt;equation&gt;[a_1,a_2,\cdots ,a_n]&lt;/equation&gt; 是原始递归函数，并且这种编码具有唯一性。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%85%8D%E5%AF%B9%E5%87%BD%E6%95%B0&quot;&gt;配对函数&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E6%95%B0&quot;&gt;哥德尔数&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%95%B8%E9%9B%86&quot;&gt;可数集&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%88%A4%E5%AE%9A%E6%80%A7&quot;&gt;可判定性&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E5%BA%B7%E6%89%98%E5%B0%94%E5%AE%9A%E7%90%86&quot;&gt;康托尔定理&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-14-34484014</guid>
<pubDate>Wed, 14 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>[公告] Idris-zh 中文翻译项目启动</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-07-34328106.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34328106&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-581b50e22da06e58321ea076d8ee5e8e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;Idris 是个通用的依赖类型纯函数式编程语言，比起 Coq 来说更注重现实世界的编程。说起来咱对这货感兴趣还是受了某莎某 be5 和某智猫的影响= =||&lt;/p&gt;&lt;p&gt;其实 Idris 中文文档翻译的坑很早就挖下了，可惜咱能力有限现在才正式启动。目前只翻译了官方教程的第一章，大家可以在 &lt;a href=&quot;http://idris-zh.readthedocs.io/&quot;&gt;Idris-zh 文档主页&lt;/a&gt; 查看。对应的 &lt;a href=&quot;https://github.com/Idris-zh/Idris-dev/tree/master/docs&quot;&gt;Idris-zh 项目地址&lt;/a&gt; 中可以找到源码。&lt;/p&gt;&lt;p&gt;官方文档的量并不算太多，本打算翻译完官方教程再说，不过咱最近忙于考试，加上人多力量大，思来想去还是在魔法店发个公告比较好。有兴趣的译者可以戳咱加入项目组一起翻译。&lt;/p&gt;&lt;p&gt;以上。&lt;/p&gt;</description>
<author>Oling Cat</author>
<guid isPermaLink="false">2018-03-07-34328106</guid>
<pubDate>Wed, 07 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Emacs之魂（七）：变量捕获与卫生宏</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-03-07-34106490.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34106490&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-be0646e5c6a0b48056bfdf78f3442375_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;843&quot; data-rawheight=&quot;370&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们介绍了宏，它与函数是不同的，函数调用发生在程序执行期间，函数在调用之前，会先对它所有的实参进行求值，然后将形参绑定到这些实参的求值结果上，函数的返回值会作为函数调用表达式的值，Lisp求值器不断的求值表达式，从而程序得以运行。&lt;/p&gt;&lt;p&gt;宏调用（macro call）发生在程序的编译期，或者说，宏调用发生在表达式的求值之前，在执行宏调用的过程中，宏形参直接绑定为实参所代表的语法对象（syntax object）上，宏调用的返回值，会进行表达式替换，将宏调用表达式替换为它的返回值，这个过程称为宏展开（macro expansion），之后在运行时，求值器就不会遇到宏了，所进行求值的只有被展开之后的表达式。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 交互函数&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在介绍常用的宏之前，我们先介绍Emacs中交互函数（interactive function）的概念。&lt;br&gt;交互函数可以使用&lt;code class=&quot;inline&quot;&gt;M-x&lt;/code&gt;在echo area中通过输入函数名进行调用（交互式调用），所以交互函数也称为命令（command）。&lt;br&gt;交互函数也可以被Lisp程序中的其他函数直接调用，这种调用方式称为非交互式调用。&lt;/p&gt;&lt;p&gt;Emacs中函数定义&lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Defining-Functions.html#Defining-Functions&quot;&gt;defun&lt;/a&gt;&lt;/code&gt;包含以下几个部分，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;defun name args [doc] [declare] [interactive] body ...&lt;/code&gt;&lt;p&gt;其中，&lt;code class=&quot;inline&quot;&gt;doc&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;declare&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;interactive&lt;/code&gt;都是可选的。&lt;/p&gt;&lt;p&gt;交互函数的定义中，具有&lt;code class=&quot;inline&quot;&gt;interactive&lt;/code&gt;部分，&lt;br&gt;它是一个形如&lt;code class=&quot;inline&quot;&gt;(interactive arg-descriptor)&lt;/code&gt;的表达式，用来指定该函数被交互调用时的行为，&lt;br&gt;对于非交互式调用，&lt;code class=&quot;inline&quot;&gt;interactive&lt;/code&gt;部分将失去作用。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;arg-descriptor&lt;/code&gt;有三种可能的写法：省略，一个字符串，或者一个Lisp表达式。&lt;br&gt;具体情况可能会比较复杂，可以参考&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Using-Interactive.html#Using-Interactive&quot;&gt;Using-Interactive&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.1 describe-key&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;describe-key&lt;/code&gt;是一个交互函数，用来展示某个快键键相关的文档信息，&lt;br&gt;我们可以使用&lt;code class=&quot;inline&quot;&gt;M-x describe-key&lt;/code&gt;来调用它，echo area中会显示如下内容，等待我们键入一个快捷键，&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e9c4d71238a11558bae673bd850860ce_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;678&quot; data-rawheight=&quot;121&quot;&gt;&lt;p&gt;如果我们键入一个快捷键，例如&lt;code class=&quot;inline&quot;&gt;C-a&lt;/code&gt;，Emacs就会展示出与&lt;code class=&quot;inline&quot;&gt;C-a&lt;/code&gt;相关的文档信息了。我们还可以使用快捷键&lt;code class=&quot;inline&quot;&gt;C-h k&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;C-h k&lt;/code&gt;相当于&lt;code class=&quot;inline&quot;&gt;M-x describe-key&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;C-a runs the command move-beginning-of-line (found in global-map),
which is an interactive compiled Lisp function in ‘simple.el’.

It is bound to C-a.

(move-beginning-of-line ARG)

Move point to beginning of current line as displayed.
(If there’s an image in the line, this disregards newlines
which are part of the text that the image rests on.)

With argument ARG not nil or 1, move forward ARG - 1 lines first.
If point reaches the beginning or end of buffer, it stops there.
To ignore intangibility, bind ‘inhibit-point-motion-hooks’ to t.&lt;/code&gt;&lt;p&gt;&lt;b&gt;1.2 describe-function&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;describe-function&lt;/code&gt;也是一个交互函数，用来展示某个函数（或者宏）相关的文档信息，它绑定到了快捷键&lt;code class=&quot;inline&quot;&gt;C-h f&lt;/code&gt;上，&lt;br&gt;调用后，echo area中会显示如下内容，等待我们输入函数（或者宏）的名字，&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d8c0390d2d4077bcdac4cdd5b810cf44_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;674&quot; data-rawheight=&quot;117&quot;&gt;&lt;p&gt;例如，&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;相关的文档信息如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;when is a Lisp macro in ‘subr.el’.

(when COND BODY...)

If COND yields non-nil, do BODY, else return nil.
When COND yields non-nil, eval BODY forms sequentially and return
value of last one, or nil if there are none.&lt;/code&gt;&lt;p&gt;它指出，&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;是一个宏，并且定义在&lt;code class=&quot;inline&quot;&gt;subr.el&lt;/code&gt;文件中。&lt;/p&gt;&lt;p&gt;鼠标左键点击&lt;code class=&quot;inline&quot;&gt;subr.el&lt;/code&gt;，会打开本地&lt;code class=&quot;inline&quot;&gt;subr.el.gz&lt;/code&gt;文件中&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;的定义，如下，&lt;br&gt;（文件路径为：&lt;code class=&quot;inline&quot;&gt;/Applications/Emacs.app/Contents/Resources/lisp/subr.el.gz&lt;/code&gt;&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(defmacro when (cond &amp;amp;rest body)
  &quot;If COND yields non-nil, do BODY, else return nil.
When COND yields non-nil, eval BODY forms sequentially and return
value of last one, or nil if there are none.
\(fn COND BODY...)&quot;
  (declare (indent 1) (debug t))
  (list &#39;if cond (cons &#39;progn body)))&lt;/code&gt;&lt;p&gt;可见，&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;只是一个语法糖，最终会展开成&lt;code class=&quot;inline&quot;&gt;if&lt;/code&gt;表达式。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;subr.el.gz&lt;/code&gt;文件中包含了很多常用的宏，&lt;br&gt;我们可以访问线上地址&lt;a href=&quot;https://github.com/emacs-mirror/emacs/blob/master/lisp/subr.el&quot;&gt;Github: emacs-mirror/emacs subr.el&lt;/a&gt;进行查阅。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 变量捕获&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;2.1 插入一个绑定&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-52535d0d127c59e76c691246b377b071_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;421&quot; data-rawheight=&quot;334&quot;&gt;&lt;code lang=&quot;emacs&quot;&gt;; -*- lexical-binding: t -*-

(defmacro insert-binding (x)
    `(let ((a 1))
        (+ ,x a)))&lt;/code&gt;&lt;p&gt;以上代码定义了一个宏&lt;code class=&quot;inline&quot;&gt;insert-binding&lt;/code&gt;，它将展开成一个&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;表达式，&lt;br&gt;将&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;插入到一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;值为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;的词法环境中。&lt;/p&gt;&lt;p&gt;其中，`&lt;code class=&quot;inline&quot;&gt;(let ((a 1)) (+ ,x a)))&lt;/code&gt;是反引用表达式，&lt;br&gt;下一篇文章中我们再详细讨论。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;(insert-binding 3)&lt;/code&gt;将展开成，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 1))
    (+ 3 a))    ; 4&lt;/code&gt;&lt;p&gt;然而，如果&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;中包含&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，就会引发歧义，例如，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (insert-binding (+ a 3)))&lt;/code&gt;&lt;p&gt;上式会展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (let ((a 1))
        (+ (+ a 3) a)))    ; 5&lt;/code&gt;&lt;p&gt;我们看表达式&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a))&lt;/code&gt;，&lt;br&gt;其中，左边第一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开之前的词法绑定，即，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (insert-binding (+ a 3)))&lt;/code&gt;&lt;p&gt;而第二个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开式中的词法绑定，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;`(let ((a 1))
        (+ ,x a))&lt;/code&gt;&lt;p&gt;在进行宏定义时，我们并不知道&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;中有没有&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，&lt;br&gt;结果导致了，宏展开式中的词法绑定意外捕获了&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;中的&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在本例中，&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;就是&lt;code class=&quot;inline&quot;&gt;(+ a 3)&lt;/code&gt;，其中&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值本来应该是&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;，&lt;br&gt;结果展开后，被宏展开式所捕获，值变成了&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，&lt;br&gt;我们通过插入一个词法绑定，完成了本例。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 插入一个自由变量&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a5d6fa2b397681d42d4ca20162e8ff13_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;403&quot; data-rawheight=&quot;328&quot;&gt;&lt;code lang=&quot;emacs&quot;&gt;; -*- lexical-binding: t -*-

(let ((a 1))
    (defmacro insert-free (x)
        `(+ ,x a)))&lt;/code&gt;&lt;p&gt;以上代码定义了一个宏&lt;code class=&quot;inline&quot;&gt;insert-free&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;(insert-free 3)&lt;/code&gt;将展开为&lt;code class=&quot;inline&quot;&gt;(+ 3 a)&lt;/code&gt;，其中&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;是自由变量，&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值取决于&lt;code class=&quot;inline&quot;&gt;(insert-free 3)&lt;/code&gt;在何处被展开。&lt;/p&gt;&lt;p&gt;例如，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (insert-free (+ a 3)))&lt;/code&gt;&lt;p&gt;将展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (+ (+ a 3) a))    ; 7&lt;/code&gt;&lt;p&gt;我们再来看表达式&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a))&lt;/code&gt;，&lt;br&gt;其中，左边第一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开之前的词法绑定，即，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (insert-free (+ a 3)))&lt;/code&gt;&lt;p&gt;而第二个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开式中的词法绑定，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 1))
    (defmacro insert-free (x)
        `(+ ,x a)))&lt;/code&gt;&lt;p&gt;在进行宏定义时，虽然我们显式的将&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;绑定为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，&lt;br&gt;但是&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;中包含的绑定，意外影响到了它，使得&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值变成了&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;。&lt;br&gt;我们通过插入一个含自由变量的表达式，让它受展开式所处的位置影响。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3 hygienic macro&lt;/b&gt;&lt;/p&gt;&lt;p&gt;以上两个例子中，插入一个绑定会污染宏展开后的环境，而插入一个自由变量会被宏展开后环境所影响，&lt;br&gt;它们都有变量捕获问题，都不是卫生的（hygienic）。&lt;/p&gt;&lt;p&gt;hygienic macro通常翻译成“卫生宏”，是一种避免变量捕获的技术，&lt;br&gt;如果所使用的宏是卫生的，那么以上两个例子中，最后的求值结果应该都是&lt;code class=&quot;inline&quot;&gt;6&lt;/code&gt;，而不是&lt;code class=&quot;inline&quot;&gt;5&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;7&lt;/code&gt;。&lt;br&gt;卫生宏是一种语言特性，&lt;a href=&quot;http://community.schemewiki.org/?RnRS&quot;&gt;Scheme&lt;/a&gt;中的宏是卫生的，而Emacs Lisp不是。&lt;/p&gt;&lt;p&gt;&lt;b&gt;如果一个宏是卫生的，&lt;/b&gt; &lt;b&gt;那么宏展开式中的所有标识符，仍处于其来源处的词法作用域中。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;（1）例如，根据&lt;code class=&quot;inline&quot;&gt;insert-binding&lt;/code&gt;的定义，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;; -*- lexical-binding: t -*-

(let ((a 1))
    (defmacro insert-free (x)
        `(+ ,x a)))
(let ((a 2))
    (insert-binding (+ a 3)))&lt;/code&gt;&lt;p&gt;将展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (let ((a 1))
        (+ (+ a 3) a)))&lt;/code&gt;&lt;p&gt;其中，&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a)&lt;/code&gt;中，&lt;br&gt;第一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开之前的词法环境，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值为&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;，&lt;br&gt;第二个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏定义式，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，&lt;br&gt;因此，&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a)&lt;/code&gt;求值为&lt;code class=&quot;inline&quot;&gt;6&lt;/code&gt;。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0f0d0d03df4a9d2654648399f00f87d1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;358&quot;&gt;&lt;p&gt;（2）又例，根据&lt;code class=&quot;inline&quot;&gt;insert-free&lt;/code&gt;的定义，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;; -*- lexical-binding: t -*-

(let ((a 1))
    (defmacro insert-free (x)
        `(+ ,x a)))
(let ((a 2))
    (insert-free (+ a 3)))&lt;/code&gt;&lt;p&gt;将展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (+ (+ a 3) a))&lt;/code&gt;&lt;p&gt;同理，&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a)&lt;/code&gt;中，&lt;br&gt;第一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开之前的词法环境，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值为&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;，&lt;br&gt;第二个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏定义式，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，&lt;br&gt;因此，&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a)&lt;/code&gt;的值也为&lt;code class=&quot;inline&quot;&gt;6&lt;/code&gt;。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d506193ef43253a3bd3b2ed80fc56297_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;352&quot;&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了交互函数，介绍了如何查看一个函数或者宏的文档和定义，&lt;br&gt;一些常用的宏，都可以通过查看&lt;code class=&quot;inline&quot;&gt;subr.el&lt;/code&gt;来找到它们。&lt;br&gt;然后，我们介绍了两种与宏相关的变量捕获问题，引出了卫生宏的概念。&lt;/p&gt;&lt;p&gt;下文，我们继续讨论宏，来看一看展开为宏定义的宏之强大威力。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/elisp.html&quot;&gt;GNU Emacs Lisp Reference Manual&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1432683/&quot;&gt;On Lisp&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/3864436/&quot;&gt;Let Over Lambda&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;http://www.scheme.com/tspl4/&quot;&gt;The Scheme Programming Language&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-07-34106490</guid>
<pubDate>Wed, 07 Mar 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
