<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Mon, 12 Feb 2018 16:33:46 +0800</lastBuildDate>
<item>
<title>【OI】【奇技淫巧】bitset在OI中的应用</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-01-29-33406432.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33406432&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d825293370685bfc6c285d7b2ad50ea1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;震惊，GDKOI2018D1T3竟有bitset水法！&lt;/p&gt;&lt;p&gt;作为一只标准蒟蒻，我在学不会标准正解FFT的情况下然后去学了一下bitset。。。&lt;/p&gt;&lt;p&gt;一般你翻开一个关于介绍bitset的blog，基本画风是这样的：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e433874acf5a3b6b77c4413512410809_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;761&quot;&gt;&lt;p&gt;（来源：&lt;a href=&quot;https://www.cnblogs.com/BaiYiShaoNian/p/4591167.html&quot;&gt;https://www.cnblogs.com/BaiYiShaoNian/p/4591167.html&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;然而作为菜鸡的我一看完就有点懵，不是说bitset可以快速查找某一个元素喵，这些...都是处理二进制的呀。&lt;/p&gt;&lt;p&gt;然后经过我的几次无脑实验我大概就摸清了使用bitset的基本套路：&lt;/p&gt;&lt;p&gt;1、bitset其实是可以看做是&lt;b&gt;一个bool类型的数组&lt;/b&gt;，只不过bitset的一个元素只占1bit的空间，而bool里面则是占1byte，这样就相当于同时减少了时间复杂度和空间复杂度，这也是bitset的优势所在。&lt;/p&gt;&lt;p&gt;2、使用bitset的时候你需要先声明，类似声明vector一样，基本格式：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;#include&amp;lt;bitset&amp;gt;
bitset&amp;lt;10005&amp;gt;a;  //10005是bitset的大小，相当于数组大小，a就相当于一个bool数组。&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;3、前面说了bitset是基本和bool数组的用法一样的，所以其实赋值的时候&lt;b&gt;完全可以这样写&lt;/b&gt;：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;a[0]=1;//等价于写a.set(0);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;4、那么话说回来&lt;b&gt;如何快速查找一个元素是否在集合内&lt;/b&gt;呢，你大可这样写：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;//x为查找元素：
if (f[x]) printf(&quot;Yes\n&quot;); else printf(&quot;No\n&quot;);&lt;/code&gt;&lt;p&gt;有人可能会问了，那这不是bool数组也可以做到吗，其实还是&lt;b&gt;空间&lt;/b&gt;的问题，用bitset可以轻松存10^8个数字并查询，bool空间是它的八倍然后就极有可能MLE~&lt;/p&gt;&lt;p&gt;那我们就来一道水题练练手吧&lt;/p&gt;&lt;a href=&quot;http://poj.org/problem?id=2443&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;2443 -- Set Operation&lt;/a&gt;&lt;p&gt;果然很水对吧（&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;bitset&amp;gt;
using namespace std;
int n,i,j,k,q,x,g,y;
bool fl;
bitset&amp;lt;10005&amp;gt; a[1015];
int main()
{
	scanf(&quot;%d&quot;,&amp;amp;n);
	for (i=1;i&amp;lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;amp;x);
		for (j=1;j&amp;lt;=x;j++)
		{
			scanf(&quot;%d&quot;,&amp;amp;g);
			a[i][g]=1;
		}
	}
	scanf(&quot;%d&quot;,&amp;amp;q);
	for (i=1;i&amp;lt;=q;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;amp;x,&amp;amp;y);
		fl=1;
		for (j=1;j&amp;lt;=n;j++)
			if (a[j][x]&amp;amp;&amp;amp;a[j][y]) {printf(&quot;Yes\n&quot;);fl=0;break;}
		if (fl) printf(&quot;No\n&quot;);
	}
	return 0;
}&lt;/code&gt;&lt;p&gt;Q：有没有好玩一点的题&lt;/p&gt;&lt;p&gt;A：bzoj3687把dp和bitset结合了起来，可惜是一道权限题qwq。有兴趣的可以看hzwer的blog看一下这道题w（http://hzwer.com/3697.html）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>萌萌哒喵酱</author>
<guid isPermaLink="false">2018-01-29-33406432</guid>
<pubDate>Mon, 29 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何让你的正则表达式拥有更好的性能</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-01-13-32896848.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32896848&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-569c3849ef9adeb2f616b0da2e694c31_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;首先呢, 这里要写的不是如何编写高效的正则表达式, 而是正则表达式引擎内部使用的一些编译优化小技巧, 以及探讨这些技巧的适用范围. &lt;/p&gt;&lt;p&gt;这里关注的是通用NFA引擎, 也就是大家平时在各种语言里最常调用的正则表达式库使用的算法. 当然啦, 还有另外一种DFA引擎比如RE2, 由于DFA的限制, 这类引擎非常难甚至不可能实现大部分的拓展(如环视和向后引用).&lt;/p&gt;&lt;p&gt;文章里我将写一些通用的正则表达式引擎技术以及技巧, 在了解了引擎之后相信大家能对正则表达式由更深入的了解同时也能更好地写出更高效的正则表达式. 文章里写的大部分技术来自我的正则表达式引擎项目(各个库的做法会有差异, 不过原则是相通的, 如果对我的正则表达式引擎实现有兴趣请看文章结尾由介绍).&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;要讨论正则表达式引擎, 我们需要一个最基本引擎模型, 为了追求更好的性能, 这里使用的非递归的虚拟机模型, 执行的是由正则表达式编译成的字节码. 一个最基本的正则表达式虚拟机需要以下几种指令:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{MATCH}, \\ &amp;amp;\texttt{SPLIT}, \\ &amp;amp;\texttt{JMP}, \\ &amp;amp;\texttt{ACCEPT} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;例如对于正则表达式 &lt;equation&gt;\texttt{(a|b)*abb}&lt;/equation&gt; 将生成虚拟机指令:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split 1, 6}\\ &amp;amp;\texttt{1 split 2, 4}\\ &amp;amp;\texttt{2 match a}\\ &amp;amp;\texttt{3 jmp 5}\\ &amp;amp;\texttt{4 match b}\\ &amp;amp;\texttt{5 split 1, 6}\\ &amp;amp;\texttt{6 match a}\\ &amp;amp;\texttt{7 match b}\\ &amp;amp;\texttt{8 match b}\\ &amp;amp;\texttt{9 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;虚拟机的实现代码如下:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;enum BYTE_CODE
{
	MATCH,
	SPLIT,
	JMP,
	ACCEPT,
};

bool match_impl(std::string str, std::vector&amp;lt;ptrdiff_t&amp;gt; byte_code, 
	size_t&amp;amp; begin, size_t&amp;amp; end)
{
	struct state
	{
		size_t IP;
		size_t index;
	};

	std::vector&amp;lt;state&amp;gt; state_stack;
	size_t off = 0;

	while (off &amp;lt; str.length())
	{
		state_stack.clear();
		state_stack.push_back({ 0, off++ });

	fail_loop:;
		while (!state_stack.empty())
		{
			auto&amp;amp; state = state_stack.back();
			auto IP = state .IP;
			auto index = state.index;
			state_stack.pop_back();

		next_loop:;
			switch (byte_code[IP])
			{
			case BYTE_CODE::MATCH:
				if (index &amp;lt; str.length() &amp;amp;&amp;amp; (str[index] == byte_code[IP + 1]))
				{
					index++;
					IP += 2;
					goto next_loop;
				}
				goto fail_loop;
			case BYTE_CODE::SPLIT:
				state_stack.push_back({ static_cast&amp;lt;size_t&amp;gt;(IP + byte_code[IP + 2]), index });
				IP += byte_code[IP + 1];
				goto next_loop;
			case BYTE_CODE::JMP:
				IP += byte_code[IP + 1];
				goto next_loop;
			case BYTE_CODE::ACCEPT:
				begin=off; end=index;
				return true;
			default:
				return false;
			}
		}
	}
	return false;
}&lt;/code&gt;&lt;p&gt;这里的虚拟机结构和之前的文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24458116&quot;&gt;正则表达式与AOT编译&lt;/a&gt;里一致.&lt;/p&gt;&lt;p&gt;关于词法分析, 语法分析和指令生成等的细节这里不做更多讨论. 在有了基本的模型之后我们便可以开始讨论如何优化引擎了.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Direct threading&lt;/h2&gt;&lt;p&gt;首先是指令分派的 &lt;equation&gt;\texttt{while-switch}&lt;/equation&gt; 循环, 每执行一条指令需要执行一次 &lt;equation&gt;\texttt{switch}&lt;/equation&gt; , 可以使用GCC的拓展&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html&quot;&gt;Labels as Values&lt;/a&gt;将switch改写为Direct threading分派指令, 减小多余的跳转带来的开销:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;static const void *next_instr[] = { 
	&amp;amp;&amp;amp;byte_code_match,
	&amp;amp;&amp;amp;byte_code_split,
	&amp;amp;&amp;amp;byte_code_jmp,
	&amp;amp;&amp;amp;byte_code_accept,
}

switch (byte_code[IP])  //for initial instruction
{

case BYTE_CODE::MATCH:
{
byte_code_match:
	//code...
}
case BYTE_CODE::SPLIT:
{
byte_code_split:
	//code...
	goto *(next_instr[byte_code[IP]]);
}
case BYTE_CODE::JMP:
{
byte_code_jmp:
	goto *(next_instr[byte_code[byte_code[IP + 1]]]);
}
case BYTE_CODE::ACCEPT:
{
byte_code_accept:
	//code...
	return true;
}

}&lt;/code&gt;&lt;p&gt;更进一步, 可以使用Context Threading with Tiny inlining, 将解释器改写成半JIT形式, 不过使用这类技术需要动态生成native code, 这里不做更多讨论, 有兴趣可以阅读paper: &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.cs.toronto.edu/~matz/pubs/demkea_context.pdf&quot;&gt;Context Threading: A flexible and efficient dispatch technique for virtual machine interpreters [.PDF]&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Memory pool&lt;/h2&gt;&lt;p&gt;在虚拟机中我们使用了一个 &lt;equation&gt;\texttt{vector}&lt;/equation&gt; 来存储每一个状态, 但是 &lt;equation&gt;\texttt{vector}&lt;/equation&gt; 在这里的内存效率不高, 主要原因是不需要随机访问, 只需要访问最顶端的头部元素, 而 &lt;equation&gt;\texttt{vector}&lt;/equation&gt; 随着状态增长发生的内存增长分配和搬移会带来显著的花销. 这个时候改用双向链表会比较合适, 配合内存池进行状态分配以获取更好的内存效率.&lt;/p&gt;&lt;p&gt;实现的思想是保存链表头部指针&lt;/p&gt;&lt;ul&gt;&lt;li&gt;访问头部时直接返回该指针指向的节点中保存的状态&lt;/li&gt;&lt;li&gt;添加新状态时检查头部指针节点的后继节点, 若为空则从内存池分配新节点, 并将头部指针指向该节点.&lt;/li&gt;&lt;li&gt;释放状态时将头部指针移动至其指向节点的前趋节点, 而不是回收该节点的内存.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;内存池的实现策略可以是一个单链表, 每个节点内包含一大块内存, 每次申请从中取出一个地址, 用尽后分配新的节点, 在完成匹配后由内存池统一回收内存. 在内存布局上新的状态储存结构更接近块状链表.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Branch stack&lt;/h2&gt;&lt;p&gt;在正则表达式循环 &lt;equation&gt;\texttt{+, *, ?}&lt;/equation&gt; 中若是出现空匹配将会造成死循环, 避免该情况的方案是在每个状态内设置一个独立的栈(使用栈是为了应对嵌套的循环, 同时这个栈是相当有用的结构, 后续将继续沿用其以支持环视与递归匹配)记录在循环开始时的匹配位置, 在匹配结束时检查是否有变化, 如果没有变换则退出该循环避免死循环.&lt;/p&gt;&lt;p&gt;每个状态的结构如下:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;struct state
{
	size_t IP;
	size_t index;
	state_stack stack;
};&lt;/code&gt;&lt;p&gt;并添加两个新指令 &lt;equation&gt;\texttt{push, repeat}&lt;/equation&gt; 用于循环, 此时正则表达式&lt;equation&gt;\texttt{(a|b)+}&lt;/equation&gt; 将编译成:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 push index}\\ &amp;amp;\texttt{1 split 2, 4}\\ &amp;amp;\texttt{2 match a}\\ &amp;amp;\texttt{3 jmp 5}\\ &amp;amp;\texttt{4 match b}\\ &amp;amp;\texttt{5 repeat 1}\\ &amp;amp;\texttt{6 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;新增加的指令对应的虚拟机代码如下:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;case BYTE_CODE::PUSH_INDEX:
	state.stack.push(index);
	goto next_loop;
case BYTE_CODE::REPEAT:
	if(state.stack.back() != index)
	{
		state_stack.push_back({ static_cast&amp;lt;size_t&amp;gt;(IP + 2]), index, state.stack });
		IP += byte_code[IP + 1];
		goto next_loop;
	}
	else	//exit loop
	{
		IP += 2;
		goto next_loop;
	}&lt;/code&gt;&lt;p&gt;这个时候内存效率问题出现了, 如果我们使用数组或 &lt;equation&gt;\texttt{vector}&lt;/equation&gt; 来实现 &lt;equation&gt;\texttt{state_stack}&lt;/equation&gt; 的话在每次执行 &lt;equation&gt;\texttt{split} &lt;/equation&gt; 时需要将整个栈复制一整遍, 这是不忍直视的效率. 这个时候我们使用惰性求值的策略:&lt;/p&gt;&lt;p&gt;将栈实现为数形结构Branch stack, 即拥有多条分支的栈结构, 将树中.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在每次复制状态时仅仅增加栈顶元素的引用计数. &lt;/li&gt;&lt;li&gt;&lt;equation&gt;\texttt{push}&lt;/equation&gt; 时增长节点.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;\texttt{pop}&lt;/equation&gt; 时检查该节点的引用计数, 若为1则回收节点, 若大于1则减小引用计数, 增加后继节点的引用计数并且栈顶指针向后移动.&lt;/li&gt;&lt;li&gt;修改节点数据时检查引用计数, 若为1则直接在原地修改, 否则分叉该节点, 之后在分叉后的节点上修改数据.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里的分支栈结构比较接近functional programming的immutable data structures的实现.&lt;/p&gt;&lt;p&gt;在拥有栈以后可以用于计数循环的实现, 比如 &lt;equation&gt;\texttt{(a|b){3}}&lt;/equation&gt; 可以在栈上面记录当前的循环次数.&lt;/p&gt;&lt;p&gt;注: 关于避免空循环还有另外一种做法不需要栈(在NFA生成阶段处理掉了), 如果有兴趣的小伙伴请告诉我, 我下次写写.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Loop instruction&lt;/h2&gt;&lt;p&gt;在正则表达式中会经常出现单个字符的循环, 比如 &lt;equation&gt;\texttt{\d}*&lt;/equation&gt; , 对于单个字符, 每一次循环都需要执行一次 &lt;equation&gt;\texttt{match}&lt;/equation&gt; 和一次 &lt;equation&gt;\texttt{repeat}&lt;/equation&gt; , 在匹配失败后还需要Backtracking, 将造成极大的性能损失, 这个时候可以引入一个新的指令 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 用于执行单个字符的循环. &lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{loop}&lt;/equation&gt; 的实现非常简单, 只需要在 &lt;equation&gt;\texttt{match}&lt;/equation&gt; 上套上一层 &lt;equation&gt;\texttt{while}&lt;/equation&gt; 循环即可. 虽然实现简单但是带来的提升却是巨大的.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Memorization&lt;/h2&gt;&lt;p&gt;&lt;equation&gt;\texttt{loop}&lt;/equation&gt; 指令的引入还可以非常容易地实现记忆化, 由于 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 指令是单个字符的循环, 因此在进行状态记忆化时不需要记录下每一次进行匹配的位置, 只需要记录开始循环和结束循环的位置即可. &lt;/p&gt;&lt;p&gt;记忆化在考虑了memory footprint的平衡后, 我个人的建议是仅仅对 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 指令进行单次的记忆化(其余指令的记忆化往往需要记录大量的已匹配位置信息, 重入时亦需要大量的检查, 往往得不偿失).&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{loop}&lt;/equation&gt; 指令的记忆化能有效地优化诸如 &lt;equation&gt;\texttt{a*a*a*b}&lt;/equation&gt; 这样的正则表达式. &lt;/p&gt;&lt;p&gt;另外在递归匹配中也可以使用记忆化来优化同一位置的重入.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;One character Lookahead&lt;/h2&gt;&lt;p&gt;对于循环来说, 每一次循环都需要进行一次状态的保存, 在进行了以上的内存优化后仍然是一个不可忽视的开销, 在循环中可以使用单个字符的向前看来减少这种额外的开销.&lt;/p&gt;&lt;p&gt;举例如下:&lt;/p&gt;&lt;p&gt;对于正则表达式 &lt;equation&gt;\texttt{\d*0\d*}&lt;/equation&gt;匹配中间存在一个字符0的字符串, 在匹配字符串1230321时, 第一个循环 &lt;equation&gt;\texttt{\d*}&lt;/equation&gt; 将在每一个字符串位置进行一次状态保存, 实际上只有在匹配到123这个位置的时候才需要真正的进行状态保存, 其余位置均不需要, 因为仅有123的后继字符0能匹配.&lt;/p&gt;&lt;p&gt;对于循环, 我们可以通过静态分析收集循环之后的可能匹配的字符, 并在每一次循环结束时进行一次预匹配, 若是失败则不保存该状态直接进行下一轮循环.&lt;/p&gt;&lt;p&gt;另外我们可以通过更为精细的静态分析配合 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 指令实现更高的效率, 例如匹配一个合法的Gmail邮箱的正则表达式 &lt;equation&gt;\texttt{[\w.]+@gmail.com}&lt;/equation&gt; 对于循环&lt;equation&gt;\texttt{[\w.]+}&lt;/equation&gt;我们使用 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 的同时可以发现该处的 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 其实不需要进行预查, 因为&lt;equation&gt;\texttt{[\w.]}&lt;/equation&gt;与 &lt;equation&gt;\texttt{@}&lt;/equation&gt; 并不相交, 也就是说 &lt;equation&gt;\texttt{[\w.]}&lt;/equation&gt; 匹配成功则 &lt;equation&gt;\texttt{@}&lt;/equation&gt; 匹配必然不成功, 那么只需要进行简单的 &lt;equation&gt;\texttt{while}&lt;/equation&gt; 循环即可, 直到匹配失败后退出循环进行后续状态的匹配. &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Repetition classification&lt;/h2&gt;&lt;p&gt;对于一般的循环, 我们可以按照其属性分类&lt;/p&gt;&lt;ul&gt;&lt;li&gt;计数循环与非计数循环.&lt;/li&gt;&lt;li&gt;空循环与非空循环.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其中注意到非计数循环与非空循环并不需要在状态的栈上保留信息(非空循环不会陷入死循环), 因此也不需要在循环前执行 &lt;equation&gt;\texttt{push}&lt;/equation&gt; 指令.&lt;/p&gt;&lt;p&gt;计数循环与非计数循环可以在语法分析阶段加以区分, 而空循环与非空循环稍微复杂一点, 需要对正则表达式做静态分析, 在中间阶段生成NFA后从循环的节点开始进行深度优先搜索(DFS)若存在一条路径不匹配任何字符则该循环为空循环, 若不存在这样的路径则意味着该循环内部至少需要匹配一个字符, 即非空循环.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Loop unrolling&lt;/h2&gt;&lt;p&gt;对于循环展开相信大家都不会陌生, 对于计数循环我们可以对其做循环展开, 例如 &lt;equation&gt;\texttt{a{4}}&lt;/equation&gt; 可展开为 &lt;equation&gt;\texttt{aaaa}&lt;/equation&gt; , 展开后不需要循环指令和压栈一个计数.&lt;/p&gt;&lt;p&gt;更进一步地, 循环展开可以配合静态分析进行更多的优化.&lt;/p&gt;&lt;p&gt;其一是可以做字符合并, 为了效率我们可以引入一个新的指令 &lt;equation&gt;\texttt{match stirng}&lt;/equation&gt; , 将 &lt;equation&gt;\texttt{match}&lt;/equation&gt; 拓展为对字符串的匹配, 编译器可以对字符串的比较做更多的优化, 更加地, 例如 &lt;equation&gt;\texttt{aab{4}}&lt;/equation&gt; 可展开为 &lt;equation&gt;\texttt{aabbbb}&lt;/equation&gt; 在有字符串匹配指令下用一条指令 &lt;equation&gt;\texttt{match aabbbb}&lt;/equation&gt; 即可完成匹配.&lt;/p&gt;&lt;p&gt;其二是可以优化掉循环中的捕获组, 这里的优化同样需要进行一些静态分析, 在循环体中有引用的捕获组不可以被删除. 例如 &lt;equation&gt;\texttt{((\d)\2){3}}&lt;/equation&gt; 可展开为 &lt;equation&gt;\texttt{(\d)\2(\d)\2((\d)\2)}&lt;/equation&gt; 注意捕获组1在前两个循环中被删除掉了, 因为该捕获组会被最后一个循环体内的内容覆盖, 因此没必要保存下来.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Merge branches&lt;/h2&gt;&lt;p&gt;对于分支 &lt;equation&gt;\texttt{|}&lt;/equation&gt; 来说, 在遇到单个字符求或的情况下是可以进行合并的, 例如 &lt;equation&gt;\texttt{1|2|3|4|5|6|7|8|9|0}&lt;/equation&gt; 将可以合并成 &lt;equation&gt;\texttt{\d}&lt;/equation&gt; . &lt;/p&gt;&lt;p&gt;该优化的实现并不复杂, 只需要检查每一条分支是否为单字符即可, 若是单字符则进行合并.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Extract the common factor&lt;/h2&gt;&lt;p&gt;另外一类的关于分支的优化是提取公因式, 例如对于匹配数字0-255正则表达式&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2}}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中分支 &lt;equation&gt;\texttt{25[0-5]|2[0-4][0-9]}&lt;/equation&gt; 将可以进行公因式提取变成 &lt;equation&gt;\texttt{2(?:5[0-5]|[0-4][0-9])}&lt;/equation&gt; 注意提取了公因式 &lt;equation&gt;\texttt{2}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;提取公因式的优化原理是推迟分支, 减少重复匹配, 若是匹配失败能更早的Backtracking.&lt;/p&gt;&lt;p&gt;该优化的实现亦并不复杂, 只需要检查每一条分支的前缀即可, 若是相同则进行合并.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Capture group classification&lt;/h2&gt;&lt;p&gt;对于捕获组来说, 可以依据是否在分支内分成两类, 对于不在分支上的捕获组, 我们可以直接使用一个全局数组来保存其捕获结果, 因为其与路径的选取无关, 因此无需保存在状态内. 对于在分支上的捕获组则需要在状态内保存捕获数据. 其中对数组的访问的内存效率是要高于访问状态的, 因此这类优化可以提高内存效率.&lt;/p&gt;&lt;p&gt;该优化的实现并不复杂, 只需要生成NFA后检查捕获组是否在分支内即可. 另外若支持递归匹配还需要考虑该捕获组是否在某个递归模式内, 因为递归模式的分支是隐含在状态内的栈上的.&lt;/p&gt;&lt;p&gt;另外对于在递归模式内的捕获组需要做额外的分析, 例如 &lt;equation&gt;\texttt{^((.)((?1)|)\2)\$}&lt;/equation&gt; , 其中在递归中捕获组3不需要记录, 因为其在递归中没有被引用, 在递归结束后递归体内的所有捕获组将会被清空.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Capture group analysis&lt;/h2&gt;&lt;p&gt;正则表达式里的路径分析的作用类似于常量折叠, 作用与条件表达式上, 对于向后引用也有作用. 原理是检查当前路径下所有必定捕获的捕获组用以确定条件.&lt;/p&gt;&lt;p&gt;举例来说表达式 &lt;equation&gt;\texttt{\1(.)}&lt;/equation&gt; 必定失败, 因为捕获组1在向后引用时未被捕获, 对于这种情况可在路径的字节码最后添加上一个 &lt;equation&gt;\texttt{halt}&lt;/equation&gt; 指令配合下面的Halt path elimination优化使用. &lt;/p&gt;&lt;p&gt;使用全局数组保存捕获结果依赖于此优化, 否则在Backtracking后数组中会留下前一状态的捕获结果, 若正好当前状态在完成捕获前引用了该捕获将会导致意料之外的结果.&lt;/p&gt;&lt;p&gt;另外的一个例子是 &lt;equation&gt;\texttt{(.)(?(1)a|b)}&lt;/equation&gt; 将会被优化成 &lt;equation&gt;\texttt{(.)a}&lt;/equation&gt; 因为在进行条件判断时捕获组1已经完成匹配了, 因此该条件表达式恒真.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Subroutine inline&lt;/h2&gt;&lt;p&gt;在正则表达式中, 对于调用Subroutine可以使用类似于C语言中的inline优化方法把被调用的模式inline到调用处, 优点是消除了一次 &lt;equation&gt;\texttt{call}&lt;/equation&gt; 与 &lt;equation&gt;\texttt{return}&lt;/equation&gt; 同时可以结合上下文环境做例如lookahead分析, Capture group analysis等的优化, 同时也利于Memorization. &lt;/p&gt;&lt;p&gt;举例如下:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{(a+).(?1)}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中 &lt;equation&gt;\texttt{(?1)}&lt;/equation&gt; 调用了模式 &lt;equation&gt;\texttt{a+}&lt;/equation&gt; , 在inline后表达式为 &lt;equation&gt;\texttt{(a+).a+}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;inline是相当常见的优化技术了, 这里不做赘述.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Recursive unfold&lt;/h2&gt;&lt;p&gt;对递归函数就行展开类似于Subroutine inline, 将最底层的递归调用展开, 好处也是于inline类似的. 值得注意的是递归的展开条件更严格, 调用递归模式在自身内只出现一次时进行展开, 否则展开的字节码将呈指数级暴涨.&lt;/p&gt;&lt;p&gt;举例如下, 匹配闭合的大括号:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{\{((?R)|)\}}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中 &lt;equation&gt;\texttt{(?R)}&lt;/equation&gt; 调用了整个模式自身, 在展开一次后表达式为 &lt;equation&gt;\texttt{\{(\{(?:(?R)|)\}|)\}}&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;注意此处展开的捕获组将会被消去(由于其在递归模式中).&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Halt path elimination&lt;/h2&gt;&lt;p&gt;字节码中有一种路径是永远不会成功匹配的, 这个时候可以将其分支削去, 举例来说:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split 1, 3}\\ &amp;amp;\texttt{1 halt}\\ &amp;amp;\texttt{2 match a}\\ &amp;amp;\texttt{3 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中 &lt;equation&gt;\texttt{halt}&lt;/equation&gt; 表示无条件匹配失败, 这时候 &lt;equation&gt;\texttt{split 1, 3}&lt;/equation&gt; 可以削去, 优化后的字节码如下:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 match a}\\ &amp;amp;\texttt{1 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Fold control flow&lt;/h2&gt;&lt;p&gt;这个是非常常见的指令层级的优化了, 举例来说对于表达式 &lt;equation&gt;\texttt{a|b|c}&lt;/equation&gt; , 若不进行分支合并生成的字节码如下:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split 1, 6}\\ &amp;amp;\texttt{1 split 2, 4}\\ &amp;amp;\texttt{2 match a}\\ &amp;amp;\texttt{3 jmp 5}\\ &amp;amp;\texttt{4 match b}\\ &amp;amp;\texttt{5 jmp 7}\\ &amp;amp;\texttt{6 match c}\\ &amp;amp;\texttt{7 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;第三行的 &lt;equation&gt;\texttt{jmp 5}&lt;/equation&gt; 可以优化为 &lt;equation&gt;\texttt{jmp 7}&lt;/equation&gt; . 连续跳转可以合并为单个跳转. 同样地 &lt;equation&gt;\texttt{split}&lt;/equation&gt; 也可以做这样的优化, 例如 &lt;equation&gt;\texttt{a||c}&lt;/equation&gt; 中的&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split 1, 6}\\ &amp;amp;\texttt{1 split 2, 4}\\ &amp;amp;\texttt{2 match a}\\ &amp;amp;\texttt{3 jmp 6}\\ &amp;amp;\texttt{4 jmp 6}\\ &amp;amp;\texttt{5 match c}\\ &amp;amp;\texttt{6 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中第二行 &lt;equation&gt;\texttt{split 2, 4}&lt;/equation&gt; 可以优化为 &lt;equation&gt;\texttt{split 2, 6}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Dead code elimination&lt;/h2&gt;&lt;p&gt;这个也是非常常见的指令层级的优化了, 继续沿用上面的例子&lt;equation&gt;\texttt{a||c}&lt;/equation&gt; , 进一步执行死代码消除后便是:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split 1, 2}\\ &amp;amp;\texttt{1 match a}\\ &amp;amp;\texttt{2 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这个优化实现也很简单, 这里不做赘述.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;JIT/AOT&lt;/h2&gt;&lt;p&gt;请参阅: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/24458116&quot;&gt;正则表达式与AOT编译&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;另外还有一些优化技术比如条件分支, 分支重排, 以及更细致的分支合并与跳转我还没来得及实现与试验, 等以后有机会再向大家做更多的介绍, 另外JIT/AOT还没有真正实现好.&lt;/p&gt;&lt;p&gt;这篇文章主要关注的优化技术, 具体的特性实现没怎么讲, 要是大家有兴趣我再写篇文章慢慢讲, 特别是一下丧心病狂的特性应该怎么做.&lt;/p&gt;&lt;p&gt;以上的所有优化技术均在我的千雪(ちゆき, Chiyuki)正则表达式引擎里实现了, 感兴趣的小伙伴欢迎来看看呀(源码一共有13000多行, 用C++17写哒, 如果需要测试代码或显示字节码的代码请告诉我):&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://hcc.trilines.net/regex/&quot;&gt;Chiyuki Regex&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;千雪支持的特性可以去&lt;a href=&quot;http://hcc.trilines.net/regex/syntax.html&quot;&gt;syntax reference&lt;/a&gt;里看看喔(基本上环视, 捕获/引用, 命名捕获, 条件匹配, 原子组, 递归匹配都支持), 我是将她作为通用引擎设计的, 尽可能多支持一些拓展. 其中由于引擎的设计支持一些非常丧心病狂的特性, 比如无限制的环视, 你甚至可以在环视内部使用嵌套循环与递归. 而且递归也不像PCRE那样是原子性的, 这意味着你可以跨递归层进行匹配. 由于我比较笨, 在这种尤其丧心病狂的特性下想不出什么很好的test case, 又没有别的引擎来做对照, 所以不知道对不对, 有没有bug.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;说了那么多优化, 我想小伙伴们肯定会好奇她的性能怎么样, 网页上的benchmark是很久以前的版本啦, 新的跑得更快一些. 现在的千雪大概跑得比非JIT的PCRE快一点(等我把JIT/AOT做出来再和你比JIT), 比Boost快两点, 将来还会更快哒. 当然啦这只是match的性能. 我没有针对search做特别的优化, 所以search在一些情况下被PCRE吊打了呀哈哈. 等我有空给大家补上新的测试数据(评论区里有3个简单的test cases对比).&lt;/p&gt;&lt;p&gt;她的缺点非常明显, 就是编译性能非常糟糕, 我想大家应该都能想到, 毕竟要跑那么多躺分析, 不过带来的好处也是有哒, 那就是很容易做进一步的去抽象生成native code, 也就是AOT编译啦.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我觉得她还是蛮快的, 当然只是在我的机子上, 所以不知道是不是真的呢?&lt;/p&gt;&lt;p&gt;最后谢谢大家观看喵~&lt;/p&gt;</description>
<author>梨梨喵</author>
<guid isPermaLink="false">2018-01-13-32896848</guid>
<pubDate>Sat, 13 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>一招鲜，吃遍天</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-01-06-32677377.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32677377&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在Haskell等语言中，有datatype generic的概念：对于各种各样的ADT，都可以表示成一系列的Sum type 跟 Product type（因为这是ADT的定义），所以理论上，只要你能处理ADT的通用定义，你就能写一个对所有ADT适用的函数。其实这就是当你写deriving Show/Eq/Ord的时候发生的情况。generic，又称polytypic programming，就是把这理论变成现实的特性。注意这跟type generic是两码事。&lt;/p&gt;&lt;p&gt;这里面的Notable Work包括Scrap Your Boilerplate：把一定的类型信息塞到运行时，（Typable），然后就可以对某个类型做一种东西，而其他类型不变。然后可以写个高阶函数，对该类型做action，其他类型（wrapper，比如list/sum/either/whatever）就默认map进去，这样就可以给[Either [Double] Double]之类的type里面的所有Double翻倍，或者加起来返回。&lt;/p&gt;&lt;p&gt;GHC.generic做的是另外的东西，把一个类型表现成Sum type/Product type/Metadata（我们称作Rep），然后所有ADT都可以转化成这类型。然后加上把某类型变成它Rep的方法，就可以写function on all ADT，然后也可以写deriving等&lt;/p&gt;&lt;p&gt;True Sum Of Product就在GHC.generic上面做了层抽象，不用ADT来表示Rep，而是表示成[[*]] （类型的列表的列表）。然后有多参Product/Sum (可以想象成NProduct :: [*] -&amp;gt; *，其实具体情况复杂点），就可以直接组合/Map/Fold Product/Sum来完成generic programming，而无需在GHC.generic中递归，因为Sum type里面可能有Product type，然后里面再有Sum type。。。而这在True Sum Of Produt中不可能发生&lt;/p&gt;&lt;p&gt;然后还有Generic Generic Programming，因为有很多套Generic Library，每套都不一样，所以就搞出了个东西unify之。。。什么鬼&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;a href=&quot;https://wiki.haskell.org/Research_papers/Generics&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Generic Paper合集&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>脚本少女魔理沙</author>
<guid isPermaLink="false">2018-01-06-32677377</guid>
<pubDate>Sat, 06 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>萌萌的忙忙的小河狸</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-01-05-32664058.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32664058&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3305ab08851a89a08a55df6ecf9f1c42_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;题图出处：&lt;a href=&quot;https://vancoolver.ca/310341&quot;&gt;都怪冬天太长：加拿大“国宝”河狸被卡在栏杆&lt;/a&gt;&lt;/blockquote&gt;&lt;h2&gt;为什么河狸这么萌&lt;/h2&gt;&lt;p&gt;我们不知道为什么河狸这么萌，但是我们更加不知道为什么河狸这么……忙。它太忙了，所以它可能是世界上最忙、最Busiest的……的什么来着？图灵机。函数。Whatever。&lt;/p&gt;&lt;p&gt;Busy Beaver Function，记作BB(n)，是这样子的一个Function。给定输入n，它输出的值是具有n个状态的图灵机，在停机之前所能够在纸带上写下的“1”的最大的个数，并且这些1之间没有任何空隙。还有另外一种定义则直接定义它&lt;b&gt;输出的值代表n个状态的图灵机停机之前所走出的最大步数&lt;/b&gt;。我们先采用采用后者吧。&lt;/p&gt;&lt;p&gt;只有一个状态的图灵机，只会在1步以后停机——或者不停机；于是我们说，BB(1) = 1。两个状态的图灵机呢？4。BB(3) = 21。BB(4) = 107。但是BB(5) &amp;gt;= 47176870……&lt;/p&gt;&lt;h2&gt;累瘫了的小河狸&lt;/h2&gt;&lt;p&gt;具有n个状态的、满足BB(n)的计算条件的图灵机被我在这里叫做河狸机。这只河狸忙到什么程度呢……你可以利用它去&lt;b&gt;判断停机问题&lt;/b&gt;。因为它是所有的图灵机伙伴里面最忙的小河狸，所以不可能有什么图灵机比它还要忙。所以，在一只图灵机旁边放一只有相同状态个数的小河狸机。在小河狸累瘫（停机）以后，如果旁边的图灵机还没有停机的话，那么就表明那只图灵机一定不会停机——因为我们已经知道了n个状态的图灵机如果能够停机的话，那么它最多会走多少步。&lt;/p&gt;&lt;p&gt;再从头到尾看一次。如果我们能够计算BB函数，那么我们就能够判断停机问题。反过来说，计算小河狸的函数是，&lt;/p&gt;&lt;p&gt;不存在的。&lt;/p&gt;&lt;h2&gt;火星人和小河狸&lt;/h2&gt;&lt;p&gt;为什么我们要讨论火星人这种东西……&lt;/p&gt;&lt;p&gt;好吧，我想要问的是，我们现在有这样子的一个问题。我们有这样子的一个函数Mars，如果它知道火星上有火星人的话，那么它就会输出1；但是如果它知道火星上没有火星人的话，那么它就会输出0。问这个问题是不是可以计算的？答案是……可以，但是我们压根就不需要知道火星上有没有火星人。我们知道这个函数Mars只会输出0和1中的其中一个，所以它的语言是&lt;b&gt;有限&lt;/b&gt;的，有限的语言都是可计算的。或者说，一个函数输出的所有可能是有限的，那么它就一定是可计算的（枚举所有的答案即可）；但是一个函数的输出的所有可能如果是一个无限的集合，那么它未必可计算。&lt;/p&gt;&lt;p&gt;以及，Mars(x) or NOT(Mars(x))的值一定是1。如果存在一个判断停机问题的函数HALT的话，HALT(x, a) or NOT(HALT(x, a))的值也一定是1。（为什么我要写成HALT(x, a)而不是HALT(x)？）&lt;/p&gt;&lt;p&gt;那么下面这个呢？&lt;/p&gt;&lt;p&gt;&lt;equation&gt;M_{ar-ver} = \frac{1}{BB(1)} + \frac{1}{BB(2)} + \frac{1}{BB(3)}...&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;为了让“可计算”在这里的定义更明确一点，也因为S是一个实数的缘故。是否存在一个算法，对于输入k，输出一个有理数M&#39;，使得|M - M&#39;| &amp;lt;= 1/k？&lt;/p&gt;&lt;h2&gt;忙忙的小河狸&lt;/h2&gt;&lt;p&gt;在给出这个答案之前，我们先留意一下另外一只小河狸：啃纸带的小河狸。它想要在纸带上留下最多的、连续的1，把纸带给啃得干干净净。这只小河狸太忙了，以至于我们可能还是会惊讶于为什么BB(5)看起来这么大……以及对于更大的n，总觉的那都是那堆数学家无聊蛋疼的产物。。。小河狸是如此地忙，以至于它比任何图灵机都要忙……比任何可计算的函数都要忙……&lt;b&gt;因此不可计算&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;好吧，为什么这样子说？虽然知道了它不可计算，但是为什么它比任何可计算的函数都要忙？&lt;/p&gt;&lt;p&gt;好，那么我们有一个任意的可计算函数f。现在我们要构造另外一个可计算函数：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;g(x) = \sum_{i=1}^{x}[f(i) + i^2]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这个函数显然可计算。&lt;/p&gt;&lt;p&gt;从g(x)的定义，我们立刻有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;g(x) &amp;gt;= f(x)；&lt;/li&gt;&lt;li&gt;g(x) &amp;gt;= x^2；&lt;/li&gt;&lt;li&gt;g(x+1) &amp;gt;= g(x)。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;假设有一台计算函数g的图灵机G，它具有q个状态，并且会让一个写了x+1那么多个1的纸带，变成g(x)+1那么多的纸带。从这个图灵机，我们要构造另外一个图灵机——&lt;/p&gt;&lt;p&gt;&lt;equation&gt;T = P^{x+1}.G.G&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;虽然说定义看起来很奇怪，但是那只是因为我们不知道P^x+1是什么。P^x+1是一个打印机，它可以没有小河狸那么忙，但是它一定要啃够x+1那么多的1（在纸带上留下这么多的一串1，然后停机）。所以上面的T的意思是，&lt;/p&gt;&lt;ul&gt;&lt;li&gt;先用打印机在纸带上留下x+1那么多的1；&lt;/li&gt;&lt;li&gt;然后用一次G，将x+1那么多的1改成g(x)+1那么多的1；&lt;/li&gt;&lt;li&gt;然后再用一次G，将g(x)+1那么多的1改成最后的g(g(x))+1那么多……的1。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;哇，真是多死了。&lt;/p&gt;&lt;p&gt;一个打印机打印x+2个1的话，可以被一个具有x个状态的图灵机构造出来。（为什么？）所以，T的内部状态个数是x+q+q（为什么？）。所以，&lt;/p&gt;&lt;p&gt;&lt;equation&gt;BB(x + 2q) \ge g(g(x)) + 1&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;因为我们构造出来的这个T在纸带上啃了那么多1，所以小河狸一定要比它……不对，至少要比它忙。&lt;/p&gt;&lt;p&gt;但是这有什么问题呢？&lt;/p&gt;&lt;ul&gt;&lt;li&gt;g(x) &amp;gt; x + 2q，因为g(x) &amp;gt;= x^2。&lt;/li&gt;&lt;li&gt;g(x + 2q) &amp;gt;= f(x + 2q)，因为g(x) &amp;gt;= f(x)。&lt;/li&gt;&lt;li&gt;BB(x + 2q) &amp;gt; g(x + 2q)，因为BB(x + 2q) &amp;gt;= g(g(x)) + 1（再具体点？）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;或者说，BB(x + 2q) &amp;gt; f(x + 2q)……或者说BB(x) &amp;gt; f(x)。&lt;/p&gt;&lt;p&gt;所以小河狸比任何图灵机都忙。你们有没有在现实中看到过这么忙的一个小河狸？&lt;/p&gt;&lt;h2&gt;不忙，但是依然萌&lt;/h2&gt;&lt;p&gt;虽然说小河狸是因为忙所以萌，但是卖萌并不需要忙。&lt;/p&gt;&lt;p&gt;花栗鼠(Chipmuck)机是这样子的一只函数：CM(n) = “n个状态的图灵机中可以构成打印机的图灵机数目”，那么虽然说这个函数并不忙，但是依然不可计算。&lt;/p&gt;&lt;p&gt;令BD(n, m)表示“n个状态的、m步内停机的图灵机中可以构成打印机的图灵机数目”（Busy Down），又令&lt;/p&gt;&lt;p&gt;&lt;equation&gt;S_{uper}BB(n) = min_n(CM(n) - BD(n, m) = 0)&lt;/equation&gt; ，或者说，让CM(n) - BD(n, m) = 0的最小的n。首先，BD显然是可计算的（为什么？）；所以如果CM也是可计算的，则SBB也是可计算的。但是SBB不可计算，因为SBB(n) &amp;gt;= BB(n)……等等，这个SBB的定义就是那一只“n个状态内最大的行动步数”的小河狸！真是萌萌哒。&lt;/p&gt;&lt;p&gt;萌性我们证完了，但是花栗鼠并不忙。因为一个具有n个状态的图灵机的数目是有限的，具体地，它的数目是 &lt;equation&gt;(6n)^{2n}&lt;/equation&gt; 。所以我们永远地有， &lt;equation&gt;CM(n) \le (6n)^{2n}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;Super (Super Busy) Beaver&lt;/h2&gt;&lt;p&gt;如果我们已经计算出了BB(1), BB(2), ……BB(n-1)，并且之前提到的S是可计算的，那么下面的这个一定是可计算的：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;M_n = \frac{1}{BB(n)} + \frac{1}{BB(n+1)} + ...&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;因为每一个BB(n)都比BB(n-1)要大，易知M_n是收敛的，也就是说，有界（什么？没学过高数？）。于是我们就也可以计算出1/(M_n)的上界。但是M_n的第一项就是1/BB(n)，并且后面每一项都比前面的一项要小很多，所以如果我们能计算出1/(M_n)的上界，我们就可以计算出1/BB(n)和BB(n)的界……意味着能计算BB(n)。&lt;/p&gt;&lt;p&gt;但是小河狸是不可计算的。&lt;/p&gt;&lt;p&gt;所以BB(n)是不可计算的，所以BB(n-1)是不可计算的，所以……所以我们的前提即便成立，即便我们知道BB(1) = 1，我们也知道，M_n是不可计算的，也知道……M是不可计算的。&lt;/p&gt;&lt;p&gt;所以M也和小河狸一样萌。&lt;/p&gt;&lt;p&gt;于是我们发现了一个很萌的有理数，很多有理数都没有这么萌。&lt;/p&gt;&lt;p&gt;你有见过这么萌的有理数吗？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;参考：&lt;/p&gt;&lt;p&gt;（习题）Scott Aaronson. 《Quantum Computing Since Democritus》&lt;/p&gt;&lt;p&gt;（习题）Michael Sipser. 《计算理论导引》&lt;/p&gt;&lt;p&gt;张鸣华. 《可计算性理论》&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;－－－－－－－－&lt;/p&gt;&lt;p&gt;注：Beaver是Beaver，但是Chipmuck只在这里是Chipmuck。&lt;/p&gt;&lt;p&gt;最后的最后，有人知道为什么我会说g(x)显然可计算嘛？&lt;/p&gt;</description>
<author>钟狸</author>
<guid isPermaLink="false">2018-01-05-32664058</guid>
<pubDate>Fri, 05 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>JavaScript实现ZLOGO: 用语法树实现多层循环</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-01-03-32571516.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32571516&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;照例先上演示弱效果图. 演示地址&lt;a href=&quot;http://codeinchinese.com/%E5%9C%883/%E5%9C%883.html&quot;&gt;照旧&lt;/a&gt;:&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-86c83e8129d192b4f22b8fa8d0ad4b40_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;117&quot; data-rawheight=&quot;117&quot;&gt;&lt;p&gt;代码如下:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;开始
  循环4次
    循环4次
      前进50
      左转90度
    到此为止
  右转90度
  到此为止
结束&lt;/code&gt;&lt;p&gt;如上文&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31870155&quot;&gt;JavaScript实现ZLOGO子集: 测试用例&lt;/a&gt;末尾所言, 此文用Antlr进行代码分析生成语法树. 再通过语法树生成p5js绘制代码.&lt;/p&gt;&lt;p&gt;Antlr支持两种代码分析方法, Visitor(监听者)和Visitor(访问者). SO上的问答&lt;a href=&quot;https://stackoverflow.com/questions/20714492/antlr4-listeners-and-visitors-which-to-implement&quot;&gt;Antlr4 Listeners and Visitors - which to implement?&lt;/a&gt;大致说明了区别. 基于有限的实践, 用Visitor方法生成语法树似乎在实现上更加方便. 尤其相比&lt;a href=&quot;http://ivanyu.me/blog/2014/09/13/creating-a-simple-parser-with-antlr/&quot;&gt;Creating a simple parser with ANTLR&lt;/a&gt;一文中使用监听者+栈来构建语法树.&lt;/p&gt;&lt;p&gt;Antlr生成工具默认不生成Visitor, 添加-visitor参数后可以生成:&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;java -cp &quot;antlr-4.7-complete.jar:$CLASSPATH&quot; org.antlr.v4.Tool -Dlanguage=JavaScript -visitor 圈3.g4&lt;/code&gt;&lt;p&gt;下面是&quot;定制访问器.js&quot;中构建语法树的部分, 看起来比实现前想的简单. 默认生成的&#39;圈3Visitor&#39;中, visitXX方法实现都是&quot;this.visitChildren(ctx)&quot;, 但那样会把所有的子节点返回值放进数组, 形成(至少这里是)多余的层次:&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;定制访问器.prototype.visit程序 = function(上下文) {
  语法树 = {子节点: this.visit(上下文.声明())};
  return 语法树;
};

定制访问器.prototype.visit循环 = function(上下文) {
  return {
    类型: &#39;循环&#39;,
    次数: parseInt(上下文.T数().getText()),
    子节点: this.visit(上下文.声明())};
};

定制访问器.prototype.visit声明 = function(上下文) {
  return this.visit(上下文.getChild(0));
};

定制访问器.prototype.visit转向 = function(上下文) {
  var 方向 = 上下文.T转向().getText();
  var 角度 = parseInt(上下文.T数().getText()) * (方向 === &quot;左&quot; ? 1 : -1);
  return {类型: &#39;转向&#39;, 参数: 角度};
};

定制访问器.prototype.visit前进 = function(上下文) {
  return {类型: &#39;前进&#39;, 参数: parseInt(上下文.T数().getText())};
};&lt;/code&gt;&lt;p&gt;上面的源码生成语法树大致如下所示. 实现上还有很多需要改进的, 比如&#39;前进&#39;和&#39;转向&#39;现在是两种&#39;类型&#39;, 但应该是一种; 根节点类型不应为空; 等等:&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-64cffeb88c144dc65304f5d678d02849_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;412&quot; data-rawheight=&quot;257&quot;&gt;&lt;p&gt;下面是&quot;编译.js&quot;中基于语法树生成指令列表的方法, 之后就与之前一样根据指令列表生成p5js绘制函数(代码也不用修改).&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;function 生成指令序列(节点) {
  var 指令序列 = [];
  // TODO: 根节点类型不应为空
  if (!节点.类型) {
    var 声明节点 = 节点.子节点;
    for (var i = 0; i &amp;lt; 声明节点.length; i++) {
      Array.prototype.push.apply(指令序列, 生成指令序列(声明节点[i]));
    }
  } else if (节点.类型 == &quot;循环&quot;) {
    var 指令序列 = [];
    for (var i = 0; i &amp;lt; 节点.次数; i++) {
      Array.prototype.push.apply(指令序列, 生成指令序列({子节点: 节点.子节点}));
    }
  } // TODO: 修改类型统一为&#39;指令&#39;
  else if (节点.类型 == &quot;前进&quot; || 节点.类型 == &quot;转向&quot;) {
    return [{名称: (节点.类型 == &quot;前进&quot; ? 常量_指令名_前进 : 常量_指令名_转向), 参数: 节点.参数}];
  }
  return 指令序列;
}&lt;/code&gt;&lt;p&gt;修改相应测试用例, 以及清理不再使用的监听器代码后. 代码已从visitor分支(&lt;a href=&quot;https://github.com/program-in-chinese/quan3/tree/visitor&quot;&gt;program-in-chinese/quan3&lt;/a&gt;)合并到master.&lt;/p&gt;</description>
<author>吴烜</author>
<guid isPermaLink="false">2018-01-03-32571516</guid>
<pubDate>Wed, 03 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>从计算复杂度往上往前（和两个没什么卵用的定理）</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-29-32476294.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32476294&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;在P和NP出现之前计算复杂性是怎么度量的？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;SPACE(f(n))，TIME(f(n))……这是在Scott Aaronson在&lt;a href=&quot;https://www.scottaaronson.com/democritus/&quot;&gt;《Quantum Computing Since Democritus》&lt;/a&gt;中PaleoComplexity一章里面所给出的答案。再翻翻其它的书，我们会得到的答案是，P=DTIME(n^c)。EXP=DTIME(2^(n^c))。（DTIME的意思是对于确定性图灵机的时间，Deterministic）NP的定义是“被非确定图灵机（Non-Deterministic）在多项式时间内解决的问题”，所以是NTIME(n^c)。&lt;/p&gt;&lt;p&gt;所以这真的就是Complexity的源头嘛？那么Complexity和Recursion Theory之间的关系究竟是什么呢？&lt;/p&gt;&lt;p&gt;这篇文章很短，因为我看书的速度比我打字的速度要快很多，所以我想偷懒（逃）不想写那么多；以及深觉文笔乏力，光看着一堆证明过程就已经觉得很爽很发光。&lt;/p&gt;&lt;p&gt;怀着很憋屈又很尊敬的心情去读书，书中的定理自然是不止那么多，很想安利人来入坑，对，这篇文章是一篇很憋屈很憋屈的安利文_(:з」∠)_&lt;/p&gt;&lt;p&gt;－－－－－－－－&lt;/p&gt;&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Blum_axioms&quot;&gt;Blum公理&lt;/a&gt;和&lt;a href=&quot;http://port70.net/~nsz/articles/classic/blum_complexity_1976.pdf&quot;&gt;计算复杂性的尺度&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;equation&gt;\{\varphi_i\}&lt;/equation&gt; 是所有的&lt;a href=&quot;https://en.wikipedia.org/wiki/%CE%9C-recursive_function&quot;&gt;递归函数&lt;/a&gt;（以及mu是一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Theory_of_descriptions&quot;&gt;摹状词&lt;/a&gt;）的枚举，其中i是第i个递归函数所对应的编号（对应到图灵机上就是哥德尔编号i所对应的图灵机）， &lt;equation&gt;\{\Phi_i\}&lt;/equation&gt; 是一组递归函数的序列。称 &lt;equation&gt;\Phi&lt;/equation&gt; 是计算复杂性的尺度（意味着计算复杂性尺度也是一个函数），当且仅当以下两个条件被满足：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;equation&gt;\varphi_i(x)&lt;/equation&gt; 有值当且仅当 &lt;equation&gt;\Phi_i(x)&lt;/equation&gt; 有值；&lt;/li&gt;&lt;li&gt;特征函数K是一个完全递归函数： &lt;equation&gt;K(i, x, y) = \begin{equation} \left\{ \begin{array}{lr} 1 &amp;amp; \Phi_i(x) = y,\\ 0 &amp;amp; otherwise(例如无定义) \end{array} \right. \end{equation} &lt;/equation&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所以来看看所谓的&lt;b&gt;时间复杂度&lt;/b&gt;是怎么对应上来的嘛？&lt;/p&gt;&lt;p&gt;&lt;equation&gt;T_i(x) = \begin{equation} \left\{ \begin{array}{lr} y &amp;amp; 多带图灵机\varphi_i(x)有值且计算步数为y,\\ undefined &amp;amp; otherwise \end{array} \right. \end{equation} &lt;/equation&gt; &lt;/p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Multitape_Turing_machine&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Multitape Turing Machine&lt;/a&gt;&lt;blockquote&gt;（问：证明这个“尺度”是一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_function&quot;&gt;完全递归函数&lt;/a&gt;，如果追求更完整的话，证明存在一个K与这个尺度对应）&lt;br&gt;（Extra Credit：证明&lt;b&gt;量子计算机&lt;/b&gt;的时间复杂度类是存在合法尺度的）&lt;/blockquote&gt;&lt;p&gt;那么&lt;b&gt;空间复杂度&lt;/b&gt;呢？&lt;/p&gt;&lt;p&gt;&lt;equation&gt;T_i(x) = \begin{equation} \left\{ \begin{array}{lr} y &amp;amp; 脱线图灵机\varphi_i(x)有值且工作区使用的格子数为y,\\ undefined &amp;amp; otherwise \end{array} \right. \end{equation} &lt;/equation&gt; &lt;/p&gt;&lt;blockquote&gt;（问：同上）&lt;/blockquote&gt;&lt;h2&gt;计算复杂度尺度的一些性质&lt;/h2&gt;&lt;p&gt;&lt;b&gt;为什么“如果计算不会太复杂的话，函数的值就不会太大”&lt;/b&gt;&lt;/p&gt;&lt;p&gt;定理：存在完全递归函数h，使得 &lt;equation&gt;\forall i \ h(x, \Phi_i(x) \ge \varphi_i(x))\ a.e.(almost\ everywhere)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;证明：令&lt;/p&gt;&lt;p&gt;&lt;equation&gt;H(i, x, y) = \begin{equation} \left\{ \begin{array}{lr} \varphi_i(x) &amp;amp; \Phi_i(x) = y\\ 1 &amp;amp; otherwise \end{array} \right. \end{equation} &lt;/equation&gt; ，&lt;/p&gt;&lt;p&gt;又令&lt;/p&gt;&lt;p&gt;&lt;equation&gt;h(x, y) = \mathop{max}_{i \le x}H(i, x, y)&lt;/equation&gt;，&lt;/p&gt;&lt;p&gt;则按照&lt;a href=&quot;https://en.wikipedia.org/wiki/Primitive_recursive_function&quot;&gt;原始递归函数&lt;/a&gt;的定义，这两个函数都是完全递归函数。令 &lt;equation&gt;x \ge i&lt;/equation&gt; 且&lt;equation&gt;\varphi_i(x)&lt;/equation&gt; 定义，则 &lt;equation&gt;h(x, \Phi_i(x)) \ge H(i, x, \Phi_i(x)) = \varphi_i(x)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;为什么“一个算法可以有任意复杂（而非简单）的算法”&lt;/b&gt;&lt;/p&gt;&lt;p&gt;定理：f、h为两个完全递归函数。则存在f的号码（如哥德尔编号或者康托尔的配对编号）使得 &lt;equation&gt;\Phi_j(x) \ge h(x)&lt;/equation&gt; 。f的号码的意思是计算函数f的图灵机。&lt;/p&gt;&lt;p&gt;证明：令&lt;/p&gt;&lt;p&gt;&lt;equation&gt;g(i, x) = \begin{equation} \left\{ \begin{array}{lr} f(x) &amp;amp; \Phi_i(x) &amp;gt; h(x)\\ 1 + \varphi_i(x) &amp;amp; otherwise \end{array} \right. \end{equation} &lt;/equation&gt; ，&lt;/p&gt;&lt;p&gt;则g是递归函数。那么，存在这样的函数q，使得：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{equation} \varphi_{q(i)}(x)\xlongequal{s-m-n定理}g(i, x) \end{equation}&lt;/equation&gt; ；&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Smn_theorem&quot;&gt;s-m-n定理&lt;/a&gt;还有一个名字，叫做参数化定理。接下来，又由&lt;a href=&quot;https://en.wikipedia.org/wiki/Kleene%27s_recursion_theorem&quot;&gt;递归定理&lt;/a&gt;，存在编号j使得 &lt;equation&gt;\varphi_{q(j)}(x)＝\varphi_{j}(x)&lt;/equation&gt; ，所以有&lt;/p&gt;&lt;p&gt;&lt;equation&gt;g(j, x) = \varphi_j(x) \ne 1+\varphi_j(x)&lt;/equation&gt; ，因此不可能有 &lt;equation&gt;\Phi_i(x) \le h(x)&lt;/equation&gt; ，因此j是f的号码。没错，到头回来，又是万恶的&lt;a href=&quot;https://en.wikipedia.org/wiki/Diagonal_method&quot;&gt;对角线&lt;/a&gt;。&lt;/p&gt;&lt;blockquote&gt;为什么两个定理不矛盾&lt;br&gt;（答案：...）&lt;/blockquote&gt;&lt;p&gt;－－－－－－－－&lt;/p&gt;&lt;p&gt;最后，真的以为计算复杂性的源头就到此为止了吗？&lt;/p&gt;&lt;p&gt;或许还会有下次更新以让这篇文章没有那么寒酸。。。&lt;/p&gt;&lt;p&gt;（嗷嗷嗷嗷嗷嗷嗷呜啊_(:з」∠)_）&lt;/p&gt;</description>
<author>钟狸</author>
<guid isPermaLink="false">2017-12-29-32476294</guid>
<pubDate>Fri, 29 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>APL/J 安利：三次方求和公式是什么？ (J)</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-29-32467987.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32467987&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安利一个 QQ 群：欢迎加入 APL Programming，群号码：332833095。欢迎 APL，J 等好棒的这一系列编程语言讨论。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们来解决这个问题：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\\ 1^3+2^3+\dots+n^3=\ ?&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这个的答案看起来显然是个 4 次的多项式，于是我们试着代入 &lt;equation&gt;n=0\dots4&lt;/equation&gt; 分别算出结果，进行多项式插值。下面的互动的 log，你看爽不爽啊？&lt;/p&gt;&lt;p&gt;没体现出优势来？那你用你最喜欢的语言写一下相同的功能，一起来比较一下优劣之处呗。&lt;/p&gt;&lt;code lang=&quot;j&quot;&gt; NB. 5 以下的自然数
   i. 5
0 1 2 3 4

   NB. 5 以下自然数的三次方
   ] cubes =. (i. 5) ^ 3
0 1 8 27 64

   NB. =. 表示定义变量
   NB. ] 表示显示结果（否则定义的变量默认不会输出）

   NB. 我们定义了一个变量
   cubes
0 1 8 27 64

   NB. 乘方表
   ^/~ i. 3
1 0 0
1 1 1
1 2 4

   NB. 这样看着更清楚
   ^table~ i. 3
+-+-----+
|^|0 1 2|
+-+-----+
|0|1 0 0|
|1|1 1 1|
|2|1 2 4|
+-+-----+

   NB. 插曲：解线性方程
   NB. 2x + 3y = 7
   NB. 6x - 7y = 10

   NB. 矩阵
   &amp;gt; 2 3 ; 6 _7
2  3
6 _7

   NB. 这里的 _ 是负号的意思

   NB. 解这个方程
   7 10 %. (&amp;gt; 2 3; 6 _7)
2.46875 0.6875

   NB. 用分数表示的精确解 (两边参数使用 x: 来转换为高精度有理数值)
   (x:7 10) %. (x: &amp;gt; 2 3; 6 _7)
79r32 11r16

   NB. xry 表示 x/y

   NB. 5 以下自然数的三次方的前缀和
   +/\ (i. 5) ^ 3
0 1 9 36 100

   NB. 参考
   +/\ 1 2 5 _7 3 4
1 3 8 1 4 8

   NB. 5 以下乘方表
   ^/~ i. 5
1 0  0  0   0
1 1  1  1   1
1 2  4  8  16
1 3  9 27  81
1 4 16 64 256
   
   NB. 解方程求多项式插值
   ] res =. (+/\ (i. 5) ^ 3) %. ^/~ i. 5
_1.00017e_13 3.5314e_12 0.25 0.5 0.25

   NB. 精确解
   ] res =. (+/\ (x:i. 5) ^ 3) %. ^/~ x:i. 5
0 0 1r4 1r2 1r4
 
   NB. 多项式求值
   res p. 12
6084
 
   NB. 0^3 + 1^3 + ... + 12^3 = 6084
   +/ (i. 13)^3
6084

   NB. 验证得知结果正确&lt;/code&gt;&lt;p&gt;结果是&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\\ {1\over4}n^2+{1\over2}n^3+{1\over4}n^4&lt;/equation&gt; &lt;/p&gt;</description>
<author>dram</author>
<guid isPermaLink="false">2017-12-29-32467987</guid>
<pubDate>Fri, 29 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>怪名乱神</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-17-32085338.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32085338&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我想给大家介绍一门语言。&lt;/p&gt;&lt;p&gt;C*。&lt;/p&gt;&lt;p&gt;C*有什么特点呢？很著名很流行。&lt;/p&gt;&lt;p&gt;我们可以看看TIOBE Index：到2017年12月，这门语言的rating达到了30.965%以上，比Java，下一个最热的语言，高了一倍有余。&lt;/p&gt;&lt;p&gt;这门语言被广泛使用于各种领域：操作系统（Linux, Windows），分布式（Spark），深度学习（部分tensorflow），区块链（bitcoin），游戏引擎（Unity）。&lt;/p&gt;&lt;p&gt;同时，C*的方言包含C, C++, Java, C#等知名语言。&lt;/p&gt;&lt;p&gt;我们先从语法开始介绍：C*的一个程序，由多个声明组成。其中，一些声明属于函数声明，而一个函数又由多条语句组成。。。&lt;/p&gt;&lt;p&gt;是不是觉得很荒谬？C没有Class, C++没有垃圾回收，Java跟C#水火不容，为什么被认作同一语言？&lt;/p&gt;&lt;p&gt;而如果我告诉你，现实比这还魔幻呢？世界上有很多语言正被冠以‘C*’这样的名字，而这些语言中，毫无共通点？这些语言中，有的有静态类型，有的有动态类型，有的两个都有，有的GC，有的是为Arduino设计的，有的在JVM上，有的有Class，有的有Reflection，有的没有Assignment，有的基于Lambda Calculus，有的则不是，有的可以任意改自身语法，有的语法是二维的，是个表格，而不是线性的，而有的甚至自带GUI，是livecoding的鼻祖之一。。&lt;/p&gt;&lt;p&gt;而这些语言，通通被称作同一个语言：Lisp。&lt;/p&gt;&lt;p&gt;而更魔幻的在后面：于是，有很多人开始讨论，为啥这门语言没有取得主流化，为啥这门语言效率这么高。。。然后得出很多答案，其中一半的直接是错误的，如：&lt;/p&gt;&lt;blockquote&gt;Lisp是第二早的高级语言，所以XXX，所以效率很高&lt;/blockquote&gt;&lt;p&gt;最早的编程语言Plankalkül，是1942到1945设计的，然后Fortran也比任何被称为Lisp的语言早。就算我们取最乐观的时间，1946到1955之间差了10年，里面出现了各种语言，AutoCode, ShortCode, Flow Chart, Haskell Curry的语言。。。&lt;/p&gt;&lt;p&gt;不过上述问题是技术错误，下面的论证则更离谱：&lt;/p&gt;&lt;blockquote&gt;Lisp社区很分裂，大家无法合作，所以没有流行&lt;/blockquote&gt;&lt;p&gt;。。。Excuse Me？如果有一天，C, C++, Java, C#都衰落了，再也没有人用，是不是因为C*社区很分裂，C/C++/Java/C#，你任意选出一对，肯定在互捏？大家无法合作也是啊，Java自己有一套库，C#自己一套，C跟C++也是，这么分裂，不衰退才怪！&lt;/p&gt;&lt;p&gt;欲加之罪，何患无辞啊！本来就不是同一个语言，为啥要放一起论证，然后去吐槽大家之间不兼容？&lt;/p&gt;&lt;p&gt;在一推只是因为历史原因被称作一家族的语言之间，找共通点，然后去论证这些语言的兴衰，特性，适用范围。。。能找出啥有价值，nontrivial的insight才怪。&lt;/p&gt;&lt;p&gt;至于S表达式？Logo不用括号，Racket有2d syntax，也有infix expression, Common Lisp有reader macro。。。试问这些语言是不是Lisp?而JMC也说过我们应该往M表达式迁移，那是不是JMC 发现了Lisp的本质劣根性？我们也可以用argument by absurdity，论证C*这个词的合理性 - 有花括号跟分号的就是C*，C*成为世界上最主流语言，C*万岁！&lt;/p&gt;&lt;p&gt;&#39;Lisp&#39;，这个词，已经没有任何有价值的意义，早就该被废弃，或者仅仅指JMC在1950末造的一个语言。就如同C*这个词不应该被引入一样。&lt;/p&gt;&lt;p&gt;另：最后，我想吐槽小部分所谓的‘Lisp’ 厨。往往，当你问，‘Lisp有什么优势/值得学’的时候（我们先不吐槽这问题提得很糟糕，就如同你不会问为啥要学C*/C*有啥优势），会跳出大致如下的答案：‘大部分主流语言的特性，早在Lisp中存在。主流PL发展只不过是catch up 1960 Lisp。’&lt;/p&gt;&lt;p&gt;这回答并很具误导性。&lt;/p&gt;&lt;p&gt;因为1960的时候，JMC 的确公开了一个语言，但是这个语言没有macro，是dynamic scope（读作：没有符合lambda calculus的first class function），连special form quote也没有（取而代之的是一个atom，换句话说你要quote compound expression得手动把(A B)转成(pair A B)）。在1967年，影响了Smalltalk跟无数学计算机人士的Logo出世，而在1970年，Scheme借鉴了Algol，修复了dynamic scope，也有macro跟continuation。Common Lisp在1984诞生，又在1990带来了Common Lisp Object System，跟metaobject protocol。1994，racket诞生，又在2002带来了composable &amp;amp; compilable macro。在今年，则出现了Collapsing Tower of Interpreter，实现了看上去有无数个interpreter，并且可以到达任何一个interpreter，更改语义，最后再运行普通的代码（并且看到更改语义带来的change），也出现了Type System as Macro，可以用宏代表静态类型。&lt;/p&gt;&lt;p&gt;这些语言都很有价值，很多都值得看。&lt;/p&gt;&lt;p&gt;但是没有一门叫Lisp的，在1960，搞对了Lambda Calculus，拥有大量影响力，有各种现代语言特性(Continuation, Type, Reflection, Macro)，有各种库，然后只有7条规则的语言。&lt;/p&gt;&lt;p&gt;我希望大家在讨论/宣传这些语言之一的时候，明白自己是在说啥。想说历史影响，可以用Scheme，玩极简主义，可以用JMC的Lisp，讨论OO，上Common Lisp，用Type/Contract，搞Racket。而不是一棒子打死，认为这些语言之间有任何共通点。&lt;/p&gt;</description>
<author>脚本少女魔理沙</author>
<guid isPermaLink="false">2017-12-17-32085338</guid>
<pubDate>Sun, 17 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Ad Infinitum!</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-15-32045442.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32045442&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近读了一篇paper，Duplication and Partial Evaluation，讲的是一门很。。奇怪的语言，&lt;/p&gt;&lt;p&gt;这门语言，可以大致想象是有无数个interpreter，一个stack着一个，interpret下一个，在最下，则是被解释的用户输入的代码。&lt;/p&gt;&lt;p&gt;你可以更改各种built in function，或者打印出来。比如说，你可以更改第1层（第0层为用户代码，第n+1层解释第n层代码）的apply，输入值print一次，输出值print一次，这样就实现了简陋debugger了。又或者对第二层解释器这样做，运行代码的时候就知道内部执行了啥&lt;/p&gt;&lt;p&gt;实现方法自然不能靠构造无限个interpreter，所以要先上laziness，按需增加，然后任何时刻，都有一个被解释的解释器去解释当下代码，然后有个被编译的解释器解释前一个解释器，这样就只有两轮。但是，这样，如果你更改n+2的代码，不会由n+1暴露到n层（换句话说n层看不出有啥区别），因为n层的时候，n+1层是被预编译的解释器执行，只有在n+1层看的到。这样，就顶多是两个编译器的开销。&lt;/p&gt;&lt;p&gt;‘顶多’，双重编译很疼，于是用了下Partial Evaluation，手动优化成一个编译器。&lt;/p&gt;&lt;p&gt;什么鬼啊这是。&lt;/p&gt;&lt;p&gt;可以在&lt;a href=&quot;http://io.livecode.ch/learn/readevalprintlove/black&quot;&gt;The reflective language Black&lt;/a&gt;试试看。&lt;/p&gt;</description>
<author>脚本少女魔理沙</author>
<guid isPermaLink="false">2017-12-15-32045442</guid>
<pubDate>Fri, 15 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Programming Languages: Application and Interpretation【译14】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-15-32037390.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32037390&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b71b632ed7974538bb2e812bcd20914e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;审校： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/9bebf466fc2535bec442451dca7cd13a&quot; data-hash=&quot;9bebf466fc2535bec442451dca7cd13a&quot; data-hovercard=&quot;p$b$9bebf466fc2535bec442451dca7cd13a&quot;&gt;@lotuc&lt;/a&gt; &lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;https://lotuc.gitbooks.io/plai-cn/content/&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;14 控制指令&lt;/h2&gt;&lt;p&gt;术语&lt;b&gt;控制&lt;/b&gt;指的是编程语言中任何使得计算过程前进的指令，因为它“控制”了计算机的程序计数器（program counter）。从这个意义上说，即使是简单的算术表达式也应该被认为是一种“控制”，而像顺序执行、函数调用和返回这样的操作，就更应该是了。不过，实践中我们通常用这个名词指代那些导致控制&lt;b&gt;非局部&lt;/b&gt;转移的——尤其是除了函数、过程以及将要学到的异常（exception）之外的——指令。本章我们将学习这类指令。&lt;/p&gt;&lt;p&gt;在研究这些控制指令时，需要指出的是，即使没有它们，我们的语言也是图灵完备的，也就是说我们并没有获得额外的“能力”。因此，控制指令所做的是，改变、改善我们的表达方式，从而增强程序的结构。所以，专注于程序的结构有益于本章的学习。&lt;/p&gt;&lt;h2&gt;14.1 Web上的控制&lt;/h2&gt;&lt;p&gt;让我们从研究Web程序的结构开始。考虑下面的程序：【注释】&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(display
  (+ (read-number &quot;First number&quot;)
     (read-number &quot;Second number&quot;)))&lt;/code&gt;&lt;blockquote&gt;今后，我们将把它称为“加法服务”。当然，你应该将它理解为更为复杂应用的一个简化版。例如，应用可能提示输入的是旅程的起点和目的地，加法对应的实际服务可能是根据输入的起点终点计算航线或者机票的价格。在两个（输入）步骤之间甚至可能也有计算：例如，在输入第一个城市后，航空公司可能会提示我们可供选择的目的地。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;为了测试这些想法，下面是read-number的实现：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (read-number [prompt : string]) : number
  (begin
    (display prompt)
    (let ([v (read)])
      (if (s-exp-number? v)
          (s-exp-&amp;gt;number v)
          (read-number prompt)))))&lt;/code&gt;&lt;p&gt;在控制台或DrRacket中运行时，该程序会提示我们输入一个数字，然后输入另一个数字，最后显示它们的总和。&lt;/p&gt;&lt;p&gt;现在假设我们想在Web服务器上运行。我们立即遇到难点：服务器端Web程序的结构是这样的：它们生成一个网页，比如请求第一个数字的网页，然后&lt;b&gt;停止&lt;/b&gt;。结果，&lt;b&gt;程序的其余部分&lt;/b&gt;——在这里，提示第二个数字，然后求和，然后打印结果——丢失了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;为什么Web服务器的行为如此奇怪？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;这种行为至少有两个原因：一个也许是历史的，另一个是技术的。历史原因是Web服务器最初设计为供应&lt;b&gt;页面&lt;/b&gt;，即静态内容。任何程序的运行都必须将其输出生成为文件，服务器将该文件提供给客户端。很自然的，开发人员想到为什么同样的程序在web上就不能按需运行。于是，后来Web上出现了&lt;b&gt;动态&lt;/b&gt;内容。构成Web应用的最小增量单元不再是页面，而是一个个执行结束后生成页面各个部分所需内容的程序。&lt;/p&gt;&lt;p&gt;更重要的原因——也是导致目前状况的原因——是技术性的。想象一下，我们的加法服务器已经生成了第一个提示。回想一下，有相当多的计算要进行：第二个提示，求和和显示结果。这些计算必须暂停，等待用户的输入。如果有成千上万的用户，那么必须暂停成千上万的计算，这会产生巨大的性能问题。此外，假设用户实际上没有完成计算——类似于在网上书店或航空公司网站上搜索，而不完成购买。服务器如何知道何时终止计算，甚至是否终止计算？而在终止之前，与该计算相关的资源仍被占用。&lt;/p&gt;&lt;p&gt;因此，Web协议从其概念上就被设计为&lt;b&gt;无状态的&lt;/b&gt;（stateless）：它不将与中间计算相关的状态存储在服务器上。这使得Web程序员被迫在其他地方维护所有必要的状态，每个请求都需要携带能够完全恢复计算所需的状态。在实践中，Web并不都是完全无状态的，但是它们在很大程度上倾向这个方向，因此研究这类程序的结构是非常有教益的。&lt;/p&gt;&lt;p&gt;接下来考虑一下客户端的Web程序：那些在浏览器中运行的程序，通常用JavaScript编写，或被编译成JavaScript。假设某个计算需要与服务器进行通信。（JavaScript提供的）指令为XMLHttpRequest。用户创建这个指令的实例，然后调用其&lt;code class=&quot;inline&quot;&gt;send&lt;/code&gt;方法向服务器发送消息。然而，与服务器通信并不是即时的（并且根据网络的状态，实际上可能永远不会完成）。这导致发送进程被挂起。&lt;/p&gt;&lt;p&gt;JavaScript的设计者决定让该语言是&lt;b&gt;单线程&lt;/b&gt;的，即，任意时间只能有一个线程在执行。【注释】这避免了赋值与线程结合而产生的各种风险。因此，JavaScript进程会被锁定以等待响应，这期间不可能做任何其他事情：例如，页面上的其他处理程序不再响应。&lt;/p&gt;&lt;blockquote&gt;因为这会导致结构性问题，现在有各种提议，实际上是要为JavaScript添加“安全的”线程。本章所描述的想法可以被看作是另一种方案，提供类似的结构优势。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;为了避免这个问题，XMLHttpRequest的设计要求开发者提供一个函数来响应请求（请求到达时将调用该程序）。该回调函数在系统中注册。需要传递请求结果给该回调函数让其完成&lt;b&gt;后续处理过程&lt;/b&gt;。因此，并非处于性能方面的考虑，而是为了避免同步、非原子性和死锁问题，客户端Web也发展出相同的程序模式。让我们更好地理解这种模式。&lt;/p&gt;&lt;h2&gt;14.1.1 将程序分解成现在和以后&lt;/h2&gt;&lt;p&gt;我们来考虑如何让上述程序在无状态的环境下——比如在Web服务器上——工作。首先我们需要确定&lt;b&gt;第一个&lt;/b&gt;交互，是提示输入第一个数字，因为Racket从左到右计算参数。将程序分成两部分是有益的：第一个交互产生啥（现在就可以运行），以及之后需要发生什么（必须以某种方式“记住”）。前者很容易：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(read-number &quot;First number&quot;)&lt;/code&gt;&lt;p&gt;我们已经用文字解释过剩下的东西了，但是现在是时候把它写成程序了。似乎应该类似于【注释】&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(display
  (+ &amp;lt;第一个交互的返回值&amp;gt;
     (read-number &quot;Second number&quot;)))&lt;/code&gt;&lt;blockquote&gt;我们现在故意忽略read-number部分，但会回过来讨论它。现在，我们假设它是内置的。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;但是，Web服务器不能执行这个东西，因为它显然不是&lt;b&gt;程序&lt;/b&gt;。我们需要一种方式将其写成程序。&lt;/p&gt;&lt;p&gt;观察一下这个计算的特点：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;它是合法的程序。&lt;/li&gt;&lt;li&gt;它需要保持暂停状态，直到请求进入。&lt;/li&gt;&lt;li&gt;它需要某种方式——例如参数——来引用前一个交互的值。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;综合这些特点，显然我们应该将其表示为函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(lambda (v1)
  (display
    (+ v1
       (read-number &quot;Second number&quot;))))&lt;/code&gt;&lt;h2&gt;14.1.2 部分的解决方案&lt;/h2&gt;&lt;p&gt;在Web上，还有个额外的问题：每个带有输入元素的Web页面都需要引用存储在Web上的程序，该程序将从表单接收数据并对其进行处理。这个程序是在表单的action字段中指明的。因此，设想服务器生成一个新的标签，将前述函数存储在与该标签相关联的表格中，并且在action字段中引用该表格。如果客户端最终提交了表单，这个时候，服务器提取出关联的函数，向其提供表单的值，从而恢复执行。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;上述方案是无状态的吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;假设我们在自定义的Web服务器上维护这么一个表格。在这个服务器上，可能会有一个特殊版本的read-number，称之为call-read-number/suspend，记录程序的其余部分：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(read-number/suspend &quot;First number&quot;
                     (lambda (v1)
                       (display
                        (+ v1
                           (read-number &quot;Second number&quot;)))))&lt;/code&gt;&lt;p&gt;为了测试，我们来实现这个子程序。首先，我们需要标签的表示法；用数字就好：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type-alias label number)&lt;/code&gt;&lt;p&gt;假设&lt;code class=&quot;inline&quot;&gt;new-label&lt;/code&gt;在每次调用时都会生成新标签。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;定义&lt;code class=&quot;inline&quot;&gt;new-label&lt;/code&gt;。需要的话参考&lt;code class=&quot;inline&quot;&gt;new-loc&lt;/code&gt;以获得灵感。&lt;/blockquote&gt;&lt;p&gt;需要一个表，来存储代表程序其余部分的子程序。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define table (make-hash empty))&lt;/code&gt;&lt;p&gt;存储这些子程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (read-number/suspend [prompt : string] rest)
  (let ([g (new-label)])
    (begin
      (hash-set! table g rest)
      (display prompt)
      (display &quot; To enter it, use the action field label &quot;)
      (display g))))&lt;/code&gt;&lt;p&gt;现在运行上面的read-number/suspend调用，系统会打印&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;First number To enter it, use the action field label 1&lt;/code&gt;&lt;p&gt;这就相当于，在Web页面中打印提示，并在action字段中放入“标签1”。因为我们在模拟网页，需要有个东西来表示浏览器的提交过程。这里需要标签（来自action字段）和表单中输入的值。给定了这两个值，这个子程序需要从表中提取出相关子程序，并将其应用于表单值。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (resume [g : label] [n : number])
  ((some-v (hash-ref table g)) n))&lt;/code&gt;&lt;p&gt;有了这些，我们现在可以模拟输入3并点击“提交”按钮的行为，运行：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (resume 1 3)&lt;/code&gt;&lt;p&gt;其中1是标签，3是用户输入。不幸的是，这么做只会产生另一个提示，因为我们还没有完成程序的转换。要去除read-number，我们需要转换整个程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(read-number/suspend &quot;First number&quot;
                     (lambda (v1)
                       (read-number/suspend &quot;Second number&quot;
                                            (lambda (v2)
                                              (display
                                               (+ v1 v2))))))&lt;/code&gt;&lt;p&gt;为了安全起见，我们还可以在read-number/suspend结束的地方添加报错，从而确保计算在每次输出之后终止（以确保“挂起”的最极端形式）。&lt;/p&gt;&lt;p&gt;执行这个程序时，必须两次使用resume：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;First number To enter it, use the action field label 1
halting: Program shut down
&amp;gt; (resume 1 3)
Second number To enter it, use the action field label 2
halting: Program shut down
&amp;gt; (resume 2 10)
13&lt;/code&gt;&lt;p&gt;其中两次用户输入分别是3和10，总和给出是13，而&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;halting&lt;/code&gt;&lt;p&gt;信息是我们添加的报错命令生成的。&lt;/p&gt;&lt;p&gt;我们故意略去了程序中某些有趣部分的类型。来看看这些类型应该是什么。read-number/suspend的第二个参数是读入数字并返回最终结果的子程序：&lt;code class=&quot;inline&quot;&gt;(number -&amp;gt; &#39;a)&lt;/code&gt;。同样，resume的返回类型也是&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;。这些&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;如何相互沟通？是通过将标签映射到&lt;code class=&quot;inline&quot;&gt;(number -&amp;gt; ’a)&lt;/code&gt;的表完成的。也就是说，计算过程中的每一步都产生相同类型的结果。&lt;code class=&quot;inline&quot;&gt;read-number/suspend&lt;/code&gt;写入表中，&lt;code class=&quot;inline&quot;&gt;resume&lt;/code&gt;从表中读取。&lt;/p&gt;&lt;h2&gt;14.1.3 实现无状态&lt;/h2&gt;&lt;p&gt;实际上我们并没有实现无状态，因为服务器上有一大张表，而我们缺乏明确手段去除此表。如果可以完全避免服务器上的状态就好了。这意味着我们必须将相关的状态移交给客户端。&lt;/p&gt;&lt;p&gt;服务器实际上以两种方式持有了状态。其一，可以存放任意多个——而不是常数个（比如线性相关于程序本身的大小）——条目的哈希表，。其二，我们在表中存放的是实实在在的闭包，而闭包中可以保有任意数量的状态。我们很快就会更清楚地看到这一点。&lt;/p&gt;&lt;p&gt;先从消除闭包开始着手。我们可以把所有的函数参数改成实名的全局函数（这迫使我们只会拥有有限个闭包，因为程序的长度不可能是无限的）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(read-number/stateless &quot;First number&quot; prog1)
 
(define (prog1 v1)
  (read-number/stateless &quot;Second number&quot; prog2))
 
(define (prog2 v2)
  (display (+ v1 v2)))&lt;/code&gt;&lt;p&gt;注意到每块代码都只引用下一块代码的名称，而没有引入真正的闭包。参数的值来自于表单。唯一的问题是：prog2中的v1是未绑定的标识符！&lt;/p&gt;&lt;p&gt;解决这个问题的方法是，不要在每一步之后创建闭包，而是将v1发送到客户端并存储在那里。存储在哪里呢？浏览器为此提供了两种机制：&lt;b&gt;Cookie&lt;/b&gt;和&lt;b&gt;隐藏字段&lt;/b&gt;。我们用哪一个？&lt;/p&gt;&lt;h2&gt;14.1.4 与状态互动&lt;/h2&gt;&lt;p&gt;Cookie和隐藏字段之间的本质区别是，&lt;b&gt;所有页面共享相同的cookie，但每个页面都包含自己的隐藏字段&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;先来考虑与现有程序的一串交互，（在两个地方都）使用read-number/suspend。就像这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;First number To enter it, use the action field label 1
&amp;gt; (resume 1 3)
Second number To enter it, use the action field label 2
&amp;gt; (resume 2 10)
13&lt;/code&gt;&lt;p&gt;因此，恢复标签2似乎表示将3加到给定的参数（即，表单字段值）。保险起见，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (resume 2 15)
18&lt;/code&gt;&lt;p&gt;一切正常。现在假设我们再次使用标签1：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (resume 1 5)
Second number To enter it, use the action field label 3&lt;/code&gt;&lt;p&gt;注意，需要使用标签3，而不是标签1来恢复这个新的程序执行。的确，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (resume 3 10)
15&lt;/code&gt;&lt;p&gt;但是我们应该问，如果重用标签2会发生什么？&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;试试&lt;code class=&quot;inline&quot;&gt;(resume 2 10)&lt;/code&gt;。&lt;/blockquote&gt;&lt;p&gt;这就是恢复之前的计算。因此，我们期望它产生和之前一样的结果：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (resume 2 10)
13&lt;/code&gt;&lt;p&gt;现在来创建一个有状态的实现。通过共享一个可变状态但是拥有自己环境的闭包可以模拟这种行为。所以我们可以这样做，使用现有的read-number/suspend，但是不依赖lambda的闭包行为，即不使用任何自由变量。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define cookie &#39;-100)
 
(read-number/suspend &quot;First number&quot;
                     (lambda (v1)
                       (begin
                         (set! cookie v1)
                         (read-number/suspend &quot;Second number&quot;
                                            (lambda (v2)
                                              (display
                                               (+ cookie v2)))))))&lt;/code&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;对于之前的交互序列，现在的&lt;b&gt;期望&lt;/b&gt;值是啥？&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;计算过程是什么样的？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;起初，似乎没啥不同：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;First number To enter it, use the action field label 1
&amp;gt; (resume 1 3)
Second number To enter it, use the action field label 2
&amp;gt; (resume 2 10)
13&lt;/code&gt;&lt;p&gt;当再次使用最初的计算时，我们确实得到新的恢复标签：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (resume 1 5)
Second number To enter it, use the action field label 3&lt;/code&gt;&lt;p&gt;使用新标签时，计算结果如我们所期望的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (resume 3 10)
15&lt;/code&gt;&lt;p&gt;关键的一步来了：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (resume 2 10)
15&lt;/code&gt;&lt;p&gt;标签2的两次恢复产生了不同的答案，这一点不足为奇，因为它们依赖于可变状态。问题是，当我们将相同的行为转换到Web时会发生什么。&lt;/p&gt;&lt;p&gt;想象一下，访问某旅馆预订网站，寻找某个城市的旅馆。返回的网页中，你看到一个旅馆的列表和标签1。你在新（浏览器）标签或窗口中浏览其中的一个旅馆；这个页面中生成了那个旅馆的信息，还有标签2用作预订旅馆。然而，你返回旅馆列表，并在新的标签或窗口中查看了另一家旅馆。这产生了第二家旅馆的信息，还有标签3用作该旅馆的预订。然而，你决定选择第一家旅馆，返回第一家旅馆的页面，然后选择预订按钮，也就是提交了标签2。你想要预订的是哪家旅馆？尽管你预期订的是&lt;b&gt;第一家&lt;/b&gt;，大多数旅游网站上，你要么预订了&lt;b&gt;第二家&lt;/b&gt;旅馆——即最后查看的，而不是预订按钮所在的网页上的那家——要么被报告错误。这是因为在Web站点普遍使用了cookie，这是大多数Web API所鼓励的做法。&lt;/p&gt;&lt;h2&gt;14.2 Continuation传递模式&lt;/h2&gt;&lt;p&gt;之前所说的函数是有名称的。虽然用Web描述问题，但是我们用的是更古老的概念：这类函数被称为&lt;b&gt;continuation&lt;/b&gt;（延续），而这种风格的程序被称为&lt;b&gt;continuation-passing style&lt;/b&gt;（Continuation传递模式，简称CPS）。【注释】这值得研究一下，因为它是学习其他各种非平凡控制指令——如生成器——的基础。&lt;/p&gt;&lt;blockquote&gt;我们会自由地将CPS当作名词和动词使用：一种特定的代码模式，将代码转化为此种模式。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;此前，我们将程序转化为，没有Web输入操作嵌套在另一个中。动机很简单：当程序终止时，所有嵌套的计算都会丢失。对于XMLHttpRequest来说，类似的论据（在程序本地意义上）成立：所有依赖于Web服务器响应结果的计算，都需要驻留在对服务器请求相关联的回调中。&lt;/p&gt;&lt;p&gt;事实上，我们并不需要转化&lt;b&gt;每一个&lt;/b&gt;表达式。只需要处理涉及实际Web交互的表达式。比如说，如果要进行的计算不是加法，而是比它复杂得多的数学表达式，这个数学表达式我们是不需要转换的（不涉及Web交互）。不过，如果这里有个函数调用，那么我们必须绝对确定这个函数、它调用的函数、这些函数调用的函数（整个调用链）中不存在任何的Web调用，才可以不对它进行转换。否则，保险起见，我们必须转化所有的这些函数。总之，我们必须转化每个我们无法确定不执行任何Web交互的表达方式。&lt;/p&gt;&lt;p&gt;因此，这里转化的核心就是把每个单参数函数&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;转换成具有额外参数的函数。这个额外的参数就是continuation，代表了其余的计算。Continuation本身也是单参数的函数。这个参数的输入是&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;&lt;b&gt;本来的&lt;/b&gt;返回值，后续计算本来需要使用这个返回值继续。转换后&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;将不再&lt;b&gt;返回&lt;/b&gt;值，而是将原来的返回值&lt;b&gt;传递给&lt;/b&gt;它的continuation。&lt;/p&gt;&lt;p&gt;CPS是种通用的转化，可以作用在任何程序上。因为它是一种程序转换，所以我们可以把它看作是特殊的去语法糖：特别之处是，它不是把程序从大语言转化到小语言（类似于宏），或者从一种语言转化到另一种语言（就像编译器那样），而是在&lt;b&gt;同一种&lt;/b&gt;语言中的程序转换：从完整语言转化到受限制的形式，遵从这里讨论的模式。因此，我们可以使用完整语言的求值器对CPS程序求值。&lt;/p&gt;&lt;h2&gt;14.2.1 用去语法糖实现&lt;/h2&gt;&lt;p&gt;我们已经对去语法糖有了很好的支持，所以我们来它来定义CPS转换。具体来说，我们将实现CPS宏。为了更加干净地将源语言与目标语言分开，我们所使用的大部分语言结构都会用略有不同的名称：单变量的rec和with而不是let和letrec；lam而不是lambda；cnd而不是if；seq取代begin；set取代set!。这会是足够丰富的语言，可以编写一些有趣的程序！&lt;/p&gt;&lt;blockquote&gt;后文中宏的子句按照我认为从容易到困难的顺序排列。但是，宏定义的代码必须避免模式的重复，因此遵循不同的顺序。&lt;br&gt;&lt;/blockquote&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro&amp;gt; ::=  ;CPS宏

    (define-syntax (cps e)
      (syntax-case e (with rec lam cnd seq set quote display read-number)
        &amp;lt;cps-macro-with-case&amp;gt;
        &amp;lt;cps-macro-rec-case&amp;gt;
        &amp;lt;cps-macro-lam-case&amp;gt;
        &amp;lt;cps-macro-cnd-case&amp;gt;
        &amp;lt;cps-macro-display-case&amp;gt;
        &amp;lt;cps-macro-read-number-case&amp;gt;
        &amp;lt;cps-macro-seq-case&amp;gt;
        &amp;lt;cps-macro-set-case&amp;gt;
        &amp;lt;cps-macro-quote-case&amp;gt;
        &amp;lt;cps-macro-app-1-case&amp;gt;
        &amp;lt;cps-macro-app-2-case&amp;gt;
        &amp;lt;cps-macro-atomic-case&amp;gt;))&lt;/code&gt;&lt;p&gt;我们的CPS表示法会将&lt;b&gt;每个&lt;/b&gt;表达式转变成单参数的函数，参数就是continuation。转换后的表达式最终要么提供值调用continuation，要么将continuation传递给其他表达式，归纳地说，其他表达式也遵从这个不变量关系，因此最终continuation会被提供某个值。所以说，所有的CPS输出看起来都类似于&lt;code class=&quot;inline&quot;&gt;(lambda (k) ...)&lt;/code&gt;（我们将依赖卫生来保证所有引入的k不会相互冲突）。&lt;/p&gt;&lt;p&gt;首先，我们来处理简单的情况，原子值。尽管概念上来说它是最简单的，但是我们将其放在最后一项，因为放在前面的话它会遮盖掉其他匹配。（理想情况下，我们应该将其放在第一个位置，然后提供一个能精确定义我们原子值的匹配表达式，这里放宽要求是因为我们对其他情况更为关心。）原子值的情况中，我们已经有一个值，将其传递给continutaion即可：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-atomic-case&amp;gt; ::=  ;原子

    [(_ atomic)
     #&#39;(lambda (k)
         (k atomic))]&lt;/code&gt;&lt;p&gt;被引用的常量也一样处理：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-quote-case&amp;gt; ::=

    [(_ &#39;e)
     #&#39;(lambda (k) (k &#39;e))]&lt;/code&gt;&lt;p&gt;我们还知道，with和rec可以当作宏来处理：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-with-case&amp;gt; ::=

    [(_ (with (v e) b))
     #&#39;(cps ((lam (v) b) e))]

&amp;lt;cps-macro-rec-case&amp;gt; ::=

    [(_ (rec (v f) b))
     #&#39;(cps (with (v (lam (arg) (error &#39;dummy &quot;nothing&quot;)))
                  (seq
                   (set v f)
                   b)))]&lt;/code&gt;&lt;p&gt;赋值也是容易的：先求出新的值，然后再执行实际的更新操作：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-set-case&amp;gt; ::=

    [(_ (set v e))
     #&#39;(lambda (k)
         ((cps e) (lambda (ev)
                    (k (set! v ev)))))]&lt;/code&gt;&lt;p&gt;序列指令也是直白的：依次执行每个操作。请注意我们保持了序列的语义：不仅遵守了操作的顺序，第一个子项（e1）的值在第二个（e2）的计算中不会被用到，所以该值所绑定到的标识符的名称也就无关紧要。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-seq-case&amp;gt; ::=

    [(_ (seq e1 e2))
     #&#39;(lambda (k)
         ((cps e1) (lambda (_)
                     ((cps e2) k))))]&lt;/code&gt;&lt;p&gt;处理条件指令时，需要创建新的continuation，用来记住我们在等待条件表达式的求值结果。不过，一旦获得了其值，根据其值的不同我们可以选择进入已有的continuation分支。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-cnd-case&amp;gt; ::=

    [(_ (cnd tst thn els))
     #&#39;(lambda (k)
         ((cps tst) (lambda (tstv)
                      (if tstv
                          ((cps thn) k)
                          ((cps els) k)))))]&lt;/code&gt;&lt;p&gt;处理函数调用时，有两种情况需要考虑。我们必须要处理语言中创建的函数，也就是单参数函数。然而，为了编写示例程序，能够使用诸如+和*之类的指令很有用。因此，&lt;b&gt;为了简单起见&lt;/b&gt;，我们将&lt;b&gt;假定&lt;/b&gt;单参数函数是用户编写的，因此需要CPS转换，而双参数函数是不会执行任何Web或其他控制操作的指令，因此可以直接调用； 我们&lt;b&gt;还&lt;/b&gt;假定原生指令可以直接写出（即，函数位置不是复杂表达式，本身不会执行Web交互）。&lt;/p&gt;&lt;p&gt;对于函数调用，我们必须先对函数和参数表达式求值，一旦获取了这些就可以实际进行函数的调用。因此我们很容易将函数调用的转换写成这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-app-1-case-take-1&amp;gt; ::=

    [(_ (f a))
     #&#39;(lambda (k)
         ((cps f) (lambda (fv)
                    ((cps a) (lambda (av)
                               (k (fv av)))))))]&lt;/code&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;你看出为什么这是错的吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;问题在于，虽然函数现在是值了，也就是闭包，其函数体可以很复杂：比如说，对函数体求值可以导致进一步的Web交互，此时函数体的其余部分，包括待处理的&lt;code class=&quot;inline&quot;&gt;(k ...)&lt;/code&gt;（即程序的其余部分）将全部丢失。为了避免这种情况，我们必须把k提供给函数的值，让归纳不变量保证k最终会被调用于fv作用于av的得到的值：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-app-1-case&amp;gt; ::=

    [(_ (f a))
     #&#39;(lambda (k)
         ((cps f) (lambda (fv)
                    ((cps a) (lambda (av)
                               (fv av k))))))]&lt;/code&gt;&lt;p&gt;处理内置双目操作的特殊情况比较容易：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-app-2-case&amp;gt; ::=

    [(_ (f a b))
     #&#39;(lambda (k)
         ((cps a) (lambda (av)
                    ((cps b) (lambda (bv)
                               (k (f av bv)))))))]&lt;/code&gt;&lt;p&gt;用户定义的函数不能使用这个模式，因为我们假设这里f的调用总是会返回，而不进行任何不寻常的控制转移。&lt;/p&gt;&lt;p&gt;函数本身就是一种值，该值本身应该被返回给挂起的计算（一个continuation）。然而，前面函数调用的情况表明，函数转化后需要传入额外的参数——调用点的continuation。这就留下一个问题：该向函数体提供哪个continuation？&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-lam-case-take-1&amp;gt; ::=

    [(_ (lam (a) b))
     (identifier? #&#39;a)
     #&#39;(lambda (k)
         (k (lambda (a dyn-k)
              ((cps b) ...))))]&lt;/code&gt;&lt;p&gt;也就是说，在这里的...位置上，我们该填入k还是dyn-k？&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;该填入哪个continuation呢？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;前者是&lt;b&gt;闭包创建位置&lt;/b&gt;的continuation。后者是&lt;b&gt;闭包调用位置&lt;/b&gt;的continuation。换一种说法，前者是“静态的”，后者是“动态的”。这里，我们需要使用动态的continuation，否则会发生非常奇怪的事情：程序会返回到创建闭包的地方，而不是它被使用的地方！这会导致非常奇怪的程序行为，所以我们避免这么做。请注意，这里我们有意识地选择动态的continuation，就如同在处理作用域时，我们选择了静态的环境。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-lam-case&amp;gt; ::=

    [(_ (lam (a) b))
     (identifier? #&#39;a)
     #&#39;(lambda (k)
         (k (lambda (a dyn-k)
              ((cps b) dyn-k))))]&lt;/code&gt;&lt;p&gt;最后，为了建模Web编程的目的，我们需要添加输入和输出指令。输出遵循前述函数调用的模式：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-display-case&amp;gt; ::=

    [(_ (display output))
     #&#39;(lambda (k)
         ((cps output) (lambda (ov)
                         (k (display ov)))))]&lt;/code&gt;&lt;p&gt;对于输入，使用现有的read-number/suspend就可以了，不过这里由我们来&lt;b&gt;生成&lt;/b&gt;其使用，而不是让程序员来创建：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-read-number-case&amp;gt; ::=

    [(_ (read-number prompt))
     #&#39;(lambda (k)
         ((cps prompt) (lambda (pv)
                         (read-number/suspend pv k))))]&lt;/code&gt;&lt;p&gt;请注意，绑定为k的continuation就是在Web交互处我们需要存储的continuation。&lt;/p&gt;&lt;p&gt;测试CPS转换后的代码有些小麻烦，因为所有CPS项都需要读入continuation。最初的continuation可以是（a）读入值并返回它，或者（b）读入值并打印它，或者（c）读入值，打印它并准备好进行下一个计算（DrRacket的交互窗口就是这么做的）。这三者其实都只是恒等函数的变体。所以，我们定义以下函数辅助测试：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (run c) (c identity))&lt;/code&gt;&lt;p&gt;例如，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (run (cps 3))                           3)
(test (run (cps ((lam ()    5)       )))      5)
(test (run (cps ((lam (x)   (* x x)) 5)))     25)
(test (run (cps (+ 5 ((lam (x) (* x x)) 5)))) 30)&lt;/code&gt;&lt;p&gt;也可以测试之前的Web程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(run (cps (display (+ (read-number &quot;First&quot;)
                      (read-number &quot;Second&quot;)))))&lt;/code&gt;&lt;p&gt;为了避免你迷失在众多代码之中，我强调一下这里的重点：&lt;b&gt;我们恢复了代码的结构&lt;/b&gt;。换种说法，即借由恰当的嵌套表达式以及帮助将其翻译以使其可以和底层API协作的代码的编译器（本例中即CPS转换程序），我们得以使用**直述的风格（direct style）**编写程序。这正是优秀的编程语言所应做的！&lt;/p&gt;&lt;h2&gt;14.2.2 例子的转化&lt;/h2&gt;&lt;p&gt;让我们来看看上面的例子是怎么转换的。你可以手工操作，也可以采取简单的办法，用DrRacket的Macro Stepper（宏步进器）完成。【注释】放入run函数传入的恒等函数，我们得到：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(lambda (k)
  ((lambda (k)
     ((lambda (k)
        ((lambda (k)
           (k &quot;First&quot;)) (lambda (pv)
                          (read-number/suspend pv k))))
      (lambda (lv)
        ((lambda (k)
           ((lambda (k)
              (k &quot;Second&quot;)) (lambda (pv)
                              (read-number/suspend pv k))))
         (lambda (rv)
           (k (+ lv rv)))))))
   (lambda (ov)
     (k (display ov)))))&lt;/code&gt;&lt;blockquote&gt;这里，为了获取的Macro Stepper的全部功能，请使用&lt;code class=&quot;inline&quot;&gt;#lang racket&lt;/code&gt;语言。&lt;/blockquote&gt;&lt;p&gt;什么！这和我们手写的版本完全不同！&lt;/p&gt;&lt;p&gt;实际上，这个程序中充满了所谓的&lt;b&gt;管理性&lt;/b&gt;lambda（administrative lambda），由我们所用的CPS算法引入。【注释】请不用担心！如果我们逐一调用这些lambda，完成替代，那么——&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;完成此步。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;——这个程序会简化为&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(read-number/suspend &quot;First&quot;
                     (lambda (lv)
                       (read-number/suspend &quot;Second&quot;
                                            (lambda (rv)
                                              (identity
                                               (display (+ lv rv)))))))&lt;/code&gt;&lt;p&gt;这正是我们想要的。&lt;/p&gt;&lt;blockquote&gt;设计更好的CPS算法，消除不必要的管理性lambda，是个研究前沿问题。&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;14.2.3 在核心中实现&lt;/h2&gt;&lt;p&gt;在研究了通过去语法糖实现CPS之后，我们应该问问，是否可将其以放在核心中。&lt;/p&gt;&lt;p&gt;回想一下，我们说过CPS适用于任何程序。有一个我们特别感兴趣的程序：解释器。显然，我们可以将CPS转换应用于其上，从而获得事实上的continuation。&lt;/p&gt;&lt;p&gt;首先，这里使用函数来表示闭包较为方便（译注，12.1节）。我们让解释器读入多读入一个参数，该参数读入值（需要传给continuation的那些值）并最终返回它们：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-interp&amp;gt; ::=  ;cps解释器

    (define (interp/k [expr : ExprC] [env : Env] [k : (Value -&amp;gt; Value)]) : Value
      &amp;lt;cps-interp-body&amp;gt;)  ;cps解释器主体&lt;/code&gt;&lt;p&gt;对于简单的情况，我们不直接返回值，而是将其传递给continuation参数即可：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-interp-body&amp;gt; ::=

    (type-case ExprC expr
      [numC (n) (k (numV n))]
      [idC (n) (k (lookup n env))]
      &amp;lt;cps-interp-plusC-case&amp;gt;
      &amp;lt;cps-interp-appC-case&amp;gt;
      &amp;lt;cps-interp-lamC-case&amp;gt;)&lt;/code&gt;&lt;p&gt;（请注意，multC的处理完全类似于plusC。）&lt;/p&gt;&lt;p&gt;还是从简单的情况开始，plusC。第一步我们解释左子表达式。该计算的continuation进行右子表达式的解释。这个计算的continuation对结果求和。求和的结果怎么处理？在interp中，它被返回，返回到那个调用解释plusC的计算。请记住，现在我们不再返回值；反之，我们将其传给continuation：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-interp-plusC-case&amp;gt; ::=

    [plusC (l r) (interp/k l env
                           (lambda (lv)
                             (interp/k r env
                                       (lambda (rv)
                                         (k (num+ lv rv))))))]&lt;/code&gt;&lt;p&gt;&lt;b&gt;习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;实现multC。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;还剩下两种相互关联的情况，它们相对更难些。&lt;/p&gt;&lt;p&gt;对于函数调用，还是需要解释两个子表达式，然后将结果的闭包应用于参数。不过，我们已经说好了，每个调用都需要带上continuation参数。因此，必须更新一下值的定义：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type Value
  [numV (n : number)]
  [closV (f : (Value (Value -&amp;gt; Value) -&amp;gt; Value))])&lt;/code&gt;&lt;p&gt;接下来必须决定传给它啥continuation。对于函数调用，就是传入解释器的continuation：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-interp-appC-case&amp;gt; ::=

    [appC (f a) (interp/k f env
                          (lambda (fv)
                            (interp/k a env
                                      (lambda (av)
                                        ((closV-f fv) av k)))))]&lt;/code&gt;&lt;p&gt;最后处理lamC的情况。和以前一样，我们必须使用lambda创建closV。不过，这个函数需要两个参数：实际的参数和调用的continuation。关键的问题是，后者该是什么？&lt;/p&gt;&lt;p&gt;有两个选择。k表示&lt;b&gt;静态的&lt;/b&gt;continuation：在闭包&lt;b&gt;创建&lt;/b&gt;位置的那个continuation。不过，我们想要的是在闭包&lt;b&gt;调用&lt;/b&gt;之处的continuation，也就是&lt;b&gt;动态的&lt;/b&gt;continuation。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-interp-lamC-case&amp;gt; ::=

    [lamC (a b) (k (closV (lambda (arg-val dyn-k)
                            (interp/k b
                                      (extend-env (bind a arg-val)
                                                  env)
                                      dyn-k))))]&lt;/code&gt;&lt;p&gt;要测试这个修改后的解释器，我们需要用某个初始continuation调用interp/k。这个子程序表示的是无需任何其他计算。自然的选择是恒等函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (interp [expr : ExprC]) : Value
  (interp/k expr mt-env
            (lambda (ans)
              ans)))&lt;/code&gt;&lt;p&gt;为了强调这只是interp/k的顶层接口，interp放弃了环境参数，自动传递空环境给interp/k。如果需要特别确定没有意外地递归使用这个函数，我们可以在其最后插入一个对error的调用，以防止它返回，或者其返回值被使用。&lt;/p&gt;&lt;h2&gt;14.3 生成器&lt;/h2&gt;&lt;p&gt;现在许多编程语言都拥有&lt;b&gt;生成器&lt;/b&gt;（generator）这一概念。生成器类似于函数，可以被调用。区别在于，常规函数总是从头开始执行，生成器从最后一次停止的地方&lt;b&gt;恢复&lt;/b&gt;。当然，这意味着生成器需要“在完成之前退出”的概念。这就是所谓的&lt;b&gt;yield&lt;/b&gt;（让位），即把控制权归还给调用者。&lt;/p&gt;&lt;h2&gt;14.3.1 各种设计&lt;/h2&gt;&lt;p&gt;生成器有许多不同的变体。可以想见，不同之处在于如何进入和退出生成器：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在某些语言中，生成器是一种对象，需要和其他对象一样实例化，恢复其执行是通过调用方法（例如Python中的next）。在其他语言中，生成器则类似于函数，而且重入是通过像函数一样调用。【注释】&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在某些语言中，让位操作——例如Python的yield——只能在生成器的语法主体中使用。在其他语言中，例如Racket，yield是在生成器主体中被绑定的、可调用的值，正由于它是值，它可以被抽象的传递、存储于数据结构中，等等。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;在有些语言中，除了普通的函数，其他值也可以用做调用，所有这些值被统称为&lt;b&gt;可调用值&lt;/b&gt;（applicable）。&lt;/blockquote&gt;&lt;p&gt;Python的设计代表了一种极端，生成器是&lt;b&gt;任何包含关键字yield的函数&lt;/b&gt;。此外，Python的yield不能作为参数传递给另一个函数，由该函数代理来执行让位。&lt;/p&gt;&lt;p&gt;还有个关于命名的小问题。在许多支持生成器的语言中，让位指令就是&lt;b&gt;字面上&lt;/b&gt;的yield：要么是关键字（如Python），要么是绑定为可调用值的标识符（如在Racket中）。还有种可能，生成器的用户必须在生成器表达式中指明让位指令的名字。【注释】也就是说，生成器是这样的&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(generator (yield) (from)
           (rec (f (lam (n)
                     (seq
                       (yield n)
                       (f (+ n 1)))))
             (f from)))&lt;/code&gt;&lt;p&gt;但是等价的写法&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(generator (y) (from)
           (rec (f (lam (n)
                     (seq
                       (y n)
                       (f (+ n 1)))))
             (f from)))&lt;/code&gt;&lt;p&gt;如果这个让位指令实际上是值，那么用户也可以这样抽象地使用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(generator (y) (from)
           (rec (f (lam (n)
                     (seq
                       ((yield-helper y) n)
                       (f (+ n 1)))))
             (f from)))&lt;/code&gt;&lt;p&gt;其中yield-helper会去调用让位指令。&lt;/p&gt;&lt;p&gt;实际上还有两个设计上的决定：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;yield是声明还是表达式？在许多语言中，它是表达式，这意味着它有值：在恢复生成器时提供的值。这使得生成器更加灵活，因为生成器的使用者可以使用参数来改变生成器的行为，而不是&lt;b&gt;被迫&lt;/b&gt;使用状态来传达所需的改变。&lt;/li&gt;&lt;li&gt;生成器执行结束时会发生什么？在很多语言中，生成器会产生异常来表示完成。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;奇怪的是，Python在对象中期望用户来确定self或this的名称，但是它没有为yield提供相同的灵活性，因为这是唯一确定哪些函数是生成器的方式！&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;14.3.2 实现生成器&lt;/h2&gt;&lt;p&gt;要实现生成器，有效的方式是使用我们的CPS宏语言。先来确定这个设计决定的意义。我们用调用来表示生成器：即，要获得来自生成器的下一个值，是通过将其应用于任何必要的参数来完成的。类似的，让位指令也是可调用的值，并且还是表达式。虽然我们已经研究过宏如何自动捕获名称（译注：13.5节），但是简单起见我们还是明确给出让位指令的名称好了。最后，当生成器执行完成时，我们会报错。&lt;/p&gt;&lt;p&gt;生成器如何工作？ 要yield，生成器必须&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;记住它现在执行到哪里，&lt;/li&gt;&lt;li&gt;知道应该返回到调用者的哪里。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;而当生成器被调用时，它应该&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;记住它的调用者执行到哪里，&lt;/li&gt;&lt;li&gt;知道它应该返回到其主体内的哪里。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;请注意调用与让位之间的对偶。&lt;/p&gt;&lt;p&gt;你可能猜到了，这些“哪里”就是continuation。&lt;/p&gt;&lt;p&gt;我们来逐步实现生成器，这相当于添加一条cps宏的规则。先写下模式的头部：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-generator-case&amp;gt; ::=  ;CPS宏，生成器子句

    [(_ (generator (yield) (v) b))
     (and (identifier? #&#39;v) (identifier? #&#39;yield))
     &amp;lt;generator-body&amp;gt;]  ;生成器主体&lt;/code&gt;&lt;p&gt;主体第一部分很简单：CPS中的所有代码都需要先读入continuation，而且由于生成器是值，所以这个值要被传给continuation：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;generator-body&amp;gt; ::=  ;生成器主体

    #&#39;(lambda (k)
        (k &amp;lt;generator-value&amp;gt;))  ;生成器的值&lt;/code&gt;&lt;p&gt;下一步要处理生成器的核心了。&lt;/p&gt;&lt;p&gt;回忆一下，生成器是可调用的值。这就是说，它可以被放在函数调用的位置，因此它必须具有与函数相同的“接口”：函数有两个参数，第一个是值，第二个是调用位置的continuation。这个子程序应该做什么？我们刚刚描述过这个。首先，生成器必须记住它的调用者正在执行的地方，这正是调用位置的continuation；“记住”这里最简单的意思是“必须保存在状态中”。然后，生成器应该返回到它之前所在的地方，即它&lt;b&gt;自己&lt;/b&gt;的continuation，这个显然必须被保存过。因此，这里可调用值的核心是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;generator-core&amp;gt; ::=  ;生成器的核心

    (lambda (v dyn-k)
      (begin
        (set! where-to-go dyn-k)
        (resumer v)))&lt;/code&gt;&lt;p&gt;这里，where-to-go记录了调用者的continuation，让位时恢复；resumer是生成器的本地continuation。让我们考虑一下它们的初始值是什么：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;where-to-go没有初始值（因为生成器尚未被调用），所以如果它被调用，需要抛出错误。幸运的是，这个错误永远不会发生，因为第一次进入生成器时会对where-to-go赋值，所以这个错误只是防范实现中出现bug。&lt;/li&gt;&lt;li&gt;最初，生成器的其余部分是整个生成器，所以resumer应该被绑定到b（的CPS）。它的continuation是什么？是整个生成器的continuation，即当生成器结束时该做啥。我们已经讨论过，这里也应该给出错误（区别是，在这种情况下错误确实会发生，如果生成器被要求产生比它配备的更多的值）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;还需要绑定yield。正如我们已经指出的，它对称于生成器的恢复：将本地continuation保存在resumer中，然后通过调用where-to-go返回。&lt;/p&gt;&lt;p&gt;把这些片段放到一起，我们得到：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;generator-value&amp;gt; ::=  ;生成器的值

    (let ([where-to-go (lambda (v) (error &#39;where-to-go &quot;nothing&quot;))])
      (letrec([resumer (lambda (v)
                         ((cps b) (lambda (k)
                                    (error &#39;generator &quot;fell through&quot;))))]
              [yield (lambda (v gen-k)
                       (begin
                         (set! resumer gen-k)
                         (where-to-go v)))])
        &amp;lt;generator-core&amp;gt;))&lt;/code&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;为什么这里使用let和letrec，而不只用let？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;请注意这些代码片段之间的依赖关系。where-to-go不依赖于resumer或yield。yield显然依赖于where-to-go和resumer。但是，为什么resumer和yield相互引用呢？&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;试试不这么做。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;你可能会遗漏的巧妙依赖是，resumer中包含b，生成器的主体，它可能包含对yield的引用。因此，它需要包含退位指令的绑定。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;生成器与协程（coroutine）和线程（thread）有什么不同？使用类似的策略来实现协程和线程。&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;14.4 Continuation和堆栈&lt;/h2&gt;&lt;p&gt;虽然看上去不明显，但是CPS转换实际上对程序执行的&lt;b&gt;栈&lt;/b&gt;（译注，调用栈）本质提供了深入的了解。首先要理解的是，continuation实际上就是&lt;b&gt;栈本身&lt;/b&gt;。这可能看起来很奇怪，因为堆栈是底层的机器实现，而continuation看似复杂。那么栈到底是什么呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;栈是还有待完成的计算的记录。continuation也是。&lt;/li&gt;&lt;li&gt;栈传统上被认为是&lt;b&gt;栈帧&lt;/b&gt;（stack &lt;br&gt;frame）的列表。也就是说，每个帧都引用该帧完成后剩余的帧。类似地，每个continuation都是个小程序，其中引用——因此包含——自己的continuation。如果为程序指令选择不同的表示形式，将其与闭包的数据结构表示相结合，我们将得到一种与计算机堆栈基本相同的continuation表示法。&lt;/li&gt;&lt;li&gt;每个栈帧中还存储了函数的参数。continuation的子程序表示法隐式地管理了此项信息，明确地由数据结构（绑定）表示。&lt;/li&gt;&lt;li&gt;栈帧中还有“局部变量”的空间。continuation原则上也是如此，尽管我们使用宏实现本地绑定，因此相当于将一切都还原成函数参数。然而从概念上讲，其中一些是“真实的”函数参数，而另一些是通过宏变成函数参数的局部绑定。&lt;/li&gt;&lt;li&gt;栈引用了堆，但没有内含堆。因此，堆中的变化在不同的栈帧都是可见的。同样地，闭包中引用了贮存，但不内含贮存，所以对贮存的修改在不同闭包中都是可见的。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因此，传统上，栈负责维护词法范围，而我们使用（静态范围的语言中的）闭包自动获得此功能。&lt;/p&gt;&lt;p&gt;现在我们可以研究各种子项的转换，从而解到堆栈的映射。例如，考虑函数应用的转换：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;[(_ (f a))
 #&#39;(lambda (k)
     ((cps f) (lambda (fv)
                ((cps a) (lambda (av)
                           (fv av k))))))]&lt;/code&gt;&lt;p&gt;该怎么“读”呢？这样：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;我们用k表示函数调用之前的栈。&lt;/li&gt;&lt;li&gt;在对函数位置（&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;）求值时，创建新的栈帧（&lt;code class=&quot;inline&quot;&gt;(lambda (fv) ...)&lt;/code&gt;）。该帧包含一个自由标识符：&lt;code class=&quot;inline&quot;&gt;k&lt;/code&gt;。因此，它的闭包需要记录环境中的这个元素，即栈的其余部分。&lt;/li&gt;&lt;li&gt;栈帧的代码部分表示一旦我们获得了函数的值，剩下的工作：计算参数，执行调用，将结果返回给等待调用结果的栈：k。&lt;/li&gt;&lt;li&gt;对f的求值完成后，对a求值，这也需要创建栈帧：&lt;code class=&quot;inline&quot;&gt;(lambda (av) ...)&lt;/code&gt;。该帧有&lt;b&gt;两个&lt;/b&gt;自由标识符：k和fv。这说明：&lt;br&gt; &lt;/li&gt;&lt;ul&gt;&lt;li&gt;我们不再需要对函数位置求值的栈帧了，但是&lt;/li&gt;&lt;li&gt;我们需要用&lt;b&gt;临时变量&lt;/b&gt;记录函数位置求值的结果，它最好是函数值。&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;这第二个帧的代码部分代表也是剩下要做的事情：对参数调用函数，在等待调用结果的栈中进行。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;条件指令也是同样的推理：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;[(_ (cnd tst thn els))
 #&#39;(lambda (k)
     ((cps tst) (lambda (tstv)
                  (if tstv
                      ((cps thn) k)
                      ((cps els) k)))))]&lt;/code&gt;&lt;p&gt;它说的是，要对条件表达式求值，我们先要创建新的栈帧。该帧中包含等待整个条件表达式值的栈。该帧根据条件表达式的值来决定，调用其子表达式之一。在判断了条件的值之后，为了求它的值而创建的帧就不再需要了，因此求值可以在k中继续。&lt;/p&gt;&lt;p&gt;从这个角度出发，我们可以更好的解释生成器的操作。每个生成器都有自己的私有栈，当执行超越其栈底时，我们的实现会报错。被调用时，生成器将表示“剩余程序”的栈的引用存储在where-to-go中，然后恢复自己的栈。在让位时，系统交换堆栈的引用。协程，线程和生成器在概念上都是相似的：它们都是创建“许多小堆栈”的机制，而不仅仅只是单个的全局堆栈。&lt;/p&gt;&lt;h2&gt;14.5 尾调用&lt;/h2&gt;&lt;p&gt;观察上面的栈模式，为当前栈添加帧，执行一些计算，最终总是返回到当前栈。特别要注意的是，在函数调用中，我们需要栈的空间来对函数求值，然后是对参数求值，但是一旦所有这些求值完成，我们就使用函数调用开始之前的栈来恢复计算。换一种说法，&lt;b&gt;函数调用本身不需要消耗栈空间&lt;/b&gt;：我们只需要空间来计算参数。&lt;/p&gt;&lt;p&gt;但是，并非所有的语言都遵守或尊重这一属性。在这样做的语言中，程序员可以使用&lt;b&gt;递归&lt;/b&gt;来获得&lt;b&gt;迭代行为&lt;/b&gt;：即，一系列函数调用不会比没有函数调用的情况下消耗更多空间。这消除了创建特殊循环结构的需要；实际上，循环可以简单地表示为语法糖。&lt;/p&gt;&lt;p&gt;当然，这个属性不适用于一般情况。如果调用f来计算调用g所需的参数，那么对f的调用相对于围绕g的上下文仍然会占用空间。因此，我们需要说明表达式之间的关系：一个表达式的处于另一表达式的&lt;b&gt;尾位置&lt;/b&gt;，如果对它的求值不需要另一表达式（求值）之外的额外空间。在我们的CPS宏中，所有使用k作为其continuation的表达式——例如，在所有子表达式求值完成之后的函数调用，或者条件表达式的then和else分支——都在其外层表达式的尾位置（也许递归地还在其外层的尾位置）。反之，所有必须创建新栈帧的表达式都不在尾位置。&lt;/p&gt;&lt;p&gt;有些语言对&lt;b&gt;尾递归&lt;/b&gt;——某个函数在其函数体的尾位置调用自己——有特殊的支持。这显然是有用的，因为它使得递归得以有效地实现循环。然而，它破坏了不能被挤入单个递归函数的“循环”。例如，当实现状态机时，最方便的方法是用一组函数，每个函数代表一个状态，然后通过（尾）调用表示状态转换。把它们变成单一的递归函数会非常繁琐（并且失去了意义）。但是，如果一种语言能够识别尾调用，它就可以（和函数内调用自己一样）优化这些跨函数的调用。&lt;/p&gt;&lt;p&gt;Racket的实现保证尾调用不会分配额外的栈空间。有人把这称为“尾调用的优化”，但这个术语是误导性的：优化是可选性的，而某种语言是否承诺正确实现尾调用是种&lt;b&gt;语义&lt;/b&gt;特性。程序员需要了解语言的行为方式，因为这会影响他们的编程方式。&lt;/p&gt;&lt;p&gt;由于这个特性，观察CPS转换之后的程序的有趣之处：其中所有的函数调用本身都是尾调用的！从本章开头的read-number/suspend例子开始，你就可以看到这点：所有待处理的计算都被放入了continuation参数。假设程序可能在任何调用中终止，等同于根本不使用任何栈空间（因为栈将会被清除）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;程序如何在没有栈的情况下运行？&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;14.6 语言特性中支持continuation&lt;/h2&gt;&lt;p&gt;了解connection和栈之间的这种关联之后，现在可以回过头讨论函数的处理：我们忽略了在&lt;b&gt;创建&lt;/b&gt;闭包时的continuation，而只使用了在闭包调用时的continuation。当然，这对应于普通的函数行为。但现在我们可以问，如果我们用创建时的connection呢？这等同于，在“程序”创建时保存对栈的（副本）的引用，然后在调用函数时忽略动态的求值，返回到函数创建点。&lt;/p&gt;&lt;p&gt;实际上，我想说的是，让lambda保持不变，而给我们的语言提供新的、对于与这种行为的指令：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;cps-macro-let/cc-case&amp;gt; ::=  ;cps宏

    [(_ (let/cc kont b))
     (identifier? #&#39;kont)
     #&#39;(lambda (k)
         (let ([kont (lambda (v dyn-k)
                       (k v))])
           ((cps b) k)))]&lt;/code&gt;&lt;p&gt;这说的是，两种情况下，控制都将返回到直接包含let/cc的表达式：要么通过正常返回（因为主体b的continuation是k），要么通过更有意思的方式，调用continuation，这会丢弃动态的continuation&lt;br&gt; dyn/k，简单地忽略它直接返回到k。&lt;/p&gt;&lt;p&gt;最简单的测试是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (run (cps (let/cc esc 3)))
      3)&lt;/code&gt;&lt;p&gt;这证实了，如果我们从不使用continuation，那么对主体的求值就好像let/cc根本不存在一样（因为&lt;code class=&quot;inline&quot;&gt;((cps b) k)&lt;/code&gt;）。如果我们使用它，传给continuation的值返回到创建点：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (run (cps (let/cc esc (esc 3))))
      3)&lt;/code&gt;&lt;p&gt;当然，这个例子揭露的还不够，不过考虑这个：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (run (cps (+ 1 (let/cc esc (esc 3)))))
      4)&lt;/code&gt;&lt;p&gt;这证实了加法会实际执行。那么动态的continuation呢？&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (run (cps (let/cc esc (+ 2 (esc 3)))))
      3)&lt;/code&gt;&lt;p&gt;这表明加2不会发生，即动态continuation确实被忽略了。为了确保创建位置的continuation被保留，请观察：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (run (cps (+ 1 (let/cc esc (+ 2 (esc 3))))))
      4)&lt;/code&gt;&lt;p&gt;从这些例子中，你可能已经注意到熟悉的模式：esc在这里的表现类似于异常。也就是说，如果你不抛出异常（在这里，调用continuation）它就好像不在那里，但是如果你抛出异常，所有未完成的中间计算都将被忽略，计算返回到异常创建点。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;使用let/cc和宏实现异常的抛出和捕获机制。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;然而，这些例子只用到了最浅层的（let/cc的）能力，因为这里调用点处的continuation总是创建点处的continuation的扩展：即后者在栈中比前者更早。然而，没有任何东西要求k和dyn-k之间存在相关。它们实际上可以是&lt;b&gt;无&lt;/b&gt;关的，这意味着它们可以是两个独立的栈，所以我们可以用它轻松地实现栈切换功能。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;为了真正与lambda类似，我们应该引入如下展开的构造，称其为cont-lambda好了：&lt;br&gt;[(_ (cont-lambda (a) b))&lt;br&gt; (identifier? #&#39;a)&lt;br&gt; #&#39;(lambda (k)&lt;br&gt;     (k (lambda (a dyn-k)&lt;br&gt;          ((cps b) k))))]&lt;/blockquote&gt;&lt;code lang=&quot;text&quot;&gt;为什么我们没有这么做呢？从两方面考虑，静态类型的角度，还有，我们如何使用这个构造来构建上述类似于异常的行为。&lt;/code&gt;&lt;h2&gt;14.6.1 用语言表达&lt;/h2&gt;&lt;p&gt;用我们的小玩具语言编写程序很快会变得令人沮丧。幸运的是，Racket已经提供了叫做call/cc的构造，用来操作continuation。call/cc是单参数的函数，其参数本身又是单参数的函数，Racket会将当前continuation传给它进行调用，而当前continuation也是单参数的子程序。能理解吗？&lt;/p&gt;&lt;p&gt;幸运的是，我们可以用call/cc轻松地将let/cc实现为宏，然后用它来编写程序。这样：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax let/cc
  (syntax-rules ()
    [(let/cc k b)
     (call/cc (lambda (k) b))]))&lt;/code&gt;&lt;p&gt;之前的所有测试仍然通过：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(test (let/cc esc 3) 3)
(test (let/cc esc (esc 3)) 3)
(test (+ 1 (let/cc esc (esc 3))) 4)
(test (let/cc esc (+ 2 (esc 3))) 3)
(test (+ 1 (let/cc esc (+ 2 (esc 3)))) 4)&lt;/code&gt;&lt;h2&gt;14.6.2 定义生成器&lt;/h2&gt;&lt;p&gt;现在我们可以创建有趣的抽象了。比如，让我们来编写生成器。之前我们需要将表达式CPS转化，并传递continuation，现在都可以通过call/cc自动完成。因此，当需要目前的continuation时，我们都可以简单地召唤它而无需改变程序。所以，额外的&lt;code class=&quot;inline&quot;&gt;...-k&lt;/code&gt;参数都会消失，在同一个地方可以用let/cc捕获相同的continuation：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax (generator e)
  (syntax-case e ()
    [(generator (yield) (v) b)
     #&#39;(let ([where-to-go (lambda (v) (error &#39;where-to-go &quot;nothing&quot;))])
         (letrec ([resumer (lambda (v)
                             (begin b
                                    (error &#39;generator &quot;fell through&quot;)))]
                  [yield (lambda (v)
                           (let/cc gen-k
                             (begin
                               (set! resumer gen-k)
                               (where-to-go v))))])
           (lambda (v)
             (let/cc dyn-k
               (begin
                 (set! where-to-go dyn-k)
                 (resumer v))))))]))&lt;/code&gt;&lt;p&gt;请观察这段代码和去语法糖到CPS代码实现的生成器之间的密切相似性。具体而言，我们去掉了额外的continuation参数，用let/cc调用替换它们，这些调用能捕获完全相同的continuation。其余的代码基本不变。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;如果我们将（两处）let/cc和赋值移到begin内的第一个语句，会发生什么呢？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;例如，我们可以编写从初始值向上迭代的生成器：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define g1 (generator (yield) (v)
                      (letrec ([loop (lambda (n)
                                       (begin
                                         (yield n)
                                         (loop (+ n 1))))])
                        (loop v))))&lt;/code&gt;&lt;p&gt;其行为是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (g1 10)
10
&amp;gt; (g1 10)
11
&amp;gt; (g1 0)
12
&amp;gt;&lt;/code&gt;&lt;p&gt;因为（生成器）主体只引用了初始值，调用yield所返回的值被忽略，所以在后续调用传入的值不起作用。相反，考虑这个生成器：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define g2 (generator (yield) (v)
                      (letrec ([loop (lambda (n)
                                       (loop (+ (yield n) n)))])
                        (loop v))))&lt;/code&gt;&lt;p&gt;在第一次调用时，它返回输入的值。在此后的调用中，该值被加到后续调用生成器所提供的值上。换一种说法，该发生器累加它的所有输入值：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (g2 10)
10
&amp;gt; (g2 15)
25
&amp;gt; (g2 5)
30&lt;/code&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;现在我们已经使用call/cc和let/cc实现了生成器，请用它们实现协程和线程。&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;14.6.3 定义线程&lt;/h2&gt;&lt;p&gt;完成生成器之后，我们再做个类似的功能：线程。具体来说，我们希望能够编写如下的程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define d display) ;;有用的简写
 
(scheduler-loop-0
 (list
  (thread-0 (y) (d &quot;t1-1  &quot;) (y) (d &quot;t1-2  &quot;) (y) (d &quot;t1-3 &quot;))
  (thread-0 (y) (d &quot;t2-1  &quot;) (y) (d &quot;t2-2  &quot;) (y) (d &quot;t2-3 &quot;))
  (thread-0 (y) (d &quot;t3-1  &quot;) (y) (d &quot;t3-2  &quot;) (y) (d &quot;t3-3 &quot;))))&lt;/code&gt;&lt;p&gt;输出应该是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;t1-1  t2-1  t3-1  t1-2  t2-2  t3-2  t1-3 t2-3 t3-3&lt;/code&gt;&lt;p&gt;我们来创建必要的组件实现此功能。&lt;/p&gt;&lt;p&gt;我们先来定义线程调度器。它读入“线程”的列表，我们假设线程的接口读入continuation，并最终将控制返回给此continuation。每当调度器重新激活某个线程时，都会向其提供continuation。调度器可以用简单的循环（round-robin）方式选择线程，也可以使用更复杂的算法；这里我们不关心如何选择的细节。&lt;/p&gt;&lt;p&gt;类似于生成器，我们假定让位由调用用户命名的子程序完成，例如这里的y。我们也可以使用名称捕获（译注，13.5节）自动绑定其名称，比如yield。&lt;/p&gt;&lt;p&gt;这里的要点的是，请注意让位由线程系统的用户手动控制。这就是所谓的&lt;b&gt;协作式多任务处理&lt;/b&gt;（cooperative multitasking）。相反，我们可以选择通过生成定时器或其他内在机制自动触发让位，而无需用户许可。这被称为&lt;b&gt;抢占式多任务处理&lt;/b&gt;（preemptive multitasking）（因为系统从线程中“抢占”——也就是夺取了——控制权）。虽然这种区别对于构建系统来说是非常重要的，但从设置continuation的角度来看，这并不重要。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;在完成协作式多任务之后，实现抢占式多任务。哪里需要修改？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;陈述了这些限制，我们可以着手编写调度器了。它读入线程的列表，只要还有剩下的线程就继续执行。每次，它将线程应用于continuation，这个continuation表示返回到调度器并继续下一个线程：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (scheduler-loop-0 threads)
  (cond
    [(empty? threads) &#39;done]
    [(cons? threads)
     (begin
       (let/cc after-thread ((first threads) after-thread))
       (scheduler-loop-0 (append (rest threads)
                                 (list (first threads)))))]))&lt;/code&gt;&lt;p&gt;当接收线程调用绑定到after-thread的continuation时，控制返回到begin序列中第一个语句的结尾。因此，提供给continuation的值会被忽略（所以可以用任何值；我们选择用&lt;code class=&quot;inline&quot;&gt;&#39;dummy&lt;/code&gt;，以便其莫名出现时方便地发现问题）。将最近调用的线程附加到线程列表的末尾（即，将该列表视为循环队列）之后，控制将继续调度器循环的其余部分。&lt;/p&gt;&lt;p&gt;接下来我们定义线程。我们说过，它是单参数的函数，参数就是调度器的continuation。由于线程需要能&lt;b&gt;恢复&lt;/b&gt;，也就是从停止的地方继续，所以它必须存储上次执行到的位置：我们将其称为thread-resumer。起初thread-resumer是整个线程体，但在后续的实例中，它将是continuation：调用yield的continuation。于是，我们得到如下的框架：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax thread-0
  (syntax-rules ()
    [(thread (yielder) b ...)
     (letrec ([thread-resumer (lambda (_)
                                (begin b ...))])
       (lambda (sched-k)
         (thread-resumer &#39;dummy)))]))&lt;/code&gt;&lt;p&gt;还剩下yielder没实现。它是无参数的函数，将线程的continuation存入thread-resumer，然后用&lt;code class=&quot;inline&quot;&gt;&#39;dummy&lt;/code&gt;调用调度器的continuation。不过，调用&lt;b&gt;哪个&lt;/b&gt;调度器的continuation呢？不是线程初始化时传入的那个，而是最新的那个。因此，我们必须以某种方式将sched-k中的值“thread”（译注，传递）给yielder。有很多种方式可以实现，但最简单的，也许是最暴力的方式是，简单地为每个线程恢复重建yielder，总是包含sched-k的最新值：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax thread-0
  (syntax-rules ()
    [(thread (yielder) b ...)
     (letrec ([thread-resumer (lambda (_)
                                (begin b ...))]
              [yielder (lambda () (error &#39;yielder &quot;nothing here&quot;))])
       (lambda (sched-k)
         (begin
           (set! yielder
                 (lambda ()
                   (let/cc thread-k
                     (begin
                       (set! thread-resumer thread-k)
                       (sched-k &#39;dummy)))))
           (thread-resumer &#39;tres))))]))&lt;/code&gt;&lt;p&gt;将这些放到一起运行，我们得到：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;t1-1  t2-1  t3-1  t1-2  t2-2  t3-2  t1-3 t2-3 t3-3&lt;/code&gt;&lt;p&gt;嘿，这就是我们想要的！但是运行继续：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;t1-3 t2-3 t3-3 t1-3 t2-3 t3-3 t1-3 t2-3 t3-3&lt;/code&gt;&lt;p&gt;嗯。&lt;/p&gt;&lt;p&gt;怎么回事？恩，我们并没有说明当线程运行结束时需要怎么处理。实际上，控制只是返回到线程调度器，调度器将线程追加到队列的末尾，然后，当线程再次到达队列的头部时，控制从之前存储的那个continuation中恢复：对应于打印第三个值。打印，控制返回，线程被追加到队尾……无限循环。&lt;/p&gt;&lt;p&gt;显然，在线程终止时，我们需要通知线程调度器，这样调度器可以将其从线程队列中移除。我们创建简单的数据类型来表示该信号：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type ThreadStatus
  [Tsuspended]
  [Tdone])&lt;/code&gt;&lt;p&gt;（当然，在真实的系统中，这些状态消息也可以带上和计算相关的值。）那么我们必须修改调度器，实际检查和使用这些值：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (scheduler-loop-1 threads)
  (cond
    [(empty? threads) &#39;done]
    [(cons? threads)
     (type-case ThreadStatus (let/cc after-thread ((first threads) after-thread))
       [Tsuspended () (scheduler-loop-1 (append (rest threads)
                                                (list (first threads))))]
       [Tdone () (scheduler-loop-1 (rest threads))])]))&lt;/code&gt;&lt;p&gt;线程的表示中有两个地方需要修改：中间返回的时候它必须传Tsuspended给调度器的continuation，终止时传Tdone。哪里是终止呢？在执行完线程体代码&lt;code class=&quot;inline&quot;&gt;b ...&lt;/code&gt;之后。最后，请注意和退位一样，终止程序必须也使用最新的调度器continuation。因而：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-syntax thread-1
  (syntax-rules ()
    [(thread (yielder) b ...)
     (letrec ([thread-resumer (lambda (_)
                                (begin b ...
                                       (finisher)))]
              [finisher (lambda () (error &#39;finisher &quot;nothing here&quot;))]
              [yielder (lambda () (error &#39;yielder &quot;nothing here&quot;))])
       (lambda (sched-k)
         (begin
           (set! finisher
                 (lambda ()
                   (let/cc thread-k
                     (sched-k (Tdone)))))
           (set! yielder
                 (lambda ()
                         (let/cc thread-k
                           (begin
                             (set! thread-resumer thread-k)
                             (sched-k (Tsuspended))))))
           (thread-resumer &#39;tres))))]))&lt;/code&gt;&lt;p&gt;用scheduler-loop-1和thread-1替换scheduler-loop-0和thread-0，重新运行前面的示例程序，我们就得到了想要的输出。&lt;/p&gt;&lt;h2&gt;14.6.4 更好的Web编程指令&lt;/h2&gt;&lt;p&gt;最后，我们回过头看看read-number：请注意，如果运行服务器程序的语言有call/cc，我们就不必CPS整个程序，而是可以简单地捕获当前continuation，将其保存在哈希表中，从而使程序结构保持不变。&lt;/p&gt;</description>
<author>MrMathematica</author>
<guid isPermaLink="false">2017-12-15-32037390</guid>
<pubDate>Fri, 15 Dec 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
