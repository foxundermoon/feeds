<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Sat, 05 May 2018 08:39:35 +0800</lastBuildDate>
<item>
<title>活化石</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-05-04-36427205.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36427205&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近计算机架构课组织了一次去&lt;a href=&quot;https://livingcomputers.org/&quot;&gt;Living Computers - Home&lt;/a&gt;的春游（误？），可惜迷路了，导致来晚，只看到一小半。&lt;/p&gt;&lt;p&gt;很好的一点是里面的计算机都是可远观而亦可亵玩 - 事实上我们的作业就是随便找台计算机在上面编程。&lt;/p&gt;&lt;p&gt;对于喜欢计算机历史的人来说很爽啊 - 从书上看着各种电脑各种OS是一码事，真正的看到，然后摸，还能用，感觉完全不一样。&lt;/p&gt;&lt;p&gt;尤其是还有Xerox Alto。还有个巨大的装着Smalltalk的盘盘。把老娘的爪爪放在圆圆的Smalltalk上然后插进Xerox Alto真是满足死我了。可惜不知道为啥Smalltalk跑不起来 - 放太久了？&lt;/p&gt;&lt;p&gt;信仰++++。&lt;/p&gt;&lt;p&gt;然后Digi-Comp（见&lt;a href=&quot;https://www.youtube.com/watch?v=_tZdE-3nR3w&quot;&gt;https://www.youtube.com/watch?v=_tZdE-3nR3w&lt;/a&gt;）也很好玩。&lt;/p&gt;&lt;p&gt;另：某Lisp厨失望了 - 没有Lisp Machine。&lt;/p&gt;&lt;p&gt;另另：有辛去的话，推荐下Pecos Pit Bar-B-Que，好好吃，实习以后大半年都没吃到这么辣的东西辣，sad&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2018-05-04-36427205</guid>
<pubDate>Fri, 04 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>第四届函数式编程分享会</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-05-01-36308855.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36308855&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;报名地址: &lt;a href=&quot;https://jinshuju.net/f/9a72wh&quot;&gt;深圳函数式编程聚会&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;计划暂定&lt;/b&gt;于2018年5月19日早9:30，于深圳福田区嘉里建设广场3栋39层（嘉石大岩资本）&lt;/p&gt;&lt;p&gt;分享函数式编程的经验，也可以微博关注@&lt;a href=&quot;http://weibo.com/u/2709495807?source=webim&quot;&gt;Haskell中文&lt;/a&gt; &lt;a href=&quot;http://weibo.com/u/1914643755?refer_flag=1005055010_&quot;&gt;@阅千人而惜知己&lt;/a&gt; &lt;a href=&quot;https://weibo.com/notyy?topnav=1&amp;amp;wvr=6&amp;amp;topsug=1&quot;&gt;@大魔头&lt;/a&gt;，如有任何疑问可以加入QQ群72874436讨论。&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6676ea444bda2c703add8474963e800a&quot; data-hash=&quot;6676ea444bda2c703add8474963e800a&quot; data-hovercard=&quot;p$b$6676ea444bda2c703add8474963e800a&quot;&gt;@阅千人而惜知己&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0a308ec0bd0ce92754be4e85db62a29a&quot; data-hash=&quot;0a308ec0bd0ce92754be4e85db62a29a&quot; data-hovercard=&quot;p$b$0a308ec0bd0ce92754be4e85db62a29a&quot;&gt;@parker liu&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/73c168246af1fab79b28736c311466e1&quot; data-hash=&quot;73c168246af1fab79b28736c311466e1&quot; data-hovercard=&quot;p$b$73c168246af1fab79b28736c311466e1&quot;&gt;@韩冬&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/2d8f51b6523e01a8529606f466d98198&quot; data-hash=&quot;2d8f51b6523e01a8529606f466d98198&quot; data-hovercard=&quot;p$b$2d8f51b6523e01a8529606f466d98198&quot;&gt;@Felis sapiens&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/4cf2f4dca8e0339f5c2a460ecb62db39&quot; data-hash=&quot;4cf2f4dca8e0339f5c2a460ecb62db39&quot; data-hovercard=&quot;p$b$4cf2f4dca8e0339f5c2a460ecb62db39&quot;&gt;@大魔头-诺铁&lt;/a&gt; &lt;/p&gt;&lt;p&gt;如果条件允许的话&lt;b&gt;可能&lt;/b&gt;会有直播&lt;/p&gt;&lt;p&gt;微信群二维码(知乎会自动转链接): &lt;/p&gt;&lt;a href=&quot;https://ibb.co/iJCteS&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Wechat IMG2&lt;/a&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我写的往届的一些记录:&lt;/p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26722010&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;祖与占：上海2017年函数式编程分享会视频&lt;/a&gt;&lt;a href=&quot;https://www.zhihu.com/question/59391737/answer/164874243&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;参加 2017 年函数式编程聚会是什么感受?&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20831552&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;祖与占：第2届函数式编程分享随便记&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>祖与占</author>
<guid isPermaLink="false">2018-05-01-36308855</guid>
<pubDate>Tue, 01 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>lambda演算与数据类型</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-25-36081360.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36081360&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fc94609d676b4704ccfce8b67fd56e62_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在大多数编程语言里面，数据类型和函数都是不同的，但它们又有种种关联。我们可以说函数是一种数据类型，换句话说就是first class function。通过pattern match我们可以拿到ADT（代数数据类型）的各个constructor的argument。再用Idris举个例子：&lt;/p&gt;&lt;code lang=&quot;idris&quot;&gt;data Maybe : (a : Type) -&amp;gt; Type where
    Nothing : Maybe a
    Just : (x : a) -&amp;gt; Maybe a&lt;/code&gt;&lt;p&gt;我们定义了2个函数：Nothing和Just，这两个function都用于构造数据类型Maybe，所以他们的返回值的类型是Maybe，我们把这两个函数称之为constructor。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;前置知识&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;对函数式编程及相关编程语言的了解&lt;/li&gt;&lt;li&gt;对Lambda演算的基本知识&lt;/li&gt;&lt;li&gt;ADT（代数数据类型）的基本知识&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;数据类型与函数&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在lambda calculus中，一切都是函数。我们通过：variable、abstraction、application来组成lambda的term。一般通过对lambda term应用normal order reduction来对lambda term进行求值。&lt;/p&gt;&lt;p&gt;既然函数可以是一种数据类型，数据类型可不可以用函数来表示呢？当然可以。例如在lambda演算中通常表示自然数的方式，或者说church number则是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;zero := λf.λx.x;
succ := λn.λf.λx.f (n f x);&lt;/code&gt;&lt;p&gt;如果不熟悉church encoding的自然数可以在维基百科中了解：&lt;/p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Lambda_calculus&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;https://en.wikipedia.org/wiki/Lambda_calculus&lt;/a&gt;&lt;p&gt;我们有多种方式将数据类型encode到lambda calculus中，如church number：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;0 := λf.λx.x;
1 := λf.λx.f x;
2 := λf.λx.f (f x);&lt;/code&gt;&lt;p&gt;则是通过将参数f递归的应用在x上来encode自然数的。&lt;/p&gt;&lt;p&gt;而peano number，或者也可以说是scott encoding的自然数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;zero := λz.λs.z;
succ := λn.λz.λs.s n;

0 := λz.λs.z;
1 := λz.λs.s (λz.λs.z);
2 := λz.λs.s (λz.λs.s (λz.λs.z));&lt;/code&gt;&lt;p&gt;则是将数据类型的constructor定义出来，并encode每个constructor的pattern match函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;数据类型的表示&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们可以通过将数据类型相关的一种operator进行encode，来将数据类型表示到lambda calculus中。例如上文自然数的例子，Church encoding是将”递归的把函数f应用n次到x上(f^n)“这种operator进行encode。Scott encoding则是将pattern match这种operator进行encoding。&lt;/p&gt;&lt;p&gt;一个operator就是一个函数，在Church encoding的自然数中，递归的把函数f应用n次到x上的function是trivial的，而pattern match则不是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;funcPow := λf.λx.λn.n f x;
matchNat := λz.λs.λn.n (λm.m (λu.λg.g (λf.λx.x)) (λg.λu.λh.h (λf.λx.f (g f x)))) (λx.λu.x) z s;&lt;/code&gt;&lt;p&gt;而用Scott encoding的peano number中，pattern match是trivial的，而funcPow则不是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;funcPow := λf.λx.λn.n x ((λg.(λy.g (y y)) (λy.g (y y))) (λg.λh.f (h x g)));
matchNat := λz.λs.λn.n z s;&lt;/code&gt;&lt;p&gt;不单单是自然数，其他数据类型也可以用类似的方法进行encode。例如对于List，我们可以将其按fold right进行encode，或者按pattern match进行encode等。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Scott encoding&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在上文中多次提到了scott encoding、pattern match这两个名词。具体来说，对于ADT（也就是有多个constructor，每个constructor有任意argument，或者说product的sum）来说，可能最简单、最直观的encode数据类型的方法就是将pattern match进行encode了，scott encoding就是指的这种encode数据类型的方法。&lt;/p&gt;&lt;p&gt;具体对于有n个constructor的ADT，对于第x个constructor，有m个argument，用如下方法进行encode：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;CtorX := λA_1 A_2 ... A_m.λC_1 C_2 ... C_n.C_x A_1 A_2 ... A_m;&lt;/code&gt;&lt;p&gt;这样就可以对直观的对不同的case进行pattern match了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Encoding of list&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文中提到过对list进行encode的2种方法，关于其他的encode方法，可以参考维基百科：&lt;/p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Church_encoding#List_encodings&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;https://en.wikipedia.org/wiki/Church_encoding#List_encodings&lt;/a&gt;&lt;p&gt;这里我们使用Scott encoding来encode list，定义list(pattern match)、nil(constructor)、cons(constructor)、length、null、append、foldr、foldl函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;list := λn.λc.λl.l n c;

nil := λn.λc.n;
cons := λh.λt.λn.λc.c h t;

length := λl.l zero (λh.λt.succ (length t));
null := λl.l true (λh.λt.false);
append := λl.λm.l m (λh.λt.cons h (append t m));
foldr := λf.λx.λl.l x (λh.λt.f h (foldr f x t));
foldl := λf.λx.λl.l x (λh.λt.foldl f (f x h) t);&lt;/code&gt;&lt;p&gt;每个函数的定义都比较直观，就不详细描述了。对于引用了其他函数的情况可以直接代换，也可以将其当作free variable，并使用abstraction将其捕获，通过application传入其定义，例如对于null：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;null := (λtrue.λfalse.λl.l true (λh.λt.false)) (λt.λf.t) (λt.λf.f);&lt;/code&gt;&lt;p&gt;需要注意的是length、append、foldr、foldl都在定义中引用了自身，也就是使用了递归。对于这种情况，需要使用不动点算子：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fix := λf.(λx.f (x x)) (λx.f (x x));&lt;/code&gt;&lt;p&gt;将其转化为：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;length := fix (λlength.λl.l zero (λh.λt.succ (length t)));
append := fix (λappend.λl.λm.l m (λh.λt.cons h (append t m)));
foldr := fix (λfoldr.λf.λx.λl.l x (λh.λt.f h (foldr f x t)));
foldl := fix (λfoldl.λf.λx.λl.l x (λh.λt.foldl f (f x h) t));&lt;/code&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了如何在lambda calculus中处理数据类型，和各种encoding之间的关系。&lt;/p&gt;&lt;p&gt;这里打个广告，写这篇文章的起因是最近在用scala写一个个人项目，lambda calculus的REPL。在设计标准库的时候涉及到了一些与本文相关的知识。已经实现了tokenizer、parser、beta reducer、eta converter、pretty printer等模块，单纯调用API来处理lambda term是没有问题了。目前正在设计核心的REPL的Extension API、library的dependencies管理、lam文件（library的源文件）的语法、标准库等。如果有兴趣参与开发，欢迎联系我！&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/yuxuanchiadm/lamcalcj&quot;&gt;https://github.com/yuxuanchiadm/lamcalcj&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Lambda_calculus&quot;&gt;Lambda calculus&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Church_encoding&quot;&gt;Church encoding&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding&quot;&gt;Mogensen–Scott encoding&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>不可构造的雨轩菌</author>
<guid isPermaLink="false">2018-04-25-36081360</guid>
<pubDate>Wed, 25 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>一款能设置你的DrRacket背景的IDE插件</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-23-36027427.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36027427&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e7f5beb3b56104a4ee29bcd37d7e8c1c_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;安装方式（两种）：&lt;/p&gt;&lt;p&gt;1.进入终端，输入下面的命令：&lt;/p&gt;&lt;p&gt;raco pkg install DrRacketTheme&lt;/p&gt;&lt;p&gt;在不同操作系统上可能有所不同，如果没有成功，请尝试先进入racket安装目录下然后在运行这条命令。&lt;/p&gt;&lt;p&gt;2.打开DrRacket，打开File菜单下的Package Manager，切换到Available from Catalog选项卡，点击Update Package List按钮，稍等片刻，然后在Filter文本框中输入DrRacketTheme，点击Install按钮。&lt;/p&gt;&lt;p&gt;设置的时候请点击View菜单下的Set Background，选择需要作为背景的图片。&lt;/p&gt;&lt;p&gt;Set Background Alignment能够设置图片的对齐方式。&lt;/p&gt;&lt;p&gt;希望这款插件能够帮助到正在学习racket或是scheme的人。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>御坂黒子</author>
<guid isPermaLink="false">2018-04-23-36027427</guid>
<pubDate>Mon, 23 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何玩弄Typed Racket</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-21-35962271.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35962271&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要玩弄Typed Racket，首先，你不可避免地要require一大堆东西：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang racket
(require racket/require)
(require typed-racket/utils/utils
         typed-racket/standard-inits
         (private parse-type)
         (rep values-rep)
         (types abbrev subtype tc-result numeric-tower)
         (typecheck typechecker tc-funapp)
         (for-template (base-env base-types))
         (rename-in (base-env base-types-extra) [Un t:Un] [-&amp;gt; t:-&amp;gt;] [-&amp;gt;* t:-&amp;gt;*])
         (env global-env)
         )

(do-standard-inits)&lt;/code&gt;&lt;p&gt;　　然后我们看看怎么parse一个类型：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (parse-type #&#39;String)
String

&amp;gt; (parse-type #&#39;(Pairof String String))
(Pairof String String)

&amp;gt; (parse-type #&#39;(All (a) (a → String)))
(All (a) (-&amp;gt; a String))&lt;/code&gt;&lt;p&gt;　　基本上直接照搬TR的语法即可。除了&lt;code class=&quot;inline&quot;&gt;-&amp;gt;&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;-&amp;gt;*&lt;/code&gt;，因为上面&lt;code class=&quot;inline&quot;&gt;base-types-extra&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;abbrev&lt;/code&gt;的冲突，要改用&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (parse-type #&#39;(String t:-&amp;gt; String))
(-&amp;gt; String String)

&amp;gt; (parse-type #&#39;(t:-&amp;gt;* (String) String))
(-&amp;gt; String String)&lt;/code&gt;&lt;p&gt;　　好了，学会parse一个类型之后，再看看怎么手动构造一些简单的类型。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; Univ
Any

&amp;gt; -Bottom
Nothing

&amp;gt; (Un -True -False)
(U #f #t)

&amp;gt; (make-Pair -String -Boolean)
(Pairof String (U #f #t))

&amp;gt; (make-Intersection (list -Boolean -True))
(∩ #t (U #f #t))

&amp;gt; (-poly (a) (-&amp;gt; a a))
(All (a) (-&amp;gt; a a))

&amp;gt; (make-Mu &#39;x (Un -Null (make-Pair -String (make-F &#39;x))))
(Listof String)

&amp;gt; (-lst Univ)
(Listof Any)&lt;/code&gt;&lt;p&gt;　　现在来构造一些复杂的类型，例如带latent proposition、latent object的函数类型：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (-&amp;gt; Univ
      (make-Values
       (list
        (make-Result -Boolean
                     (-PS (-is-type (make-Path null (cons 0 0)) -String)
                          (-not-type (make-Path null (cons 0 0)) -String))
                     -empty-obj))))
(-&amp;gt; Any (U #f #t) : String)

&amp;gt; (make-pred-ty -String)
(-&amp;gt; Any (U #f #t) : String)&lt;/code&gt;&lt;p&gt;　　此外，latent propositions常用的缩写有&lt;code class=&quot;inline&quot;&gt;true-propset&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;-false-propset&lt;/code&gt;等；latent object常用的缩写有&lt;code class=&quot;inline&quot;&gt;-arg-path&lt;/code&gt;等。&lt;/p&gt;&lt;p&gt;　　说完构造类型了，现在开始进行类型推导：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (tc-expr #&#39;&#39;1)
(tc-results
 (list (tc-result 1 (Top | Bot) -))
 #f)
 
&amp;gt; (tc-expr #&#39;&#39;&quot;123&quot;)
(tc-results
 (list (tc-result String (Top | Bot) -))
 #f)&lt;/code&gt;&lt;p&gt;　　要注意的是这个推导是针对&lt;i&gt;Fully Expanded Programs&lt;/i&gt;，Typed Racket把程序展开到&lt;i&gt;Fully Expanded Programs&lt;/i&gt;的同时做了的事包括有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;把类型声明记录到一个环境里。&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (register-type #&#39;f1 Univ)  
&amp;gt; (tc-expr #&#39;f1)
 (tc-results  (list (tc-result Any (Top | Top) -))  #f)&lt;/code&gt;&lt;ul&gt;&lt;li&gt;插入一些&lt;i&gt;syntax properties&lt;/i&gt;，以便在&lt;i&gt;Fully Expanded Programs&lt;/i&gt;里留下足够的辅助信息，主要需要注意的有&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;typechecker:plambda&lt;/code&gt;：用于多态。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;type-label&lt;/code&gt;：用于在引入binding的时候声明类型。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;type-ascription&lt;/code&gt;：用于ann。&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (tc-expr (syntax-property #&#39;&#39;1 &#39;type-ascription -Integer))
(tc-results
 (list
  (tc-result
   (U
    0
    1
    Byte-Larger-Than-One
    Negative-Fixnum
    Negative-Integer-Not-Fixnum
    Positive-Fixnum-Not-Index
    Positive-Index-Not-Byte
    Positive-Integer-Not-Fixnum)
   (Top | Bot)
   -))
 #f)
 
 &amp;gt; (tc-expr (syntax-property
            #`(#%plain-lambda
               (#,(syntax-property
                   #&#39;x
                   &#39;type-label
                   #&#39;a))
               x)
            &#39;typechecker:plambda
            #&#39;(a)))
(tc-results
 (list
  (tc-result
   (All (a) (-&amp;gt; a a))
   (Top | Bot)
   -))
 #f)&lt;/code&gt;&lt;p&gt;　　这样基本上就差不多了，然后说一下&lt;i&gt;subtyping&lt;/i&gt;：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (subtype -One -Integer)
#t

&amp;gt; (subtype -True (Un -True -False))
#t

&amp;gt; (subtype (-poly (a) (Un a -String)) -String)
#t&lt;/code&gt;&lt;p&gt;　　掌握这些东西后，差不多就可以玩Typed Racket了，比如探究latent object对类型推导的影响（参见&lt;a href=&quot;https://github.com/racket/typed-racket/issues/678&quot;&gt;https://github.com/racket/typed-racket/issues/678&lt;/a&gt;）：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (register-type #&#39;f1 (-poly (a)
                           (-&amp;gt; (make-Intersection (list a top-func))
                               (make-Values
                                (list
                                 (make-Result
                                  (make-Intersection (list a top-func))
                                  -true-propset
                                  -empty-obj
                                  ))))))
&amp;gt; (register-type #&#39;f2 (-poly (a)
                           (-&amp;gt; (make-Intersection (list a top-func))
                               (make-Values
                                (list
                                 (make-Result
                                  (make-Intersection (list a top-func))
                                  -true-propset
                                  (-arg-path 0)
                                  ))))))
                                  
&amp;gt; (tc-expr #`(#%plain-app f1 f1))
(tc-results
 (list
  (tc-result
   (-&amp;gt; Nothing (case-&amp;gt;))
   (Top | Bot)
   -))
 #f)
 
&amp;gt; (tc-expr #`(#%plain-app f2 f2))
(tc-results
 (list
  (tc-result
   (All
    (a)
    (-&amp;gt; (∩ (case-&amp;gt;) a) (∩ (case-&amp;gt;) a)))
   (Top | Bot)
   -))
 #f)&lt;/code&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>qww6</author>
<guid isPermaLink="false">2018-04-21-35962271</guid>
<pubDate>Sat, 21 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Racket杂谈：可扩展的宏</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-21-35953489.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35953489&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;　　去年9月份的文章了，估计只有群友看过，现在放到公开场所来。Typed Racket用到的宏技巧被称为Advanced Macrology，那么这里介绍的算是trivial macrology吧。写的比较啰嗦狗血，随意了。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;　　众所周知，宏是很多Lisp方言中重要的一部分，在Racket中亦是如此。Racket中有着众多功能各不相同的宏：轻量级的&lt;code class=&quot;inline&quot;&gt;cond&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;case&lt;/code&gt;，……；中量级的&lt;code class=&quot;inline&quot;&gt;match&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;for&lt;/code&gt;，……；重量级的&lt;code class=&quot;inline&quot;&gt;racket/class&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;syntax/parse&lt;/code&gt;等……&lt;/p&gt;&lt;p&gt;　　有一天，路人丙注意到，Racket中很多复杂的宏都提供了一种可以自定义关键字的机制：&lt;code class=&quot;inline&quot;&gt;for&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;define-sequence-syntax&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;match&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;define-match-expander&lt;/code&gt;以及&lt;code class=&quot;inline&quot;&gt;syntax/parse&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;pattern-expander&lt;/code&gt;等。使用这类机制，用户可以自行给原有的宏加上自己想要的功能！&lt;/p&gt;&lt;p&gt;　　于是路人丙开始思考如何给自己的宏加上这种方便的能力。路人丙注意到，&lt;code class=&quot;inline&quot;&gt;pattern-expander&lt;/code&gt;是使用普通的&lt;code class=&quot;inline&quot;&gt;define-syntax&lt;/code&gt;来定义的。聪明的路人丙立刻想到使用&lt;code class=&quot;inline&quot;&gt;syntax-local-value&lt;/code&gt;来获取宏展开环境中的值。他写下了如下一段试验代码：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang racket

(define x &#39;(1))

(define-syntax (expander1 stx)
  (syntax-case stx ()
    [id #&#39;(id x)]))

(define-syntax (use-expander stx)
  (syntax-case stx ()
    [(_ id in)
     ((syntax-local-value #&#39;id) #&#39;in)]))

(use-expander expander1 car)&lt;/code&gt;&lt;p&gt;　　运行该程序，路人丙如愿所偿地得到了结果&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。嗯，大功告成，路人丙成功揭开了这类宏的秘密，他感觉自己功力大增，距离成为一代宗师已经不远了！&lt;/p&gt;&lt;p&gt;　　直到有一天，他稍微改了下自己的程序：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang racket

(define x &#39;(1))

(define-syntax (expander1 stx)
  (syntax-case stx ()
    [id #&#39;(id x)]))

(define-syntax (use-expander stx)
  (syntax-case stx ()
    [(_ id in)
     #`(let ([x &#39;(2)])
         #,((syntax-local-value #&#39;id) #&#39;in))]))

(use-expander expander1 car)&lt;/code&gt;&lt;p&gt;　　运行结果是&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;，路人丙慌了，按照习俗，宏应该是 &lt;i&gt;hygienic&lt;/i&gt; 的,&lt;code class=&quot;inline&quot;&gt;expander1&lt;/code&gt;中的&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;不应该意外地绑定&lt;code class=&quot;inline&quot;&gt;use-expander&lt;/code&gt;中的&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;，这样的结果令他无法接受。那么应该怎么改呢？&lt;/p&gt;&lt;p&gt;　　路人丙百思不得其解，于是他向路人壬请教了这个问题。路人壬告诉他，这种xxx expadner在Racket社区中，有一种固定的写法。路人丙记下了这个写法，回去果然一试即成。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang racket

(begin-for-syntax
  (define (apply-expander proc stx)
    (define introducer (make-syntax-introducer))
    (define intro-stx (introducer (syntax-local-introduce stx)))
    (syntax-local-introduce (introducer (proc intro-stx)))))

(define x &#39;(1))

(define-syntax (expander1 stx)
  (syntax-case stx ()
    [id #&#39;(id x)]))

(define-syntax (use-expander stx)
  (syntax-case stx ()
    [(_ id in)
     #`(let ([x &#39;(2)])
         #,(apply-expander (syntax-local-value #&#39;id) #&#39;in))]))

(use-expander expander1 car)&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解释&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　我们首先来回顾一下Racket的宏展开原理，参考&lt;a href=&quot;https://docs.racket-lang.org/reference/syntax-model.html&quot;&gt;1.2 Syntax Model&lt;/a&gt;，我们看到：&lt;/p&gt;&lt;blockquote&gt;Before the expander passes a &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax object&lt;/a&gt; to a transformer,the &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax object&lt;/a&gt; is extended with a fresh &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._scope%29&quot;&gt;scope&lt;/a&gt; (thatapplies to all sub-&lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax objects&lt;/a&gt;) to distinguish &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax objects&lt;/a&gt;at the macro’s use site from &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax objects&lt;/a&gt; that are introduced by the macro;in the result of the transformer the presence of the &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._scope%29&quot;&gt;scope&lt;/a&gt; isflipped, so that introduced &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax objects&lt;/a&gt; retain the &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._scope%29&quot;&gt;scope&lt;/a&gt;,and use-site &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax objects&lt;/a&gt; do not have it. In addition, ifthe use of a transformer is in the same definition context as its binding,the use-site &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax object&lt;/a&gt; is extended with an additional freshuse-site scope that is not flipped in the transformer’s result,so that only use-site &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax objects&lt;/a&gt; have the &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._use._site._scope%29&quot;&gt;use-site scope&lt;/a&gt;.&lt;/blockquote&gt;&lt;p&gt;　　简单来说，在宏展开之前，各个 &lt;i&gt;identifier&lt;/i&gt; 会被打上一个特殊的标记，然后传递给 &lt;i&gt;transformer&lt;/i&gt; 进行展开，展开完成后，结果中带有该标记的去除该标记，没有的则加上。可以发现，经过这么一番处理， &lt;i&gt;transformer&lt;/i&gt; 中新引入的  &lt;i&gt;identifier&lt;/i&gt; 全部带上了该标记，而作为参数传进来的则是原封不动。Racket通过这些标记得以区分出宏展开引入的 &lt;i&gt;identifier&lt;/i&gt; ，具体参考&lt;a href=&quot;http://www.cs.utah.edu/plt/scope-sets/index.html&quot;&gt;Binding as Sets of Scopes&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;　　再看看文档中对&lt;code class=&quot;inline&quot;&gt;make-syntax-introducer&lt;/code&gt;的解释，我们发现，上面的代码其实模仿了这一过程！第一次的&lt;code class=&quot;inline&quot;&gt;introducer&lt;/code&gt;给所有的syntax objects加上了该标记，第二次则是将其反转，这样一来，&lt;code class=&quot;inline&quot;&gt;expander1&lt;/code&gt;引入的&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;就被区分开了。&lt;/p&gt;&lt;p&gt;　　那么&lt;code class=&quot;inline&quot;&gt;introducer&lt;/code&gt;前后的&lt;code class=&quot;inline&quot;&gt;syntax-local-introduce&lt;/code&gt;在这里又干了什么呢？答案很简单，因为&lt;code class=&quot;inline&quot;&gt;use-expander&lt;/code&gt;本身也是一个宏，展开前后也做了上面的操作。如果没有&lt;code class=&quot;inline&quot;&gt;syntax-local-introduce&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;expander1&lt;/code&gt;展开后&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;不带有&lt;code class=&quot;inline&quot;&gt;use-expander&lt;/code&gt;的标记，然后&lt;code class=&quot;inline&quot;&gt;use-expander&lt;/code&gt;展开结束，标记反转，&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;同时带上了&lt;code class=&quot;inline&quot;&gt;expander1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;use-expander&lt;/code&gt;的标记，根据Racket的按最大子集确定 &lt;i&gt;identifier&lt;/i&gt; 的绑定的算法，仍然有可能得到出人意料的结果。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang racket

(begin-for-syntax
  (define (apply-expander proc stx)
    (define introducer (make-syntax-introducer))
    (define intro-stx (introducer stx))
    (introducer (proc intro-stx))))

(define x &#39;(1))

(define-syntax (expander1 stx)
  (syntax-case stx ()
    [id #&#39;(id x)]))

(define-syntax (use-expander stx)
  (syntax-case stx ()
    [(_ id in)
     #`(let ([x &#39;(2)])
         #,(apply-expander (syntax-local-value #&#39;id) #&#39;in))]))

(use-expander expander1 car) ;得到2，而不是1&lt;/code&gt;&lt;p&gt;　　通过使用&lt;code class=&quot;inline&quot;&gt;syntax-local-introduce&lt;/code&gt;，我们实际上将&lt;code class=&quot;inline&quot;&gt;expander1&lt;/code&gt;当做了另一次无关的展开，排除了这种风险。&lt;/p&gt;&lt;p&gt;　　这就是Racket社区中对于xxx expander的习惯性写法。例子参见&lt;a href=&quot;https://github.com/racket/racket/blob/e819b58461b31f6e2b6cfb0aa2ab420ac682d9d9/racket/collects/racket/match/parse-helper.rkt#L169&quot;&gt;match-expander&lt;/a&gt;以及&lt;a href=&quot;https://github.com/racket/racket/blob/44eb5532adcfdc37cd5310245b7d02e0b9f97056/racket/collects/syntax/parse/private/rep.rkt#L613&quot;&gt;pattern-expander&lt;/a&gt;。&lt;/p&gt;</description>
<author>qww6</author>
<guid isPermaLink="false">2018-04-21-35953489</guid>
<pubDate>Sat, 21 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>《软件基础》中文版正式上线</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-21-35937895.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35937895&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d8bec70405d79db734aefc490425a9d5_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;《&lt;a href=&quot;https://coq-zh.github.io/SF-zh/&quot;&gt;软件基础&lt;/a&gt;》系列（英文版 &lt;a href=&quot;https://softwarefoundations.cis.upenn.edu/&quot;&gt;Software Foundations&lt;/a&gt;，主要作者 &lt;a href=&quot;http://www.cis.upenn.edu/~bcpierce/&quot;&gt;Benjamin C. Pierce&lt;/a&gt;）主要介绍了可靠软件的数学基础。书籍目前分为《逻辑基础》、《编程语言基础》和《函数式算法验证》三卷本。内容涵盖了函数式编程、逻辑基础、计算机辅助定理证明、Coq 证明助理、编程语言理论、操作语义、霍尔逻辑、静态类型系统、基础数据结构和算法的形式化验证等非常丰富的内容。&lt;/p&gt;&lt;p&gt;《软件基础》最主要的新颖之处在于，书中的每一处细节都百分之百地形式化且通过了机器验证。 每卷书中的所有文本，包括练习，根本上都是一份 Coq 证明助理的「证明脚本」。&lt;/p&gt;&lt;p&gt;本系列书籍的目标受众包括高年级本科生、研究生、博士以及研究者在内的广大读者。书中并未假定读者有逻辑学或编程语言的背景，不过熟悉一些数学对于学习来说会很有帮助。 &lt;/p&gt;&lt;p&gt;目前正在翻译的为《软件基础》系列的第一卷《逻辑基础》。网站为 Alpha 版，不少章节尚未翻译完成，因此译文中还存在着大量的错误和纰漏，欢迎广大读者&lt;a href=&quot;https://github.com/Coq-zh/SF-zh&quot;&gt;加入审校&lt;/a&gt;，发起 Issue 参与讨论并打磨斧正。&lt;/p&gt;&lt;p&gt;&lt;b&gt;注：由于本书源码库基于官方私有库翻译，网站为源码库编译生成而来，因此为避免同步合并的麻烦，我们只接受 Issue，不接受 PR。&lt;/b&gt;&lt;/p&gt;</description>
<author>Oling Cat</author>
<guid isPermaLink="false">2018-04-21-35937895</guid>
<pubDate>Sat, 21 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>命运之轮</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-15-35699422.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35699422&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我最初学编程，应该也就是2010年左右的事情吧。&lt;/p&gt;&lt;p&gt;当时啥也不会，就会在C++吧水贴。&lt;/p&gt;&lt;p&gt;在那，听说过了有一个很厉害很潮流的东西，叫做C++11，有什么叫concept跟module的东西，好像挺厉害的样子。&lt;/p&gt;&lt;p&gt;当时，在clang上就可以用C++11了，只不过这两功能还没有，就有auto, lambda, constexpr 不知道有没有（记不清了），也很好了。&lt;/p&gt;&lt;a href=&quot;https://www.zhihu.com/question/56943731&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;时间快进到现在，这两功能还是没加进去。&lt;/a&gt;&lt;p&gt;不过C++厨们可以稍稍放心，我今天不是来黑C++的。&lt;/p&gt;&lt;p&gt;这固然是C++的悲剧，不过也是所有语言的悲剧。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果去看历史，去看看一个个语言的发展，我们会发现一个规律：&lt;/p&gt;&lt;p&gt;&lt;b&gt;语言/语言家族的发展，是不停的扩大，直到无法支撑自身的重量而倒下为止。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;让我们跳到1958。&lt;/p&gt;&lt;p&gt;ALGOL。&lt;/p&gt;&lt;p&gt;只要大家说计算机历史，就一定要说ALGOL。&lt;/p&gt;&lt;p&gt;因为这可以说是一切的开端。也是一门伟大的语言。&lt;/p&gt;&lt;p&gt;做Algol相关的work的图灵奖得主，足足有6个：John Backus，Alan Perlis，Peter Naur，John McCarthy，Edsger W. Dijkstra，Tony Hoare。还有无冕之王，Peter Landin跟John Reynold。&lt;/p&gt;&lt;p&gt;但是，为何这么成功的语言，却默默无名？因为错在了下一步。&lt;/p&gt;&lt;p&gt;在1960后，ALGOL推出了ALGOL 58，ALGOL 60，还有各种方言后，大家开始慢慢懂该怎么设计语言，实现编译器了。BNF，Recursion，Continuation，Stack，都慢慢被大家发明发现，慢慢熟悉。大家也开始发现了ALGOL 60没做好跟没有做的东西。&lt;/p&gt;&lt;p&gt;于是，1962起，大家开始发明一门新的，叫ALGOL X的语言，旨在把这些问题修好。从1962起讨论，一直到1965，变成一个draft。高兴的ALGOL厨把这叫做ALGOL W，并且等着用了。一切就差一些小修小补了。&lt;/p&gt;&lt;p&gt;就跟物理学大厦就剩下两朵乌云一样。&lt;/p&gt;&lt;p&gt;快进半年。另外一个ALGOL W的draft被奉上。情况不容乐观。&lt;/p&gt;&lt;p&gt;本来说好的三个月，跳票成了半年不说，draft变得更厚更长，问题反而越来越多。于是说在等三个月，我们再修修。&lt;/p&gt;&lt;p&gt;明明说三月，三月后又三月，三月后又三月，都快一年了。&lt;/p&gt;&lt;p&gt;拖了9个月后，在1968年尾，一个叫ALGOL W的，连设计者也不爱的怪兽产生了。&lt;/p&gt;&lt;p&gt;自此，ALGOL被命运之轮碾过。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;故事的另一个主角，则知名得多。CPL。&lt;/p&gt;&lt;p&gt;这是1963，离悲剧还远得很，这时候大家都已自己是ALGOL方言为荣。&lt;/p&gt;&lt;p&gt;CPL就是一个ALGOL方言，旨在做更底层的ALGOL。&lt;/p&gt;&lt;p&gt;语言的设计也不算很复杂，唯一的问题就是不知道为啥，编译器死活写不出来。&lt;/p&gt;&lt;p&gt;于是，1967，有人在想，为何我们不把CPL简化点？这样就能做出编译器来了。&lt;/p&gt;&lt;p&gt;然后就出现了BCPL。同年，BCPL的编译器也被实现了。&lt;/p&gt;&lt;p&gt;两年后，为了把BCPL放上微型机，再次简化，出现了B。&lt;/p&gt;&lt;p&gt;同时间，B的一些问题被发现，效率也不够高，于是一个差不多的语言开始被设计，C。&lt;/p&gt;&lt;p&gt;而在C设计过程中，1970年，CPL的编译器终于面世。&lt;/p&gt;&lt;p&gt;命运之轮碾压过ALGOL，再碾压过CPL，碾压一次不够再碾压一次，BCPL，最后出了B，然后造就了C。最大赢家。&lt;/p&gt;&lt;p&gt;之后的，就是历史。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;不过，这不是结束。也不是结束的开始。顶多是开始的结束。&lt;/p&gt;&lt;p&gt;还记得最开头的C++吗？没错，命运之轮怎么会放过C。&lt;/p&gt;&lt;p&gt;在C++后，为了简化，出现了JAVA，旨在消除C++的各种复杂性-比如不区分unsigned啊，自动管理内存啊，只有Class啊-只不过，到了最后，还是照样该变大变大。自动管理内存的确比手动简单，但是JVM确变成一个怪兽。就连unsigned这种小东西，&lt;a href=&quot;https://www.zhihu.com/question/39596383/answer/82267124&quot;&gt;也回到语言中了。&lt;/a&gt;屠龙的勇士，必成恶龙。&lt;/p&gt;&lt;p&gt;另外一边，PERL崩溃之后诞生的Python也一样，，不知道怎么的，就加入了optional static typing。。。说好的only one way呢？Simplicity呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;专门搞PL的人别偷笑，Scala就不说了，Haskell也一样，GHC无比复杂，连RecursiveDo都能水一篇&lt;a href=&quot;https://pdfs.semanticscholar.org/20ab/57bf6d14d6a08a950b015d17af5f41b1b22b.pdf&quot;&gt;170页的Paper&lt;/a&gt;，有一个minimal core，也不能解决这问题。也别以为Macro能解决问题-R6RS总共有187页，其中，有90页是语言定义。被称为怪兽的ALGOL W也就265页，实在差不了多少。ALGOL 60呢？17页。ALGOL 58则只有15页。不过R7RS倒是还行，只有77页。当然，这是以丢掉向后兼容性为代价的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;有没有语言试图挑战这命运之轮？&lt;/p&gt;&lt;p&gt;有。Scheme，Python，都壮士断腕，丢掉了向后兼容性。自己不丢，别人就会给你丢。&lt;/p&gt;&lt;p&gt;Go也算是，Rob Pike活了60年，啥大风大浪没见过，尤其是Google的Build Server再也撑不起他们的C++，当然知道复杂度乃洪水猛兽-要不然为啥死撑不肯加generic。&lt;/p&gt;&lt;p&gt;不过这几个付出的代价不少-不是兼容性就是限制自己发展。对于语言设计者来说，这是个绕不开的问题。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;回到最初。为什么C++的concept module老是跳票，总共跳了9年？&lt;/p&gt;&lt;p&gt;还记得ALGOL W有多少页吗？265。至于C++17，1600多。6个ALGOL W，100个ALGOL 58。能让人大呼卧槽的数字。Java标准700页，加上JVM，也有1300页。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;于是隔几天，我跟朋友吃饭的时候提起，卧槽，现在的编程语言复杂度都变成鬼了，100个ALGOL。这么复杂，怎么设计怎么写编译器。&lt;/p&gt;&lt;p&gt;我那在nvidia实习的朋友听了，不以为然的说了声，哦。直到我过了半年，上了门计算机架构的课，才明白为什么他没有被震惊到。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其实PL的复杂度爆炸还算好的了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2018-04-15-35699422</guid>
<pubDate>Sun, 15 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Programming Languages: Application and Interpretation【译17】【完】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-13-35657622.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35657622&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b71b632ed7974538bb2e812bcd20914e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;校对: &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/9bebf466fc2535bec442451dca7cd13a&quot; data-hash=&quot;9bebf466fc2535bec442451dca7cd13a&quot; data-hovercard=&quot;p$b$9bebf466fc2535bec442451dca7cd13a&quot;&gt;@lotuc&lt;/a&gt; &lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;https://lotuc.gitbooks.io/plai-cn/content/&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;17 其他调用语义&lt;/h2&gt;&lt;p&gt;很久以前，我们讨论过在执行函数调用时替换的问题。现在是时候考虑一些替代方案了。当时，我们只提出了一种方案；其实还有更多选择。要理解这一点，请试着回答这个问题：&lt;/p&gt;&lt;p&gt;&lt;b&gt;下列哪些是相同的？&lt;/b&gt;&lt;br&gt;* &lt;code class=&quot;inline&quot;&gt;(f x (current-seconds))&lt;/code&gt;&lt;br&gt;* &lt;code class=&quot;inline&quot;&gt;(f x (current-seconds))&lt;/code&gt;&lt;br&gt;* &lt;code class=&quot;inline&quot;&gt;(f x (current-seconds))&lt;/code&gt;&lt;br&gt;* &lt;code class=&quot;inline&quot;&gt;(f x (current-seconds))&lt;/code&gt;&lt;/p&gt;&lt;p&gt;我们将会发现，这段语法可以对应非常不同的运行时行为。比如我们提到过的区别：何时求值&lt;code class=&quot;inline&quot;&gt;(current-seconds)&lt;/code&gt;导致的不同。另一个不同是，求值的&lt;b&gt;次数有多少&lt;/b&gt;（也即&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;运行的次数）。还有一个不同，&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的值是严格从调用者流向被调用者，还是甚至可能以相反的方向流动！&lt;/p&gt;&lt;h2&gt;17.1 惰性调用&lt;/h2&gt;&lt;p&gt;先来考虑参数何时规约为值。即，我们是将形参替换为实参的&lt;b&gt;值&lt;/b&gt;呢，还是实参&lt;b&gt;表达式&lt;/b&gt;本身？如果我们定义&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (sq x) (* x x))&lt;/code&gt;&lt;p&gt;然后这样调用&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(sq (+ 2 3))&lt;/code&gt;&lt;p&gt;它是规约为&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(* 5 5)&lt;/code&gt;&lt;p&gt;呢，还是&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(* (+ 2 3) (+ 2 3))&lt;/code&gt;&lt;p&gt;？前者被称为&lt;b&gt;及早&lt;/b&gt;（eager）调用，后者则被称为&lt;b&gt;惰性&lt;/b&gt;（lazy）调用。【注释】当然，我们不想回到使用替换模型定义解释器，但将替换视为设计原则总是有用的。&lt;/p&gt;&lt;blockquote&gt;有些人将前者称为&lt;b&gt;严格&lt;/b&gt;的（strict）。更加晦涩难解的术语将前者称为&lt;b&gt;调用次序求值&lt;/b&gt;（applicative-order evaluation），后者称为&lt;b&gt;正常次序求值&lt;/b&gt;（normal-order evaluation）。还有，前者称为&lt;b&gt;传值调用&lt;/b&gt;（call-by-value），后者称为&lt;b&gt;传名调用&lt;/b&gt;（call-by-name）或&lt;b&gt;传需求调用&lt;/b&gt;（call-by-need）。最后这两个术语——传名和传需求——实际技术上有区别，我们将在后文讨论。关于名字的介绍就到这里。&lt;/blockquote&gt;&lt;h2&gt;17.1.1 惰性调用示例&lt;/h2&gt;&lt;p&gt;惰性这一选择有着辉煌的历史（例如，纯正的λ演算就用它），但是回归编程实践，考虑对于某些运算符，在函数调用时不对参数求值而等到需要用到参数值时才求值会出现什么问题。例如，考虑定义&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define ones (cons 1 ones))&lt;/code&gt;&lt;p&gt;在标准Racket中，这显然是有问题的：（左侧的）&lt;code class=&quot;inline&quot;&gt;ones&lt;/code&gt;还没有完成定义，我们就（在右侧）尝试对它求值，所以这会导致错误。但是，如果我们直到真正需要时才对其求值，那么这个定义就成立了。因为每次&lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt;操作都会获得另一个&lt;code class=&quot;inline&quot;&gt;ones&lt;/code&gt;，我们得到了一个无穷链表。&lt;/p&gt;&lt;p&gt;我们略过了很多需要解释的地方。&lt;code class=&quot;inline&quot;&gt;cons&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt;位置求值得到的是&lt;code class=&quot;inline&quot;&gt;ones&lt;/code&gt;的&lt;b&gt;副本&lt;/b&gt;呢，还是原表达式本身呢？换句话说，我们是简单地创建了无限展开的链表，还是创建了实际上&lt;b&gt;循环的&lt;/b&gt;链表？&lt;/p&gt;&lt;p&gt;这很大程度上取决于我们的语言是否带有赋值。如果有赋值，那么也许我们可以修改结果链表中的每个单元格，这意味着我们可以观察上述两个实现之间的区别：在展开版本中，修改一个&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;不会影响另一个，而在循环版本中，更改一个&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;会影响所有其他。因此，在有赋值的语言中，我们可能会倾向于惰性展开，而不是循环数据。&lt;/p&gt;&lt;p&gt;请记住这里的讨论。我们暂时还无法解决它；不妨再考察一下惰性求值，然后回到这个问题。&lt;/p&gt;&lt;h2&gt;17.1.2 什么是值？&lt;/h2&gt;&lt;p&gt;回到之前的核心高阶函数解释器，我们记得有两种类型的值：数和闭包。要支持惰性求值，我们要问，在函数调用中怎么处理。究竟传入什么？&lt;/p&gt;&lt;p&gt;这似乎很明显：在惰性调用语义中，我们需要传入&lt;b&gt;表达式&lt;/b&gt;。但细想就有问题了。表达式中包含标识符名称，【注释】而我们不希望它们被意外地绑定。&lt;/p&gt;&lt;blockquote&gt;我们马上会发现，这里它们真的是&lt;b&gt;标识符&lt;/b&gt;而不是&lt;b&gt;变量&lt;/b&gt;，。&lt;/blockquote&gt;&lt;p&gt;例如，假设我们有&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (f x)
  (lambda (y)
    (+ x y)))&lt;/code&gt;&lt;p&gt;这样调用它：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;((f 3) (+ x 4))&lt;/code&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;这应该返回什么？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;显然，应该得到错误，报告x没有被绑定。&lt;/p&gt;&lt;p&gt;现在来逐步分析。第一步调用创建闭包，其中&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;绑定到&lt;code class=&quot;inline&quot;&gt;3&lt;/code&gt;。如果接下来将&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;绑定到&lt;code class=&quot;inline&quot;&gt;(+ x 4)&lt;/code&gt;，于是得到表达式&lt;code class=&quot;inline&quot;&gt;(+ x (+ x 4))&lt;/code&gt;，而其环境中&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;是绑定的。因此我们得到答案&lt;code class=&quot;inline&quot;&gt;10&lt;/code&gt;，而不是错误。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;我们这里有做什么微妙的假设吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;是的，我们有：我们假定&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;调用时其会对各参数进行求值并都返回数。也许&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;也可以是惰性的；我们稍后研究这个问题。不管怎么说，重点不变：如果我们不小心的话，这个错误的表达会得到某种合法的答案，而不是错误。&lt;/p&gt;&lt;p&gt;如果您认为这问题只关于错误的程序，因此可以专门处理（例如，先扫描程序源寻找自由标识符），下面是同一个&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的另一个的用法：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(let ([x 5])
  ((f 3) x))&lt;/code&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;这应该返回什么？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;正常来说这应该求得&lt;code class=&quot;inline&quot;&gt;(+ 3 5)&lt;/code&gt;的结果（即&lt;code class=&quot;inline&quot;&gt;8&lt;/code&gt;）。但是，如果我们在算术表达式中替换&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;，我们会得到&lt;code class=&quot;inline&quot;&gt;(+ 3 3)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在这个例子中。后面这个例子包含了解决方案的关键，只有当我们用到环境时，问题才会出现；反之如果我们使用替换，一遇到&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;就替换函数调用中的&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;，结果就符合期望。事实上，请注意，这个观点对前一个例子也适用：如果我们使用替换，那么&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的出现就导致错误。简而言之，我们必须确保基于环境的实现和基于替换的实现行为一致。听起来熟悉不！&lt;/p&gt;&lt;p&gt;换种说法，解决方案是将参数表达式&lt;b&gt;与其环境捆绑在一起&lt;/b&gt;：即创建闭包。此闭包没有参数，所以它实际上是&lt;b&gt;thunk（译注，无参数的lambda）&lt;/b&gt;。【注释】我们可以使用已有的函数来表示这里的thunk，但是直觉告诉我们，更好的做法是为逻辑上不同的目的使用不同的数据表示：&lt;code class=&quot;inline&quot;&gt;closV&lt;/code&gt;表示用户创建的闭包，用另一种东西表示内部创建的闭包。事实上，正如我们将看到的那样，将它们分开是明智的做法，因为有一个地方我们需要能将它们区分开来。&lt;/p&gt;&lt;blockquote&gt;事实上，这表明函数有两个用途：用值替换名称，推迟替换。&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;只有前一个功能而没有后一个；thunk只有后一个功能而没有前一个。前文已经明确，前者本身是很有价值的；本节表明后者也是如此。&lt;/blockquote&gt;&lt;p&gt;总结来说，现在我们新的值的集合是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define-type Value
  [numV (n : number)]
  [closV (arg : symbol) (body : ExprC) (env : Env)]
  [suspendV (body : ExprC) (env : Env)])&lt;/code&gt;&lt;p&gt;前两个变体完全不变；第三个是新的，正如我们所讨论的，它实际上是一个无参数的子程序，正如其类型所表明的那样。&lt;/p&gt;&lt;h2&gt;17.1.3 什么导致求值？&lt;/h2&gt;&lt;p&gt;回头来讨论算术表达式。对&lt;code class=&quot;inline&quot;&gt;(+ 1 2)&lt;/code&gt;求值时，惰性调用的解释器可以返回好几种东西，包括&lt;code class=&quot;inline&quot;&gt;(suspendV (+ 1 2) mt-env)&lt;/code&gt;。【注释】这样，挂起的计算可以级联起来，在极限情况下，任何程序都会立即返回“答案”：表示挂起（suspension）计算的thunk。&lt;/p&gt;&lt;blockquote&gt;这里放上&lt;code class=&quot;inline&quot;&gt;mt-env&lt;/code&gt;（译注，空白环境）是合理的，因为就算&lt;code class=&quot;inline&quot;&gt;(+ 1 2)&lt;/code&gt;表达式存在于非空的环境中，它其中也不包含自有标识符，因此不需要任何环境的绑定。&lt;/blockquote&gt;&lt;p&gt;显然，必须&lt;b&gt;有什么东西&lt;/b&gt;用来强制解除挂起。（当然，解除挂起的意思是，在存储下来的环境中对主体求值。）这种解除表达式挂起状态的位置称为&lt;b&gt;严格点（strictness point）&lt;/b&gt;。最明显的严格点是交互式环境的打印，因为如果用户使用交互环境显然是希望看到答案。我们用&lt;code class=&quot;inline&quot;&gt;strict&lt;/code&gt;子程序表示解除挂起：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (strict [v : Value]) : Value
  (type-case Value v
    [numV (n) v]
    [closV (a b e) v]
    [suspendV (b e) (strict (interp b e))]))&lt;/code&gt;&lt;p&gt;这里返回的&lt;code class=&quot;inline&quot;&gt;Value&lt;/code&gt;保证不是&lt;code class=&quot;inline&quot;&gt;suspendV&lt;/code&gt;。我们可以假设打印程序会对被求值的表达式调用&lt;code class=&quot;inline&quot;&gt;strict&lt;/code&gt;，以获得要打印的值。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;如果使用闭包来表示挂起的计算，后果是啥？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;上面&lt;code class=&quot;inline&quot;&gt;strict&lt;/code&gt;的定义依赖于区分延迟计算——是内部构建的闭包——与用户定义闭包的能力。如果我们将两者混为一谈，那么这里就不得不去猜测如何处理零参数闭包。如果没有进一步处理它们，我们可能会错误地得到报错（例如，&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;可能会得到thunk而不是其中的数值）。如果进一步处理，我们可能会意外地过早调用用户定义的thunk。总之，对于thunk我们需要一个标志，告诉我们它们是内部的还是用户定义的。为了清晰起见，我们的解释器使用独立的变体。&lt;/p&gt;&lt;p&gt;接下来讨论&lt;code class=&quot;inline&quot;&gt;strict&lt;/code&gt;和解释器之间的互动。不幸的是，按我们原来的定义，这将导致无限循环。解释加法将创建创建该计算的挂起，&lt;code class=&quot;inline&quot;&gt;strict&lt;/code&gt;会试图解除这个挂起，解除的方式是让解释器去解释加法，而这又……显然，我们不能简单的让每个表达式都挂起其计算；相反，我们只挂起函数调用。这不会使语言变得荒谬，又足以让我们拥有惰性求值的强大力量。&lt;/p&gt;&lt;h2&gt;17.1.4 解释器&lt;/h2&gt;&lt;p&gt;照例，我们将分步定义解释器。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;lazy-interp&amp;gt; ::=

    (define (interp [expr : ExprC] [env : Env]) : Value
      (type-case ExprC expr
        &amp;lt;lazy-numC-case&amp;gt;
        &amp;lt;lazy-idC-case&amp;gt;
        &amp;lt;lazy-plusC/multC-case&amp;gt;
        &amp;lt;lazy-appC-case&amp;gt;
        &amp;lt;lazy-lamC-case&amp;gt;))&lt;/code&gt;&lt;p&gt;数很容易：它们已经是值了，所以没必要挂起它们：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;lazy-numC-case&amp;gt; ::=

    [numC (n) (numV n)]&lt;/code&gt;&lt;p&gt;闭包同样保持不变：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;lazy-lamC-case&amp;gt; ::=

    [lamC (a b) (closV a b env)]&lt;/code&gt;&lt;p&gt;标识符应该返回它们所绑定的内容：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;lazy-idC-case&amp;gt; ::=

    [idC (n) (lookup n env)]&lt;/code&gt;&lt;p&gt;算术表达式的参数通常被定义为严格点，不然的话我们会不得不在其他地方自行实现算术运算：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;lazy-plusC/multC-case&amp;gt; ::=

    [plusC (l r) (num+ (strict (interp l env))
                       (strict (interp r env)))]
    [multC (l r) (num* (strict (interp l env))
                       (strict (interp r env)))]&lt;/code&gt;&lt;p&gt;最后我们要处理函数调用。在这里，我们不再对参数求值，而是将其挂起。然而，函数位置必须是严格点，否则我们不知道要调用什么函数，也就不知道如何继续计算：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;lazy-appC-case&amp;gt; ::=

    [appC (f a) (local ([define f-value (strict (interp f env))])
                  (interp (closV-body f-value)
                            (extend-env (bind (closV-arg f-value)
                                              (suspendV a env))
                                        (closV-env f-value))))]&lt;/code&gt;&lt;p&gt;这就行了！添加一种新的结果类型、插入一些&lt;code class=&quot;inline&quot;&gt;strict&lt;/code&gt;、并在函数调用参数位置用&lt;code class=&quot;inline&quot;&gt;suspendV&lt;/code&gt;替换&lt;code class=&quot;inline&quot;&gt;interp&lt;/code&gt;，我们就将及早调用解释器转换成了惰性调用了。然而，这个小小的变化对我们编写的程序有着巨大的影响！要更全面地了解这种影响，请学习Haskell或Racket中的&lt;code class=&quot;inline&quot;&gt;#lang lazy&lt;/code&gt;语言。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;如果我们把标识符子句替换为&lt;code class=&quot;inline&quot;&gt;(strict (lookup n env))&lt;/code&gt;（即对查找标识符的结果调用&lt;code class=&quot;inline&quot;&gt;strict&lt;/code&gt;），会对语言产生什么影响？请考虑更丰富的语言的情况，比如包含数据结构的情况。&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;编写一些程序，它们在惰性求值下会给出和及早求值不同的结果（在两种情况下，同样的程序给出不同的结果）。请给出有意义的差异，一个返回&lt;code class=&quot;inline&quot;&gt;suspendV&lt;/code&gt;而另一个返回实际计算结果这种不算。比如说，一个会终止而另一个不会，或者一个会产生错误而另一个不会？&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;调整两个解释器，让它们记录求得答案的步数。对于在两种求值策略下产生相同答案的程序，一个策略是否总是比另一个需要更多步骤？&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;17.1.5 惰性和赋值&lt;/h2&gt;&lt;p&gt;惰性求值的优点之一是它会延迟执行。通常这是好事：它使我们能够构建无限的数据结构，还能避免不必要的计算。不幸的是，它也改变了计算发生的时间，尤其是表达式求值的相对时间，这将取决于何时遇到严格点。结果是，程序员基本无法预测计算的顺序。当表达式执行赋值操作时，这显然是个问题，因为这种情形下预测程序计算结果非常困难（相对及早求值来说）。&lt;/p&gt;&lt;p&gt;这导致了，所有惰性语言的核心中都不支持赋值。在Haskell中，赋值和其他状态操作都是通过诸如&lt;b&gt;monad（单子）&lt;/b&gt;和&lt;b&gt;arrow（箭头）&lt;/b&gt;等多种机制引入的，这些机制实质上赋予我们（严格）顺序化代码的能力；这种顺序性对于能够预测执行顺序以及操作结果至关重要。如果程序结构良好，这些依赖关系的数量应该很小；此外，Haskell类型系统试图在类型本身中反映这些操作，因此程序员可以更轻松地推理其效果。&lt;/p&gt;&lt;h2&gt;17.1.6 缓存计算结果&lt;/h2&gt;&lt;p&gt;从已经得出的惰性计算必须不包含赋值这个结论，我们可以观察到一个喜人的结果（能不能称其为副作用呢？）：给定固定的环境，同一表达式总会产生相同的答案。其结果是，当表达式第一次被严格求值时，运行时系统可以缓存其值，并在随后计算它时返回这个缓存值。当然，这种缓存（这是&lt;b&gt;记忆化&lt;/b&gt;(memoization)的一种形式）只有当表达式每次返回相同的值时才成立，这正是我们所假设的。实际上，编译器和运行时系统可以积极地在程序的不同部分中使用相同的表达式，并且如果其环境的相关部分相同，则合并求值。每当被需要时都对挂起的计算进行求值的策略称为&lt;b&gt;传名调用&lt;/b&gt;；将结果缓存起来，则称为&lt;b&gt;传需求调用&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;17.2 响应式调用&lt;/h2&gt;&lt;p&gt;来考虑这个表达式&lt;code class=&quot;inline&quot;&gt;(current-seconds)&lt;/code&gt;。求值时，它返回一个表示当前时间的数。例如，&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (current-seconds)
1353030630&lt;/code&gt;&lt;p&gt;但即使我们盯着执行过程，当看见这个数时它就已经过时了！它表示函数调用发生的时间，而不会一直保持为当前时间。&lt;/p&gt;&lt;h2&gt;17.2.1 动机样例：计时器&lt;/h2&gt;&lt;p&gt;假设我们要实现一个计时器，记录经过的时间。理想情况下，我们会这样写：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(let ([start (current-seconds)])
  (- (current-seconds)
     start))&lt;/code&gt;&lt;p&gt;在JavaScript中就是：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;d = new Date();
start = d.getTime();
current = d.getTime();
elapsed = current - start;&lt;/code&gt;&lt;p&gt;在大多数机器上，此Racket表达式，或JavaScript中&lt;code class=&quot;inline&quot;&gt;elapsed&lt;/code&gt;的值将被求得为&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;，或着某个非常小的数字。这是因为这些程序代表了经过时间的&lt;b&gt;一次&lt;/b&gt;度量：即第二次调用获取当前时间子程序时的时间。这样我们拿到一个瞬间的时间片，而不是实际的计时器。&lt;/p&gt;&lt;p&gt;在大多数语言中，要构建真正的计时器，我们必须创建某种计时器对象的实例，然后设置回调。每当时钟滴答时，计时器对象——代表操作系统——都会调用回调函数。然后回调负责更新系统其余部分的值，我们期望它能全局一致地完成这个任务。但是，回调函数无法通过返回值来实现这点，因为它会返回到操作系统，而操作系统无法感知到、也不关心我们的应用程序；因此，回调只能通过赋值来执行其行为。例如在JavaScript中：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;var timerID = null;
var elapsedTime = 0;

function doEverySecond() {
  elapsedTime += 1;
  document.getElementById(&#39;curTime&#39;).innerHTML = elapsedTime; }
function startTimer() {
  timerId = setInterval(doEverySecond, 1000); }&lt;/code&gt;&lt;p&gt;假设这里的HTML页面id为&lt;code class=&quot;inline&quot;&gt;curTime&lt;/code&gt;，并且&lt;code class=&quot;inline&quot;&gt;onload&lt;/code&gt;或其他回调会调用&lt;code class=&quot;inline&quot;&gt;startTimer&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;要避免这种意大利面风格的代码，一种替代方案是应用程序反复向操作系统轮询当前时间。然而：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;过于频繁地调用会浪费资源，而调用过于不频繁则会导致错误的值。不过，要以恰当的频率进行调用，我们需要先有一个计时器信号！&lt;/li&gt;&lt;li&gt;尽管可以为诸如定时器之类的常规事件创建这样的轮询循环，但对于诸如用户输入等不可预知的行为（其频率通常不能被预测）的来说，这是不可能的。&lt;/li&gt;&lt;li&gt;除此之外，编写这样的循环会污染程序的结构，迫使开发人员承担额外的负担。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;基于回调的方案体现了&lt;b&gt;控制反转&lt;/b&gt;（inversion of control）的思想。现在，操作系统负责调用（从而进入）应用程序，而不是应用程序调用操作系统（所提供的功能）。本应深度嵌套于显示表达式的内部的响应行为现在被置于顶层，其他计算将由其值驱动。这么做的根本原因在于，对外部世界的控制权不再程序手中，因此应该由外部刺激决定程序何时运行以及如何运行，而非内部的程序表达式。&lt;/p&gt;&lt;h2&gt;17.2.2 回调的类型是四字母单词&lt;/h2&gt;&lt;p&gt;这种模式的特征（可以这么说）体现在类型中。由于操作系统对程序的值不可知，所以回调通常没有返回类型，或者只返回通用的状态指示值，而不是特定于应用程序的值。因此，在静态类型语言中，它们的类型通常是&lt;b&gt;四个字母的单词&lt;/b&gt;。 例如，下面是Java中某GUI库的片段：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;interface ChangeListener extends EventListener {
  void stateChanged(ChangeEvent e) { ... } }

interface ActionListener extends EventListener {
  void actionPerformed(ActionEvent e) { ... } }

interface MouseListener extends EventListener {
  void mouseClicked(MouseEvent e) { ... }
  void mouseEntered(MouseEvent e) { ... } }&lt;/code&gt;&lt;p&gt;OCaml中是这样：&lt;/p&gt;&lt;code lang=&quot;ocaml&quot;&gt;mainLoop : unit -&amp;gt; unit
closeTk : unit -&amp;gt; unit

destroy : &#39;a Widget.widget -&amp;gt; unit
update : unit -&amp;gt; unit

pack : ... -&amp;gt; &#39;d Widget.widget list -&amp;gt; unit
grid : ... -&amp;gt; &#39;b Widget.widget list -&amp;gt; unit&lt;/code&gt;&lt;p&gt;在Haskell中，这四个字母中包含一个额外的空格：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;select :: Selecting w =&amp;gt; Event w (IO ())
mouse :: Reactive w =&amp;gt; Event w (EventMouse -&amp;gt; IO ())
keyboard :: Reactive w =&amp;gt; Event w (EventKey -&amp;gt; IO ())
resize :: Reactive w =&amp;gt; Event w (IO ())
focus :: Reactive w =&amp;gt; Event w (Bool -&amp;gt; IO ())
activate :: Reactive w =&amp;gt; Event w (Bool -&amp;gt; IO ())&lt;/code&gt;&lt;p&gt;诸如此类。在所有这些情况下，类似“void”类型的存在清楚地表明这些函数不会返回任何有意义的值，所以它们唯一的目的必须是修改贮存或者具有其他副作用。这也意味着复杂的组合手段（例如表达式的嵌套）是不可能的：void类型语句唯一的组合操作是顺序执行。因此这些类型表明我们将被迫放弃编写嵌套表达式。&lt;/p&gt;&lt;p&gt;当然，通过我们之前对Web编程的讨论，读者应该已经熟悉这个问题。无状态的服务器和单线程的客户端程序都会出现这个问题。服务器上，我们至少还能使用continuation解决这个问题。但是，不是所有的语言都支持continuation，且实现continuation也会很繁琐。此外，设置合适的continuation作为回调来传递可能会非常棘手。因此，我们将探索另一种解决方案。&lt;/p&gt;&lt;h2&gt;17.2.3 替代方案：响应式语言&lt;/h2&gt;&lt;p&gt;考虑DrRacket中的FrTime（发音为“Father Time”）语言。【注释】如果我们在交互窗口中运行下面的表达式，我们仍然得到0或者非常小的正数：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(let ([start (current-seconds)])
  (- (current-seconds)
     start))&lt;/code&gt;&lt;blockquote&gt;在DrRacket v5.3中，必须从“语言/Language”菜单中选择该语言；只写&lt;code class=&quot;inline&quot;&gt;#lang frtime&lt;/code&gt;不会提供想要的交互窗口行为。&lt;/blockquote&gt;&lt;p&gt;事实上，我们可以尝试其他几种表达式，看上去FrTime似乎与传统的Racket完全一样。&lt;/p&gt;&lt;p&gt;但是，它还绑定了额外一些标识符。例如，有一个值绑定到&lt;code class=&quot;inline&quot;&gt;seconds&lt;/code&gt;。如果我们将其输入交互窗口的提示符，结果非常有意思！首先我们看到&lt;code class=&quot;inline&quot;&gt;1353030630&lt;/code&gt;，然后一秒后&lt;code class=&quot;inline&quot;&gt;1353030631&lt;/code&gt;，再一秒&lt;code class=&quot;inline&quot;&gt;1353030632&lt;/code&gt;，诸如此类。这种值被称为&lt;b&gt;行为&lt;/b&gt;（behavior）：随时间变化的值。但是我们没有编写任何回调或其他代码将其值保持为当前时间。&lt;/p&gt;&lt;p&gt;行为可以用于计算。 例如可以这么写&lt;code class=&quot;inline&quot;&gt;(- seconds seconds)&lt;/code&gt;，并且它总是计算为&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;。请在交互提示符中尝试更多表达式：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(add1 seconds)
(modulo seconds 10)
(build-list (modulo seconds 10) identity)
(build-list (add1 (modulo seconds 10)) identity)&lt;/code&gt;&lt;p&gt;正如你所看到的，行为是“粘性的”：如果任何子表达式是行为，包含它的表达式也是。&lt;/p&gt;&lt;p&gt;基于这里的求值模型，每当&lt;code class=&quot;inline&quot;&gt;seconds&lt;/code&gt;更新，整个应用程序重新求值：因此，即使我们写了看似简单的表达式，不包含任何明确的循环控制，程序仍然会“循环”。最早我们探索的调用语义，其中参数被求值一次，然后惰性求值那里的调用语义中，参数可能被求值零次，现在这个调用语义会根据需要对参数以及与它们对应的整个函数进行多次求值。因此，表达式“内部”的响应式值不再需要被带到“外部”；相反，它们可以内嵌在表达式中，为程序员提供更自然的表达方式。这种求值方式被称为&lt;b&gt;数据流&lt;/b&gt;（dataflow）或&lt;b&gt;函数响应式&lt;/b&gt;（functional reactive）编程。&lt;/p&gt;&lt;blockquote&gt;历史上，&lt;b&gt;数据流&lt;/b&gt;一般指的是具有一阶函数的语言，而&lt;b&gt;函数响应式&lt;/b&gt;语言还支持高阶函数。&lt;/blockquote&gt;&lt;p&gt;FrTime实现了我们所说的&lt;b&gt;透明响应式&lt;/b&gt;，即程序员可以在程序求值的任意位置插入响应行为，而无需对其上下文进行任何语法修改。这么做的优点是，现有程序中很易于加入响应式，但这也使求值模型更加复杂，成本预估更为困难。在其他语言中，程序员需要通过适当的原语明确地引入行为，不那么方便，但可预测性更强。FrTime的姊妹语言Flapjax是JavaScript的扩展，同时支持这两种模式。&lt;/p&gt;&lt;blockquote&gt;参见&lt;a href=&quot;http://www.flapjax-lang.org/&quot;&gt;Flapjax网站&lt;/a&gt;。&lt;/blockquote&gt;&lt;h2&gt;17.2.4 实现透明响应式&lt;/h2&gt;&lt;p&gt;要使现有语言实现透明响应式，我们必须（自然地）改变函数调用的语义。分两步来做。首先将响应式函数调用改写成更复杂的形式，然后我们将展示这种更复杂的形式支持响应式更新。&lt;/p&gt;&lt;h2&gt;17.2.4.1 数据流图的构建&lt;/h2&gt;&lt;p&gt;很容易用语法糖来解释将函数调用变成响应性的本质。假设我们已经定义了新的构造器&lt;code class=&quot;inline&quot;&gt;behavior&lt;/code&gt;。该构造器的接收一个表示每当参数更新时所需要进行的计算的thunk以及所有表达式所依赖的值为参数。那么&lt;code class=&quot;inline&quot;&gt;(f x y)&lt;/code&gt;这样的表达式就展开为&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(if (or (behavior? x) (behavior? y))
    (behavior (λ () (f (current-value x) (current-value y))) x y)
    (f x y))&lt;/code&gt;&lt;p&gt;其中我们假设，如果输入是常数而非行为，那么&lt;code class=&quot;inline&quot;&gt;current-value&lt;/code&gt;的行为就是恒等函数。&lt;/p&gt;&lt;p&gt;来看一下使用上述定义的两个例子。考虑两个参数都不是行为的简单情况，例如&lt;code class=&quot;inline&quot;&gt;(+ 3 4)&lt;/code&gt;。 去语法糖得到&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(if (or (behavior? 3) (behavior? 4))
    (behavior (λ () (+ (current-value 3) (current-value 4))) 3 4)
    (+ 3 4))&lt;/code&gt;&lt;p&gt;由于&lt;code class=&quot;inline&quot;&gt;3&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;4&lt;/code&gt;都是数而非行为，这就规约为&lt;code class=&quot;inline&quot;&gt;(+ 3 4)&lt;/code&gt;，正是我们想要的。这反映了一个重要的原则：当没有行为出现时，程序的行为完全等同于与非响应式语言版本。&lt;/p&gt;&lt;p&gt;如果计算&lt;code class=&quot;inline&quot;&gt;(+ 1 seconds)&lt;/code&gt;，展开为&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(if (or (behavior? 1) (behavior? seconds))
    (behavior (λ () (+ (current-value 1) (current-value seconds))) 1 seconds)
    (+ 1 seconds))&lt;/code&gt;&lt;p&gt;由于&lt;code class=&quot;inline&quot;&gt;seconds&lt;/code&gt;是行为，这规约为&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(behavior (λ () (+ (current-value 1) (current-value seconds))) 1 seconds)&lt;/code&gt;&lt;p&gt;如果其他表达式依赖于此，现在它们都会看到其参数也是行为，于是该属性如我们之前所论证的那样是“粘性的”。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;上述去语法糖是否依赖于及早求值？如果有的话，是以什么方式？&lt;br&gt;&lt;/blockquote&gt;&lt;h2&gt;17.2.4.2 数据流图的更新&lt;/h2&gt;&lt;p&gt;当然，仅仅构建行为值是不够的。这里关键的附加信息位于&lt;code class=&quot;inline&quot;&gt;behavior&lt;/code&gt;的参数中。语言会过滤掉那些本身是行为的参数（例如前述的&lt;code class=&quot;inline&quot;&gt;seconds&lt;/code&gt;），并将新行为注册为依赖于现有行为的行为。这个注册过程创建了行为表达式的依赖关系图，称为&lt;b&gt;数据流图&lt;/b&gt;(dataflow graph)（因为它反映了数据流动所需的路径）。&lt;/p&gt;&lt;p&gt;如果程序求值得到的不是行为，那么就是是答案，并且不会创建图表。但是，如果存在行为依赖，那么求值不会产生传统的答案，而会产生行为值，并且会记录其依赖。（实践中，有必要记录下哪些内建行为实际地被用到，以避免对程序中没有引用到的内建行为进行求值）。总之，&lt;b&gt;程序执行会生成数据流图&lt;/b&gt;。因此，我们需要的不是新的、专门的语言求值器；而是要将图构建语义嵌入到传统求值器中。&lt;/p&gt;&lt;p&gt;现在可以运行数据流传播算法了。每当某个内建行为发生变化时，该算法会调用其存储的thunk，获取新值，存储之，然后发信号给依赖于它的所有行为。例如，如果&lt;code class=&quot;inline&quot;&gt;seconds&lt;/code&gt;更新，它会通知对应表达式&lt;code class=&quot;inline&quot;&gt;(+ 1 seconds)&lt;/code&gt;的行为。后者于是对其thunk求值，即&lt;code class=&quot;inline&quot;&gt;(λ () (+ (current-value 1) (current-value seconds)))&lt;/code&gt;。这会对&lt;code class=&quot;inline&quot;&gt;seconds&lt;/code&gt;的最新值加&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，将其作为该行为的的新值——正如我们所期望的那样。&lt;/p&gt;&lt;h2&gt;17.2.4.3 求值顺序&lt;/h2&gt;&lt;p&gt;上面对图更新的讨论过于简单了。考虑以下程序：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(&amp;gt; (add1 seconds)
   seconds)&lt;/code&gt;&lt;p&gt;这个程序里有一个内建行为，&lt;code class=&quot;inline&quot;&gt;seconds&lt;/code&gt;，构造了两个新行为：分别是&lt;code class=&quot;inline&quot;&gt;(add1 seconds)&lt;/code&gt;和整个表达式。&lt;/p&gt;&lt;p&gt;我们期望这个表达永远计算为真。但是，当&lt;code class=&quot;inline&quot;&gt;seconds&lt;/code&gt;更新时，取决于处理更新的顺序，可能会在更新&lt;code class=&quot;inline&quot;&gt;(add1 seconds)&lt;/code&gt;之前更新整个表达式。假设&lt;code class=&quot;inline&quot;&gt;seconds&lt;/code&gt;的旧值是&lt;code class=&quot;inline&quot;&gt;100&lt;/code&gt;，所以新值是&lt;code class=&quot;inline&quot;&gt;101&lt;/code&gt;。但是，&lt;code class=&quot;inline&quot;&gt;(add1 seconds)&lt;/code&gt;的节点仍然存储了其旧值（因为它尚未更新），所以它的值还是&lt;code class=&quot;inline&quot;&gt;(add1 100)&lt;/code&gt;即&lt;code class=&quot;inline&quot;&gt;101&lt;/code&gt;。这意味着&lt;code class=&quot;inline&quot;&gt;&amp;gt;&lt;/code&gt;会比较&lt;code class=&quot;inline&quot;&gt;101&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;（译注，此处应为&lt;code class=&quot;inline&quot;&gt;101&lt;/code&gt;），得到假，于是这个表达式返回了其静态描述不可能产生的值。这种情况被称为&lt;b&gt;毛刺&lt;/b&gt;（glitch）。&lt;/p&gt;&lt;p&gt;避免上面例子所描述的毛刺的方案很简单（而且可以证明这么做足够了）。就是对节点&lt;b&gt;拓扑排序&lt;/b&gt;。每个节点只在它所依赖的节点更新后才被处理，因此不存在查看过时或不一致的值的危险。&lt;/p&gt;&lt;p&gt;在图中出现循环时问题变得难了。在这种情况下，我们需要特殊的递归算子来为循环行为提供初始值。这样做就打破了循环依赖关系，将求值简化为已定义的过程。&lt;/p&gt;&lt;p&gt;关于数据流语言的求值还有很多可以讨论的内容，例如条件的处理、还有离散和流式（stream-like）行为对偶的概念。 我希望你会去阅读响应式语言的文献，以便更多地了解这些主题。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;之前我们提到过一个Haskell库。不过，公平地说，我们展示的响应式解决方案是用Haskell来阐述的，因为惰性求值更容易支持这种求值形式。&lt;br&gt;用惰性求值实现响应式。&lt;/blockquote&gt;&lt;h2&gt;17.3 回溯调用&lt;/h2&gt;&lt;p&gt;同一个调用可能发生多次的另一个原因是，它是&lt;b&gt;搜索树&lt;/b&gt;的一部分。这类语言的调用语义试图去满足搜索；如果成功，则返回成功的信息，但如果失败，则会重试调用以期成功。当然，这假定程序按照所写的逻辑中，尝试给定的那些选择最终会搜索成功。因此，具有回溯调用语义的语言的核心操作是&lt;b&gt;逻辑析取&lt;/b&gt;（disjunction，或）。出于各种原因，此类语言还支持&lt;b&gt;逻辑合取&lt;/b&gt;（conjunction，与），其中一个原因是，实现逻辑非会有问题，所以通常的布尔代数规则并不适用。&lt;/p&gt;&lt;h2&gt;17.3.1 通过搜索获得满足&lt;/h2&gt;&lt;p&gt;使用二值目标描述回溯搜索问题比较简单。即使只是寻找满足命题公式的布尔变量的值，从性能的角度来也是非常有挑战性的，并且这在各种现实世界问题中非常重要。【注释1】然而，我们只讨论这个问题的简化版本，只使用布尔常量而非变量，这样我们只需要确定公式的真实性就可以了。不那么有趣，但它会有助于我们理解一般的、实际上有趣的情况。【注释2】&lt;/p&gt;&lt;blockquote&gt;参见“SAT求解器”的众多用途。&lt;br&gt;&lt;br&gt;对于这种特殊情况，制定真值表就可以了，但对一般情况这不起作用。&lt;/blockquote&gt;&lt;p&gt;假设我们的输入是包含析取、合取和表示真假的常量的公式。目标是判定公式本身求值为真还是假。我们希望尽量减少计算量，当发现答案——无论哪一个——我们都希望尽快将其返回到依赖于它的上下文。例如，如果在计算某个合取过程中发现某个项为假，我们希望整个（合取）项立即得假——条件表达式求值中的&lt;b&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC&quot;&gt;短路求值&lt;/a&gt;&lt;/b&gt;概念。而且，我们也希望这种做法能泛化到调用堆栈中：如果子表达式求得真或假，并且这可以决定包含表达式的值了，那么它也应该快速地“通知所在堆栈”。&lt;/p&gt;&lt;p&gt;因此，一般来说，每个计算都应该再带两个容器参数：一个用来报告当前项为真（如果发现是真），另一个报告当前项为假（如果发现是假）。为了避免未决函数调用等问题的复杂性，我们还将限定两个参数的值都为&lt;b&gt;continuation&lt;/b&gt;，这样该值能尽快地回到正确的上下文中，而不用对中间那些不会影响到结果的部分进行求值。&lt;/p&gt;&lt;p&gt;这些continuation目前没有太多有意思的值可以传递：给它的唯一参数也是我们能获取到的唯一信息（一比特的信息，代表真或假）。因为默认情况下continuation需要有一参数，我们将提供一个符号表示知道的内容。&lt;/p&gt;&lt;p&gt;最容易的值是真和假本身。之前说过，所有表达式都会读入两个continuation，称为&lt;b&gt;成功&lt;/b&gt;和&lt;b&gt;失败&lt;/b&gt;continuation，如果式子具有明确的值，则调用其中一个。因此，真值调用成功continuation，而假值调用失败的那个：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (truth t1 t2) (t1 &#39;yes))
(define (falsity t1 t2) (t2 &#39;no))&lt;/code&gt;&lt;p&gt;现在我们来讨论析取。为了简单起见，我们将讨论其双目版本。和所有计算一样，两个回溯搜索的析取必须接受成功和失败continuation。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;try-or-bt&amp;gt; ::=

    (define (try-or t1 t2)
      (lambda (success failure)
        &amp;lt;try-or-bt-body&amp;gt;))&lt;/code&gt;&lt;p&gt;从概念上讲，最简单的方式是创建两个局部continuation，称之为&lt;code class=&quot;inline&quot;&gt;pass&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;fail&lt;/code&gt;，并传递给&lt;code class=&quot;inline&quot;&gt;t1&lt;/code&gt;求值。如果t1（或者递归地，它的某个子计算）成功，控制将返回到创建&lt;code class=&quot;inline&quot;&gt;pass&lt;/code&gt;的上下文；如果失败，则返回到&lt;code class=&quot;inline&quot;&gt;fail&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果控制返回到&lt;code class=&quot;inline&quot;&gt;pass&lt;/code&gt;，我们就知道第一个子表达式成功了。但是因为对于析取，这就够了，所以我们现在可以将控制交给continuation &lt;code class=&quot;inline&quot;&gt;success&lt;/code&gt;。因此任何对&lt;code class=&quot;inline&quot;&gt;pass&lt;/code&gt;的调用都应该立即触发&lt;code class=&quot;inline&quot;&gt;success&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;反之，假设&lt;code class=&quot;inline&quot;&gt;t1&lt;/code&gt;失败。那我们应该试试&lt;code class=&quot;inline&quot;&gt;t2&lt;/code&gt;。因此&lt;code class=&quot;inline&quot;&gt;fail&lt;/code&gt;应被定义在序列操作中，接下来要尝试&lt;code class=&quot;inline&quot;&gt;t2&lt;/code&gt;；如果&lt;code class=&quot;inline&quot;&gt;t1&lt;/code&gt;成功，控制将不会以这种方式返回。接下来尝试&lt;code class=&quot;inline&quot;&gt;t2&lt;/code&gt;时，不必担心&lt;code class=&quot;inline&quot;&gt;pass&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;fail&lt;/code&gt;：在&lt;code class=&quot;inline&quot;&gt;t1&lt;/code&gt;失败后，整个析取的成功和失败等同于&lt;code class=&quot;inline&quot;&gt;t2&lt;/code&gt;（尾位置的一种形式）的成功和失败，因此它的成功和失败continuation与整个表达式的相同。于是，我们获得：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;lt;try-or-bt-body&amp;gt; ::=

    (success (let/cc pass
               (begin
                 (let/cc fail
                   (t1 pass fail))
                 (t2 success failure))))&lt;/code&gt;&lt;p&gt;因此，如果&lt;code class=&quot;inline&quot;&gt;t1&lt;/code&gt;成功，则控制返回到创建&lt;code class=&quot;inline&quot;&gt;pass&lt;/code&gt;的上下文，即调用&lt;code class=&quot;inline&quot;&gt;success&lt;/code&gt;。如果&lt;code class=&quot;inline&quot;&gt;t1&lt;/code&gt;成功（译注，应为失败），则控制返回到创建&lt;code class=&quot;inline&quot;&gt;fail&lt;/code&gt;的continuation，也就是序列中的下一个语句，&lt;code class=&quot;inline&quot;&gt;t2&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;根据对称推理，我们可以得到对偶的&lt;code class=&quot;inline&quot;&gt;try-and&lt;/code&gt;程序：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (try-and t1 t2)
  (lambda (success failure)
    (failure (let/cc fail
               (begin
                 (let/cc pass
                   (t1 pass fail))
                 (t2 success failure))))))&lt;/code&gt;&lt;p&gt;为了方便测试，我们可以编写封装函数，将这些基于continuation的回复转换为简单的值：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (run t)
  (let/cc escape
    (t (lambda (v) (escape &#39;yes))
       (lambda (v) (escape &#39;no)))))&lt;/code&gt;&lt;p&gt;然后以此创建测试案例，从&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(test (run (try-or falsity falsity)) &#39;no)&lt;/code&gt;&lt;p&gt;到&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(test (run (try-or (try-and (try-or falsity truth) (try-or truth falsity))
                   (try-and truth (try-and falsity truth)))) &#39;yes)&lt;/code&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>MrMathematica</author>
<guid isPermaLink="false">2018-04-13-35657622</guid>
<pubDate>Fri, 13 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>PLAI 目录</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-13-35656658.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35656658&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5b75968e8163a797fd2dc822782b2251_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;合作译者 &lt;a href=&quot;https://www.zhihu.com/people/802e5a4b8b40cc8d665968a2ad620302&quot;&gt;@MrMathematica&lt;/a&gt;&lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//lotuc.gitbooks.io/plai-cn/content/&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;p&gt;一年多，终于翻译完了，很大一部分要归功于 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/802e5a4b8b40cc8d665968a2ad620302&quot; data-hash=&quot;802e5a4b8b40cc8d665968a2ad620302&quot; data-hovercard=&quot;p$b$802e5a4b8b40cc8d665968a2ad620302&quot;&gt;@MrMathematica&lt;/a&gt;，不然估计拖的时间会更长。&lt;/p&gt;&lt;hr&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24578121&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-b71b632ed7974538bb2e812bcd20914e&quot; data-image-width=&quot;432&quot; data-image-height=&quot;576&quot; data-image-size=&quot;120x160&quot;&gt;lotuc：Programming Languages: Application and Interpretation【译1-4】&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24720187&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-bb7aa62f4e7909bdfb8ec8ede8f3ed33&quot; data-image-width=&quot;432&quot; data-image-height=&quot;576&quot; data-image-size=&quot;120x160&quot;&gt;lotuc：Programming Languages: Application and Interpretation【译5】&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24991964&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-f94555d70b9a6bb704dfd919a5e5c419&quot; data-image-width=&quot;432&quot; data-image-height=&quot;576&quot; data-image-size=&quot;120x160&quot;&gt;lotuc：Programming Languages: Application and Interpretation【译6】&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25446515&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-f0ead669fe0d45e93dc5cbce9b419f46&quot; data-image-width=&quot;432&quot; data-image-height=&quot;576&quot; data-image-size=&quot;120x160&quot;&gt;lotuc：Programming Languages: Application and Interpretation【译7】&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25722562&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-f0ead669fe0d45e93dc5cbce9b419f46&quot; data-image-width=&quot;432&quot; data-image-height=&quot;576&quot; data-image-size=&quot;120x160&quot;&gt;lotuc：Programming Languages: Application and Interpretation【译8】&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26395620&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-f0ead669fe0d45e93dc5cbce9b419f46&quot; data-image-width=&quot;432&quot; data-image-height=&quot;576&quot; data-image-size=&quot;120x160&quot;&gt;lotuc：Programming Languages: Application and Interpretation【译9】&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28031784&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-f0ead669fe0d45e93dc5cbce9b419f46&quot; data-image-width=&quot;432&quot; data-image-height=&quot;576&quot; data-image-size=&quot;120x160&quot;&gt;lotuc：Programming Languages: Application and Interpretation【译10】&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31582483&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-b71b632ed7974538bb2e812bcd20914e&quot; data-image-width=&quot;432&quot; data-image-height=&quot;576&quot; data-image-size=&quot;120x160&quot;&gt;lotuc：Programming Languages: Application and Interpretation【译11】&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31582536&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-b71b632ed7974538bb2e812bcd20914e&quot; data-image-width=&quot;432&quot; data-image-height=&quot;576&quot; data-image-size=&quot;120x160&quot;&gt;lotuc：Programming Languages: Application and Interpretation【译12】&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31817926&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-b71b632ed7974538bb2e812bcd20914e&quot; data-image-width=&quot;432&quot; data-image-height=&quot;576&quot; data-image-size=&quot;120x160&quot;&gt;MrMathematica：Programming Languages: Application and Interpretation【译13】&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32037390&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-b71b632ed7974538bb2e812bcd20914e&quot; data-image-width=&quot;432&quot; data-image-height=&quot;576&quot; data-image-size=&quot;120x160&quot;&gt;MrMathematica：Programming Languages: Application and Interpretation【译14】&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33865846&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-b71b632ed7974538bb2e812bcd20914e&quot; data-image-width=&quot;432&quot; data-image-height=&quot;576&quot; data-image-size=&quot;120x160&quot;&gt;MrMathematica：Programming Languages: Application and Interpretation【译15上】&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35115633&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-b71b632ed7974538bb2e812bcd20914e&quot; data-image-width=&quot;432&quot; data-image-height=&quot;576&quot; data-image-size=&quot;120x160&quot;&gt;MrMathematica：Programming Languages: Application and Interpretation【译15中】&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35198525&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-b71b632ed7974538bb2e812bcd20914e&quot; data-image-width=&quot;432&quot; data-image-height=&quot;576&quot; data-image-size=&quot;120x160&quot;&gt;MrMathematica：Programming Languages: Application and Interpretation【译15下】&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35291037&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-1575f6b8191e20ef774d57c41608be45&quot; data-image-width=&quot;432&quot; data-image-height=&quot;576&quot; data-image-size=&quot;120x160&quot;&gt;lotuc：Programming Languages: Application and Interpretation【译16】&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35657622&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-b71b632ed7974538bb2e812bcd20914e&quot; data-image-width=&quot;432&quot; data-image-height=&quot;576&quot; data-image-size=&quot;120x160&quot;&gt;MrMathematica：Programming Languages: Application and Interpretation【译17】【完】&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>lotuc</author>
<guid isPermaLink="false">2018-04-13-35656658</guid>
<pubDate>Fri, 13 Apr 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
