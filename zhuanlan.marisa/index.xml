<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Thu, 15 Feb 2018 15:06:03 +0800</lastBuildDate>
<item>
<title>delimited continuations完全攻略</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-02-15-33399006.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33399006&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-eb471c83c20ac7b33a45d0f2bf17a90c_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;宣传一下我的群：Expert Scheme：523791077&lt;/p&gt;&lt;p&gt;&lt;b&gt;Part I ： shift and reset&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;警告：在racket中使用shift/reset，请加上这句：&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(require racket/control)&lt;/code&gt;&lt;p&gt;&lt;b&gt;A. shift和reset的基本规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;要了解shift和reset如何使用，就必须先了解shift和reset的求值规则：&lt;/p&gt;&lt;p&gt;当reset的内部是简单表达式的时候，整个表达式直接返回其值。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (+ 1 2)) =&amp;gt; 3&lt;/code&gt;&lt;p&gt;当reset的内部的shift被求值时，需要注意，返回shift的body。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (+ 1 (shift k 2)))  =&amp;gt; 2&lt;/code&gt;&lt;p&gt;把reset想象成一个整块，shift就是在其中打洞。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(+ 1 hole)&lt;/code&gt;&lt;p&gt;你现在需要一个值把洞填上去，我们可以写一个函数：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (hole) (+ 1 hole))&lt;/code&gt;&lt;p&gt;而shift的第一个标识符k所绑定的值就是这个函数(一般称为continuation，用字母k表示，或者用ctx表示）。&lt;/p&gt;&lt;p&gt;这个表达式：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (+ (shift k (k (k 1))) 1))&lt;/code&gt;&lt;p&gt;我们的k函数应当是（注意，这个例子中的hole与上一个例子的hole位置是不同的）&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (hole) (+ hole 1))&lt;/code&gt;&lt;p&gt;整个表达式应当返回shift的body部分，即：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(k (k 1))&lt;/code&gt;&lt;p&gt;而我们已经知道k的值了，直接带入表达式计算得出3。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;B. 与Arclisp中方括号的关系&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;Since functions of one argument are so often used in Lisp programs,&lt;br&gt;Arc has a special notation for them.  [... _ ...]  is an abbreviation&lt;br&gt;for (fn (_) (... _ ...)).  So our first map example could have been&lt;br&gt;written&lt;br&gt;&lt;br&gt;arc&amp;gt; (map [+ _ 10] &#39;(1 2 3))&lt;br&gt;(11 12 13)&lt;/blockquote&gt;&lt;p&gt;Arclisp允许你在表达式中开洞，这样表达式就成了一个函数。&lt;/p&gt;&lt;p&gt;而reset/shift中也允许你这么做。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (shift k k))  = 
(lambda (x) x) = 
[ _ ] (in Arclisp)&lt;/code&gt;&lt;p&gt;第二个例子：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (+ 1 (* 2 (shift k k))))  =
(lambda (x) (+ 1 (* 2 x)))  =
[+ 1 (* 2 _)] (in Arclisp)&lt;/code&gt;&lt;p&gt;我们发现Arclisp中的_与(shift k k)某种意义上有很大的相似性。&lt;/p&gt;&lt;p&gt;下面是一个更酷的例子：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (+ (shift k1 k1) (shift k2 k2)))&lt;/code&gt;&lt;p&gt;为了区分前后两个k，我将它们分别标记为k1和k2。&lt;/p&gt;&lt;p&gt;很明显k1是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x1)
  (+ x1 (shift k2 k2)))&lt;/code&gt;&lt;p&gt;我们的reset表达式返回了k1。&lt;/p&gt;&lt;p&gt;尝试向k1这个函数中喂一个值2：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(+ 2 (shift k2 k2))&lt;/code&gt;&lt;p&gt;现在你应该感到犯难了，还有一个shift表达式，但是外层已经没有reset了。&lt;/p&gt;&lt;p&gt;于是shift并不知道把k2返回到哪里，也不知道&lt;b&gt;打洞的范围是多大&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;k2是:&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x) x)&lt;/code&gt;&lt;p&gt;还是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x) (+ 2 x))&lt;/code&gt;&lt;p&gt;幸运的是，shift和reset已经帮我们考虑到这个难题了，会帮我们自动地在k1体内加一个reset。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;k1 = (lambda (x1) (reset (+ x1 (shift k2 k2))))&lt;/code&gt;&lt;p&gt;很明显，我们可以直接写出k2 （别弄丢了reset）：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x2) (reset (+ x1 x2)))&lt;/code&gt;&lt;p&gt;综合起来结果就是&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x1)
  (lambda (x2)
    (+ x1 x2)))&lt;/code&gt;&lt;p&gt;因为当reset体内没有shift时，直接返回其值，所以我们可以将两个reset消去。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;请验证 (shift k (k &lt;i&gt;val&lt;/i&gt;))和&lt;i&gt;val&lt;/i&gt;在reset体内是等价的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;C. 重新认识shift/reset&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们从shift里面获得一个k，上一节讨论过这个k应当是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x) (reset expr ...))&lt;/code&gt;&lt;p&gt;考虑下面的表达式：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (shift k (shift k 1)))&lt;/code&gt;&lt;p&gt;结果是1，按照我们原来的规则进行求值：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;=&amp;gt; (shift k 1)&lt;/code&gt;&lt;p&gt;遇到了同样的难题！外层没有reset，肯定是自动帮我们加的:&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;=&amp;gt; (reset (shift k 1))&lt;/code&gt;&lt;p&gt;所以，是时候拓展我们的求值规则了。&lt;/p&gt;&lt;p&gt;(reset val) =&amp;gt; val&lt;br&gt;(reset E[(shift k expr)]) =&amp;gt; (&lt;b&gt;reset&lt;/b&gt; ((lambda (k) expr) (lambda (v) (&lt;b&gt;reset&lt;/b&gt; E[v]))))&lt;br&gt; ; where E has no reset&lt;/p&gt;&lt;p&gt;我将其中需要添加reset的部分用粗体标出。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;D. 与不确定性计算，list monad的关系&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这是一个计算a+b是否等于c的程序，如果等于c，那么输出整个式子：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(let ([a 1])
  (let ([b 1])
    (let ([c 2])
      (when (= (+ a b) c) (printf &quot;~a+~a=~a\n&quot; a b c)))))&lt;/code&gt;&lt;p&gt;可以把他们写成reset/shift的形式：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (let ([a (shift k (k 1))])
         (let ([b (shift k (k 1))])
           (let ([c (shift k (k 2))])
             (when (= (+ a b) c) (printf &quot;~a+~a=~a\n&quot; a b c))))))&lt;/code&gt;&lt;p&gt;两种写法是等价的，现在我们的a，b，c可能是多个不确定的值，也就是要进行多次计算。&lt;/p&gt;&lt;p&gt;我们可以把k想象成填一个值，进行一次计算，于是我们将函数k进行细胞分裂，多次计算。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (let ([a (shift k (k 1) (k 2) (k 3))])
         (let ([b (shift k (k 1) (k 2) (k 3))])
           (let ([c (shift k (k 1)(k 2)(k 3))])
             (when (= (+ a b) c) (printf &quot;~a+~a=~a\n&quot; a b c))))))&lt;/code&gt;&lt;p&gt;返回结果：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;1+1=2
1+2=3
2+1=3&lt;/code&gt;&lt;p&gt;如果你觉得这个例子难以理解，那么下面的呢（输出 123）：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (let ([a (shift k (k 1) (k 2) (k 3))])
         (print a)))&lt;/code&gt;&lt;p&gt;list monad或是list comprehension是一种很好用的计算列表的方法，但是racket中没有do notation，必须用宏来替代。（实际上racket提供了for comprehension作为替代方案，我们这里为了演示reset和shift的作用不考虑。）&lt;/p&gt;&lt;p&gt;但是，我们也可以用reset和shift来直接实现：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define return list)
(define (in-list lst)
  (shift k
         (apply append
                (map k lst))))

(reset (let ([a (in-list &#39;(1 2 3))]
             [b (in-list &#39;(1 2 3))])
         (return (list a b))))&lt;/code&gt;&lt;p&gt;返回结果：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&#39;((1 1) (1 2) (1 3) (2 1) (2 2) (2 3) (3 1) (3 2) (3 3))&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;E. 与状态，state monad的关系&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在一些语言中不支持赋值语句，无法保存状态，可以用state monad来模拟，同样地，state monad也可以用reset和shift模拟。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (get)
  (shift k (lambda (s) ((k s) s))))
(define (put s)
  (shift k (lambda (-s)
             ((k (void)) s))))
(define ((return x) s) x)&lt;/code&gt;&lt;p&gt;下面展现了一个很有意思的例子：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (tick)
  (let ([a (get)])
    (put (+ a 1))))
((reset (tick)
       (tick)
       (tick)
       (return (get))) 0)&lt;/code&gt;&lt;p&gt;试试看用shift和reset是否能实现其他monad。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;F. 与stream，generator的关系&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当我们需要表示无穷时，我们通常借助于stream与generator，而shift/reset与这二者间有着微妙的关系。&lt;/p&gt;&lt;p&gt;我们需要使用define-syntax-rule，不了解的请看：&lt;a href=&quot;http://docs.racket-lang.org/reference/stx-patterns.html?q=define-syntax-rule#%28form._%28%28lib._racket%2Fprivate%2Fmisc..rkt%29._define-syntax-rule%29%29&quot;&gt;12.1 Pattern-Based Syntax Matching&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;看下面的例子：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define s (reset (shift k (stream-cons 1 (k (void))))
                 (shift k (stream-cons 2 (k (void))))
                 (shift k (stream-cons 3 (k (void))))
                 (shift k &#39;())))&lt;/code&gt;&lt;p&gt;这个例子生成了一个内容为1 2 3的stream，而内部的语法却接近generator！&lt;/p&gt;&lt;p&gt;我们可以写宏来让你看的更加清楚：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define-syntax-rule (stream/generate expr ...)
  (reset expr ...))
(define-syntax-rule (stream/yield expr ...)
  (shift k (stream-cons (begin expr ...) (k (void)))))

(define s (stream/generate
           (stream/yield 1)
           (stream/yield 2)
           (stream/yield 3)))

(define (integer-sequences x)
  (stream/generate (stream/yield x)
                   (integer-sequences (+ x 1))))&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;用shift和reset实现generator的任务更为艰巨，我们曾经在&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25749077&quot;&gt;愉悦的scheme之旅（2）--用callcc合成控制流&lt;/a&gt;介绍过用call/cc实现的generator，但是因为有了shift和reset一切都变简单了。&lt;/p&gt;&lt;p&gt;我们需要使用syntax-parameter，不了解的请看&lt;a href=&quot;http://docs.racket-lang.org/reference/stxparam.html?q=syntax-parameter&quot;&gt;12.5 Syntax Parameters&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;完整程序如下：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang racket
(require racket/control racket/stxparam)
(define-syntax-parameter yield 
  (syntax-rules ()
    [(_ expr ...)
     (raise-syntax-error &#39;generator-err
                         &quot;You must use yield in the body of generator&quot;)]))

(define-syntax-rule (generate expr ...)
  (letrec ([state (lambda ()
                 (syntax-parameterize
                     ([yield (syntax-rules ()
                               [(_ expr2 (... ...)) (shift k
                                                           (set! state
                                                                 (lambda () (k (void))))
                                                           (values expr2 (... ...)))])])
                   (reset (begin expr ... (void)))))])
    (lambda ()
      (state)
      )))
(define g (generate (yield 1)
                    (yield 6)
                    (yield 7)
                    (yield 10)))&lt;/code&gt;&lt;p&gt;宏会干扰我们的思考，我们看看展开后是什么样子吧。&lt;/p&gt;&lt;p&gt;racket的macro stepper是宏调试的利器，通过它，我们可以直接看到展开的结果：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(syntax-parameterize
  ((yield
    (syntax-rules ()
      ((_ expr2 ...)
       (shift k (set! state (lambda () (k (void)))) (values expr2 ...))))))
  (reset (begin (yield 1) (yield 6) (yield 7) (yield 10) (void))))&lt;/code&gt;&lt;p&gt;这并不是最终的结果，因为syntax-parameterize没有展开,由于一些限制，我们手动展开一下：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (begin (shift k (set! state (lambda () (k (void)))) (values 1))
                (shift k (set! state (lambda () (k (void)))) (values 6))
                (shift k (set! state (lambda () (k (void)))) (values 7))
                (shift k (set! state (lambda () (k (void)))) (values 10))
                (void)))&lt;/code&gt;&lt;p&gt;现在应该看的很清楚了，第一次调用时返回1，state则变成了：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda () (reset (begin (void)
                         (shift k (set! state (lambda () (k (void)))) (values 6))
                         (shift k (set! state (lambda () (k (void)))) (values 7))
                         (shift k (set! state (lambda () (k (void)))) (values 10))
                         (void))))&lt;/code&gt;&lt;p&gt;剩下的应该不难了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;G.  算法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;考虑函数genlist：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(genlist &#39;(1 2)) =&amp;gt; &#39;((1) (1 2))
(genlist &#39;(1 2 3 4)) =&amp;gt; &#39;((1) (1 2) (1 2 3) (1 2 3 4))&lt;/code&gt;&lt;p&gt;有人会这么做：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (genlist lst)
  (define (genlist lst last)
    (if (null? lst) &#39;()
        (let ([x (append last (list (car lst)))])
          (cons x (genlist (cdr lst) x)))))
  (genlist lst &#39;()))&lt;/code&gt;&lt;p&gt;可惜效率并不高，因为多次向队尾插入数据。&lt;/p&gt;&lt;p&gt;借助CPS，我们可以这么写（其实也可看成difference list）：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (genlist lst)
  (define (genlist lst ctx)
    (if (null? lst)
        (list (ctx &#39;()))
        (cons (ctx (list (car lst)))
              (genlist (cdr lst)
                       (lambda (x) (ctx (cons (car lst) x)))))))
  (if (null? lst)
      &#39;()
      (genlist lst (lambda (x) x))))&lt;/code&gt;&lt;p&gt;考虑lst=&#39;(1 2 3 4)的情况，ctx分别是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;ctx1 = [list* _]
ctx2 = [list* 1 _]
ctx3 = [list* 1 2 _]
ctx4 = [list* 1 2 3 _]&lt;/code&gt;&lt;p&gt;我们可以用shift和reset重写：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (genlist lst)
  (define (genlist lst)
    (if (null? lst)
        (shift k &#39;())
        (shift k
               (cons (k (list (car lst)))
                     (reset (k (cons (car lst)
                                     (genlist (cdr lst)))))))))
  (reset (genlist lst)))&lt;/code&gt;&lt;p&gt;可以自己尝试推倒一下。&lt;/p&gt;&lt;p&gt;shift和reset还能做其他一些算法例如cps变换，anf变换，closure conversion等，这里不再详细介绍。&lt;/p&gt;&lt;p&gt;新手的课后作业：&lt;/p&gt;&lt;p&gt;尝试用shift和reset实现cps变换和anf变换。&lt;/p&gt;&lt;p&gt;老手的课后作业(难度非常大，做好心理准备）：&lt;/p&gt;&lt;p&gt;阅读&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.schemeworkshop.org/2016/scheme16-paper6.pdf&quot;&gt;Deriving Pure, Naturally-Recursive Operations for Processing Tail-Aligned Lists&lt;/a&gt;(SCHEME AND FUNCTIONAL PROGRAMMING WORKSHOP 2016)&lt;/p&gt;&lt;p&gt;并尝试用shift和reset改写其中的算法。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Part II : shift0 and reset0&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;A. 求值规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;直接给出shift0和reset0的求值规则：&lt;/p&gt;&lt;p&gt;(reset0 &lt;i&gt;val&lt;/i&gt;) &lt;a href=&quot;file:///C:/Program%20Files/Racket/doc/reference/if.html?q=shift#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29&quot;&gt;=&amp;gt;&lt;/a&gt; &lt;i&gt;val&lt;/i&gt;&lt;/p&gt;&lt;p&gt;(reset0 &lt;i&gt;E&lt;/i&gt;[(shift0 &lt;i&gt;k&lt;/i&gt; &lt;i&gt;expr&lt;/i&gt;)]) &lt;a href=&quot;file:///C:/Program%20Files/Racket/doc/reference/if.html?q=shift#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._~3d~3e%29%29&quot;&gt;=&amp;gt;&lt;/a&gt; ((lambda (&lt;i&gt;k&lt;/i&gt;) &lt;i&gt;expr&lt;/i&gt;) (lambda (&lt;i&gt;v&lt;/i&gt;) (&lt;b&gt;reset0&lt;/b&gt; &lt;i&gt;E&lt;/i&gt;[&lt;i&gt;v&lt;/i&gt;])))&lt;/p&gt;&lt;p&gt;仔细比较与shift和reset的不同，你会发现是不是少了一个reset0，也就是说&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset0 (shift0 k expr)) =&amp;gt; expr&lt;/code&gt;&lt;p&gt;而不是&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset (shift k expr)) =&amp;gt; (reset expr)&lt;/code&gt;&lt;p&gt;那么思考下面这段程序，k1和k2分别是什么？&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset0 (+ 1
           (reset0 (+ 2 (shift0 k1 (shift0 k2 3))))))&lt;/code&gt;&lt;p&gt;k1是显而易见的：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x1)
  (reset0 (+ 2 x1)))&lt;/code&gt;&lt;p&gt;根据我们刚才讨论的内容继续求值：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;=&amp;gt; (reset0 (+ 1 (shift0 k2 1)))&lt;/code&gt;&lt;p&gt;然后就能得到k2了&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda (x2) (reset0 (+ 1 x2)))&lt;/code&gt;&lt;p&gt;这里，我们最先得到的k1，是内层的continuation，而k2，是外层的continuation。&lt;/p&gt;&lt;p&gt;我们可以将他们组合一下，得到整个continuation：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(reset0 (+ 1 (reset0
              (+ 2 (shift0 k1
                           (shift0 k2 (k2 (k1 3))))))))&lt;/code&gt;&lt;p&gt;这与 (+ 1 (+ 2 3))是等价的。&lt;/p&gt;&lt;p&gt;我们捕获的continuation具有了层次这一概念，接下来我们该利用这一特点搞事了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;B. 括号解析&lt;/b&gt;&lt;/p&gt;&lt;p&gt;下面思考这个问题，给与一个含有左括号的标记&#39;left 和右括号标记的&#39;right的列表，将其转换成有层次的列表。&lt;/p&gt;&lt;p&gt;(parse-parens &#39;(a b left c right)) =&amp;gt; &#39;(a b (c))&lt;/p&gt;&lt;p&gt;(parse-parens &#39;(a left b left c right right d)) =&amp;gt; &#39;(a (b (c)) d)&lt;/p&gt;&lt;p&gt;现在我们考虑解析&#39;(a b left c right)，以continuation的思维来看的话：&lt;/p&gt;&lt;p&gt;符号a ，ctx = (lambda (x) x)&lt;/p&gt;&lt;p&gt;符号b，ctx = (lambda (x) (cons a x))&lt;/p&gt;&lt;p&gt;符号left，ctx = (lambda (x) (list* a b x))&lt;/p&gt;&lt;p&gt;到这里我们就觉得有些困难了，因为left c right是一个整体，我们必须要解析到right才能知道这个整体的内容是&#39;(c)。&lt;/p&gt;&lt;p&gt;我们可以考虑使用双层的continuation：&lt;/p&gt;&lt;p&gt;符号a，ctx-inner = (lambda (x) x) ctx-outer = (lambda (x) x)&lt;/p&gt;&lt;p&gt;符号b，ctx-inner = (lambda (x) x) ctx-outer = (lambda (x) (cons a x))&lt;/p&gt;&lt;p&gt;符号left,ctx-inner = (lambda (x) x) ctx-outer = (lambda (x) (list* a b x))&lt;/p&gt;&lt;p&gt;符号c ,  ctx-inner = (lambda (x) (cons c x)) ctx-outer = (lambda (x) (list* a b x))&lt;/p&gt;&lt;p&gt;符号right , 清空ctx-inner， 结果送入ctx-outer&lt;/p&gt;&lt;p&gt;ctx-inner = (lambda (x) x) ctx-outer = (lambda (x) (list* a b c x))&lt;/p&gt;&lt;p&gt;解析完毕，清空ctx-outer。&lt;/p&gt;&lt;p&gt;解析时ctx-inner负责处理内部，ctx-outer负责解析外部。&lt;/p&gt;&lt;p&gt;当我们的括号的层次不止两层时，我们的ctx也不止两个，无穷无尽的ctx组成了一个ctx栈。&lt;/p&gt;&lt;p&gt;现在，考虑如何用shift0和reset0实现：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (parse-parens lst)
  (define (parse-parens lst)
    (if (null? lst) &#39;()
        (match (car lst)
          [&#39;left (reset0 (parse-parens (cdr lst)))]
          [&#39;right (shift0 k1 (shift0 k2 (reset0 (k2 (cons (k1 &#39;()) (parse-parens (cdr lst)))))))]
          [_ (shift0 k (reset0 (k (cons (car lst) (parse-parens (cdr lst))))))])))
  (reset0 (parse-parens lst)))&lt;/code&gt;&lt;p&gt;每次遇到left时，我们开辟一个新的reset0层，每次遇到right时，我们将该层次闭合。&lt;/p&gt;&lt;p&gt;这是利用同样办法写出来的表达式解析器：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (parse-exp lst)
  (define (parse-exp lst)
    (if (null? lst) (error &quot;No exp&quot;)
        (match lst
          [(list (? number? x)) x]
          [(list (? number? x) (and (or &#39;+ &#39;-) op) rst ...) (shift0 k1
                                                                    (shift0 k2 (shift0 k3
                                                                                       (reset0 
                                                                                        (list op  (k3 (k2 (k1 x))) (reset0
                                                                                                                    (reset0
                                                                                                                     (parse-exp rst))))))))]
          [(list (? number? x) (and (or &#39;* &#39;/) op) rst ...) (shift0
                                                             k1 (shift0 k2
                                                                        (reset0  (list op (k1 (k2 x)) (reset0
                                                                                                       (parse-exp rst))))))]
          [(list (? number? x) (and &#39;^ op) rst ...) (shift0
                                                     k (reset0
                                                        (list op (k x) (parse-exp rst))))]
          )))
  (reset0 (reset0 (reset0 (parse-exp lst)))))&lt;/code&gt;&lt;p&gt;比如1+2*3^6-7*8的层次是：&lt;/p&gt;&lt;p&gt;1 + [ 2 * (3^6) ] - [ 7*8 ]&lt;/p&gt;&lt;p&gt;这就是为什么有三个优先级就需要三个reset0的缘故。&lt;/p&gt;&lt;p&gt;课后作业：&lt;/p&gt;&lt;p&gt;1.可以用shift0和reset0实现shift和reset吗，试试看。&lt;/p&gt;&lt;p&gt;2.这个表达式解析器存在一个缺陷，所有操作符都会视为左结合的，然而：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(parse-exp &#39;(1 ^ 2 ^ 3))  =&amp;gt; &#39;(^ (^ 1 2) 3)&lt;/code&gt;&lt;p&gt;指数运算应当是右结合的，请尝修复这个bug。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>御坂黒子</author>
<guid isPermaLink="false">2018-02-15-33399006</guid>
<pubDate>Thu, 15 Feb 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>【OI】【奇技淫巧】bitset在OI中的应用</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-01-29-33406432.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33406432&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d825293370685bfc6c285d7b2ad50ea1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;震惊，GDKOI2018D1T3竟有bitset水法！&lt;/p&gt;&lt;p&gt;作为一只标准蒟蒻，我在学不会标准正解FFT的情况下然后去学了一下bitset。。。&lt;/p&gt;&lt;p&gt;一般你翻开一个关于介绍bitset的blog，基本画风是这样的：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e433874acf5a3b6b77c4413512410809_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;761&quot;&gt;&lt;p&gt;（来源：&lt;a href=&quot;https://www.cnblogs.com/BaiYiShaoNian/p/4591167.html&quot;&gt;https://www.cnblogs.com/BaiYiShaoNian/p/4591167.html&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;然而作为菜鸡的我一看完就有点懵，不是说bitset可以快速查找某一个元素喵，这些...都是处理二进制的呀。&lt;/p&gt;&lt;p&gt;然后经过我的几次无脑实验我大概就摸清了使用bitset的基本套路：&lt;/p&gt;&lt;p&gt;1、bitset其实是可以看做是&lt;b&gt;一个bool类型的数组&lt;/b&gt;，只不过bitset的一个元素只占1bit的空间，而bool里面则是占1byte，这样就相当于同时减少了时间复杂度和空间复杂度，这也是bitset的优势所在。&lt;/p&gt;&lt;p&gt;2、使用bitset的时候你需要先声明，类似声明vector一样，基本格式：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;#include&amp;lt;bitset&amp;gt;
bitset&amp;lt;10005&amp;gt;a;  //10005是bitset的大小，相当于数组大小，a就相当于一个bool数组。&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;3、前面说了bitset是基本和bool数组的用法一样的，所以其实赋值的时候&lt;b&gt;完全可以这样写&lt;/b&gt;：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;a[0]=1;//等价于写a.set(0);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;4、那么话说回来&lt;b&gt;如何快速查找一个元素是否在集合内&lt;/b&gt;呢，你大可这样写：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;//x为查找元素：
if (f[x]) printf(&quot;Yes\n&quot;); else printf(&quot;No\n&quot;);&lt;/code&gt;&lt;p&gt;有人可能会问了，那这不是bool数组也可以做到吗，其实还是&lt;b&gt;空间&lt;/b&gt;的问题，用bitset可以轻松存10^8个数字并查询，bool空间是它的八倍然后就极有可能MLE~&lt;/p&gt;&lt;p&gt;那我们就来一道水题练练手吧&lt;/p&gt;&lt;a href=&quot;http://poj.org/problem?id=2443&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;2443 -- Set Operation&lt;/a&gt;&lt;p&gt;果然很水对吧（&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;bitset&amp;gt;
using namespace std;
int n,i,j,k,q,x,g,y;
bool fl;
bitset&amp;lt;10005&amp;gt; a[1015];
int main()
{
	scanf(&quot;%d&quot;,&amp;amp;n);
	for (i=1;i&amp;lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;amp;x);
		for (j=1;j&amp;lt;=x;j++)
		{
			scanf(&quot;%d&quot;,&amp;amp;g);
			a[i][g]=1;
		}
	}
	scanf(&quot;%d&quot;,&amp;amp;q);
	for (i=1;i&amp;lt;=q;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;amp;x,&amp;amp;y);
		fl=1;
		for (j=1;j&amp;lt;=n;j++)
			if (a[j][x]&amp;amp;&amp;amp;a[j][y]) {printf(&quot;Yes\n&quot;);fl=0;break;}
		if (fl) printf(&quot;No\n&quot;);
	}
	return 0;
}&lt;/code&gt;&lt;p&gt;Q：有没有好玩一点的题&lt;/p&gt;&lt;p&gt;A：bzoj3687把dp和bitset结合了起来，可惜是一道权限题qwq。有兴趣的可以看hzwer的blog看一下这道题w（http://hzwer.com/3697.html）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>萌萌哒喵酱</author>
<guid isPermaLink="false">2018-01-29-33406432</guid>
<pubDate>Mon, 29 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何让你的正则表达式拥有更好的性能</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-01-13-32896848.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32896848&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-569c3849ef9adeb2f616b0da2e694c31_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;首先呢, 这里要写的不是如何编写高效的正则表达式, 而是正则表达式引擎内部使用的一些编译优化小技巧, 以及探讨这些技巧的适用范围. &lt;/p&gt;&lt;p&gt;这里关注的是通用NFA引擎, 也就是大家平时在各种语言里最常调用的正则表达式库使用的算法. 当然啦, 还有另外一种DFA引擎比如RE2, 由于DFA的限制, 这类引擎非常难甚至不可能实现大部分的拓展(如环视和向后引用).&lt;/p&gt;&lt;p&gt;文章里我将写一些通用的正则表达式引擎技术以及技巧, 在了解了引擎之后相信大家能对正则表达式由更深入的了解同时也能更好地写出更高效的正则表达式. 文章里写的大部分技术来自我的正则表达式引擎项目(各个库的做法会有差异, 不过原则是相通的, 如果对我的正则表达式引擎实现有兴趣请看文章结尾由介绍).&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;要讨论正则表达式引擎, 我们需要一个最基本引擎模型, 为了追求更好的性能, 这里使用的非递归的虚拟机模型, 执行的是由正则表达式编译成的字节码. 一个最基本的正则表达式虚拟机需要以下几种指令:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{MATCH}, \\ &amp;amp;\texttt{SPLIT}, \\ &amp;amp;\texttt{JMP}, \\ &amp;amp;\texttt{ACCEPT} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;例如对于正则表达式 &lt;equation&gt;\texttt{(a|b)*abb}&lt;/equation&gt; 将生成虚拟机指令:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split 1, 6}\\ &amp;amp;\texttt{1 split 2, 4}\\ &amp;amp;\texttt{2 match a}\\ &amp;amp;\texttt{3 jmp 5}\\ &amp;amp;\texttt{4 match b}\\ &amp;amp;\texttt{5 split 1, 6}\\ &amp;amp;\texttt{6 match a}\\ &amp;amp;\texttt{7 match b}\\ &amp;amp;\texttt{8 match b}\\ &amp;amp;\texttt{9 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;虚拟机的实现代码如下:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;enum BYTE_CODE
{
	MATCH,
	SPLIT,
	JMP,
	ACCEPT,
};

bool match_impl(std::string str, std::vector&amp;lt;ptrdiff_t&amp;gt; byte_code, 
	size_t&amp;amp; begin, size_t&amp;amp; end)
{
	struct state
	{
		size_t IP;
		size_t index;
	};

	std::vector&amp;lt;state&amp;gt; state_stack;
	size_t off = 0;

	while (off &amp;lt; str.length())
	{
		state_stack.clear();
		state_stack.push_back({ 0, off++ });

	fail_loop:;
		while (!state_stack.empty())
		{
			auto&amp;amp; state = state_stack.back();
			auto IP = state .IP;
			auto index = state.index;
			state_stack.pop_back();

		next_loop:;
			switch (byte_code[IP])
			{
			case BYTE_CODE::MATCH:
				if (index &amp;lt; str.length() &amp;amp;&amp;amp; (str[index] == byte_code[IP + 1]))
				{
					index++;
					IP += 2;
					goto next_loop;
				}
				goto fail_loop;
			case BYTE_CODE::SPLIT:
				state_stack.push_back({ static_cast&amp;lt;size_t&amp;gt;(IP + byte_code[IP + 2]), index });
				IP += byte_code[IP + 1];
				goto next_loop;
			case BYTE_CODE::JMP:
				IP += byte_code[IP + 1];
				goto next_loop;
			case BYTE_CODE::ACCEPT:
				begin=off; end=index;
				return true;
			default:
				return false;
			}
		}
	}
	return false;
}&lt;/code&gt;&lt;p&gt;这里的虚拟机结构和之前的文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24458116&quot;&gt;正则表达式与AOT编译&lt;/a&gt;里一致.&lt;/p&gt;&lt;p&gt;关于词法分析, 语法分析和指令生成等的细节这里不做更多讨论. 在有了基本的模型之后我们便可以开始讨论如何优化引擎了.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Direct threading&lt;/h2&gt;&lt;p&gt;首先是指令分派的 &lt;equation&gt;\texttt{while-switch}&lt;/equation&gt; 循环, 每执行一条指令需要执行一次 &lt;equation&gt;\texttt{switch}&lt;/equation&gt; , 可以使用GCC的拓展&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html&quot;&gt;Labels as Values&lt;/a&gt;将switch改写为Direct threading分派指令, 减小多余的跳转带来的开销:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;static const void *next_instr[] = { 
	&amp;amp;&amp;amp;byte_code_match,
	&amp;amp;&amp;amp;byte_code_split,
	&amp;amp;&amp;amp;byte_code_jmp,
	&amp;amp;&amp;amp;byte_code_accept,
}

switch (byte_code[IP])  //for initial instruction
{

case BYTE_CODE::MATCH:
{
byte_code_match:
	//code...
}
case BYTE_CODE::SPLIT:
{
byte_code_split:
	//code...
	goto *(next_instr[byte_code[IP]]);
}
case BYTE_CODE::JMP:
{
byte_code_jmp:
	goto *(next_instr[byte_code[byte_code[IP + 1]]]);
}
case BYTE_CODE::ACCEPT:
{
byte_code_accept:
	//code...
	return true;
}

}&lt;/code&gt;&lt;p&gt;更进一步, 可以使用Context Threading with Tiny inlining, 将解释器改写成半JIT形式, 不过使用这类技术需要动态生成native code, 这里不做更多讨论, 有兴趣可以阅读paper: &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.cs.toronto.edu/~matz/pubs/demkea_context.pdf&quot;&gt;Context Threading: A flexible and efficient dispatch technique for virtual machine interpreters [.PDF]&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Memory pool&lt;/h2&gt;&lt;p&gt;在虚拟机中我们使用了一个 &lt;equation&gt;\texttt{vector}&lt;/equation&gt; 来存储每一个状态, 但是 &lt;equation&gt;\texttt{vector}&lt;/equation&gt; 在这里的内存效率不高, 主要原因是不需要随机访问, 只需要访问最顶端的头部元素, 而 &lt;equation&gt;\texttt{vector}&lt;/equation&gt; 随着状态增长发生的内存增长分配和搬移会带来显著的花销. 这个时候改用双向链表会比较合适, 配合内存池进行状态分配以获取更好的内存效率.&lt;/p&gt;&lt;p&gt;实现的思想是保存链表头部指针&lt;/p&gt;&lt;ul&gt;&lt;li&gt;访问头部时直接返回该指针指向的节点中保存的状态&lt;/li&gt;&lt;li&gt;添加新状态时检查头部指针节点的后继节点, 若为空则从内存池分配新节点, 并将头部指针指向该节点.&lt;/li&gt;&lt;li&gt;释放状态时将头部指针移动至其指向节点的前趋节点, 而不是回收该节点的内存.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;内存池的实现策略可以是一个单链表, 每个节点内包含一大块内存, 每次申请从中取出一个地址, 用尽后分配新的节点, 在完成匹配后由内存池统一回收内存. 在内存布局上新的状态储存结构更接近块状链表.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Branch stack&lt;/h2&gt;&lt;p&gt;在正则表达式循环 &lt;equation&gt;\texttt{+, *, ?}&lt;/equation&gt; 中若是出现空匹配将会造成死循环, 避免该情况的方案是在每个状态内设置一个独立的栈(使用栈是为了应对嵌套的循环, 同时这个栈是相当有用的结构, 后续将继续沿用其以支持环视与递归匹配)记录在循环开始时的匹配位置, 在匹配结束时检查是否有变化, 如果没有变换则退出该循环避免死循环.&lt;/p&gt;&lt;p&gt;每个状态的结构如下:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;struct state
{
	size_t IP;
	size_t index;
	state_stack stack;
};&lt;/code&gt;&lt;p&gt;并添加两个新指令 &lt;equation&gt;\texttt{push, repeat}&lt;/equation&gt; 用于循环, 此时正则表达式&lt;equation&gt;\texttt{(a|b)+}&lt;/equation&gt; 将编译成:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 push index}\\ &amp;amp;\texttt{1 split 2, 4}\\ &amp;amp;\texttt{2 match a}\\ &amp;amp;\texttt{3 jmp 5}\\ &amp;amp;\texttt{4 match b}\\ &amp;amp;\texttt{5 repeat 1}\\ &amp;amp;\texttt{6 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;新增加的指令对应的虚拟机代码如下:&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;case BYTE_CODE::PUSH_INDEX:
	state.stack.push(index);
	goto next_loop;
case BYTE_CODE::REPEAT:
	if(state.stack.back() != index)
	{
		state_stack.push_back({ static_cast&amp;lt;size_t&amp;gt;(IP + 2]), index, state.stack });
		IP += byte_code[IP + 1];
		goto next_loop;
	}
	else	//exit loop
	{
		IP += 2;
		goto next_loop;
	}&lt;/code&gt;&lt;p&gt;这个时候内存效率问题出现了, 如果我们使用数组或 &lt;equation&gt;\texttt{vector}&lt;/equation&gt; 来实现 &lt;equation&gt;\texttt{state_stack}&lt;/equation&gt; 的话在每次执行 &lt;equation&gt;\texttt{split} &lt;/equation&gt; 时需要将整个栈复制一整遍, 这是不忍直视的效率. 这个时候我们使用惰性求值的策略:&lt;/p&gt;&lt;p&gt;将栈实现为数形结构Branch stack, 即拥有多条分支的栈结构, 将树中.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在每次复制状态时仅仅增加栈顶元素的引用计数. &lt;/li&gt;&lt;li&gt;&lt;equation&gt;\texttt{push}&lt;/equation&gt; 时增长节点.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;\texttt{pop}&lt;/equation&gt; 时检查该节点的引用计数, 若为1则回收节点, 若大于1则减小引用计数, 增加后继节点的引用计数并且栈顶指针向后移动.&lt;/li&gt;&lt;li&gt;修改节点数据时检查引用计数, 若为1则直接在原地修改, 否则分叉该节点, 之后在分叉后的节点上修改数据.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里的分支栈结构比较接近functional programming的immutable data structures的实现.&lt;/p&gt;&lt;p&gt;在拥有栈以后可以用于计数循环的实现, 比如 &lt;equation&gt;\texttt{(a|b){3}}&lt;/equation&gt; 可以在栈上面记录当前的循环次数.&lt;/p&gt;&lt;p&gt;注: 关于避免空循环还有另外一种做法不需要栈(在NFA生成阶段处理掉了), 如果有兴趣的小伙伴请告诉我, 我下次写写.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Loop instruction&lt;/h2&gt;&lt;p&gt;在正则表达式中会经常出现单个字符的循环, 比如 &lt;equation&gt;\texttt{\d}*&lt;/equation&gt; , 对于单个字符, 每一次循环都需要执行一次 &lt;equation&gt;\texttt{match}&lt;/equation&gt; 和一次 &lt;equation&gt;\texttt{repeat}&lt;/equation&gt; , 在匹配失败后还需要Backtracking, 将造成极大的性能损失, 这个时候可以引入一个新的指令 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 用于执行单个字符的循环. &lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{loop}&lt;/equation&gt; 的实现非常简单, 只需要在 &lt;equation&gt;\texttt{match}&lt;/equation&gt; 上套上一层 &lt;equation&gt;\texttt{while}&lt;/equation&gt; 循环即可. 虽然实现简单但是带来的提升却是巨大的.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Memorization&lt;/h2&gt;&lt;p&gt;&lt;equation&gt;\texttt{loop}&lt;/equation&gt; 指令的引入还可以非常容易地实现记忆化, 由于 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 指令是单个字符的循环, 因此在进行状态记忆化时不需要记录下每一次进行匹配的位置, 只需要记录开始循环和结束循环的位置即可. &lt;/p&gt;&lt;p&gt;记忆化在考虑了memory footprint的平衡后, 我个人的建议是仅仅对 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 指令进行单次的记忆化(其余指令的记忆化往往需要记录大量的已匹配位置信息, 重入时亦需要大量的检查, 往往得不偿失).&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{loop}&lt;/equation&gt; 指令的记忆化能有效地优化诸如 &lt;equation&gt;\texttt{a*a*a*b}&lt;/equation&gt; 这样的正则表达式. &lt;/p&gt;&lt;p&gt;另外在递归匹配中也可以使用记忆化来优化同一位置的重入.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;One character Lookahead&lt;/h2&gt;&lt;p&gt;对于循环来说, 每一次循环都需要进行一次状态的保存, 在进行了以上的内存优化后仍然是一个不可忽视的开销, 在循环中可以使用单个字符的向前看来减少这种额外的开销.&lt;/p&gt;&lt;p&gt;举例如下:&lt;/p&gt;&lt;p&gt;对于正则表达式 &lt;equation&gt;\texttt{\d*0\d*}&lt;/equation&gt;匹配中间存在一个字符0的字符串, 在匹配字符串1230321时, 第一个循环 &lt;equation&gt;\texttt{\d*}&lt;/equation&gt; 将在每一个字符串位置进行一次状态保存, 实际上只有在匹配到123这个位置的时候才需要真正的进行状态保存, 其余位置均不需要, 因为仅有123的后继字符0能匹配.&lt;/p&gt;&lt;p&gt;对于循环, 我们可以通过静态分析收集循环之后的可能匹配的字符, 并在每一次循环结束时进行一次预匹配, 若是失败则不保存该状态直接进行下一轮循环.&lt;/p&gt;&lt;p&gt;另外我们可以通过更为精细的静态分析配合 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 指令实现更高的效率, 例如匹配一个合法的Gmail邮箱的正则表达式 &lt;equation&gt;\texttt{[\w.]+@gmail.com}&lt;/equation&gt; 对于循环&lt;equation&gt;\texttt{[\w.]+}&lt;/equation&gt;我们使用 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 的同时可以发现该处的 &lt;equation&gt;\texttt{loop}&lt;/equation&gt; 其实不需要进行预查, 因为&lt;equation&gt;\texttt{[\w.]}&lt;/equation&gt;与 &lt;equation&gt;\texttt{@}&lt;/equation&gt; 并不相交, 也就是说 &lt;equation&gt;\texttt{[\w.]}&lt;/equation&gt; 匹配成功则 &lt;equation&gt;\texttt{@}&lt;/equation&gt; 匹配必然不成功, 那么只需要进行简单的 &lt;equation&gt;\texttt{while}&lt;/equation&gt; 循环即可, 直到匹配失败后退出循环进行后续状态的匹配. &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Repetition classification&lt;/h2&gt;&lt;p&gt;对于一般的循环, 我们可以按照其属性分类&lt;/p&gt;&lt;ul&gt;&lt;li&gt;计数循环与非计数循环.&lt;/li&gt;&lt;li&gt;空循环与非空循环.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其中注意到非计数循环与非空循环并不需要在状态的栈上保留信息(非空循环不会陷入死循环), 因此也不需要在循环前执行 &lt;equation&gt;\texttt{push}&lt;/equation&gt; 指令.&lt;/p&gt;&lt;p&gt;计数循环与非计数循环可以在语法分析阶段加以区分, 而空循环与非空循环稍微复杂一点, 需要对正则表达式做静态分析, 在中间阶段生成NFA后从循环的节点开始进行深度优先搜索(DFS)若存在一条路径不匹配任何字符则该循环为空循环, 若不存在这样的路径则意味着该循环内部至少需要匹配一个字符, 即非空循环.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Loop unrolling&lt;/h2&gt;&lt;p&gt;对于循环展开相信大家都不会陌生, 对于计数循环我们可以对其做循环展开, 例如 &lt;equation&gt;\texttt{a{4}}&lt;/equation&gt; 可展开为 &lt;equation&gt;\texttt{aaaa}&lt;/equation&gt; , 展开后不需要循环指令和压栈一个计数.&lt;/p&gt;&lt;p&gt;更进一步地, 循环展开可以配合静态分析进行更多的优化.&lt;/p&gt;&lt;p&gt;其一是可以做字符合并, 为了效率我们可以引入一个新的指令 &lt;equation&gt;\texttt{match stirng}&lt;/equation&gt; , 将 &lt;equation&gt;\texttt{match}&lt;/equation&gt; 拓展为对字符串的匹配, 编译器可以对字符串的比较做更多的优化, 更加地, 例如 &lt;equation&gt;\texttt{aab{4}}&lt;/equation&gt; 可展开为 &lt;equation&gt;\texttt{aabbbb}&lt;/equation&gt; 在有字符串匹配指令下用一条指令 &lt;equation&gt;\texttt{match aabbbb}&lt;/equation&gt; 即可完成匹配.&lt;/p&gt;&lt;p&gt;其二是可以优化掉循环中的捕获组, 这里的优化同样需要进行一些静态分析, 在循环体中有引用的捕获组不可以被删除. 例如 &lt;equation&gt;\texttt{((\d)\2){3}}&lt;/equation&gt; 可展开为 &lt;equation&gt;\texttt{(\d)\2(\d)\2((\d)\2)}&lt;/equation&gt; 注意捕获组1在前两个循环中被删除掉了, 因为该捕获组会被最后一个循环体内的内容覆盖, 因此没必要保存下来.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Merge branches&lt;/h2&gt;&lt;p&gt;对于分支 &lt;equation&gt;\texttt{|}&lt;/equation&gt; 来说, 在遇到单个字符求或的情况下是可以进行合并的, 例如 &lt;equation&gt;\texttt{1|2|3|4|5|6|7|8|9|0}&lt;/equation&gt; 将可以合并成 &lt;equation&gt;\texttt{\d}&lt;/equation&gt; . &lt;/p&gt;&lt;p&gt;该优化的实现并不复杂, 只需要检查每一条分支是否为单字符即可, 若是单字符则进行合并.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Extract the common factor&lt;/h2&gt;&lt;p&gt;另外一类的关于分支的优化是提取公因式, 例如对于匹配数字0-255正则表达式&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2}}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中分支 &lt;equation&gt;\texttt{25[0-5]|2[0-4][0-9]}&lt;/equation&gt; 将可以进行公因式提取变成 &lt;equation&gt;\texttt{2(?:5[0-5]|[0-4][0-9])}&lt;/equation&gt; 注意提取了公因式 &lt;equation&gt;\texttt{2}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;提取公因式的优化原理是推迟分支, 减少重复匹配, 若是匹配失败能更早的Backtracking.&lt;/p&gt;&lt;p&gt;该优化的实现亦并不复杂, 只需要检查每一条分支的前缀即可, 若是相同则进行合并.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Capture group classification&lt;/h2&gt;&lt;p&gt;对于捕获组来说, 可以依据是否在分支内分成两类, 对于不在分支上的捕获组, 我们可以直接使用一个全局数组来保存其捕获结果, 因为其与路径的选取无关, 因此无需保存在状态内. 对于在分支上的捕获组则需要在状态内保存捕获数据. 其中对数组的访问的内存效率是要高于访问状态的, 因此这类优化可以提高内存效率.&lt;/p&gt;&lt;p&gt;该优化的实现并不复杂, 只需要生成NFA后检查捕获组是否在分支内即可. 另外若支持递归匹配还需要考虑该捕获组是否在某个递归模式内, 因为递归模式的分支是隐含在状态内的栈上的.&lt;/p&gt;&lt;p&gt;另外对于在递归模式内的捕获组需要做额外的分析, 例如 &lt;equation&gt;\texttt{^((.)((?1)|)\2)\$}&lt;/equation&gt; , 其中在递归中捕获组3不需要记录, 因为其在递归中没有被引用, 在递归结束后递归体内的所有捕获组将会被清空.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Capture group analysis&lt;/h2&gt;&lt;p&gt;正则表达式里的路径分析的作用类似于常量折叠, 作用与条件表达式上, 对于向后引用也有作用. 原理是检查当前路径下所有必定捕获的捕获组用以确定条件.&lt;/p&gt;&lt;p&gt;举例来说表达式 &lt;equation&gt;\texttt{\1(.)}&lt;/equation&gt; 必定失败, 因为捕获组1在向后引用时未被捕获, 对于这种情况可在路径的字节码最后添加上一个 &lt;equation&gt;\texttt{halt}&lt;/equation&gt; 指令配合下面的Halt path elimination优化使用. &lt;/p&gt;&lt;p&gt;使用全局数组保存捕获结果依赖于此优化, 否则在Backtracking后数组中会留下前一状态的捕获结果, 若正好当前状态在完成捕获前引用了该捕获将会导致意料之外的结果.&lt;/p&gt;&lt;p&gt;另外的一个例子是 &lt;equation&gt;\texttt{(.)(?(1)a|b)}&lt;/equation&gt; 将会被优化成 &lt;equation&gt;\texttt{(.)a}&lt;/equation&gt; 因为在进行条件判断时捕获组1已经完成匹配了, 因此该条件表达式恒真.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Subroutine inline&lt;/h2&gt;&lt;p&gt;在正则表达式中, 对于调用Subroutine可以使用类似于C语言中的inline优化方法把被调用的模式inline到调用处, 优点是消除了一次 &lt;equation&gt;\texttt{call}&lt;/equation&gt; 与 &lt;equation&gt;\texttt{return}&lt;/equation&gt; 同时可以结合上下文环境做例如lookahead分析, Capture group analysis等的优化, 同时也利于Memorization. &lt;/p&gt;&lt;p&gt;举例如下:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{(a+).(?1)}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中 &lt;equation&gt;\texttt{(?1)}&lt;/equation&gt; 调用了模式 &lt;equation&gt;\texttt{a+}&lt;/equation&gt; , 在inline后表达式为 &lt;equation&gt;\texttt{(a+).a+}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;inline是相当常见的优化技术了, 这里不做赘述.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Recursive unfold&lt;/h2&gt;&lt;p&gt;对递归函数就行展开类似于Subroutine inline, 将最底层的递归调用展开, 好处也是于inline类似的. 值得注意的是递归的展开条件更严格, 调用递归模式在自身内只出现一次时进行展开, 否则展开的字节码将呈指数级暴涨.&lt;/p&gt;&lt;p&gt;举例如下, 匹配闭合的大括号:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{\{((?R)|)\}}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中 &lt;equation&gt;\texttt{(?R)}&lt;/equation&gt; 调用了整个模式自身, 在展开一次后表达式为 &lt;equation&gt;\texttt{\{(\{(?:(?R)|)\}|)\}}&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;注意此处展开的捕获组将会被消去(由于其在递归模式中).&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Halt path elimination&lt;/h2&gt;&lt;p&gt;字节码中有一种路径是永远不会成功匹配的, 这个时候可以将其分支削去, 举例来说:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split 1, 3}\\ &amp;amp;\texttt{1 halt}\\ &amp;amp;\texttt{2 match a}\\ &amp;amp;\texttt{3 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中 &lt;equation&gt;\texttt{halt}&lt;/equation&gt; 表示无条件匹配失败, 这时候 &lt;equation&gt;\texttt{split 1, 3}&lt;/equation&gt; 可以削去, 优化后的字节码如下:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 match a}\\ &amp;amp;\texttt{1 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Fold control flow&lt;/h2&gt;&lt;p&gt;这个是非常常见的指令层级的优化了, 举例来说对于表达式 &lt;equation&gt;\texttt{a|b|c}&lt;/equation&gt; , 若不进行分支合并生成的字节码如下:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split 1, 6}\\ &amp;amp;\texttt{1 split 2, 4}\\ &amp;amp;\texttt{2 match a}\\ &amp;amp;\texttt{3 jmp 5}\\ &amp;amp;\texttt{4 match b}\\ &amp;amp;\texttt{5 jmp 7}\\ &amp;amp;\texttt{6 match c}\\ &amp;amp;\texttt{7 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;第三行的 &lt;equation&gt;\texttt{jmp 5}&lt;/equation&gt; 可以优化为 &lt;equation&gt;\texttt{jmp 7}&lt;/equation&gt; . 连续跳转可以合并为单个跳转. 同样地 &lt;equation&gt;\texttt{split}&lt;/equation&gt; 也可以做这样的优化, 例如 &lt;equation&gt;\texttt{a||c}&lt;/equation&gt; 中的&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split 1, 6}\\ &amp;amp;\texttt{1 split 2, 4}\\ &amp;amp;\texttt{2 match a}\\ &amp;amp;\texttt{3 jmp 6}\\ &amp;amp;\texttt{4 jmp 6}\\ &amp;amp;\texttt{5 match c}\\ &amp;amp;\texttt{6 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中第二行 &lt;equation&gt;\texttt{split 2, 4}&lt;/equation&gt; 可以优化为 &lt;equation&gt;\texttt{split 2, 6}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Dead code elimination&lt;/h2&gt;&lt;p&gt;这个也是非常常见的指令层级的优化了, 继续沿用上面的例子&lt;equation&gt;\texttt{a||c}&lt;/equation&gt; , 进一步执行死代码消除后便是:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} &amp;amp;\texttt{0 split 1, 2}\\ &amp;amp;\texttt{1 match a}\\ &amp;amp;\texttt{2 accept} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这个优化实现也很简单, 这里不做赘述.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;JIT/AOT&lt;/h2&gt;&lt;p&gt;请参阅: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/24458116&quot;&gt;正则表达式与AOT编译&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;另外还有一些优化技术比如条件分支, 分支重排, 以及更细致的分支合并与跳转我还没来得及实现与试验, 等以后有机会再向大家做更多的介绍, 另外JIT/AOT还没有真正实现好.&lt;/p&gt;&lt;p&gt;这篇文章主要关注的优化技术, 具体的特性实现没怎么讲, 要是大家有兴趣我再写篇文章慢慢讲, 特别是一下丧心病狂的特性应该怎么做.&lt;/p&gt;&lt;p&gt;以上的所有优化技术均在我的千雪(ちゆき, Chiyuki)正则表达式引擎里实现了, 感兴趣的小伙伴欢迎来看看呀(源码一共有13000多行, 用C++17写哒, 如果需要测试代码或显示字节码的代码请告诉我):&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://hcc.trilines.net/regex/&quot;&gt;Chiyuki Regex&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;千雪支持的特性可以去&lt;a href=&quot;http://hcc.trilines.net/regex/syntax.html&quot;&gt;syntax reference&lt;/a&gt;里看看喔(基本上环视, 捕获/引用, 命名捕获, 条件匹配, 原子组, 递归匹配都支持), 我是将她作为通用引擎设计的, 尽可能多支持一些拓展. 其中由于引擎的设计支持一些非常丧心病狂的特性, 比如无限制的环视, 你甚至可以在环视内部使用嵌套循环与递归. 而且递归也不像PCRE那样是原子性的, 这意味着你可以跨递归层进行匹配. 由于我比较笨, 在这种尤其丧心病狂的特性下想不出什么很好的test case, 又没有别的引擎来做对照, 所以不知道对不对, 有没有bug.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;说了那么多优化, 我想小伙伴们肯定会好奇她的性能怎么样, 网页上的benchmark是很久以前的版本啦, 新的跑得更快一些. 现在的千雪大概跑得比非JIT的PCRE快一点(等我把JIT/AOT做出来再和你比JIT), 比Boost快两点, 将来还会更快哒. 当然啦这只是match的性能. 我没有针对search做特别的优化, 所以search在一些情况下被PCRE吊打了呀哈哈. 等我有空给大家补上新的测试数据(评论区里有3个简单的test cases对比).&lt;/p&gt;&lt;p&gt;她的缺点非常明显, 就是编译性能非常糟糕, 我想大家应该都能想到, 毕竟要跑那么多躺分析, 不过带来的好处也是有哒, 那就是很容易做进一步的去抽象生成native code, 也就是AOT编译啦.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我觉得她还是蛮快的, 当然只是在我的机子上, 所以不知道是不是真的呢?&lt;/p&gt;&lt;p&gt;最后谢谢大家观看喵~&lt;/p&gt;</description>
<author>梨梨喵</author>
<guid isPermaLink="false">2018-01-13-32896848</guid>
<pubDate>Sat, 13 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>一招鲜，吃遍天</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-01-06-32677377.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32677377&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在Haskell等语言中，有datatype generic的概念：对于各种各样的ADT，都可以表示成一系列的Sum type 跟 Product type（因为这是ADT的定义），所以理论上，只要你能处理ADT的通用定义，你就能写一个对所有ADT适用的函数。其实这就是当你写deriving Show/Eq/Ord的时候发生的情况。generic，又称polytypic programming，就是把这理论变成现实的特性。注意这跟type generic是两码事。&lt;/p&gt;&lt;p&gt;这里面的Notable Work包括Scrap Your Boilerplate：把一定的类型信息塞到运行时，（Typable），然后就可以对某个类型做一种东西，而其他类型不变。然后可以写个高阶函数，对该类型做action，其他类型（wrapper，比如list/sum/either/whatever）就默认map进去，这样就可以给[Either [Double] Double]之类的type里面的所有Double翻倍，或者加起来返回。&lt;/p&gt;&lt;p&gt;GHC.generic做的是另外的东西，把一个类型表现成Sum type/Product type/Metadata（我们称作Rep），然后所有ADT都可以转化成这类型。然后加上把某类型变成它Rep的方法，就可以写function on all ADT，然后也可以写deriving等&lt;/p&gt;&lt;p&gt;True Sum Of Product就在GHC.generic上面做了层抽象，不用ADT来表示Rep，而是表示成[[*]] （类型的列表的列表）。然后有多参Product/Sum (可以想象成NProduct :: [*] -&amp;gt; *，其实具体情况复杂点），就可以直接组合/Map/Fold Product/Sum来完成generic programming，而无需在GHC.generic中递归，因为Sum type里面可能有Product type，然后里面再有Sum type。。。而这在True Sum Of Produt中不可能发生&lt;/p&gt;&lt;p&gt;然后还有Generic Generic Programming，因为有很多套Generic Library，每套都不一样，所以就搞出了个东西unify之。。。什么鬼&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;a href=&quot;https://wiki.haskell.org/Research_papers/Generics&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Generic Paper合集&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>脚本少女魔理沙</author>
<guid isPermaLink="false">2018-01-06-32677377</guid>
<pubDate>Sat, 06 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>萌萌的忙忙的小河狸</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-01-05-32664058.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32664058&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3305ab08851a89a08a55df6ecf9f1c42_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;题图出处：&lt;a href=&quot;https://vancoolver.ca/310341&quot;&gt;都怪冬天太长：加拿大“国宝”河狸被卡在栏杆&lt;/a&gt;&lt;/blockquote&gt;&lt;h2&gt;为什么河狸这么萌&lt;/h2&gt;&lt;p&gt;我们不知道为什么河狸这么萌，但是我们更加不知道为什么河狸这么……忙。它太忙了，所以它可能是世界上最忙、最Busiest的……的什么来着？图灵机。函数。Whatever。&lt;/p&gt;&lt;p&gt;Busy Beaver Function，记作BB(n)，是这样子的一个Function。给定输入n，它输出的值是具有n个状态的图灵机，在停机之前所能够在纸带上写下的“1”的最大的个数，并且这些1之间没有任何空隙。还有另外一种定义则直接定义它&lt;b&gt;输出的值代表n个状态的图灵机停机之前所走出的最大步数&lt;/b&gt;。我们先采用采用后者吧。&lt;/p&gt;&lt;p&gt;只有一个状态的图灵机，只会在1步以后停机——或者不停机；于是我们说，BB(1) = 1。两个状态的图灵机呢？4。BB(3) = 21。BB(4) = 107。但是BB(5) &amp;gt;= 47176870……&lt;/p&gt;&lt;h2&gt;累瘫了的小河狸&lt;/h2&gt;&lt;p&gt;具有n个状态的、满足BB(n)的计算条件的图灵机被我在这里叫做河狸机。这只河狸忙到什么程度呢……你可以利用它去&lt;b&gt;判断停机问题&lt;/b&gt;。因为它是所有的图灵机伙伴里面最忙的小河狸，所以不可能有什么图灵机比它还要忙。所以，在一只图灵机旁边放一只有相同状态个数的小河狸机。在小河狸累瘫（停机）以后，如果旁边的图灵机还没有停机的话，那么就表明那只图灵机一定不会停机——因为我们已经知道了n个状态的图灵机如果能够停机的话，那么它最多会走多少步。&lt;/p&gt;&lt;p&gt;再从头到尾看一次。如果我们能够计算BB函数，那么我们就能够判断停机问题。反过来说，计算小河狸的函数是，&lt;/p&gt;&lt;p&gt;不存在的。&lt;/p&gt;&lt;h2&gt;火星人和小河狸&lt;/h2&gt;&lt;p&gt;为什么我们要讨论火星人这种东西……&lt;/p&gt;&lt;p&gt;好吧，我想要问的是，我们现在有这样子的一个问题。我们有这样子的一个函数Mars，如果它知道火星上有火星人的话，那么它就会输出1；但是如果它知道火星上没有火星人的话，那么它就会输出0。问这个问题是不是可以计算的？答案是……可以，但是我们压根就不需要知道火星上有没有火星人。我们知道这个函数Mars只会输出0和1中的其中一个，所以它的语言是&lt;b&gt;有限&lt;/b&gt;的，有限的语言都是可计算的。或者说，一个函数输出的所有可能是有限的，那么它就一定是可计算的（枚举所有的答案即可）；但是一个函数的输出的所有可能如果是一个无限的集合，那么它未必可计算。&lt;/p&gt;&lt;p&gt;以及，Mars(x) or NOT(Mars(x))的值一定是1。如果存在一个判断停机问题的函数HALT的话，HALT(x, a) or NOT(HALT(x, a))的值也一定是1。（为什么我要写成HALT(x, a)而不是HALT(x)？）&lt;/p&gt;&lt;p&gt;那么下面这个呢？&lt;/p&gt;&lt;p&gt;&lt;equation&gt;M_{ar-ver} = \frac{1}{BB(1)} + \frac{1}{BB(2)} + \frac{1}{BB(3)}...&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;为了让“可计算”在这里的定义更明确一点，也因为S是一个实数的缘故。是否存在一个算法，对于输入k，输出一个有理数M&#39;，使得|M - M&#39;| &amp;lt;= 1/k？&lt;/p&gt;&lt;h2&gt;忙忙的小河狸&lt;/h2&gt;&lt;p&gt;在给出这个答案之前，我们先留意一下另外一只小河狸：啃纸带的小河狸。它想要在纸带上留下最多的、连续的1，把纸带给啃得干干净净。这只小河狸太忙了，以至于我们可能还是会惊讶于为什么BB(5)看起来这么大……以及对于更大的n，总觉的那都是那堆数学家无聊蛋疼的产物。。。小河狸是如此地忙，以至于它比任何图灵机都要忙……比任何可计算的函数都要忙……&lt;b&gt;因此不可计算&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;好吧，为什么这样子说？虽然知道了它不可计算，但是为什么它比任何可计算的函数都要忙？&lt;/p&gt;&lt;p&gt;好，那么我们有一个任意的可计算函数f。现在我们要构造另外一个可计算函数：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;g(x) = \sum_{i=1}^{x}[f(i) + i^2]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这个函数显然可计算。&lt;/p&gt;&lt;p&gt;从g(x)的定义，我们立刻有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;g(x) &amp;gt;= f(x)；&lt;/li&gt;&lt;li&gt;g(x) &amp;gt;= x^2；&lt;/li&gt;&lt;li&gt;g(x+1) &amp;gt;= g(x)。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;假设有一台计算函数g的图灵机G，它具有q个状态，并且会让一个写了x+1那么多个1的纸带，变成g(x)+1那么多的纸带。从这个图灵机，我们要构造另外一个图灵机——&lt;/p&gt;&lt;p&gt;&lt;equation&gt;T = P^{x+1}.G.G&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;虽然说定义看起来很奇怪，但是那只是因为我们不知道P^x+1是什么。P^x+1是一个打印机，它可以没有小河狸那么忙，但是它一定要啃够x+1那么多的1（在纸带上留下这么多的一串1，然后停机）。所以上面的T的意思是，&lt;/p&gt;&lt;ul&gt;&lt;li&gt;先用打印机在纸带上留下x+1那么多的1；&lt;/li&gt;&lt;li&gt;然后用一次G，将x+1那么多的1改成g(x)+1那么多的1；&lt;/li&gt;&lt;li&gt;然后再用一次G，将g(x)+1那么多的1改成最后的g(g(x))+1那么多……的1。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;哇，真是多死了。&lt;/p&gt;&lt;p&gt;一个打印机打印x+2个1的话，可以被一个具有x个状态的图灵机构造出来。（为什么？）所以，T的内部状态个数是x+q+q（为什么？）。所以，&lt;/p&gt;&lt;p&gt;&lt;equation&gt;BB(x + 2q) \ge g(g(x)) + 1&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;因为我们构造出来的这个T在纸带上啃了那么多1，所以小河狸一定要比它……不对，至少要比它忙。&lt;/p&gt;&lt;p&gt;但是这有什么问题呢？&lt;/p&gt;&lt;ul&gt;&lt;li&gt;g(x) &amp;gt; x + 2q，因为g(x) &amp;gt;= x^2。&lt;/li&gt;&lt;li&gt;g(x + 2q) &amp;gt;= f(x + 2q)，因为g(x) &amp;gt;= f(x)。&lt;/li&gt;&lt;li&gt;BB(x + 2q) &amp;gt; g(x + 2q)，因为BB(x + 2q) &amp;gt;= g(g(x)) + 1（再具体点？）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;或者说，BB(x + 2q) &amp;gt; f(x + 2q)……或者说BB(x) &amp;gt; f(x)。&lt;/p&gt;&lt;p&gt;所以小河狸比任何图灵机都忙。你们有没有在现实中看到过这么忙的一个小河狸？&lt;/p&gt;&lt;h2&gt;不忙，但是依然萌&lt;/h2&gt;&lt;p&gt;虽然说小河狸是因为忙所以萌，但是卖萌并不需要忙。&lt;/p&gt;&lt;p&gt;花栗鼠(Chipmuck)机是这样子的一只函数：CM(n) = “n个状态的图灵机中可以构成打印机的图灵机数目”，那么虽然说这个函数并不忙，但是依然不可计算。&lt;/p&gt;&lt;p&gt;令BD(n, m)表示“n个状态的、m步内停机的图灵机中可以构成打印机的图灵机数目”（Busy Down），又令&lt;/p&gt;&lt;p&gt;&lt;equation&gt;S_{uper}BB(n) = min_n(CM(n) - BD(n, m) = 0)&lt;/equation&gt; ，或者说，让CM(n) - BD(n, m) = 0的最小的n。首先，BD显然是可计算的（为什么？）；所以如果CM也是可计算的，则SBB也是可计算的。但是SBB不可计算，因为SBB(n) &amp;gt;= BB(n)……等等，这个SBB的定义就是那一只“n个状态内最大的行动步数”的小河狸！真是萌萌哒。&lt;/p&gt;&lt;p&gt;萌性我们证完了，但是花栗鼠并不忙。因为一个具有n个状态的图灵机的数目是有限的，具体地，它的数目是 &lt;equation&gt;(6n)^{2n}&lt;/equation&gt; 。所以我们永远地有， &lt;equation&gt;CM(n) \le (6n)^{2n}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;Super (Super Busy) Beaver&lt;/h2&gt;&lt;p&gt;如果我们已经计算出了BB(1), BB(2), ……BB(n-1)，并且之前提到的S是可计算的，那么下面的这个一定是可计算的：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;M_n = \frac{1}{BB(n)} + \frac{1}{BB(n+1)} + ...&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;因为每一个BB(n)都比BB(n-1)要大，易知M_n是收敛的，也就是说，有界（什么？没学过高数？）。于是我们就也可以计算出1/(M_n)的上界。但是M_n的第一项就是1/BB(n)，并且后面每一项都比前面的一项要小很多，所以如果我们能计算出1/(M_n)的上界，我们就可以计算出1/BB(n)和BB(n)的界……意味着能计算BB(n)。&lt;/p&gt;&lt;p&gt;但是小河狸是不可计算的。&lt;/p&gt;&lt;p&gt;所以BB(n)是不可计算的，所以BB(n-1)是不可计算的，所以……所以我们的前提即便成立，即便我们知道BB(1) = 1，我们也知道，M_n是不可计算的，也知道……M是不可计算的。&lt;/p&gt;&lt;p&gt;所以M也和小河狸一样萌。&lt;/p&gt;&lt;p&gt;于是我们发现了一个很萌的有理数，很多有理数都没有这么萌。&lt;/p&gt;&lt;p&gt;你有见过这么萌的有理数吗？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;参考：&lt;/p&gt;&lt;p&gt;（习题）Scott Aaronson. 《Quantum Computing Since Democritus》&lt;/p&gt;&lt;p&gt;（习题）Michael Sipser. 《计算理论导引》&lt;/p&gt;&lt;p&gt;张鸣华. 《可计算性理论》&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;－－－－－－－－&lt;/p&gt;&lt;p&gt;注：Beaver是Beaver，但是Chipmuck只在这里是Chipmuck。&lt;/p&gt;&lt;p&gt;最后的最后，有人知道为什么我会说g(x)显然可计算嘛？&lt;/p&gt;</description>
<author>钟狸</author>
<guid isPermaLink="false">2018-01-05-32664058</guid>
<pubDate>Fri, 05 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>JavaScript实现ZLOGO: 用语法树实现多层循环</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-01-03-32571516.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32571516&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;照例先上演示弱效果图. 演示地址&lt;a href=&quot;http://codeinchinese.com/%E5%9C%883/%E5%9C%883.html&quot;&gt;照旧&lt;/a&gt;:&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-86c83e8129d192b4f22b8fa8d0ad4b40_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;117&quot; data-rawheight=&quot;117&quot;&gt;&lt;p&gt;代码如下:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;开始
  循环4次
    循环4次
      前进50
      左转90度
    到此为止
  右转90度
  到此为止
结束&lt;/code&gt;&lt;p&gt;如上文&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31870155&quot;&gt;JavaScript实现ZLOGO子集: 测试用例&lt;/a&gt;末尾所言, 此文用Antlr进行代码分析生成语法树. 再通过语法树生成p5js绘制代码.&lt;/p&gt;&lt;p&gt;Antlr支持两种代码分析方法, Visitor(监听者)和Visitor(访问者). SO上的问答&lt;a href=&quot;https://stackoverflow.com/questions/20714492/antlr4-listeners-and-visitors-which-to-implement&quot;&gt;Antlr4 Listeners and Visitors - which to implement?&lt;/a&gt;大致说明了区别. 基于有限的实践, 用Visitor方法生成语法树似乎在实现上更加方便. 尤其相比&lt;a href=&quot;http://ivanyu.me/blog/2014/09/13/creating-a-simple-parser-with-antlr/&quot;&gt;Creating a simple parser with ANTLR&lt;/a&gt;一文中使用监听者+栈来构建语法树.&lt;/p&gt;&lt;p&gt;Antlr生成工具默认不生成Visitor, 添加-visitor参数后可以生成:&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;java -cp &quot;antlr-4.7-complete.jar:$CLASSPATH&quot; org.antlr.v4.Tool -Dlanguage=JavaScript -visitor 圈3.g4&lt;/code&gt;&lt;p&gt;下面是&quot;定制访问器.js&quot;中构建语法树的部分, 看起来比实现前想的简单. 默认生成的&#39;圈3Visitor&#39;中, visitXX方法实现都是&quot;this.visitChildren(ctx)&quot;, 但那样会把所有的子节点返回值放进数组, 形成(至少这里是)多余的层次:&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;定制访问器.prototype.visit程序 = function(上下文) {
  语法树 = {子节点: this.visit(上下文.声明())};
  return 语法树;
};

定制访问器.prototype.visit循环 = function(上下文) {
  return {
    类型: &#39;循环&#39;,
    次数: parseInt(上下文.T数().getText()),
    子节点: this.visit(上下文.声明())};
};

定制访问器.prototype.visit声明 = function(上下文) {
  return this.visit(上下文.getChild(0));
};

定制访问器.prototype.visit转向 = function(上下文) {
  var 方向 = 上下文.T转向().getText();
  var 角度 = parseInt(上下文.T数().getText()) * (方向 === &quot;左&quot; ? 1 : -1);
  return {类型: &#39;转向&#39;, 参数: 角度};
};

定制访问器.prototype.visit前进 = function(上下文) {
  return {类型: &#39;前进&#39;, 参数: parseInt(上下文.T数().getText())};
};&lt;/code&gt;&lt;p&gt;上面的源码生成语法树大致如下所示. 实现上还有很多需要改进的, 比如&#39;前进&#39;和&#39;转向&#39;现在是两种&#39;类型&#39;, 但应该是一种; 根节点类型不应为空; 等等:&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-64cffeb88c144dc65304f5d678d02849_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;412&quot; data-rawheight=&quot;257&quot;&gt;&lt;p&gt;下面是&quot;编译.js&quot;中基于语法树生成指令列表的方法, 之后就与之前一样根据指令列表生成p5js绘制函数(代码也不用修改).&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;function 生成指令序列(节点) {
  var 指令序列 = [];
  // TODO: 根节点类型不应为空
  if (!节点.类型) {
    var 声明节点 = 节点.子节点;
    for (var i = 0; i &amp;lt; 声明节点.length; i++) {
      Array.prototype.push.apply(指令序列, 生成指令序列(声明节点[i]));
    }
  } else if (节点.类型 == &quot;循环&quot;) {
    var 指令序列 = [];
    for (var i = 0; i &amp;lt; 节点.次数; i++) {
      Array.prototype.push.apply(指令序列, 生成指令序列({子节点: 节点.子节点}));
    }
  } // TODO: 修改类型统一为&#39;指令&#39;
  else if (节点.类型 == &quot;前进&quot; || 节点.类型 == &quot;转向&quot;) {
    return [{名称: (节点.类型 == &quot;前进&quot; ? 常量_指令名_前进 : 常量_指令名_转向), 参数: 节点.参数}];
  }
  return 指令序列;
}&lt;/code&gt;&lt;p&gt;修改相应测试用例, 以及清理不再使用的监听器代码后. 代码已从visitor分支(&lt;a href=&quot;https://github.com/program-in-chinese/quan3/tree/visitor&quot;&gt;program-in-chinese/quan3&lt;/a&gt;)合并到master.&lt;/p&gt;</description>
<author>吴烜</author>
<guid isPermaLink="false">2018-01-03-32571516</guid>
<pubDate>Wed, 03 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>从计算复杂度往上往前（和两个没什么卵用的定理）</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-29-32476294.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32476294&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;在P和NP出现之前计算复杂性是怎么度量的？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;SPACE(f(n))，TIME(f(n))……这是在Scott Aaronson在&lt;a href=&quot;https://www.scottaaronson.com/democritus/&quot;&gt;《Quantum Computing Since Democritus》&lt;/a&gt;中PaleoComplexity一章里面所给出的答案。再翻翻其它的书，我们会得到的答案是，P=DTIME(n^c)。EXP=DTIME(2^(n^c))。（DTIME的意思是对于确定性图灵机的时间，Deterministic）NP的定义是“被非确定图灵机（Non-Deterministic）在多项式时间内解决的问题”，所以是NTIME(n^c)。&lt;/p&gt;&lt;p&gt;所以这真的就是Complexity的源头嘛？那么Complexity和Recursion Theory之间的关系究竟是什么呢？&lt;/p&gt;&lt;p&gt;这篇文章很短，因为我看书的速度比我打字的速度要快很多，所以我想偷懒（逃）不想写那么多；以及深觉文笔乏力，光看着一堆证明过程就已经觉得很爽很发光。&lt;/p&gt;&lt;p&gt;怀着很憋屈又很尊敬的心情去读书，书中的定理自然是不止那么多，很想安利人来入坑，对，这篇文章是一篇很憋屈很憋屈的安利文_(:з」∠)_&lt;/p&gt;&lt;p&gt;－－－－－－－－&lt;/p&gt;&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Blum_axioms&quot;&gt;Blum公理&lt;/a&gt;和&lt;a href=&quot;http://port70.net/~nsz/articles/classic/blum_complexity_1976.pdf&quot;&gt;计算复杂性的尺度&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;equation&gt;\{\varphi_i\}&lt;/equation&gt; 是所有的&lt;a href=&quot;https://en.wikipedia.org/wiki/%CE%9C-recursive_function&quot;&gt;递归函数&lt;/a&gt;（以及mu是一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Theory_of_descriptions&quot;&gt;摹状词&lt;/a&gt;）的枚举，其中i是第i个递归函数所对应的编号（对应到图灵机上就是哥德尔编号i所对应的图灵机）， &lt;equation&gt;\{\Phi_i\}&lt;/equation&gt; 是一组递归函数的序列。称 &lt;equation&gt;\Phi&lt;/equation&gt; 是计算复杂性的尺度（意味着计算复杂性尺度也是一个函数），当且仅当以下两个条件被满足：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;equation&gt;\varphi_i(x)&lt;/equation&gt; 有值当且仅当 &lt;equation&gt;\Phi_i(x)&lt;/equation&gt; 有值；&lt;/li&gt;&lt;li&gt;特征函数K是一个完全递归函数： &lt;equation&gt;K(i, x, y) = \begin{equation} \left\{ \begin{array}{lr} 1 &amp;amp; \Phi_i(x) = y,\\ 0 &amp;amp; otherwise(例如无定义) \end{array} \right. \end{equation} &lt;/equation&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所以来看看所谓的&lt;b&gt;时间复杂度&lt;/b&gt;是怎么对应上来的嘛？&lt;/p&gt;&lt;p&gt;&lt;equation&gt;T_i(x) = \begin{equation} \left\{ \begin{array}{lr} y &amp;amp; 多带图灵机\varphi_i(x)有值且计算步数为y,\\ undefined &amp;amp; otherwise \end{array} \right. \end{equation} &lt;/equation&gt; &lt;/p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Multitape_Turing_machine&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Multitape Turing Machine&lt;/a&gt;&lt;blockquote&gt;（问：证明这个“尺度”是一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_function&quot;&gt;完全递归函数&lt;/a&gt;，如果追求更完整的话，证明存在一个K与这个尺度对应）&lt;br&gt;（Extra Credit：证明&lt;b&gt;量子计算机&lt;/b&gt;的时间复杂度类是存在合法尺度的）&lt;/blockquote&gt;&lt;p&gt;那么&lt;b&gt;空间复杂度&lt;/b&gt;呢？&lt;/p&gt;&lt;p&gt;&lt;equation&gt;T_i(x) = \begin{equation} \left\{ \begin{array}{lr} y &amp;amp; 脱线图灵机\varphi_i(x)有值且工作区使用的格子数为y,\\ undefined &amp;amp; otherwise \end{array} \right. \end{equation} &lt;/equation&gt; &lt;/p&gt;&lt;blockquote&gt;（问：同上）&lt;/blockquote&gt;&lt;h2&gt;计算复杂度尺度的一些性质&lt;/h2&gt;&lt;p&gt;&lt;b&gt;为什么“如果计算不会太复杂的话，函数的值就不会太大”&lt;/b&gt;&lt;/p&gt;&lt;p&gt;定理：存在完全递归函数h，使得 &lt;equation&gt;\forall i \ h(x, \Phi_i(x) \ge \varphi_i(x))\ a.e.(almost\ everywhere)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;证明：令&lt;/p&gt;&lt;p&gt;&lt;equation&gt;H(i, x, y) = \begin{equation} \left\{ \begin{array}{lr} \varphi_i(x) &amp;amp; \Phi_i(x) = y\\ 1 &amp;amp; otherwise \end{array} \right. \end{equation} &lt;/equation&gt; ，&lt;/p&gt;&lt;p&gt;又令&lt;/p&gt;&lt;p&gt;&lt;equation&gt;h(x, y) = \mathop{max}_{i \le x}H(i, x, y)&lt;/equation&gt;，&lt;/p&gt;&lt;p&gt;则按照&lt;a href=&quot;https://en.wikipedia.org/wiki/Primitive_recursive_function&quot;&gt;原始递归函数&lt;/a&gt;的定义，这两个函数都是完全递归函数。令 &lt;equation&gt;x \ge i&lt;/equation&gt; 且&lt;equation&gt;\varphi_i(x)&lt;/equation&gt; 定义，则 &lt;equation&gt;h(x, \Phi_i(x)) \ge H(i, x, \Phi_i(x)) = \varphi_i(x)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;为什么“一个算法可以有任意复杂（而非简单）的算法”&lt;/b&gt;&lt;/p&gt;&lt;p&gt;定理：f、h为两个完全递归函数。则存在f的号码（如哥德尔编号或者康托尔的配对编号）使得 &lt;equation&gt;\Phi_j(x) \ge h(x)&lt;/equation&gt; 。f的号码的意思是计算函数f的图灵机。&lt;/p&gt;&lt;p&gt;证明：令&lt;/p&gt;&lt;p&gt;&lt;equation&gt;g(i, x) = \begin{equation} \left\{ \begin{array}{lr} f(x) &amp;amp; \Phi_i(x) &amp;gt; h(x)\\ 1 + \varphi_i(x) &amp;amp; otherwise \end{array} \right. \end{equation} &lt;/equation&gt; ，&lt;/p&gt;&lt;p&gt;则g是递归函数。那么，存在这样的函数q，使得：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{equation} \varphi_{q(i)}(x)\xlongequal{s-m-n定理}g(i, x) \end{equation}&lt;/equation&gt; ；&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Smn_theorem&quot;&gt;s-m-n定理&lt;/a&gt;还有一个名字，叫做参数化定理。接下来，又由&lt;a href=&quot;https://en.wikipedia.org/wiki/Kleene%27s_recursion_theorem&quot;&gt;递归定理&lt;/a&gt;，存在编号j使得 &lt;equation&gt;\varphi_{q(j)}(x)＝\varphi_{j}(x)&lt;/equation&gt; ，所以有&lt;/p&gt;&lt;p&gt;&lt;equation&gt;g(j, x) = \varphi_j(x) \ne 1+\varphi_j(x)&lt;/equation&gt; ，因此不可能有 &lt;equation&gt;\Phi_i(x) \le h(x)&lt;/equation&gt; ，因此j是f的号码。没错，到头回来，又是万恶的&lt;a href=&quot;https://en.wikipedia.org/wiki/Diagonal_method&quot;&gt;对角线&lt;/a&gt;。&lt;/p&gt;&lt;blockquote&gt;为什么两个定理不矛盾&lt;br&gt;（答案：...）&lt;/blockquote&gt;&lt;p&gt;－－－－－－－－&lt;/p&gt;&lt;p&gt;最后，真的以为计算复杂性的源头就到此为止了吗？&lt;/p&gt;&lt;p&gt;或许还会有下次更新以让这篇文章没有那么寒酸。。。&lt;/p&gt;&lt;p&gt;（嗷嗷嗷嗷嗷嗷嗷呜啊_(:з」∠)_）&lt;/p&gt;</description>
<author>钟狸</author>
<guid isPermaLink="false">2017-12-29-32476294</guid>
<pubDate>Fri, 29 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>APL/J 安利：三次方求和公式是什么？ (J)</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-29-32467987.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32467987&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安利一个 QQ 群：欢迎加入 APL Programming，群号码：332833095。欢迎 APL，J 等好棒的这一系列编程语言讨论。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们来解决这个问题：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\\ 1^3+2^3+\dots+n^3=\ ?&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这个的答案看起来显然是个 4 次的多项式，于是我们试着代入 &lt;equation&gt;n=0\dots4&lt;/equation&gt; 分别算出结果，进行多项式插值。下面的互动的 log，你看爽不爽啊？&lt;/p&gt;&lt;p&gt;没体现出优势来？那你用你最喜欢的语言写一下相同的功能，一起来比较一下优劣之处呗。&lt;/p&gt;&lt;code lang=&quot;j&quot;&gt; NB. 5 以下的自然数
   i. 5
0 1 2 3 4

   NB. 5 以下自然数的三次方
   ] cubes =. (i. 5) ^ 3
0 1 8 27 64

   NB. =. 表示定义变量
   NB. ] 表示显示结果（否则定义的变量默认不会输出）

   NB. 我们定义了一个变量
   cubes
0 1 8 27 64

   NB. 乘方表
   ^/~ i. 3
1 0 0
1 1 1
1 2 4

   NB. 这样看着更清楚
   ^table~ i. 3
+-+-----+
|^|0 1 2|
+-+-----+
|0|1 0 0|
|1|1 1 1|
|2|1 2 4|
+-+-----+

   NB. 插曲：解线性方程
   NB. 2x + 3y = 7
   NB. 6x - 7y = 10

   NB. 矩阵
   &amp;gt; 2 3 ; 6 _7
2  3
6 _7

   NB. 这里的 _ 是负号的意思

   NB. 解这个方程
   7 10 %. (&amp;gt; 2 3; 6 _7)
2.46875 0.6875

   NB. 用分数表示的精确解 (两边参数使用 x: 来转换为高精度有理数值)
   (x:7 10) %. (x: &amp;gt; 2 3; 6 _7)
79r32 11r16

   NB. xry 表示 x/y

   NB. 5 以下自然数的三次方的前缀和
   +/\ (i. 5) ^ 3
0 1 9 36 100

   NB. 参考
   +/\ 1 2 5 _7 3 4
1 3 8 1 4 8

   NB. 5 以下乘方表
   ^/~ i. 5
1 0  0  0   0
1 1  1  1   1
1 2  4  8  16
1 3  9 27  81
1 4 16 64 256
   
   NB. 解方程求多项式插值
   ] res =. (+/\ (i. 5) ^ 3) %. ^/~ i. 5
_1.00017e_13 3.5314e_12 0.25 0.5 0.25

   NB. 精确解
   ] res =. (+/\ (x:i. 5) ^ 3) %. ^/~ x:i. 5
0 0 1r4 1r2 1r4
 
   NB. 多项式求值
   res p. 12
6084
 
   NB. 0^3 + 1^3 + ... + 12^3 = 6084
   +/ (i. 13)^3
6084

   NB. 验证得知结果正确&lt;/code&gt;&lt;p&gt;结果是&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\\ {1\over4}n^2+{1\over2}n^3+{1\over4}n^4&lt;/equation&gt; &lt;/p&gt;</description>
<author>dram</author>
<guid isPermaLink="false">2017-12-29-32467987</guid>
<pubDate>Fri, 29 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>怪名乱神</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-17-32085338.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32085338&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我想给大家介绍一门语言。&lt;/p&gt;&lt;p&gt;C*。&lt;/p&gt;&lt;p&gt;C*有什么特点呢？很著名很流行。&lt;/p&gt;&lt;p&gt;我们可以看看TIOBE Index：到2017年12月，这门语言的rating达到了30.965%以上，比Java，下一个最热的语言，高了一倍有余。&lt;/p&gt;&lt;p&gt;这门语言被广泛使用于各种领域：操作系统（Linux, Windows），分布式（Spark），深度学习（部分tensorflow），区块链（bitcoin），游戏引擎（Unity）。&lt;/p&gt;&lt;p&gt;同时，C*的方言包含C, C++, Java, C#等知名语言。&lt;/p&gt;&lt;p&gt;我们先从语法开始介绍：C*的一个程序，由多个声明组成。其中，一些声明属于函数声明，而一个函数又由多条语句组成。。。&lt;/p&gt;&lt;p&gt;是不是觉得很荒谬？C没有Class, C++没有垃圾回收，Java跟C#水火不容，为什么被认作同一语言？&lt;/p&gt;&lt;p&gt;而如果我告诉你，现实比这还魔幻呢？世界上有很多语言正被冠以‘C*’这样的名字，而这些语言中，毫无共通点？这些语言中，有的有静态类型，有的有动态类型，有的两个都有，有的GC，有的是为Arduino设计的，有的在JVM上，有的有Class，有的有Reflection，有的没有Assignment，有的基于Lambda Calculus，有的则不是，有的可以任意改自身语法，有的语法是二维的，是个表格，而不是线性的，而有的甚至自带GUI，是livecoding的鼻祖之一。。&lt;/p&gt;&lt;p&gt;而这些语言，通通被称作同一个语言：Lisp。&lt;/p&gt;&lt;p&gt;而更魔幻的在后面：于是，有很多人开始讨论，为啥这门语言没有取得主流化，为啥这门语言效率这么高。。。然后得出很多答案，其中一半的直接是错误的，如：&lt;/p&gt;&lt;blockquote&gt;Lisp是第二早的高级语言，所以XXX，所以效率很高&lt;/blockquote&gt;&lt;p&gt;最早的编程语言Plankalkül，是1942到1945设计的，然后Fortran也比任何被称为Lisp的语言早。就算我们取最乐观的时间，1946到1955之间差了10年，里面出现了各种语言，AutoCode, ShortCode, Flow Chart, Haskell Curry的语言。。。&lt;/p&gt;&lt;p&gt;不过上述问题是技术错误，下面的论证则更离谱：&lt;/p&gt;&lt;blockquote&gt;Lisp社区很分裂，大家无法合作，所以没有流行&lt;/blockquote&gt;&lt;p&gt;。。。Excuse Me？如果有一天，C, C++, Java, C#都衰落了，再也没有人用，是不是因为C*社区很分裂，C/C++/Java/C#，你任意选出一对，肯定在互捏？大家无法合作也是啊，Java自己有一套库，C#自己一套，C跟C++也是，这么分裂，不衰退才怪！&lt;/p&gt;&lt;p&gt;欲加之罪，何患无辞啊！本来就不是同一个语言，为啥要放一起论证，然后去吐槽大家之间不兼容？&lt;/p&gt;&lt;p&gt;在一推只是因为历史原因被称作一家族的语言之间，找共通点，然后去论证这些语言的兴衰，特性，适用范围。。。能找出啥有价值，nontrivial的insight才怪。&lt;/p&gt;&lt;p&gt;至于S表达式？Logo不用括号，Racket有2d syntax，也有infix expression, Common Lisp有reader macro。。。试问这些语言是不是Lisp?而JMC也说过我们应该往M表达式迁移，那是不是JMC 发现了Lisp的本质劣根性？我们也可以用argument by absurdity，论证C*这个词的合理性 - 有花括号跟分号的就是C*，C*成为世界上最主流语言，C*万岁！&lt;/p&gt;&lt;p&gt;&#39;Lisp&#39;，这个词，已经没有任何有价值的意义，早就该被废弃，或者仅仅指JMC在1950末造的一个语言。就如同C*这个词不应该被引入一样。&lt;/p&gt;&lt;p&gt;另：最后，我想吐槽小部分所谓的‘Lisp’ 厨。往往，当你问，‘Lisp有什么优势/值得学’的时候（我们先不吐槽这问题提得很糟糕，就如同你不会问为啥要学C*/C*有啥优势），会跳出大致如下的答案：‘大部分主流语言的特性，早在Lisp中存在。主流PL发展只不过是catch up 1960 Lisp。’&lt;/p&gt;&lt;p&gt;这回答并很具误导性。&lt;/p&gt;&lt;p&gt;因为1960的时候，JMC 的确公开了一个语言，但是这个语言没有macro，是dynamic scope（读作：没有符合lambda calculus的first class function），连special form quote也没有（取而代之的是一个atom，换句话说你要quote compound expression得手动把(A B)转成(pair A B)）。在1967年，影响了Smalltalk跟无数学计算机人士的Logo出世，而在1970年，Scheme借鉴了Algol，修复了dynamic scope，也有macro跟continuation。Common Lisp在1984诞生，又在1990带来了Common Lisp Object System，跟metaobject protocol。1994，racket诞生，又在2002带来了composable &amp;amp; compilable macro。在今年，则出现了Collapsing Tower of Interpreter，实现了看上去有无数个interpreter，并且可以到达任何一个interpreter，更改语义，最后再运行普通的代码（并且看到更改语义带来的change），也出现了Type System as Macro，可以用宏代表静态类型。&lt;/p&gt;&lt;p&gt;这些语言都很有价值，很多都值得看。&lt;/p&gt;&lt;p&gt;但是没有一门叫Lisp的，在1960，搞对了Lambda Calculus，拥有大量影响力，有各种现代语言特性(Continuation, Type, Reflection, Macro)，有各种库，然后只有7条规则的语言。&lt;/p&gt;&lt;p&gt;我希望大家在讨论/宣传这些语言之一的时候，明白自己是在说啥。想说历史影响，可以用Scheme，玩极简主义，可以用JMC的Lisp，讨论OO，上Common Lisp，用Type/Contract，搞Racket。而不是一棒子打死，认为这些语言之间有任何共通点。&lt;/p&gt;</description>
<author>脚本少女魔理沙</author>
<guid isPermaLink="false">2017-12-17-32085338</guid>
<pubDate>Sun, 17 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Ad Infinitum!</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2017-12-15-32045442.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32045442&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近读了一篇paper，Duplication and Partial Evaluation，讲的是一门很。。奇怪的语言，&lt;/p&gt;&lt;p&gt;这门语言，可以大致想象是有无数个interpreter，一个stack着一个，interpret下一个，在最下，则是被解释的用户输入的代码。&lt;/p&gt;&lt;p&gt;你可以更改各种built in function，或者打印出来。比如说，你可以更改第1层（第0层为用户代码，第n+1层解释第n层代码）的apply，输入值print一次，输出值print一次，这样就实现了简陋debugger了。又或者对第二层解释器这样做，运行代码的时候就知道内部执行了啥&lt;/p&gt;&lt;p&gt;实现方法自然不能靠构造无限个interpreter，所以要先上laziness，按需增加，然后任何时刻，都有一个被解释的解释器去解释当下代码，然后有个被编译的解释器解释前一个解释器，这样就只有两轮。但是，这样，如果你更改n+2的代码，不会由n+1暴露到n层（换句话说n层看不出有啥区别），因为n层的时候，n+1层是被预编译的解释器执行，只有在n+1层看的到。这样，就顶多是两个编译器的开销。&lt;/p&gt;&lt;p&gt;‘顶多’，双重编译很疼，于是用了下Partial Evaluation，手动优化成一个编译器。&lt;/p&gt;&lt;p&gt;什么鬼啊这是。&lt;/p&gt;&lt;p&gt;可以在&lt;a href=&quot;http://io.livecode.ch/learn/readevalprintlove/black&quot;&gt;The reflective language Black&lt;/a&gt;试试看。&lt;/p&gt;</description>
<author>脚本少女魔理沙</author>
<guid isPermaLink="false">2017-12-15-32045442</guid>
<pubDate>Fri, 15 Dec 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
