<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Sat, 06 Oct 2018 02:23:51 +0800</lastBuildDate>
<item>
<title>用Control.Dsl代替Monad</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-10-05-46014989.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/46014989&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Control.Dsl&lt;/code&gt;为Haskell提供了一套工具集来创建“可扩展”的领域特定语言，定制DSL&lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块。&lt;/p&gt;&lt;p&gt;DSL &lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块可以包含来自不同作者提供的各种操作。每个操作可以定义为一个GADT，由&lt;code class=&quot;inline&quot;&gt;Dsl&lt;/code&gt;类型类来解释执行，既可以有副作用，也可以是纯函数。&lt;/p&gt;&lt;p&gt;DSL &lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块是个抽象的“脚本”，其依赖的类型类可以自动推断。因此，只要提供不同的类型类实例，数据结构和解释器实现都可以随之改变。&lt;/p&gt;&lt;p&gt;本文剩下部分将会介绍如何用&lt;code class=&quot;inline&quot;&gt;Control.Dsl&lt;/code&gt;创建一门可扩展DSL，以及可以切换的两个解释器。 文中所有代码都基于&lt;code class=&quot;inline&quot;&gt;control-dsl&lt;/code&gt;包，可以在&lt;code class=&quot;inline&quot;&gt;ghci&lt;/code&gt;中运行。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Getting started&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Dsl&lt;/code&gt;类型类提供了&lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;、 &lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;=&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;return&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;fail&lt;/code&gt;等操作，用来代替&lt;code class=&quot;inline&quot;&gt;Monad&lt;/code&gt;中的对应操作。 你可以使用&lt;code class=&quot;inline&quot;&gt;RebindableSyntax&lt;/code&gt;扩展来启用&lt;code class=&quot;inline&quot;&gt;Dsl&lt;/code&gt;版的定制&lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块。 &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :set -XRebindableSyntax
&amp;gt;&amp;gt;&amp;gt; import Prelude hiding ((&amp;gt;&amp;gt;), (&amp;gt;&amp;gt;=), return, fail)
&amp;gt;&amp;gt;&amp;gt; import Control.Dsl&lt;/code&gt;&lt;h2&gt;&lt;b&gt;DSL model&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果你要创建一门DSL来执行控制台的IO操作，你可以以GADT方式定义一些DSL中的基本操作：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; data MaxLengthConfig r a where MaxLengthConfig :: MaxLengthConfig r Int
&amp;gt;&amp;gt;&amp;gt; data GetLine r a where GetLine :: GetLine r String
&amp;gt;&amp;gt;&amp;gt; data PutStrLn r a where PutStrLn :: String -&amp;gt; PutStrLn r ()&lt;/code&gt;&lt;h2&gt;&lt;b&gt;DSL&lt;/b&gt; &lt;b&gt;&lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;&lt;/b&gt;语句块&lt;/h2&gt;&lt;p&gt;以上操作可以用于&lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
dslBlock = do
  maxLength &amp;lt;- MaxLengthConfig
  line1 &amp;lt;- GetLine
  line2 &amp;lt;- GetLine
  when (length line1 + length line2 &amp;gt; maxLength) $ do
    PutStrLn &quot;The input is too long&quot;
    fail &quot;Illegal input&quot;
  PutStrLn (&quot;The input is &quot; ++ line1 ++ &quot; and &quot; ++ line2)
  return ()
:}&lt;/code&gt;&lt;p&gt;以上&lt;code class=&quot;inline&quot;&gt;dslBlock&lt;/code&gt;函数利用刚定义的操作和Control.Dsl内置操作创建了一段DSL抽象脚本。&lt;/p&gt;&lt;p&gt;GADT操作和结果语句（&lt;code class=&quot;inline&quot;&gt;return&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;fail&lt;/code&gt;）都是特设多态的限界continuation（ad-hoc polymorphic delimited continuations），由类型类&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;解释执行。GHC可以把所需的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;类型自动推断出来：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :type dslBlock
dslBlock
  :: (PolyCont (Return IOError) r Void, PolyCont (Return ()) r Void,
      PolyCont MaxLengthConfig r Int, PolyCont GetLine r [Char],
      PolyCont PutStrLn r ()) =&amp;gt;
     r&lt;/code&gt;&lt;h2&gt;&lt;b&gt;创建无副作用解释器&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;只要提供了适用的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt; 实例，&lt;code class=&quot;inline&quot;&gt;r&lt;/code&gt;可以是任意类型。比如：以下代码定义了无副作用的解释器&lt;code class=&quot;inline&quot;&gt;PureInterpreter&lt;/code&gt;以及对应的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;实例：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; type PureInterpreter = Int -&amp;gt; [String] -&amp;gt; Cont [String] IOError&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont MaxLengthConfig PureInterpreter Int where
  runPolyCont MaxLengthConfig = runPolyCont Get
:}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont PutStrLn PureInterpreter () where
  runPolyCont (PutStrLn s) = runPolyCont (Yield s)
:}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont (Return ()) PureInterpreter Void where
  runPolyCont (Return ()) = runPolyCont Empty
:}&lt;/code&gt;&lt;p&gt;以上三个&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;实例简单的转发到Control.Dsl的内置操作上。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont GetLine PureInterpreter String where
  runPolyCont k = runCont $ do
    x : xs &amp;lt;- Get @[String]
    Put xs
    return x
:}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;GetLine&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;实例要稍微复杂一些，实现为一个&lt;code class=&quot;inline&quot;&gt;Cont&lt;/code&gt; ，由若干个内置操作组合而成。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;无副作用地运行DSL&lt;/b&gt;&lt;/h2&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; runPurely = dslBlock :: PureInterpreter
&amp;gt;&amp;gt;&amp;gt; errorHandler e = [&quot;(handled) &quot; ++ show e]&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; runCont (runPurely 80 [&quot;LINE_1&quot;, &quot;LINE_2&quot;]) errorHandler
[&quot;The input is LINE_1 and LINE_2&quot;]&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; longInput = [replicate 40 &#39;*&#39;, replicate 41 &#39;*&#39;]
&amp;gt;&amp;gt;&amp;gt; runCont (runPurely 80 longInput) errorHandler
[&quot;The input is too long&quot;,&quot;(handled) user error (Illegal input)&quot;]&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; runCont (runPurely 80 [&quot;ONE_LINE&quot;]) errorHandler
[&quot;(handled) user error (Pattern match failure in do expression at &amp;lt;interactive&amp;gt;...&quot;]&lt;/code&gt;&lt;h2&gt;&lt;b&gt;创建有副作用的解释器&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;此外，只要提供了有副作用的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;实例，&lt;code class=&quot;inline&quot;&gt;dslBlock&lt;/code&gt;还能以带副作用的方式运行。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; type EffectfulInterpreter = Handle -&amp;gt; IO ()&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont GetLine EffectfulInterpreter String where
  runPolyCont GetLine = runCont $ do
    h &amp;lt;- Get
    line &amp;lt;- Monadic (hGetLine h)
    return line
:}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Monadic&lt;/code&gt;是个内置操作，可以在DSL &lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块执行monad操作，比如IO。其他操作（比如&lt;code class=&quot;inline&quot;&gt;Get&lt;/code&gt;）可以和&lt;code class=&quot;inline&quot;&gt;Monadic&lt;/code&gt;出现在同一个&lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;语句块，而不需要任何monad transformer。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont MaxLengthConfig (IO ()) Int where
  runPolyCont MaxLengthConfig f = f 80
:}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont PutStrLn (IO ()) () where
  runPolyCont (PutStrLn s) = (Prelude.&amp;gt;&amp;gt;=) (putStrLn s)
:}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
instance PolyCont (Return IOError) (IO ()) Void where
  runPolyCont (Return e) _ = hPutStrLn stderr (show e)
:}&lt;/code&gt;&lt;h2&gt;&lt;b&gt;以副作用方式运行DSL&lt;/b&gt;&lt;/h2&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; runEffectfully = dslBlock :: EffectfulInterpreter&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; :{
withSystemTempFile &quot;tmp-input-file&quot; $ \_ -&amp;gt; \h -&amp;gt; do
  Monadic $ hPutStrLn h &quot;LINE_1&quot;
  Monadic $ hPutStrLn h &quot;LINE_2&quot;
  Monadic $ hSeek h AbsoluteSeek 0
  runEffectfully h
:}
The input is LINE_1 and LINE_2&lt;/code&gt;&lt;h2&gt;&lt;b&gt;结论&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了如何用&lt;code class=&quot;inline&quot;&gt;Control.Dsl&lt;/code&gt;创建自己的DSL。不同于&lt;code class=&quot;inline&quot;&gt;Monad&lt;/code&gt;，用&lt;code class=&quot;inline&quot;&gt;Control.Dsl&lt;/code&gt;创建的DSL可以扩展。只要创建GADT和对应的&lt;code class=&quot;inline&quot;&gt;PolyCont&lt;/code&gt;，就可以为现有的解释器添加新操作。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;相关链接&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Atry/Control.Dsl&quot;&gt;Control.Dsl on Github&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://hackage.haskell.org/package/control-dsl&quot;&gt;control-dsl on Hackage&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2018-10-05-46014989</guid>
<pubDate>Fri, 05 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Resolving Python Symbols</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-10-02-45835774.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45835774&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该文对Python作用域相关知识进行彻底剖析。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Python中的变量符号&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Python的一个变量符号在一个作用域下只有以下中一种形式: &lt;/p&gt;&lt;ul&gt;&lt;li&gt;Local&lt;/li&gt;&lt;li&gt;Free&lt;/li&gt;&lt;li&gt;Cell&lt;/li&gt;&lt;li&gt;Global&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;注: Python解释器允许实现多重作用域&lt;/p&gt;&lt;p&gt;不同形式的符号对数据的存取方式不同。local, cell, free变量被存放在可随机访问的序列结构中，而global变量存于可变的哈希表中。&lt;/p&gt;&lt;p&gt;有一个基本概念 &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_binding&quot;&gt;bound&lt;/a&gt; 用来形容来自非外部的符号, 对于Python我们有&lt;/p&gt;&lt;ul&gt;&lt;li&gt;bound vars = cell vars+ local vars&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;按照概念, global vars应当属于free vars, 但python为了实现可变的全局符号表, 两者被分离开来。可以这样理解: free vars的符号在作用域被定义时即可确定, 而全局符号表可在任意时刻被增减修改。&lt;/p&gt;&lt;h2&gt;free vars可以用如下方式描述:&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;当一个符号无法在当前作用域内被找到，且能够在其上的某一层作用域被找到，以及找到符号的作用域不是全局的, 那么它在当前作用域内表示一个free vars。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;2. 在某个作用域中符号被标记为nonlocal的变量，如果这个作用域不是顶层或者顶层之下一个。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;cell vars可以被如下方式描述:&lt;/h2&gt;&lt;p&gt;当一个变量可以在当前作用域被找到，且在其下的作用域是自由变量。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;则&lt;/p&gt;&lt;h2&gt;local vars可以被如下方式描述&lt;/h2&gt;&lt;p&gt;在当前作用域进入(enter), 不是cell vars, 没有被nonlocal标记的变量。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;例子:&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;x = 1     # x : global
def f(a): # a : local
   b = 1  # b : local
   def g(y):  # g在f中, local;  y在g中, local
      c + y   # c在g中, free
   c = 2      # c在f中, cell
   d = 2      # d在f中, cell
   def h():   
       # d在不h中,但位于h存放free vars的位置
       def i():
          nonlocal d # d在i中, free 
          d = 3
   &lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;求出一个程序中的所有符号及其作用域&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;运算被加载的符号的函数为(&lt;equation&gt;R&lt;/equation&gt; = requires), 被存储的符号(&lt;equation&gt;E &lt;/equation&gt; = entered), 被显式标记为nonlocal的符号(&lt;equation&gt;N &lt;/equation&gt; = explicit_nonlocals)，被显式标记为global的符号( &lt;equation&gt;G&lt;/equation&gt;  = explicit globals)。&lt;/p&gt;&lt;p&gt;记取作用域 &lt;equation&gt;C&lt;/equation&gt; 的多个下层为 &lt;equation&gt;Children\; C&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;取作用域的上层为 &lt;equation&gt;Parent\; C&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;则&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align}  Local\; C  &amp;amp;=  \{ v \in Bound\; C  \;| \; v \not \in Cell\;C\}  \\  Cell\;C     &amp;amp;= \{ v   \in Bound \; C \; | v \in \cup_{C&#39; \in Children\; C} \;  Free \; C&#39; \} \\ Free\; C &amp;amp;=  N\; C \cup (\cup_{i \in Z^+} \{ v \in R \;C\cap Bound\;Parent^i  \;C \}) \\ Bound \; C &amp;amp;= \{ v \in E \; C \;|\; v  \not \in Global\; C, \; v \not \in N\; C \} \\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;计算时，先bound，再free, 后cell, 再local。&lt;/p&gt;&lt;p&gt;实现: &lt;a href=&quot;https://github.com/thautwarm/kizmi/blob/master/kizmi/extended_python/symbol_analyzer.py&quot;&gt;Yet Another Python Python&lt;/a&gt;&lt;/p&gt;&lt;p&gt;效果: (如下图)&lt;/p&gt;&lt;p&gt;用处: 实现原汁原味的Python时，可以预先计算好作用域符号表，将&lt;a href=&quot;https://github.com/python/cpython/blob/master/Python/symtable.c&quot;&gt;https://github.com/python/cpython/blob/master/Python/symtable.c&lt;/a&gt; 大幅简化。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6f74cd2c911b5cd4ee29df4234b7d55c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;933&quot; data-rawheight=&quot;776&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6f74cd2c911b5cd4ee29df4234b7d55c&quot; data-watermark-src=&quot;v2-d45f5dbf97b19fa9a8180a005528987c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;注: 使用pending/future的策略可以不预先计算作用域表，但书写较为麻烦。实现如下:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/thautwarm/reley/blob/master/reley/impl/compiler.py&quot;&gt;Haskell like language in Python&lt;/a&gt;&lt;/p&gt;&lt;p&gt;思路:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;async def emit_stmt(...):
    # 加载名字
    await declared(...)
    # 对内部结构进行编译
    await compiled(...)
    # 对作用域符号表进行修正
    await resolved(...)
    # 后续编译&lt;/code&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>头顶青天红美铃</author>
<guid isPermaLink="false">2018-10-02-45835774</guid>
<pubDate>Tue, 02 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>7天7paper</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-10-01-45815032.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45815032&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各位国庆快乐！&lt;/p&gt;&lt;p&gt;好久都没写东西了，就随便找个借口写点东西吧。&lt;/p&gt;&lt;p&gt;既然国庆放七天，我就随手推荐七篇paper吧，在脑袋里面找出来的，以前可能推荐过，不要见怪。&lt;/p&gt;&lt;p&gt;Generic Deriving of Generic Traversals - 好中规中矩的paper，就是说‘我用generics搞出了scrap your boilerplate without runtime type checking’，没有任何novelty。不过数字好漂亮啊！&lt;/p&gt;&lt;p&gt;Generic Programming of All Kinds - 靠De Bruijn Index跟各种扩展把True Sum of Product搞上gadt/constrainted/rankn等等等等。几天前当 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/2d8f51b6523e01a8529606f466d98198&quot; data-hash=&quot;2d8f51b6523e01a8529606f466d98198&quot; data-hovercard=&quot;p$b$2d8f51b6523e01a8529606f466d98198&quot;&gt;@Felis sapiens&lt;/a&gt; 到西雅图来玩的时候曾经问他‘True Sum of Product跟Scrap Your Boilerplate你选那个’，结果他竟然给我说GHC.Generic！原因是TSOP/SYB等难以搞上复杂一点的类型（GADT/RankN）。现在看到这篇paper，越来越觉得有道理 - 这搞是搞上去了，不过好复杂，说不定反而比Generic用起来更麻烦呢。&lt;/p&gt;&lt;p&gt;Demystifying Differentiable Programming: Shift/Reset the Penultimate Backpropagator - 这是The paper on AD。曾经想过，其实只有两种AD算法，forward跟reverse，其他的一切ad算法都只是这两的变种（numerical ad是forward，但是不用infinitesmall，改某个足够小的值，symbolic也是forward，但是没有cse，同理，把wengert list变成runtime datastructure就是higher order reverse mode），然后写个blog。结果发现，这不就是这篇paper吗。结果竟然被ICFP拒了，什么鬼。&lt;/p&gt;&lt;p&gt;Beautiful differentiation - 这篇paper提出了differentiation tower，一次求出无数个导，挺漂亮的。另外也是conal照常的猫论时间。&lt;/p&gt;&lt;p&gt;Lightweight Static Capabilities - 教你怎么在不玩type level programming的情况下实现某种意义上的dependent type。&lt;/p&gt;&lt;p&gt;Ghosts of Departed Proofs - 上面内篇paper的扩展，变得更general了&lt;/p&gt;&lt;p&gt;Haskell is not not ML - Wadler老爷子说过‘一个idea会被逻辑学家发明一遍，再被计算机科学家发明一遍’。这篇paper给我的感觉是SPJ挥舞着大锤子，在intuitionistic paraconsistent logic上敲了敲，然后duang的一声发现能用来unify strict&amp;amp;lazy language。以前看过para logic的时候，发现这是intuition的dual，但是在PL中完全没找到用途。。。现在竟然被找出来了，v587&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2018-10-01-45815032</guid>
<pubDate>Mon, 01 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>浅谈 编程语言研究 与 程序分析</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-10-01-45208498.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45208498&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-177562a74b47d6e59e518120f85e7ead_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;前言&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在上一篇文章《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43914842&quot;&gt;浅谈国内高校编程语言教育&lt;/a&gt;》（简称《浅教》）中，我提到了国外顶尖大学的编程语言课程大都是由从事&lt;b&gt;编程语言&lt;/b&gt;（Programming Languages简称，&lt;b&gt;PL&lt;/b&gt;）研究的专门人才来讲授的。PL作为软件的核心技术，在软件开发效率、软件可靠性、安全性、性能等方面都提供了根本性的支持。PL是一个已经活跃了50余年的研究领域，作为软件创新的核心动力，如今仍是一个极有生命力且非常活跃的学科。&lt;/p&gt;&lt;p&gt;如《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43914842&quot;&gt;浅教&lt;/a&gt;》所述，在排名领先的世界名校中，但凡有点规模的计算机院系，几乎都会有PL方向的全职教授和研究人员，且越顶尖的大学，PL的研究越受重视。然而我国的情况并非如此，PL这样历史悠久且庞大复杂的学科在中国计算机学会并没有相应的专委（Again，形式化方法专委和软件工程专委无法取代编程语言专委，反之亦然），高校和科研院所也极少有专门注明PL为研究方向的教授和科研人员。因此，我想通过这篇文章向感兴趣的知友们简单介绍一下当前PL研究的整体概况和我所在的研究领域——PL方向下程序分析的研究现状。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;编程语言会议&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;判断一个人的研究领域是否属于PL，最简单的方法就是看他文章发表的会议。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;A级会议&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;国际上编程语言有公认的四大顶会：&lt;b&gt;PLDI&lt;/b&gt;、&lt;b&gt;POPL&lt;/b&gt;、&lt;b&gt;OOPSLA&lt;/b&gt;、&lt;b&gt;ECOOP&lt;/b&gt;。（有点像Security里面的四大顶会Oakland、CCS、Usenix Security、NDSS）。&lt;/p&gt;&lt;p&gt;如果非要细分，PLDI和POPL要比OOPSLA和ECOOP好。这么多年，我通过博士、博后导师们的灌输+开会聊天了解到，欧洲人一般认为ECOOP稍好于OOPSLA（欧洲的PL研究人员特别多，很多知名编程语言的创始人也都来自欧洲如C++, C#, Python, Scala, PHP, ML, Haskell等），而北美人一般认为OOPSLA稍好于ECOOP。说ECOOP稍好的人一般持“OOPSLA由美国ACM主导，有钱有颜（资金和宣传力），且ECOOP（由欧洲AITO主导）被毙掉的文章一般会流向OOPSLA（ECOOP和OOPSLA作为姊妹会议同一年创办且deadline一前一后），所以OOPSLA有更多的submission和随之而来更低的录取率”。&lt;/p&gt;&lt;p&gt;我刚开始读博士时不太懂，单纯地认为录取率低的会议好于录取率高的，后来随着在research上逐渐成熟慢慢了解到一个会议的好坏要看一个领域自己的人对它的认可情况，这个会议的program committee比它的排名、会议规模和录取率更重要（后面也懂得顶会论文数量和citation并不能评价一个人的真正学术水平和影响，这个就不在此展开了）。打一个比方，超级女声和青歌赛，前者报名人数众多1000人（因为名气大能出名，能吼两句的都想试试）且录取率很低（进100，10%），而后者报名人数很少200人（起码都是稍微专业一些的）随之录取率也相对较高（进50，25%），但你不能因为说前者人数更多且竞争更激烈，就觉得进超女决赛的人比进青歌赛决赛的人唱歌更好吧。&lt;/p&gt;&lt;p&gt;近些年，OOPSLA和ECOOP为了扩大PL在应用方面的影响力，也鼓励录取一些偏软件工程（SE）等方面的文章，个人认为在录取的文章中，还是那些偏PL的文章的整体水平更高，因为PL人审PL类文章会更专业且更严格（当然凡事也都有例外，偏PL的文章也有差的而偏SE的文章也有好的）。&lt;/p&gt;&lt;p&gt;实际上还有一个非常好的PL会议，虽然不像ECOOP和OOPSLA那样general，但其名声和质量并不比它们差。这个会议就是&lt;b&gt;ICFP&lt;/b&gt;，是functional programming领域的ECOOP和OOPSLA。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;B级会议&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;继PLDI/POPL/OOPSLA/ECOOP后下一个档次的PL会议是&lt;b&gt;ESOP&lt;/b&gt;（欧洲编程语言会议），这个是“纯”PL的会议（搞纯PL的人认为这个会议相当的好）。在我个人所在的研究领域program analysis（注：它是偏PL的基础分析技术即传统的静态分析，例如pointer/points-to/alias analysis等，而并不是利用这些基础分析技术开发的偏SE应用的software analysis）也有一些和ESOP一个档次的“类”PL会议。&lt;/p&gt;&lt;p&gt;这个档次的“类”PL会议包括静态分析会议&lt;b&gt;SAS&lt;/b&gt;（VMCAI和SAS一个级别，但搞抽象解释的朋友，他们很多都投VMCAI，告诉我他们认为SAS稍好于&lt;b&gt;VMCAI&lt;/b&gt;），软件工程会议&lt;b&gt;ISSTA&lt;/b&gt;（还有一个稍偏PL的SE会议是FSE，但FSE比ISSTA更好些，一般认为非同一级别），编译会议&lt;b&gt;CGO&lt;/b&gt;（CGO和CC一个级别，但近几年CGO要稍好于&lt;b&gt;CC&lt;/b&gt;），再有就是更小众的（在分析领域一般认为虽属同一档次但比前面的会议稍差那么一点的）内存管理会议&lt;b&gt;ISMM&lt;/b&gt;，还有偏嵌入式的&lt;b&gt;LCTES&lt;/b&gt;和&lt;b&gt;EMSOFT&lt;/b&gt;等。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;C级会议&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;再下一个档次的“纯”PL会议是&lt;b&gt;APLAS&lt;/b&gt;，它被认为明显好于同属一个档次的其他“类”PL会议，如&lt;b&gt;SOAP（&lt;/b&gt;是个非常好的workshop有很多不错的分析文章）、&lt;b&gt;SCAM&lt;/b&gt;、&lt;b&gt;SAC&lt;/b&gt;的&lt;b&gt;PL track&lt;/b&gt;（SAC的老牌高质track）等。&lt;/p&gt;&lt;p&gt;最后提一下PL的期刊&lt;b&gt;TOPLAS&lt;/b&gt;，公认为PL最好的期刊，挺难投的（一年貌似就十几篇），它的submission来源主要集中在PL的四大顶会（一般是把会议文章内容扩展30%左右）。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;编程语言都研究些什么&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;PL学科庞大，结构复杂，让我这么个搞PL分析的说清楚整个PL都在研究什么是不可能的（估计这辈子都说不清楚）。但是简介一下概貌还是可以的。我觉得按照如下三个方面对PL的研究进行分类是相对容易理解的。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;纯PL&lt;/b&gt;，即关于PL本身的设计。例如，&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;语言设计和拓展 （language designs and extensions）&lt;/li&gt;&lt;li&gt;类型系统 （type systems）&lt;/li&gt;&lt;li&gt;语言语义和程序逻辑 （language semantics and program logics）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;2. &lt;b&gt;PL支持环境&lt;/b&gt;，即支撑PL的编译和运行系统。例如，&lt;/p&gt;&lt;ul&gt;&lt;li&gt;编译器技术 （optimization, transformation等）&lt;/li&gt;&lt;li&gt;运行时技术（virtual machine, garbage collection等）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;3. &lt;b&gt;PL应用&lt;/b&gt;，即利用PL的语法语义等知识对PL编写的程序展开的一系列应用。例如，&lt;/p&gt;&lt;ul&gt;&lt;li&gt;程序分析（program analysis）&lt;/li&gt;&lt;li&gt;程序验证（program verification）&lt;/li&gt;&lt;li&gt;程序合成（program synthesis）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上述分类只是一个框架，实际上并没有展开，因为它很难展开，太庞杂了。例如，纯PL中的第一条“语言设计和拓展”，就这一点就有各种编程范式，比如，object-oriented, functional, logic, constraint, domain-specific, asynchronized programming等等。因此针对PL的研究内容我就止步于此，大家有一个大致了解就好。&lt;/p&gt;&lt;p&gt;下面我针对上述各PL分类方向的研究现状做一个简单的总结。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1. &lt;/b&gt;纯PL的研究相比于十年前已经安静很多了，但是大家也不要低估研究纯PL的这些人的数量，他们大多分布在世界顶级大学和软件公司，如今各种纯PL技术仍活跃在各大PL舞台，主要是POPL，ECOOP，ICFP和ESOP，PLDI和OOPSLA也有一些。我个人认为纯PL圈子的人有如当年占据计算机领域金字塔尖的那些搞算法、逻辑、复杂性的研究者们，虽然如今力量日渐消退，但我依然认为他们是引领PL乃至软件领域发展的一股中坚力量，值得尊敬。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. &lt;/b&gt;PL支持环境实际上和编译领域、系统领域甚至体系结构都有一些关系。由于上层编程语言本身就是各种类型，那么支持它们的编译和运行时技术更是种类繁多，层出不穷。就凭当今主流的那些编程语言，也可以让这个方向的研究一直持续下去，毕竟使用它们的金主们（各大软件公司）为了它们编写的程序有更好的可靠性和性能也会给这股研究力量多多支持的。此外还有各种编译和系统方面交叉人才的加持，我相信这个方向还会有很多实用的技术被创造出来。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.&lt;/b&gt; PL应用举的这三个例子，如今在PL的热度是一年比一年高，主要原因是如今的软件越来越复杂了，对于可靠性、安全性、性能和编写效率都有新的要求，提出了新的挑战，有很多实际且有趣的问题亟待解决，甚至这些技术的展开和探讨对于编程语言的设计也会有很大的影响。如果你是一个research新人，对PL有点兴趣但不知道研究什么好，我建议你入PL应用的坑，因为我认为它至少在未来五年依然会是一个很活跃的研究方向（原因如上所述）。&lt;/p&gt;&lt;p&gt;接下来，我们来聊聊PL应用中最庞大、最火热的分支之一，程序分析。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;程序分析 &lt;/b&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;程序分析的重要性&lt;/b&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;学术界&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;程序分析可以看成是一个交叉的研究方向，因为你会在PL以外的其它不同计算机领域的会议上看到程序分析的topic。例如，软件工程如FSE, ICSE, ISSTA, ASE等；系统领域如 OSDI, SOSP, ASPLOS, EuroSys, ATC等；安全领域如Oakland, CCS, NDSS, Usenix Security等等。造成这种交叉性质的原因不难理解：程序分析是一种方法技术，目的是分析出程序在可靠性、安全性、性能等各种方面的表现和问题，而各领域的程序都是用编程语言写的，且都或多或少地有上述方面的分析需求，因此不同领域对于程序分析的广泛兴趣便不足为奇。尤其是近些年，程序分析在上述很多会议的Call For Papers里都会被单独列为一项愿意接收的topic，比较火热。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;企业界&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;程序分析不只在学术界占有重要席位，近些年来也越来越受到企业界的青睐，原因我在之前简单提到过，因为当今的软件越来越复杂，在可靠性、安全性、性能等方面提出了新的要求和挑战，这些都是传统技术（如软件测试等）很难驾驭的。据我所知，国际知名的大公司都有专门的程序分析研究或开发组，例如Microsoft，Google，Oracle，Apple，IBM，Facebook、Uber、华为等等。随着人们逐渐意识到程序分析的重要性，专门研发程序分析技术的公司也越来越多，例如Coverity（被收购），GrammaTech，Semmle，SourceBrella（源伞）等。&lt;/p&gt;&lt;p&gt;如上所述，程序分析无论在学术界还是工业界都扮演着重要的角色。程序分析如此重要，它到底是个啥呢？接下来，我们来简单看看什么是程序分析。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;2. &lt;b&gt;什么是程序分析&lt;/b&gt;&lt;/p&gt;&lt;p&gt;程序分析虽有静态动态之分，但从PL的角度我们一般关注的是&lt;b&gt;静态分析&lt;/b&gt;（static analysis）。简单说来，静态分析要回答的问题是&lt;/p&gt;&lt;blockquote&gt;我想知道在任何输入下，整个程序或程序的某一点是否能满足某种条件或特性？&lt;/blockquote&gt;&lt;p&gt;但是，程序的输入可以无穷无尽，程序到达某一点的路径可以根据输入变化莫测、不胜枚举，如何将所有情况都考虑周全最后得出一个正确的（sound）结论呢？为此，我觉得静态分析技术的核心可以围绕两个关键字展开：Abstraction和Over-approximation。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Abstraction&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;程序在动态执行时，有各种不同类型的动态值，例如int类型的 1, -2, 350，String类型的 “a”, &quot;007&quot;, &quot;Hello&quot; 还有各种referenced的concrete object（比如你在一个死循环里放一句new A()你想想运行时会有无数个A类型的concrete object被生成直到吃满你的内存），如果你想用有限的内存资源来分析这些无限的动态值，你首先需要把它们抽象起来，即Abstraction。例如只有一个int类型的抽象值（或一个整数int、一个负数int、一个0，共三个抽象值），一个类型的String值，一个new A()语句只生成一个抽象的对象，即（和上面concrete object对应的）abstract object。怎么抽象是可以调节的，抽象方式不同，静态分析的精度和速度便会不同。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Over-approximation&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;程序在动态执行时，根据输入的不同，可能会走各种不同的路径，随着程序规模和复杂度的增加，这些路径也会无穷无尽，最终不能用有限的空间来枚举每条可能的动态路径下的不同值（路径爆炸），进而也无法知道程序的某一点的值是否还满足某些条件。为了用有限的空间和时间来“枚举”无限路径下的各种可能值，我们需要保守近似over-approximation。如下所示&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;if (e) x = 1 
else x = 0 
@Label A&lt;/code&gt;&lt;p&gt;假设我们想知道程序Label A这一点x的值是什么？想象一下如果我们可以枚举路径，我们可以得到很精确的答案，即在e == true时x = 1 （路径1）；在 e == false时x = 0 （路径2）。然而如果程序很大且复杂，我们没法枚举每一条路径（路径爆炸）下的值。over-approximation是在某些程序位置或区域保守地近似不同执行路径（executions）下的值。如在Label A，我们可以说无论走哪条路，x要么是1要么是0。这是sound（safe）的结论，尽管不精确，但是如果x只要不是负数就可以做某种优化，那么这样的结论就是有用的。对不同路径抽象的粒度是可以调节的，粒度不同（如context, flow, path-sensitivity），静态分析的精度和速度也会不同。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;实际上真正的静态分析要复杂的多，因为它要针对不同编程语言不同语法下的不同语义来合理的抽象近似程序在每一个语句下的动态运行结果（可以想象成静态地抽象一个解释器）。因此静态分析是和编程语言紧密相关的（需要深入准确地了解语言的语法和语义）。如此，我再说&lt;b&gt;程序分析（静态分析）实际上是偏PL的研究方向&lt;/b&gt;你就更容易理解了。&lt;/p&gt;&lt;p&gt;如今，软件工程、系统和安全方向的很多程序分析都是利用基础的静态分析技术和结果，结合程序和问题的特点，进行更high-level的分析，比如查到更有趣的bug和安全漏洞，或更好的帮助优化或理解程序等等。既然基础静态分析和PL联系的这么紧密且如此重要，我觉得有必要再深入地了解一下它。接下来，我要介绍基础静态分析中最核心、最重要的一个分支（之一），也是大家经常在各种程序分析论文和程序分析工具的代码、文档和注释中看到的指针分析（pointer analysis），又名指向分析（points-to analysis）或别名分析（alias analysis）。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;指针分析/指向分析/别名分析（Pointer/Points-To/Alias Analysis）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;提到静态分析，都应该听说过指针分析，这个奇葩研究方向居然延续了近40年而且长盛不衰，至今仍活跃在各大PL相关会议当中。原因很简单，它太重要了。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;什么是指针分析&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;指针分析并不是“分析指针”，如果不好理解，你可以用它的另一个名字“指向分析”来记，顾名思义，给定程序的任何变量或引用p，指向分析在compile-time（静态）回答p都可能指向哪些值（实际上也是回答静态分析的问题）。既然知道了p1和p2都指向什么，如果p1和p2的指向有交集，就说p1和p2互相alias（alias对很多sound的分析是必须的），因此指向分析也叫别名分析即alisas analysis。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;指针分析的重要性&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为什么指针分析如此重要？就像几乎所有指针分析论文中描述的那样，指针分析可以认为几乎是所有静态分析的基础，因为它可以被用来构建全局的程序控制流（Interprocedural control flow graph, ICFG）和方法调用图（call graph），且所有全局的程序静态分析都需要这些基本结构，与指针分析提供的指向信息和别名信息来构建自己更high-level的静态分析。&lt;/p&gt;&lt;p&gt;我上面提到的那些大的软件公司尤其是IBM、Oracle等都有自己专门的指针分析的团队（ &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/487163f4982c221d9e7b085a7c59cd46&quot; data-hash=&quot;487163f4982c221d9e7b085a7c59cd46&quot; data-hovercard=&quot;p$b$487163f4982c221d9e7b085a7c59cd46&quot;&gt;@TwoFrogs&lt;/a&gt; 的源伞公司也是研发指针分析的，国内首屈一指），很多程序分析的开源或商业框架也都是用指针分析搭建起来的。40年来各种PL相关会议上的指针分析论文层出不穷。近十多年来，指针分析的重点也逐渐从以前的C语言侧重到面向对象语言（这个不难理解，毕竟如今的应用软件的主流语言是面向对象），占据了近些年来各大PL相关top会议指针分析topic的更多席位。&lt;/p&gt;&lt;p&gt;既然面向对象（OO）指针分析（主要是Java）在近些年相对更受关注，接下来我们就简单聊聊它的发展进程，我觉得下面的梳理对想入坑或感兴趣的同学会有所帮助。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;OO指针分析的过去和现在&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;OO的指针分析一般以Java为主，现在的很多Android的静态分析技术和工具也都是基于Java指针分析的。接下来，我通过几个关键人物和他们开发的关键技术或工具来帮助梳理Java指针分析的研究进程。故事从枫叶国说起：&lt;/p&gt;&lt;blockquote&gt;加拿大麦吉尔大学的Laurie Hendren教授（早期指针分析领军人物之一）的研究组在1999年以论文的形式发表了Soot，Soot直到今天仍是最流行的针对Java的静态分析器。&lt;br&gt;&lt;br&gt;在2003年，Laurie的学生Ondřej Lhoták在Soot上开发了指针分析Spark，影响力很大。Ondřej Lhoták从2003后继续发力，一直在指针分析的topic发表文章，例如用BDD来实现指针分析，强调context-sensitivity对于Java的重要性等等。Ondřej 现在是加拿大滑铁卢大学的副教授，可以说他是Java指针分析的最核心人物之一。&lt;br&gt;&lt;br&gt;Laurie的另一个学生Eric Bodden（现德国Paderborn大学教授）从大概2012年接管了Soot，并在其上增加了IFDS的实现框架，在近些年开展了一系列针对Java的demand-driven指针分析的研究（注：Eric在分析程序安全性上有一些知名的工作，比如针对Android的taint analysis框架FlowDroid）。&lt;/blockquote&gt;&lt;p&gt;在2009年之前，还有几个人需要提及。&lt;/p&gt;&lt;blockquote&gt;首先是Ana Milonova（现美国伦斯勒理工学院副教授）。Ana是Barbara G. Ryder（早期指针分析的领军人物之一，现弗吉尼亚理工教授）的学生。Ana在2002年提出了object-sensitivity并验证用它作为Java的context会带来更好的分析精度甚至速度。这就打破了一直以来从C语言静态分析那里继承而来的基于callsite的context-sensitivity的局面。这个工作在业内影响力很大，四大Java指针分析框架Doop，Wala，Soot，Chord都有object-sensitivity的实现，因为它是Java指针分析精度提升的必备技术。&lt;br&gt;&lt;br&gt;其次是Mayur Naik（现宾夕法尼亚大学副教授）。Mayur是Alex Aiken（早期的指针/程序分析的重要人物之一，现斯坦福大学教授）的学生，他2006年发表了Chord，起初Chord是为了静态检测Java程序的data race写的，而他检测data race的核心技术就是依赖指针分析，因为Chord本身实现了不同种指针分析算法，如今被认为是Java指针分析的四大框架之一。实际上，Mayur的Chord是基于John Whaley的BDDBDDB框架写的 ，BDDBDDB是2004年发表于PLDI的指针分析工作。John是斯坦福大学Monica S. Lam教授（编译龙书的作者之一，最新版龙书关于静态分析那部分就是Monica写的，她也是早期指针分析的重要人物之一）的学生，John和Monica在90年代末期也做了一系列指针分析工作。但是John最后自己创业，分析工作没有延续。&lt;br&gt;&lt;br&gt;再者是Manu Sridharan（现Uber静态分析团队的leader），他在加州伯克利读博士期间，于2005和2006两年连续发表了针对Java的demand-driven指针分析的工作，业内影响力较大，后续很多demand-driven指针分析工作都受此影响。Manu毕业后去了IBM T. J. Watson研究中心，参与了另一个知名Java指针分析框架Wala的开发，实际上之前IBM的研究人员已经开始了指针分析的研究和Wala的实现。&lt;/blockquote&gt;&lt;p&gt;2009年后Java的指针分析主要有以下几个国际团队在做，&lt;/p&gt;&lt;blockquote&gt;希腊雅典大学的Yannis Smaragdakis教授，&lt;br&gt;澳洲新南威尔士大学的Jingling Xue教授，&lt;br&gt;韩国高丽大学的Hakjoo Oh教授，&lt;br&gt;德国Paderborn大学的Eric Bodden教授，&lt;br&gt;香港科技大学的Charles Zhang教授，&lt;br&gt;澳洲悉尼大学的Bernhard Scholz教授和与其合作的Oracle Lab的程序分析团队，&lt;br&gt;美国宾西法尼亚大学的Mayur Naik教授，&lt;br&gt;加拿大滑铁卢大学的Ondřej Lhoták教授。&lt;/blockquote&gt;&lt;p&gt;注：值得一提的是，以上除了Bodden和Naik教授的团队，其余几个团队也做过或正在做C/C++的指针分析。实际上在我们国内也有做过C/C++的指针分析团队，那就是中科院计算所的冯晓兵教授和李炼研究员。关于C/C++的指针分析如果大家感兴趣可以访问以上几个团队的主页，外加UCSB的Ben Hardekopf教授和印度理工的Uday Khedker教授。&lt;/p&gt;&lt;p&gt;2009年后，Java（或OO）指针分析领域的最核心人物当属雅典大学的Yannis Smaragdakis教授，接下来我们简单了解一下他的工作。&lt;/p&gt;&lt;blockquote&gt;Yannis Smaragdakis教授原来是美国佐治亚理工和马萨诸塞大学的教授，后来在2011年左右回到了希腊的雅典大学任教。他2009年在OOPSLA发表了当今最先进的Java指针分析器Doop，然后持续地在各PL顶级会议POPL，PLDI，OOPSLA，ECOOP发表大量的指针分析文章。我个人认为目前为止Yannis对指针分析最大的贡献有两个，一个就是Doop这个指针分析器本身，另一个是于2011年在POPL发表的一篇文章。这篇文章从新精确地解释了Ana Milanova在2002年提出的object-sensitivity的定义，以消除从02年到11年期间关于object-sensitivity的有分歧的理解：即当context层数大于一层时应该用哪些object来做context。此外这篇文章又提出了一种新的context技术叫type-sensitivity（精度比object-sensitivity稍差但是速度快很多），这对于大程序分析不scalable的问题起到了很好的缓解作用。&lt;/blockquote&gt;&lt;p&gt;2016年以后到今天，Java指针分析的关键人物是我们的一位知友Tian Tan &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/f87c102df451bc1ec42085ea759c82fb&quot; data-hash=&quot;f87c102df451bc1ec42085ea759c82fb&quot; data-hovercard=&quot;p$b$f87c102df451bc1ec42085ea759c82fb&quot;&gt;@甜品专家&lt;/a&gt; （新南威尔士大学Jingling Xue教授的博士，现在是丹麦Aarhus大学Anders Møller教授的博士后）。&lt;/p&gt;&lt;blockquote&gt;Tian在2016发表于SAS的工作改变了20多年来context-sensitivity一直使用连续context元素的局面，巧妙地避开了对分析精度没有用却又影响分析速度的context元素。据我所知，上面提到的Ondřej Lhoták，Yannis Smaragdakis还有Mayur Naik教授在不同场合都对这项工作有很高的评价，此外，上面提到的Hakjoo Oh教授团队在今年的OOPSLA，就是用机器学习的方法尝试了Tian的这个工作。Tian从2017年开始又陆续在PLDI、OOPSLA和FSE等顶会发表了针对Java的一系列指针分析工作，感兴趣的同学可以去他主页看看。&lt;/blockquote&gt;&lt;p&gt;关于Java的指针分析我就说这么多，接下来简单提及一下另一个OO语言JavaScript的指针分析研究团队。值得注意的是，国际上有很多团队做JavaScript的程序分析，但是做JS指针分析这种很基础的并不多。主要有以下几个团队：&lt;/p&gt;&lt;blockquote&gt;丹麦Aarhus大学的Anders Møller教授&lt;br&gt;韩国KAIST的Sukyoung Ryu教授&lt;br&gt;IBM Watson研究中心的Wala分析团队&lt;br&gt;英国帝国理工学院的Benjamin Livshits教授&lt;br&gt;美国弗吉尼亚理工的Barbara G. Ryder教授（不活跃状态）&lt;br&gt;美国加州圣芭芭拉大学的Ben Hardekopf教授（不活跃状态）&lt;/blockquote&gt;&lt;p&gt;在这里我就不对JS的指针分析展开了（它主要的一些技术还是来源于Java的指针分析，但是JS的一些神烦的特性还是让搞JS指针分析的人吃了不少苦），有兴趣的同学可以访问上述团队的主页。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这篇文章从介绍PL会议入手，简单描述了哪些人是从事PL研究的，他们都研究些什么，这些研究的现状怎样。接着，介绍了PL研究的一个重要分支——（基础）程序分析，包括什么是程序分析（主要是静态分析）以及为什么程序分析在今天越来越重要。最后，介绍了程序分析中最核心、最重要的技术（之一）—— 指针分析，包括指针分析的概念、重要性以及它发展的过去和现在。希望这篇科普性的文章让你对PL的研究和程序分析技术都能有所了解。&lt;/p&gt;&lt;p&gt;过去的50多年里，针对PL的research从来没有间断过，也一直保持着生命力，它成就了如今软件的琳琅满目，也影响着未来软件的生产力和创新力。作为信息时代崛起的大国，不应该在如此重要的研究领域掉队，衷心期待我国编程语言领域科研的进步。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;后记&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;终于完成了这两篇关于PL的文章，一篇问教育，一篇道科研。世界上有那么多研究领域，多到你只要能看到这两篇文章，你就已经和PL有着难得的缘分了。无论你是想做一名出色的程序员，还是想成为一名优秀的PL方向的researcher，你都为这份缘分续上了契约，我也和你一样，一直走在履行约定的路上，虽然道阻且长，却也一路风光（太 文 艺 了，对 不 住 了 ）。那么，同道中人，一起加油吧！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;最后，感谢 &lt;a href=&quot;https://zhuanlan.zhihu.com/marisa&quot;&gt;雾雨魔法店&lt;/a&gt; 和店里热爱PL的小伙伴们，非常感谢邀请我来写文章 (((┏(;￣▽￣)┛&lt;/p&gt;&lt;p&gt;祝大家国庆快乐！&lt;/p&gt;</description>
<author>啥玩应啊</author>
<guid isPermaLink="false">2018-10-01-45208498</guid>
<pubDate>Mon, 01 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>浅谈国内高校编程语言教育</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-09-28-43914842.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43914842&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f40e47a835c6d5972970334e11e3f0a1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;开篇&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在知乎上活跃着、潜水着很大一批程序员，有的出于对编程的热爱不断磨练提升自己的编程阶位，有的迫于自身的能力和工作的需要不得不强迫自己加班补课不能掉队，有的一直努力着试图在高薪和兴趣之间牵上一条能够说服自己的线。他们大多低调勤奋，每天在跟代码死磕，拿着相对称心工资的同时也为加班压力烦心无奈，更多的幸福也许来自于每每调试成功或完成任务那一刻的暗自欣喜，悄悄地告诉自己“我还不赖”，默默地激励自己“我可以更好”。这篇文章就是为了这些简单的人——如今和未来的“程序员”们。&lt;/p&gt;&lt;p&gt;我觉得在正文之前，有必要先简单自我介绍一下，以防下面的内容没人看，觉得我在瞎扯（那我就白写了啊(&amp;gt;﹏&amp;lt;)）。我叫啥玩应儿，一个普普通通的海外博士+博后，在编程语言（PL）领域（更细化一点是编程语言的程序分析方向）做过一些微小的工作。这篇文章我用心准备了很多天，因为它有着比较“神圣”的写作动机。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;动机&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;此文的写作动机主要来源于两股力量的碰撞：惋惜和鼓舞。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;惋惜&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我发现在知乎上很多科班出身的计算机或软件专业的大学生对于一些基础的编程语言问题比如“什么是解释器”，“什么是编程语言的语义”，“什么是函数式编程”，“为什么语言会有静态和动态类型”等等很多基础知识并不清楚（更不要提诸如“所有编程语言的核是什么”，“它们如何被一些基本的语言特性组成搭建最终形成自己的语言生态”等更进一步的知识），更令人不安的是很多人认为“我不了解它们并不影响我编程，所以不知道也无所谓”。&lt;/p&gt;&lt;p&gt;想到这里，我的脑海中立刻浮现出我人生中的第一门编程语言课（C语言）当时全国通用的清华大学谭浩强的绿皮《C程序设计》教材，和老师课上不断强调的“变量使用前应该声明”，“循环数组不能越界”，“printf的参数有哪些”.....之后又学了一些编程语言课（Java面向对象编程设计，C++等）。然而一路下来，对于编程语言的理解依然停留在我了解这个语言的语法，熟悉它的开发环境，知道怎么查文档和API使用，也知道怎么用它和一些相关的framework或library完成一些实际的编程任务，然后（心虚地）在简历上写道熟悉某某编程语言。&lt;/p&gt;&lt;p&gt;如今想来，这么多学生不喜欢编程，感觉它难且太复杂，枯燥无味却又不得不死记硬啃，写了那么多代码和作业却依旧感觉距离理解编程语言相距甚远。这哪里是学生的错？在这个年代还拿C语言作为入门编程语言（这本身就是“误国误民”！！！）且一味讲解这些语言的语法细节和如何使用它们实现数据结构和算法，这如何让学生真正地理解编程语言并提起兴趣？我为这么多本可以更喜欢编程的学生和本可以更热衷自己编程工作的程序员感到惋惜甚至不平。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;鼓舞&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我在知乎上同时又发现以 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/227135f01257c4d6bdb21a726ef6d53a&quot; data-hash=&quot;227135f01257c4d6bdb21a726ef6d53a&quot; data-hovercard=&quot;p$b$227135f01257c4d6bdb21a726ef6d53a&quot;&gt;@rainoftime&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/2d8f51b6523e01a8529606f466d98198&quot; data-hash=&quot;2d8f51b6523e01a8529606f466d98198&quot; data-hovercard=&quot;p$b$2d8f51b6523e01a8529606f466d98198&quot;&gt;@Felis sapiens&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0251012c87c2d3f56ac34de7d71cdcbc&quot; data-hash=&quot;0251012c87c2d3f56ac34de7d71cdcbc&quot; data-hovercard=&quot;p$b$0251012c87c2d3f56ac34de7d71cdcbc&quot;&gt;@圆角骑士魔理沙&lt;/a&gt; 等为代表的另一波人。他们是纯粹的编程语言爱好者，经常分享着编程语言很多有趣且有用的知识（据说他们这些志同道合的小伙伴私底下也有编程语言交流群分享知识）。我觉得他们很厉害（也很羡慕，因为他们讨论的很多有用的东西我都不懂甚至之前都没听说过，惭愧惭愧(*+﹏+*)），同时也感受到他们对于自己喜欢的东西的那种难得的专注和纯粹。&lt;/p&gt;&lt;p&gt;这些对兴趣的专注和纯粹本应该是大学生在自己专业上该有的年轻的、百舸争流的样貌，如今却被年薪、房价和社会的物化价值观所左右。如果连我们国家顶尖大学的教育都摆脱不了物欲横流的浮躁，又如何完成国家民族集体人格的进一步塑造？在这种背景下，知乎上的这些编程语言爱好者们的所为有如夏日之凉风，让我意识到咱们国家始终有一群爱学习、爱思考、忠于兴趣的学生。他们的存在激励着我说出今天想说的话，希望让更少的学生被惋惜，让更多的学生受鼓舞。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;为什么编程语言教育在我国不受重视？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如今计算机行业日新月异，随着计算能力的不断提升和信息智能化在各行业的大量普及（当然还有一些大公司在背后搞事情），香饽饽领域如“人工智能”“大数据”等受到了前所未有的瞩目。加之我国现今正在产业升级当中，想要利用国内巨大市场和国人对于新鲜事物特有的包容心态等在所谓“工业革命4.0”的历史进程中弯道超车，把“人工智能”“大数据”“物联网”等计算机&lt;b&gt;应用&lt;/b&gt;学科列为了国家战略规划项目。&lt;/p&gt;&lt;p&gt;这些行业的从业人员也没有让大家失望，很多智能应用确实很大程度上改善了人们的生活体验（我回国手机刷个小黄车都兴奋不已(ｏ￣∇￣)见笑）。然而如此一来，计算机应用学科强大的优势便更容易让人们忽视对计算机基础学科的关注和发展（本来基础学科因为其回报不能被立即“看到”而已经受到了一定的忽视）。这其中最重要的计算机基础学科之一，也是在我国一直被忽视的学科，就是编程语言。&lt;/p&gt;&lt;p&gt;如果说硬件的核心是芯片，软件的核心便是编程语言。前一阵子中兴芯片事件闹得沸沸扬扬，当时我看到报道后既气愤又无奈。其实多少了解到咱们国家对芯片的研究是有投入的，然而由于芯片行业本身研究成本极高且要和各种国际上更重视更有钱的公司机构竞争，创新成本太大。可是编程语言作为软件的重要核心，研究成本照比硬件几乎为零，在我国却一直不被重视，因为很多人对编程语言学科抱有一种误解的态度：&lt;/p&gt;&lt;blockquote&gt;“通用的编程语言全世界就那么几个，该有的都有了，我也会用，有啥可研究的？总不会让我再去设计一个新的编程语言吧？那有啥用？而且也没人用啊！”&lt;/blockquote&gt;&lt;p&gt;如此，编程语言学科的研究很容易受到轻视，研究受到轻视导致了这门学科人才的缺失，&lt;b&gt;Label A&lt;/b&gt;:  人才缺失意味着没有足够专业的人来为其重要性发声（编程语言学科的人才本来就不多），又因为其作为基础学科发展效果不会像应用学科“立竿见影”，国家高等教育决策层便无法主动意识到发展它的必要，因此从决策层便不会发展这一学科并重视、引进相关人才, &lt;b&gt;goto Label A&lt;/b&gt;。无从责备啊╮(╯▽╰)╭&lt;/p&gt;&lt;p&gt;此外，由于编程语言是一门结构性很强、在国外发展了近60年如今仍旧活跃的重要计算机学科，因此绝对不是只要会编程、有博士学位和相关计算机或软件工程背景的人（如懂操作系统、体系结构、数据结构和算法、计算机网络啥的(-ι_- )很熟悉吧）就能教好其课程的专业。如此一来，我们国家缺乏编程语言方向相关的人才，势必造成今天国内高校编程语言教育落后的局面。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;重视编程语言教育真的很重要吗？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;“在X年内，进入世界知名大学行列；在X+Y年内，冲入世界一流大学行列”，这是近几年国内很多高校的通用口号模板。然而我们再来看看真正世界的“知名”“一流”大学（例如Top 100，包括MIT、Stanford、UC Berkeley、CMU、Cornell、UPenn、UW、Harvard、ETH、Oxford、Cambridge等太多名校），你会发现它们之中但凡有点规模的计算机院系，几乎都有编程语言（programmming languages）方向的教授或研究人员，而且往往排名越靠前的大学越重视编程语言，相关科研人员也越多，编程语言课程都是由这些专业人才讲授的。&lt;/p&gt;&lt;p&gt;反之，我国&lt;b&gt;绝大多数&lt;/b&gt;985、211高校无论计算机学院还是软件学院，编程语言方向居然没有全职教授（&lt;b&gt;几乎&lt;/b&gt;是南京大学冯新宇教授一个人为我国大陆高校计算机编程语言方向撑着场面，从顶会论文数量看）。此外，我国计算机学会有那么多计算机方向的专委，就是没有编程语言专委（注，形式化方法专委和软件工程专委根本无法取代编程语言专委，反之亦然）。&lt;/p&gt;&lt;p&gt;这一对比应该很说明问题了：不是我们有问题，就是我们学习的那些世界一流大学有问题。然而我前面也解释过了，于我而言，我国编程语言教育的落后和人才的缺失是个无从责备的问题；换言之，我相信如果咱们高校或教育决策层的领导意识到了这个问题的重要性，是有动力和能力解决它的（毕竟干实事为学生想的领导还是有的）。&lt;/p&gt;&lt;p&gt;刚刚，世界名校们用它们强大的编程语言教授阵容向我们客观地展示了编程语言教育的重要性。接下来，我想从个人和社会两个层面主观地谈谈提高编程语言教育质量的好处。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1. 个人&lt;/b&gt;&lt;/p&gt;&lt;p&gt;编程语言虽然复杂，但是其设计是遵循着一些基本规则的。不同语言的语法语义虽然有所不同，但一些基本的核是相似的（例如基于表达式扩展的语法和对基本数据类型的抽象），编程语言可以顺着这些核一点点展开，根据语言设计的初衷选择合适的编程范式（例如命令式还是函数式还是都要）进而对核进行相应的调整（例如函数本身是不是个基本数据类型），一点点添加需要的规则（例如什么样的scoping，什么样的类型系统）和特性（例如是否支持多线程，支持异步），这些规则特性与编程语言之核的组合，造就了今天编程语言的琳琅满目。&lt;/p&gt;&lt;p&gt;然而，我们如今绝大多数国内的教育不解释这些基本原理和它们与编程语言的本质关系，学生对编程语言缺乏一种抓得住的“全局观”和举一反三的能力，看到的都是被“糖化”后的语法和复杂的语用环境，所以感到语言太复杂、枯燥。如此一来，以下情形便容易解释了。例如，&lt;/p&gt;&lt;ul&gt;&lt;li&gt;你经常对编译器和解释器报出的错毫无头绪；&lt;/li&gt;&lt;li&gt;你无法理解为什么一些framework或library的用法是这样那样的，因此你只能靠着例子和pattern来编程，对于背后被封装和使用的原理一无所知，进而导致了一旦有问题自己便推不出原因，只能找google或有求于同事；&lt;/li&gt;&lt;li&gt;你对于大的任务该用什么样的编程语言或怎样使用其特性无法做出独立的思考，天经地义地觉得这是leader该管的事；&lt;/li&gt;&lt;li&gt;还有太多太多心有余力不足的情况。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因此，对于个人，受到更好的编程语言教育意味着可以更好的理解从语言本身到构建出的复杂软件系统，对于问题的“势”和通过编程手段解决问题的“器”也都会有更好的把握。&lt;/p&gt;&lt;p&gt;编程语言的教育好比是为了构建出每个人编程知识树的主干（这种结构性很强的知识体系是很难通过经验自我摸索的），每遇到新的问题都可以用已有的编程语言知识消化吸收（或在此基础上通过查找资料更容易对其理解），进而每一步编程经历的积累都是给自己的知识树添枝增叶，日积月累，你的程序可以不知觉地写的更快，更简洁易懂，更少错，更安全，也会更容易学习理解新的编程语言和软件框架。&lt;/p&gt;&lt;p&gt;更重要的是其可以帮助个人对编程语言产生更浓厚的兴趣，这对于程序员健康心态的调整很重要：没有兴趣，迫于生活压力各种收罗经验编织履历向别人证明你已走多远；有了兴趣一路打怪升级顺便带带小弟时刻提醒自己还差多远但一切却又怡然自得，事业幸福感油然而生，生活幸福感便交相辉映。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. 社会&lt;/b&gt;&lt;/p&gt;&lt;p&gt;随着社会对于信息化的不断依赖，软件势必走向复杂化，进而对于软件可靠性、高效性、安全性等都提出了新的挑战。这意味着日后对于程序员个人编程能力和素质都会有更高的要求（我后面会在应该如何讲授编程语言课程中简单提到几点）。因此，我国高校在培养软件人才方面应当应势所驱，重视编程语言的教育进而提高未来程序员编程素质、基本功和对待编程的兴趣，这对于整体提高处于信息化中的社会生产力是大有裨益的。随之而来的是软实力的质变，并一定会同时酝酿新技术的革新，因为基数和兴趣都得到提升，概率便不会让创造力失望。&lt;/p&gt;&lt;p&gt;简而言之，更好的编程语言教育可以切实地提高软件生产力，同时培育创新的沃土。例如，在大数据和智能计算的驱动下，很多行业都会利用自己领域内的数据进行一番智能变革（如医疗、城市建设、特种装备等），这给很多软件创新带来新的机遇，我们的程序员应该有能力有信心意识到，他们自己是可以创造或调制适合该行业领域应用的专属编程语言（如DSL），使得行业专家也可以很方便的使用语言编程，满足各种特定的可靠性、性能甚至知识产权等需求。这给新兴软件应用行业的创新提供了丰厚的技术资本，这些应用行业本身又会刺激市场，对计算机行业创新带来新的需求和机遇。&lt;/p&gt;&lt;p&gt;综上所述，重视并提高编程语言教育质量对个人和社会的发展都是大有裨益的。但是如何提高编程语言教育质量呢？最直接有效的方法就是讲授好编程语言课程。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;应该如何讲授编程语言课程？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这是一个引火烧身的问题啊。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先，这个问题没有正确答案，我相信每个人心中都有自己的看法。&lt;/li&gt;&lt;li&gt;其次，我对编程语言的理解和知识的掌握十分有限，我觉得知乎上很多编程语言爱好者还有很多有长时间编程经验的程序员都比我更懂编程语言（更不要提 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/a06cfb38e37dac1658e6457df4d7f032&quot; data-hash=&quot;a06cfb38e37dac1658e6457df4d7f032&quot; data-hovercard=&quot;p$b$a06cfb38e37dac1658e6457df4d7f032&quot;&gt;@RednaxelaFX&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/487163f4982c221d9e7b085a7c59cd46&quot; data-hash=&quot;487163f4982c221d9e7b085a7c59cd46&quot; data-hovercard=&quot;p$b$487163f4982c221d9e7b085a7c59cd46&quot;&gt;@TwoFrogs&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0970f947b898ecc0ec035f9126dd4e08&quot; data-hash=&quot;0970f947b898ecc0ec035f9126dd4e08&quot; data-hovercard=&quot;p$b$0970f947b898ecc0ec035f9126dd4e08&quot;&gt;@vczh&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/745f68a74a02e49711cc097e1855b1e1&quot; data-hash=&quot;745f68a74a02e49711cc097e1855b1e1&quot; data-hovercard=&quot;p$b$745f68a74a02e49711cc097e1855b1e1&quot;&gt;@蓝色&lt;/a&gt; 等这些大牛）。&lt;/li&gt;&lt;li&gt;再次，我本身没有专业的授课经验（只有tutor和偶尔的guest lecturer这种简单的经历），很难切身体会到那种潜在的“知识输出”和学生“知识接收”不对称的问题，但是我也相信，老师是可以通过自己的努力来尽量减小这种不对称的（我不是站着说话腰不疼，因为我以后也是要当老师的，我觉得我愿意在科研压力之外给自己这样的要求，我觉得这是为师者的本分）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以上一番自我觉悟后，我仍想通过结合国内高校编程语言教育的一些实际情况，简单阐述一下关于“应该如何讲授编程语言课程”的几点&lt;b&gt;个人看法&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1. 脉络和整体的把握  &lt;/b&gt;&lt;/p&gt;&lt;p&gt;一个比较好的编程语言课程的脉络可以是从简入深地“成长”一个编程语言。这个“成长”不是基于具体语言的语法和特征的（比如Java的基本数据类型，运算符，变量声明长啥样），而是基于语言的基本概念的。换言之，上一门真正意义的编程语言课（尽管这门课指定了一门需要掌握的具体编程语言），应该主要是为了学习隐藏在这门具体语言背后的、支撑它的编程语言理论知识，而这门具体的语言（它的语法、语义、语用等）是为了理解这些编程语言知识的。&lt;/p&gt;&lt;p&gt;例如，编程语言可以从数据抽象开始，通过表达式（expression）表达基本的“逻辑”和“运算”，引入条件和循环对其“控制”，引入函数对其“封装”，函数的封装需要scoping，函数的调用需要context等概念来支撑；再high-level一点，imperative语言抽象数据，用变量绑定，用状态存储；functional语言既抽象数据又抽象行为，因此可以通过表达式传递“计算”，可以无需状态存储；再high-level一点，object-oriented语言有了状态和行为的统一封装，引入了类和继承等基本概念，而后者又需要overwritten，field hidden等概念支撑等等等等。如此一来，在一点点“成长”讲解这些编程语言知识的同时，用特定的语言的语法、语义来具体解释这些概念和知识。如此，不但能更深刻地掌握一门具体的编程语言，也能帮助了解编程语言设计的整体和核心，这是举一反三的基础，更是兴趣和自信的源泉。&lt;/p&gt;&lt;p&gt;当然，有的老师可能愿意把整个编程语言安排成初级和高级两个课程，在前者中讲授一门具体语言，在后者中专门讲解编程语言的理论知识，这也是一个合理的设计。但我个人更偏好一起来讲，因为理论和实践同时相互刺激能引起更强的求知欲，原因很简单，理论需要实践来解释how，实践需要理论来支撑why，一个学生如果能同时知道why和how，没有理由不愿意了解更多，虽然最后有没有兴趣是学生自己的事，但是是否引导了学生的兴趣是教育的事。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. 讲授被忽略的重要编程语言知识&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如上所述，国内的编程语言课程更侧重针对某一门具体语言的讲解，而缺少对编程语言整体设计的理解和判断。这好比学人体素描不识人体骨骼构成，学中医不讲阴阳，学音乐不知乐理。如此一来，知识的理解受限且无法融会贯通，不可深究亦不能长远。接下来我用两个重要的（但在国内编程语言课中经常被忽略的）编程语言知识点“函数式编程”和“语言的静态动态类型”作为例子简单说明一下。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;函数式编程&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们国内编程语言课程接触到的一般都是命令式语言（imperative）像C、Java、C++等，其中面向对象（object-oriented简称OO）的理论也有所普及。很多人听说过函数式语言（functional）但是并不了解，感觉现在找工作并没有强制要求了解函数式编程，所以觉得不学无所谓。&lt;/p&gt;&lt;p&gt;实际上多少了解一下函数式编程的思维更有助于理解用代码“抽象”和“计算”的概念。例如，如果普通数据value可以抽象，为什么行为（behaviour/action）不能抽象？我们可以把行为（用函数function来表达）看成像数据一样的value（first-class citizens），这样一来传入function的argument既可以是普通value也可以是行为（function）本身（进而引出higher-order function的概念），这使得function可以通过其function参数来“多态”行为，而一次计算任务就可以看成一套“行为”的组合（function的传递和调用），这样在实现一些计算任务时，代码会更简洁，逻辑会更清晰。&lt;/p&gt;&lt;p&gt;如今“函数式编程”被应用在越来越多的主流OO编程语言中。例如编程一霸JavaScript广泛支持了函数式编程机制；企业级代码新秀Scala一直以OO与Functional的“完美”结合标榜自己；就连OO代言人Java在Java 8后也开始通过“糖化”语法来支持函数式编程（如lambda expression）。对于一些纯函数式语言像Haskell，已经成为很多特殊行业（如金融）的宠儿。因此，教一教函数式编程（或思维）对编程语言的理解和实践都是有益的。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;语言的静态动态类型&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;有的时候编程语言可以通过“静态语言”和“动态语言”进行分类，如Scala、Haskell属于前者，JavaScript、Python属于后者。因此，有必要讲讲为什么会有静动之分，为什么不能各自取代对方，这对于理解编程语言的设计初衷和面对不同编程任务如何选择语言，都是有帮助的。&lt;/p&gt;&lt;p&gt;简单而言，静态语言定义变量需要声明类型，调用函数需要匹配类型等，而动态语言一般没有这种类型声明和匹配的约束。前者程序在运行前一般需要编译器静态检查这些约束，而后者程序可以直接在解释器上动态裸奔。各自好处是容易理解的，根据能量守恒原则（胡扯），静态语言需要程序员费时费力照规矩办事，面对复杂系统能大量减少运行时错误，写出的程序也容易理解和便于分析；反之，动态语言解放编程者天性想啥写啥，直接上手直接运行，轻便省力，但更容易导致运行时错误，且代码一般只有自己当天能读懂（o_O）。这也解释了为啥复杂的企业级软件青睐于静态语言，而脚本或轻量级程序一般选可以迅速上手的动态语言。&lt;/p&gt;&lt;p&gt;理解了这些，也就更容易理解为啥有时候编程语言会“动中向静”（JavaScript和TypeScript，动态语言静态化），有时候会“静中有动”（Java和Reflection，静态语言通过metaobject开了个动态的口子），有时候会“静动兼修”（Gradual typing）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;3. 拓展一些常见的编程语言知识&lt;/b&gt;&lt;/p&gt;&lt;p&gt;有的时候拓展讲解一点常见的编程语言知识会更有趣且有启发性。我举两个简单的例子：继承和异常处理（两个都拿常见的Java语言为例吧）。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;继承&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;相信面向对象课程都有针对继承的讲解（毕竟OO三大件是封装、继承、多态），比如Java中的类和父类的继承关系以及继承带来的好处。但是往往我们有一种倾向，就是觉得存在即合理，因此觉得继承一定就是好的，进而通常并不讲解Java中这种基于类的继承的弊端。实际上这种Java基于类的继承方式被很多PL的人吐槽过（当然只吐槽它不好的地方），因为它在很多情况下会造成不必要的冗余和开销（简单说就是你可以和你爹很多基因一样，但是不代表你俩穿的衣服都是一样的）。实际上很多继承关系是可以被更轻量级的composition比如Mixin技术代替的（虽然不像Scala、Ruby等语言在语言层面原生态支持Mixin，Java在Java 8后通过interface default methods也可以间接实现Mixin）。有了这些了解，也可以更容易理解其它继承设计的初衷和意义了，比如JavaScript这种基于prototype的更轻便的继承方式。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;异常处理&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;说到异常处理最直观的感受就是一种编程语言提供的处理错误的机制。很多程序任务都不可避免地要处理各种可预判的错误，例如访问的文件不存在，取值的对象为空等等，在异常处理机制下，错误可以标准化也可以定制化，不同的错误可以根据其类型通过try/catch捕捉处理。实际上，在此基础上如果再拓展讲一点，学生也许能站在更高（更抽象）的层面看到编程语言背后的设计哲学。这一点就是“异常处理”背后体现的“逻辑分流”设计。程序本身有“主体逻辑”（以期待的输入进行任务计算完成输出），然而这一过程不可避免地要处理“错误逻辑”。如何让程序以及编程者的主体逻辑思维不受错误逻辑干扰（代码也会随之简洁易懂）是异常处理机制设计的一个重要初衷。有了上面“逻辑分流”的理解，学生以后看到例如JavaScript的Promise这样的特性（resolve和reject分流），就会更容易理解该特性设计的初衷并愿意在合适的编程场合使用该特性。&lt;/p&gt;&lt;p&gt;以上，我觉得对一些基础知识（如上面讲的“继承”“异常处理”等）拓展地讲解，学生更容易跳出某个语言本身，更容易站在编程语言设计层面上去思考（进而将知识融汇贯通形成自己的知识树），甚至有可能进一步思考各种奇形怪状语言的雏形，这种兴趣的代入和思考的启发应该是教育的重心。我也相信这种“由内而外”的“漫天想象”会带来日后很多有生命的创新。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;4. 对于语义的重视&lt;/b&gt;&lt;/p&gt;&lt;p&gt;编程语言的语义非常重要，学习好语义可以从本质上理解编程语言，因为它在教你运行（该语言写的）程序的解释器是如何思考工作的。大家知道很多通用编程语言有很长的规范来具体地描述语言的语法、语义和特性以及它们应该怎么被使用，很多市面上的编程语言书籍（例如XX程序设计语言，XX handbook，XX in action太多了）也是参考这些规范文档来撰写的。然而无论是官方的规范手册还是书籍都是用自然语言描写的，这就会产生很多歧义和覆盖不到一些特殊情况。这也意味着看书学习一个一个语法特性编程尝试后，也很难对语言有一个整体的了解，对于语言局部的细节也很难有准确的把握。&lt;/p&gt;&lt;p&gt;在这种背景下，编程语言的形式化语义显得尤其重要，它通过一套基于数学的形式化的描述，通过语言的语法定义其相应的语义（注，一般只定义语言的核心部分，因为实际的通用编程语言很复杂，很难形式化准确定义描述所有其特性语义，如此一来整个语言和其使用环境并不能够得到严谨准确地描述和证明，因此可以说如今的编程语言包括编译器和运行环境实际上都会有bug，只是很多都还没有暴露而已）。编程语言领域语义的研究有着较长的历史，很多国外顶级大学的编程语言课程都会有形式化语义的专门讲解，描述语义的方法也有很多（如denotational semantics，operational semantics等）。&lt;/p&gt;&lt;p&gt;然而，尽管编程语言语义很重要，我们国内的编程语言教育几乎忽略了这一块，据我所知，只有北京大学的熊英飞老师和南京大学的冯新宇老师等极少高校编程语言课上会单独讲授包括语义在内的语言理论知识（感谢他们！）&lt;/p&gt;&lt;p&gt;实际上，如果不是单独的程序语言理论课程也不用全面细致地讲解它们（这样会有些枯燥，毕竟我们不是法国人(￣▽￣&quot;)）。例如，如果编程课程选择学习的语言是Java，可以考虑把整个Java的核心部分的语法和语义拿出来，挑选一种语义方法比如operational semantics里的small-step state machine方法来描述并一一讲解语言的每个核心语法和其对应的语义，这样学生在掌握了描述语法、语义方法的同时，也在整体和细节上理解了Java，这非常有益于日后更好地理解编程语言并编写程序。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这篇文章从“写作动机”开始，先后针对“为什么我国不重视编程语言教育”，“好的编程语言教育会对个人和社会带来什么好处”，“应当如何讲授编程语言课程”几个问题逐一阐述了我的个人观点。从来没有花过这么多时间和心思写这种观点性的文章，但是写完又有一种内心的满足，因为如同在文中“写作动机”所述，“希望让更少的学生被惋惜，让更多的学生受鼓舞”，尽管只是编程语言这一小领域，我仍庆幸自己迈出的这一小步。&lt;/p&gt;&lt;p&gt;知乎是一个挺好的地方，虽然如今感受到了更多的浮躁，但仍然能看到人们对于知识的渴望和对于自己进步的渴求，尤其是那些在更新速度极快的计算机领域中的学生和程序员们。鉴于自己在国内受过的编程语言教育和在知乎上看到的形形色色的编程语言问题，我切实地感受到了我国编程语言教育的落后，如文中所述，这对信息时代下的个人和社会的发展都会带来不可估量的损失。&lt;/p&gt;&lt;p&gt;我虽资质平平，但仍想借此文发声：我国高校主管计算机和软件教育的领导们，各计算机学院软件学院的院长们，人工智能、物联网、大数据等计算机应用固然重要，但请不要忽视计算机基础、软件核心“编程语言”的教育和研究，毕竟所有应用软件都是编程语言写的，毕竟如今的计算机行业对程序员的“质”的要求越来越高，毕竟我们有着这么多渴望编程知识和兴趣的准程序员们。期待我国编程语言教育和科研的进步。&lt;/p&gt;&lt;p&gt;此致。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;后记&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;“国内编程语言教育”，即使是“浅谈”，我也觉得这个题目很大。我自知自己对编程语言的理解还很欠火候，也真心觉得编程能力与有很多工作经验的程序员相差甚远，因此每每下笔，都怕是妄谈，也尤为此，对文中每个观点都尽量客观地呈现自己所见所想。我在知乎上虽然是个nobody，但还是希望认可文中一些观点的知友们帮助宣传一下，别让这篇文章沉的那么快，希望能引发软件行业的同学们和程序员的一点思考，也希望能让那些关心学生和计算机教育的相关领导看到，真正帮助改变我国编程语言教育的现状。&lt;/p&gt;&lt;p&gt;最后，这篇文章这么长，能一直看完的人啊，我敬佩你（谢谢你！）ｂ（￣▽￣）ｄ&lt;/p&gt;&lt;hr&gt;&lt;blockquote&gt;这两天在写一篇&lt;b&gt;《浅谈 编程语言研究 与 程序分析》&lt;/b&gt;的文章，过几天会放上来，如果大家感兴趣并且闲着无聊，可以来看看。&lt;/blockquote&gt;&lt;hr&gt;&lt;p&gt;======2018年10月1日更新======&lt;/p&gt;&lt;p&gt;上面提到的文章写好了，在这里&lt;/p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45208498&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-177562a74b47d6e59e518120f85e7ead&quot; data-image-width=&quot;845&quot; data-image-height=&quot;591&quot; data-image-size=&quot;180x120&quot;&gt;啥玩应啊：浅谈 编程语言研究 与 程序分析&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>啥玩应啊</author>
<guid isPermaLink="false">2018-09-28-43914842</guid>
<pubDate>Fri, 28 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Recursion Schemes（四）空间换时间</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-09-24-45249950.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45249950&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e5a2a9858bfa0c0e317c6943a84edb5b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;引言&lt;/h2&gt;&lt;p&gt;我们对于 &lt;i&gt;Bananas, Lenses, Envelopes, and Barbed Wire&lt;/i&gt; 一文中介绍的 Recursion Scheme 的认识已然逐渐明朗，是时候引入一些新的内容了。&lt;a href=&quot;http://cs.ioc.ee/~tarmo/papers/inf99.pdf&quot;&gt;Primitive(Co)Recursion and Course-of-Value (Co)Iteration, Categorically&lt;/a&gt;，原论文完成的 7 年之后，Tarmo Uustalu 和 Varmo Vene 发表了这篇论文，其讨论并且形式化了 apomorphism （我们上一篇中已有所涉及），同时还讨论了两种新的 Recursion Scheme，histomorphism 和 futumorphism。&lt;/p&gt;&lt;p&gt;Primitive(Co)Recursion and Course-of-Value (Co)Iteration, Categorically 同样是一篇充满干货的文章，但由于使用了范畴论的定义，并且沿用了上一篇论文的表示方法，使得文章变得较为晦涩。我们使用 Haskell 来重新讨论一下论文中新的 Recursion Scheme，它们其实只不过是  paramorphisms 和 apomorphism 的变种而已。在实际中，它们提供了更加强大的表达能力以及清晰的语义。正如 Uustalu 和 Vene 所说：&lt;/p&gt;&lt;blockquote&gt; 我们相信那些热爱编程语言以及对于编程语言证明感兴趣的人们会因这些 Scheme 的简洁易懂而从中获益。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;文中代码使用的是 Haskell，其源码可以在&lt;a href=&quot;https://github.com/patrickt/recschemes/blob/master/src/Part4.lhs&quot;&gt;这里&lt;/a&gt;看到。&lt;/p&gt;&lt;h2&gt;前情回顾&lt;/h2&gt;&lt;p&gt;前文中我们定义了 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 一个 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt; 的不动点，具有 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt; 用来构造和析构[1]。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Term f = In { out :: f (Term f) }&lt;/code&gt;&lt;p&gt;我们定义了 Algebra 其应用在 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt; 上，得到单独的值 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Algebra f a = f a -&amp;gt; a&lt;/code&gt;&lt;p&gt;接着我们定义了 catamorphism &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 来自底向上[2]遍历嵌套数据结构。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;cata :: (Functor f) =&amp;gt; Algebra f a -&amp;gt; Term f -&amp;gt; a -- 译者注：原文为 cata :: (Functor f) =&amp;gt; Algebra f a -&amp;gt; a -&amp;gt; Term f，应为笔误
cata f = out &amp;gt;&amp;gt;&amp;gt; fmap (cata f) &amp;gt;&amp;gt;&amp;gt; f&lt;/code&gt;&lt;p&gt;但 catamorphism 有它的局限性，它在求值并向上传递结果的过程中丢失了原数据的信息，为了解决这个问题我们引入了 paramorphism，在传递结果的同时传递原数据的信息：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type RAlgebra f a = f (Term f, a) -&amp;gt; a

para :: Functor f =&amp;gt; RAlgebra f a -&amp;gt; Term f -&amp;gt; a
para f = out &amp;gt;&amp;gt;&amp;gt; fmap (id &amp;amp;&amp;amp;&amp;amp; para f) &amp;gt;&amp;gt;&amp;gt; f&lt;/code&gt;&lt;h2&gt;引入 Histomorphism&lt;/h2&gt;&lt;p&gt;Paramorphism 给了我们看到原数据的能力，但是这往往是不够的，我们有时不光会需要原数据的信息，同时还需要之前的计算结果。一个经典的例子是求斐波那契数列[3]，其常见的求解方法如下：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fib :: Int -&amp;gt; Int  
fib 0 = 0  
fib 1 = 1  
fib n = fib (n-1) + fib (n-2)&lt;/code&gt;&lt;p&gt;如果我们将这个函数表示成 catamorphism，那么虽然 &lt;code class=&quot;inline&quot;&gt;fib(n-1)&lt;/code&gt; 会被记录下来，但是我们需要重新计算一次 &lt;code class=&quot;inline&quot;&gt;fib(n-2)&lt;/code&gt;，这显然不太科学，那么有没有更好的解决方案呢？&lt;/p&gt;&lt;p&gt;熟悉命令式编程的同学可能会考虑把递归转化为迭代，但是这样就引入了可变状态。又或者我们可以引入记忆化搜索，但这样的办法也并不简洁。Uustalu 和 Vene 提出的 histomorphism 就是为了解决这一问题：我们可以记录历史上计算过的信息，这样的递归过程被称为 &lt;a href=&quot;https://en.wikipedia.org/wiki/Course-of-values_recursion&quot;&gt;course-of-value recursion&lt;/a&gt;，即对于当前值得计算依赖于多个历史值。&lt;/p&gt;&lt;p&gt;与其操作 &lt;code class=&quot;inline&quot;&gt;f a&lt;/code&gt;，我们直接定义 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt;，其在保持自己本身结构的同时，记录了 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，我们可以认为这就是 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 带有属性的一个变种：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Attr f a = Attr  
              { attribute :: a
              , hole      :: f (Attr f a)
              }&lt;/code&gt;&lt;p&gt;这个结构可以递归地保持其所有子节点的计算成果，&lt;code class=&quot;inline&quot;&gt;hole&lt;/code&gt; 保持了在 cata 中丢失的数据结构，&lt;code class=&quot;inline&quot;&gt;attribute&lt;/code&gt; 保持了计算的值。&lt;/p&gt;&lt;p&gt;使用 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt; 的结构保持了过去计算的历史（&lt;i&gt;history&lt;/i&gt;[4]），所以在上面定义的结构被称为 &lt;i&gt;histomorphism&lt;/i&gt;，同样地为了定义 histomorphism，我们需要先定义 algebra，一如 F-algebra 之于 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt;，或 R-algebra 之于 &lt;code class=&quot;inline&quot;&gt;para&lt;/code&gt;，定义 &lt;i&gt;CV-algebra&lt;/i&gt;，它表示 course-of-value algebra：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type CVAlgebra f a = f (Attr f a) -&amp;gt; a&lt;/code&gt;&lt;p&gt;其中之前的计算结果在 &lt;code class=&quot;inline&quot;&gt;hole&lt;/code&gt; 中，递归地存储了下来。&lt;/p&gt;&lt;p&gt;我们的 &lt;code class=&quot;inline&quot;&gt;histo&lt;/code&gt; 函数与 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;para&lt;/code&gt; 大体类似，首先解析 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt;，接着使用 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt; 应用到子节点求值，最后使用 CV-algebra 求当前节点值：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;histo :: Functor f =&amp;gt; CVAlgebra f a -&amp;gt; Term f -&amp;gt; a
histo h = out &amp;gt;&amp;gt;&amp;gt; fmap worker &amp;gt;&amp;gt;&amp;gt; h&lt;/code&gt;&lt;p&gt;那么 worker 的类型是什么呢？我们使用 Haskell 的 type hole 功能来检查一下[5]，我们在 worker 前面添加下划线表示一个 type hole，当编译完成的时候，GHC 就会提醒我们所有使用 type hole 的地方类型是什么。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;histo :: Functor f =&amp;gt; CVAlgebra f a -&amp;gt; Term f -&amp;gt; a
histo h = out &amp;gt;&amp;gt;&amp;gt; fmap _worker &amp;gt;&amp;gt;&amp;gt; h&lt;/code&gt;&lt;p&gt;运行 GHC 就可以得到 type hole 的类型信息了：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;/Users/patrick/src/morphisms/src/Main.hs:14:24: error:
    • Found hole: ‘_worker’ with type :: Term f -&amp;gt; Attr f a&lt;/code&gt;&lt;p&gt;这样 &lt;code class=&quot;inline&quot;&gt;Term f&lt;/code&gt; 就变换成了 &lt;code class=&quot;inline&quot;&gt;Attr f a&lt;/code&gt;，则 &lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt; 解析之后的 &lt;code class=&quot;inline&quot;&gt;f Term f&lt;/code&gt; 就变成了 &lt;code class=&quot;inline&quot;&gt;f Attr f a&lt;/code&gt; 正好可以传入 CVAlgebra，得到 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;一个 &lt;code class=&quot;inline&quot;&gt;Attr f a&lt;/code&gt;，包括一个 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 类型，以及一个递归类型 &lt;code class=&quot;inline&quot;&gt;f (Attr f a)&lt;/code&gt;，首先我们搭建 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt; 的框架，输入一个 &lt;code class=&quot;inline&quot;&gt;Term f&lt;/code&gt;，记为 &lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;，返回一个 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt;，包括上述两个部分。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;worker t = Attr _ _&lt;/code&gt;&lt;p&gt;第一个部分 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，可以使用 &lt;code class=&quot;inline&quot;&gt;histo&lt;/code&gt; 得到，这与 catamorphism 非常相似，因为 catamorphism 就是 histomorphism 去除掉历史信息的部分：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;worker t = Attr (histo h t) _&lt;/code&gt;&lt;p&gt;第二个部分需要 &lt;code class=&quot;inline&quot;&gt;f (Attr f a)&lt;/code&gt;，我们可以把 &lt;code class=&quot;inline&quot;&gt;out&lt;/code&gt; 应用到 &lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt; 上，来获得 &lt;code class=&quot;inline&quot;&gt;f (Term f)&lt;/code&gt;，接着因为 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt;，我们可以使用 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;， 所以我们需要一个 &lt;code class=&quot;inline&quot;&gt;Term f -&amp;gt; Attr f a&lt;/code&gt; 类型的函数，而这正是 &lt;code class=&quot;inline&quot;&gt;worker&lt;/code&gt; 本身！&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;worker t = Attr (histo h t) (fmap worker (out t))&lt;/code&gt;&lt;p&gt;这正是 &lt;code class=&quot;inline&quot;&gt;histo&lt;/code&gt; 的有趣之处，同包含 &lt;code class=&quot;inline&quot;&gt;worker&lt;/code&gt;，而它又包含 &lt;code class=&quot;inline&quot;&gt;histo&lt;/code&gt; 这样的二重递归结构，完整代码如下：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;histo :: Functor f =&amp;gt; CVAlgebra f a -&amp;gt; Term f -&amp;gt; a
histo h = out &amp;gt;&amp;gt;&amp;gt; fmap worker &amp;gt;&amp;gt;&amp;gt; h where
    worker t = Attr (histo h t) (fmap worker (out t))&lt;/code&gt;&lt;p&gt;但是，这个写法中子过程的计算不能被很好地共享，每个 &lt;code class=&quot;inline&quot;&gt;worker&lt;/code&gt; 会重新计算，而非复用之前的结果，所以我们需要对代码进行一些改写：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;histo :: Functor f =&amp;gt; CVAlgebra f a -&amp;gt; Term f -&amp;gt; a  
histo h = worker &amp;gt;&amp;gt;&amp;gt; attribute where  
  worker = out &amp;gt;&amp;gt;&amp;gt; fmap worker &amp;gt;&amp;gt;&amp;gt; (h &amp;amp;&amp;amp;&amp;amp; id) &amp;gt;&amp;gt;&amp;gt; mkAttr
  mkAttr (a, b) = Attr a b&lt;/code&gt;&lt;p&gt;我们来分析下上面这段代码的运行原理，&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt; 函数捕捉并保持了 &lt;code class=&quot;inline&quot;&gt;worker&lt;/code&gt; 函数的运行结果，去除掉这一部分，函数完全等价为 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt;，正是保持了这一部分使得我们可以将历史信息保持在 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt; 中，可以认为它的每一步都保存了当前的计算结果的快照。所以通过保持计算结果，我们实际上就实现了一个折叠过程中的缓存。&lt;/p&gt;&lt;p&gt;刚才我们使用斐波那契数列作为 course-of-value 的一个例子，但是这里我们不会使用 &lt;code class=&quot;inline&quot;&gt;histo&lt;/code&gt; 去计算第 n 项的数值（不过这是个不错的习题），我们将解决一个更加有趣一点的问题，histomorphism 将显示出其简洁与强大之处，同类问题也可以很好地泛化。&lt;/p&gt;&lt;h2&gt;硬币找零&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Change-making_problem&quot;&gt;硬币找零问题&lt;/a&gt;是算法领域非常经典的一类问题，经典的版本为给出面值为 &lt;code class=&quot;inline&quot;&gt;N&lt;/code&gt; 的纸币，以及一个可以选用的面值的硬币零钱（1角，5角等）问有多少种找零的方法？最常见的做法为使用动态规划求解，那么如何使用 histomorphism 来解决这一问题呢？&lt;/p&gt;&lt;p&gt;我们首先定义可找的零钱种类：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Cent = Int

coins :: [Cent]  
coins = [50, 25, 10, 5, 1]&lt;/code&gt;&lt;p&gt;接着定义函数 &lt;code class=&quot;inline&quot;&gt;change&lt;/code&gt;，它接受一个数额，并返回可找零钱的方法数：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;change :: Cent -&amp;gt; Int&lt;/code&gt;&lt;p&gt;硬币找零问题实际是&lt;a href=&quot;https://en.wikipedia.org/wiki/Knapsack_problem&quot;&gt;背包问题&lt;/a&gt;的一个特例，本文对算法本身不做过多叙述，大家可以在链接中找到详细说明。如前所述，我们可以使用 histomorphism 来解决这类问题。但是这里的第一个难题就是，我们需要一个可以遍历的数据结构！我们只有自然数，不是链表，不是数组，也不是树，更不是函子，那么怎么在整数上做递归遍历呢？&lt;/p&gt;&lt;p&gt;实际上我们需要将整数以一种不太常见的方式进行定义，每一个整数不是零，就是之前的数字 +1。换句话说，我们需要的是&lt;a href=&quot;https://en.wikipedia.org/wiki/Peano_axioms&quot;&gt;皮亚诺公理&lt;/a&gt;，我们定义 &lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt;[6]：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Nat a  
    = Zero
    | Next a
    deriving Functor&lt;/code&gt;&lt;p&gt;这样我们使用 &lt;code class=&quot;inline&quot;&gt;Term Nat&lt;/code&gt; 就可以表示自然数了：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;one, two, three :: Term Nat
one   = In (Next (In Zero))
two   = In (Next one)
three = In (Next two)&lt;/code&gt;&lt;p&gt;我们也需要定义与 &lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt; 相互转换的辅助函数：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;-- Convert from a natural number to its foldable equivalent, and vice versa.  
expand :: Int -&amp;gt; Term Nat  
expand 0 = In Zero  
expand n = In (Next (expand (n - 1)))

compress :: Nat (Attr Nat a) -&amp;gt; Int  
compress Zero              = 0  
compress (Next (Attr _ x)) = 1 + compress x&lt;/code&gt;&lt;p&gt;下面我们定义 &lt;code class=&quot;inline&quot;&gt;change&lt;/code&gt; 函数，它接受数额 &lt;code class=&quot;inline&quot;&gt;amt&lt;/code&gt;，其中 CVAlgebra 我们定义为 &lt;code class=&quot;inline&quot;&gt;go&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;change :: Cent -&amp;gt; Int  
change amt = histo go (expand amt) where&lt;/code&gt;&lt;p&gt;其中的 &lt;code class=&quot;inline&quot;&gt;go&lt;/code&gt; 函数需要实现的即为算法中递推公式的部分，其定义如下：（译者注，原文中的代码有错误，具体可见&lt;a href=&quot;https://github.com/patrickt/recschemes/issues/1&quot;&gt;这里&lt;/a&gt;的讨论）&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;go :: Nat (Attr Nat Int) -&amp;gt; Int
go Zero = 1
go curr@(Next attr) = let
  given = compress curr
  validCoins = filter (&amp;lt;= given) coins
  in sum (map (lookup attr) validCoins)

lookup :: Attr Nat a -&amp;gt; Int -&amp;gt; a
lookup cache 1 = attribute cache
lookup cache n = lookup inner (n - 1) where (Next inner) = hole cache&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;go Zero = 1&lt;/code&gt;，定义了动态规划的初始状态，首先通过调用 &lt;code class=&quot;inline&quot;&gt;compress&lt;/code&gt; 函数，可以获得当前的递推位置，接着通过 &lt;code class=&quot;inline&quot;&gt;validCoins&lt;/code&gt; 筛选出符合要求的前置状态，通过 &lt;code class=&quot;inline&quot;&gt;lookup&lt;/code&gt; 函数得到这些前置状态的 &lt;code class=&quot;inline&quot;&gt;attribute&lt;/code&gt;，其加和即为结果。&lt;/p&gt;&lt;h2&gt;动态缓存&lt;/h2&gt;&lt;p&gt;注意到 &lt;code class=&quot;inline&quot;&gt;f (Attr f a)&lt;/code&gt; 的缓存形状实际上随着函子 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 的变化而变化，当 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt; 时，&lt;code class=&quot;inline&quot;&gt;Attr Nat a&lt;/code&gt; 实际上同构于 &lt;code class=&quot;inline&quot;&gt;[]&lt;/code&gt;，这也是为什么 &lt;code class=&quot;inline&quot;&gt;lookup&lt;/code&gt; 的实现方式与 &lt;code class=&quot;inline&quot;&gt;!!&lt;/code&gt; 的实现是同构的原因。&lt;/p&gt;&lt;p&gt;而如果我们将函子 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 定为 &lt;code class=&quot;inline&quot;&gt;[]&lt;/code&gt;，那么 &lt;code class=&quot;inline&quot;&gt;Attr [] a&lt;/code&gt; 则同构于多叉树，同理如果 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;Either b&lt;/code&gt; 那么 &lt;code class=&quot;inline&quot;&gt;Attr (Either b) a&lt;/code&gt;，同构于一个终止状态为 &lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt; 的非空列表。&lt;/p&gt;&lt;p&gt;对于任意可折叠的嵌套式结构，&lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt; 会自动生成与之相匹配的缓存，而且是完全自动的，而这也是动态缓存的含义所在。&lt;/p&gt;&lt;h2&gt;替代 Paramorphism&lt;/h2&gt;&lt;p&gt;与之前一样，我们使用 Histomorphism 来替代 Paramorphism。在这之前我们先看一下替代 Catamorphism 的情况，使用 Histomorphism 替代 Catamorphism 非常简单，我们只需要忽视 &lt;code class=&quot;inline&quot;&gt;hole&lt;/code&gt; 里面的值就好了，在传入 F-algebra 之前，CV-algebra 需要做的是使用 &lt;code class=&quot;inline&quot;&gt;attribute&lt;/code&gt; 取值即可：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;cata :: Functor f =&amp;gt; Algebra f a -&amp;gt; Term f -&amp;gt; a  
cata f = histo (fmap attribute &amp;gt;&amp;gt;&amp;gt; f)&lt;/code&gt;&lt;p&gt;与之类似地，我们也可以表达 Paramorphism，我们只需要提取出 &lt;code class=&quot;inline&quot;&gt;hole&lt;/code&gt; 中与 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 有关的部分即可，我们需要将 &lt;code class=&quot;inline&quot;&gt;f (Attr f a)&lt;/code&gt; 转化为 &lt;code class=&quot;inline&quot;&gt;f (Term f, a)&lt;/code&gt;（实际上这也是原论文的语法符号非常怪异的原因之一，在一个真实的语言中实现这些不可避免地需要引入很多这样的语法噪音）：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;para :: Functor f =&amp;gt; RAlgebra f a -&amp;gt; Term f -&amp;gt; a  
para f = histo (fmap worker &amp;gt;&amp;gt;&amp;gt; f) where  
  worker (Attr a h) = (In (fmap (worker &amp;gt;&amp;gt;&amp;gt; fst) h), a)&lt;/code&gt;&lt;h2&gt;伪结语&lt;/h2&gt;&lt;p&gt;由于原文这一章的内容相比于之前章节显著地增多，我决定把原文拆成两部分，在下一部分中，我们会使用翻转箭头的技巧来讨论 Histomorphism 的对偶形式 Futumorphism 并给出例子。心急的朋友可以在&lt;a href=&quot;https://blog.sumtypeofway.com/recursion-schemes-part-iv-time-is-of-the-essence/#fn9&quot;&gt;这里&lt;/a&gt;看到原文。&lt;/p&gt;&lt;p&gt;感谢大家能耐心读到这里！&lt;/p&gt;&lt;p&gt;祝大家中秋快乐！&lt;/p&gt;&lt;p&gt;[1]: Bob Harper，在 &lt;i&gt;Practical Foundations for Programming Languages&lt;/i&gt; 中，曾将这样的操作称为 “rolling” 和 “unrolling”。这也是非常形象的：&lt;code class=&quot;inline&quot;&gt;(f (Term f)) -&amp;gt; f (Term f) -&amp;gt; Term f&lt;/code&gt; 的过程就像是一个平面卷起的样子，而 &lt;code class=&quot;inline&quot;&gt;Term f -&amp;gt; f (Term f) -&amp;gt; f (f (Term f))&lt;/code&gt; 就像是对应的展开的过程。&lt;/p&gt;&lt;p&gt;[2]: Rob Rix 的&lt;a href=&quot;https://twitter.com/rob_rix/status/793430628637274112&quot;&gt;文章&lt;/a&gt;，曾论证过，尽管我们常说 catamorphism 是自底向上的，但这一描述是不够准确的：catamorphism 的 递归过程是自顶向下的，而在求值的部分才是自底向上的&lt;/p&gt;&lt;p&gt;[3]: 令人遗憾的是，在这个经典的例子中，recursion scheme 并不能表现它的威力。相比之下，我们常见的写法会更加简明。所以斐波那契数列或许并不是好的例子，在之后的文章中，我会尽量使用更加有趣优雅的例子，以免给大家留下 recursion scheme 笨重无用且对现实世界毫无价值的错误印象。&lt;/p&gt;&lt;p&gt;[4]: history 的词源相当复杂，主要来自于希腊语 “ἱστορία”，表示已经学到的东西，它还有 “ἱστορέω” 的变形，表示在研究中学习，而这又来自于 “ἵστωρ” ，表示掌握知识或者专家，这也与历史最开始口口相传的情况吻合，而希腊词根 “ἱστο”，则含有网（web）的意思，也与 &lt;code class=&quot;inline&quot;&gt;Attr&lt;/code&gt;，保持和生成数据的方式吻合。&lt;/p&gt;&lt;p&gt;[5]: 这一功能借鉴自 Agda 和 Idris。&lt;/p&gt;&lt;p&gt;[6]: 敏锐的读者可能会发现这一定义与 &lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt; 是等价的，这里的定义是为了使用更加符合自然数本质的结构。 &lt;/p&gt;</description>
<author>禾木旁</author>
<guid isPermaLink="false">2018-09-24-45249950</guid>
<pubDate>Mon, 24 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>函数式编程与数字电路</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-09-14-44000409.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/44000409&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前函数式编程应用主要是在编译器（Haskell，ml），以及大数据和分布式系统（Scala），但其实用函数式语言编写硬件逻辑电路也有一段历史了，特别是开源的RISC V 最近让Chisel好好火了一把，这一幕挺像当年的Spark。除了基于Scala的Chisel外，还有一门是基于Haskell的Clash。Chisel是利用macro元编程和Scala原本的编译器，实现了一个可以方便构建RTL的库，而后者的方法更激进，是通过修改Haskell的编译器GHC来直接把Haskell代码转变为RTL。&lt;/p&gt;&lt;p&gt;需要注意的是，虽然他们都是基于非常高层的抽象语言，但是和所谓的High Level Synthesis没什么关系，要实现任何东西都是需要自己在RTL级别进行构建和思考的，编译器并不会变魔术一样帮你实现某些算法，可以把他们看作是某些语法糖，理论上仍然是可以把Verilog再编译回去的，而不像Haskell编译为汇编那样不可逆。&lt;/p&gt;&lt;p&gt;那为啥不老老实实用Verilog？虽然都是RTL，但是他们相当于给Verilog加上了部分元编程的能力，所以最后生成的Verilog代码大小可能会让人惊叹。另一个是模块化，在项目一大以后优势就体现出来了，Scala的Trait，Haskell的Type Class，都能够更好的组织代码。在编辑器方面，Scala有开源免费的Intellij ，用起来是非常爽的，能提升不少战斗力，另外Haskell的VS code也不错。&lt;/p&gt;&lt;p&gt;Chisel和Clash除了语法和实现，感觉差异不是很大，Clash由于是基于Haskell而且严重依赖Type Class，所以学习曲线更加陡峭，不过Chisel深入学习以后也需要了解下Subtyping相关的类型系统知识。定制化方面，Chisel的架构更灵活一些，分离出了一个叫Firrtl的IR，比较容易加入某些中间代码变换。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;关于Chisel对于生产力的提升，可以看看 @&lt;a href=&quot;https://www.zhihu.com/people/xfguo&quot;&gt;郭雄飞&lt;/a&gt; 的回答&lt;/p&gt;&lt;a href=&quot;https://www.zhihu.com/question/58584770/answer/284119982&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-a5b864ff40c14ea5bd899c6072809019&quot; data-image-width=&quot;120&quot; data-image-height=&quot;120&quot; data-image-size=&quot;ipico&quot;&gt;https://www.zhihu.com/question/58584770/answer/284119982&lt;/a&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/58584770/answer/284119982&quot;&gt;郭雄飞：RISC-V开源项目为什么选用chisel这种新的高层次建模语言，而不是SystemVerilog?&lt;/a&gt;&lt;/p&gt;&lt;a href=&quot;https://www.zhihu.com/question/58584770/answer/284119982&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-a5b864ff40c14ea5bd899c6072809019&quot; data-image-width=&quot;120&quot; data-image-height=&quot;120&quot; data-image-size=&quot;ipico&quot;&gt;RISC-V开源项目为什么选用chisel这种新的高层次建模语言，而不是SystemVerilog?&lt;/a&gt;&lt;a href=&quot;https://github.com/freechipsproject/chisel3/wiki&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;v2-3adf1d09765d5840cf68feec5eeda97e&quot; data-image-width=&quot;420&quot; data-image-height=&quot;420&quot; data-image-size=&quot;ipico&quot;&gt;freechipsproject/chisel3&lt;/a&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Martin awodey</author>
<guid isPermaLink="false">2018-09-14-44000409</guid>
<pubDate>Fri, 14 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Recursion Schemes（三）基于上下文的折叠</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-09-02-43560128.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43560128&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e5a2a9858bfa0c0e317c6943a84edb5b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;前情回顾&lt;/h2&gt;&lt;p&gt;在上一篇文章中，我们定义了 catamorphism，一种一般性的遍历嵌套数据结构的手段，但是这一方法有它的局限性，本章中我们将讨论这些局限，并介绍更强力的遍历手段 paramorphism&lt;/p&gt;&lt;p&gt;如前所述，本文的代码可以在&lt;a href=&quot;https://github.com/patrickt/recschemes/blob/master/src/Part3.hs&quot;&gt;这里&lt;/a&gt;找到。&lt;/p&gt;&lt;p&gt;在过去的两篇文章中，我们定义了 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 来表示函子 &lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt; 的不动点，并使用 &lt;code class=&quot;inline&quot;&gt;In&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Out&lt;/code&gt; 来作为构造和析构函数，从而使 &lt;code class=&quot;inline&quot;&gt;Term f&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;f (Term f)&lt;/code&gt; 相互联系了起来：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Term f = In { out :: f (Term f) }&lt;/code&gt;&lt;p&gt;接着利用 &lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt; 的递归特性，我们定义了可以在 &lt;code class=&quot;inline&quot;&gt;Term f&lt;/code&gt; 上进行变换的 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;bottomUp :: Functor a =&amp;gt; (Term a -&amp;gt; Term a) -&amp;gt; Term a -&amp;gt; Term a  
bottomUp fn =  
  out                    -- 1) 解析结构
  &amp;gt;&amp;gt;&amp;gt; fmap (bottomUp fn) -- 2) 递归
  &amp;gt;&amp;gt;&amp;gt; In                 -- 3) 构造结构
  &amp;gt;&amp;gt;&amp;gt; fn                 -- 4) 应用&lt;/code&gt;&lt;p&gt;当我们不考虑重新构造结构的部分以后，我们得到了 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt;，可以使 &lt;code class=&quot;inline&quot;&gt;Term f&lt;/code&gt; 变成某种累加值 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，使用 &lt;code class=&quot;inline&quot;&gt;Algebra&lt;/code&gt; 将 &lt;code class=&quot;inline&quot;&gt;f a&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 联系了起来：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Algebra f a = f a -&amp;gt; a

cata :: (Functor f) =&amp;gt; Algebra f a -&amp;gt; Term f -&amp;gt; a  
cata fn =  
    out                -- 1) 解析结构
    &amp;gt;&amp;gt;&amp;gt; fmap (cata fn) -- 2) 递归
    &amp;gt;&amp;gt;&amp;gt; fn             -- 3) 应用&lt;/code&gt;&lt;h2&gt;Paramorphism&lt;/h2&gt;&lt;p&gt;Catamorphism 相当简单优雅，但往往在现实中并不实用，因为在遍历过程中，它丢失了原有结构与上下文信息，比如在上一章中文档生成的例子里，我们只能对当前节点生成文档，因为其它所有子节点已经变成了文档的一部分。&lt;/p&gt;&lt;p&gt;这在我们需要上下文信息来进行判断的场景中会变得非常麻烦，比如我希望在函数无参数时，文档以特殊格式显示该函数，那么我必须重新解析文档来获取之前关于函数参数的信息，这显然非常笨拙。&lt;/p&gt;&lt;p&gt;一个显然更优雅的解法就是在 &lt;code class=&quot;inline&quot;&gt;Algebra&lt;/code&gt; 生成最终结果的时候，我们能同时保留原始的上下文信息，&lt;code class=&quot;inline&quot;&gt;Algebra&lt;/code&gt; 的输入是 &lt;code class=&quot;inline&quot;&gt;f a&lt;/code&gt; 如果我们能保持原有的结构 &lt;code class=&quot;inline&quot;&gt;Term f&lt;/code&gt;，同时也能拿到当前的结果 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，并以两者一同作为输入：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;f (Term f, a) -&amp;gt; a&lt;/code&gt;&lt;p&gt;我们把这样的结构定义为 &lt;code class=&quot;inline&quot;&gt;R-algebra&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type RAlgebra f a = f (Term f, a) -&amp;gt; a&lt;/code&gt;&lt;p&gt;与之对应的，使用 &lt;code class=&quot;inline&quot;&gt;R-algebra&lt;/code&gt; 来进行数据结构遍历的机制被称为 &lt;i&gt;paramorphism&lt;/i&gt;，同样从词源的角度分析，paramorphism 的词缀 &lt;i&gt;para&lt;/i&gt; 实际上与 &lt;i&gt;parallel&lt;/i&gt; 的相同——来自于希腊语 παρά，代表“旁边”，“临近”，“一旁”的含义[1]。除去可以看到当前位置的上下文，paramorphism 和 catamorphism 实际上非常相似。&lt;/p&gt;&lt;p&gt;下面我们来看下 paramorphism 的具体实现，我们不能再直接地使用 &lt;code class=&quot;inline&quot;&gt;fmap para&lt;/code&gt; 我们的函数返回了一个元组，我们需要解析并递归其中的表达式，同时保持原来的结构，为止我们定义了一个附属函数 &lt;code class=&quot;inline&quot;&gt;fanout&lt;/code&gt;，它接受一个 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 并且返回递归结果和 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 本身。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;para :: (Functor f) =&amp;gt; RAlgebra f a -&amp;gt; Term f -&amp;gt; a  
para rAlg = out &amp;gt;&amp;gt;&amp;gt; fmap fanout &amp;gt;&amp;gt;&amp;gt; rAlg  
    where fanout :: Term f -&amp;gt; (Term f, a)
          fanout t = (t, para rAlg t)&lt;/code&gt;&lt;p&gt;就这么简单！这就是 paramorphism 的经典定义，我们现在可以在保持原有的信息和结构的同时，获得我们想要的结果。其实 Haskell 甚至可以给出更优雅的实现，使用 &lt;code class=&quot;inline&quot;&gt;Control.Arrow&lt;/code&gt; 提供的 &lt;code class=&quot;inline&quot;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; 组合子，它接收两个函数 &lt;code class=&quot;inline&quot;&gt;foo&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;bar&lt;/code&gt;[2]，并且返回一个函数，它的输入是 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，返回是 &lt;code class=&quot;inline&quot;&gt;(foo a, bar a)&lt;/code&gt; 的元组。它将两个函数的输出进行了组合。&lt;/p&gt;&lt;p&gt;所以我们的 &lt;code class=&quot;inline&quot;&gt;fanout&lt;/code&gt; 可以构造为：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fanout = id &amp;amp;&amp;amp;&amp;amp; para f&lt;/code&gt;&lt;p&gt;所以原代码可以改写为：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;para&#39; :: Functor f =&amp;gt; RAlgebra f a -&amp;gt; Term f -&amp;gt; a  
para&#39; f = out &amp;gt;&amp;gt;&amp;gt; fmap (id &amp;amp;&amp;amp;&amp;amp; para&#39; f) &amp;gt;&amp;gt;&amp;gt; f&lt;/code&gt;&lt;p&gt;是不是简洁了许多？&lt;/p&gt;&lt;h2&gt;替代 Catamorphism&lt;/h2&gt;&lt;p&gt;实际上我们之前到 &lt;code class=&quot;inline&quot;&gt;RAlgebra&lt;/code&gt; 中元组的定义也不无改进空间，我们可以将它使用函数重写：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type RAlgebra&#39; f a = Term f -&amp;gt; f a -&amp;gt; a&lt;/code&gt;&lt;p&gt;那么随之我们对 &lt;code class=&quot;inline&quot;&gt;para&lt;/code&gt; 的定义也需要随之修改：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;-- &amp;amp; 函数的作用是逆序函数的调用顺序，  
-- 与 $ 操作符类似，不过执行的顺序相反
para&#39;&#39; :: Functor f =&amp;gt; RAlgebra&#39; f a -&amp;gt; Term f -&amp;gt; a  
para&#39;&#39; alg t = out t &amp;amp; fmap (para&#39;&#39; alg) &amp;amp; alg t&lt;/code&gt;&lt;p&gt;正如 &lt;code class=&quot;inline&quot;&gt;bottomUp&lt;/code&gt; 可以用 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 表达，&lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 也可以用 &lt;code class=&quot;inline&quot;&gt;qara&lt;/code&gt; 来表达，我们只需要忽略掉额外传入的 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt; 即可，我们使用 Haskell 提供的 &lt;code class=&quot;inline&quot;&gt;const&lt;/code&gt; 函数即可（即 K-组合子）：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;cata&#39; :: Functor f =&amp;gt; Algebra f a -&amp;gt; Term f -&amp;gt; a  
cata&#39; f = para&#39;&#39; (const f)&lt;/code&gt;&lt;p&gt;这正是 Recursion Scheme 的优美之处，我们不断引入新的更强大的构造结构，而旧的总能被新的所表达。&lt;/p&gt;&lt;h2&gt;举个例子&lt;/h2&gt;&lt;p&gt;对于 &lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt; 函数来说，直接返回它的参数，我们可以等价地用 &lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt; 来替换 &lt;code class=&quot;inline&quot;&gt;id(x)&lt;/code&gt; 我们来考虑一个我们前文提到的的文档生成器，出于某些原因[3]，我们希望在文档中进行这个优化。&lt;/p&gt;&lt;p&gt;我们需要检查每个函数调用，通过判断函数名是否为 &lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt; 来决定是否直接返回参数，这正是使用 paramorphism 的地方，我们这里使用的语法树与之前的一样：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fastPretty :: RAlgebra&#39; Expr Doc

-- 除了 Call 节点的定义，其他部分与之前的定义均相同
fastPretty _ (Literal i) = P.int i  
fastPretty _ (Ident s)   = P.text s  

-- Call 节点正是我们感兴趣的部分，我们会检查它的第一个参数是否为 id，如果是的话，我们只返回参数部分

fastPretty (In Call { func = &quot;id&quot; })  
           Call {args = [theArg]} = theArg
fastPretty _ (Call f as)     = f &amp;lt;&amp;gt; P.parens (P.cat (P.punctuate &quot;, &quot; as))  
-- The other cases are the same as `prettyPrint` in the last installment.&lt;/code&gt;&lt;p&gt;当我们在遍历结构时需要上下文，那么 Paramorphism 就会变成一个不错的选择。&lt;/p&gt;&lt;h2&gt;Apomorphism&lt;/h2&gt;&lt;p&gt;在上一篇文章中，我们通过翻转箭头的技巧实现了 &lt;code class=&quot;inline&quot;&gt;ana&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;cata&lt;/code&gt; 的对偶：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;cata f = out &amp;gt;&amp;gt;&amp;gt; fmap (cata f) &amp;gt;&amp;gt;&amp;gt; f

ana f = In &amp;lt;&amp;lt;&amp;lt; fmap (ana f) &amp;lt;&amp;lt;&amp;lt; f&lt;/code&gt;&lt;p&gt;而 &lt;code class=&quot;inline&quot;&gt;ana&lt;/code&gt; 的参数就被表示为 &lt;code class=&quot;inline&quot;&gt;Coalgebra&lt;/code&gt;，作为 &lt;code class=&quot;inline&quot;&gt;Algebra&lt;/code&gt; 的对偶：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Coalgebra f a = a -&amp;gt; f a

ana f :: (Functor f) =&amp;gt; Coalgebra f a -&amp;gt; a -&amp;gt; Term f&lt;/code&gt;&lt;p&gt;同理，我们也会看到 paramorphism 的对偶，&lt;i&gt;apomorphism&lt;/i&gt;，apo 的词缀来源于希腊语，ἀπο，代表“远离”或“分离”的意思，如在 “apogee” （月球位于远地点）或 “apostasy”（背教，变节），所以我们来看看 R-algebra 的对偶是怎样的。我们先翻转箭头看看：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Nope = a -&amp;gt; f (Term f, a)&lt;/code&gt;&lt;p&gt;不对！我们这里必须将 &lt;code class=&quot;inline&quot;&gt;RAlgebra&lt;/code&gt; 中所有的构造部分都进行翻转，我们确实可以翻转函数的方向，但注意，我们还有元组，那么一个元组的对偶是什么呢？&lt;/p&gt;&lt;p&gt;元组包含它的所有子元素，什么它的对偶就是只包含其中一个元素亦即：&lt;code class=&quot;inline&quot;&gt;Either&lt;/code&gt;，所以对于一个同时包含 &lt;code class=&quot;inline&quot;&gt;Term f&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 的元组我们使用 &lt;code class=&quot;inline&quot;&gt;Either&lt;/code&gt; 来表示它的对偶：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type RCoalgebra f a = a -&amp;gt; f (Either (Term f) a)&lt;/code&gt;&lt;p&gt;好吧，那么这在实践中的含义是什么呢？这表示我们可以在展开的过程中进行计算，如果我们返回了 &lt;code class=&quot;inline&quot;&gt;Left&lt;/code&gt; 其中包含一个 &lt;code class=&quot;inline&quot;&gt;Term&lt;/code&gt;，那么 apomorphism 会结束并返回一个叶子节点，单如果我们决定返回 &lt;code class=&quot;inline&quot;&gt;Right&lt;/code&gt; 其中包含一个 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，那么展开就会继续下去，我们可以根据参数的情况来决定之后展开的操作，所以就不需要考虑 &lt;code class=&quot;inline&quot;&gt;break&lt;/code&gt; 或异常处理了。&lt;/p&gt;&lt;p&gt;同样地使用翻转箭头的技巧，我们来看看 &lt;code class=&quot;inline&quot;&gt;para&lt;/code&gt; 的对偶 &lt;code class=&quot;inline&quot;&gt;apo&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;para&#39; :: Functor f =&amp;gt; RAlgebra f a -&amp;gt; Term f -&amp;gt; a  
para&#39; f = out &amp;gt;&amp;gt;&amp;gt; fmap fanout &amp;gt;&amp;gt;&amp;gt; f where fanout = id &amp;amp;&amp;amp;&amp;amp; para&#39; f

apo f :: Functor f =&amp;gt; RCoalgebra f a -&amp;gt; a -&amp;gt; Term f  
apo f = In &amp;lt;&amp;lt;&amp;lt; fmap fanin &amp;lt;&amp;lt;&amp;lt; f where fanin = ???&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;fanin&lt;/code&gt; 的实现并不显然，我们可以先从类型上入手来看看：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fanin :: Either (Term f) a -&amp;gt; Term f&lt;/code&gt;&lt;p&gt;对于 &lt;code class=&quot;inline&quot;&gt;Left&lt;/code&gt; 我们使用 &lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt; 函数就好了，而对于 &lt;code class=&quot;inline&quot;&gt;Right&lt;/code&gt; 我们则需要正常的递归下去，那么我们需要 Haskell 的 &lt;code class=&quot;inline&quot;&gt;either&lt;/code&gt; 函数，它接受两个函数，并根据 Either 的左右值应用对应的函数，并返回相应的结果：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;apo :: Functor f =&amp;gt; RCoalgebra f a -&amp;gt; a -&amp;gt; Term f  
apo f = In &amp;lt;&amp;lt;&amp;lt; fmap fanin &amp;lt;&amp;lt;&amp;lt; f where fanin = either id (apo f)&lt;/code&gt;&lt;p&gt;类似地，我们可以使用 &lt;code class=&quot;inline&quot;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; 的对偶函数 &lt;code class=&quot;inline&quot;&gt;|||&lt;/code&gt; 来重写 &lt;code class=&quot;inline&quot;&gt;fanin&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; 使用所有传入的函数，而 &lt;code class=&quot;inline&quot;&gt;|||&lt;/code&gt; 只使用其中一个。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;apo :: Functor f =&amp;gt; RCoalgebra f a -&amp;gt; a -&amp;gt; Term f  
apo f = In &amp;lt;&amp;lt;&amp;lt; fmap (id ||| apo f) &amp;lt;&amp;lt;&amp;lt; f&lt;/code&gt;&lt;h2&gt;结语&lt;/h2&gt;&lt;p&gt;如果读者们坚持读到了这里，那么你对 Recursion Scheme 已经有了相当的了解了，下一章中，我们将会讨论 futumorphism 和 histomorphism，并且展示其中强大的结构（以及一些迷之词缀）&lt;/p&gt;&lt;p&gt;感谢 Rob Rix, Colin Barrett，和 Manuel Chakravarty 对本文的指导和建议。 &lt;/p&gt;&lt;h2&gt;译者的话&lt;/h2&gt;&lt;p&gt;欢迎大家关注我的专栏&lt;a href=&quot;https://zhuanlan.zhihu.com/catclaw&quot;&gt;猫爪&lt;/a&gt;，这个系列的文章我会更新完成（当然是不定期的=w=），之后应该也会发一些看到的有趣的 FP 类知识，基本上会是 Haskell 的，具体方向还没想好，大家有什么想法和建议也可以私信提出来讨论。&lt;/p&gt;&lt;p&gt;谢谢大家！&lt;/p&gt;&lt;p&gt;[1]:现代英语中常用 “para” 词缀表示 “虚假的”，“不正常的” 等含义（如 “parapsychology” 或 “paresthesia”）——这是从“旁边”的含义中引申而来的，在 paramorphism 一词中，并没有不正常或是低劣的含义。&lt;/p&gt;&lt;p&gt;[2]:实际上，这里的函数应该是指 &lt;code class=&quot;inline&quot;&gt;Category&lt;/code&gt;，不过函数 &lt;code class=&quot;inline&quot;&gt;-&amp;gt;&lt;/code&gt; 就是一种 &lt;code class=&quot;inline&quot;&gt;Category&lt;/code&gt;。（译者注：如果读者有 monad 的既视感，那么恭喜你，这种的直觉说是对的，可以阅读 &lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Arrow_tutorial&quot;&gt;Arrows&lt;/a&gt; 以了解更多）&lt;/p&gt;&lt;p&gt;[3]:实际上这样的优化步骤不应该出现在生成文档这样的场景下，而是在编译优化或者其他中间结果生成这样的时候，这里使用文档生成的例子，只是为了方便说明。&lt;/p&gt;</description>
<author>禾木旁</author>
<guid isPermaLink="false">2018-09-02-43560128</guid>
<pubDate>Sun, 02 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Python 实现阴阳谜题（Yin Yang Puzzle）</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-08-29-43207643.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43207643&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-51d5125f46b7553c669a0878c104eb41_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;搜了一圈&lt;b&gt;竟然没有&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;就是这个众所周知的把 call/cc 玩出花来的。&lt;/p&gt;&lt;a href=&quot;https://www.zhihu.com/question/27683900&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;e95c1c2b95f924056dca52e6b7a9bf01&quot; data-image-width=&quot;1241&quot; data-image-height=&quot;1376&quot; data-image-size=&quot;ipico&quot;&gt;如何实现 Call / CC 或者阴阳谜题（Yin Yang Puzzle）？&lt;/a&gt;&lt;p&gt;创造宇宙这种事，没有 call/cc 可以每次新建一个 generator 啊。&lt;/p&gt;&lt;code lang=&quot;python3&quot;&gt;def puzzle():
    def yin(yin):
        yield &#39;@&#39;
        def yang(yang):
            yield &#39;*&#39;
            yield from yin(yang)
        yield from yang(yang)
    yield from yin(yin)

for x, _ in zip(puzzle(), range(256)):
    print(x, end=&#39;&#39;)
print()&lt;/code&gt;&lt;p&gt;输出&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;@*@**@***@****@*****@******@*******@********@*********@**********@***********@************@*************@**************@***************@****************@*****************@******************@*******************@********************@*********************@***&lt;/code&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>HOOCCOOH</author>
<guid isPermaLink="false">2018-08-29-43207643</guid>
<pubDate>Wed, 29 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>一个现代的parser generator框架应该是什么样的</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-08-29-43206998.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43206998&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-04f502b196883798b6fcc7f8f94c59aa_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;8102年，在编译前端这个方面，原始的气息还没有远离我们。&lt;br&gt; 对于某种并非常用格式的字符串，我们想要解析它们，通常会确实地花费一些心思。 在&lt;a href=&quot;https://en.wikipedia.org/wiki/Comparison_of_parser_generators&quot;&gt;这方面的工具&lt;/a&gt;中，我们耳熟能详的东西有&lt;a href=&quot;http://www.antlr.org/&quot;&gt;Antlr4&lt;/a&gt;, &lt;a href=&quot;http://dinosaur.compilertools.net/&quot;&gt;Lex &amp;amp; Yacc&lt;/a&gt;, 各种&lt;a href=&quot;https://en.wikipedia.org/wiki/Parser_combinator&quot;&gt;ParserC&lt;/a&gt;的实现。在我开始敲码的这几年，也出现了&lt;a href=&quot;http://www.lihaoyi.com/fastparse/&quot;&gt;Fastparse&lt;/a&gt;这样的框架。&lt;/p&gt;&lt;p&gt;我们来看一些parse二元&lt;code class=&quot;inline&quot;&gt;+/-&lt;/code&gt;运算的例子:&lt;br&gt; &lt;code class=&quot;inline&quot;&gt;Antlr4&lt;/code&gt;(ruby片段), 来自&lt;a href=&quot;https://github.com/Antlr/grammars-v4/blob/master/ruby/Corundum.g4&quot;&gt;这里&lt;/a&gt;:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;dynamic_result : 
               | &amp;lt;此处省略...&amp;gt;
               | dynamic_result op=( PLUS | MINUS ) int_result
               | int_result op=( PLUS | MINUS ) dynamic_result
               | dynamic_result op=( PLUS | MINUS )  float_result
               | float_result op=( PLUS | MINUS )  dynamic_result
               | dynamic_result op=( PLUS | MINUS ) dynamic_result
               | &amp;lt;此处省略...&amp;gt;
               ;&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;cpython自己实现的pgen&lt;/code&gt;(cpython片段), 来自&lt;a href=&quot;https://github.com/python/cpython/blob/master/Grammar/Grammar&quot;&gt;这里&lt;/a&gt;:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;arith_expr: term ((&#39;+&#39;|&#39;-&#39;) term)*&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Lex &amp;amp;&amp;amp; Yacc&lt;/code&gt;, 来自&lt;a href=&quot;https://www.ibm.com/developerworks/aix/tutorials/au-lexyacc/index.html&quot;&gt;这里&lt;/a&gt;:&lt;/p&gt;&lt;code lang=&quot;antlr&quot;&gt;addexpr: NUMBER PLUSTOKEN NUMBER 
         { 
             printf(&quot;%f\n&quot;,($1+$3));
         }
         | NUMBER MINUSTOKEN NUMBER 
         { 
             printf(&quot;%f\n&quot;,($1-$3));
         }
         ;&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Fastparse&lt;/code&gt;, 来自&lt;a href=&quot;http://www.lihaoyi.com/fastparse&quot;&gt;这里&lt;/a&gt;:&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;val addSub: P[Int] = P( divMul ~ (CharIn(&quot;+-&quot;).! ~/ divMul).rep ).map(eval)&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;nom(parserc for Rust)&lt;/code&gt;(片段), 来自&lt;a href=&quot;https://stevedonovan.github.io/rust-gentle-intro/nom-intro.html&quot;&gt;这里&lt;/a&gt;:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;named!(expr&amp;lt;&amp;amp;str,f64&amp;gt;, do_parse!(
        init: term &amp;gt;&amp;gt;
        res: fold_many0!(
            tuple!(
                alt!(tag_s!(&quot;+&quot;) | tag_s!(&quot;-&quot;)),
                term
            ),
            init,
            |acc, v:(_,f64)| {
                if v.0 == &quot;+&quot; {acc + v.1} else {acc - v.1}
            }
        )
        &amp;gt;&amp;gt; (res)
    ));&lt;/code&gt;&lt;p&gt;经过对上述代码的预览，以及简要地查看相关链接，我们能够了解一点它们的差异。&lt;/p&gt;&lt;p&gt;我不太清楚人们在看到它们之后会如何选择，什么是加分项，什么可能会被diss。这种时候，我总会怀着这样一种考虑进行选择: &lt;/p&gt;&lt;p&gt;&lt;b&gt;功能是否完备正交，约定是否简洁必要&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;但说实在的，在&lt;b&gt;功能完备&lt;/b&gt;这个方面，人们可能就会出现分歧，例如有人认为, parser就按照文法定义(如果有的话)生成s-expression好了，一个列表头部有一个tag, 用以唯一识别node的结构，其余的都是子结构; 有的人又会觉得, 我就是要从一堆字符串里面parse出来一个结构体又有什么问题。更多的，有些parser框架还不支持left recur(比如cpython那个pgen)，也有人写的框架需要&lt;a href=&quot;https://www.zhihu.com/question/266250146/answer/306132266&quot;&gt;把左递归explicitly标记出来&lt;/a&gt;, 有的框架则默认处理了。&lt;/p&gt;&lt;p&gt;这时总得有自己的判断，这也是文章的观点:&lt;/p&gt;&lt;h2&gt;功能完备正交&lt;/h2&gt;&lt;h2&gt;功能1: AST的重写&lt;/h2&gt;&lt;p&gt;比方说重写ast这件事，cpython自己实现那玩意儿是没有的，Antlr可以轻松实现同为ast结构的重写，但是形成特定的数据结构，Antlr和yacc能以极其扭曲复杂的方式给出相应的笨重实现(而且这在使用中是极其常见的)，而这一切对于&lt;code class=&quot;inline&quot;&gt;fastparse&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;nom&lt;/code&gt;这种parser combinator基本是算是稀松平常。&lt;/p&gt;&lt;p&gt;一些相关事件如下:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Antlr/Antlr4/issues/1732&quot;&gt;Antlr4 issue1732&lt;/a&gt;&lt;br&gt; &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.quora.com/What-are-the-steps-to-use-antlr-to-create-an-abstract-syntax-tree-of-Java-source-code-and-then-walk-the-tree&quot;&gt;Antlr: about ast rewriting&lt;/a&gt;&lt;br&gt; &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;AST的重写有一些非常重大的意义，这个意义和我们需要结构体，而不是把其field数据存放到不同类型的数组中一样。请耐心看下面这个事情。&lt;/p&gt;&lt;p&gt;合格的文法书写者总会写出这样一种文法，使得parsing后一阶段需要处理的数据结构与这种文法保持着结构上的一致。&lt;/p&gt;&lt;p&gt;例如(因为非技术原因，我会尽量使用python写例子):&lt;/p&gt;&lt;p&gt;文法:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Add ::= Expr &#39;+&#39; Expr
# 一个二元运算的ast表示
class Add(Expr):
    left: Expr
    right: Expr&lt;/code&gt;&lt;p&gt;而仅仅是parse一段符合&lt;code class=&quot;inline&quot;&gt;Expr &#39;+&#39; Expr&lt;/code&gt;的文法，你的parse结果很可能是这样的:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;[Expr([Token(...)]), Token(+), Expr([Token(...)])]&lt;/code&gt;&lt;p&gt;拿到这样原始的ast，虽说确实可以进行下一步的工作，但说真的，操作这样的ast可读性太差了，&lt;b&gt;&quot;你在一段sexpr里取第三个位置，鬼知道你取的是什么&quot;&lt;/b&gt;，而且类型也没有，不安全，不可维护。&lt;/p&gt;&lt;p&gt;我经历过这样的时期，你可以观光一下，我是如何用这样的ast造出一门门语言的。。 &lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/thautwarm/Rem&quot;&gt;功能缺失的EBNFParser&lt;/a&gt; &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/thautwarm/Rem&quot;&gt;Rem语言&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这个时候，我认为需要这样一种功能:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Add ::= left=Expr &#39;+&#39; right=Expr 
    -&amp;gt;  Add(left, right)&lt;/code&gt;&lt;p&gt;有一件非常有意思的事情是，如果你的文法中，除开辅助的语法结构，如果每一个都写了这样的重写规则，你会发现你似乎可以直接把你parse后的东西交给编译器的后端, 比如下面这样一段可能不严谨但比较形象的叙述:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;parse数字出来了一个叫Number的结构体，里面包了一个数字&lt;/li&gt;&lt;li&gt;parse加法出来了一个叫Add的结构体，里面左右分别是Number实例&lt;/li&gt;&lt;li&gt;parse lambda表达式出来了一个叫Lambda的结构体，里面的body属性正好是之前parse出来那个Add实例  &lt;/li&gt;&lt;li&gt;以此类推...&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于经常使用ADT的人，我觉得还有必要说一下，在这样的重写功能下，你直接得到了一棵&lt;code class=&quot;inline&quot;&gt;data/type&lt;/code&gt;定义的语法树，而你所做的不过是仅仅写了一段文法。&lt;/p&gt;&lt;p&gt;关于语法树重写有更多基于易用性的简化，如果有兴趣请与我直接讨论。&lt;/p&gt;&lt;h2&gt;功能2: 额外的Parsing约束条件&lt;/h2&gt;&lt;p&gt;就是说Parsing guard.&lt;/p&gt;&lt;p&gt;比如，我们都知道，一段xml或者其derivative总是以&lt;code class=&quot;inline&quot;&gt;&amp;lt;xxx&amp;gt;&lt;/code&gt;开头，然后以&lt;code class=&quot;inline&quot;&gt;&amp;lt;/xxx&amp;gt;&lt;/code&gt;结尾。这里是一个状态相关的要素，并非所有parser都能对xml的parsing是否成功做出判断。&lt;/p&gt;&lt;p&gt;我在昨年的某一天产生了这样一个想法，它重重地敲击着我的神经，呼唤着我的实现:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;xml = &#39;&amp;lt;&#39; tag1 = tagName &#39;&amp;gt;&#39; 
       ...省略
       &#39;&amp;lt;&#39; &#39;/&#39; tag2 = tagName &#39;&amp;gt;&#39;
       with tag1 == tag2&lt;/code&gt;&lt;p&gt;我设计了&lt;code class=&quot;inline&quot;&gt;with&lt;/code&gt;子句，让一个&lt;b&gt;有名字的parser&lt;/b&gt;成功parse后，还需要对捕捉到的tag1和tag2进行相等比较，如果表达式为假，则parse失败。&lt;/p&gt;&lt;p&gt;同样的，还有一个&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;子句，用于刚刚进入某个&lt;b&gt;有名字的parser&lt;/b&gt;时，进行的预先判断，如果判断为假，则该parser失败。&lt;/p&gt;&lt;p&gt;在我的方法下，这个&lt;b&gt;有名字的parser&lt;/b&gt;对于context sensitive的文法处理是一个比较重要的概念，但是这个是&lt;a href=&quot;https://github.com/thautwarm/RBNF&quot;&gt;私货&lt;/a&gt;，有兴趣请直接与我细聊。&lt;/p&gt;&lt;p&gt;通过这些额外的parsing约束条件，我们可以轻易实现很多复杂的功能。人们总喜欢通过构造context sensitive的tokenizers来实现缩进，可是这并不是唯一的方式，甚至不是好的方式，如果有兴趣不妨看一下&lt;a href=&quot;https://github.com/thautwarm/merlin/blob/master/rml/rml/rml.rbnf&quot;&gt;我是如何实现一个类ocaml语言的缩进的&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;功能3: 左递归的支持&lt;/h2&gt;&lt;p&gt;无论是显式表明左递归，还是不需要额外约定直接处理，我认为左递归的支持是必要的。上升到用户层面，且不说不是所有人都关心各种各样的左递归消除方式，即使了解且熟悉，让用户使用你的服务时需要为之付出精力，怎么想也是一种缺憾。&lt;br&gt; 当然从根本上讲，左递归所代表的左结合的关系，在数据结构中不可避免。  &lt;/p&gt;&lt;h2&gt;关于功能的完备正交 &amp;amp; 关于parser的抽象&lt;/h2&gt;&lt;p&gt;在parser本身的功能上, 我认为，如果拥有上述三种功能，那么几乎可以解决任何parsing问题，不仅仅是缩进这种小菜, 还可以&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30279723&quot;&gt;各减平均各自乘相加除以项数开方&lt;/a&gt;, 根据用户自定义的词语，动态的生成新的parser，不再需要空格分隔关键字这些操作。&lt;br&gt; &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/thautwarm/RBNF/blob/master/demos/calc-for-rbnf/calc-immediately.rbnf&quot;&gt;parser写完，解释器即写完&lt;/a&gt;&lt;br&gt; &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;总之要什么有什么，确实就是这么为所欲为。&lt;/p&gt;&lt;p&gt;但关于正交的问题，则需要说得多一点了。&lt;/p&gt;&lt;p&gt;既然完备，既然正交，那么核心里就必然有一些基本的东西来生成所有可能的构造。&lt;/p&gt;&lt;p&gt;我们写后端都知道讲language constructs, 而写前端，如果是上下文无关语法，我们有前人们给好的BNF和EBNF，其语法结构对应了一套正交完备的、描述context free的语法功能，由于这些语法结构可以直接和不同的parser combinator一一对应，所以我们可以知道, 严格按照BNF/EBNF语法结构实现的parserc框架可以正交地表达出完备的、受限于context free情境下的parsing能力。&lt;/p&gt;&lt;p&gt;P.S : 有些版本的EBNF中可能存在一些不正交的功能(例如A ::= [B] C和 A ::= B C | C等价)，这是为了使用上的便利性。因为并没有带来超过一只手的新约定，学习曲线和遗忘曲线依然令人满意。&lt;/p&gt;&lt;p&gt;而给EBNF添加之前讲到的&lt;b&gt;语法树重写&lt;/b&gt;以及&lt;b&gt;额外的Parsing约束条件&lt;/b&gt;(parsing guard)之后，这个&lt;b&gt;扩展的扩展BNF&lt;/b&gt;就成为能轻松描述诸多context sensitive cases的强大范式，而它的language constructs，满打满算，好像也才是个位数。&lt;/p&gt;&lt;code lang=&quot;fsharp&quot;&gt;type Rewrite = ...
type Guard   = ...

type EEBNFParser = 
(** &#39;&amp;lt;token&amp;gt;&#39; *)
| Literal of string
(** A ::= a b c d e*)
| And     of EEBNFParser list
(** A ::= a | b | c | d*)
| Or      of EEBNFParser list
(** A ::= a{1, 10} *)
| Rep     of at_least: int * at_most: int * EEBNFParser
(** A ::= b=B c=C D E *)
| Bind    of name: string * EEBNFParser
(** A ::= ... // 语法树重写、parsing guard
          when ...
          with ...
          rewrite ...
 *)
| Named   of name: string * EEBNFParser * Rwrite * Guard&lt;/code&gt;&lt;p&gt;看清楚了，&lt;b&gt;context sensitive的parser只要5种基本结构&lt;/b&gt;, 左递归的实现则涉及具体parser算法的问题。 更多的，这里的parser不再是一个type constructor，如果你脑子里仍然装有&lt;code class=&quot;inline&quot;&gt;&#39;t Parser&lt;/code&gt;把tokenizers转换成&lt;code class=&quot;inline&quot;&gt;&#39;t&lt;/code&gt;或是&lt;code class=&quot;inline&quot;&gt;&#39;t AST&lt;/code&gt;类型，不妨看一下我&lt;a href=&quot;https://github.com/thautwarm/Ruiko.fs/tree/master/RBNF/Core&quot;&gt;对parser的定义和其parse所得对象的一种解耦&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;以上，是我对于一个现代parser generator框架的抽象核心的导出。&lt;/p&gt;&lt;h2&gt;约定简洁必要&lt;/h2&gt;&lt;p&gt;这个时候，往前翻一翻rust的&lt;code class=&quot;inline&quot;&gt;nom&lt;/code&gt;的示例代码，以及doc里&lt;a href=&quot;https://docs.rs/nom/4.0.0/nom/#modules&quot;&gt;这一大堆API&lt;/a&gt;, 是什么考虑让设计者们抛弃parserc的紧凑优美，达到这样一种神奇的现状?&lt;/p&gt;&lt;p&gt;个人看法 ———— 我觉得这exactly就是&lt;code class=&quot;inline&quot;&gt;overdeveloped&lt;/code&gt;。该rewrite就rewrite，不用自己搞一套。如无必要，勿增实体。&lt;/p&gt;&lt;p&gt;从之前我说的那个功能完备正交的核心走过来，我有理由认为绝大多数的parser框架都极度冗长，Antlr 和 lex&amp;amp;yacc要实现rewrite和parsing guard简直就像原始人在玩泥巴，需要手写一坨坨巨长的、需要遵守一堆conventions的嵌入代码，  &lt;/p&gt;&lt;p&gt;&lt;b&gt;没有快速实践想法的repl之类的东西&lt;/b&gt;(我知道Antlr有一个&lt;a href=&quot;https://stackoverflow.com/questions/24766006/getting-Antlr-to-generate-a-script-interpreter&quot;&gt;这个&lt;/a&gt;, 但是对着dsl/esdl的文件直接执行的，目前不存在的。 &lt;b&gt;私货&lt;/b&gt;: &lt;code class=&quot;inline&quot;&gt;rbnf run &amp;lt;script&amp;gt;&lt;/code&gt;了解一下),&lt;/p&gt;&lt;p&gt;&lt;b&gt;甚至lexer居然还不是自动生成的&lt;/b&gt; ———— 这样的直接结果是因为需要用户手写lexer又要引入一堆conventions。同时，由于&lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/337676/what-is-the-procedure-that-is-followed-when-writing-a-lexer-based-upon-a-grammar&quot;&gt;一套文法的定义已然可以蕴含对应的lexer&lt;/a&gt;，你再让用户手写，令人窒息何如！&lt;/p&gt;&lt;p&gt;如此看来，除了fastparse简直没有一个能看。&lt;/p&gt;&lt;p&gt;fastparse的话, 基本上很符合之前那个5个基本constructs的核心，API比起核心也就是多搞了一些糖。&lt;/p&gt;&lt;p&gt;若真非要我挑好多刺，我觉得有点迫真。但并不是没有，&quot;鬼画桃符&quot;可以黑一个。&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;val option = P( &quot;c&quot;.? ~ &quot;a&quot;.rep(sep=&quot;b&quot;).! ~ End)
val captureRep = P( &quot;a&quot;.!.rep ~ &quot;b&quot; ~ End)&lt;/code&gt;&lt;p&gt;虽然这并不是大问题, 你稍微认真看还是相当可读的，况且向scala这种语言要求颜值是不是有点精分?&lt;/p&gt;&lt;p&gt;更多地，对于real world来说，Repeat有sep这个玩意儿真的蛮方便的，我觉得比较惊艳的一个特性还有&lt;a href=&quot;http://www.lihaoyi.com/fastparse/#Opaque&quot;&gt;Opaque&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;以上并没有非常详细地说明&lt;b&gt;约定简洁必要&lt;/b&gt;这个主题，因为本身API的简洁必要已经是非常明确的概念:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;必要: 保证功能完整&lt;/li&gt;&lt;li&gt;简洁: 这个结构被使用起来轻量，可读性较高&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在这个section的最后，我提一个事情。 一个半月前我基本实现了一个sql(这个就不能放链接了因为是工作相关)，照着&lt;a href=&quot;https://github.com/apache/spark/blob/master/sql/catalyst/src/main/Antlr4/org/apache/spark/sql/catalyst/parser/SqlBase.g4&quot;&gt;Antlr 1094行ebnf的sparksql&lt;/a&gt;改，然后简化为350行，且直接生成极其high level的tagged union(python里我不好意思说这是ADT)。那几天看g4不知道恶心了多少次。&lt;/p&gt;&lt;h2&gt;其他重要的特性&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;模块化与代码复用&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;parser generator使用某种dsl刻画，那么应该使用模块的方式进行管理，并且这种模块的语法还应该对不同后端做出合理描述。&lt;/p&gt;&lt;p&gt;这里不上一下私货的话，实在没什么别的替代品。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;# bnf源码的模块，不同后端可以复用
import std.common.[Number Space]

# `[python] import` 引导python specific的模块，用以构造rewrite和parsing guard。
# 不同后端不复用
[python] import functools.[reduce]
[python] import operator.[add sub mul truediv floordiv mod]&lt;/code&gt;&lt;ul&gt;&lt;li&gt;parser可持久化&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;也许由于巨量的编译前优化，构造某些parser相对缓慢，但应该容许构造完毕后能dump到存储单元，并以二进制方式进行快速的load。&lt;/p&gt;&lt;p&gt;可持久化并非总是为了性能，如果load持久化的parser对象不需要原parser generator库的依赖，也会是一个巨大的优势。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Automatically lexer&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;之前已经有提到，我认为这也是现代parser generator的一种标志。&lt;/p&gt;&lt;p&gt;当lexer可以被文法决定时，用户不应该再被要求书写它。&lt;/p&gt;&lt;h2&gt;最后&lt;/h2&gt;&lt;ul&gt;&lt;li&gt; 私货&lt;br&gt; 以上一切，在&lt;a href=&quot;https://github.com/thautwarm/RBNF&quot;&gt;RBNF&lt;/a&gt;中&lt;b&gt;高度完成&lt;/b&gt;。&lt;br&gt; 之前 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0251012c87c2d3f56ac34de7d71cdcbc&quot; data-hash=&quot;0251012c87c2d3f56ac34de7d71cdcbc&quot; data-hovercard=&quot;p$b$0251012c87c2d3f56ac34de7d71cdcbc&quot;&gt;@圆角骑士魔理沙&lt;/a&gt;  给我说了一个东西，从一个写好的AST自动生成一个Parser。&lt;br&gt; 然而我都有这个东西了，还要啥自行车...(雾:&lt;br&gt; &lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;text&quot;&gt;// 定义文法; 事实上还有embedded python的方式，和写AST差不多。
A :: = B C as c D as d

// 不仅生成了parser, 还帮我自动定义了AST =_=

type AST = A | C | D | ...
type A = {
    c : C
    d : D
} 
type C = ...
...
//然后parse一下符合文法的字符串，就是那套ADT了。&lt;/code&gt;&lt;ul&gt;&lt;li&gt; 错误定位怎么做&lt;br&gt; 首先，tokenizer里面要包含lineno(行号), colno(列号), filename(可选，如果你的语言没有source code inline的话是不需要的)。&lt;br&gt; 然后AST可以都增加lineno, colno, filename三个属性。 当然对于AST错误定位，更好的办法是下面这段代码所示。详见&lt;a href=&quot;https://github.com/thautwarm/LLAST/tree/master/LLAST/LLVM&quot;&gt;LLAST&lt;/a&gt;.&lt;br&gt; &lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;fsharp&quot;&gt;type location = {
(**
for location resolving in exception reporting.
*)
    filename: string
    lineno  : int
    colno   : int
}
type AST = 
    | ...
    | Locate of location * AST&lt;/code&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>头顶青天红美铃</author>
<guid isPermaLink="false">2018-08-29-43206998</guid>
<pubDate>Wed, 29 Aug 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
