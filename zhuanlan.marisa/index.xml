<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Fri, 13 Apr 2018 09:40:15 +0800</lastBuildDate>
<item>
<title>数组小技巧 区间操作</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-12-35568092.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35568092&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bbeaba667e1b3162c62356eca878b7a9_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;猛然发现自己的个人主页被访问了1,000次以上了！&lt;/p&gt;&lt;p&gt;嘛嘛，那么讲一些自己的关于数组的心得体会吧。正好也是整理一下。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;声明：&lt;/p&gt;&lt;p&gt;查询单个元素：给定一个下标，获取数组上对应下标上元素的值&lt;/p&gt;&lt;p&gt;修改单个元素：给定一个下标，让对应下标上的元素加上一个给定的值&lt;/p&gt;&lt;p&gt;查询区间和：对于一个给定的合法区间[i,j]来说，查询数组在[i,j]上的所有元素之和&lt;/p&gt;&lt;p&gt;修改区间和：对于一个给定的合法区间[i,j]来说，让[i,j]里的每一个元素都加上某一个给定的值&lt;/p&gt;&lt;p&gt;单个元素虽然可以看成对于某个区间[i,i]上的操作，但是我还是要特意拿出来。&lt;/p&gt;&lt;p&gt;数组下标从1开始&lt;/p&gt;&lt;hr&gt;&lt;p&gt;普通数组： &lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;const int maxm=100;
int arr[maxm];&lt;/code&gt;&lt;p&gt;查询单个元素时间复杂度: O(1)&lt;/p&gt;&lt;p&gt;修改单个元素时间复杂度: O(1)&lt;/p&gt;&lt;p&gt;查询区间和时间复杂度: O(n)&lt;/p&gt;&lt;p&gt;修改区间和时间复杂度: O(n)&lt;/p&gt;&lt;p&gt;评价：被广泛使用的结构......&lt;/p&gt;&lt;hr&gt;&lt;p&gt;前缀和：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;int sum[maxm];
for(int i=1;i&amp;lt;maxm;++i)sum[i]=sum[i-1]+arr[i];&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;即对于前缀和数组sum来说&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;sum[i]=arr[1]+arr[2]+......+arr[i]&lt;/code&gt; &lt;/p&gt;&lt;p&gt;查询单个元素时间复杂度: O(1) -&amp;gt; sum[i]-sum[i-1]&lt;/p&gt;&lt;p&gt;修改单个元素时间复杂度: O(n) &lt;/p&gt;&lt;p&gt;查询区间和时间复杂度: O(1) -&amp;gt; sum[j]-sum[i-1]&lt;/p&gt;&lt;p&gt;修改区间和时间复杂度: O(n)&lt;/p&gt;&lt;p&gt;评价：在数组不会发生变化，且需要频繁查询区间和的时候的很好的选择。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;差分：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;int diff[maxm]
diff[1]=arr[1];
for(int i=2;i&amp;lt;maxm;++i)diff[i]=arr[i]-arr[i-1];&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;即对于差分数组diff来说：&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;diff[1]=arr[1], diff[i]=arr[i]-arr[i-1];&lt;/code&gt; &lt;/p&gt;&lt;p&gt;查询单个元素时间复杂度: O(n) -&amp;gt; diff[i]+diff[i-1]+.... + diff[1]&lt;/p&gt;&lt;p&gt;修改单个元素时间复杂度: O(1) -&amp;gt; 只考虑涉及到arr[i]的元素即可&lt;/p&gt;&lt;p&gt;查询区间和时间复杂度: O(n)&lt;/p&gt;&lt;p&gt;修改区间和时间复杂度: O(1) -&amp;gt; 考虑[i,j]区间+1，则diff[i]+=1,diff[j+1]-=1即可&lt;/p&gt;&lt;p&gt;评价：好像用得不是很多...用在需要对区间进行更新而且中间还不能查询的时候。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;三者关系：&lt;/p&gt;&lt;p&gt;普通数组求前缀和变为前缀和数组&lt;/p&gt;&lt;p&gt;差分数组求前缀和变为普通数组&lt;/p&gt;&lt;p&gt;前缀和数组差分变为普通数组&lt;/p&gt;&lt;p&gt;普通数组差分变为差分数组&lt;/p&gt;&lt;hr&gt;&lt;p&gt;引入数据结构：树状数组，此处不对树状数组原理做任何解释&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;//定义操作lowerbit
//bit-&amp;gt;binary index tree
inline int lowerbit(int x){return x&amp;amp;-x;}
//定义插入操作
int _ins(int i,int x){while(i&amp;lt;maxm)bit[i]+=x,i+=lowerbit(i);}
//定义查询操作
int query(int i){
    int ans=0;
    while(i)ans+=bit[i],i-=lowerbit(i);
    return ans;
}
for(int i=1;i&amp;lt;maxm;++i)
_ins(i,arr[i]);&lt;/code&gt;&lt;p&gt;以上是最基本的树状数组代码，即对原arr数组建立一个树状数组&lt;/p&gt;&lt;p&gt;查询单个元素时间复杂度: O(lgn) &lt;/p&gt;&lt;p&gt;修改单个元素时间复杂度: O(lgn) &lt;/p&gt;&lt;p&gt;查询区间和时间复杂度: O(lgn) -&amp;gt; query(j)-query(i-1)&lt;/p&gt;&lt;p&gt;修改区间和时间复杂度: O(nlgn) &lt;/p&gt;&lt;hr&gt;&lt;p&gt;让我们考虑对差分数组diff建立树状数组：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;for(int i=1;i&amp;lt;maxm;++i)
_ins(i,diff[i]);&lt;/code&gt;&lt;p&gt;这样做完之后我们就能得到：&lt;/p&gt;&lt;p&gt;查询单个元素时间复杂度: O(lgn) &lt;/p&gt;&lt;p&gt;修改单个元素时间复杂度: O(lgn) &lt;/p&gt;&lt;p&gt;查询区间和时间复杂度: O(nlgn)&lt;/p&gt;&lt;p&gt;修改区间和时间复杂度: O(lgn)  -&amp;gt; 考虑区间[i,j]+1，_ins(i,1), _ins(j+1,-1)&lt;/p&gt;&lt;hr&gt;&lt;p&gt;问题来了，树状数组和对diff建立的树状数组都不能很好的进行区间修改和查询......那么我们有没有什么办法呢&lt;/p&gt;&lt;p&gt;考虑 &lt;code class=&quot;inline&quot;&gt;arr[1]+arr[2]+....+arr[n]&lt;/code&gt; &lt;/p&gt;&lt;p&gt;用diff改写一下成为&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;(diff[1]) + (diff[1] + diff[2]) + .....  + (diff[1] + diff[2] + ..... + diff[n])&lt;/code&gt; &lt;/p&gt;&lt;p&gt;合并一下同类项&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;n*diff[1] + (n-1)*diff[2] + ...... + 1*diff[n]&lt;/code&gt;  ---- &lt;b&gt;(1)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;改写一下式子&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;n*(diff[1] + diff[2] + ...... + diff[n])  - ( 0*diff[1] + 1*diff[2] + ...... + (n-1)*diff[n]) &lt;/code&gt; ---- &lt;b&gt;(2)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;至此，我们便得到了可以进行区间修改的差分树状数组了。&lt;/p&gt;&lt;p&gt;我们我们不仅对差分数组diff建立一个树状数组快速求diff上的区间和，同时对 (i-1)*diff[i] 也建立一个树状数组快速求该数组的区间和，再相减即可。&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;//(i-1)*diff[i]数组的ins和query
//[i,j]+val时
_ins(i,(i-1)*val);
_ins(j+1,-(n-j-1)*val);
//查询[i,j]时
query(j)-query(i-1);&lt;/code&gt;&lt;p&gt;至此，我们通过建立两个树状数组即可得到区间修改和区间查询的良好数据结构了。&lt;/p&gt;&lt;p&gt;查询单个元素时间复杂度: O(lgn) &lt;/p&gt;&lt;p&gt;修改单个元素时间复杂度: O(lgn) &lt;/p&gt;&lt;p&gt;查询区间和时间复杂度: O(lgn)&lt;/p&gt;&lt;p&gt;修改区间和时间复杂度: O(lgn) &lt;/p&gt;&lt;p&gt;评价：常数也线段树要小，支持区间修改的结构。可是我没怎么用过，一般都是写打lazy tag的线段树了。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;思考题：&lt;/p&gt;&lt;p&gt;在上一段中，我们是对(2)式建立了两个树状数组来完成区间操作，那么，我们能不能仅仅对(1)式建立一个树状数组来完成区间操作，而且还要少一倍的空间呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Spica</author>
<guid isPermaLink="false">2018-04-12-35568092</guid>
<pubDate>Thu, 12 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>C宏元编程:编译期LISP解释器（三）A级原语</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-07-35382626.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35382626&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;目录⇣&lt;br&gt;    &lt;a href=&quot;https://zhuanlan.zhihu.com/p/35121316&quot;&gt;（一）总体思路&lt;/a&gt;&lt;br&gt;    &lt;a href=&quot;https://zhuanlan.zhihu.com/p/35172411&quot;&gt;（二）列表操作&lt;/a&gt;&lt;br&gt;⇢&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35382626&quot;&gt;（三）A级原语&lt;/a&gt;&lt;br&gt;外部链接⇣&lt;br&gt;这是一个超级神奇的项目&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/BlueFlo0d/CSP&quot;&gt;CSP Git Repo&lt;/a&gt; &lt;br&gt;纯粹用C宏写的LISP解释器！&lt;br&gt;（目前还没有完成，最重要的lambda已经实现了，cond暂时还有问题嵌套会出错x）&lt;br&gt;（想拉一些小伙伴一起玩一起烧脑呀！可惜似乎人类玩家直接看源码大概率大脑爆栈，于是尝试写了一些文章之类。。原始wiki可以戳这里&lt;br&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/BlueFlo0d/CSP/wiki/Implementation-details&quot;&gt;CSP Wiki&lt;/a&gt; &lt;/blockquote&gt;&lt;code lang=&quot;text&quot;&gt;//最近有些忙没时间来管这个项目结果开发进度完全停滞了呢QAQ。。
//Contributor! Contributor! Contributor!&lt;/code&gt;&lt;p&gt;这次我们来看一些复杂一点的Interpreter A原语实现。&lt;/p&gt;&lt;h2&gt;ATOM原语&lt;/h2&gt;&lt;p&gt;首先贴相关代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define _DESTROY_E(...) __VA_ARGS__
#define _DESTROY_N(...)
#define _DESTROY_BOTTOM _DESTROY_E(_DESTROY_N,_DESTROY_N)
#define _ODESTROY(car,k,...) k(_n((car)) ODESTROYY)
#define _ODESTROYY(car,k,...) k(_n((car)) ODESTROY)
#define ODESTROY(...) _ODESTROY( __VA_ARGS__,_DESTROY_E)
#define ODESTROYY(...) _ODESTROYY( __VA_ARGS__,_DESTROY_E)

#define _bsem )
#define _T(x) T
#define __ATOM(x) ODESTROY x (_DESTROY_BOTTOM)
#define RODESTROY T _n()(
#define KATOMT(...) (T)
#define KATOMR () _n _n()(
#define ATOM(x) _e(CAT(KATOM,_e(CAT(R,__ATOM(x)) _bsem)))&lt;/code&gt;&lt;p&gt;前面这一大堆东西目的很明显（_DESTROY_E _DESTROY_N _DESTROY_BOTTOM _ODESTROYY _ODESTROYY ODESTROY ODESTROYY）（还不明白的同学可以复习一下之前发的文档）。_ODESTROYY _ODESTROYY目的就是交替展开出零宏来吃掉形如(a)(b)(c)...的一连串列表／原子，而ODESTROY ODESTROYY利用零点构造技术，这样只需要采用ODESTROY (a)(b)(c)... (_DESTROY_BOTTOM)就可以消灭掉“尾巴”，干净地吃掉整个列表。至于为什么这里又定义了一遍单位宏和零宏，主要是为了避免命名空间污染。因为CPP对于两个不同名的单位宏／零宏处理行为是不一样的（例如e1(e2(...))能在一次扫描中展开，而e1(e1(...))则可能需要2次，特别是内层e1是在前一次扫描过程中展开出来的情况下），为了防止系统大起来之后各种weird，干脆能采用不同名单位宏／零宏的都约定重新命名好了。&lt;/p&gt;&lt;p&gt;后面的就是实现ATOM的主要部分。这里利用了ODESTROY的这个性质：它能吃掉(a)(b)(c)..这样一组带括号的东西，但却对a这样不带括号的项没有任何作用。&lt;/p&gt;&lt;p&gt;所以思路很明确了：把输入的括号“脱掉”再用ODESTROY作用，原子／列表的行为就会出现差异。&lt;/p&gt;&lt;p&gt;然后就是老套路：粘贴宏CAT邪术。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;__ATOM(a) //=&amp;gt;ODESTROY a (_DESTROY_BOTTOM)
__ATOM((a)) //=&amp;gt;ODESTROY (a) (_DESTROY_BOTTOM)=&amp;gt; 没有啦！
CAT(KATOM,_e(CAT(R,__ATOM(a)) _bsem)) 
//=&amp;gt;CAT(KATOM,RODESTROY a (_DESTROY_BOTTOM) _bsem)
//=&amp;gt;CAT(KATOM,T (a (_DESTROY_BOTTOM)))
//=&amp;gt;KATOMT(a (_DESTROY_BOTTOM)) =&amp;gt; (T) 胜利！
CAT(KATOM,_e(CAT(R,__ATOM((a))) _bsem)) 
//=&amp;gt;CAT(KATOM,R _bsem)
//=&amp;gt;KATOMR _bsem
//=&amp;gt;() _n() =&amp;gt;() 胜利！&lt;/code&gt;&lt;p&gt;这样ATOM原语就实现辣！&lt;/p&gt;&lt;h2&gt;AND函数&lt;/h2&gt;&lt;p&gt;现在来分析一下Interpreter A中实现的这个非原语宏：AND函数。&lt;/p&gt;&lt;p&gt;（Root of LISP中提到了这个函数所以我就实现了。。不过在Interpreter B eval中没有用到，感兴趣的小伙伴可以把它作为Interpreter B函数来整合一下）&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define _AND(a) INTERNAL_EVAL((COND((NOT(a)(COND_EAT))((T)(_AND_Y)))))
#define _AND_Y(a) INTERNAL_EVAL((COND((NOT(a)(COND_EAT))((T)(_AND)))))

#define andtransCOND_EAT ()
#define andtransCOND_EATY ()
#define andtrans_AND_Y (T)
#define andtrans_AND (T)

#define $and(a) CAT(andtrans,_AND a)&lt;/code&gt;&lt;p&gt;这里用到了COND原语，它的实现思路和ATOM类似，但可能复杂一些，感兴趣的可以自行阅读源码（误&lt;/p&gt;&lt;p&gt;另外COND乃万恶之源，它不会跳过假分支的求值过程。。所以AND对于非法输入也不会非常稳定，需要保证其子句都是安全的。&lt;/p&gt;&lt;p&gt;COND的用法：&lt;/p&gt;&lt;p&gt;COND((()(expr1))((T)(expr2))(()(expr3))...) =&amp;gt; (expr1) （即展开成第一个条件为真的子句）&lt;/p&gt;&lt;p&gt;这里的INTERNAL_EVAL是用于执行Interpreter A上类列表写法的一个工具宏。&lt;/p&gt;&lt;p&gt;$and工作原理：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$and((T)()(T)) // =&amp;gt; CAT(andtrans, _AND(T)()(T))
// 如果 _AND 后是(T) 那么它会展开出_AND_Y，以此进行交替迭代，直到碰到非真的原子为止。
//=&amp;gt;CAT(andtrans, _AND_Y()(T) )
// _AND_Y碰到“假”了！现在它展开出 COND_EAT, 用你熟悉的方式吃掉后面的所有项
// 吃完后剩下 COND_EAT 或 COND_EATY尾巴
//=&amp;gt;CAT(andtrans,COND_EATY) =&amp;gt; () CAT宏邪术！
// 如果从头到尾都是真元素，则会剩下 _AND 或 _AND_Y 尾巴
//最后留下andtrans_AND或andtrans_AND_Y =&amp;gt; (T)&lt;/code&gt;&lt;h2&gt;P.S.&lt;/h2&gt;&lt;p&gt;和已有wiki同构的部分已经写完了。。接下来就得两边一起写了。。然后解释器核心还没开发完呢。所以%滑稽%&lt;/p&gt;</description>
<author>K.Scarlet</author>
<guid isPermaLink="false">2018-04-07-35382626</guid>
<pubDate>Sat, 07 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Programming Languages: Application and Interpretation【译16】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-04-35291037.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35291037&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1575f6b8191e20ef774d57c41608be45_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;初翻： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/802e5a4b8b40cc8d665968a2ad620302&quot; data-hash=&quot;802e5a4b8b40cc8d665968a2ad620302&quot; data-hovercard=&quot;p$b$802e5a4b8b40cc8d665968a2ad620302&quot;&gt;@MrMathematica&lt;/a&gt; &lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//lotuc.gitbooks.io/plai-cn/content/&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;16 动态地检查程序中的不变量：契约&lt;/h2&gt;&lt;p&gt;类型系统提供了丰富且有价值的表示程序不变量的方式。然而，它们也代表了一种重要的权衡，因为并非所有程序的非平凡属性都可以被静态验证。【注释】此外，即使某个属性可以设计静态方法解决，注解和计算复杂度的负担也可能过大。因此，我们所关心的一些属性不可避免地只能被忽略或在运行时解决。本章我们来讨论运行时检查不变量。&lt;/p&gt;&lt;blockquote&gt;这是一个正式的定理，被称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Rice&#39;s_theorem&quot;&gt;赖斯定理&lt;/a&gt;。&lt;/blockquote&gt;&lt;p&gt;实际上，每种编程语言都包含某种形式的断言机制，使程序员能够编写比语言的静态类型系统允许的更丰富的属性。在没有静态类型的语言中，这些属性可能以简单的类型断言开始：例如，某个参数是否为数。然而，断言语言通常是整个编程语言，因此任何谓词都可以用作断言：例如，某个加密包的实现可能希望确保某些参数通过素性测试，或者某个平衡二叉搜索树可能想要确保其子树确实是平衡且有序的。&lt;/p&gt;&lt;h2&gt;16.1 以契约实现谓词&lt;/h2&gt;&lt;p&gt;因此很容易想到如何实现简单的契约（contract）。【注释】契约包含一个谓词。它读入一个值并将谓词应用于该值。如果值能通过谓词判断，则契约原样返回该值；否则，该契约会报告错误。其行为只能是返回原值或报错：它不应以任何方式更改值。简而言之，对于能通过谓词的值，契约本身就是恒等函数。&lt;/p&gt;&lt;blockquote&gt;下面我们将使用&lt;code class=&quot;inline&quot;&gt;#lang plai&lt;/code&gt;语言，原因有两个。首先，这更好地模拟了动态类型语言编程。其次，为了简单起见，我们将契约写成类型化的断言，但是在静态类型语言中，它们将由类型检查器处理，使得我们无法看到运行时行为。从效果来看，“关闭”类型检查器会更容易。然而，即使在静态类型的世界里，契约也是非常有意义的，因为它们增强了程序员可以表达的不变量。&lt;/blockquote&gt;&lt;p&gt;我们使用如下函数编码该本质：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (make-contract pred?)
  (lambda (val)
    (if (pred? val) val (blame &quot;violation&quot;))))

(define (blame s) (error &#39;contract &quot;~a&quot; s))&lt;/code&gt;&lt;p&gt;契约的例子：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define non-neg?-contract
  (make-contract
   (lambda (n) (and (number? n)
                    (&amp;gt;= n 0)))))&lt;/code&gt;&lt;p&gt;（在静态类型语言中，检查&lt;code class=&quot;inline&quot;&gt;number?&lt;/code&gt;当然是不必要的，因为它可以在类型系统中使用契约函数的方式静态检查！）假设我们要确保计算平方根时不会得到虚数；可以这么写&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (real-sqrt-1 x)
  (sqrt (non-neg?-contract x)))&lt;/code&gt;&lt;p&gt;在很多语言中，断言是写作语句而不是表达式，所以另一种编写方式是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (real-sqrt-2 x)
  (begin
    (non-neg?-contract x)
    (sqrt x)))&lt;/code&gt;&lt;p&gt;（在某些情况下，这种形式更清晰，因为它在函数的开始部分清晰地声明了参数的期望值。它还确保参数只被检查一次。实际上，在某些语言中，契约可以写入函数头部中 ，从而改善接口给出的信息。）现在，如果将&lt;code class=&quot;inline&quot;&gt;real-sqrt-1&lt;/code&gt;或&lt;code class=&quot;inline&quot;&gt;real-sqrt-2&lt;/code&gt;应用于&lt;code class=&quot;inline&quot;&gt;4&lt;/code&gt;，则它们产生&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;，但如果应用于&lt;code class=&quot;inline&quot;&gt;-1&lt;/code&gt;，则会引发违反契约的错误。&lt;/p&gt;&lt;h2&gt;16.2 标签、类型和对值的观测&lt;/h2&gt;&lt;p&gt;到这里我们已经重现了大多数语言中断言系统的本质。还有什么要讨论的？我们先假设手上的语言不是静态类型的。我们希望编写的断言至少要能重现传统的类型不变量，甚至更多。前述的&lt;code class=&quot;inline&quot;&gt;make-contract&lt;/code&gt;可以覆盖所有标准类型的属性，比如检查数、字符串等等，假设语言提供了合适的谓词，或者可以从已有的谓词中构造出来。是这样吗？&lt;/p&gt;&lt;p&gt;回想一下，即使我们最简单的类型语言也不仅仅只包含数等基本类型，还包含构造类型。尽管其中的一些，如链表和向量，似乎并不是很难，但一旦涉及赋值、性能和问责，挑战就来了，后面将讨论它们。然而，函数就很难处理了。&lt;/p&gt;&lt;p&gt;作为示例，我们来看这个函数：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define d/dx
  (lambda (f)
    (lambda (x)
      (/ (- (f (+ x 0.001))
            (f x))
         0.001))))&lt;/code&gt;&lt;p&gt;其静态类型是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;((number -&amp;gt; number) -&amp;gt; (number -&amp;gt; number))&lt;/code&gt;&lt;p&gt;（它读入一个函数，并生成其导数——也是个函数。）假设我们想用契约来处理这种情况。&lt;/p&gt;&lt;p&gt;根本的问题是，在大多数语言中，我们无法直接将其表示为谓词。大多数语言的运行时系统关于值的类型存储了非常有限的信息——相对于我们目前所看到的类型，这些信息太过有限，我们应该用不同的名称来描述它们；传统上它们被称为&lt;b&gt;标签&lt;/b&gt;（tag）。【注释】有些情况下，标签与我们认为是类型的不谋而合：例如，数会带上标识其为数的标签（甚至可能是某种特定类型的数）、字符串带有标识其为字符串的标签，等等。因此，我们可以基于这些标签的值来编写谓词。&lt;/p&gt;&lt;blockquote&gt;已经有一些工作试图保存丰富的类型信息，从源程序到较低的抽象层次、一直到汇编语言，但这些都是研究工作。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;当我们处理结构化值时，情况就复杂了。向量将会带有标签声明它是向量，但不会指明它的元素是什么类型的值（而且它们甚至可能都不是同一类型）；不过，程序通常也可以获得向量的大小，从而遍历向量来收集此信息。（然而，关于结构化值后面还更多有待讨论的。）&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;编写契约，检查只包含偶数的链表。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;这就是：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define list-of-even?-contract
  (make-contract
   (lambda (l)
     (and (list? l) (andmap number? l) (andmap even? l)))))&lt;/code&gt;&lt;p&gt;（同样，请注意，如果我们静态地知道这是数的链表，则无需问前两个问题。）类似地，对象可能只将自己标识为对象，而不提供其他信息。但是，在允许对对象结构进行反射（reflection）的语言中，契约仍可以收集它所需的信息。&lt;/p&gt;&lt;p&gt;然而，在任何语言中，当遇到函数时就出问题了。我们一般将函数的类型理解为包含其输入和输出的类型，但是对运行时系统，函数只是带有函数标签的不透明对象，可能还有一些非常有限的元数据（如函数的参数数量）。运行时系统甚至难以分辨函数是否读入和生成函数——而非其他类型的值——更不用说判断它是否读入并生成&lt;code class=&quot;inline&quot;&gt;(number -&amp;gt; number)&lt;/code&gt;类型的函数了。&lt;/p&gt;&lt;p&gt;这个问题很好地体现在JavaScript的（错误命名的）&lt;code class=&quot;inline&quot;&gt;typeof&lt;/code&gt;运算符中。传给其数或字符串等基本类型的值，&lt;code class=&quot;inline&quot;&gt;typeof&lt;/code&gt;会返回对应类型名字的字符串（例如&lt;code class=&quot;inline&quot;&gt;&quot;number&quot;&lt;/code&gt;）。对于对象，它返回&lt;code class=&quot;inline&quot;&gt;&quot;object&quot;&lt;/code&gt;。最要命的是，对于函数它返回&lt;code class=&quot;inline&quot;&gt;&quot;function&quot;&lt;/code&gt;，没有额外的信息。&lt;/p&gt;&lt;blockquote&gt;出于这个原因，&lt;code class=&quot;inline&quot;&gt;typeof&lt;/code&gt;对这个操作符来说可能是个糟糕的名字。它应该被称为&lt;code class=&quot;inline&quot;&gt;tagof&lt;/code&gt;，为未来的可能出现的JavaScript静态类型系统留下的&lt;code class=&quot;inline&quot;&gt;typeof&lt;/code&gt;这个名字。&lt;/blockquote&gt;&lt;p&gt;总而言之，这意味着当遇到函数时，函数契约只能检查它是否的确是函数（如果不是，那显然是错误的）。它无法检查有关该函数的定义域和值域的任何信息。我们要放弃吗？&lt;/p&gt;&lt;h2&gt;16.3 高阶契约&lt;/h2&gt;&lt;p&gt;为了确定要做什么，我们先回忆一下契约最初提供了什么保证。在前述的&lt;code class=&quot;inline&quot;&gt;real-sqrt-1&lt;/code&gt;中，我们要求参数是非负的。然而，只有在&lt;code class=&quot;inline&quot;&gt;real-sqrt-1&lt;/code&gt;被实际使用时才会进行检查，并且仅检查实际传入的值。例如，如果程序包含片段&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(lambda () (real-sqrt-1 -1))&lt;/code&gt;&lt;p&gt;但该thunk一直没被调用，那么程序员将永远不会看到这里的契约被违反。事实上，可能在程序的这次运行中没有调用此thunk，但在后一次运行中调用到了；因此，该程序包含一个潜在的契约错误。出于此原因，通常最好用静态类型来表示不变量；但在使用契约时，我们明白，仅当程序执行到相关位置时，我们才会收到错误通知。&lt;/p&gt;&lt;p&gt;这是有用的见解，因为它为我们的函数问题提供了解决方案。对于指明的函数值，我们立即检查它真的是函数。但是，我们不会忽略定义域和值域的契约，而是&lt;b&gt;延迟&lt;/b&gt;处理。我们在函数（每次）实际作用于某个值时检查定义域契约，并在函数实际返回值时检查值域契约。&lt;/p&gt;&lt;p&gt;这显然和&lt;code class=&quot;inline&quot;&gt;make-contract&lt;/code&gt;不是一种模式。因此，我们给&lt;code class=&quot;inline&quot;&gt;make-contract&lt;/code&gt;起个更具描述性的名称：它检查&lt;b&gt;即时的&lt;/b&gt;（immediate）契约（即当前可以完整检查的契约）。&lt;/p&gt;&lt;blockquote&gt;在Racket契约系统中，即时契约被称为&lt;b&gt;扁平的&lt;/b&gt;（flat）。这个术语有点误导，因为它们也可以保护数据结构。&lt;/blockquote&gt;&lt;code lang=&quot;racket&quot;&gt;(define (immediate pred?)
  (lambda (val)
    (if (pred? val) val (blame val))))&lt;/code&gt;&lt;p&gt;相比之下，函数契约读入两个契约作为参数——分别表示对定义域和值域的检查——并返回谓词。这个谓词作用于需要满足契约的值。首先，它会检查给定的值实际上是函数：这部分仍然是即时的。然后，我们创建一个&lt;b&gt;代理&lt;/b&gt;（surrogate）函数，由它来应用“剩余的”契约——检查定义域和值域——但其他方面与原函数行为相同。&lt;/p&gt;&lt;p&gt;创建代理这一行为背离了传统的断言机制，也就是只是简单地检查而不改变值。相反，对于函数，如果想要检查契约，我们必须使用新创建的代理。因此，一般来说我们需要创建封装函数，它会读入契约和值，并创建该值的保护版本：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (guard ctc val) (ctc val))&lt;/code&gt;&lt;p&gt;一个非常简单的例子，假设我们要用数契约包装&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;函数（使用稍后定义的函数契约的构造函数&lt;code class=&quot;inline&quot;&gt;function&lt;/code&gt;）：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define a1 (guard (function (immediate number?)
                            (immediate number?))
                  add1))&lt;/code&gt;&lt;p&gt;我们希望&lt;code class=&quot;inline&quot;&gt;a1&lt;/code&gt;本质上绑定到以下代码：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define a1
  (lambda (x)
    (num?-con (add1 (num?-con x)))))&lt;/code&gt;&lt;p&gt;其中&lt;code class=&quot;inline&quot;&gt;(lambda (x) ...)&lt;/code&gt;是代理；它会&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;的调用之处前后调用数值契约。回忆一下，在没有违规的情况下，契约的行为就是恒等函数，所以这个程序在不违规的情况下行为于&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;完全相同。&lt;/p&gt;&lt;p&gt;为了达到此目的，我们使用下面的&lt;code class=&quot;inline&quot;&gt;function&lt;/code&gt;定义。【注释】请记住，我们还必须确保给定的值真的是函数（这里的&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;的确是，这一点可以立即检查，这也是为什么在我们将代理绑定到a1时此项检查已经消失的原因）：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (function dom rng)
  (lambda (val)
    (if (procedure? val)
        (lambda (x) (rng (val (dom x))))
        (blame val))))&lt;/code&gt;&lt;blockquote&gt;简单起见，我们这里假设单参数函数，不过扩展到多参数的情况很简单。事实上，更复杂的契约甚至可以检查参数&lt;b&gt;之间&lt;/b&gt;的关系。&lt;/blockquote&gt;&lt;p&gt;要理解这是如何工作的，我们来替换参数。为了保持代码可读性，我们先构造&lt;code class=&quot;inline&quot;&gt;number?&lt;/code&gt;契约检查器，并将其命名：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define num?-con (immediate number?))
= (define num?-con
    (lambda (val)
      (if (number? val) val (blame val))))&lt;/code&gt;&lt;p&gt;回到&lt;code class=&quot;inline&quot;&gt;a1&lt;/code&gt;的定义。我们先调用&lt;code class=&quot;inline&quot;&gt;guard&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define a1
  ((function num?-con num?-con)
   add1))&lt;/code&gt;&lt;p&gt;接下来调用函数契约的构造函数：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define a1
  ((lambda (val)
     (if (procedure? val)
         (lambda (x) (num?-con (val (num?-con x))))
         (blame val)))
   add1))&lt;/code&gt;&lt;p&gt;调用左括号-左括号-lambda得：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define a1
  (if (procedure? add1)
      (lambda (x) (num?-con (add1 (num?-con x))))
      (blame add1)))&lt;/code&gt;&lt;p&gt;请注意，这一步会检查被保护的值的确是函数。因此我们得到&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define a1
  (lambda (x)
    (num?-con (add1 (num?-con x)))))&lt;/code&gt;&lt;p&gt;这正是我们想要获得的代理，对于不违规的调用，其行为就是&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;有多少种方式可以违背上述的&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;契约？&lt;/blockquote&gt;&lt;p&gt;三种方式，分别对应于三个契约构造函数：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;被封装的值可能不是函数；&lt;/li&gt;&lt;li&gt;被封装的是函数，它可能被作用于不为数的值；或者&lt;/li&gt;&lt;li&gt;被封装的是函数，输入也是数，但其返回值不是数类型。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;编写示例实现这三种违规行为，并观察契约系统的行为。你能改进错误信息以更好地区分这些情况吗？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;同样的封装技术也适用于&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define d/dx
  (guard (function (function (immediate number?) (immediate number?))
                   (function (immediate number?) (immediate number?)))
         (lambda (f)
           (lambda (x)
             (/ (- (f (+ x 0.001))
                   (f x))
                0.001)))))&lt;/code&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;违反此契约的方式有七种，分别对应于七个契约构造函数。根据需要，传入（错误的）参数或修改代码，以违反它们中的每一个。是否可以改进错误报告，以正确识别每种违规行为？&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;请注意，嵌套函数的契约推迟了两处即时契约的检查，而不是一处。这符合我们的期望，因为即时契约只能报告实际值的问题，所以直到应用于实际值之前，它们无法报告任何错误。但是，这确实意味着“违规”这个概念很微妙：传递给&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;的函数值可能的确违反了契约，但这类违规只有在传递或返回数值之后才会被&lt;b&gt;观测&lt;/b&gt;到。&lt;/p&gt;&lt;h2&gt;16.4 便捷语法&lt;/h2&gt;&lt;p&gt;之前我们看到了两种扁平契约的使用风格，分别由&lt;code class=&quot;inline&quot;&gt;real-sqrt-1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;real-sqrt-2&lt;/code&gt;体现。这两种风格各有缺点。后者让人联想到传统的断言系统，它不能用于高阶值（函数），因为被封装的值才需要检查。（当然，传统的断言系统只处理扁平契约，所以它们忽略了这个细微的差别。）前者将值的使用放与契约之中，理论上这可行，但有三个缺点：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;开发人员可能会忘记封装某些使用。&lt;/li&gt;&lt;li&gt;契约在每次使用中都会被检查一次，在多次使用时这是浪费。&lt;/li&gt;&lt;li&gt;程序混合了契约检查和其功能行为，降低了可读性。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;幸运的是，一般情况下，明智地使用语法糖就可以解决此问题。例如，假设我们要将契约附加到函数的参数上，那么开发人员可以这么编写：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define/contract (real-sqrt (x :: (immediate positive?)))
  (sqrt x))&lt;/code&gt;&lt;p&gt;意图是用&lt;code class=&quot;inline&quot;&gt;positive?&lt;/code&gt;来保护&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;，但只在函数调用时只执行一次检查。这应该转化为：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (real-sqrt new-x)
  (let ([x (guard (immediate positive?) new-x)])
    (sqrt x)))&lt;/code&gt;&lt;p&gt;也就是说，宏为每个标识符生成新名称，然后将用户给出的名称关联到新名称的封装版本。这个宏的实现如下：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define-syntax (define/contract stx)
  (syntax-case stx (::)
    [(_ (f (id :: c) ...) b)
     (with-syntax ([(new-id ...) (generate-temporaries #&#39;(id ...))])
       #&#39;(define f
           (lambda (new-id ...)
             (let ([id (guard c new-id)]
                   ...)
               b))))]))&lt;/code&gt;&lt;p&gt;有了这些（语法上的）便利，契约语言的设计师可以提高契约使用的可读性、效率和健壮性。&lt;/p&gt;&lt;h2&gt;16.5 扩展到复合数据结构&lt;/h2&gt;&lt;p&gt;正如我们已经讨论过的，将契约扩展到结构化数据类型（如链表、向量和用户定义的递归数据类型）似乎很容易。只需要提供适当的对运行时观测集。一般来说这取决于语言提供类型的精度。例如，正如我们之前讨论过的，支持数据类型的语言不需要&lt;b&gt;类型&lt;/b&gt;谓词，但仍然会提供区分&lt;b&gt;变体&lt;/b&gt;的谓词；这种情况下，类型级别的“契约”检查最好（也许必须）留给静态类型系统，而由契约来断言更精确的结构特性。&lt;/p&gt;&lt;p&gt;但是，这种策略可能会遇到严重的性能问题。例如，假设我们编写了平衡二叉搜索树，能以对数渐近时间（相对树的大小）实现插入和查找。接下来我们将树封装在合适的契约中。遗憾的是，仅检查契约就会访问整个树，从而用去线性时间！因此，理想情况下更好的策略是，构建树的时候就（以增量方式）完成契约检查，查找时则不需要再次检查。&lt;/p&gt;&lt;p&gt;更糟的是，平衡和顺序都是搜索树的递归属性。因此原则上，每个子树都应满足，所以每次递归调用都需要检查。在插入过程中，由于插入是递归的，将在每个访问的子树上检查契约。在大小为 &lt;equation&gt;t&lt;/equation&gt; 的树中，契约谓词应用于 &lt;equation&gt;\frac{t}{2}&lt;/equation&gt; 元素的子树，然后应用于 &lt;equation&gt;\frac{t}{4}&lt;/equation&gt; 元素的子子树，依此类推，在最坏情况下，会访问总数为 &lt;equation&gt;\frac{t}{2}+\frac{t}{4}+...+\frac{t}{t}&lt;/equation&gt; 的元素——使我们预期的对数时间插入过程花费线性时间。&lt;/p&gt;&lt;p&gt;对这两个例子，许多情况下都可以采用措施缓解。每个值都需要与它已经通过的一组契约相关联（或内部存储，或存储于散列表中）。然后，当需要调用契约时，首先检查它是否已被检查过，如果有，则不再检查。这实质上是将契约检查记忆化（memoization），从而减少检查的算法复杂性。当然，对记忆化而言，最好值是不可变的。如果这些值可能发生变化，并且契约执行任意计算，那么此优化可能无法做到可靠。&lt;/p&gt;&lt;p&gt;检查数据结构还有一个微妙的问题。作为例子，考虑我们之前编写的检查数链表中所有值均是偶数的契约。假设我们已经用契约封装了链表，但只对链表的第一个元素感兴趣。当然，我们检查了列表中的所有值，这可能需要很长时间。但更重要的是，用户可能会争辩说，报告链表第二个元素违规的行为本身违反了我们对契约检查的期望，因为我们并未实际使用该元素。&lt;/p&gt;&lt;p&gt;这意味着推迟检查某些值，即使它们可以即时被检查。例如，可以将整个链表转换为包含延时检查的封装值，每个值仅在访问时被检查。这种策略可能很有吸引力，但编码该策略并不简单，尤其当存在&lt;b&gt;别名&lt;/b&gt;的情况下会遇到问题：如果两个不同的标识符引用同一链表，一个有契约保护而另一个没有，我们必须确保它们都按预期运行（这通常意味着我们不能在链表中存储任何可变状态）。&lt;/p&gt;&lt;h2&gt;16.6 再论契约和观测&lt;/h2&gt;&lt;p&gt;契约实现还有一个奇怪的普遍问题——遇到复杂数据时更甚。之前，我们抱怨说检查函数的契约很难，因为我们观测能力受限：我们能检查的只有值是否是函数。在真实的语言中，数据结构的问题其实是相反的：我们的观测能力过剩。例如，如果我们实施延迟检查链表的策略，则很可能需要使用某个结构体来保存实际链表，并修改&lt;code class=&quot;inline&quot;&gt;first&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;rest&lt;/code&gt;，以此（检查契约后）获取结构体中的值。但是，像&lt;code class=&quot;inline&quot;&gt;list?&lt;/code&gt;这样的函数现在可能返回&lt;code class=&quot;inline&quot;&gt;false&lt;/code&gt;而不是&lt;code class=&quot;inline&quot;&gt;true&lt;/code&gt;，因为结构体不是链表；因此，&lt;code class=&quot;inline&quot;&gt;list?&lt;/code&gt;需要绑定到新函数上，遇到这些特殊的表示链表的延迟契约结构体也返回&lt;code class=&quot;inline&quot;&gt;true&lt;/code&gt;。但契约系统作者还需要记得解决&lt;code class=&quot;inline&quot;&gt;cons?&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;pair?&lt;/code&gt;，天知道还有多少其他函数都可以执行观测操作。&lt;/p&gt;&lt;p&gt;一般来说，有一个观测基本上不可能“修复”：&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;。通常情况下，每个值&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;它自己，即使函数也是如此。然而，函数封装以后就是新的函数了，不但&lt;b&gt;不&lt;/b&gt;&lt;code class=&quot;inline&quot;&gt;eq?&lt;/code&gt;自己，也&lt;b&gt;不应该&lt;/b&gt;，因为其行为真的不同了（尽管只是在违反契约的情况下，并且只在提供了足够多的输入值得以观测到违规行为后）。然而，这意味着程序无法暗中保护自己，因为守护行为可以被观测到。因此，恶意模块有时可以检测它收到的是否是受保护的值，如果是就正常运行，否则就不！&lt;/p&gt;&lt;h2&gt;16.7 契约和赋值&lt;/h2&gt;&lt;p&gt;我们无疑应该关注契约与赋值之间的相互作用，当契约延迟检查——固有延迟或者以延迟方式实现——时更是如此。有两件事值得关注。一是将契约值存储在可变状态中；二是&lt;b&gt;为&lt;/b&gt;可变状态编写的契约。&lt;/p&gt;&lt;p&gt;当我们存储契约值时，封装策略确保契约检查正常进行。在每个步骤，契约都会尽可能多地检查现有的值，并创建包含其余检查的封装值。因此，即使这个封装值被存储在可变状态并在稍后检索以供使用，它仍然包含这些检查，并且当值最终被使用时它们将被执行。&lt;/p&gt;&lt;p&gt;另一个问题是编写可变数据的契约，如box和向量。在这种情况下，我们可能必须为包含契约的整个数据类型创建封装。然后，当数据类型中的值被替换为新值时，执行更新的操作（例如&lt;code class=&quot;inline&quot;&gt;set-box!&lt;/code&gt;）需要从封装中检索契约，将其应用于新值并存储新封装的值。因此，这需要修改数据结构赋值操作符的行为，使其对契约值敏感。然而，赋值不会改变违规行为的发生点：即时契约即时发生，延时契约遇到（非法）输入值时发生。&lt;/p&gt;&lt;h2&gt;16.8 契约的组合&lt;/h2&gt;&lt;p&gt;我们已经讨论过所有基本数据类型的组合，本节很自然要契约的组合。正如之前讨论的&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35291037/chap15.md#1533-%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B&quot;&gt;联合&lt;/a&gt;和&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35291037/chap15.md#1535-%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B&quot;&gt;交叉&lt;/a&gt;类型一样，我们应该考虑契约的联合和交叉（分别是“或”与“和”）；还应当考虑取反。然而，契约只是表面上类似于类型，所以我们必须根据契约来考虑这些问题，而不是试图将我们从类型学到的意义映射到契约领域。&lt;/p&gt;&lt;p&gt;直接的例子总是简单的。联合契约通过析取组合——事实上，因为是谓词，其结果可以字面上用&lt;code class=&quot;inline&quot;&gt;or&lt;/code&gt;组合——而交叉契约通过合取组合。我们依次调用谓词，进行短路求值（译注，参见&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35291037/chap17.md#1731-%E9%80%9A%E8%BF%87%E6%90%9C%E7%B4%A2%E8%8E%B7%E5%BE%97%E6%BB%A1%E8%B6%B3&quot;&gt;后文&lt;/a&gt;），最后产生错误或返回契约的值。交叉契约通过合取（&lt;code class=&quot;inline&quot;&gt;and&lt;/code&gt;）组合。而取反契约就是直接调用原始的契约，但对谓词取反（通过&lt;code class=&quot;inline&quot;&gt;not&lt;/code&gt;）。&lt;/p&gt;&lt;p&gt;在延迟、高阶的情况下，契约组合要困难得多。例如，考虑对数到数的函数的契约进行取反。这里取反到底是什么意思？是否表示该函数&lt;b&gt;不&lt;/b&gt;应接受数？或者如果接受了数，它不应该返回数？或两者都要？特别是，我们如何执行这样的契约？例如，如何检查某个函数不接受数——是否期望在给予数时会产生错误？但请考虑用这样的契约封装的恒等函数；因为当给予数（或者其他任何值）时，它显然不会出错，这是否意味着应该等到它产生值，如果它确实产生了数，那么拒绝它？但最糟糕的是，请注意，这意味着我们将在&lt;b&gt;未&lt;/b&gt;定义的定义域中运行函数：显然这会破坏程序中的不变量、污染堆栈、或使程序崩溃。&lt;/p&gt;&lt;p&gt;交叉契约要求值通过所有子契约。这意味着高阶值需要重新封装，检查所有定义域子契约以及所有值域子契约。只要一个子契约没有满足，整个交叉（契约）都会失败。&lt;/p&gt;&lt;p&gt;联合契约更加微妙，因为任何一个子契约失败都不直接导致值被拒绝。相反，它只是意味着这个子契约不再是所封装值所遵守的契约；其他子契约仍然可能被遵守，只有当没有任何子契约候选时才拒绝值。这意味着联合契约的实现中必须记录哪些子契约通过或失败——这里，记录就意味着赋值。【注释】由于每条子包契约失败时，它将被从候选名单删除，而剩下的会继续执行。当没有候选子契约时，系统必须报告违规行为。错误报告最好要提供导致每个子契约失败的实际值（请记住，这些值可能嵌套在多层函数中）。&lt;/p&gt;&lt;blockquote&gt;在类似Racket的多线程语言中，还需要加锁以避免竞争条件。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;Racket所实现的契约构造器和组合器对可接受的子契约形式提出了限制。这使得实现既有效率又能提供有用的错误消息。此外，上面讨论的极端情况很少在实践中出现——当然现在如果需要你知道如何实现它们。&lt;/p&gt;&lt;h2&gt;16.9 问责&lt;/h2&gt;&lt;p&gt;本节回过头讨论报告契约违反的问题。这指的不是打印什么字符串，而是更重要的问题，报告&lt;b&gt;什么&lt;/b&gt;。我们将看到，此问题实际上是语义上的考虑。&lt;/p&gt;&lt;p&gt;为了说明这个问题，回想一下上面&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;的定义，假设我们在没有任何契约检查的情况下运行。先假设我们将这个函数应用于完全不合适的&lt;code class=&quot;inline&quot;&gt;string-append&lt;/code&gt;（它既不读入也不产生数）。这么做只会产生一个值：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (define d/dx-sa (d/dx string-append))&lt;/code&gt;&lt;p&gt;（请注意，即使有契约检查，这也会通过，因为函数契约的即时部分认可&lt;code class=&quot;inline&quot;&gt;string-append&lt;/code&gt;是函数。）接下来假设我们将&lt;code class=&quot;inline&quot;&gt;d/dx-sa&lt;/code&gt;应用于一个数，这应是正常行为：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (d/dx-sa 10)
string-append: contract violation
  expected: string?
  given: 10.001&lt;/code&gt;&lt;p&gt;请注意，错误报告位于&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;函数体的内部。一方面，这完全是合理的：这是&lt;code class=&quot;inline&quot;&gt;string-append&lt;/code&gt;不正确调用发生的地方。另一方面，&lt;b&gt;错误&lt;/b&gt;并非来自&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;，而来自声称&lt;code class=&quot;inline&quot;&gt;string-append&lt;/code&gt;是合法的数到数的函数的代码。但问题是，做这件事的代码早已逃之夭夭；它已经不在堆栈中，因此也不在传统错误报告机制的范围内。&lt;/p&gt;&lt;p&gt;这个问题不是&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;所特有的；事实上，大型系统中它很常见。这是因为系统——尤其是含有图形、网络和其他外部接口的系统——中大量使用&lt;b&gt;回调&lt;/b&gt;（callback）：对某个实体感兴趣而被注册的函数（或方法），要发某种状态或值的信号时被调用。（在这里，&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;等价于图形层，而&lt;code class=&quot;inline&quot;&gt;string-append&lt;/code&gt;等价于传给它（并由它存储）的回调。）最终，系统层会调用回调。如果这会导致错误，那&lt;b&gt;既不是&lt;/b&gt;系统层的错误，它收到的回调符合要求的契约，&lt;b&gt;也不是&lt;/b&gt;回调本身的错误，它应该有合理的用途，只是被错误地提供给函数。相反，&lt;b&gt;错误来源于引入这两者的实体&lt;/b&gt;。然而，此时调用栈只包含回调（位于栈顶）和系统（位于其下）——唯一有错的一方不在了。这种类型的错误因此非常难调试。&lt;/p&gt;&lt;p&gt;解决办法是扩展契约系统，纳入&lt;b&gt;问责&lt;/b&gt;（blame）的概念。想法是，有效地记录将一对组件组合在一起的那个实体，以便如果它们之间发生契约违规，我们可以将失败归因于该实体。请注意，这只在函数的情况下才有实际意义，但为了一致性，我们以自然的方式也将问责扩展到即时契约中。&lt;/p&gt;&lt;p&gt;对于函数，请注意有两种可能的失败点：要么它被&lt;b&gt;给予了&lt;/b&gt;是错误的值（先验条件），要么是它&lt;b&gt;生成了&lt;/b&gt;错误的值（后验条件）。区分这两种情况很重要，因为在前一种情况下，我们应该将错误归咎于环境——这里，也即实参表达式——而在后一种情况下（假设参数已经通过），则应归咎于函数本身。（对即时值的自然扩展是我们只能对值值本身不满足契约进行问责，也就是“后验条件”）。&lt;/p&gt;&lt;p&gt;对于契约，我们引入术语&lt;b&gt;正&lt;/b&gt;（positive）和&lt;b&gt;负&lt;/b&gt;（negative）位置。对于一阶函数，负位置是先验条件，正位置是后验条件。这么看这似乎是不必要的额外术语。但我们很快就会看到，这两个术语具有更一般的含义。&lt;/p&gt;&lt;p&gt;现在将情况推广到契约的参数。之前，即时契约读入一个谓词，而函数契约读入定义域和值域的契约。这点保持不变。不过它们返回的将是函数，此函数有两个参数：正负位置的标签。（这个标签可以是任何合理的数据类型：抽象语法节点、缓冲区偏移量、或其他描述符。简单起见，我们使用字符串。）这样，函数契约将闭包于程序位置标签，以便将来对非法函数的提供方进行问责。&lt;/p&gt;&lt;p&gt;现在由&lt;code class=&quot;inline&quot;&gt;guard&lt;/code&gt;函数负责传入契约调用位置的标签：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (guard ctc val pos neg) ((ctc pos neg) val))&lt;/code&gt;&lt;p&gt;由&lt;code class=&quot;inline&quot;&gt;blame&lt;/code&gt;显示合适的标签（由契约实现传给它）：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (blame s) (error &#39;contract s))&lt;/code&gt;&lt;p&gt;假设我们像以前一样，保护&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;的使用。正负位置用什么名字有意义呢？正位置是后验条件：这里的任何失败都必须归咎于&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;的函数体。负位置是先验条件：这里的任何失败都必须归咎于&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;的参数。因此：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define a1 (guard (function (immediate number?)
                            (immediate number?))
                  add1
                  &quot;add1 body&quot; ;add1函数体
                  &quot;add1 input&quot;)) ;add1的输入&lt;/code&gt;&lt;p&gt;假设传给&lt;code class=&quot;inline&quot;&gt;guard&lt;/code&gt;的不是函数，我们会期望在“后验条件”位置出现错误：这并不是后验条件的失败，而是因为，如果调用的不是函数，不能去指责参数。（当然，这表明我们这里扩展了术语“后验条件”，更合理地应该使用术语“正（位置）”。）因为相信&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;的实现只会返回数，所以我们预计它不可能让后置条件失败。当然，我们期望像&lt;code class=&quot;inline&quot;&gt;(a1 &quot;x&quot;)&lt;/code&gt;这样的表达式触发先验条件错误，可以在&lt;code class=&quot;inline&quot;&gt;&quot;add1 input&quot;&lt;/code&gt;位置处发出契约错误。相反，如果我们保护的函数违反了后验条件，比如这样，&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define bad-a1 (guard (function (immediate number?)
                                (immediate number?))
                      number-&amp;gt;string
                      &quot;bad-add1 body&quot;
                      &quot;bad-add1 input&quot;))&lt;/code&gt;&lt;p&gt;我们希望将责任被归咎于&lt;code class=&quot;inline&quot;&gt;&quot;bad-add1 body&quot;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;接下来讨论如何实现这些契约构造函数。对于即时契约，我们说过应问责正位置：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (immediate pred?)
  (lambda (pos neg)
    (lambda (val)
      (if (pred? val) val (blame pos)))))&lt;/code&gt;&lt;p&gt;对于函数，我们可能想这么写&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (function dom rng)
  (lambda (pos neg)
    (lambda (val)
      (if (procedure? val)
          (lambda (x) (dom (val (rng x))))
          (blame pos)))))&lt;/code&gt;&lt;p&gt;但是这根本不能运作：它违反了契约所预期的签名。这是因为，现在所有契约都期望输入正负位置的标签，也就是&lt;code class=&quot;inline&quot;&gt;dom&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;rng&lt;/code&gt;不能像上面那样使用。（另一个理由，函数体中用到了&lt;code class=&quot;inline&quot;&gt;pos&lt;/code&gt;，但完全不含&lt;code class=&quot;inline&quot;&gt;neg&lt;/code&gt;，尽管已经看到过一些例子，我们认为责任必须归咎于&lt;code class=&quot;inline&quot;&gt;neg&lt;/code&gt;所绑定的位置。）所以很明显，我们要以某种方式使用&lt;code class=&quot;inline&quot;&gt;pos&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;neg&lt;/code&gt;实例化的值域和定义域契约，以便它们“知道”和“记住”可能调用非法函数的地方。&lt;/p&gt;&lt;p&gt;最显然的做法是用相同的&lt;code class=&quot;inline&quot;&gt;dom&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;rng&lt;/code&gt;值实例化这些契约构造函数：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (function dom rng)
  (lambda (pos neg)
    (let ([dom-c (dom pos neg)]
          [rng-c (rng pos neg)])
      (lambda (val)
        (if (procedure? val)
            (lambda (x) (rng-c (val (dom-c x))))
            (blame pos))))))&lt;/code&gt;&lt;p&gt;现在所有签名都匹配了，我们可以运行契约了。但这样做时，返回不太对劲。比如，在我们最简单的违反契约的例子中，返回是&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (a1 &quot;x&quot;)
contract: add1 body&lt;/code&gt;&lt;p&gt;咦？也许我们应该展开&lt;code class=&quot;inline&quot;&gt;a1&lt;/code&gt;的代码，来看看发生了什么。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(a1 &quot;x&quot;)
= (guard (function (immediate number?)
                   (immediate number?))
         add1
         &quot;add1 body&quot;
         &quot;add1 input&quot;)
= (((function (immediate number?) (immediate number?))
    &quot;add1 body&quot; &quot;add1 input&quot;)
   add1)
= (let ([dom-c ((immediate number?) &quot;add1 body&quot; &quot;add1 input&quot;)]
        [rng-c ((immediate number?) &quot;add1 body&quot; &quot;add1 input&quot;)])
    (lambda (x) (rng-c (add1 (dom-c x)))))
= (let ([dom-c (lambda (val)
                 (if (number? val) val (blame &quot;add1 body&quot;)))]
        [rng-c (lambda (val)
                 (if (number? val) val (blame &quot;add1 body&quot;)))])
    (lambda (x) (rng-c (add1 (dom-c x)))))&lt;/code&gt;&lt;p&gt;可怜的&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;：它都没有获得机会！剩下的唯一问责标签是&lt;code class=&quot;inline&quot;&gt;&quot;add1 body&quot;&lt;/code&gt;，所以只能归咎于它了。&lt;/p&gt;&lt;p&gt;等下会讨论此问题，先来观察上面的代码，其中没有任何函数契约的踪迹。我们有的只是即时契约，当实际值（如果）发生时进行问责。这与我们之前所说&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35291037/chap16.md#163-%E9%AB%98%E9%98%B6%E5%A5%91%E7%BA%A6&quot;&gt;只能观测到即时值&lt;/a&gt;完全一致。当然，这只适用于一阶函数；当遇到高阶函数时，这不再成立。&lt;/p&gt;&lt;p&gt;错在哪里？请注意，在&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;函数体中只有绑定到&lt;code class=&quot;inline&quot;&gt;rng-c&lt;/code&gt;的契约应该被问责。相反，&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;的输入中应该被问责的是绑定到&lt;code class=&quot;inline&quot;&gt;dom-c&lt;/code&gt;的契约。看起来，在函数契约的定义域位置，正负标签需要……交换。&lt;/p&gt;&lt;p&gt;考虑契约保护的&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;，我们会发现情况确实如此。关键的见解是，当调用的函数作为参数时，“外部”成为“内部”，反之亦然。也就是说，&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;的函数体——处于正位置——调用了被求微分的函数，将这个函数的函数体置于正位置，并将调用者——&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;的函数体——置于负位置。因此，在契约的定义域一侧，每次嵌套函数契约都会导致正负位置交换。&lt;/p&gt;&lt;p&gt;值域一侧无需交换。继续考虑&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;。它返回的函数代表导数，所以它的输入是数（代表计算导数的点），返回也是数（该点的导数）。这个函数的负位置就是使用微分函数的客户——即先验条件——正位置就是&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;本身——即后验条件——因为它负责生成导数。&lt;/p&gt;&lt;p&gt;这样，我们就更正的、正确的函数构造函数的定义：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(define (function dom rng)
  (lambda (pos neg)
    (let ([dom-c (dom neg pos)]
          [rng-c (rng pos neg)])
      (lambda (val)
        (if (procedure? val)
            (lambda (x) (rng-c (val (dom-c x))))
            (blame pos))))))&lt;/code&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;将此应用于之前的例子，确认得到的问责符合预期。此外，手动展开代码以了解为何。&lt;br&gt;&lt;/blockquote&gt;&lt;p&gt;更进一步，假设我们定义&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;的正位置标签为&lt;code class=&quot;inline&quot;&gt;&quot;d/dx body&quot;&lt;/code&gt;，负位置标签为&lt;code class=&quot;inline&quot;&gt;&quot;d/dx input&quot;&lt;/code&gt;。假设我们传给它函数&lt;code class=&quot;inline&quot;&gt;number-&amp;gt;string&lt;/code&gt;（此函数明显无法计算导数），然后将结果应用于&lt;code class=&quot;inline&quot;&gt;10&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;((d/dx (guard (function (immediate number?)
                        (immediate string?))
              number-&amp;gt;string
              &quot;n-&amp;gt;s body&quot;
              &quot;n-&amp;gt;s input&quot;))
 10)&lt;/code&gt;&lt;p&gt;这正确地表明，应该归咎于将&lt;code class=&quot;inline&quot;&gt;number-&amp;gt;string&lt;/code&gt;假定为数函数提供给&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;的表达式——而不是&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;本身。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;手工计算&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;，将其作用于&lt;b&gt;所有&lt;/b&gt;相关的违规情况，并确认由此产生的问责是准确的。如果你将&lt;code class=&quot;inline&quot;&gt;string-&amp;gt;number&lt;/code&gt;传给&lt;code class=&quot;inline&quot;&gt;d/dx&lt;/code&gt;，附带函数契约指明它将字符串映射到数，会发生什么？如果你在没有契约的情况下传入相同的函数呢？&lt;/blockquote&gt;</description>
<author>lotuc</author>
<guid isPermaLink="false">2018-04-04-35291037</guid>
<pubDate>Wed, 04 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（八）：范畴</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-04-35237925.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35237925&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8fd16e3275832ced282b1a9c125bb8c2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;775&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文中，我们用群，拓扑空间，CPO作为例子，&lt;br&gt;来说明什么是&lt;b&gt;数学结构&lt;/b&gt;，以及数学结构是如何通过映射来保持的。&lt;br&gt;群同态保持了群结构，连续映射保持了拓扑结构，连续函数保持了完全偏序结构。&lt;/p&gt;&lt;p&gt;那么群结构与拓扑结构之间是否有联系呢？&lt;br&gt;我们能否建立拓扑空间与群之间的对应关系呢？&lt;/p&gt;&lt;p&gt;在代数拓扑中，就存在这样的例子，&lt;br&gt;人们找到了和拓扑空间相关的群论概念，例如基本群和同调群，&lt;br&gt;拓扑空间的连续映射可以导出这些群的群同态。&lt;/p&gt;&lt;p&gt;这就为了人们使用代数学方法研究其他数学分支，奠定了基础，&lt;br&gt;实际上，最原始的范畴论想法也是起源于此。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 图示法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在前一篇中我们学过了&lt;b&gt;幺半群&lt;/b&gt;，&lt;br&gt;它指的是一个集合 &lt;equation&gt;M&lt;/equation&gt; ，以及 &lt;equation&gt;M&lt;/equation&gt; 上的二元运算 &lt;equation&gt;\cdot&lt;/equation&gt; ，满足以下两个条件，&lt;br&gt;（1） &lt;equation&gt;\forall x,y,z\in M&lt;/equation&gt; ， &lt;equation&gt;(x\cdot y)\cdot z=x\cdot (y\cdot z)&lt;/equation&gt; ，&lt;br&gt;（2） &lt;equation&gt;\exists e\in M&lt;/equation&gt; ， &lt;equation&gt;\forall x\in M&lt;/equation&gt; ， &lt;equation&gt;x\cdot e=e\cdot x=x&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;这两个条件除了可以用等式来表示，还可以用&lt;b&gt;图&lt;/b&gt;（diagram）来表示，&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1bd56c30e34a673a998895029362c270_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1138&quot; data-rawheight=&quot;234&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们称以上两张图都是&lt;b&gt;可交换的&lt;/b&gt;（commutative），&lt;br&gt;即，沿着不同的路径进行运算，只要起点和终点相同，则运算的结果就相同。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;&amp;lt;x,y,z&amp;gt;\mapsto &amp;lt;x,yz&amp;gt;\mapsto x(yz)&lt;/equation&gt; ，总是等于 &lt;equation&gt;&amp;lt;x,y,z&amp;gt;\mapsto &amp;lt;xy,z&amp;gt;\mapsto (xy)z&lt;/equation&gt; ，&lt;br&gt;即， &lt;equation&gt;x(yz)=(xy)z&lt;/equation&gt; ，表明 &lt;equation&gt;M&lt;/equation&gt; 中元素的运算满足&lt;b&gt;结合律&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;又例， &lt;equation&gt;&amp;lt;0,x&amp;gt;\mapsto &amp;lt;e,x&amp;gt;\mapsto ex&lt;/equation&gt; ，总是等于 &lt;equation&gt;&amp;lt;0,x&amp;gt;\mapsto x&lt;/equation&gt; ，即 &lt;equation&gt;ex=x&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;&amp;lt;x,0&amp;gt;\mapsto &amp;lt;x,e&amp;gt;\mapsto xe&lt;/equation&gt; ，总是等于 &lt;equation&gt;&amp;lt;x,0&amp;gt;\mapsto x&lt;/equation&gt; ，即 &lt;equation&gt;xe=x&lt;/equation&gt; 。&lt;br&gt;因此， &lt;equation&gt;ex=x=xe&lt;/equation&gt; ，表明 &lt;equation&gt;M&lt;/equation&gt; 中存在&lt;b&gt;幺元&lt;/b&gt; &lt;equation&gt;e&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;所以，我们可以用以上两个图表，作为幺半群的定义，称为&lt;b&gt;图示法&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;另一方面，考虑在集合论中讨论映射的时候，一般都不写具体元素，还可以表示为，&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65f472da6c217b0f01bbc9704f4df946_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1070&quot; data-rawheight=&quot;218&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中， &lt;equation&gt;\mu:M\times M\to M&lt;/equation&gt; ， &lt;equation&gt;\eta:1\to M&lt;/equation&gt; ，是两个函数， &lt;equation&gt;1=\{0\}&lt;/equation&gt; 是只有一个元素的集合。&lt;/p&gt;&lt;p&gt;用图示法来表示幺半群，更具一般性。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 范畴&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;范畴是一个数学概念，也可以用图示法来表示。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-07f823a724618aaf5e160d394a7eab6e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;178&quot; data-rawheight=&quot;161&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;一个&lt;b&gt;范畴&lt;/b&gt; &lt;equation&gt;Cat&lt;/equation&gt; 由一系列&lt;b&gt;对象&lt;/b&gt;（object）和&lt;b&gt;箭头&lt;/b&gt;（arrow）组成。&lt;br&gt;对于每一个箭头 &lt;equation&gt;f&lt;/equation&gt; ，有两个对象与之关联，&lt;br&gt;称为箭头 &lt;equation&gt;f&lt;/equation&gt; 的&lt;b&gt;定义域&lt;/b&gt;（domain）和&lt;b&gt;值域&lt;/b&gt;（codomain）。&lt;/p&gt;&lt;p&gt;并且，还要满足以下几条规则，&lt;br&gt;（1）对于每一个对象 &lt;equation&gt;a&lt;/equation&gt; ，存在&lt;b&gt;恒等箭头&lt;/b&gt;（identity arrow）， &lt;equation&gt;i:a\to a&lt;/equation&gt; &lt;br&gt;（2）箭头满足&lt;b&gt;结合律&lt;/b&gt;，对于任意的箭头 &lt;equation&gt;f,g,h&lt;/equation&gt; ，有 &lt;equation&gt;(f\cdot g)\cdot h=f\cdot (g\cdot h)&lt;/equation&gt; &lt;br&gt;（3）箭头的集合在箭头组合运算下是&lt;b&gt;封闭的&lt;/b&gt;&lt;/p&gt;&lt;p&gt;其中， &lt;equation&gt;f\cdot g&lt;/equation&gt; 表示 &lt;equation&gt;g&lt;/equation&gt; 和 &lt;equation&gt;f&lt;/equation&gt; 的组合运算，它也是一个箭头，其中 &lt;equation&gt;g&lt;/equation&gt; 的值域是 &lt;equation&gt;f&lt;/equation&gt; 的定义域。&lt;/p&gt;&lt;p&gt;例子：&lt;br&gt;所有的集合，以集合为对象，集合之间的映射作为箭头，构成了一个范畴，&lt;br&gt;所有的群，以群作为对象，群同态作为箭头，构成了一个范畴，&lt;br&gt;所有的拓扑空间，以拓扑空间作为对象，拓扑空间之间的连续映射为箭头，构成了一个范畴。&lt;/p&gt;&lt;p&gt;以上三个例子中，&lt;br&gt;范畴中的对象都是集合，箭头都是映射，这就很容易造成误解。&lt;br&gt;因为，&lt;b&gt;范畴中的对象可以不是集合，箭头也可以不是映射，&lt;br&gt;&lt;/b&gt;理解这一点至关重要。&lt;/p&gt;&lt;p&gt;例如，完全偏序 &lt;equation&gt;(D,\leqslant)&lt;/equation&gt; ，&lt;br&gt;以 &lt;equation&gt;D&lt;/equation&gt; 中的元素作为对象，以 &lt;equation&gt;x\leqslant y&lt;/equation&gt; 作为 &lt;equation&gt;x,y&lt;/equation&gt; 之间的箭头，同样构成了一个范畴。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 函子&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;函子就是两个范畴之间的箭头。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9a2d8a5e543c0e1e27695a353869dda1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;436&quot; data-rawheight=&quot;243&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;一个&lt;b&gt;函子&lt;/b&gt; &lt;equation&gt;F&lt;/equation&gt; 是范畴 &lt;equation&gt;C&lt;/equation&gt; 到范畴 &lt;equation&gt;D&lt;/equation&gt; 的箭头， &lt;equation&gt;F:C\to D&lt;/equation&gt; ，它满足以下条件，&lt;br&gt; &lt;equation&gt;F&lt;/equation&gt; 把 &lt;equation&gt;C&lt;/equation&gt; 中的对象 &lt;equation&gt;c&lt;/equation&gt; 映射为 &lt;equation&gt;D&lt;/equation&gt; 中的对象 &lt;equation&gt;F~c&lt;/equation&gt; ，把 &lt;equation&gt;C&lt;/equation&gt; 中的箭头 &lt;equation&gt;f&lt;/equation&gt; 映射为 &lt;equation&gt;D&lt;/equation&gt; 中的箭头 &lt;equation&gt;F~f&lt;/equation&gt; 。&lt;br&gt;并且， &lt;equation&gt;F~(f\cdot g)=(F~f)\cdot (F~g)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;值得注意的是，等式左边的 &lt;equation&gt;\cdot&lt;/equation&gt; ，表示 &lt;equation&gt;C&lt;/equation&gt; 中的箭头组合运算，&lt;br&gt;等式右边的 &lt;equation&gt;\cdot&lt;/equation&gt; ，表示D&lt;i&gt;D&lt;/i&gt;中的箭头组合运算。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4. 自然变换&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;自然变换&lt;/b&gt;（natural transformation）是&lt;b&gt;一族箭头&lt;/b&gt;，&lt;br&gt;将范畴 &lt;equation&gt;A&lt;/equation&gt; 在一个函子中的像（picture），变换成了另一个函子的像。&lt;/p&gt;&lt;p&gt;给定两个函子 &lt;equation&gt;S,T:A\to B&lt;/equation&gt; ，其中 &lt;equation&gt;A&lt;/equation&gt; 和 &lt;equation&gt;B&lt;/equation&gt; 是范畴。&lt;br&gt;自然变换的每个&lt;b&gt;分量&lt;/b&gt;（components）使下图可交换。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-eed0e9ebd54183d14091dd04da29d37f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;696&quot; data-rawheight=&quot;225&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中， &lt;equation&gt;\tau_a&lt;/equation&gt; 是 &lt;equation&gt;B&lt;/equation&gt; 中的箭头， &lt;equation&gt;\tau_a:Sa\to Ta&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;5. Monad&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;范畴到自身的函子，称为&lt;b&gt;自函子&lt;/b&gt;（endofunctor）。&lt;br&gt;设 &lt;equation&gt;T:X\to X&lt;/equation&gt; 是任意范畴 &lt;equation&gt;X&lt;/equation&gt; 上的自函子，自函子复合之后仍为自函子，&lt;br&gt; &lt;equation&gt;T^2=T\circ T:X\to X&lt;/equation&gt; ， &lt;equation&gt;T^3=T^2\circ T:X\to X&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;\mu:T^2\to T&lt;/equation&gt; 是一个自然变换，其分量为 &lt;equation&gt;\mu_x:T^2x\to Tx&lt;/equation&gt; ， &lt;equation&gt;\forall x\in X&lt;/equation&gt; ，&lt;br&gt;则使用 &lt;equation&gt;\mu&lt;/equation&gt; 可以定义另外两个自然变换，&lt;br&gt; &lt;equation&gt;T\mu:T^3\to T^2&lt;/equation&gt; ，它的分量为 &lt;equation&gt;(T\mu)_x=T(\mu_x):T^3x\to T^2x&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\mu T:T^3\to T^2&lt;/equation&gt; ，它的分量为 &lt;equation&gt;(\mu T)_x=\mu_{Tx}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;范畴 &lt;equation&gt;X&lt;/equation&gt; 上的一个&lt;b&gt;Monad&lt;/b&gt;，指的是三元组 &lt;equation&gt;\left \langle T,\eta,\mu \right \rangle&lt;/equation&gt; ，它们使下图可交换，&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b877301e440b9c0f78a488e7e0022833_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;732&quot; data-rawheight=&quot;194&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中， &lt;equation&gt;T:X\to X&lt;/equation&gt; 是范畴 &lt;equation&gt;X&lt;/equation&gt; 上的自函子， &lt;equation&gt;\eta:I_X\to T&lt;/equation&gt; ， &lt;equation&gt;\mu:T^2\to T&lt;/equation&gt; 是两个自然变换。&lt;/p&gt;&lt;p&gt;值得注意的是，Monad与幺半群的图示法是相似的，&lt;br&gt;只需要将幺半群定义中的 &lt;equation&gt;\times&lt;/equation&gt; ，改写成自函子的复合运算，&lt;br&gt;把单位集合 &lt;equation&gt;1&lt;/equation&gt; ，改写成单位自函子即可。&lt;/p&gt;&lt;p&gt;因此，我们说&lt;b&gt;Monad是自函子范畴上的一个幺半群&lt;/b&gt;。&lt;/p&gt;&lt;blockquote&gt;All told, a monad in X is just a monoid in the category of endofunctors of X, with product x replaced by composition of endofunctors and unit set by the identity endofunctor.&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;6. Hask范畴上的Monad&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果把Haskell语言中的类型作为对象，把类型之间的函数看做箭头，&lt;br&gt;则在函数复合运算下，构成了一个范畴，称为&lt;b&gt;Hask范畴&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;函子&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Haskell中类型类（type class）&lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt;的每一个实例，定义了Hask范畴中的一个函子。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class Functor (f :: * -&amp;gt; *) where
    fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;表示了函子作用在箭头上的结果。&lt;br&gt;作用在对象上，可以使用&lt;code class=&quot;inline&quot;&gt;pure :: a -&amp;gt; f a&lt;/code&gt;来表示。&lt;/p&gt;&lt;p&gt;在Haskell中，一个类型要成为&lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt;的实例，还要满足相应的“&lt;a href=&quot;https://wiki.haskell.org/Functor#Functor_Laws&quot;&gt;Functor Law&lt;/a&gt;”，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fmap id = id
fmap (f . g) = fmap f . fmap g&lt;/code&gt;&lt;p&gt;可以&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Category_theory#Functors&quot;&gt;证明&lt;/a&gt;，这些“Functor Law”刚好使&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;pure&lt;/code&gt;构成了范畴论意义上的函子。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Monad&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Haskell中类型类&lt;code class=&quot;inline&quot;&gt;Monad&lt;/code&gt;的每一个实例，定义了Hask范畴中的一个Monad。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class Functor m =&amp;gt; Monad m where
    return :: a -&amp;gt; m a
    (&amp;gt;&amp;gt;=)  :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b&lt;/code&gt;&lt;p&gt;在Haskell中，一个类型要成为&lt;code class=&quot;inline&quot;&gt;Monad&lt;/code&gt;的实例，还要满足相应的“&lt;a href=&quot;https://wiki.haskell.org/Monad#Monad_class&quot;&gt;Monad Law&lt;/a&gt;”，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;return a &amp;gt;&amp;gt;= k                  =  k a
m        &amp;gt;&amp;gt;= return             =  m
m        &amp;gt;&amp;gt;= (\x -&amp;gt; k x &amp;gt;&amp;gt;= h)  =  (m &amp;gt;&amp;gt;= k) &amp;gt;&amp;gt;= h&lt;/code&gt;&lt;p&gt;可以&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Category_theory#Monads&quot;&gt;证明&lt;/a&gt;，这些“Monad Law”刚好使&lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;=&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;return&lt;/code&gt;构成了范畴论意义上的Monad。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了范畴论相关的一些内容，&lt;br&gt;介绍了什么是&lt;b&gt;范畴&lt;/b&gt;，什么是&lt;b&gt;函子&lt;/b&gt;，什么是&lt;b&gt;自然变换&lt;/b&gt;，&lt;br&gt;这些都是理解笛卡尔闭范畴所必须的。&lt;/p&gt;&lt;p&gt;为了理解什么是范畴，我们列举了前一篇提到的群，拓扑空间，CPO作为例子，&lt;br&gt;还借用了Haskell中的Functor和Monad学习了Hask范畴。&lt;/p&gt;&lt;p&gt;下文我们将继续学习范畴论，&lt;br&gt;理解什么是笛卡尔闭范畴，以及如何用它解释简单类型 &lt;equation&gt;\lambda&lt;/equation&gt; 演算的语义。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Category_(mathematics)&quot;&gt;Category (mathematics)&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Category_theory&quot;&gt;Haskell/Category theory&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1823110/&quot;&gt;Categories for the Working Mathematician&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-04-04-35237925</guid>
<pubDate>Wed, 04 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>C++函数式实现BST、线段树(单点修改)（2）</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-02-35201534.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35201534&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-39ccb0ee296de0b726bb2f2c939ca101_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35114696&quot;&gt;C++函数式实现BST、线段树(单点修改)（1）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;上一次是之前写的BST，那么我们今天就来聊一聊线段树~单点修改的。&lt;/p&gt;&lt;p&gt;本篇前置知识：线段树(普通递归的写法，非zwk)&lt;/p&gt;&lt;p&gt;最好掌握但是不掌握也没什么很大关系只是后面有一段论述可能会看不懂而已的知识：主席树&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Part I：线段树复习&lt;/p&gt;&lt;p&gt;我觉得每个人的对于线段树的写法可能不一样，比如这样一个例题：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1754&quot;&gt;Problem - 1754&lt;/a&gt;&lt;/p&gt;&lt;p&gt;单点更新：给出两个数x y，代表把x位置的数更新为y (y&amp;gt;=0)&lt;/p&gt;&lt;p&gt;查询区间max值：给出两个数x y，求区间[x,y]上的最大值&lt;/p&gt;&lt;p&gt;一开始长度为n的数组会指定初始值。&lt;/p&gt;&lt;p&gt;那么关键就是三个函数：(node代表当前节点编号，le和ri代表当前node代表的区间，st就是线段树数组)&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;void init(int node,int le,int ri){
    if(le==ri)
        st[node]=GIVEN_VALUE //GIVEN_VALUE只表示这里的给定的初始值，并不是预定义的常量
    else{
        int m=(le+ri)&amp;gt;&amp;gt;1;
        init(node&amp;lt;&amp;lt;1,le,m);
        init(node&amp;lt;&amp;lt;1|1,m+1,ri);
        st[node]=max(st[node&amp;lt;&amp;lt;1],st[node&amp;lt;&amp;lt;1|1]);
    }
}

void update(int node,int le,int ri){
    if(le==ri)
        st[node]=y;
    else{
        int m=(le+ri)&amp;gt;&amp;gt;1;
        if(x&amp;lt;=m)
            update(node&amp;lt;&amp;lt;1,le,m);
        else
            update(node&amp;lt;&amp;lt;1|1,m+1,ri);
        st[node]=max(st[node&amp;lt;&amp;lt;1],st[node&amp;lt;&amp;lt;1|1]);
    }
}

int query(int node,int le,int ri){
    int m=(le+ri)&amp;gt;&amp;gt;1;
    if(x&amp;lt;=le&amp;amp;&amp;amp;ri&amp;lt;=y)
        return st[node];
    if(y&amp;lt;=m)
        return query(node&amp;lt;&amp;lt;1,le,m);
    if(x&amp;gt;m)
        return query(node&amp;lt;&amp;lt;1|1,m+1,ri);
    if(le&amp;lt;x||ri&amp;gt;y)
        return max(query(node&amp;lt;&amp;lt;1,le,m),query(node&amp;lt;&amp;lt;1|1,m+1,ri));
}&lt;/code&gt;&lt;p&gt;（好早之前写的代码了...但是逻辑应该还是很清楚的，注意update是单点更新）&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Part II: 函数式写法&lt;/p&gt;&lt;p&gt;(没有提交，只测了样例，应该是正确的，提交肯定过不了..)&lt;/p&gt;&lt;p&gt;(new完没有delete)&lt;/p&gt;&lt;p&gt;让我们首先定义Node结构体，同之前的BST是类似的，注意声明了一个全局的root变量&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;struct Node{
    int v;
    Node* le,*ri;
    explicit Node(int value=0,Node* lef=nullptr,Node* righ=nullptr):
        v(value),le(lef),ri(righ){}
}*root;&lt;/code&gt;&lt;p&gt;然后就是init函数&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;Node* init(int le,int ri){
    if(le==ri)
        return new Node(GIVEN_VALUE);
    else{
        int m=(le+ri)&amp;gt;&amp;gt;1;
        Node* lef=init(le,m),*rig = init(m+1,ri);
        return new Node(max(lef-&amp;gt;v,rig-&amp;gt;v),lef,rig);
    }
}&lt;/code&gt;&lt;p&gt;这里的le和ri代表当前节点代表的区间，因此一开始的调用是init(1,n)。假设le==ri，代表当前已经走到叶子节点了，则直接返回，否则分别init完左右子之后再返回自身节点。&lt;/p&gt;&lt;p&gt;然后就是update函数：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;Node* update(Node* st,int le,int ri){
    if(le==ri)
        return new Node(y);
    else{
        int m=(le+ri)&amp;gt;&amp;gt;1;
        Node* tmp;
        if(x&amp;lt;=m){
            tmp=update(st-&amp;gt;le,le,m);
            return new Node(max(tmp-&amp;gt;v,st-&amp;gt;ri-&amp;gt;v),tmp,st-&amp;gt;ri);
        }else{
            tmp=update(st-&amp;gt;ri,m+1,ri);
            return new Node(max(tmp-&amp;gt;v,st-&amp;gt;le-&amp;gt;v),st-&amp;gt;le,tmp);
        }
    }
}&lt;/code&gt;&lt;p&gt;注意这里是单点更新..即更新的区间是[x,x]，因此只要考虑x&amp;lt;=m和x&amp;gt;m的情况即可。同BST类似，这一下又会开创出一条新链出来，即从root节点到最终的叶子节点是一条新链，然后这条链有链向原来的节点。这个过程基本和之前BST是一样的，就不画图了，而且鼠绘完全二叉树好难......，相比BST只是多了一个更新自身的值的操作而已。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Part III：主席树&lt;/p&gt;&lt;p&gt;在BST中，我们最外层调用bst_insert是这样调用的&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;root=bst_insert(rand()%100,root);&lt;/code&gt;&lt;p&gt;同理，我们这里最外层调用update&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;root=update(root,1,n);&lt;/code&gt;&lt;p&gt;但是，假如我们这里不把root的值覆盖掉，而是把root声明为一个数组，比如说这样&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;int size=0;
root[size++]=init(1,n);&lt;/code&gt;&lt;p&gt;我们每一次都这样更新&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;root[size+1]=update(root[size],1,n);
++size;&lt;/code&gt;&lt;p&gt;这里的意思就是，我们把单点更新之后的线段树，即仅仅有着一条新链，但是其余节点仍然指向上一棵线段树的节点的线段树的根节点保存起来。这也就意味着，我们做了m次操作之后，root里面会有m+1棵线段树(初始有1棵)。对于相邻两棵线段树来说，后面一棵仅仅和之前的一棵有一条链是不一样的而已，后面一棵其余的节点是仍然指向前面那一棵的，换而言之，后面一棵的非新链上的节点是和前面一棵公用的。&lt;/p&gt;&lt;p&gt;这样做有什么好处？&lt;/p&gt;&lt;p&gt;一个显而易见的好处就是我们现在能够查询历史版本了，比如说，询问在第k次修改之后的区间[x,y]上的最大值，因为对于每一次修改之后的线段树的root节点我们都保存在了数组里面，因此便直接调用&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;query(root[k],1,n)&lt;/code&gt;&lt;p&gt;即可。注意此处适用于单点修改，区间修改需要打lazy tag，我还需要仔细想一想。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么最后再来一个例题讲解 &lt;a href=&quot;http://poj.org/problem?id=2104&quot;&gt;2104 -- K-th Number&lt;/a&gt;&lt;/p&gt;&lt;p&gt;题意是给出 n和m，n是数组长度，m是操作次数，n为100,000，m为5000&lt;/p&gt;&lt;p&gt;每一次操作给出三个数x y k询问区间[x,y]上第k小的数&lt;/p&gt;&lt;p&gt;首先考虑简单情况，如何用线段树解决询问区间[1,n]上的第k小的数。&lt;/p&gt;&lt;p&gt;假设数组元素的数据范围是[1,100]，那么我们开一个至少有100个叶子节点的线段树，线段树的节点维护当前区间数字出现次数之和，每来一个数v，就对区间[v,v]进行+1操作。查询时先看左子树的次数之和left_sum是否超过k，若超过，进入左子树查询，否则进入右子树查询第k-left_sum小的数。&lt;/p&gt;&lt;p&gt;但是现在元素的数据范围是1e9太大了，因为n最多只有100,000，离散化即可。&lt;/p&gt;&lt;p&gt;我们解决了对于整个数组查询第k小的问题，接下来解决区间查询&lt;/p&gt;&lt;p&gt;注意到区间数字出现次数之和可以用前缀和来维护，即对于任意一个区间[x,y]&lt;/p&gt;&lt;p&gt;[x,y]中的数字出现次数之和等于 [1,y]中数字出现次数之和 - [1,x-1]中数字出现次数之和&lt;/p&gt;&lt;p&gt;这也就意味着我们只需要n棵线段树就能求出任意一个区间的数字出现次数之和，这n棵线段树对应着区间[1,1]、[1,2]、[1,3]、......、[1,n]。&lt;/p&gt;&lt;p&gt;对于查询任意一个区间[x,y]，我们只要拿对应[1,y]线段树上节点的值减掉[1,x-1]线段树上对应节点的值即可。&lt;/p&gt;&lt;p&gt;最后看这n个线段树有什么性质&lt;/p&gt;&lt;p&gt;对于相邻两个线段树，即[1,i]和[1,i+1]，相当于把源数组的第i+1个元素，无妨说是a，在[1,i]线段树上对区间[a,a]进行了+1操作，即，满足我们上面所说的，相邻两棵线段树只有一条链是不一样的。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Part IV：&lt;/p&gt;&lt;p&gt;函数式实现线段树代码：&lt;a href=&quot;https://github.com/Hatsunespica/CL/blob/master/Melange/segmentTree.cpp&quot;&gt;https://github.com/Hatsunespica/CL/blob/master/Melange/segmentTree.cpp&lt;/a&gt;&lt;/p&gt;&lt;p&gt;有关于例题的k-number的AC代码可以参看我的回答，我的回答只有两个...&lt;/p&gt;&lt;p&gt;写了很多，若有错误，还请指正。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Spica</author>
<guid isPermaLink="false">2018-04-02-35201534</guid>
<pubDate>Mon, 02 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Programming Languages: Application and Interpretation【译15下】</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-02-35198525.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35198525&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b71b632ed7974538bb2e812bcd20914e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;初翻： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/9bebf466fc2535bec442451dca7cd13a&quot; data-hash=&quot;9bebf466fc2535bec442451dca7cd13a&quot; data-hovercard=&quot;p$b$9bebf466fc2535bec442451dca7cd13a&quot;&gt;@lotuc&lt;/a&gt; &lt;/p&gt;&lt;p&gt;原文：&lt;a href=&quot;http://cs.brown.edu/courses/cs173/2012/book/index.html&quot;&gt;PLAI 第二版&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/lotuc/PLAI-cn&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;GitBook：&lt;a href=&quot;https://lotuc.gitbooks.io/plai-cn/content/&quot;&gt;PLAI-cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;翻译声明见 Github 仓库&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;15.3.3 联合类型&lt;/h2&gt;&lt;p&gt;假设我们要建立动物园动物的链表，动物有这些种类：犰狳、红尾蚺等。目前，我们必须创建新的数据类型：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type Animal
  [armadillo (alive? : boolean)] ;犰狳
  [boa (length : number)]) ;蚺&lt;/code&gt;&lt;blockquote&gt;“在德州，马路中间除了黄线和死掉的犰狳什么都没有。” —— Jim Hightower&lt;/blockquote&gt;&lt;p&gt;然后创建它的链表：&lt;code class=&quot;inline&quot;&gt;(listof Animal)&lt;/code&gt;。因此，&lt;code class=&quot;inline&quot;&gt;Animal&lt;/code&gt;类型表示的是&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;的“联合（或称联合体，union）”，不过要创建这种联合的唯一方式是每次都创建新类型：比如要创建动物和植物的联合，就需要：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type LivingThings
  [animal (a : Animal)]
  [plant (p : Plant)])&lt;/code&gt;&lt;p&gt;这样实际的动物现在裹在了更深一“层”。这些类型被称为&lt;b&gt;带标签的联合&lt;/b&gt;（tagged union）或&lt;b&gt;可辨识的联合&lt;/b&gt;（discriminated union），因为我们需要显式引入类似&lt;code class=&quot;inline&quot;&gt;animal&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;plant&lt;/code&gt;的标签（或称&lt;b&gt;辨识符&lt;/b&gt;(discriminator)）来区分它们。相应地，结构体只能通过数据类型声明来定义；要创建只包含一种变体的数据结构，如&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type Constraints
  [eqCon (lhs : Term) (rhs : Term)])&lt;/code&gt;&lt;p&gt;来表示该数据结构，我们需要使用类型&lt;code class=&quot;inline&quot;&gt;Constraints&lt;/code&gt;而不是&lt;code class=&quot;inline&quot;&gt;eqCons&lt;/code&gt;，因为&lt;code class=&quot;inline&quot;&gt;eqCons&lt;/code&gt;不是类型，只是能在运行时区分的类型变体。&lt;/p&gt;&lt;p&gt;无论哪种方式，联合类型的要点是表示析取或“或”。值的类型是联合中某个类型。值通常只能是联合中某个特定的类型，不过这取决于联合类型的精确定义、规范它们的规则等等。&lt;/p&gt;&lt;h2&gt;15.3.3.1 作为类型的结构体&lt;/h2&gt;&lt;p&gt;对此自然的反应可能是，为什么不移除这种限制？为什么不允许每个结构体独立存在，将类型定义为一些结构体的集合？毕竟，不管是C还是Racket，程序员都可以定义独立的结构体，无需使用标签构造函数将它们包裹在其它类型里！例如，Racket里可以写：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(struct armadillo (alive?))
(struct boa (length))&lt;/code&gt;&lt;p&gt;加个注释：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;;; 动物是下面两者之一：
;; - (armadillo &amp;lt;boolean&amp;gt;)
;; - (boa &amp;lt;number&amp;gt;)&lt;/code&gt;&lt;p&gt;但是由于Racket不强制静态类型，这种比较不太清楚。然而，我们可以和 &lt;i&gt;Typed Racket&lt;/i&gt; （内置与DrRacket中的静态类型Racket）相比较。下面是对应的静态类型代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#lang typed/racket
 
(struct: armadillo ([alive? : Boolean]))
(struct: boa ([length : Real])) ;; feet&lt;/code&gt;&lt;p&gt;无需引用&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;就可以定义使用&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;类型值的函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;;; http://en.wikipedia.org/wiki/Boa_constrictor#Size_and_weight
(define: (big-one? [b : boa]) : Boolean
  (&amp;gt; (boa-length b) 8))&lt;/code&gt;&lt;p&gt;事实上，如果调用此函数时传入其它类型，如&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;——&lt;code class=&quot;inline&quot;&gt;(big-one? (armadillo true))&lt;/code&gt;——将发生&lt;b&gt;静态&lt;/b&gt;错误。因为&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;之间的关系等同与数和字符串之间的关系。&lt;/p&gt;&lt;p&gt;当然，我们仍可以定义这些类型的联合：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type Animal (U armadillo boa))&lt;/code&gt;&lt;p&gt;在这之上定义函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define: (safe-to-transport? [a : Animal]) : Boolean
  (cond
    [(boa? a) (not (big-one? a))]
    [(armadillo? a) (armadillo-alive? a)]))&lt;/code&gt;&lt;p&gt;之前我们有&lt;b&gt;一种包含两个变体的类型&lt;/b&gt;，现在则有&lt;b&gt;三种类型&lt;/b&gt;，其中两种类型恰巧能方便的通过联合定义第三种。&lt;/p&gt;&lt;h2&gt;15.3.3.2 无标签联合&lt;/h2&gt;&lt;p&gt;看起来我们好像还需要辨识标签，但并非如此。在支持联合类型的语言中，通常这样获取类型构造器&lt;code class=&quot;inline&quot;&gt;optionof&lt;/code&gt;：将期望的返回类型和用于表示失败或者&lt;code class=&quot;inline&quot;&gt;none&lt;/code&gt;的类型结合起来。例如，下面是&lt;code class=&quot;inline&quot;&gt;(optionof number)&lt;/code&gt;的等价实现：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type MaybeNumber (U Number Boolean))&lt;/code&gt;&lt;p&gt;同时，&lt;code class=&quot;inline&quot;&gt;Boolean&lt;/code&gt;本身也可以是&lt;code class=&quot;inline&quot;&gt;True&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;False&lt;/code&gt;的联合，在Typed Racket中也确实如此。因此，选择（option）类型更为准确的模拟实现应该是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type MaybeNumber (U Number False))&lt;/code&gt;&lt;p&gt;更为一般的，可以定义：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(struct: none ())
(define-type (Maybeof T) (U T none))&lt;/code&gt;&lt;p&gt;由于由于&lt;code class=&quot;inline&quot;&gt;none&lt;/code&gt;是新的、独特的类型，不会和其它类型混淆，因此该定义适用于所有类型。它提供给我们与选择类型相同的好处，且我们的值没有被埋入深一层的&lt;code class=&quot;inline&quot;&gt;some&lt;/code&gt;结构体，而是立即可用。例如&lt;code class=&quot;inline&quot;&gt;member&lt;/code&gt;，其Typed Racket中的类型是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(All (a) (a (Listof a) -&amp;gt; (U False (Listof a))))&lt;/code&gt;&lt;p&gt;如果元素未找到，&lt;code class=&quot;inline&quot;&gt;member&lt;/code&gt;返回&lt;code class=&quot;inline&quot;&gt;false&lt;/code&gt;；否则，它将返回从该元素开始的链表（即，链表的第一个元素是期望的元素）。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (member 2 (list 1 2 3))
&#39;(2 3)&lt;/code&gt;&lt;p&gt;将其转换为使用&lt;code class=&quot;inline&quot;&gt;Maybeof&lt;/code&gt;实现，可以写成：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define: (t) (in-list? [e : t] [l : (Listof t)]) : (Maybeof (Listof t))
  (let ([v [member e l]])
    (if v
        v
        (none))))&lt;/code&gt;&lt;p&gt;如果元素未找到，它将返回值&lt;code class=&quot;inline&quot;&gt;(none)&lt;/code&gt;；如果找到了，仍然是返回链表：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (in-list? 2 (list 1 2 3))
&#39;(2 3)&lt;/code&gt;&lt;p&gt;这样就无需从&lt;code class=&quot;inline&quot;&gt;some&lt;/code&gt;容器中取出链表。&lt;/p&gt;&lt;h2&gt;15.3.3.3 辨识无标签联合&lt;/h2&gt;&lt;p&gt;将值放入联合是一码事；我们还需要考虑如何以类型良好的方式将值从其中取出来。在我们的类ML类型系统中，我们使用程式化的符号——我们的语言中&lt;code class=&quot;inline&quot;&gt;type-case&lt;/code&gt;，ML中的模式匹配——来标识和取出各部分。具体来说，对于代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define (safe-to-transport? [a : Animal]) : boolean
  (type-case Animal a
             [armadillo (a?) a?]
             [boa (l) (not (big-one? l))]))&lt;/code&gt;&lt;p&gt;在整个表达式中&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的类型保持一致。标识符&lt;code class=&quot;inline&quot;&gt;a?&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;l&lt;/code&gt;分别被绑定到布尔类型和数类型的值上，&lt;code class=&quot;inline&quot;&gt;big-one?&lt;/code&gt;接收的就是这些类型，而不是&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;。换句话说，&lt;code class=&quot;inline&quot;&gt;big-one?&lt;/code&gt;函数的输入类型不可以是&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;，因为根本没有这样的类型。&lt;/p&gt;&lt;p&gt;反之，使用联合类型的话，我们确实有&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;类型。因此，我们遵守对值进行谓词操作将&lt;b&gt;缩小其类型&lt;/b&gt;的原则。例如，在&lt;code class=&quot;inline&quot;&gt;cond&lt;/code&gt;的子句&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;[(boa? a) (not (big-one? a))]&lt;/code&gt;&lt;p&gt;中，尽管&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的初始类型为&lt;code class=&quot;inline&quot;&gt;Animal&lt;/code&gt;，在通过&lt;code class=&quot;inline&quot;&gt;boa?&lt;/code&gt;测试后，类型检查器会将其类型缩小到&lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;的分支，这样&lt;code class=&quot;inline&quot;&gt;big-one?&lt;/code&gt;调用得以通过类型检查。反过来，其在条件表达式剩余部分的类型&lt;b&gt;不是&lt;/b&gt; &lt;code class=&quot;inline&quot;&gt;boa&lt;/code&gt;——这里，只剩下&lt;code class=&quot;inline&quot;&gt;armadillo&lt;/code&gt;一种可能。这给类型检查器提出了更高的要求，它需要能测试并识别特定模式（称为&lt;b&gt;条件分割&lt;/b&gt;(if-splitting)）；缺了这种能力就无法使用联合类型编程；当然我们可以只识别类ML系统中能识别的模式，也就是模式匹配、&lt;code class=&quot;inline&quot;&gt;type-case&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;15.3.3.4 改造为静态类型&lt;/h2&gt;&lt;p&gt;毫不奇怪，Typed Racket使用联合类型。当将现有语言改造为静态类型时，它们尤其有用，因为现有语言（如脚本语言中）的程序没有用类ML类型系统的原则来定义。这种类型改造的通用的原则之一是尽可能多地静态捕获动态异常。当然，检查器最终会让一些程序无法通过检查【注释】，但如果它拒绝太多可以无错运行的程序，开发者不太可能采用它。由于这些程序是在没有考虑类型检查的情况下编写的，因此类型检查器需要以更为激进的方式接受该语言中被认为合理的习惯用法。&lt;/p&gt;&lt;blockquote&gt;除非它实现了称为&lt;b&gt;软类型&lt;/b&gt;（soft typing）的有趣想法：不拒绝任何程序，而是提供信息告知程序中无法通过类型检查之处。&lt;/blockquote&gt;&lt;p&gt;考虑下面的JavaScript函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;var slice = function (arr, start, stop) {
  var result = [];
  for (var i = 0; i &amp;lt;= stop - start; i++) {
      result[i] = arr[start + i];
  }
  return result;
}&lt;/code&gt;&lt;p&gt;它读入一个数组和两个索引，返回这两个索引之间的子数组。例如，&lt;code class=&quot;inline&quot;&gt;slice([5, 7, 11, 13], 0, 2)&lt;/code&gt;求得&lt;code class=&quot;inline&quot;&gt;[5, 7, 11]&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在JavaScript中，开发人员在函数调用时可以自由的省略任意或者所有尾部参数。每个被省略的参数都被赋予特定值&lt;code class=&quot;inline&quot;&gt;undefined&lt;/code&gt;，如何处理这种情形完全由函数决定。例如，&lt;code class=&quot;inline&quot;&gt;slice&lt;/code&gt;的典型实现允许用户省略最后一个参数；下面的定义&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;var slice = function (arr, start, stop) {
  if (typeof stop == &quot;undefined&quot;)
    stop = arr.length - 1;
  var result = [];
  for (var i = 0; i &amp;lt;= stop - start; i++) {
    result[i] = arr[start + i];
  }
  return result;
}&lt;/code&gt;&lt;p&gt;在未给定第三个参数时自动返回到数组结尾的子数组：因此&lt;code class=&quot;inline&quot;&gt;slice([5, 7, 11, 13], 2)&lt;/code&gt;返回&lt;code class=&quot;inline&quot;&gt;[11, 13]&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在Typed JavaScript【注释】中，程序员可以通过为给定参数指定类型&lt;code class=&quot;inline&quot;&gt;U Undefined&lt;/code&gt;来显式地指明函数可以接受更少的参数，此函数的类型如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;∀ t : (Array[t] * Int * (Int U Undefined) -&amp;gt; Array[t])&lt;/code&gt;&lt;blockquote&gt;由Arjun Guha等人在布朗（大学）创建。参见&lt;a href=&quot;http://www.jswebtools.org/&quot;&gt;我们的网站&lt;/a&gt;。&lt;/blockquote&gt;&lt;p&gt;原则上，这意味着表达式&lt;code class=&quot;inline&quot;&gt;stop - start&lt;/code&gt;存在发生类型错误的可能，因为&lt;code class=&quot;inline&quot;&gt;stop&lt;/code&gt;可能不是数。然而，当用户省略该参数时，对&lt;code class=&quot;inline&quot;&gt;stop&lt;/code&gt;的赋值正好将其设为数类型。换句话说，在所有控制路径上，减法发生前&lt;code class=&quot;inline&quot;&gt;stop&lt;/code&gt;都将是数类型，因此该函数能通过类型检查。当然，这要求类型检查器能够对控制流（条件）和状态（赋值）进行推断来确保函数类型正确；而Typed JavaScript可以做到，也因此能允许这样的函数。&lt;/p&gt;&lt;h2&gt;15.3.3.4 设计选择&lt;/h2&gt;&lt;p&gt;拥有联合类型的语言中，通常有&lt;/p&gt;&lt;ul&gt;&lt;li&gt;独立的结构体类型（通常用类表示），而不是带有变体的数据类型。&lt;/li&gt;&lt;li&gt;用于表示特定类型的特殊（ad hoc）结构体集合。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sentinel_value&quot;&gt;哨兵值（sentinel value）&lt;/a&gt;表示失败。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;将这种风格的程序转换成满足类ML类型风格的非常费事。因此，许多改造过来的类型系统引入联合类型来减轻类型化过程的负担。&lt;/p&gt;&lt;p&gt;上述三个属性中，第一个相对中立，但是其它两个需要更多讨论。我们以反序依次解决它们。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先处理哨兵值。很多情况下，哨兵应该被替换为异常，但是在很多语言中，抛出异常的代价巨大。因此开发者倾向于区分真正的异常情况——不应该发生——和正常运行中的预期情况。检查元素是否属于链表发现不存在的情况显然属于后者（如果我们已经知道元素是否存在，这个谓词判断就无需进行）。在后一种情况下，使用哨兵是合理的。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;然而，我们需要认识到，在C程序中，未能检测异常的哨兵值是错误——甚至安全缺陷——的常见原因。这点很容易解决。在C中，哨兵值和普通返回值&lt;b&gt;类型相同&lt;/b&gt;（或者至少等同于类型相同），而且运行时也没有检查。因此哨兵可以被当作合法的值使用，且不会出现类型错误。这就导致哨兵值&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;可以被当作分配数据的地址来使用，从而导致系统崩溃。与之不同，我们的哨兵是真正意义上的新类型，无法用于任何计算。观察到前语言中没有任何函数的输入类型为&lt;code class=&quot;inline&quot;&gt;none&lt;/code&gt;，可以推理出这点。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;先忽略这里贬义的“特殊”一词，对一组结构体进行不同的分组是否是个好主意？实际上，就算在遵循类ML规范的程序中，当程序员希望刻画一个大宇宙的子宇宙时，也会出现这种分组的情形。例如，ML程序员会使用下面的类型&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;(define-type SExp&lt;br&gt;  [numSexp (n : number)]&lt;br&gt;  [strSexp (s : string)]&lt;br&gt;  [listSexp (l : (listof SExp))])&lt;/p&gt;&lt;blockquote&gt;表示s-expression。如果有函数希望操作这些项的某个子集，比如数和数的链表，就必须创建新的类型，然后将值在两种类型之间转换，尽管这两个类型的内部表示完全相同。另一个例子，考虑CPS表达式的集合，这显然是所有可能表达式的一个子集，但如果不得不为其创建新的类型，我们将无法对其使用任何已有的表达式处理程序，比如解释器。&lt;/blockquote&gt;&lt;p&gt;换种说法，联合类型似乎是我们之前见到的ML风格类型系统的合理变种。但是，即使在联合类型中仍有设计选择，它们都有其后果。例如，允许类型系统创建新联合类型吗？允许用户定义（和命名）联合吗？也就是说，允许表达式&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(if (phase-of-the-moon)
    10
    true)&lt;/code&gt;&lt;p&gt;通过类型检查吗（将创建类型&lt;code class=&quot;inline&quot;&gt;(U Number Boolean)&lt;/code&gt;），还是由于其引入了之前未命名并显式标识的类型而将其判定为类型错误？Typed Racket提供的是前者：它将创建真正的临时联合。对于给现有代码引入类型来说，这么做可能更好，因为它更加灵活。但对于写新代码来说，这是否是个好的设计还并不清楚，因为并非程序员期望内的联合会出现，而且无法避免。这给程序语言的设计空间提供了一个未被探索的角落。&lt;/p&gt;&lt;h2&gt;15.3.4 名义类型系统与结构类型系统&lt;/h2&gt;&lt;p&gt;我们最初的类型检查器中，如果两个类型具有相同的结构，则认为它们是相同的。事实上我们根本没有提供类型的命名机制，因此不清楚有何替代方案。&lt;/p&gt;&lt;p&gt;现在考虑Typed Racket。程序员可以写&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define-type NB1 (U Number Boolean))
(define-type NB2 (U Number Boolean))&lt;/code&gt;&lt;p&gt;然后写&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define: v : NB1 5)&lt;/code&gt;&lt;p&gt;假设还定义了函数&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(define: (f [x : NB2]) : NB2 x)&lt;/code&gt;&lt;p&gt;然后用&lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt;调用&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;，即&lt;code class=&quot;inline&quot;&gt;(f v)&lt;/code&gt;：该调用应该通过类型检查吗？&lt;/p&gt;&lt;p&gt;有两种完全合理的解释。一种是说&lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt;被声明为类型&lt;code class=&quot;inline&quot;&gt;NB1&lt;/code&gt;，与&lt;code class=&quot;inline&quot;&gt;NB2&lt;/code&gt;&lt;b&gt;名称&lt;/b&gt;不同，因此应该被当作不同&lt;b&gt;类型&lt;/b&gt;，所以该调用应导致错误。这种系统被称为&lt;b&gt;名义的&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Nominal_type_system&quot;&gt;nominal&lt;/a&gt;），因为类型的名字对于确定类型是否相等极为重要。&lt;/p&gt;&lt;p&gt;与之对应，另一种解释是说因为&lt;code class=&quot;inline&quot;&gt;NB1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;NB2&lt;/code&gt;&lt;b&gt;结构&lt;/b&gt;相同，因此开发者无法写出在这两种类型的值上表现的不同的程序来，所以它们应该被视为相同。【注释】这种类型系统被称为&lt;b&gt;结构的&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Structural_type_system&quot;&gt;structural&lt;/a&gt;），将允许上面的程序通过检查。（Typed Racket遵循结构类型的规范，理由同样是减少导入现有动态类型代码的负担，这些Racket代码通常是以结构解释为模型编写的。事实上，Typed Racket中&lt;code class=&quot;inline&quot;&gt;(f v)&lt;/code&gt;不仅能通过类型检查，而且打印出的返回类型为&lt;code class=&quot;inline&quot;&gt;NB1&lt;/code&gt;，无视&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;返回值的类型注解！）&lt;/p&gt;&lt;blockquote&gt;如果特别小心，你会注意到被认为相同和实际相同之间是有区别的。这里不会涉及该问题，但请考虑编译器作者选择值的表示时其影响是啥，尤其在允许运行时获取值的静态类型的语言中。&lt;/blockquote&gt;&lt;p&gt;名义和结构类型之间的区别在面向对象语言中是最常见的争议，&lt;a href=&quot;https://github.com/lotuc/PLAI-cn/blob/master/chap15.md#1538-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B&quot;&gt;后面&lt;/a&gt;将简要回顾这个问题。然而，这里的重点是要说明这些问题本质上并不关乎“对象”。任何允许命名类型的语言——出于程序员精神健康的需要，也就是所有的语言了——都要应付此问题：命名只是方便起见，还是说所选的名字是被认为是有意义的？选择前者导致结构类型，选择后者导致名义类型。&lt;/p&gt;&lt;h2&gt;15.3.5 交叉类型&lt;/h2&gt;&lt;p&gt;我们刚探索了联合类型，很自然的就会想到有没有&lt;b&gt;交叉&lt;/b&gt;（intersection）类型呢。确实有。&lt;/p&gt;&lt;p&gt;如果联合类型指（该类型的）值属于这个联合中某个类型，交叉类型显然意味着该值属于交叉中的&lt;b&gt;所有&lt;/b&gt;类型：合取，或“且”。这可能看起来很奇怪：值怎么可能属于多种类型呢？&lt;/p&gt;&lt;p&gt;用具体例子回答，考虑&lt;b&gt;重载函数&lt;/b&gt;。例如，某些语言中&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;即可操作数，也能操作字符串；传入两个数它返回数，传入两个字符串它返回字符串。这种语言中，&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;的类型应该是什么呢？不是&lt;code class=&quot;inline&quot;&gt;(number number -&amp;gt; number)&lt;/code&gt;，因为那样它将不能用于字符串；同样的原因，也不是&lt;code class=&quot;inline&quot;&gt;(string string -&amp;gt; string)&lt;/code&gt;。甚至它也不是&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(U (number number -&amp;gt; number)
   (string string -&amp;gt; string))&lt;/code&gt;&lt;p&gt;因为&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;不仅仅是这些函数之一：实际上它（同时）是这两者。我们可以认为其类型是&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((number U string) (number U string) -&amp;gt; (number U string))&lt;/code&gt;&lt;p&gt;这说明它的每个参数和返回值都只能是这两种类型之一，而不同时为两者。但是，这样做会导致精度损失。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;这种类型以何种方式损失精度？&lt;/blockquote&gt;&lt;p&gt;观察到，对于这个类型，&lt;b&gt;所有&lt;/b&gt;函数调用的返回值类型均为&lt;code class=&quot;inline&quot;&gt;(number U string)&lt;/code&gt;。因此，对于每个返回值都必须区分数和字符串，不然我们将得到类型错误。所以，尽管我们知道给定两个数参数将返回数结果，但这种信息在类型系统中丢失了。&lt;/p&gt;&lt;p&gt;更巧妙的是，这个类型允许独立的选择每个参数的类型。因此，根据该类型，&lt;code class=&quot;inline&quot;&gt;(+ 3 &quot;x&quot;)&lt;/code&gt;也是合法的（且其返回值类型为&lt;code class=&quot;inline&quot;&gt;(number U string)&lt;/code&gt;）。但我们描述的加法操作当然没有对这组参数定义过！&lt;/p&gt;&lt;p&gt;因此描述这种加法的更为合适的类型是&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(^ (number number -&amp;gt; number)
   (string string -&amp;gt; string))&lt;/code&gt;&lt;p&gt;这里的&lt;code class=&quot;inline&quot;&gt;∧&lt;/code&gt;让人联想到逻辑上的合取操作符。这允许函数用两个数或者两个字符串进行调用，其它的则不允许。使用两个数调用返回数类型；使用两个字符串调用返回字符串类型；除此之外没有其它合法调用了。这刚好对应于我们期望的重载行为（有时也称为&lt;b&gt;特设多态&lt;/b&gt;(ad hoc polymorphism)）。请注意这只能处理有限数量重载的情况。&lt;/p&gt;&lt;h2&gt;15.3.6 递归类型&lt;/h2&gt;&lt;p&gt;学过联合类型之后，值得讨论一下我们原来遇到过的递归数据类型表达式。如果接受变体作为类型构造器，我们可以将递归类型写作它们的联合吗？例如就&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;来说，能否将它描述成等价于&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;((BTmt) U (BTnd number BTnum BTnum))&lt;/code&gt;&lt;p&gt;的类型吗，其中&lt;code class=&quot;inline&quot;&gt;BTmt&lt;/code&gt;是零参数的构造器，而&lt;code class=&quot;inline&quot;&gt;BTnd&lt;/code&gt;是三参数的？不过，这三个参数的类型是什么？按上面所写的类型，&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;要么是类型语言内建的（这不能令人满意），要么是未绑定的。也许我们要的是&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;BTnum = ((BTmt) U (BTnd number BTnum BTnum))&lt;/code&gt;&lt;p&gt;问题是这个方程没有明显解法（还记得&lt;code class=&quot;inline&quot;&gt;ω&lt;/code&gt;吗？）。&lt;/p&gt;&lt;p&gt;这种情况我们讨论&lt;a href=&quot;https://github.com/lotuc/PLAI-cn/blob/master/chap9.md#91-%E9%80%92%E5%BD%92%E4%B8%8E%E5%BE%AA%E7%8E%AF%E6%95%B0%E6%8D%AE&quot;&gt;值的递归&lt;/a&gt;时就熟悉过。那时，我们发明了递归函数构造器（并展示了其实现）来规避这个问题。这里我们同样需要递归类型构造器。按惯例它被称为&lt;code class=&quot;inline&quot;&gt;μ&lt;/code&gt;（希腊字母“缪”）。有了它，我们可以将上面的类型写做&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;μ BTnum : ((BTmt) U (BTnd number BTnum BTnum))&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;μ&lt;/code&gt;是绑定构造；它将&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;绑定到后面写的整个类型上，包括对&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;自身的递归绑定。实践中，整个递归类型就是我们希望得到的称为&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;的类型：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;BTnum = μ BTnum : ((BTmt) U (BTnd number BTnum BTnum))&lt;/code&gt;&lt;p&gt;尽管这看起来像是循环定义，但请注意，右侧的&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;不依赖于等式左侧的那个：即，我们可以将其重写为&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;BTnum = μ T : ((BTmt) U (BTnd number T T))&lt;/code&gt;&lt;p&gt;换句话说，&lt;code class=&quot;inline&quot;&gt;BTnum&lt;/code&gt;的这个定义可以被认为是语法糖，可以在程序的各个地方替换使用，无需担心无限回归的问题。&lt;/p&gt;&lt;p&gt;语义层面上，对&lt;code class=&quot;inline&quot;&gt;μ&lt;/code&gt;绑定的类型的意义有两种截然不同的思考方式：它们可以被解释为&lt;b&gt;同构递归&lt;/b&gt;（isorecursive）或&lt;b&gt;等价递归&lt;/b&gt;（equirecursive）。然而其中区别很微妙，超出了本章范围。【注释】只需理解递归类型可以被视为等同于它的展开。例如，我们定义数的链表类型为&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;NumL = μ T : ((MtL) U (ConsL number T))&lt;/code&gt;&lt;p&gt;于是有&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;μ T : ((MtL) U (ConsL number T))
= (MtL) U (ConsL number (μ T : ((MtL) U (ConsL number T))))
= (MtL) U (ConsL number (MtL))
        U (ConsL number (ConsL number (μ T : ((MtL) U (ConsL number T)))))&lt;/code&gt;&lt;p&gt;以此类推（同构和等价递归之间的区别正是在相等性的概念上：是定义上的相等性还是同构意义上的）。每一步中，我们将参数&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;替换成整个类型。和值的递归一样，它的意思是需要时我们可以“获得另一个”&lt;code class=&quot;inline&quot;&gt;ConsL&lt;/code&gt;构造。换种说法，链表的&lt;b&gt;类型&lt;/b&gt;可以写成零或任意多元素的联合；这等价于包含零个、一个或任意个元素的&lt;b&gt;类型&lt;/b&gt;；以此类推。任何数的链表都（恰好）符合这些类型。&lt;/p&gt;&lt;blockquote&gt;Pierce的书中对此解释的非常好。&lt;/blockquote&gt;&lt;p&gt;注意到，即使基于对于&lt;code class=&quot;inline&quot;&gt;μ&lt;/code&gt;的这种非正式理解，我们已经可以给&lt;code class=&quot;inline&quot;&gt;ω&lt;/code&gt;进而&lt;code class=&quot;inline&quot;&gt;Ω&lt;/code&gt;提供类型。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;描述&lt;code class=&quot;inline&quot;&gt;ω&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;Ω&lt;/code&gt;的类型。&lt;/blockquote&gt;&lt;h2&gt;15.3.7 子类型&lt;/h2&gt;&lt;p&gt;假设我们有一个典型的二叉树定义；简单起见，我们假设值为数。为了说明问题，我们用Typed Racket写：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#lang typed/racket

(define-struct: mt ())
(define-struct: nd ([v : Number] [l : BT] [r : BT]))
(define-type BT (U mt nd))&lt;/code&gt;&lt;p&gt;考虑二叉树具体的值：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;gt; (mt)
- : mt
#&amp;lt;mt&amp;gt;
&amp;gt; (nd 5 (mt) (mt))
- : nd
#&amp;lt;nd&amp;gt;&lt;/code&gt;&lt;p&gt;请注意，每个结构体构造器构造出自己对应类型的值，而不是&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;类型的值。但是考虑&lt;code class=&quot;inline&quot;&gt;(nd 5 (mt) (mt))&lt;/code&gt;：&lt;code class=&quot;inline&quot;&gt;nd&lt;/code&gt;的定义表明其子树必须为&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;类型，但我们可以传给它&lt;code class=&quot;inline&quot;&gt;mt&lt;/code&gt;类型的值。&lt;/p&gt;&lt;p&gt;显然，使用&lt;code class=&quot;inline&quot;&gt;mt&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;nd&lt;/code&gt;来定义&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;并不是巧合。但是，它确实表明在进行类型检查时，不能只检查构造函数的相等性，至少我们目前所做的不够。相反，我们必须检查一种类型“适用于”另一种。这种行为被称为&lt;b&gt;子类型化&lt;/b&gt;（subtyping）。&lt;/p&gt;&lt;p&gt;子类型化的本质是定义一种关系，通常用&lt;code class=&quot;inline&quot;&gt;&amp;lt;:&lt;/code&gt;表示，将一对类型关联起来。在期待类型&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的位置，如果放入类型&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的值也成立，那么我们就称&lt;code class=&quot;inline&quot;&gt;S &amp;lt;: T&lt;/code&gt;：换句话说，子类型化将&lt;b&gt;可替代性&lt;/b&gt;的概念（即，任何期望类型&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的值的地方，都可以被替换成类型为&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的值）形式化。当这种关系成立时，&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;被称作&lt;b&gt;子类型&lt;/b&gt;（subtype），&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;被称作&lt;b&gt;超类型&lt;/b&gt;（supertype）。使用子集去解释这点是很有用的（通常也是准确的）：如果&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的值是&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的子集，那么期望接受&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;值的表达式收到&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;值时不会出问题。&lt;/p&gt;&lt;p&gt;子类型化对类型系统有着深远影响。我们必须审视每一种类型，并理解它和子类型化之间的相互作用。对于基本类型，这通常比较明显：数、字符串等不相交的类型，彼此无关。（存在一些语言，使用某基本类型表示其它的基本类型——例如，某些脚本语言中，数只不过是特殊写法的字符串，还有些语言中，布尔值就是数——这些语言中，基本类型之间也可能存在子类型关系，但是这并不常见。）但是，我们必须考虑子类型化和每个复合类型构造器之间的关系。&lt;/p&gt;&lt;p&gt;事实上，甚至我们关于类型的表述也需要改变。假设我们有个类型为&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的表达式。通常我们会说它产生类型为&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的值。现在，我们需要小心的说，它产出&lt;b&gt;最多为&lt;/b&gt;&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的值，因为它可能只产出&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的某个子类型的值。因此，每个对类型的引用都隐含地涉及可能的子类型引用。为避免烦恼我会控制不这么做，但要小心，忽略这种隐含的解释可能导致推理错误。&lt;/p&gt;&lt;h2&gt;15.3.7.1 联合&lt;/h2&gt;&lt;p&gt;我们来讨论联合和子类型化会发生什么相互作用。显然，每个子联合是整个联合的子类型。在我们所用的例子中，显然每个&lt;code class=&quot;inline&quot;&gt;mt&lt;/code&gt;值都是&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;值；这同样适用于&lt;code class=&quot;inline&quot;&gt;nd&lt;/code&gt;。因而，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;mt &amp;lt;: BT
nd &amp;lt;: BT&lt;/code&gt;&lt;p&gt;于是，&lt;code class=&quot;inline&quot;&gt;(mt)&lt;/code&gt;也是&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;类型的，因此表达式&lt;code class=&quot;inline&quot;&gt;(nd 5 (mt) (mt))&lt;/code&gt;类型正确，就是&lt;code class=&quot;inline&quot;&gt;nd&lt;/code&gt;——因此也是&lt;code class=&quot;inline&quot;&gt;BT&lt;/code&gt;类型。一般来说，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;S &amp;lt;: (S U T)
T &amp;lt;: (S U T)&lt;/code&gt;&lt;p&gt;（我们写了两个看上去差不多的的规则，这是为了明确说明子类型处在联合中的哪“一边”并不重要）。它的意思是，&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的值可以被认为是&lt;code class=&quot;inline&quot;&gt;S U T&lt;/code&gt;的值，因为任何&lt;code class=&quot;inline&quot;&gt;S U T&lt;/code&gt;类型的表达式都确实可以包含&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;类型的值。&lt;/p&gt;&lt;h2&gt;15.3.7.2 交叉&lt;/h2&gt;&lt;p&gt;既然到了这里，我们也简要的讨论一下交叉。正如你可能想象的那样，交叉的行为是对偶的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(S ∧ T) &amp;lt;: S
(S ∧ T) &amp;lt;: T&lt;/code&gt;&lt;p&gt;为了说明这点，使用子集的解释：如果值即是&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;也是&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;，显然，它可以是两者中的任意一个。&lt;/p&gt;&lt;p&gt;&lt;b&gt;思考题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;为什么下面两条假设&lt;b&gt;不&lt;/b&gt;成立？&lt;/blockquote&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;(S U T) &amp;lt;: S&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;T &amp;lt;: (S ∧ T)&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第一条不成立是因为类型&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的值是&lt;code class=&quot;inline&quot;&gt;(S U T)&lt;/code&gt;中完全合法的值。例如，数是类型&lt;code class=&quot;inline&quot;&gt;(string U number)&lt;/code&gt;的一员。然而，数不可以在需要类型为&lt;code class=&quot;inline&quot;&gt;string&lt;/code&gt;的时候被使用。&lt;/p&gt;&lt;p&gt;至于第二条，类型&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;的值一般来说不是类型&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的值。任何希望类型&lt;code class=&quot;inline&quot;&gt;(S ∧ T)&lt;/code&gt;消费者希望其能够既作为&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;也作为&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，而后一点无法保证。例如对前面重载的&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;来说，如果&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;(number number -&amp;gt; number)&lt;/code&gt;，那么该类型的函数无法对字符串进行处理。&lt;/p&gt;&lt;h2&gt;15.3.7.3 函数&lt;/h2&gt;&lt;p&gt;我们还讨论过一种复合类型：函数。【注释】我们需要决定子类型关系中，任何一个类型为函数时的规则。通常我们认为函数和其它类型不相交，因此我们只需考虑函数类型作函数类型子类型的情况：也既，何时式子&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(S1 -&amp;gt; T1) &amp;lt;: (S2 -&amp;gt; T2)&lt;/code&gt;&lt;p&gt;成立？方便起见，我们称类型&lt;code class=&quot;inline&quot;&gt;(S1 -&amp;gt; T1)&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;f1&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;(S2 -&amp;gt; T2)&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;f2&lt;/code&gt;。问题就变成了，如果表达式的期望类型为&lt;code class=&quot;inline&quot;&gt;f2&lt;/code&gt;，何种情况下给其传递&lt;code class=&quot;inline&quot;&gt;f1&lt;/code&gt;类型的函数是安全的？使用子集合解释来考虑这个问题比较容易。&lt;/p&gt;&lt;blockquote&gt;我们还讨论过参数化数据类型。在本书中，对它们子类型化的探索作为练习留给读者。&lt;/blockquote&gt;&lt;p&gt;考虑&lt;code class=&quot;inline&quot;&gt;f2&lt;/code&gt;类型的使用。它返回值的类型为&lt;code class=&quot;inline&quot;&gt;T2&lt;/code&gt;。因此，函数调用所在的上下文会对&lt;code class=&quot;inline&quot;&gt;T2&lt;/code&gt;类型的值满意。显然，如果&lt;code class=&quot;inline&quot;&gt;T1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;T2&lt;/code&gt;相同，那么这里&lt;code class=&quot;inline&quot;&gt;f2&lt;/code&gt;的使用也能通过类型检查；类似的，如果&lt;code class=&quot;inline&quot;&gt;T1&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;T2&lt;/code&gt;值的一个子集，也是可以的。唯一的问题是，如果&lt;code class=&quot;inline&quot;&gt;T1&lt;/code&gt;的值比&lt;code class=&quot;inline&quot;&gt;T2&lt;/code&gt;多，该上下文将可能遭遇非期望的值，从而导致未定义行为。换句话说，我们需要&lt;code class=&quot;inline&quot;&gt;T1 &amp;lt;: T2&lt;/code&gt;。注意这里包含的“方向”与整个函数类型中的方向相同；这被称为&lt;b&gt;协变&lt;/b&gt;（covariance，两者在相同的方向上变化）。这也许正是你所期望的。&lt;/p&gt;&lt;p&gt;出于同样的原因，你可能认为参数位置也出现协变：即&lt;code class=&quot;inline&quot;&gt;S1 &amp;lt;: S2&lt;/code&gt;。这也符合预期，但它是错的。让我们看看为什么。&lt;/p&gt;&lt;p&gt;调用&lt;code class=&quot;inline&quot;&gt;f2&lt;/code&gt;类型的函数，需要提供类型为&lt;code class=&quot;inline&quot;&gt;S2&lt;/code&gt;的值作参数。假设我们将函数替换为类型&lt;code class=&quot;inline&quot;&gt;f1&lt;/code&gt;的。如果&lt;code class=&quot;inline&quot;&gt;S1 &amp;lt;: S2&lt;/code&gt;，这意味着新函数仅能接受&lt;code class=&quot;inline&quot;&gt;S1&lt;/code&gt;类型的值——这是一个严格子集。这意味着对于某些值——在&lt;code class=&quot;inline&quot;&gt;S2&lt;/code&gt;中但不在&lt;code class=&quot;inline&quot;&gt;S1&lt;/code&gt;中的值——函数调用会提供它们为参数，而换入的函数在它们之上并无定义，这导致未定义的行为。为避免此，需要假定相反的方向：即替代函数应该至少能接收原函数能够接收的那些值。因此我们需要&lt;code class=&quot;inline&quot;&gt;S2 &amp;lt;: S1&lt;/code&gt;，我们说该位置是&lt;b&gt;逆变&lt;/b&gt;（contravariant）的：它和子类型化方向相反。&lt;/p&gt;&lt;p&gt;综合这两个发现，我们得到函数（对于方法也一样）子类型化的规则：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(S2 &amp;lt;: S1) and (T1 &amp;lt;: T2) =&amp;gt; (S1 -&amp;gt; T1) &amp;lt;: (S2 -&amp;gt; T2)&lt;/code&gt;&lt;h2&gt;15.3.7.4 实现子类型&lt;/h2&gt;&lt;p&gt;当然，这些规则假定我们已经修改了类型检查器遵循子类型化的要求。子类型化的本质规则是，如果有表达式&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;，其类型为&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，且&lt;code class=&quot;inline&quot;&gt;S &amp;lt;: T&lt;/code&gt;，那么&lt;code class=&quot;inline&quot;&gt;e&lt;/code&gt;也具有类型&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;。虽然这听起来很直观，但它也有问题，原因有二：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;到目前为止，我们所有的类型规则都是语法驱动的，这使我们可以编写递归下降的类型检查器。但现在有可一条适用于所有表达式的规则，我们不知道何时应用这条规则了。&lt;/li&gt;&lt;li&gt;可能存在很多级别的子类型。这使得何时“停止”子类型化不再是个显而易见的问题。特别是，原来类型检查会求出表达式的类型，现在表达式可以有很多可能的类型；如果我们返回了“错误”的类型，可能会导致类型错误（因为它不是上下文期望的类型），尽管这时候可能存在其它的类型能够满足上下文需求。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这两个问题指出的是，我们这里给出的关于子类型化的描述根本上来说是&lt;b&gt;声明性的&lt;/b&gt;：我们描述了它是怎样的，但是没有将这种说明转换成算法。对于每个实际的静态类型语言，将其转换成&lt;b&gt;子类型算法&lt;/b&gt;——实现类型检查器的实际算法（理想情况下，该类型检查器仅让所有声明机制下被认为是有效的程序通过类型检测，也即，既可靠又完备）——或多或少是个有趣的问题。&lt;/p&gt;&lt;h2&gt;15.3.8 对象类型&lt;/h2&gt;&lt;p&gt;正如我们&lt;a href=&quot;https://github.com/lotuc/PLAI-cn/blob/master/chap15.md#1534-%E5%90%8D%E4%B9%89%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F&quot;&gt;前面&lt;/a&gt;提到的，对象的类型通常分为两个阵营：名义的和结构的。名义类型大多数程序员通过Java都熟悉了，所以这里不多讨论。对象的结构类型是说，对象的类型本身就是一个结构化的对象，由字段的名字及它们的类型组成。例如，有两个方法——&lt;code class=&quot;inline&quot;&gt;add1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;sub1&lt;/code&gt;——的对象，其类型将是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;{add1 : (number -&amp;gt; number), sub1 : (number -&amp;gt; number)}&lt;/code&gt;&lt;p&gt;（为方便引用，我们称这个类型为&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;。）类型检查的做法也很容易预计：对于字段的访问，我们只需确保字段存在，并将解引用表达式类型求为该字段的声明类型；对于方法调用，我们不仅需要确保对应成员存在，还要确保其类型是函数。到目前为止，一切都很简单。&lt;/p&gt;&lt;p&gt;对象类型会因为很多原因而变复杂：&lt;/p&gt;&lt;blockquote&gt;很多书都专注于此问题。尽管有点过时，但是Abadi和Carelli的《A Theory of &lt;br&gt;Objects（对象理论）》仍然很重要。Bruce的《Foundationos of Object-Oriented Languages: Types and Semantics（面向对象语言基础：类型和语义）》更为现代，阐述也更温和。Pierce的书则漂亮的覆盖了所有必要的理论。&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;自引用。&lt;code class=&quot;inline&quot;&gt;self&lt;/code&gt;的类型是什么？它必须和整个对象的类型相同，因为任何可以从“外部”施加到对象上的操作也可以通过&lt;code class=&quot;inline&quot;&gt;self&lt;/code&gt;在“内部”施加。这意味着对象是递归类型。&lt;/li&gt;&lt;li&gt;访问控制：私有（private）、公共（public）和其它限制。这导致对象“外部”和“内部”类型之间的区别。&lt;/li&gt;&lt;li&gt;继承：不仅需要为父对象指定类型，还需要考虑继承路径上哪些东西可见，这和“外部”可见的东西又有区别。&lt;/li&gt;&lt;li&gt;多重继承和子类型之间的相互作用。&lt;/li&gt;&lt;li&gt;像Java这样的语言中，类和接口之间的关系存在运行时成本。&lt;/li&gt;&lt;li&gt;赋值。&lt;/li&gt;&lt;li&gt;类型转换。&lt;/li&gt;&lt;li&gt;横生枝节。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;等等。其中的一些问题会因为名义类型而简化，因为给定类型名我们就可以确定其行为的所有信息（类型声明实际变成了一个字典，从中可以查询关于对象的描述），这也是赞成名义类型的一个论据。&lt;/p&gt;&lt;blockquote&gt;请注意，Java的方法不是构建名义类型系统的唯一方法。之前讨论过，Java的类系统不必要地限制了程序员的表达能力；相应地，Java的名义类型不必要地将类型（接口描述）和实现混为一谈。因此，名义类型系统可以比Java做的好得多。例如，Scala在这个方面就做出了重要的改变。&lt;/blockquote&gt;&lt;p&gt;对这些问题进行充分论述需要更多的篇幅。这里我们只讨论一个有趣的问题。还记得我们说过，子类型化迫使我们考虑每种类型构造器吗？有了对象的结构类型，我们就必须多考虑一种：对象类型构造器。因此我们必须了解它与子类型化之间的相互作用。&lt;/p&gt;&lt;p&gt;在开始之前，先来确保我们理解对象类型到底意味着什么。考虑上面的&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;类型，其中列出了两个方法。什么对象的类型可以是它？显然，恰好拥有这两个方法、且方法的类型符合的对象符合条件。同样明显的是，如果某个对象只包含这两个方法中的一个而不含另一个，不管它还包含有其它什么，都不符合条件。但其中短语“不管它还包含其它什么”是最先要考虑的。如果对象表示的是算术包，除了这两个方法之外，它还包含&lt;code class=&quot;inline&quot;&gt;+&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt;呢（所有方法的类型也都正确）？这种情况下的对象当然能提供上面两个方法，因此该算术包确实具有类型&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;。不过将其作为类型&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;使用时，其它方法不可用。&lt;/p&gt;&lt;p&gt;下面我们写下这个包的完整类型，称之为&lt;code class=&quot;inline&quot;&gt;as+*&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;{add1  : (number -&amp;gt; number),
 sub1  : (number -&amp;gt; number),
 +     : (number number -&amp;gt; number),
 *     : (number number -&amp;gt; number)}&lt;/code&gt;&lt;p&gt;前面论证的是，类型&lt;code class=&quot;inline&quot;&gt;as+*&lt;/code&gt;的对象也允许被声明为类型&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;，这意味着它可以放入任何期望&lt;code class=&quot;inline&quot;&gt;addsub&lt;/code&gt;类型值的上下文。换句话说，我们刚才的意思其实是&lt;code class=&quot;inline&quot;&gt;as+* &amp;lt;: addsub&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;{add1  : (number -&amp;gt; number),           {add1 : (number -&amp;gt; number),
 sub1  : (number -&amp;gt; number),        &amp;lt;:  sub1 : (number -&amp;gt; number)}
 +     : (number number -&amp;gt; number),
 *     : (number number -&amp;gt; number)}&lt;/code&gt;&lt;p&gt;这可能乍一看令人困惑：我们说过子类型化遵从集合包含关系，因此我们期望小的集合在左侧而大的集合在右侧。可这里，好像“大的类型”（至少在字符数量的意义上是）在左侧而“小的类型”在右侧。&lt;/p&gt;&lt;p&gt;要理解为什么这是正确的，需要建立这样的直觉：“越大”的类型包含的值越少。左侧的每个对象都含有四个方法，而且其中包含了右侧的那两个方法。但是，有很多对象有右侧的两个方法，但是不包含左侧那另外两个方法。如果我将类型看作对可接受值形状的约束的话，“更大”的类型给定了更多的约束，因此会导致更少的值。于是，尽管&lt;b&gt;类型&lt;/b&gt;的大小关系可能看上去不对，但是它们所包含的值的集合的大小关系是正确的。&lt;/p&gt;&lt;p&gt;更一般地，这表明从对象中删除字段就能获得超类型。这被称为&lt;b&gt;宽度子类型化&lt;/b&gt;（width subtyping），因为子类型“更宽”，而我们通过调整对象“宽度”来移动到更上层的类型。即使在Java的名义类型世界中也能看到这点：当沿着继承链上溯时，类中的方法和字段越来越少，直到&lt;code class=&quot;inline&quot;&gt;Object&lt;/code&gt;——所有类的超类型——包含得最少。因此对于Java中的任意类类型&lt;code class=&quot;inline&quot;&gt;C&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;C &amp;lt;: Object&lt;/code&gt;。&lt;/p&gt;&lt;blockquote&gt;有时，&lt;b&gt;缩小&lt;/b&gt;（narrowing）和&lt;b&gt;拓宽&lt;/b&gt;（widening）的使用方式会让人疑惑，它看上去好像用反了一样。拓宽是指从子类型转到超类型，因为它是从一个“较窄”（较小）的集合到一个“较宽”（较大）的集合。这些术语是独立演化而来的，很不幸，并不一致。&lt;/blockquote&gt;&lt;p&gt;正如你可能预计的那样，还有一种重要的子类型化形式，是关于给定成员&lt;b&gt;内部&lt;/b&gt;的。就是说，任何特定的成员都可以归入相应位置的超类型。出于显而易见的原因，这种形式的子类型化被称为&lt;b&gt;深度子类型化&lt;/b&gt;（depth subtyping）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;练习题&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;构造两个深度子类型化的例子。其中一个，给定字段为对象类型，使用宽度子类型化去取该字段的子类型。另一个例子中，给定字段为函数类型。&lt;/blockquote&gt;&lt;p&gt;Java中限制了深度子类型化，它倾向于类型在对象层次结构中保持不变，因为这对传统的赋值操作来说是安全的。&lt;/p&gt;&lt;p&gt;宽度和深度子类型化的结合包含了对象子类型化中大部分最有趣的情形。然而，仅实现这两种子类型化的类型系统不可避免地会招致程序员恼火。其它方便的（而且数学上必须的）规则还包括：改变名称排列顺序的能力、反身性（每个类型是其自己的子类型，因为将子类型关系解释为&lt;code class=&quot;inline&quot;&gt;⊆&lt;/code&gt;更方便）和传递性。像Typed JavaScript这样的语言使用了所有这些特性为程序员提供最大的灵活性。&lt;/p&gt;</description>
<author>MrMathematica</author>
<guid isPermaLink="false">2018-04-02-35198525</guid>
<pubDate>Mon, 02 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>发布Compute.scala，多维数组上的科学计算库</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-01-35183750.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35183750&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同学们，愚人节快乐，&lt;/p&gt;&lt;p&gt;今天我很荣幸向大家介绍&lt;b&gt;Compute.scala&lt;/b&gt;。Compute.scala是个科学计算库，可以利用GPU、CPU和其他设备并行计算多维数组。它是下一版本DeepLearning.scala v3.0的新后端，用来解决我们在DeepLearning.scala v2.0的ND4J后端中遇到的各种性能问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Compute.scala可以把多个操作动态合并成一个核函数。执行复杂计算公式时能比以前大大加速。&lt;/li&gt;&lt;li&gt;Compute.scala可以把内存、显存和其他原生资源管理起来，消耗的资源要比ND4J依赖垃圾收集的做法少得多。&lt;/li&gt;&lt;li&gt;Compute的维度转换操作（比如&lt;code class=&quot;inline&quot;&gt;permute&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;broadcast&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;reshape&lt;/code&gt;）都是视图，不额外占用显存或内存。&lt;/li&gt;&lt;li&gt;Compute的多维数组可以和JVM的集合互相转换，从而可以支持Scala原生的&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;reduce&lt;/code&gt;等集合操作，而且依然可以运行在GPU上。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;性能评测&lt;/h2&gt;&lt;p&gt;我们最近做了一些性能评测，对比Compute.scala和ND4J的性能：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://jmh.morethan.io/?source=https://raw.githubusercontent.com/ThoughtWorksInc/Compute.scala/f4fcd1cd54b9deea8b8234114b2bcdcf8c739038/benchmarks/nvidia-gpu.json&quot;&gt;Compute.scala vs ND4J on a NVIDIA Titan X GPU&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://jmh.morethan.io/?source=https://thoughtworksinc.github.io/Compute.scala/benchmarks/amd-gpu.json&quot;&gt;Compute.scala on a AMD RX480 GPU&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;从性能评测结果看：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Compute.scala支持各个厂商的GPU，ND4J只支持NVIDIA GPU。&lt;/li&gt;&lt;li&gt;在大数组上，Compute.scala比ND4J快。比如把65536×32的矩阵和32×32的矩阵相乘，那么Compute.scala要比ND4J快12倍多。&lt;/li&gt;&lt;li&gt;运行包含多个原子操作的复杂公式，Compute.scala比ND4J快。比如当对32×32×32的数组调用一个&lt;code class=&quot;inline&quot;&gt;tanh&lt;/code&gt;时，Compute.scala只比ND4J快五倍多，但是如果执行的表达式包含了100个&lt;code class=&quot;inline&quot;&gt;tanh&lt;/code&gt;，Compute.scala就比ND4J快三十倍多。&lt;/li&gt;&lt;li&gt;在很小的数组上执行单个简单操作时，ND4J比Compute.scala快。&lt;/li&gt;&lt;li&gt;ND4J的&lt;code class=&quot;inline&quot;&gt;permute&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;broadcast&lt;/code&gt;极慢，大概比Compute.scala慢上百倍，导致我们的卷积评测根本跑不出能看的结果（注：和ND4J同一家作者的Deeplearning4J用了文档上没记载的内部特殊方式使用&lt;code class=&quot;inline&quot;&gt;permute&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;broadcast&lt;/code&gt;，并不像上述评测里这么慢）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;注：这个评测结果并不是愚人节笑话。&lt;/p&gt;&lt;h2&gt;后续工作&lt;/h2&gt;&lt;p&gt;我们刚刚完成Compute.scala的最小可用原型，版本号v0.3.1。Compute.scala的功能仍然有待继续完善，我们将在正式版本发布以前完成以下功能：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;支持单精度浮点数以外的数据类型(&lt;a href=&quot;https://github.com/ThoughtWorksInc/Compute.scala/issues/104&quot;&gt;#104&lt;/a&gt;)&lt;/li&gt;&lt;li&gt;增加更多的OpenCL数学函数(&lt;a href=&quot;https://github.com/ThoughtWorksInc/Compute.scala/issues/101&quot;&gt;#101&lt;/a&gt;)&lt;/li&gt;&lt;li&gt;进一步性能调优(&lt;a href=&quot;https://github.com/ThoughtWorksInc/Compute.scala/labels/performance&quot;&gt;#62, #103&lt;/a&gt;)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;欢迎大家来贡献代码和文档。新贡献者可以从&lt;a href=&quot;https://github.com/ThoughtWorksInc/Compute.scala/labels/good%20first%20issue&quot;&gt;good first issues&lt;/a&gt;开搞。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;相关链接&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/ThoughtWorksInc/Compute.scala&quot;&gt;Compute.scala on Github&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://javadoc.io/page/com.thoughtworks.compute/tensors_2.12/latest/com/thoughtworks/compute/index.html&quot;&gt;Compute API Documentation&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>杨博</author>
<guid isPermaLink="false">2018-04-01-35183750</guid>
<pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>The C Programming Language：入门</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-01-35179359.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35179359&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
序&lt;br&gt;&lt;br&gt;在本书的开篇，我们首先概要地介绍 C 语言，主要是通过实际的程序引入 C 语言的基本元素，至于其中的具体细节、规则以及一些例外情况，在此暂时不多做讨论。因此，本章不准备完整、详细地讨论 C 语言中的一些技术（当然，这里所举的所有例子都是正确的）。我们是希望读者能尽快地编写出有用的程序，为此，本章将重点介绍一些基本概念，比如变量与 常量、算术运算、控制流、函数、基本输入／输出等。而对于编写较大型程序所涉及到的一 些重要特性，比如指针、结构、C 语言中十分丰富的运算符集合、部分控制流语句以及标准库 等，本章将暂不做讨论。 &lt;br&gt;&lt;br&gt;这种讲解方式也有缺点。应当提请注意的是，在本章的内容中无法找到任何特定语言特
性的完整说明，并且，由于比较简略，可能会使读者产生一些误解；再者，由于所举的例子 并没有用到 C 语言的所有强大功能，因此，这些例子也许并不简洁、精炼。虽然我们已经尽力将这些问题的影响降到最低，但问题肯定还是存在。另一个不足之处在于，本章所讲的某些内容在后续相关章节还必须再次讲述。我们希望这种重复给读者带来的帮助效果远远超过它的负面影响。 &lt;br&gt;&lt;br&gt;无论是利还是弊，一个经验丰富的程序员应该可以从本章介绍的内容中推知他们自己进
行程序设计所需要的一些基本元素。初学者应编写一些类似的小程序作为本章内容的补充练习。无论是经验丰富的程序员还是初学者，都可以把本章作为后续各章详细讲解的内容的框架。 &lt;br&gt;&lt;br&gt;1.1. 入门
&lt;br&gt;&lt;br&gt;学习一门新程序设计语言的惟一途径就是使用它编写程序。对于所有语言的初学者来说，编写的第一个程序几乎都是相同的，即：&lt;br&gt;请打印出下列内容 &lt;br&gt;&lt;br&gt;hello, world &lt;br&gt;&lt;br&gt;尽管这个练习很简单，但对于初学语言的人来说，它仍然可能成为一大障碍，因为要实
现这个目的，我们首先必须编写程序文本，然后成功地运行编译，并加载、运行，最后输出到某个地方。掌握了这些操作细节以后，其它事情就比较容易了。 &lt;br&gt;&lt;br&gt;在 C 语言中，我们可以用下列程序打印出&lt;br&gt;&lt;br&gt;“hello, world”：
&lt;br&gt;#include &amp;lt;stdio.h&amp;gt; 
&lt;br&gt;main() 
&lt;br&gt;{ 
&lt;br&gt; printf(&quot;hello, world\n&quot;); 
&lt;br&gt;} &lt;br&gt;&lt;br&gt;如何运行这个程序取决于所使用的系统。这里举一个特殊的例子。在 UNIX 操作系统中，首先必须在某个文件中建立这个源程序，并且以“.c”作为文件的扩展名，例如 hello.c，然后再通过下列命令进行编译： &lt;br&gt;&lt;br&gt;gcc hello.c &lt;br&gt;&lt;br&gt;如果源程序没有什么错误（例如漏掉字符或拼错字符），编译过程将顺利进行，并生成一个可
执行文件 a.out。然后，我们输入： &lt;br&gt;a.out 
&lt;br&gt;即可运行 a.out，打印出下列信息：
&lt;br&gt;hello, world 
&lt;br&gt;在其它操作系统中，编译、加载、运行等规则会有所不同。
&lt;br&gt;————————————————————————&lt;br&gt;#include &amp;lt;stdio.h&amp;gt; 
   &lt;br&gt; 包含标准库的信息&lt;br&gt;main() 
   &lt;br&gt;   定义名为 main 的函数，它不接受参数值&lt;br&gt;{ 
    &lt;br&gt;   main 函数的语句都被括在花括号中&lt;br&gt; printf(&quot;hello, world\n&quot;); 
&lt;br&gt;   main 函数调用库函数 printf 以显示字符序列&lt;br&gt;}       &lt;br&gt;   \n 代表换行符&lt;br&gt;                           第一个C语言程序&lt;br&gt;————————————————————————&lt;br&gt;&lt;br&gt;下面对程序本身做些说明。一个 C 语言程序，无论其大小如何，都是由函数和变量组成的。函数中包含一些语句，以指定所要执行的计算操作；变量则用于存储计算过程中使用的值。C 语言中的函数类似于 Fortran 语言中的子程序和函数，与 Pascal 语言中的过程和函数也很类似。在本例中，函数的名字为main。通常情况下，函数的命名没有限制，但 main 是一个特殊的函数名——每个程序都从 main 函数的起点开始执行，这意味着每个程序都必须在某个位置包含一个 main 函数。 &lt;br&gt;main 函数通常会调用其它函数来帮助完成某些工作，被调用的函数可以是程序设计人员
&lt;br&gt;自己编写的，也可以来自于函数库。上述程序段中的第一行语句
&lt;br&gt;&lt;br&gt;#include &amp;lt;stdio.h&amp;gt; 
&lt;br&gt;&lt;br&gt;用于告诉编译器在本程序中包含标准输入／输出库的信息。许多 C 语言源程序的开始处都包
含这一行语句。我们将在第 7 章和附录 B 中对标准库进行详细介绍。 &lt;br&gt;&lt;br&gt;函数之间进行数据交换的一种方法是调用函数向被调用函数提供一个值（称为参数）列
&lt;br&gt;表。函数名后面的一对圆括号将参数列表括起来。在本例中，main 函数不需要任何参数，因
此用空参数表()表示。 &lt;br&gt;&lt;br&gt;函数中的语句用一对花括号{}括起来。本例中的 main 函数仅包含下面一条语句：
&lt;br&gt;printf(&quot;hello, world\n&quot;); 
&lt;br&gt;调用函数时，只需要使用函数名加上用圆括号括起来的参数表即可。上面这条语句将&quot;hello, 
&lt;br&gt;world\n&quot;。作为参数调用 printf 函数。printf 是一个用于打印输出的库函数，在此处，它打印双引号中间的字符串。用双引号括起来的字符序列称为字符串或字符串常量，如&quot;hello,world\n&quot;就是一个字符串。目前我们仅使用字符串作为 printf 及其它函数的参数。&lt;br&gt;&lt;br&gt;在 C 语言中，字符序列\n 表示换行符，在打印中遇到它时，输出打印将换行，从下一行
&lt;br&gt;的左端行首开始。如果去掉字符串中的\n（这是个值得一做的练习），即使输出打印完成后也
不会换行。在 printf 函数的参数中，只能用\n 表示换行符。如果用程序的换行代替\n，例如：
&lt;br&gt;&lt;br&gt;printf(&quot;hello, world 
&lt;br&gt;&quot;); 
&lt;br&gt;&lt;br&gt;C 编译器将会产生一条错误信息。
&lt;br&gt;&lt;br&gt;printf 函数永远不会自动换行，这样我们可以多次调用该函数以分阶段得到一个长的输
&lt;br&gt;出行。上面给出的第一个程序也可以改写成下列形式：
&lt;br&gt;&lt;br&gt;#include &amp;lt;stdio.h&amp;gt; 
&lt;br&gt;main() 
&lt;br&gt;{ 
&lt;br&gt; printf(&quot;hello, &quot;); 
&lt;br&gt; printf(&quot;world&quot;); 
&lt;br&gt; printf(&quot;\n&quot;); 
&lt;br&gt;} 
&lt;br&gt;&lt;br&gt;这段程序与前面的程序的输出相同。
&lt;br&gt;请注意，\n 只代表一个字符。类似于\n 的转义字符序列为表示无法输入的字符或不可见
&lt;br&gt;字符提供了一种通用的可扩充的机制。除此之外，C 语言提供的转义字符序列还包括：\t 表
&lt;br&gt;示制表符；\b 表示回退符；\&quot;表示双引号；\\表示反斜杠符本身。2.3 节将给出转义字符序
列的完整列表。&lt;br&gt;&lt;br&gt;练习 1-1&lt;br&gt;在你自己的系统中运行“hello, world”程序。再有意去掉程序中的部分内容，看看会得到什么出错信息。 &lt;br&gt;练习 1-2 &lt;br&gt;做个实验，当 printf 函数的参数字符串中包含\c（其中 c 是上面的转义
字符序列中未曾列出的某一个字符）时，观察一下会出现什么情况。 &lt;br&gt;————————————————————————&lt;br&gt;&lt;br&gt;原作者：&lt;br&gt;Brian W. Kernighan 
&lt;br&gt;Dennis M. Ritchie&lt;br&gt;ヾ(@゜∇゜@)ノ祝米娜桑愚人节快乐~有什么不好的尽管在评论区提出哦~</description>
<author>A.Scarlet</author>
<guid isPermaLink="false">2018-04-01-35179359</guid>
<pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>C宏元编程:编译期LISP解释器（二）列表操作</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-01-35172411.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35172411&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;目录⇣&lt;br&gt;    &lt;a href=&quot;https://zhuanlan.zhihu.com/p/35121316&quot;&gt;（一）总体思路&lt;/a&gt;&lt;br&gt;⇢&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35172411&quot;&gt;（二）列表操作&lt;/a&gt;&lt;br&gt;外部链接⇣&lt;br&gt;这是一个超级神奇的项目&lt;a href=&quot;https://github.com/BlueFlo0d/CSP&quot;&gt;CSP Git Repo&lt;/a&gt; &lt;/blockquote&gt;&lt;blockquote&gt;纯粹用C宏写的LISP解释器！&lt;br&gt;（目前还没有完成，最重要的lambda已经实现了，cond暂时还有问题嵌套会出错x）&lt;br&gt;（想拉一些小伙伴一起玩一起烧脑呀！可惜似乎人类玩家直接看源码大概率大脑爆栈，于是尝试写了一些文章之类。。原始wiki可以戳这里&lt;br&gt;&lt;a href=&quot;https://github.com/BlueFlo0d/CSP/wiki/Implementation-details&quot;&gt;CSP Wiki&lt;/a&gt; &lt;/blockquote&gt;&lt;p&gt;这次要开始分析真正的Interpreter A原语啦！坐稳啦！&lt;/p&gt;&lt;h2&gt;列表结构&lt;/h2&gt;&lt;p&gt;开始分析LISP操作前我们先来看看CSP中列表的表示：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(a) //我是原子
( (a) (b) (c) (d) ) //我是列表&lt;/code&gt;&lt;p&gt;为什么要这样呢，用下面这种方式不会更自然吗：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;a //我才是原子
(a,b,c,d) //我才是列表&lt;/code&gt;&lt;p&gt;首先第一种方式括号更多，更符合LISP书写传统（划掉&lt;/p&gt;&lt;p&gt;最重要的是第一种方式在迭代列表和安全操作上有很多优点，例如迭代列表我们可以这样实现：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define sth(x) dosth(x) sth_y
#define sth_y(x) dosth(x) sth
sth(a)(b)(c)(d) // =&amp;gt; dosth(a) sth_y(b)(c)(d) ... 
// =&amp;gt; dosth(a) dosth(b) ... sth 或 sth_y （最后剩下一个没展开完的）&lt;/code&gt;&lt;p&gt;最后剩下的那个“尾巴”可以用零点构造或者以下方式“吃掉”：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define _sth(list) CAT(sth list,_end)
#define sth_end
#define sth_y_end
_sth((a)(b)(c)(d)) // =&amp;gt; CAT( dosth(a) ... sth,_end) =&amp;gt; dosth(a) ... sth_end =&amp;gt; dosth(a)&lt;/code&gt;&lt;p&gt;不过零点构造技术在柯里化的多元迭代函数上有更多优点，所以CSP中两者皆有采用。&lt;/p&gt;&lt;p&gt;至于安全性，接下来会提到。&lt;/p&gt;&lt;h2&gt;基本操作：CAR&lt;/h2&gt;&lt;p&gt;CAR：取一个列表第一个元素的操作，LISP基本原语之一&lt;/p&gt;&lt;p&gt;以下是朴素的CAR实现：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define CAR(x) (_CAR x ))
#define _CAR(x) x _n(
CAR ( (a) (b) (c) ) //=&amp;gt;(_CAR (a) (b) (c) )) 
//=&amp;gt; (a _n( (b) (c) )) =&amp;gt; (a)&lt;/code&gt;&lt;p&gt;这里让CAR定义式中的_CAR展开出一个_n(（未匹配左括号），和后面CAR中的未匹配右括号配对，构成一个零宏，从而将第一个元素后的内容都吃掉。&lt;/p&gt;&lt;p&gt;看起来很好是吗？不过实际上完全不能用。因为在CPP中，由于似乎无法实现短路的逻辑判断，条件分支中所有的clause都会先求值再遴选，这样这些clause大部分都会接受非法输入。&lt;/p&gt;&lt;p&gt;那么看看上面的CAR接受非法输入会发生什么：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;CAR(a) //=&amp;gt;(_CAR a)) 破坏括号平衡！
CAR() //=&amp;gt;(_CAR )) 破坏括号平衡！&lt;/code&gt;&lt;p&gt;会将整个展开过程破坏掉！所以我们需要在非法输入下安全的CAR宏。&lt;/p&gt;&lt;p&gt;实现如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define COND_EAT(x) COND_EATY
#define COND_EATY(x) COND_EAT
#define COND_EAT_FIRST(x) COND_EATY
#define SAFE_CAR_N(x) (())_n
#define SAFE_CAR_EAT_CAR )SAFE_CAR_N((
#define COND_EATY_SCEND (a)
#define COND_EAT_SCEND (a)
#define SAFE_CAR(a) _E(_e _SAFE_CAR(a))
#define _SAFE_CAR(a)  _e(_n _n()(CAT(SAFE_CAR_EAT,_E(_e CAR(CAT(COND_EAT_FIRST a,_SCEND)))))(CAR(a)))
//                                                        ^ 对于非法输入展开失败，输出 (_CAR ... ))
//                                                 ^ _E(_e ...) （两个单位宏名，一对括号）会吞掉参数的一对括号. =&amp;gt; _CAR )
//                                 ^ 连接成 SAFE_CAR_EAT_CAR =========\
//                                v 非法输入导致最后那个CAR同样展开失败.   |
// =&amp;gt; _e(_n _n() () SAFE_CAR_N(() (_CAR ... )) )                      &amp;lt;==/
// =&amp;gt; _e( (()) )
// =&amp;gt; (()) 
//代入 SAFE_CAR 中=&amp;gt; _E(_e (()) )=&amp;gt;()输出一个合法的空列表！&lt;/code&gt;&lt;p&gt;解释一下。_SAFE_CAR 宏大体分为前面的判断体_n _n()(CAT(SAFE_CAR_EAT,_E(_e CAR(CAT(COND_EAT_FIRST a,_SCEND))))) 和后面的主体(CAR(a))，以及最外面增加一次扫描次数的单位宏。判断体应当在输入非法时吃掉主体，而合法时自身输出空。&lt;/p&gt;&lt;p&gt;首先看到 CAT(COND_EAT_FIRST a,_SCEND)，这个目的是把所有形如(b)((c)(d))...之类的合法a值约化为(a)以方便判断体逻辑（否则可能会有很多嵌套列表，难以操作），而将不合法输入约化为一个不含括号的字符串。&lt;/p&gt;&lt;p&gt;此后交由CAR，对于不合法输入会输出形如(_CAR ...))，吞掉一对括号后与SAFE_CAR_EAT连成SAFE_CAR_EAT_CAR，再展开成熟悉的)SAFE_CAR_N((这种未匹配括号形式影响展开过程（多出一个左括号是为了和后面CAR展开失败输出的多余右括号匹配）。而对于合法输入，则直接被_n _n() (...) 吞掉。&lt;/p&gt;&lt;p&gt;SAFE_CDR采用类似思路实现。&lt;/p&gt;&lt;p&gt;好累啊就主要部分先写这么多吧，接下来稍微扯一下CSP解释器A中怎么处理多元函数的&lt;/p&gt;&lt;h2&gt;CSP解释器A中的柯里化&lt;/h2&gt;&lt;p&gt;之前提过的两个宏交替展开非常好，但似乎无法处理需要两个参数的do_sth。&lt;/p&gt;&lt;p&gt;其实可以通过柯里化解决，不过这样展开次数始终会缺一次所以还是得外置一组单位宏来延迟展开。&lt;/p&gt;&lt;p&gt;柯里化技巧的核心：ZIP宏&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#define _be(y) y)
#define ZIP(x)   _n() (x,_be //This _n() delays the expansion of do_sth macro, after _be is expanded. otherwise it will an unmatched bracket error. 
do_sth ZIP(a)(b) =&amp;gt;do_sth _n()(a,_be(b)&lt;/code&gt;&lt;p&gt;如果外面再加一个单位宏强制增加一次扫描，就会变成：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;do_sth (a,b)&lt;/code&gt;&lt;p&gt;这样，一个签名为do_sth(a,b)的二元宏，就可以通过ZIP封装为do_sth ZIP，一个接受一元输入，输出一个一元宏的宏，从而能够处理一个CSP列表的前两项。&lt;/p&gt;&lt;p&gt;在CSP实现中，通常将参数放在待迭代列表前：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(arg)(a)(b)(c)....&lt;/code&gt;&lt;p&gt;do_sth实现为处理(arg,a)，并将arg放在处理结果之后，然后进行递归：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;do_sth (arg)
=&amp;gt; real_do_sth(arg,a) do_sth_y (arg) 
do_sth (arg)(a)(b)(c)
=&amp;gt; real_do_sth(arg,a) do_sth_y (arg) (b)(c)&lt;/code&gt;&lt;p&gt;这样就实现了带参数的迭代列表操作。&lt;/p&gt;</description>
<author>K.Scarlet</author>
<guid isPermaLink="false">2018-04-01-35172411</guid>
<pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>C++函数式实现BST、线段树(单点修改)（1）</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-01-35114696.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35114696&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1942006d5b24fedc190cafc1338070f4_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;偶然看到Common Lisp(&lt;b&gt;CL&lt;/b&gt;)中BST的写法，又联想到了自己写过的单点修改的主席树，觉得这两者几乎差不多，因此拿来分享一下，也顺便应该能解决一下为什么主席树又有一个“函数式版本的线段树”名称&lt;/p&gt;&lt;p&gt;本来打算直接用CL写的......但是想到可能很多人并不熟悉CL，于是就用C++代替了。&lt;/p&gt;&lt;p&gt;目前只打算写单点更新的线段树，而至于区间更新的需要打lazy tag，我需要去学习一下区间更新的主席树再来更新......&lt;/p&gt;&lt;p&gt;本来想完整的写完，但是想到一次性写完可能显得会太长而导致太长不看的可能，所以还是留线段树到下一次吧。&lt;/p&gt;&lt;p&gt;本篇前置知识：BST(Binary Search Tree，二叉搜索树)，C++基本语法&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Part I： 函数式风格几个important properties(此段引用自Land Of Lisp, Ch14, &quot;What is Functional Programming?&quot;)&lt;/p&gt;&lt;ul&gt;&lt;li&gt;只要传入的参数相同，函数总是返回同样的结果。The function always returns the same result, as long as the same arguments are passed into it. &lt;/li&gt;&lt;li&gt;函数不会引用定义在函数外部的变量，除非那个变量是常量。The function never references variables that are defined outside the function, unless we are certain that these variables will remain constant.&lt;/li&gt;&lt;li&gt;函数不会修改变量的值。No variables are modified by the function.&lt;/li&gt;&lt;li&gt;函数除了返回(动词)值以外什么也不干。(原谅本人直译......)The purpose of the function is to do nothing other than to return a result.&lt;/li&gt;&lt;li&gt;函数不会对外界造成任何改变。The function doesn’t do anything that is visible to the outside world, such as pop up a dialog box on the screen or make your computer go &quot;Bing!&quot;&lt;/li&gt;&lt;li&gt;The function doesn&#39;t take information from an outside source, such as&lt;br&gt;the keyboard or the hard drive.&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;p&gt;Part II：函数式的BST实现 &lt;/p&gt;&lt;p&gt;(new完没有delete)&lt;/p&gt;&lt;p&gt;用到的语法知识有：C++ explicit，nullptr，初始化列表，全局变量默认值&lt;/p&gt;&lt;p&gt;BST中节点的定义(注意声明了一个类型为Node*的全局变量root)&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;struct Node{
    int v;
    Node* le,*ri;
    explicit Node(int value=0,Node* lef=nullptr,Node* righ=nullptr)
            :v(value),le(lef),ri(righ){};
}*root;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;BST的插入：&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;Node* bst_insert(int value,Node* bst){
    if(bst==nullptr)
        return new Node(value);
    if(value==bst-&amp;gt;v)
        return bst;
    else if(value&amp;lt;bst-&amp;gt;v)
        return new Node(bst-&amp;gt;v,bst_insert(value,bst-&amp;gt;le),bst-&amp;gt;ri);
    else
        return new Node(bst-&amp;gt;v,bst-&amp;gt;le,bst_insert(value,bst-&amp;gt;ri));
}&lt;/code&gt;&lt;p&gt;接下来讲解bst_insert：&lt;/p&gt;&lt;p&gt;（1）此方法接受一个value，即待插入的值，以及一个Node*，代表&lt;b&gt;当前&lt;/b&gt;的bst的root，因此一开始使用时传入root&lt;/p&gt;&lt;p&gt;（2）此方法前两种情况为简单情况，一个是&lt;b&gt;当前&lt;/b&gt;bst为空时，则返回一个新的、值为value的、左右子都为nullptr的节点。另一个是发现待插入的值和当前节点相等时，为避免重复直接返回自己。(其实这一步可以不要，不过，anyway，这反正不是重点......)&lt;/p&gt;&lt;p&gt;（3）第三种情况和第四种情况是对称的，看到第三种情况，是当前插入的值小于&lt;b&gt;当前&lt;/b&gt;bst的root，那么就返回一个新节点，这个新节点的值是&lt;b&gt;当前&lt;/b&gt;bst的root值，左子是在&lt;b&gt;当前&lt;/b&gt;root的左子上调用bst_insert的返回值，右子是&lt;b&gt;当前&lt;/b&gt;root的右子。&lt;/p&gt;&lt;p&gt;（4）第四种情况把上面的“小于”换成大于，“左”换成“右”，“右”换成“左”&lt;/p&gt;&lt;p&gt;画个图理解一下(纯手绘...请将就着看吧)&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-40276c163ce177a0876ca5d82e20c3c1_r.jpg&quot; data-caption=&quot;考虑在该树上插入新元素 9.5&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;651&quot; data-watermark-src=&quot;v2-3d90af0c145d21db9f50fdc41db4e48b&quot;&gt;&lt;p&gt;第一次调用bst_insert为bst_insert(9.5,root)&lt;/p&gt;&lt;p&gt;返回值是new Node(10,bst_insert(9.5,root-&amp;gt;le),root-&amp;gt;ri)&lt;/p&gt;&lt;p&gt;在途中需要求出bst_insert(9.5,root-&amp;gt;le)的值来完成构造函数，因此&lt;/p&gt;&lt;p&gt;第二次调用bst_insert为bst_insert(9.5,root-&amp;gt;le)&lt;/p&gt;&lt;p&gt;返回值是new Node(8,root-&amp;gt;le-&amp;gt;le,bst_insert(9.5,root-&amp;gt;le-&amp;gt;ri))&lt;/p&gt;&lt;p&gt;在途中需要求出bst_insert(9.5,root-&amp;gt;le-&amp;gt;ri)来完成构造函数，因此&lt;/p&gt;&lt;p&gt;第三次调用bst_insert为bst_insert(9.5,root-&amp;gt;le-&amp;gt;ri)&lt;/p&gt;&lt;p&gt;返回值是new Node(9,root-&amp;gt;le-&amp;gt;ri-&amp;gt;le,bst_inseret(9.5,root-&amp;gt;le-&amp;gt;ri-&amp;gt;ri))&lt;/p&gt;&lt;p&gt;在途中需要求出bst_inseret(9.5,root-&amp;gt;le-&amp;gt;ri-&amp;gt;ri)来完成构造函数，因此&lt;/p&gt;&lt;p&gt;第四次调用bst_insert为bst_inseret(9.5,root-&amp;gt;le-&amp;gt;ri-&amp;gt;ri)&lt;/p&gt;&lt;p&gt;但是root-&amp;gt;le-&amp;gt;ri-&amp;gt;ri为nullptr，因此会直接返回Node(9.5)，因此返回过程如下&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-03814a87e336d4e4212d6d4a06ab87f2_r.jpg&quot; data-caption=&quot;途中的次序表示第几次的返回值，黑线表示连接到了原来的节点&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1633&quot; data-watermark-src=&quot;v2-1f9d2e3dc03b5a53f6dc7c2312660ef3&quot;&gt;&lt;p&gt;我们可以发现，插入的返回值就是一条链，代表的是从真正的root节点一直到被插入的地方的链，其余的节点都是连接到的原来的节点上。因此我们只要令root等于第一次调用bst_insert的返回值就OK了。&lt;/p&gt;&lt;p&gt;可以发现，这其中我们并没有对原来bst上进行修改，而是创建了一条新链，而让这条链和之前的bst共用某些节点。(单点更新的主席树！)&lt;/p&gt;&lt;p&gt;这个联系留到下一次再发。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;BST插入的使用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;int main(){
    srand(time(0));
    for(int i=0;i&amp;lt;10;++i)
        root=bst_insert(rand()%100,root);
    dfs(root);//随便遍历一下，表明it works pretty well. 2333333333
    return 0;
}

void dfs(Node* bst){
    if(bst!=nullptr){
        cout&amp;lt;&amp;lt;bst-&amp;gt;v&amp;lt;&amp;lt;&#39; &#39;;
        dfs(bst-&amp;gt;le);dfs(bst-&amp;gt;ri);
    }
}&lt;/code&gt;&lt;hr&gt;&lt;p&gt;Part III：其他&lt;/p&gt;&lt;p&gt;我觉得我应该把函数式删除拿出来写一个番外篇...这毕竟和写作本文的主旨没有关联。&lt;/p&gt;&lt;p&gt;本篇中的BST完整代码:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Hatsunespica/CL/blob/master/Melange/f_bst.cpp&quot;&gt;https://github.com/Hatsunespica/CL/blob/master/Melange/f_bst.cpp&lt;/a&gt;&lt;/p&gt;&lt;p&gt;假如觉得有什么地方写的错误或不好or可以改进的地方，请尽管提出来。&lt;/p&gt;</description>
<author>Spica</author>
<guid isPermaLink="false">2018-04-01-35114696</guid>
<pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
