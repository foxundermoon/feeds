<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>雾雨魔法店</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/</link>
<description>http://zhuanlan.zhihu.com/marisa/20419321</description>
<language>zh-cn</language>
<lastBuildDate>Mon, 21 May 2018 03:33:05 +0800</lastBuildDate>
<item>
<title>Homotopy type theory univalence 简明入门(4th深圳函数式聚会)</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-05-20-37062630.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37062630&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在昨天的聚会中（不少大佬坐飞机从北上赶来！），我讲了如何在Adga中使用Homotopy type theory进行定理证明。本来以为这么冷门的东西没人关注，没想到讲完大家还问了不少问题。这里我把昨天讲的整理一下可以让更多人看到（ppt写得太潦草就不放啦）&lt;/p&gt;&lt;p&gt;代码在这里：&lt;a href=&quot;https://github.com/doofin/hott-examples&quot;&gt;doofin/hott-examples&lt;/a&gt;&lt;/p&gt;&lt;p&gt;其中用到的一个关键而trival的函数是transport，给定任意的depentent type B（B也可以是常数类型）和(p : x == y)，输出一个B x → B y 的函数。也就是说我有一个定理B x是关于x的，又有一个x == y 的证明p，就可以把这个定理transport 从而证明了B y&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;data _==_ {i} {A : Type i} (a : A) : A → Type i where
  idp : a == a

ap : ∀ {i j} {A : Type i} {B : Type j} (f : A → B) {x y : A}
  → (x == y → f x == f y)
ap f idp = idp

coe : ∀ {i} {A B : Type i} (p : A == B) → A → B
coe idp x = x

transport : ∀ {i j} {A : Type i} (B : A → Type j) {x y : A} (p : x == y)
  → (B x → B y)
transport B p = coe (ap B p)
&lt;/code&gt;&lt;p&gt;这比较容易理解，因为x==y,所以关于x的定理自然可以转到y上。但是因为identity type (_ &lt;i&gt;== _&lt;/i&gt;) 的唯一构造器是idp : a == a ，所以这并没有任何用处，唯一能证明的就是因为x==x 所以B x -&amp;gt; B x.&lt;/p&gt;&lt;p&gt;这时我们自然会想到，难道给出x 和 y 的同构函数对 f : x-&amp;gt; y , g: y -&amp;gt; x , 以及它们互逆的证明不行吗？这是可以的，但是无法利用这个非常generic 的函数transport，我们对于每个定理B x都需要手动地插入f , g .&lt;/p&gt;&lt;p&gt;这时就要用到大名鼎鼎的univalence了。&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;postulate  -- Univalence axiom
  ua : ∀ {i} {A B : Type i} → (A ≃ B) → A == B
&lt;/code&gt;&lt;p&gt;对于 同构类型(A ≃ B)，它能构造identity type.在agda里边是一条postulate，也就是如果你使用了ua然后编译为程序是无法运行的，因为只给出了类型而没有给出term.&lt;/p&gt;&lt;p&gt;有了ua以后就简单了，只需要把同构扔进ua，再transport一下，我们就得到了一个非常generic 的函数：B x -&amp;gt; B y &lt;/p&gt;&lt;p&gt;下面是更加具体的例子，用来处理两个同构的自然数：&lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;doubleN : ℕ -&amp;gt; ℕ -- C n
doubleN = nind z (\ _ n -&amp;gt; s (s n))

n2n&#39; : ℕ -&amp;gt; ℕ&#39;
n2n&#39; = nind z&#39; (\ _ n&#39; -&amp;gt; s&#39; n&#39;)

n&#39;2n : ℕ&#39; -&amp;gt; ℕ
n&#39;2n =  n&#39;ind z (\ _ n&#39; -&amp;gt; s  n&#39;)

-- ap :  x == y -&amp;gt; f x == f y
-- transport : ∀ {i j} {A : Type i} (B : A → Type j) {x y : A} (p : x == y)
--  → (B x → B y)
n~n&#39; : is-equiv n2n&#39; -- simple version
n~n&#39; = is-eq
  n2n&#39; --  (f : A → B)
  n&#39;2n --  (g : B → A)
  (n&#39;ind {λ x → n2n&#39; (n&#39;2n x) == x} idp (λ _ x=&#39;=y → ap s&#39; x=&#39;=y )) -- (f-g : (b : B) → f (g b) == b) ,idp :0==0
  (nind {λ x → n&#39;2n (n2n&#39; x) == x} idp (λ _ x==y → ap s x==y ))
 -- (g-f : (a : A) → g (f a) == a)
doubleN&#39; : ℕ&#39; -&amp;gt; ℕ&#39; -- double from univalence . transport:  a~b -&amp;gt; pa -&amp;gt; pb
doubleN&#39; = transport ( λ a → a → a) (ua (n2n&#39; , n~n&#39;)) (doubleN) -- P , n == n&#39; , double n -&amp;gt; double n&#39;
-- define + with recursor for natural number,2 
-- using currying,the type A is ℕ

doubleN&#39;nouniv : ℕ&#39; -&amp;gt; ℕ&#39;
doubleN&#39;nouniv n&#39; = n2n&#39; (doubleN (n&#39;2n n&#39;))
&lt;/code&gt;&lt;h2&gt;这里可能还体现不出威力，但是如果要证明的是关于更复杂结构的定理比如：&lt;/h2&gt;&lt;code lang=&quot;agda&quot;&gt;record IsSemigroup (∙ : Op₂ A) : Set (a ⊔ ℓ) where
  field
    isEquivalence : IsEquivalence _≈_
    assoc         : Associative ∙
    ∙-cong        : Congruent₂ ∙

  setoid : Setoid a ℓ
  setoid = record { isEquivalence = isEquivalence }

  open IsEquivalence isEquivalence public
&lt;/code&gt;&lt;p&gt;这时有univalence 就确实能省很多功夫了，下次我会尝试给出更好的例子。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;使用HoTT库进行定理证明还有个好处是只需要函数式编程就够了，应该不再需要学rewrite，dependent之类dependent type 语言特有的一些复杂特性()。&lt;/p&gt;&lt;p&gt;如果还想知道如何证明Univalence(也就是让其能够计算)，可以研究一下&lt;a href=&quot;https://github.com/mortberg/cubicaltt&quot;&gt;mortberg/cubicaltt&lt;/a&gt;，cubical type theory 是一个比较热门的方向。&lt;/p&gt;</description>
<author>Martin awodey</author>
<guid isPermaLink="false">2018-05-20-37062630</guid>
<pubDate>Sun, 20 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>后浪</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-05-18-37007550.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37007550&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近跟人聊天，他说物理学停歇不前，那像二战的黄金时代，产生了相对论跟量子力学。于是，我想起了去年刚学历史没多久的自己。。当时我觉得CS的黄金时代 - 1960~80已经过去，互联网，OS，GUI，Computer Architecture，等等，全部出自那个时代，而我们只是想方设法去monetize这些。唉。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现在看来，实在是有失偏颇。&lt;/p&gt;&lt;p&gt;要对历史/当下做评价的最主要的问题是，credit assignment实在太难做。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;举个例子，大家是如何看待区块链的？&lt;/p&gt;&lt;p&gt;我曾经问过我的PHD同事/朋友，他们的答案，除了一个就是搞区块链的，通通是‘敬而远之/bubble/pyramid scheme’。&lt;/p&gt;&lt;p&gt;而这的核心，是因为区块链‘没有现实价值’。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;而1970年代的Xerox高层是怎么评价Xerox PARC的？&lt;/p&gt;&lt;p&gt;‘没有用’‘白花钱’。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;看出问题了吗？如果我们真穿越回1970，说不定我们会感叹着真是一代不如一代，老冯搞出了老冯架构，IBM搞出了计算机架构，海軍准將弄出了COBOL，一推人搞出了Algol，我们就有些民科般乱搞的人。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;而他们也情有可原 - 1960~70出现了PC&amp;amp;GUI&amp;amp;Tablet/Smart Phone的概念，一直到90才步入大众（phone得到2010），而70年同时的出现的internet呢？Amazon在dot com bubble受到的影响一直到2010才恢复过来，这整整隔了40年。从一个东西被发明，到走到现实，往往需要很久的时间去降低成本/建立中层建筑/寻找应用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;而区块链只出现了10年，根据历史的发展，很可能30年后才兑现 - 现在评论区块链有没有用，实在太早。&lt;/p&gt;&lt;p&gt;但是，如果最近各个还在发展中的idea（block chain/deep learning/quantum computing），真在几十年后被发现是www级别的idea呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那我们这就不止是第二春 - 黄金时代只是现在这时代的前传。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;甚至，还有个更基本的问题 - internet固然是伟大的发明，bob taylor 当初也没有预料到会有 search engine存在啊。这credit多少得给Parc/Bob，多少Google？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那，什么时代是最好的时代？&lt;/p&gt;&lt;blockquote&gt;　　杨过问道：“郭伯伯，你说襄阳守得住吗？”郭靖沉吟良久，手指西方郁郁苍苍的丘陵树木，说道：“襄阳古往今来最了不起的人物，自然是诸葛亮。此去以西二十里的隆中，便是他当年耕田隐居的地方。诸葛亮治国安民的才略，我们粗人也懂不了。他曾说只知道‘鞠躬尽瘁，死而後已’，至於最後成功失败，他也看不透了。我与你郭伯母谈论襄阳守得住、守不住，谈到後来，也总只是‘鞠躬尽瘁，死而後已’这八个字。”&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我认为，学历史，是为了抓住&amp;amp;复现各种机会，而不是去怀古伤今或者轻议冢中人 - 那实在是太难了，谋事在人，成事在天就好。&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2018-05-18-37007550</guid>
<pubDate>Fri, 18 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>活化石</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-05-04-36427205.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36427205&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近计算机架构课组织了一次去&lt;a href=&quot;https://livingcomputers.org/&quot;&gt;Living Computers - Home&lt;/a&gt;的春游（误？），可惜迷路了，导致来晚，只看到一小半。&lt;/p&gt;&lt;p&gt;很好的一点是里面的计算机都是可远观而亦可亵玩 - 事实上我们的作业就是随便找台计算机在上面编程。&lt;/p&gt;&lt;p&gt;对于喜欢计算机历史的人来说很爽啊 - 从书上看着各种电脑各种OS是一码事，真正的看到，然后摸，还能用，感觉完全不一样。&lt;/p&gt;&lt;p&gt;尤其是还有Xerox Alto。还有个巨大的装着Smalltalk的盘盘。把老娘的爪爪放在圆圆的Smalltalk上然后插进Xerox Alto真是满足死我了。可惜不知道为啥Smalltalk跑不起来 - 放太久了？&lt;/p&gt;&lt;p&gt;信仰++++。&lt;/p&gt;&lt;p&gt;然后Digi-Comp（见&lt;a href=&quot;https://www.youtube.com/watch?v=_tZdE-3nR3w&quot;&gt;https://www.youtube.com/watch?v=_tZdE-3nR3w&lt;/a&gt;）也很好玩。&lt;/p&gt;&lt;p&gt;另：某Lisp厨失望了 - 没有Lisp Machine。&lt;/p&gt;&lt;p&gt;另另：有辛去的话，推荐下Pecos Pit Bar-B-Que，好好吃，实习以后大半年都没吃到这么辣的东西辣，sad&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2018-05-04-36427205</guid>
<pubDate>Fri, 04 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>第四届函数式编程分享会</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-05-01-36308855.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36308855&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;报名地址: &lt;a href=&quot;https://jinshuju.net/f/9a72wh&quot;&gt;深圳函数式编程聚会&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;计划暂定&lt;/b&gt;于2018年5月19日早9:30，于深圳福田区嘉里建设广场3栋39层（嘉石大岩资本）&lt;/p&gt;&lt;p&gt;分享函数式编程的经验，也可以微博关注@&lt;a href=&quot;http://weibo.com/u/2709495807?source=webim&quot;&gt;Haskell中文&lt;/a&gt; &lt;a href=&quot;http://weibo.com/u/1914643755?refer_flag=1005055010_&quot;&gt;@阅千人而惜知己&lt;/a&gt; &lt;a href=&quot;https://weibo.com/notyy?topnav=1&amp;amp;wvr=6&amp;amp;topsug=1&quot;&gt;@大魔头&lt;/a&gt;，如有任何疑问可以加入QQ群72874436讨论。&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6676ea444bda2c703add8474963e800a&quot; data-hash=&quot;6676ea444bda2c703add8474963e800a&quot; data-hovercard=&quot;p$b$6676ea444bda2c703add8474963e800a&quot;&gt;@阅千人而惜知己&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0a308ec0bd0ce92754be4e85db62a29a&quot; data-hash=&quot;0a308ec0bd0ce92754be4e85db62a29a&quot; data-hovercard=&quot;p$b$0a308ec0bd0ce92754be4e85db62a29a&quot;&gt;@parker liu&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/73c168246af1fab79b28736c311466e1&quot; data-hash=&quot;73c168246af1fab79b28736c311466e1&quot; data-hovercard=&quot;p$b$73c168246af1fab79b28736c311466e1&quot;&gt;@韩冬&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/2d8f51b6523e01a8529606f466d98198&quot; data-hash=&quot;2d8f51b6523e01a8529606f466d98198&quot; data-hovercard=&quot;p$b$2d8f51b6523e01a8529606f466d98198&quot;&gt;@Felis sapiens&lt;/a&gt; &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/4cf2f4dca8e0339f5c2a460ecb62db39&quot; data-hash=&quot;4cf2f4dca8e0339f5c2a460ecb62db39&quot; data-hovercard=&quot;p$b$4cf2f4dca8e0339f5c2a460ecb62db39&quot;&gt;@大魔头-诺铁&lt;/a&gt; &lt;/p&gt;&lt;p&gt;如果条件允许的话&lt;b&gt;可能&lt;/b&gt;会有直播&lt;/p&gt;&lt;p&gt;微信群二维码(知乎会自动转链接): &lt;/p&gt;&lt;a href=&quot;https://ibb.co/iJCteS&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Wechat IMG2&lt;/a&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我写的往届的一些记录:&lt;/p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26722010&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;祖与占：上海2017年函数式编程分享会视频&lt;/a&gt;&lt;a href=&quot;https://www.zhihu.com/question/59391737/answer/164874243&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;参加 2017 年函数式编程聚会是什么感受?&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20831552&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;祖与占：第2届函数式编程分享随便记&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>祖与占</author>
<guid isPermaLink="false">2018-05-01-36308855</guid>
<pubDate>Tue, 01 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>lambda演算与数据类型</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-25-36081360.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36081360&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fc94609d676b4704ccfce8b67fd56e62_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在大多数编程语言里面，数据类型和函数都是不同的，但它们又有种种关联。我们可以说函数是一种数据类型，换句话说就是first class function。通过pattern match我们可以拿到ADT（代数数据类型）的各个constructor的argument。再用Idris举个例子：&lt;/p&gt;&lt;code lang=&quot;idris&quot;&gt;data Maybe : (a : Type) -&amp;gt; Type where
    Nothing : Maybe a
    Just : (x : a) -&amp;gt; Maybe a&lt;/code&gt;&lt;p&gt;我们定义了2个函数：Nothing和Just，这两个function都用于构造数据类型Maybe，所以他们的返回值的类型是Maybe，我们把这两个函数称之为constructor。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;前置知识&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;对函数式编程及相关编程语言的了解&lt;/li&gt;&lt;li&gt;对Lambda演算的基本知识&lt;/li&gt;&lt;li&gt;ADT（代数数据类型）的基本知识&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;数据类型与函数&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在lambda calculus中，一切都是函数。我们通过：variable、abstraction、application来组成lambda的term。一般通过对lambda term应用normal order reduction来对lambda term进行求值。&lt;/p&gt;&lt;p&gt;既然函数可以是一种数据类型，数据类型可不可以用函数来表示呢？当然可以。例如在lambda演算中通常表示自然数的方式，或者说church number则是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;zero := λf.λx.x;
succ := λn.λf.λx.f (n f x);&lt;/code&gt;&lt;p&gt;如果不熟悉church encoding的自然数可以在维基百科中了解：&lt;/p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Lambda_calculus&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;https://en.wikipedia.org/wiki/Lambda_calculus&lt;/a&gt;&lt;p&gt;我们有多种方式将数据类型encode到lambda calculus中，如church number：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;0 := λf.λx.x;
1 := λf.λx.f x;
2 := λf.λx.f (f x);&lt;/code&gt;&lt;p&gt;则是通过将参数f递归的应用在x上来encode自然数的。&lt;/p&gt;&lt;p&gt;而peano number，或者也可以说是scott encoding的自然数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;zero := λz.λs.z;
succ := λn.λz.λs.s n;

0 := λz.λs.z;
1 := λz.λs.s (λz.λs.z);
2 := λz.λs.s (λz.λs.s (λz.λs.z));&lt;/code&gt;&lt;p&gt;则是将数据类型的constructor定义出来，并encode每个constructor的pattern match函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;数据类型的表示&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们可以通过将数据类型相关的一种operator进行encode，来将数据类型表示到lambda calculus中。例如上文自然数的例子，Church encoding是将”递归的把函数f应用n次到x上(f^n)“这种operator进行encode。Scott encoding则是将pattern match这种operator进行encoding。&lt;/p&gt;&lt;p&gt;一个operator就是一个函数，在Church encoding的自然数中，递归的把函数f应用n次到x上的function是trivial的，而pattern match则不是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;funcPow := λf.λx.λn.n f x;
matchNat := λz.λs.λn.n (λm.m (λu.λg.g (λf.λx.x)) (λg.λu.λh.h (λf.λx.f (g f x)))) (λx.λu.x) z s;&lt;/code&gt;&lt;p&gt;而用Scott encoding的peano number中，pattern match是trivial的，而funcPow则不是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;funcPow := λf.λx.λn.n x ((λg.(λy.g (y y)) (λy.g (y y))) (λg.λh.f (h x g)));
matchNat := λz.λs.λn.n z s;&lt;/code&gt;&lt;p&gt;不单单是自然数，其他数据类型也可以用类似的方法进行encode。例如对于List，我们可以将其按fold right进行encode，或者按pattern match进行encode等。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Scott encoding&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在上文中多次提到了scott encoding、pattern match这两个名词。具体来说，对于ADT（也就是有多个constructor，每个constructor有任意argument，或者说product的sum）来说，可能最简单、最直观的encode数据类型的方法就是将pattern match进行encode了，scott encoding就是指的这种encode数据类型的方法。&lt;/p&gt;&lt;p&gt;具体对于有n个constructor的ADT，对于第x个constructor，有m个argument，用如下方法进行encode：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;CtorX := λA_1 A_2 ... A_m.λC_1 C_2 ... C_n.C_x A_1 A_2 ... A_m;&lt;/code&gt;&lt;p&gt;这样就可以对直观的对不同的case进行pattern match了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Encoding of list&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文中提到过对list进行encode的2种方法，关于其他的encode方法，可以参考维基百科：&lt;/p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Church_encoding#List_encodings&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;https://en.wikipedia.org/wiki/Church_encoding#List_encodings&lt;/a&gt;&lt;p&gt;这里我们使用Scott encoding来encode list，定义list(pattern match)、nil(constructor)、cons(constructor)、length、null、append、foldr、foldl函数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;list := λn.λc.λl.l n c;

nil := λn.λc.n;
cons := λh.λt.λn.λc.c h t;

length := λl.l zero (λh.λt.succ (length t));
null := λl.l true (λh.λt.false);
append := λl.λm.l m (λh.λt.cons h (append t m));
foldr := λf.λx.λl.l x (λh.λt.f h (foldr f x t));
foldl := λf.λx.λl.l x (λh.λt.foldl f (f x h) t);&lt;/code&gt;&lt;p&gt;每个函数的定义都比较直观，就不详细描述了。对于引用了其他函数的情况可以直接代换，也可以将其当作free variable，并使用abstraction将其捕获，通过application传入其定义，例如对于null：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;null := (λtrue.λfalse.λl.l true (λh.λt.false)) (λt.λf.t) (λt.λf.f);&lt;/code&gt;&lt;p&gt;需要注意的是length、append、foldr、foldl都在定义中引用了自身，也就是使用了递归。对于这种情况，需要使用不动点算子：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fix := λf.(λx.f (x x)) (λx.f (x x));&lt;/code&gt;&lt;p&gt;将其转化为：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;length := fix (λlength.λl.l zero (λh.λt.succ (length t)));
append := fix (λappend.λl.λm.l m (λh.λt.cons h (append t m)));
foldr := fix (λfoldr.λf.λx.λl.l x (λh.λt.f h (foldr f x t)));
foldl := fix (λfoldl.λf.λx.λl.l x (λh.λt.foldl f (f x h) t));&lt;/code&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了如何在lambda calculus中处理数据类型，和各种encoding之间的关系。&lt;/p&gt;&lt;p&gt;这里打个广告，写这篇文章的起因是最近在用scala写一个个人项目，lambda calculus的REPL。在设计标准库的时候涉及到了一些与本文相关的知识。已经实现了tokenizer、parser、beta reducer、eta converter、pretty printer等模块，单纯调用API来处理lambda term是没有问题了。目前正在设计核心的REPL的Extension API、library的dependencies管理、lam文件（library的源文件）的语法、标准库等。如果有兴趣参与开发，欢迎联系我！&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/yuxuanchiadm/lamcalcj&quot;&gt;https://github.com/yuxuanchiadm/lamcalcj&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Lambda_calculus&quot;&gt;Lambda calculus&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Church_encoding&quot;&gt;Church encoding&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding&quot;&gt;Mogensen–Scott encoding&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>不可构造的雨轩菌</author>
<guid isPermaLink="false">2018-04-25-36081360</guid>
<pubDate>Wed, 25 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>一款能设置你的DrRacket背景的IDE插件</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-23-36027427.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36027427&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e7f5beb3b56104a4ee29bcd37d7e8c1c_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;安装方式（两种）：&lt;/p&gt;&lt;p&gt;1.进入终端，输入下面的命令：&lt;/p&gt;&lt;p&gt;raco pkg install DrRacketTheme&lt;/p&gt;&lt;p&gt;在不同操作系统上可能有所不同，如果没有成功，请尝试先进入racket安装目录下然后在运行这条命令。&lt;/p&gt;&lt;p&gt;2.打开DrRacket，打开File菜单下的Package Manager，切换到Available from Catalog选项卡，点击Update Package List按钮，稍等片刻，然后在Filter文本框中输入DrRacketTheme，点击Install按钮。&lt;/p&gt;&lt;p&gt;设置的时候请点击View菜单下的Set Background，选择需要作为背景的图片。&lt;/p&gt;&lt;p&gt;Set Background Alignment能够设置图片的对齐方式。&lt;/p&gt;&lt;p&gt;希望这款插件能够帮助到正在学习racket或是scheme的人。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>御坂黒子</author>
<guid isPermaLink="false">2018-04-23-36027427</guid>
<pubDate>Mon, 23 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何玩弄Typed Racket</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-21-35962271.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35962271&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要玩弄Typed Racket，首先，你不可避免地要require一大堆东西：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang racket
(require racket/require)
(require typed-racket/utils/utils
         typed-racket/standard-inits
         (private parse-type)
         (rep values-rep)
         (types abbrev subtype tc-result numeric-tower)
         (typecheck typechecker tc-funapp)
         (for-template (base-env base-types))
         (rename-in (base-env base-types-extra) [Un t:Un] [-&amp;gt; t:-&amp;gt;] [-&amp;gt;* t:-&amp;gt;*])
         (env global-env)
         )

(do-standard-inits)&lt;/code&gt;&lt;p&gt;　　然后我们看看怎么parse一个类型：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (parse-type #&#39;String)
String

&amp;gt; (parse-type #&#39;(Pairof String String))
(Pairof String String)

&amp;gt; (parse-type #&#39;(All (a) (a → String)))
(All (a) (-&amp;gt; a String))&lt;/code&gt;&lt;p&gt;　　基本上直接照搬TR的语法即可。除了&lt;code class=&quot;inline&quot;&gt;-&amp;gt;&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;-&amp;gt;*&lt;/code&gt;，因为上面&lt;code class=&quot;inline&quot;&gt;base-types-extra&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;abbrev&lt;/code&gt;的冲突，要改用&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (parse-type #&#39;(String t:-&amp;gt; String))
(-&amp;gt; String String)

&amp;gt; (parse-type #&#39;(t:-&amp;gt;* (String) String))
(-&amp;gt; String String)&lt;/code&gt;&lt;p&gt;　　好了，学会parse一个类型之后，再看看怎么手动构造一些简单的类型。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; Univ
Any

&amp;gt; -Bottom
Nothing

&amp;gt; (Un -True -False)
(U #f #t)

&amp;gt; (make-Pair -String -Boolean)
(Pairof String (U #f #t))

&amp;gt; (make-Intersection (list -Boolean -True))
(∩ #t (U #f #t))

&amp;gt; (-poly (a) (-&amp;gt; a a))
(All (a) (-&amp;gt; a a))

&amp;gt; (make-Mu &#39;x (Un -Null (make-Pair -String (make-F &#39;x))))
(Listof String)

&amp;gt; (-lst Univ)
(Listof Any)&lt;/code&gt;&lt;p&gt;　　现在来构造一些复杂的类型，例如带latent proposition、latent object的函数类型：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (-&amp;gt; Univ
      (make-Values
       (list
        (make-Result -Boolean
                     (-PS (-is-type (make-Path null (cons 0 0)) -String)
                          (-not-type (make-Path null (cons 0 0)) -String))
                     -empty-obj))))
(-&amp;gt; Any (U #f #t) : String)

&amp;gt; (make-pred-ty -String)
(-&amp;gt; Any (U #f #t) : String)&lt;/code&gt;&lt;p&gt;　　此外，latent propositions常用的缩写有&lt;code class=&quot;inline&quot;&gt;true-propset&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;-false-propset&lt;/code&gt;等；latent object常用的缩写有&lt;code class=&quot;inline&quot;&gt;-arg-path&lt;/code&gt;等。&lt;/p&gt;&lt;p&gt;　　说完构造类型了，现在开始进行类型推导：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (tc-expr #&#39;&#39;1)
(tc-results
 (list (tc-result 1 (Top | Bot) -))
 #f)
 
&amp;gt; (tc-expr #&#39;&#39;&quot;123&quot;)
(tc-results
 (list (tc-result String (Top | Bot) -))
 #f)&lt;/code&gt;&lt;p&gt;　　要注意的是这个推导是针对&lt;i&gt;Fully Expanded Programs&lt;/i&gt;，Typed Racket把程序展开到&lt;i&gt;Fully Expanded Programs&lt;/i&gt;的同时做了的事包括有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;把类型声明记录到一个环境里。&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (register-type #&#39;f1 Univ)  
&amp;gt; (tc-expr #&#39;f1)
 (tc-results  (list (tc-result Any (Top | Top) -))  #f)&lt;/code&gt;&lt;ul&gt;&lt;li&gt;插入一些&lt;i&gt;syntax properties&lt;/i&gt;，以便在&lt;i&gt;Fully Expanded Programs&lt;/i&gt;里留下足够的辅助信息，主要需要注意的有&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;typechecker:plambda&lt;/code&gt;：用于多态。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;type-label&lt;/code&gt;：用于在引入binding的时候声明类型。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;type-ascription&lt;/code&gt;：用于ann。&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (tc-expr (syntax-property #&#39;&#39;1 &#39;type-ascription -Integer))
(tc-results
 (list
  (tc-result
   (U
    0
    1
    Byte-Larger-Than-One
    Negative-Fixnum
    Negative-Integer-Not-Fixnum
    Positive-Fixnum-Not-Index
    Positive-Index-Not-Byte
    Positive-Integer-Not-Fixnum)
   (Top | Bot)
   -))
 #f)
 
 &amp;gt; (tc-expr (syntax-property
            #`(#%plain-lambda
               (#,(syntax-property
                   #&#39;x
                   &#39;type-label
                   #&#39;a))
               x)
            &#39;typechecker:plambda
            #&#39;(a)))
(tc-results
 (list
  (tc-result
   (All (a) (-&amp;gt; a a))
   (Top | Bot)
   -))
 #f)&lt;/code&gt;&lt;p&gt;　　这样基本上就差不多了，然后说一下&lt;i&gt;subtyping&lt;/i&gt;：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (subtype -One -Integer)
#t

&amp;gt; (subtype -True (Un -True -False))
#t

&amp;gt; (subtype (-poly (a) (Un a -String)) -String)
#t&lt;/code&gt;&lt;p&gt;　　掌握这些东西后，差不多就可以玩Typed Racket了，比如探究latent object对类型推导的影响（参见&lt;a href=&quot;https://github.com/racket/typed-racket/issues/678&quot;&gt;https://github.com/racket/typed-racket/issues/678&lt;/a&gt;）：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (register-type #&#39;f1 (-poly (a)
                           (-&amp;gt; (make-Intersection (list a top-func))
                               (make-Values
                                (list
                                 (make-Result
                                  (make-Intersection (list a top-func))
                                  -true-propset
                                  -empty-obj
                                  ))))))
&amp;gt; (register-type #&#39;f2 (-poly (a)
                           (-&amp;gt; (make-Intersection (list a top-func))
                               (make-Values
                                (list
                                 (make-Result
                                  (make-Intersection (list a top-func))
                                  -true-propset
                                  (-arg-path 0)
                                  ))))))
                                  
&amp;gt; (tc-expr #`(#%plain-app f1 f1))
(tc-results
 (list
  (tc-result
   (-&amp;gt; Nothing (case-&amp;gt;))
   (Top | Bot)
   -))
 #f)
 
&amp;gt; (tc-expr #`(#%plain-app f2 f2))
(tc-results
 (list
  (tc-result
   (All
    (a)
    (-&amp;gt; (∩ (case-&amp;gt;) a) (∩ (case-&amp;gt;) a)))
   (Top | Bot)
   -))
 #f)&lt;/code&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>qww6</author>
<guid isPermaLink="false">2018-04-21-35962271</guid>
<pubDate>Sat, 21 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Racket杂谈：可扩展的宏</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-21-35953489.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35953489&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;　　去年9月份的文章了，估计只有群友看过，现在放到公开场所来。Typed Racket用到的宏技巧被称为Advanced Macrology，那么这里介绍的算是trivial macrology吧。写的比较啰嗦狗血，随意了。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;　　众所周知，宏是很多Lisp方言中重要的一部分，在Racket中亦是如此。Racket中有着众多功能各不相同的宏：轻量级的&lt;code class=&quot;inline&quot;&gt;cond&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;do&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;case&lt;/code&gt;，……；中量级的&lt;code class=&quot;inline&quot;&gt;match&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;for&lt;/code&gt;，……；重量级的&lt;code class=&quot;inline&quot;&gt;racket/class&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;syntax/parse&lt;/code&gt;等……&lt;/p&gt;&lt;p&gt;　　有一天，路人丙注意到，Racket中很多复杂的宏都提供了一种可以自定义关键字的机制：&lt;code class=&quot;inline&quot;&gt;for&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;define-sequence-syntax&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;match&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;define-match-expander&lt;/code&gt;以及&lt;code class=&quot;inline&quot;&gt;syntax/parse&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;pattern-expander&lt;/code&gt;等。使用这类机制，用户可以自行给原有的宏加上自己想要的功能！&lt;/p&gt;&lt;p&gt;　　于是路人丙开始思考如何给自己的宏加上这种方便的能力。路人丙注意到，&lt;code class=&quot;inline&quot;&gt;pattern-expander&lt;/code&gt;是使用普通的&lt;code class=&quot;inline&quot;&gt;define-syntax&lt;/code&gt;来定义的。聪明的路人丙立刻想到使用&lt;code class=&quot;inline&quot;&gt;syntax-local-value&lt;/code&gt;来获取宏展开环境中的值。他写下了如下一段试验代码：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang racket

(define x &#39;(1))

(define-syntax (expander1 stx)
  (syntax-case stx ()
    [id #&#39;(id x)]))

(define-syntax (use-expander stx)
  (syntax-case stx ()
    [(_ id in)
     ((syntax-local-value #&#39;id) #&#39;in)]))

(use-expander expander1 car)&lt;/code&gt;&lt;p&gt;　　运行该程序，路人丙如愿所偿地得到了结果&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。嗯，大功告成，路人丙成功揭开了这类宏的秘密，他感觉自己功力大增，距离成为一代宗师已经不远了！&lt;/p&gt;&lt;p&gt;　　直到有一天，他稍微改了下自己的程序：&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang racket

(define x &#39;(1))

(define-syntax (expander1 stx)
  (syntax-case stx ()
    [id #&#39;(id x)]))

(define-syntax (use-expander stx)
  (syntax-case stx ()
    [(_ id in)
     #`(let ([x &#39;(2)])
         #,((syntax-local-value #&#39;id) #&#39;in))]))

(use-expander expander1 car)&lt;/code&gt;&lt;p&gt;　　运行结果是&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;，路人丙慌了，按照习俗，宏应该是 &lt;i&gt;hygienic&lt;/i&gt; 的,&lt;code class=&quot;inline&quot;&gt;expander1&lt;/code&gt;中的&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;不应该意外地绑定&lt;code class=&quot;inline&quot;&gt;use-expander&lt;/code&gt;中的&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;，这样的结果令他无法接受。那么应该怎么改呢？&lt;/p&gt;&lt;p&gt;　　路人丙百思不得其解，于是他向路人壬请教了这个问题。路人壬告诉他，这种xxx expadner在Racket社区中，有一种固定的写法。路人丙记下了这个写法，回去果然一试即成。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang racket

(begin-for-syntax
  (define (apply-expander proc stx)
    (define introducer (make-syntax-introducer))
    (define intro-stx (introducer (syntax-local-introduce stx)))
    (syntax-local-introduce (introducer (proc intro-stx)))))

(define x &#39;(1))

(define-syntax (expander1 stx)
  (syntax-case stx ()
    [id #&#39;(id x)]))

(define-syntax (use-expander stx)
  (syntax-case stx ()
    [(_ id in)
     #`(let ([x &#39;(2)])
         #,(apply-expander (syntax-local-value #&#39;id) #&#39;in))]))

(use-expander expander1 car)&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解释&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　我们首先来回顾一下Racket的宏展开原理，参考&lt;a href=&quot;https://docs.racket-lang.org/reference/syntax-model.html&quot;&gt;1.2 Syntax Model&lt;/a&gt;，我们看到：&lt;/p&gt;&lt;blockquote&gt;Before the expander passes a &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax object&lt;/a&gt; to a transformer,the &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax object&lt;/a&gt; is extended with a fresh &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._scope%29&quot;&gt;scope&lt;/a&gt; (thatapplies to all sub-&lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax objects&lt;/a&gt;) to distinguish &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax objects&lt;/a&gt;at the macro’s use site from &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax objects&lt;/a&gt; that are introduced by the macro;in the result of the transformer the presence of the &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._scope%29&quot;&gt;scope&lt;/a&gt; isflipped, so that introduced &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax objects&lt;/a&gt; retain the &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._scope%29&quot;&gt;scope&lt;/a&gt;,and use-site &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax objects&lt;/a&gt; do not have it. In addition, ifthe use of a transformer is in the same definition context as its binding,the use-site &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax object&lt;/a&gt; is extended with an additional freshuse-site scope that is not flipped in the transformer’s result,so that only use-site &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._syntax._object%29&quot;&gt;syntax objects&lt;/a&gt; have the &lt;a href=&quot;http://docs.racket-lang.org/reference/syntax-model.html#%28tech._use._site._scope%29&quot;&gt;use-site scope&lt;/a&gt;.&lt;/blockquote&gt;&lt;p&gt;　　简单来说，在宏展开之前，各个 &lt;i&gt;identifier&lt;/i&gt; 会被打上一个特殊的标记，然后传递给 &lt;i&gt;transformer&lt;/i&gt; 进行展开，展开完成后，结果中带有该标记的去除该标记，没有的则加上。可以发现，经过这么一番处理， &lt;i&gt;transformer&lt;/i&gt; 中新引入的  &lt;i&gt;identifier&lt;/i&gt; 全部带上了该标记，而作为参数传进来的则是原封不动。Racket通过这些标记得以区分出宏展开引入的 &lt;i&gt;identifier&lt;/i&gt; ，具体参考&lt;a href=&quot;http://www.cs.utah.edu/plt/scope-sets/index.html&quot;&gt;Binding as Sets of Scopes&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;　　再看看文档中对&lt;code class=&quot;inline&quot;&gt;make-syntax-introducer&lt;/code&gt;的解释，我们发现，上面的代码其实模仿了这一过程！第一次的&lt;code class=&quot;inline&quot;&gt;introducer&lt;/code&gt;给所有的syntax objects加上了该标记，第二次则是将其反转，这样一来，&lt;code class=&quot;inline&quot;&gt;expander1&lt;/code&gt;引入的&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;就被区分开了。&lt;/p&gt;&lt;p&gt;　　那么&lt;code class=&quot;inline&quot;&gt;introducer&lt;/code&gt;前后的&lt;code class=&quot;inline&quot;&gt;syntax-local-introduce&lt;/code&gt;在这里又干了什么呢？答案很简单，因为&lt;code class=&quot;inline&quot;&gt;use-expander&lt;/code&gt;本身也是一个宏，展开前后也做了上面的操作。如果没有&lt;code class=&quot;inline&quot;&gt;syntax-local-introduce&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;expander1&lt;/code&gt;展开后&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;不带有&lt;code class=&quot;inline&quot;&gt;use-expander&lt;/code&gt;的标记，然后&lt;code class=&quot;inline&quot;&gt;use-expander&lt;/code&gt;展开结束，标记反转，&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;同时带上了&lt;code class=&quot;inline&quot;&gt;expander1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;use-expander&lt;/code&gt;的标记，根据Racket的按最大子集确定 &lt;i&gt;identifier&lt;/i&gt; 的绑定的算法，仍然有可能得到出人意料的结果。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang racket

(begin-for-syntax
  (define (apply-expander proc stx)
    (define introducer (make-syntax-introducer))
    (define intro-stx (introducer stx))
    (introducer (proc intro-stx))))

(define x &#39;(1))

(define-syntax (expander1 stx)
  (syntax-case stx ()
    [id #&#39;(id x)]))

(define-syntax (use-expander stx)
  (syntax-case stx ()
    [(_ id in)
     #`(let ([x &#39;(2)])
         #,(apply-expander (syntax-local-value #&#39;id) #&#39;in))]))

(use-expander expander1 car) ;得到2，而不是1&lt;/code&gt;&lt;p&gt;　　通过使用&lt;code class=&quot;inline&quot;&gt;syntax-local-introduce&lt;/code&gt;，我们实际上将&lt;code class=&quot;inline&quot;&gt;expander1&lt;/code&gt;当做了另一次无关的展开，排除了这种风险。&lt;/p&gt;&lt;p&gt;　　这就是Racket社区中对于xxx expander的习惯性写法。例子参见&lt;a href=&quot;https://github.com/racket/racket/blob/e819b58461b31f6e2b6cfb0aa2ab420ac682d9d9/racket/collects/racket/match/parse-helper.rkt#L169&quot;&gt;match-expander&lt;/a&gt;以及&lt;a href=&quot;https://github.com/racket/racket/blob/44eb5532adcfdc37cd5310245b7d02e0b9f97056/racket/collects/syntax/parse/private/rep.rkt#L613&quot;&gt;pattern-expander&lt;/a&gt;。&lt;/p&gt;</description>
<author>qww6</author>
<guid isPermaLink="false">2018-04-21-35953489</guid>
<pubDate>Sat, 21 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>《软件基础》中文版正式上线</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-21-35937895.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35937895&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d8bec70405d79db734aefc490425a9d5_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;《&lt;a href=&quot;https://coq-zh.github.io/SF-zh/&quot;&gt;软件基础&lt;/a&gt;》系列（英文版 &lt;a href=&quot;https://softwarefoundations.cis.upenn.edu/&quot;&gt;Software Foundations&lt;/a&gt;，主要作者 &lt;a href=&quot;http://www.cis.upenn.edu/~bcpierce/&quot;&gt;Benjamin C. Pierce&lt;/a&gt;）主要介绍了可靠软件的数学基础。书籍目前分为《逻辑基础》、《编程语言基础》和《函数式算法验证》三卷本。内容涵盖了函数式编程、逻辑基础、计算机辅助定理证明、Coq 证明助理、编程语言理论、操作语义、霍尔逻辑、静态类型系统、基础数据结构和算法的形式化验证等非常丰富的内容。&lt;/p&gt;&lt;p&gt;《软件基础》最主要的新颖之处在于，书中的每一处细节都百分之百地形式化且通过了机器验证。 每卷书中的所有文本，包括练习，根本上都是一份 Coq 证明助理的「证明脚本」。&lt;/p&gt;&lt;p&gt;本系列书籍的目标受众包括高年级本科生、研究生、博士以及研究者在内的广大读者。书中并未假定读者有逻辑学或编程语言的背景，不过熟悉一些数学对于学习来说会很有帮助。 &lt;/p&gt;&lt;p&gt;目前正在翻译的为《软件基础》系列的第一卷《逻辑基础》。网站为 Alpha 版，不少章节尚未翻译完成，因此译文中还存在着大量的错误和纰漏，欢迎广大读者&lt;a href=&quot;https://github.com/Coq-zh/SF-zh&quot;&gt;加入审校&lt;/a&gt;，发起 Issue 参与讨论并打磨斧正。&lt;/p&gt;&lt;p&gt;&lt;b&gt;注：由于本书源码库基于官方私有库翻译，网站为源码库编译生成而来，因此为避免同步合并的麻烦，我们只接受 Issue，不接受 PR。&lt;/b&gt;&lt;/p&gt;</description>
<author>Oling Cat</author>
<guid isPermaLink="false">2018-04-21-35937895</guid>
<pubDate>Sat, 21 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>命运之轮</title>
<link>https://henix.github.io/feeds/zhuanlan.marisa/2018-04-15-35699422.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35699422&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我最初学编程，应该也就是2010年左右的事情吧。&lt;/p&gt;&lt;p&gt;当时啥也不会，就会在C++吧水贴。&lt;/p&gt;&lt;p&gt;在那，听说过了有一个很厉害很潮流的东西，叫做C++11，有什么叫concept跟module的东西，好像挺厉害的样子。&lt;/p&gt;&lt;p&gt;当时，在clang上就可以用C++11了，只不过这两功能还没有，就有auto, lambda, constexpr 不知道有没有（记不清了），也很好了。&lt;/p&gt;&lt;a href=&quot;https://www.zhihu.com/question/56943731&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;时间快进到现在，这两功能还是没加进去。&lt;/a&gt;&lt;p&gt;不过C++厨们可以稍稍放心，我今天不是来黑C++的。&lt;/p&gt;&lt;p&gt;这固然是C++的悲剧，不过也是所有语言的悲剧。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果去看历史，去看看一个个语言的发展，我们会发现一个规律：&lt;/p&gt;&lt;p&gt;&lt;b&gt;语言/语言家族的发展，是不停的扩大，直到无法支撑自身的重量而倒下为止。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;让我们跳到1958。&lt;/p&gt;&lt;p&gt;ALGOL。&lt;/p&gt;&lt;p&gt;只要大家说计算机历史，就一定要说ALGOL。&lt;/p&gt;&lt;p&gt;因为这可以说是一切的开端。也是一门伟大的语言。&lt;/p&gt;&lt;p&gt;做Algol相关的work的图灵奖得主，足足有6个：John Backus，Alan Perlis，Peter Naur，John McCarthy，Edsger W. Dijkstra，Tony Hoare。还有无冕之王，Peter Landin跟John Reynold。&lt;/p&gt;&lt;p&gt;但是，为何这么成功的语言，却默默无名？因为错在了下一步。&lt;/p&gt;&lt;p&gt;在1960后，ALGOL推出了ALGOL 58，ALGOL 60，还有各种方言后，大家开始慢慢懂该怎么设计语言，实现编译器了。BNF，Recursion，Continuation，Stack，都慢慢被大家发明发现，慢慢熟悉。大家也开始发现了ALGOL 60没做好跟没有做的东西。&lt;/p&gt;&lt;p&gt;于是，1962起，大家开始发明一门新的，叫ALGOL X的语言，旨在把这些问题修好。从1962起讨论，一直到1965，变成一个draft。高兴的ALGOL厨把这叫做ALGOL W，并且等着用了。一切就差一些小修小补了。&lt;/p&gt;&lt;p&gt;就跟物理学大厦就剩下两朵乌云一样。&lt;/p&gt;&lt;p&gt;快进半年。另外一个ALGOL W的draft被奉上。情况不容乐观。&lt;/p&gt;&lt;p&gt;本来说好的三个月，跳票成了半年不说，draft变得更厚更长，问题反而越来越多。于是说在等三个月，我们再修修。&lt;/p&gt;&lt;p&gt;明明说三月，三月后又三月，三月后又三月，都快一年了。&lt;/p&gt;&lt;p&gt;拖了9个月后，在1968年尾，一个叫ALGOL W的，连设计者也不爱的怪兽产生了。&lt;/p&gt;&lt;p&gt;自此，ALGOL被命运之轮碾过。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;故事的另一个主角，则知名得多。CPL。&lt;/p&gt;&lt;p&gt;这是1963，离悲剧还远得很，这时候大家都已自己是ALGOL方言为荣。&lt;/p&gt;&lt;p&gt;CPL就是一个ALGOL方言，旨在做更底层的ALGOL。&lt;/p&gt;&lt;p&gt;语言的设计也不算很复杂，唯一的问题就是不知道为啥，编译器死活写不出来。&lt;/p&gt;&lt;p&gt;于是，1967，有人在想，为何我们不把CPL简化点？这样就能做出编译器来了。&lt;/p&gt;&lt;p&gt;然后就出现了BCPL。同年，BCPL的编译器也被实现了。&lt;/p&gt;&lt;p&gt;两年后，为了把BCPL放上微型机，再次简化，出现了B。&lt;/p&gt;&lt;p&gt;同时间，B的一些问题被发现，效率也不够高，于是一个差不多的语言开始被设计，C。&lt;/p&gt;&lt;p&gt;而在C设计过程中，1970年，CPL的编译器终于面世。&lt;/p&gt;&lt;p&gt;命运之轮碾压过ALGOL，再碾压过CPL，碾压一次不够再碾压一次，BCPL，最后出了B，然后造就了C。最大赢家。&lt;/p&gt;&lt;p&gt;之后的，就是历史。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;不过，这不是结束。也不是结束的开始。顶多是开始的结束。&lt;/p&gt;&lt;p&gt;还记得最开头的C++吗？没错，命运之轮怎么会放过C。&lt;/p&gt;&lt;p&gt;在C++后，为了简化，出现了JAVA，旨在消除C++的各种复杂性-比如不区分unsigned啊，自动管理内存啊，只有Class啊-只不过，到了最后，还是照样该变大变大。自动管理内存的确比手动简单，但是JVM确变成一个怪兽。就连unsigned这种小东西，&lt;a href=&quot;https://www.zhihu.com/question/39596383/answer/82267124&quot;&gt;也回到语言中了。&lt;/a&gt;屠龙的勇士，必成恶龙。&lt;/p&gt;&lt;p&gt;另外一边，PERL崩溃之后诞生的Python也一样，，不知道怎么的，就加入了optional static typing。。。说好的only one way呢？Simplicity呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;专门搞PL的人别偷笑，Scala就不说了，Haskell也一样，GHC无比复杂，连RecursiveDo都能水一篇&lt;a href=&quot;https://pdfs.semanticscholar.org/20ab/57bf6d14d6a08a950b015d17af5f41b1b22b.pdf&quot;&gt;170页的Paper&lt;/a&gt;，有一个minimal core，也不能解决这问题。也别以为Macro能解决问题-R6RS总共有187页，其中，有90页是语言定义。被称为怪兽的ALGOL W也就265页，实在差不了多少。ALGOL 60呢？17页。ALGOL 58则只有15页。不过R7RS倒是还行，只有77页。当然，这是以丢掉向后兼容性为代价的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;有没有语言试图挑战这命运之轮？&lt;/p&gt;&lt;p&gt;有。Scheme，Python，都壮士断腕，丢掉了向后兼容性。自己不丢，别人就会给你丢。&lt;/p&gt;&lt;p&gt;Go也算是，Rob Pike活了60年，啥大风大浪没见过，尤其是Google的Build Server再也撑不起他们的C++，当然知道复杂度乃洪水猛兽-要不然为啥死撑不肯加generic。&lt;/p&gt;&lt;p&gt;不过这几个付出的代价不少-不是兼容性就是限制自己发展。对于语言设计者来说，这是个绕不开的问题。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;回到最初。为什么C++的concept module老是跳票，总共跳了9年？&lt;/p&gt;&lt;p&gt;还记得ALGOL W有多少页吗？265。至于C++17，1600多。6个ALGOL W，100个ALGOL 58。能让人大呼卧槽的数字。Java标准700页，加上JVM，也有1300页。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;于是隔几天，我跟朋友吃饭的时候提起，卧槽，现在的编程语言复杂度都变成鬼了，100个ALGOL。这么复杂，怎么设计怎么写编译器。&lt;/p&gt;&lt;p&gt;我那在nvidia实习的朋友听了，不以为然的说了声，哦。直到我过了半年，上了门计算机架构的课，才明白为什么他没有被震惊到。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其实PL的复杂度爆炸还算好的了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>圆角骑士魔理沙</author>
<guid isPermaLink="false">2018-04-15-35699422</guid>
<pubDate>Sun, 15 Apr 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
