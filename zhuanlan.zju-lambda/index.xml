<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>ZJU Lambda</title>
<link>https://henix.github.io/feeds/zhuanlan.zju-lambda/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Mon, 12 Feb 2018 16:29:22 +0800</lastBuildDate>
<item>
<title>Haskell 中的“定理证明”</title>
<link>https://henix.github.io/feeds/zhuanlan.zju-lambda/2017-11-30-31567423.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31567423&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-24cc9824870cdcc4194b2c0ec0097d23_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;题图：鲸 | 花生( •̀ ω •́ ) [pixiv] &lt;a href=&quot;https://www.pixiv.net/member_illust.php?mode=medium&amp;amp;illust_id=66023124&quot;&gt;https://www.pixiv.net/member_illust.php?mode=medium&amp;amp;illust_id=66023124&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;这篇文章讲了什么&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;i&gt;这是一篇休闲向文章&lt;/i&gt;&lt;/p&gt;&lt;p&gt;总结了 Codewars 上面的几道证明题的思想并加以延拓，希望读者能在看完这篇文章之前/之后解决练习中的题目。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下面是正文&lt;/p&gt;&lt;hr&gt;&lt;p&gt;众所周知，Haskell 并没有真正意义上的 dependent type，但通过一些技巧 （利用GADT）可以“模拟”dependent type，并可以通过其证明一些定理。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;利用 GADT 模拟 Dependent Type&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先我们需要作为&lt;b&gt;值&lt;/b&gt;的类型&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Z
 data S n&lt;/code&gt;&lt;p&gt;注意到，这里的 &lt;code class=&quot;inline&quot;&gt;Z&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;n 都只是单纯的类型，你甚至不能构造出相应类型的值出来。&lt;/p&gt;&lt;p&gt;所以我们需要把它们与实际存在的值联系起来&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Nat a where
      Zero :: Nat Z
      Succ :: Nat a -&amp;gt; Nat (S a)&lt;/code&gt;&lt;p&gt;于是我们有&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  (Succ Zero) :: Nat (S Z)
  (Succ (Succ Zero)) :: Nat (S (S Z))&lt;/code&gt;&lt;p&gt;这样我们获得了在类型层次上的自然数，并保持了它与实际的值的同构关系。&lt;/p&gt;&lt;p&gt;光有自然数是没有意义的，我们需要赋予它们运算的能力。&lt;/p&gt;&lt;p&gt;那么 &lt;code class=&quot;inline&quot;&gt;Nat n&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;Nat m&lt;/code&gt; 相加的结果应该是什么呢？&lt;/p&gt;&lt;p&gt;首先它应该是一个 &lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt; ，其次它的类型应该对应于两数相加的结果。&lt;/p&gt;&lt;p&gt;借助于 GHC 的 Type Family 与 Type Operator 扩展，我们可以定义出 合理的 类型层面上的自然数的加法与乘法&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  type family (:+:) (n :: *) (m :: *) :: *
  type instance Z   :+: m = m
  type instance S n :+: m = S (n :+: m)
  
  type family (:*:) (n :: *) (m :: *) :: *
  type instance Z   :*: m = Z
  type instance S n :*: m = m :+: (n :*: m)&lt;/code&gt;&lt;p&gt;然后是数据层面的自然数&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  infixl 4 +
  (+) :: Nat n -&amp;gt; Nat m -&amp;gt; Nat (n :+: m)
  Zero + a = a
  (Succ x) + a = Succ (x + a)
  
  infixl 5 *
  (*) :: Nat n -&amp;gt; Nat m -&amp;gt; Nat (n :*: m)
  Zero * _ = Zero
  (Succ x) * m = m + x * m&lt;/code&gt;&lt;p&gt;有&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  (Succ (Succ Zero)) * (Succ (Succ Zero)) :: Nat (S (S (S (S Z))))&lt;/code&gt;&lt;p&gt;基于类型上的自然数，我们可以定义 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; (在类型中包含了长度信息的 &lt;code class=&quot;inline&quot;&gt;List&lt;/code&gt;)了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  data Vec a n where
      VNil :: Vec a Z
      VCons :: a -&amp;gt; Vec a n -&amp;gt; Vec a (S n)&lt;/code&gt;&lt;p&gt;长度为 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 与长度为 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 连接起来之后的长度为 &lt;code class=&quot;inline&quot;&gt;n + m&lt;/code&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  (++) :: Vec a n -&amp;gt; Vec a m -&amp;gt; Vec a (n :+: m)
  VNil ++ ys = ys
  VCons x xs ++ y = VCons x (xs ++ y)&lt;/code&gt;&lt;p&gt;把长度为 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 重复 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 次之后得到的 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 的长度为 &lt;code class=&quot;inline&quot;&gt;n * m&lt;/code&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  repeat :: Nat n -&amp;gt; Vec a m -&amp;gt; Vec a (n :*: m)
  repeat Zero _ = VNil
  repeat (Succ x) xs = xs ++ repeat x xs&lt;/code&gt;&lt;p&gt;有了长度信息，就有类型安全的 &lt;code class=&quot;inline&quot;&gt;head&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;tail&lt;/code&gt; 了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  headV :: Vec a (S n) -&amp;gt; a
  headV (VCons x _) = x
  
  tailV :: Vec a (S n) -&amp;gt; Vec a n
  tailV (VCons _ xs) = xs&lt;/code&gt;&lt;p&gt;因为 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 作为 GADT 的类型在这里受到了第二个类型参数为 &lt;code class=&quot;inline&quot;&gt;S n&lt;/code&gt; 的束缚，所以可以保证这里的 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 不会是 &lt;code class=&quot;inline&quot;&gt;VNil&lt;/code&gt; ，这两个函数都是 &lt;b&gt;完全&lt;/b&gt; 的。&lt;/p&gt;&lt;p&gt;借鉴之前定义类型层面上自然数的加法与乘法的思想，我们可以定义相应的减法、求最大值、最小值等。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  type family (:-:) (n :: *) (m :: *) :: *
  type instance n :-: Z = n
  type instance Z :-: m = Z
  type instance S n :-: S m = n :-: m
  
  type family (:^:) (n :: *) (m :: *) :: *
  type instance Z :^: n = n
  type instance n :^: Z = n
  type instance S n :^: S m = S (n :^: m)
  
  type family (:~:) (n :: *) (m :: *) :: *
  type instance Z :~: m = Z
  type instance n :~: Z = Z
  type instance S n :~: S m = S (n :~: m)&lt;/code&gt;&lt;p&gt;(这里使用了 &lt;code class=&quot;inline&quot;&gt;:~:&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;:^:&lt;/code&gt; 分别代表求最大值和最小值)&lt;/p&gt;&lt;p&gt;于是有&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  zip :: Vec a n -&amp;gt; Vec b m -&amp;gt; Vec (a, b) (n :~: m)
  zip VNil _ = VNil
  zip _ VNil = VNil
  zip (VCons x xs) (VCons y ys) = VCons (x, y) (zip xs ys)&lt;/code&gt;&lt;h2&gt;&lt;b&gt;进行简单的定理证明&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Haskell&lt;/code&gt; 中没有 Prop ，所以我们得从头开始描述“相等”这个概念。&lt;/p&gt;&lt;p&gt;首先定义代表两个类型层面的自然数相等的类型&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Equal a b where
      EqZ :: Equal Z Z
      EqS :: Equal a b -&amp;gt; Equal (S a) (S b)&lt;/code&gt;&lt;p&gt;借助于 Type Operator 我们可以写成&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; type a === b = Equal a b&lt;/code&gt;&lt;p&gt;相等关系具有自反性&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  refl :: Nat n -&amp;gt; n === n
  refl Zero = EqZ
  refl (Succ x) = EqS $ refl x&lt;/code&gt;&lt;p&gt;相等关系具有对称性&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  symm :: a === b -&amp;gt; b === a
  symm EqZ = EqZ
  symm (EqS x) = EqS $ symm x&lt;/code&gt;&lt;p&gt;相等关系具有传递性&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  (&amp;lt;=&amp;gt;) :: a === b -&amp;gt; b === c -&amp;gt; a === c
  EqZ &amp;lt;=&amp;gt; EqZ = EqZ
  EqS x &amp;lt;=&amp;gt; EqS y = EqS $ x &amp;lt;=&amp;gt; y&lt;/code&gt;&lt;p&gt;因为 Type Operator 也能定义优先级，所以下面给出：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  infixl 2 ===
  infixl 4 :+:
  infixr 4 :-:
  infixl 5 :*:&lt;/code&gt;&lt;p&gt; 来减少括号的个数&lt;/p&gt;&lt;h2&gt;加法结合律&lt;/h2&gt;&lt;p&gt;那么我们来试着证明一下加法的结合律&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  plusComb :: Nat n -&amp;gt; Nat m -&amp;gt; Nat p -&amp;gt; n :+: (m :+: p) === n :+: m :+: p&lt;/code&gt;&lt;p&gt;我们对 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 进行归纳：&lt;/p&gt;&lt;p&gt; 当 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 为 0 的时，在加法中的 0 会直接消除，所以使用 &lt;code class=&quot;inline&quot;&gt;refl (m + p)&lt;/code&gt; 就好了；&lt;/p&gt;&lt;p&gt; 当 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;S n1&lt;/code&gt; 时，把等式两边的 S 用 &lt;code class=&quot;inline&quot;&gt;EqS&lt;/code&gt; 提取出来，再使用归纳假设就可以了：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  plusComb :: Nat n -&amp;gt; Nat m -&amp;gt; Nat p -&amp;gt; n :+: (m :+: p) === n :+: m :+: p
  plusComb Zero p q = refl (p + q)
  plusComb (Succ n) m p = EqS $ plusComb n m p&lt;/code&gt;&lt;h2&gt;加法交换律&lt;/h2&gt;&lt;p&gt;那么再尝试一下稍微困难一点的加法交换律吧&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  plusCommutes :: Nat n -&amp;gt; Nat m -&amp;gt; n :+: m === m :+: n&lt;/code&gt;&lt;p&gt;当 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 为 0 的时，证明很平凡。我们需要的是这么一个类型：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  Nat n -&amp;gt; n :+: Z === n&lt;/code&gt;&lt;p&gt;只需要对 n 进行归纳就好了。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  nPlusZero :: n === n -&amp;gt; n === n :+: Z
  nPlusZero EqZ        = EqZ
  nPlusZero (EqS eq) = EqS $ nPlusZero eq&lt;/code&gt;&lt;p&gt;当 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;S m1&lt;/code&gt; 时，我们需要的东西的类型为&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  (n :+: S m1) === S (m1 :+: n)&lt;/code&gt;&lt;p&gt;根据归纳法，我们可以得到&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;EqS (plusCommutes n m1) :: S (m1 :+: n) === S (n :+: m1)&lt;/code&gt;&lt;p&gt;借助于相等关系的传递性，目标变成了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; (n :+: S m1) === S (n :+: m1)&lt;/code&gt;&lt;p&gt;而这个命题的证明也只需要对 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 进行归纳&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  nPlusSm :: Nat n -&amp;gt; Nat m -&amp;gt; n :+: S m === S (n :+: m)
  nPlusSm Zero      m = EqS $ refl m
  nPlusSm (Succ n) m = EqS $ nPlusSm n m&lt;/code&gt;&lt;p&gt;把这些步骤拼起来，就得到了我们最终的证明&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  plus2 :: Nat n -&amp;gt; Nat m -&amp;gt; n :+: m === m :+: n
  plus2 n Zero = symm $ nPlusZero $ refl n
  plus2 n (Succ m) = nPlusSm n m &amp;lt;=&amp;gt; symm (EqS $ plus2 m n)&lt;/code&gt;&lt;h2&gt;乘法交换律&lt;/h2&gt;&lt;p&gt;看了加法我们再来看乘法&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; multCommute :: Nat n -&amp;gt; Nat m -&amp;gt; n :*: m === m :*: n&lt;/code&gt;&lt;p&gt;证明的方法和加法几乎一样，仍然从归纳法入手，对 n 进行归纳。中间需要用到一些引理，比如&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  multCommuteS :: Nat n -&amp;gt; Nat m -&amp;gt; m :*: S n === m :+: m :*: n
  plusSwap :: Nat a -&amp;gt; Nat b -&amp;gt; Nat c -&amp;gt; a :+: (b :+: c) === b :+: (a :+: c)&lt;/code&gt;&lt;p&gt;等等，这里不再详细说明具体的推导，直接给出实现，有兴趣的同学可以试着自己写一遍&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; equalPlus :: Nat a -&amp;gt; Nat b -&amp;gt; a === b -&amp;gt; Nat c -&amp;gt; a :+: c === b :+: c
 equalPlus a b eq Zero = symm (nPlusZero a) &amp;lt;=&amp;gt; eq &amp;lt;=&amp;gt; nPlusZero b
 equalPlus a b eq (Succ c) = nPlusSm a c &amp;lt;=&amp;gt; Fuck (equalPlus a b eq c) &amp;lt;=&amp;gt; symm (nPlusSm b c)
  
 equalPlus&#39; :: Nat a -&amp;gt; Nat b -&amp;gt; a === b -&amp;gt; Nat c -&amp;gt; c :+: a === c :+: b
 equalPlus&#39; a b eq c = plusCommutes c a &amp;lt;=&amp;gt; equalPlus a b eq c &amp;lt;=&amp;gt; plusCommutes b c
  
 plusSwap&#39; :: Nat a -&amp;gt; Nat b -&amp;gt; Nat c -&amp;gt; a :+: b :+: c === b :+: a :+: c
 plusSwap&#39; a b = equalPlus (a + b) (b + a) (plusCommutes a b)
  
 plusSwap :: Nat a -&amp;gt; Nat b -&amp;gt; Nat c -&amp;gt; a :+: (b :+: c) === b :+: (a :+: c)
 plusSwap a b c = plusCommute a b c &amp;lt;=&amp;gt; plusSwap&#39; a b c &amp;lt;=&amp;gt; symm (plusCommute b a c)
  
 multCommuteS_1 :: Nat n -&amp;gt; Nat m -&amp;gt; n :+: (m :*: S n) === m :+: (n :+: (m :*: n))
 multCommuteS_1 n m = equalPlus&#39; (m * Succ n) (m + m * n) (multCommuteS n m) n &amp;lt;=&amp;gt; plusSwap n m (m * n)
  
 multCommuteS :: Nat n -&amp;gt; Nat m -&amp;gt; m :*: S n === m :+: m :*: n
 multCommuteS _ Zero = Refl
 multCommuteS n (Succ m) = Fuck $ multCommuteS_1 n m
  
 multCommutes :: Nat n -&amp;gt; Nat m -&amp;gt; n :*: m === m :*: n
 multCommutes Zero m = symm $ multNZero m
 multCommutes (Succ n) m = symm
      (multCommuteS n m &amp;lt;=&amp;gt; equalPlus&#39; (m * n) (n * m) (multCommutes m n) m)&lt;/code&gt;&lt;h2&gt;&lt;b&gt;从自然数说开去&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们在上面定义的“相等”中，只对自然数进行了规定，那么我们怎么表示任何一种东西相等的概念呢？我们需要对 &lt;code class=&quot;inline&quot;&gt;Equal&lt;/code&gt; 进行修改。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Equal a b where
      Refl :: Equal a a
      Derive :: Equal a b -&amp;gt; Equal (p a) (p b)&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; 对应之前的 &lt;code class=&quot;inline&quot;&gt;EqZ&lt;/code&gt; , &lt;code class=&quot;inline&quot;&gt;Derive&lt;/code&gt; 对应 &lt;code class=&quot;inline&quot;&gt;EqS&lt;/code&gt; 。从定义上我们就能知道相等关系的自反性。&lt;/p&gt;&lt;p&gt;重新定义之后，我们就再也不需要 &lt;code class=&quot;inline&quot;&gt;refl&lt;/code&gt; 这个函数了，因为直接使用 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; 就可以了。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;symm&lt;/code&gt; 的定义和原来类似，&lt;code class=&quot;inline&quot;&gt;trans&lt;/code&gt; 则需要一点小小的修改：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; (&amp;lt;=&amp;gt;) :: a === b -&amp;gt; b === c -&amp;gt; a === c
 Refl        &amp;lt;=&amp;gt; Refl        = Refl
 Derive x &amp;lt;=&amp;gt; Refl        = Derive $ x      &amp;lt;=&amp;gt; Refl
 Refl        &amp;lt;=&amp;gt; Derive y = Derive $ Refl &amp;lt;=&amp;gt; y
 Derive x &amp;lt;=&amp;gt; Derive y = Derive $ x      &amp;lt;=&amp;gt; y&lt;/code&gt;&lt;p&gt;为了证明我们定义的 &lt;code class=&quot;inline&quot;&gt;Equal&lt;/code&gt; 不仅仅对自然数有用，我们引入了类型层面的 &lt;code class=&quot;inline&quot;&gt;Bool&lt;/code&gt; 来增加多样性。&lt;/p&gt;&lt;p&gt;首先是类型定义&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data T
data F&lt;/code&gt;&lt;p&gt;然后是对应的数据类型&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Boolean :: * -&amp;gt; * where
      Tr :: Boolean T
      Fa :: Boolean F&lt;/code&gt;&lt;p&gt;对于每一个需要参与证明的函数，我们需要在类型上实现一遍。&lt;/p&gt;&lt;p&gt;对于 &lt;code class=&quot;inline&quot;&gt;Boolean&lt;/code&gt; 而言，先实现与或非 &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; type family Inv (n :: *) :: *
 type instance Inv T = F
 type instance Inv F = T
  
 type family (||) (n :: *) (m :: *) :: *
 type instance T || T = T
 type instance F || T = T
 type instance T || F = T
 type instance F || F = F
  
 type family (&amp;amp;&amp;amp;) (n :: *) (m :: *) :: *
 type instance T &amp;amp;&amp;amp; T = T
 type instance T &amp;amp;&amp;amp; F = F
 type instance F &amp;amp;&amp;amp; T = F
 type instance F &amp;amp;&amp;amp; F = F&lt;/code&gt;&lt;p&gt;首先证明双重否定律&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  doubleNeg :: Boolean b -&amp;gt; Inv (Inv b) === b
  doubleNeg Tr = Refl
  doubleNeg Fa = Refl&lt;/code&gt;&lt;p&gt;要注意的是，这里并不能把两个分支合在一起写，因为它并不能直接把 &lt;code class=&quot;inline&quot;&gt;Inv (Inv b)&lt;/code&gt; 推导到 &lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;&lt;/p&gt;&lt;p&gt;然后是德摩根律&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; demorgan :: Boolean a -&amp;gt; Boolean b -&amp;gt; Inv (a &amp;amp;&amp;amp; b) === Inv a || Inv b
 demorgan Tr Tr = Refl
 demorgan Tr Fa = Refl
 demorgan Fa Tr = Refl
 demorgan Fa Fa = Refl&lt;/code&gt;&lt;p&gt;仍然要进行详细的分类讨论，理由同上&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;同样的，我们还能利用 Type Family 描述一些性质 ，比如自然数的奇偶性&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; type family IsOdd (n :: *) :: *
 type instance IsOdd Z = F
 type instance IsOdd (S Z) = T
 type instance IsOdd (S (S n)) = IsOdd n
  
 type family IsEven (n :: *) :: *
 type instance IsEven Z = T
 type instance IsEven (S Z) = F
 type instance IsEven (S (S n)) = IsEven n&lt;/code&gt;&lt;p&gt;试着证明一下：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus :: Nat n -&amp;gt; Nat m -&amp;gt; IsOdd (n :+: m) === IsOdd n ^ IsOdd m&lt;/code&gt;&lt;p&gt;因为 &lt;code class=&quot;inline&quot;&gt;IsEven&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;IsOdd&lt;/code&gt; 的递归定义中都有两层的预设，所以我们在用归纳法证明时也需要考虑相应的 3 种情况&lt;/p&gt;&lt;ol&gt;&lt;li&gt;当 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;Z&lt;/code&gt; 时&lt;/li&gt;&lt;/ol&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus Zero m :: IsOdd m === (F ^ IsOdd m)&lt;/code&gt;&lt;p&gt;只需要实现这两个函数（它们的实现都是平凡的）&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; falseXor :: Boolean b -&amp;gt; b === F ^ b
 isodd :: Nat a -&amp;gt; Boolean (IsOdd a)&lt;/code&gt;&lt;p&gt;就有&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus Zero x = falseXor $ isodd x&lt;/code&gt;&lt;ol&gt;&lt;li&gt;当 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;S Z&lt;/code&gt; 时&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;对 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 进行归纳，当 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;Z&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;S Z&lt;/code&gt; 时，结果就是 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; ，而当 &lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;S (S m&#39;)&lt;/code&gt; 时，我们需要的类型为&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus (Succ Zero) (Succ (Succ x)) :: IsOdd (S n3) === (T ^ IsOdd n3)&lt;/code&gt;&lt;p&gt;同样的，只需要把它拎出去，用归纳法再证一遍就好了&lt;/p&gt;&lt;ol&gt;&lt;li&gt;当 &lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;S (S n&#39;)&lt;/code&gt; 时&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们需要的类型为：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus (Succ (Succ x)) y :: IsOdd (n2 :+: m) === (IsOdd n2 ^ IsOdd m)&lt;/code&gt;&lt;p&gt;利用归纳假设就能直接证明了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddPlus (Succ (Succ x)) y = oddPlus x y&lt;/code&gt;&lt;h2&gt;&lt;b&gt;还有什么？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;注意到我们的很多证明，实际上都只是在类型层面的变化。比如下面这个&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; oddEvenS :: Nat n -&amp;gt; IsOdd n === IsEven (S n)
 oddEvenS Zero = Refl
 oddEvenS (Succ Zero) = Refl
 oddEvenS (Succ (Succ x)) = oddEvenS x&lt;/code&gt;&lt;p&gt;把递归展开的话就能发现它所有情况下的 “值” 都是 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; ，但我们不能直接对所有的情况赋 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; ，因为这个递归是对 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; 上的类型进行修改的过程。类型推导不会对 Type Family 中的递归定义进行展开，所以我们还是得自己动手证明一遍。&lt;/p&gt;&lt;h2&gt;“性质” 的表示方法&lt;/h2&gt;&lt;p&gt;我们使用了 &lt;code class=&quot;inline&quot;&gt;Equal&lt;/code&gt; 表示两个类型相等的概念，那么同样的，我们还可以用这种方法描述其它的一元/二元/多元关系，比如我们可以换一种方式表示奇偶性：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Even :: * -&amp;gt; * where
      ZeroEven :: Even Z
      Add2Even :: Even n -&amp;gt; Even (S (S n))
  
data Odd :: * -&amp;gt; * where
      OneOdd :: Odd (S Z)
      Add2Odd :: Odd n -&amp;gt; Odd (S (S n))&lt;/code&gt;&lt;p&gt;或者描述两个自然数的大小关系：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Greater :: * -&amp;gt; * where
      GreZ :: Greater (S Z) Z
      GreS1 :: Greater x y -&amp;gt; Greater (S x) y
      GreS2 :: Greater x y -&amp;gt; Greater (S x) (S y)&lt;/code&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Derive&lt;/code&gt; 的局限&lt;/h2&gt;&lt;p&gt;事实上，我们在 &lt;code class=&quot;inline&quot;&gt;Equal&lt;/code&gt; 中定义的 &lt;code class=&quot;inline&quot;&gt;Derive&lt;/code&gt; 并不是万能的，比如我们不能这样&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; deriveOdd :: Nat n -&amp;gt; n === m -&amp;gt; IsOdd n === IsOdd m
 deriveOdd _ eq = Derive eq -- wrong !&lt;/code&gt;&lt;p&gt;报错信息为&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;Couldn&#39;t match type ‘IsOdd n’ with ‘p0 n’
      Expected type : IsOdd n === IsOdd m
      Actual   type    : p0 n === p0 m&lt;/code&gt;&lt;p&gt;它只能对字面量进行推导，比如&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; deriveS :: n === m -&amp;gt; S n === S m&lt;/code&gt;&lt;h2&gt;&lt;b&gt;练习&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;你现在应该可以解决下面几道题目&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.codewars.com/kata/singletons&quot;&gt;https://www.codewars.com/kata/singletons&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.codewars.com/kata/odd-plus-even-equals-odd-prove-it&quot;&gt;https://www.codewars.com/kata/odd-plus-even-equals-odd-prove-it&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.codewars.com/kata/a-plus-b-equals-b-plus-a-prove-it&quot;&gt;https://www.codewars.com/kata/a-plus-b-equals-b-plus-a-prove-it&lt;/a&gt;&lt;/p&gt;&lt;p&gt;最后一道题证明的是加法交换律，除了文中给出的方法，还有一种更精妙的写法，读者可以试着找一找&lt;/p&gt;&lt;h2&gt;更多练习&lt;/h2&gt;&lt;p&gt;证明乘法交换律&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; multCommute :: Nat n -&amp;gt; Nat m -&amp;gt; Nat p -&amp;gt; n :*: m :*: p === n :*: (m :*: p)&lt;/code&gt;&lt;p&gt;以及更多你能想到的东西&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>zjuwyd</author>
<guid isPermaLink="false">2017-11-30-31567423</guid>
<pubDate>Thu, 30 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Lens: 从入门到再次入门</title>
<link>https://henix.github.io/feeds/zhuanlan.zju-lambda/2017-11-24-31328798.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31328798&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-28c51979d43ba132a98057d07b183025_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;类型补全计画&lt;/h2&gt;&lt;p&gt;从上一篇我们可以看出，Lens 就是整合在一起的 &lt;code class=&quot;inline&quot;&gt;Getter&lt;/code&gt;和 &lt;code class=&quot;inline&quot;&gt;Setter&lt;/code&gt;，借助&lt;code class=&quot;inline&quot;&gt;set&lt;/code&gt;&lt;i&gt;, &lt;/i&gt;&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;&lt;i&gt;, &lt;/i&gt;&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;这三个函数，我们可以分别使用 Lens 的&lt;code class=&quot;inline&quot;&gt;Getter&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;Setter&lt;/code&gt;。但是我们目前的 Lens 类型定义并不是完整的，因此我们首先对 Lens 的类型进行补全。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens s a = Functor f =&amp;gt; (a -&amp;gt; f a) -&amp;gt; (s -&amp;gt; f s)&lt;/code&gt;&lt;p&gt;首先让我们看这样一个例子： &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;set _1 ((1,2),3) 3
set _1 ((1,2),3) True&lt;/code&gt;&lt;p&gt;在我们目前的类型定义上面的代码第一行可以正常工作，而第二行则不可以。但是第二行确实是合乎逻辑的，我们的确有时候需要讲一个原本是数字的地方设置为布尔值或是其他的什么东西。&lt;/p&gt;&lt;p&gt;让我们将原先的 Lens 类型定义进行简单的改变，这样就可以在通过 Lens 对数据操作时改变数据的类型。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens s t a b = Functor f =&amp;gt; (a -&amp;gt; f b) -&amp;gt; (s -&amp;gt; f t)&lt;/code&gt;&lt;p&gt;我们可以可以直观地解读这个新的类型定义的含义，对&lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt;类型的量的一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;类型的域进行某种操作，之后该域变为&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;，相应的&lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt;变为&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;。当然这里的&lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;t&lt;/code&gt;的关系并不是随意的，而是依赖于&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;的关系。&lt;/p&gt;&lt;p&gt;现在我们之前使用的 Lens 类型将定义如下：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens&#39; s a = Lens s s a a
-- Or
{-# LANGUAGE LiberalTypeSynonyms #-}
type Simple f a b = f a a b b
type Lens&#39; = Simple Lens &lt;/code&gt;&lt;p&gt;在这个定义下我们可以定义出由&lt;code class=&quot;inline&quot;&gt;getter&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;setter&lt;/code&gt;构建 Lens 的函数&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;lens :: (s -&amp;gt; a) -&amp;gt; (s -&amp;gt; b -&amp;gt; t) -&amp;gt; Lens s t a b
lens getter setter f s = setter s &amp;lt;$&amp;gt; f (getter s)&lt;/code&gt;&lt;p&gt;下面让我们来回忆一下&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;的定义&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;over lens f = runIdentity . lens (Identity . f)
view lens b = getConst $ lens Const b &lt;/code&gt;&lt;p&gt;我们发现在&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;分别取&lt;code class=&quot;inline&quot;&gt;Identity&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;Const&lt;/code&gt;的时候，Lens 就分别表现出了 &lt;code class=&quot;inline&quot;&gt;Setter&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;Getter&lt;/code&gt;的特性。对于&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;而言，他们只需要使用单一的 Functor ，因此我们可以专门定义&lt;code class=&quot;inline&quot;&gt;Getter&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;Setter&lt;/code&gt;的类型。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Getting r s a = (a -&amp;gt; Const r a) -&amp;gt; s -&amp;gt; Const r s
type Setter s t a b = (a -&amp;gt; Identity b) -&amp;gt; s -&amp;gt; Identity t
type Setting = Simple Setter &lt;/code&gt;&lt;p&gt;在有了这个定义之后，我们就可以修改之前三个常用函数的类型签名：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view :: Getting a s a -&amp;gt; s -&amp;gt; a
over :: Setter s t a b -&amp;gt; (a -&amp;gt; b) -&amp;gt; s -&amp;gt; t
set  :: Setter s t a b -&amp;gt; b -&amp;gt; s -&amp;gt; t&lt;/code&gt;&lt;p&gt;这样的改变看似没有什么作用，但通过这样的改变，三个常用函数不再以 Lens 为作用对象，而是更加聚焦于一类更加通用的类型。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;作为概念积类型的类型与作为概念的值&lt;/h2&gt;&lt;p&gt;通过之前的例子，我们可以看到我们用 Lens 来操作一个&lt;b&gt;积类型(Product Type)&lt;/b&gt;，例如元组、Record ；于此相对，Lens 不能用来操作&lt;b&gt;和类型(Sum Type)&lt;/b&gt;。我们可以用 Lens 改变或是读取积类型的某个&lt;b&gt;部分(Component)&lt;/b&gt;的值。但是实际上，我们不需要一个&lt;b&gt;实在的&lt;/b&gt;积类型，也不需要一个实在的部分，只需要概念上的积类型与概念上的部分即可。这样的表述显得非常抽象，让我们来看几个例子。&lt;/p&gt;&lt;p&gt;第一个例子是列表，我们将要操作的不是列表的元素这些实在的部分，而是抽象的部分，&lt;b&gt;列表的长度&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;让我们定义这个玄乎的&lt;code class=&quot;inline&quot;&gt;_length&lt;/code&gt;Lens ：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;_length :: Lens&#39; [a] Int
_length f l = const l &amp;lt;$&amp;gt; f (length l)&lt;/code&gt;&lt;p&gt;可以看出，它可以从一个列表中提取出它的长度，但是不会改变它的长度&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view (_1._length) (&quot;hello&quot;, 3)
--&amp;gt; 5
set (_1._length) 9 (&quot;world&quot;, 3) 
--&amp;gt; (&quot;world&quot;,3)&lt;/code&gt;&lt;p&gt;在这个例子中，长度并不是列表的一个实在的部分，我们操作的积类型也不是一个实在的积类型，而是概念中的某种包含长度的积类型。&lt;/p&gt;&lt;p&gt;再看第二个例子，我们操作一个数字的绝对值。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;_abs :: (Num a, Ord a) =&amp;gt; Lens&#39; a a
_abs f i = setabs &amp;lt;$&amp;gt; f (abs i)
  where sgn x
            | x &amp;gt;= 0 = 1
            | x &amp;lt;  0 = -1
        setabs x
               | x &amp;gt;= 0 = x*sgn i
               | x &amp;lt;  0 = error &quot;Abs must be non-negative&quot;
view _abs -123
--&amp;gt; 123
set _abs 13 -99
--&amp;gt; -13&lt;/code&gt;&lt;p&gt;可以看出，概念上，数字确实含有“绝对值”这一部分的值，但是数字与绝对值的关系同样也不是“元组与每个元素”之间的关系，也不是“记录与它的域”的关系。同时，数字本身，并不明显是那种积类型，这里我们同样是将其看作了概念上的积类型。&lt;/p&gt;&lt;p&gt;引入这两个例子的目的是说明，Lens 是某种更加抽象与普遍化的工具，它不仅仅用来处理具体的数据结构与数据结构内部的值，也可以用来处理各种各样的情况；Lens 聚焦于某个数据结构（实在的或是概念上的）的某个值上，这无关乎这个值是实在地存在于这个数据结构里，还是抽象地、概念上地存在于这个数据上，这为我们以后利用 Lens 完成语义的表达提供了可行性。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;多焦点数据操作&lt;/h2&gt;&lt;p&gt;Lens 在工作的过程中，对某个数据结构内某个值应用了一个&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; f b&lt;/code&gt;的函数，并最终得到一个&lt;code class=&quot;inline&quot;&gt;f t&lt;/code&gt;类型的新数据结构。假设现在我们想要操作某个列表&lt;code class=&quot;inline&quot;&gt;[a]&lt;/code&gt;中的所有元素，那么我们期望对列表中的每个元素应用&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; f b&lt;/code&gt;的函数，并且最终得到一个&lt;code class=&quot;inline&quot;&gt;f [b]&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;对于应用某个函数于列表中的每个元素这一任务，我们有非常熟悉的解决方案&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;。 &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;map (f::a-&amp;gt;f b) (xs::[a]) :: [f b] &lt;/code&gt;&lt;p&gt;但是我们期望得到的类型是&lt;code class=&quot;inline&quot;&gt;f [b]&lt;/code&gt;而不是&lt;code class=&quot;inline&quot;&gt;[f b]&lt;/code&gt;，我们需要一个将函子的列表转换为列表的函子的函数，而实际上，函子没有足够的约束来支持这样的操作，最简单的例子就是，一个空函子的列表我们没法直接找到对应的空列表的函子；此外更一般的场合我们需要将&lt;code class=&quot;inline&quot;&gt;f a&lt;/code&gt;合并至&lt;code class=&quot;inline&quot;&gt;f [a]&lt;/code&gt;得到一个新的&lt;code class=&quot;inline&quot;&gt;f [a]&lt;/code&gt;的函数，其类型为&lt;code class=&quot;inline&quot;&gt;f a -&amp;gt; f [a] -&amp;gt; f [a]&lt;/code&gt;，而我们有的列表拼接函数的类型为&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;，这也不是函子的升格可以直接完成的。而应用函子恰巧有我们需要的&lt;code class=&quot;inline&quot;&gt;pure&lt;/code&gt;函数处理第一种情况，又有可以对双参数函数升格的&lt;code class=&quot;inline&quot;&gt;liftA2&lt;/code&gt;。由此看来，我们需要的是使用应用函子代替函子完成我们的需要。&lt;/p&gt;&lt;p&gt;有了这些分析，我们不难写出将函子的列表提取为列表的函子的函数。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;(&amp;lt;:&amp;gt;) :: Applicative f =&amp;gt; f a -&amp;gt; f [a] -&amp;gt; f [a],
(&amp;lt;:&amp;gt;) = liftA2 (:)
sequenceA :: (Applicative f) =&amp;gt; [f a] -&amp;gt; f [a]  
sequenceA [] = pure []  
sequenceA (x:xs) = x &amp;lt;:&amp;gt; sequenceA xs&lt;/code&gt;&lt;p&gt;接下来我们需要的操作列表中全部元素的 Lens 的实现也可以容易给出，因为我们先前已经通过&lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;实现了&lt;code class=&quot;inline&quot;&gt;(a -&amp;gt; f b) -&amp;gt; [a] -&amp;gt; [f b]&lt;/code&gt;，只需再对结果应用刚实现的&lt;code class=&quot;inline&quot;&gt;sequenceA&lt;/code&gt;就可以恰好得到我们需要的 Lens 类型。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;_every :: Applicative f =&amp;gt; (a -&amp;gt; f b) -&amp;gt; [a] -&amp;gt; f [b]
_every f xs = sequenceA $ map f xs

over _every (+1) [2,3,4]
--&amp;gt; [3,4,5]&lt;/code&gt;&lt;p&gt;由于应用函子是特殊的函子，所以&lt;code class=&quot;inline&quot;&gt;_every&lt;/code&gt;是特殊的 Lens， 我们将这类 Lens 命名为 Traversal。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Traversal s t a b = Applicative f =&amp;gt; (a -&amp;gt; f b) -&amp;gt; s -&amp;gt; f t
type Traversal&#39; s a = Traversal s s a a&lt;/code&gt;&lt;p&gt;取这个名字的原因是，在标准库&lt;code class=&quot;inline&quot;&gt;Data.Traversal&lt;/code&gt;中实际上恰好有一个函数&lt;code class=&quot;inline&quot;&gt;traverse&lt;/code&gt;符合我们的要求， 这个函数并非为 Lens 专门设计，但它的类型恰好与我们先前的&lt;code class=&quot;inline&quot;&gt;_every&lt;/code&gt; 相同，不仅如此这个函数不仅可以在列表上工作，也可以在所有&lt;code class=&quot;inline&quot;&gt;Traversable&lt;/code&gt;类型上工作。由于这类 Lens 操作均依赖于&lt;code class=&quot;inline&quot;&gt;traverse&lt;/code&gt;， 所以取名为 Traversal 。&lt;/p&gt;&lt;p&gt;让我们简单地看一下 Traversal 是如何与&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;一通工作的： &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;traverse :: Traversable t =&amp;gt; Traversal (t a) (t b) a b
over traverse (+1) [2,3,4]
runIdentity . traverse (Identity . (+1)) [2,3,4]
runIdentity $ sequenceA $ map (Identity . (+1)) [2,3,4]
runIdentity $ sequenceA [Identity 3, Identity 4, Identity 5]
runIdentity $ Identity 3 &amp;lt;:&amp;gt; Identity 4 &amp;lt;:&amp;gt; Identity 5 &amp;lt;:&amp;gt; Identity []
runIdentity $ Identity [3, 4, 5]
--&amp;gt; [3,4,5]&lt;/code&gt;&lt;p&gt;但是，现在我们的 Traversal 不能正确与&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;工作。 例如，对于下面的代码&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view traverse [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
view traverse [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]&lt;/code&gt;&lt;p&gt;我们期望的结果是这样的，我们只需要它原封不动地返回即可&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
[1,2,3]&lt;/code&gt;&lt;p&gt;而实际上，我们得到了看似匪夷所思的结果&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;&quot;123&quot;
-- error: No instance for (Monoid Char) arising from a use of ‘traverse’&lt;/code&gt;&lt;p&gt;让我们展开 Traversal 与&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;工作的过程 &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view traverse [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
getConst $ traverse (Const b) [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
getConst $ sequenceA $ map (Const b) [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
getConst $ sequenceA  [Const &quot;1&quot;, Const &quot;2&quot;, Const &quot;3&quot;]
getConst $ sequenceA $ Const &quot;1&quot; &amp;lt;:&amp;gt; Const &quot;2&quot; &amp;lt;:&amp;gt; Const &quot;3&quot; &amp;lt;:&amp;gt; pure []&lt;/code&gt;&lt;p&gt;我们实际上清楚&lt;code class=&quot;inline&quot;&gt;Const a&lt;/code&gt;本身并非应用函子,&lt;code class=&quot;inline&quot;&gt;Monoid a =&amp;gt; Const a&lt;/code&gt;才是 ，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;类型的值不是“容器”内的值，而是“容器”的一部分，容器内并不存在值。于是，将应用函子范畴上的值应用到应用函子范畴上的函数时，内部并无操作，有的只是“容器”的合并。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;instance Monoid a =&amp;gt; Applicative (Const a) where
  pure _ = Const empty
  (Const x) &amp;lt;*&amp;gt; (Const y) = Const (x &amp;lt;&amp;gt; y)&lt;/code&gt;&lt;p&gt;列表的默认&lt;code class=&quot;inline&quot;&gt;mappend&lt;/code&gt;操作是列表合并，所以我们就可以将上面的计算继续写下去了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;getConst $ sequenceA  Const &quot;1&quot; &amp;lt;:&amp;gt; Const &quot;2&quot; &amp;lt;:&amp;gt; Const &quot;3&quot; &amp;lt;:&amp;gt; pure []
getConst $ sequenceA  Const &quot;1&quot; &amp;lt;:&amp;gt; Const &quot;2&quot; &amp;lt;:&amp;gt; Const &quot;3&quot; &amp;lt;:&amp;gt; Const &quot;&quot;
getConst $ sequenceA  Const &quot;1&quot; &amp;lt;:&amp;gt; Const &quot;2&quot; &amp;lt;:&amp;gt; Const &quot;3&quot;
getConst $ sequenceA  Const &quot;1&quot; &amp;lt;:&amp;gt; Const &quot;23&quot;
getConst $ sequenceA  Const &quot;123&quot;
&quot;123&quot;&lt;/code&gt;&lt;p&gt;可以看出，这并不是匪夷所思的结果，而是在这些定义下的合理结果。实际上，从&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;类型上我们也可以看出它的确做了它应当的工作。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view :: Getting a s a -&amp;gt; s -&amp;gt; a

view traverse [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
-- view :: Getting String [String] String -&amp;gt; [String] -&amp;gt; String&lt;/code&gt;&lt;p&gt;它最终确实给了我们一个字符串。&lt;/p&gt;&lt;p&gt;所以，我们需要构建专用于 Traversal 的&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;函数。考虑之前&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;的定义&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view :: Getting a b a -&amp;gt; b -&amp;gt; a
view lens = getConst . lens Const &lt;/code&gt;&lt;p&gt;这里他将原来的值不加改变地喂给了&lt;code class=&quot;inline&quot;&gt;getConst&lt;/code&gt;， 我们可以讲原始值套在一个 Monoid 里完成我们需要的效果。这里，我们需要的就是最终得到一个列表，因此只需要再套一层列表的 Monoid 即可，外面套的这层 Monoid 会互相合并，最终只剩下一个列表，里面排满了原来的元素。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;toListOf :: Getting [a] s a -&amp;gt; s -&amp;gt; [a]
toListOf lens = getConst . lens (\x -&amp;gt; Const [x])

toListOf traverse [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
--&amp;gt; [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
toListOf traverse [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]
--&amp;gt; [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]&lt;/code&gt;&lt;p&gt;这个函数似乎没有多大用处，它原封不动地返回了原本的列表。但是，我们可以依托于&lt;code class=&quot;inline&quot;&gt;traverse&lt;/code&gt; 构建更多更有用的 Traversal。&lt;/p&gt;&lt;p&gt;例如聚焦于一个列表中全部满足某个条件的 Traversal&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;_all :: (a -&amp;gt; Bool) -&amp;gt; Traversal&#39; [a] a
_all st f s = traverse update s
  where
    update old = if st old then f old else pure old
    
toListOf (_all (/=0)) [1,2,0,3,4,0,5]
--&amp;gt; [1,2,3,4,5] &lt;/code&gt;&lt;p&gt;同时，我们描述过 Traversal 是一种特殊的 Lens， 所以它具有 Lens 各种有用的性质，例如通过互相复合来处理嵌套的列表。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;toListOf (traverse.traverse) [[1,2],[1,2,3,4]]
--&amp;gt; [1,2,1,2,3,4]
xs = [[1,2],[1,2,3,4],[4,5,6],[23,4,5,5,4],[1],[2,3]]
over (_all (\x-&amp;gt; length x &amp;lt;= 3 ) .traverse) (+1) xs
-- &amp;gt;[[2,3],[1,2,3,4],[5,6,7],[23,4,5,5,4],[2],[3,4]]&lt;/code&gt;&lt;p&gt;或者与普通的 Lens 复合，来完成复杂的操作。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;toListOf (traverse._1) [(1,2),(3,4),(5,6)]
--&amp;gt; [1,3,5]&lt;/code&gt;&lt;p&gt;需要注意的是，Traversal 是特殊的 Lens，也就是说在 Lens 上多出一些特定的限制，因此 Traversal 与普通 Lens 的复合将会仍然继承这些限制，即 Traversal 与 Lens 的复合仍是 Traversal。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;使用更多 Monoid 来获得多种效果&lt;/h2&gt;&lt;p&gt;在上面我们使用了&lt;code class=&quot;inline&quot;&gt;[]&lt;/code&gt;这一 Monoid 来实现了合成列表的效果，实际上，我们还可以使用其他Monoid。下面让我们看几个例子。&lt;/p&gt;&lt;p&gt;第一个例子是将包装过的 &lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt;作为一个 Monoid，并取名为 &lt;code class=&quot;inline&quot;&gt;First&lt;/code&gt; 。从名字我们也可以看出来，它的作用就是取出列表的首个元素。 &lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype First a = First (Maybe a)

instance Monoid (First a) where
  mempty = First Nothing
  mappend (First Nothing) y = y
  mappend        x        _ = x

preview :: Getting (First a) s a -&amp;gt; s -&amp;gt; Maybe a
preview lens = getFirst . getConst . lens (Const . First . Just)

preview (_all (/=0)) [3, 2, 1, 0]
--&amp;gt; Just 3

preview (_all (/=0)) [0,0,0]
--&amp;gt; Nothing&lt;/code&gt;&lt;p&gt;同样，修改 &lt;code class=&quot;inline&quot;&gt;mappend&lt;/code&gt;的定义我们可以得到 &lt;code class=&quot;inline&quot;&gt;Last&lt;/code&gt;，这里不再具体给出。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;第二个例子是包装过的&lt;code class=&quot;inline&quot;&gt;Bool&lt;/code&gt;，我们可以用它来判断一个列表中是否含有某个元素&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Any = Any { getAny :: Bool }

instance Monoid Any where
  mempty = Any False
  Any x `mappend` Any y = Any (x || y)
  
has :: Getting Any s a -&amp;gt; s -&amp;gt; Bool
has l = getAny . getConst . l (const $ Const (Any True)) 

has (_all (==0)) [3, 2, 1, 0]
--&amp;gt; True&lt;/code&gt;&lt;p&gt;我们发现，由于 Traversal 具有良好的抽象能力，我们仅仅选用不同的 Monoid 就实现了多种多用的效果，这无疑是非常令人振奋的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;-- 2017/11/25日更新&lt;/p&gt;&lt;p&gt;出现了各种错误（捂脸），谢谢 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/0251012c87c2d3f56ac34de7d71cdcbc&quot; data-hash=&quot;0251012c87c2d3f56ac34de7d71cdcbc&quot; data-hovercard=&quot;p$b$0251012c87c2d3f56ac34de7d71cdcbc&quot;&gt;@脚本少女魔理沙&lt;/a&gt; 指正╮(╯▽╰)╭&lt;/p&gt;</description>
<author>孙浩然</author>
<guid isPermaLink="false">2017-11-24-31328798</guid>
<pubDate>Fri, 24 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Agda 中的证明，从零到一</title>
<link>https://henix.github.io/feeds/zhuanlan.zju-lambda/2017-11-02-30686586.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30686586&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-461e72ecf40a21b6804d43e7201d21de_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;最近在学 Agda ，感觉摸到了定理证明的门，希望各路大神不吝赐教。这是一个系列，这篇文章讲的太基础是因为它是第一篇哈。原文链接：&lt;a href=&quot;http://ice1000.org/2017/11/01/ProofInAgda/&quot;&gt;Agda 中的证明，从零到一&lt;/a&gt;&lt;/p&gt;&lt;p&gt;类型则命题，程序则证明。这句话表达了定理证明的一个很重要的思想。&lt;/p&gt;&lt;p&gt;我一开始就没有搞懂这句话在说什么。 在我自认为搞懂的时候，我把我以前没有搞懂的原因归结为我看的教程太垃圾了。&lt;/p&gt;&lt;p&gt;一开始我理解这个问题的同时，我以为我也理解了之前一个 Haskell 关于 &lt;code class=&quot;inline&quot;&gt;IO Monad&lt;/code&gt; 的问题，但实际上不是我想的那样。 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/30686586/h%3Ccode%3Ettps://h%3C/code%3Eackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#line-1173&quot;&gt;Haskell 的 IO Monad 的实现&lt;/a&gt; 比我想象的要复杂一些，因此本文不谈 Haskell 。&lt;/p&gt;&lt;h2&gt;前置知识&lt;/h2&gt;&lt;p&gt;这是一篇面向略懂 dependent type 的人的定理证明教程，然后你要看得懂类 Haskell 的语法。 因为我在学这个的时候就是只会点 Haskell ，然后用过 GADT 和 type family 模拟过 dependent type 。&lt;/p&gt;&lt;p&gt;给出一些参考资料：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://learn%3Ci%3Eyouahaskell.com/cha%3C/i%3Epters&quot;&gt;一个比较简单的 Haskell 入门教程 Learn you a Haskell&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/67043774/answer/249019401&quot;&gt;虎哥介绍的 GADT&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.codewars.com/kata/singletons&quot;&gt;介绍 GADT 的 CodeWars Kata: Singletons&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.codewars.com/kata/scott-encoding&quot;&gt;介绍 GADT 的 CodeWars Kata: Scott Encoding&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;声明在前面&lt;/h2&gt;&lt;p&gt;由于 Agda 语言的特殊性，本文将使用 LaTeX 和代码块来共同展示代码。 前者是为了保证字符的正确显示，后者是为了方便读者复制代码。&lt;/p&gt;&lt;p&gt;本文不讲 Agda 基本语法和 Emacs 的使用。可能以后会有另外的文章。&lt;/p&gt;&lt;p&gt;本文主要内容是帮助一个没接触过定理证明但是接触过 dependent type 的人（这就是我接触定理证明之前的状态）理解一个非常非常简单的定理证明的例子。&lt;/p&gt;&lt;h2&gt;如何理解定理证明&lt;/h2&gt;&lt;p&gt;首先，我们已经知道，我们这是要用类型表达命题，类型对应的实现来证明这个命题的正确性。&lt;/p&gt;&lt;p&gt;命题中的基本元素一般是值的类型(而且很多时候都是代数数据类型)，也就是 &lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} p \rightarrow q&lt;/equation&gt; 的那个 &lt;equation&gt;p&lt;/equation&gt; 或者 &lt;equation&gt;q&lt;/equation&gt; 。 而这个 &lt;equation&gt;\rightarrow&lt;/equation&gt; 对应的就是 “函数” 这一概念，它组合了两个类型，表达了 “推出” 这一逻辑概念。&lt;/p&gt;&lt;p&gt;比如，我实现了一个这样的类型的函数：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;p \rightarrow q&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;p → q &lt;/code&gt;&lt;p&gt;那么这个函数的实现就是&lt;/p&gt;&lt;blockquote&gt;如果 p 成立，则 q 成立&lt;/blockquote&gt;&lt;p&gt;，或者说，&lt;/p&gt;&lt;blockquote&gt;&lt;equation&gt;p \rightarrow q&lt;/equation&gt; &lt;/blockquote&gt;&lt;p&gt;这个命题的证明。&lt;/p&gt;&lt;p&gt;再比如，我实现了一个这样的类型的函数：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;p \rightarrow q \rightarrow r &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;p → q → r &lt;/code&gt;&lt;p&gt;那么这个函数的实现就是&lt;/p&gt;&lt;blockquote&gt;如果 p 成立，那么 “如果 q 成立，那么 r 成立” 这一命题成立&lt;/blockquote&gt;&lt;p&gt;，或者说，&lt;/p&gt;&lt;blockquote&gt;&lt;equation&gt;p \rightarrow ( q \rightarrow r )&lt;/equation&gt; &lt;/blockquote&gt;&lt;p&gt;这个命题的证明。&lt;/p&gt;&lt;p&gt;其实我们原本想表达的意思是&lt;/p&gt;&lt;blockquote&gt;&lt;equation&gt; p\ \&amp;amp;\&amp;amp;\ q\rightarrow r &lt;/equation&gt; &lt;/blockquote&gt;&lt;p&gt;但是这个 &lt;equation&gt;\&amp;amp;\&amp;amp;&lt;/equation&gt; 关系暂时没讲所以先就这样。&lt;/p&gt;&lt;p&gt;这就是 “类型则命题，程序则证明” 的含义。&lt;/p&gt;&lt;p&gt;在 Agda 中，上面的代码应该写成这样：&lt;/p&gt;&lt;p&gt;&lt;equation&gt; \DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \proof : \{p\ q\ r : \Set\} \rightarrow p \rightarrow q \rightarrow r &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;proof : {p q r : Set} → p → q → r &lt;/code&gt;&lt;p&gt;下面我们看一些实例。&lt;/p&gt;&lt;h2&gt;refl 与相等性&lt;/h2&gt;&lt;p&gt;之所以我没有再学习 Idris 就是因为那些教程没说 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; 是啥 (Idris 叫 &lt;code class=&quot;inline&quot;&gt;Refl&lt;/code&gt; ， Agda 叫 &lt;code class=&quot;inline&quot;&gt;refl&lt;/code&gt;) 就直接在代码里面用了，我看的时候就一脸蒙蔽，还以为是我智商太低没看懂他 implicit 的东西。 但是好在我看了一坨很友好的 Agda 代码后民白了。&lt;/p&gt;&lt;p&gt;首先，我们可以定义这样一个用来表示相等关系的 GADT ，它对于任何一个 Level 的任何一个实例都成立。 这里我们用了 Universal Polymorphism 表达这个 “对于任何一个 Level “ 的概念。&lt;/p&gt;&lt;p&gt;然后我们使用 &lt;code class=&quot;inline&quot;&gt;refl&lt;/code&gt; 这个类型构造器表达 “这个相等关系成立” 这一事实。&lt;/p&gt;&lt;p&gt;我们用 &lt;equation&gt;\equiv&lt;/equation&gt; 表示他（标准库的定义在 &lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;http://agda.readthedocs.io/en/v2.5.3/language/built-ins.html#equality&quot;&gt;Agda.Builtin.Equality&lt;/a&gt;&lt;/code&gt; 中）：&lt;/p&gt;&lt;p&gt;&lt;equation&gt; \DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \begin{align*} &amp;amp; \data\ \_{\equiv}\_\ \{a\} \{A : \Set a\} (x : A) : A \rightarrow \Set a\where \\ &amp;amp;\ \ \refl : x \equiv x \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;data _≡_ {a} {A : Set a} (x : A) : A → Set a where
  refl : x ≡ x &lt;/code&gt;&lt;p&gt;如果你看不懂这个类型签名也没有关系，只需要接受”这个 GADT 只有一个叫 &lt;code class=&quot;inline&quot;&gt;refl&lt;/code&gt; 的类型构造器”这一事实就好了。&lt;/p&gt;&lt;p&gt;然后我们可以用它进行一些证明。比如我们来证明相等性的传递性，也就是&lt;/p&gt;&lt;blockquote&gt;如果 a &lt;equation&gt;\equiv&lt;/equation&gt; b 并且 b &lt;equation&gt;\equiv&lt;/equation&gt; c ，那么 a &lt;equation&gt;\equiv&lt;/equation&gt; c&lt;/blockquote&gt;&lt;p&gt;。然后我们来看看这个命题对应的类型：&lt;/p&gt;&lt;p&gt;&lt;equation&gt; \DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \_{\leftrightarrows}\_ : \{A : \Set\} \{a\ b\ c : A\} \rightarrow a \equiv b \rightarrow b \equiv c \rightarrow a \equiv c &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_⇆_ : {A : Set} {a b c : A} → a ≡ b → b ≡ c → a ≡ c &lt;/code&gt;&lt;p&gt;那么我们要怎么实现它，也就是证明它呢？&lt;/p&gt;&lt;p&gt;我一开始写下了这样的东西：&lt;/p&gt;&lt;p&gt;&lt;equation&gt; \DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \_{\leftrightarrows}\_\ ab\ bc = ? &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_⇆_ ab bc = ? &lt;/code&gt;&lt;p&gt;然后我就不知道该怎么办了。&lt;/p&gt;&lt;p&gt;事实上，这个原本就很简单的证明被我想复杂了。 因为这个定理是不证则明的，那么我们要如何表达，如何通过 &lt;code class=&quot;inline&quot;&gt;ab&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;bc&lt;/code&gt; 这两个模式匹配出来的结果进行变换得到这个不证则明的定理呢？&lt;/p&gt;&lt;p&gt;首先这个模式匹配的参数就不应该这样通配地用 &lt;code class=&quot;inline&quot;&gt;ab&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;bc&lt;/code&gt; 来表达。 我们应该把这两个相等关系 (他们的本质是 GADT) 给模式匹配出来。&lt;/p&gt;&lt;p&gt;由于直接写 &lt;code class=&quot;inline&quot;&gt;ab&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;bc&lt;/code&gt; 什么都得不出来，我于是尝试将 &lt;code class=&quot;inline&quot;&gt;ab&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;bc&lt;/code&gt; 用模式匹配消耗掉，然后 Agda 直接在右边给我自动填入了 &lt;code class=&quot;inline&quot;&gt;refl&lt;/code&gt; ，然后好像就 Q.E.D 了：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \_{\leftrightarrows}\_\ \refl\ \refl =\refl &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;_⇆_ refl refl = refl -- 编译通过！ &lt;/code&gt;&lt;p&gt;这是为什么呢？我们来分别看下这两种写法的含义。&lt;/p&gt;&lt;h2&gt;使用 ab bc&lt;/h2&gt;&lt;p&gt;这样的话实际上是把 &lt;equation&gt;a \equiv b&lt;/equation&gt; 和 &lt;equation&gt; b \equiv c&lt;/equation&gt; 两个条件当成了”变量”而不是作为”条件”。 也就是说，当使用 &lt;code class=&quot;inline&quot;&gt;abbc&lt;/code&gt; 时，右边就需要”通过 &lt;equation&gt;a \equiv b&lt;/equation&gt; 和 &lt;equation&gt;b \equiv c&lt;/equation&gt; 这两个条件，再对这两个条件套用一些变换，得出 &lt;equation&gt;a \equiv c&lt;/equation&gt; ”。&lt;/p&gt;&lt;p&gt;在这个时候，编译器并没有把 &lt;equation&gt;a \equiv b&lt;/equation&gt; 和 &lt;equation&gt;b \equiv c &lt;/equation&gt; 当成既成条件，而是当成了 “变量” 。&lt;/p&gt;&lt;p&gt;这就回到了我们原本的需求，我们原本就是需要写出一个 &lt;equation&gt;a \equiv b\ \&amp;amp;\&amp;amp;\ b \equiv c \Rightarrow a \equiv c&lt;/equation&gt; 的变换。&lt;/p&gt;&lt;p&gt;如果要用变换强行实现的话，可以使用 &lt;code class=&quot;inline&quot;&gt;with&lt;/code&gt; 语句（就是 Agda 的 &lt;code class=&quot;inline&quot;&gt;case of&lt;/code&gt;）把这两个变量模式匹配出来，然后直接得证。 这里给出一个代码实现。&lt;/p&gt;&lt;p&gt;&lt;equation&gt; \begin{eqnarray} \_{\leftrightarrows}_1\_\ ab\ bc \with ab\ &amp;amp;|&amp;amp;bc \\ ... \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \refl\ &amp;amp;|&amp;amp;\refl = \refl \end{eqnarray}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_⇆₁_ ab bc with ab  | bc
...           | refl | refl = refl &lt;/code&gt;&lt;p&gt;这种方法和下面的做法是等价的。&lt;/p&gt;&lt;p&gt;如果你没有看懂这一坨，可以尝试继续读下去，说不定看完下面那坨你就懂了。&lt;/p&gt;&lt;h2&gt;使用 refl&lt;/h2&gt;&lt;p&gt;由于 &lt;equation&gt;a \equiv b&lt;/equation&gt; 已经是一个条件了，我们直接把它的值取出来。 这时，右边的代码就 &lt;b&gt;已经是建立在&lt;/b&gt; &lt;equation&gt;a \equiv b&lt;/equation&gt; &lt;b&gt;和&lt;/b&gt; &lt;equation&gt;b \equiv c&lt;/equation&gt; &lt;b&gt;这两个既成条件下&lt;/b&gt; 的了，因此这时 Agda 已经认为 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;c&lt;/code&gt; 三者相等了。&lt;/p&gt;&lt;p&gt;利用这一点，我们直接使用 &lt;code class=&quot;inline&quot;&gt;refl&lt;/code&gt; 是没有问题的。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\_{\leftrightarrows}_0\_\ \refl\ \refl = \refl &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;_⇆₀_ refl refl = refl &lt;/code&gt;&lt;h2&gt;顺带一提&lt;/h2&gt;&lt;p&gt;当然我们也可以这样写，这是一个语法糖：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \refl {\leftrightarrows}_0\refl = \refl &lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;refl ⇆₀ refl = refl&lt;/code&gt;&lt;p&gt;之前那个比较 trivial 的模式匹配也可以这样写：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect}\begin{eqnarray} ab\ {\leftrightarrows}_1\ ab \with ab\ &amp;amp;|&amp;amp;bc \\ ... \ \ \ \ \ \ \ \ \ \ \ \ \ |\ \ \refl\ &amp;amp;|&amp;amp;\refl = \refl \end{eqnarray}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;ab ⇆₁ bc with ab  | bc
...         | refl | refl = refl &lt;/code&gt;&lt;h2&gt;另一个例子&lt;/h2&gt;&lt;p&gt;现在你肯定有点感觉了，但是这个例子太 trivial 你又感觉自己有点没懂， 那么我们再来看看这个稍微复杂点的例子帮你加深一下理解。&lt;/p&gt;&lt;p&gt;首先：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \forall\ \{ a \}\ \{ A : \Set a \} &lt;/equation&gt; &lt;/p&gt;&lt;p&gt;表示 Universal Polymorphism 。然后考虑一个函数，我们有：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\DeclareMathOperator{Set}{Set} \DeclareMathOperator{refl}{refl} \DeclareMathOperator{proof}{proof} \DeclareMathOperator{data}{data} \DeclareMathOperator{where}{where} \DeclareMathOperator{with}{with} \DeclareMathOperator{Vect}{Vect} \begin{align*} &amp;amp; \ggg : \forall\ \{a\ b\}\ \{A : \Set a\}\ \{B : \Set b\} \{m\ n\} \{f : A \rightarrow B\} \rightarrow m \equiv n \rightarrow f\ m \equiv f\ n \\ &amp;amp; \ggg \refl = \refl \end{align*}&lt;/equation&gt; &lt;/p&gt;&lt;code lang=&quot;agda&quot;&gt;⋙ : ∀ {a b} {A : Set a} {B : Set b} {m n} {f : A → B} → m ≡ n → f m ≡ f n
⋙ refl = refl &lt;/code&gt;&lt;p&gt;和上面一样，在建立了 &lt;i&gt;m&lt;/i&gt;≡&lt;i&gt;n&lt;/i&gt;m≡n 的基础上，可以直接用 &lt;code class=&quot;inline&quot;&gt;refl&lt;/code&gt; 表达他们对于同一个函数应用的结果相等。&lt;/p&gt;&lt;p&gt;我是在 &lt;a href=&quot;https://stackoverflow.com/questions/27091668/refl-in-agda-explaining-congruence-property&quot;&gt;这个 StackOverflow 问题&lt;/a&gt; 里看到这个代码的，唯一的回答里面还有更多的解释。&lt;/p&gt;&lt;p&gt;这个我就暂时不作过多讲解了，以后再说。&lt;/p&gt;&lt;h2&gt;结束&lt;/h2&gt;&lt;p&gt;这个证明太简单了，只有一步，没有什么实际意义，仅用于入门理解。 下一篇文章我们将会进行一个稍微复杂点的关于与或关系的证明。&lt;/p&gt;&lt;p&gt;我说完了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;执壶的代码块高亮竟然支持 Agda ，感动中国简直&lt;/p&gt;</description>
<author>考古学家千里冰封</author>
<guid isPermaLink="false">2017-11-02-30686586</guid>
<pubDate>Thu, 02 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>浙大源上线 Hackage 和 Stackage 啦！</title>
<link>https://henix.github.io/feeds/zhuanlan.zju-lambda/2017-11-01-30655525.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30655525&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6be912ed9b92948cacb8dfd313308db4_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;浙大源目前的维护者 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/e7d58ff2738b65fced751a30c51c87b8&quot; data-hash=&quot;e7d58ff2738b65fced751a30c51c87b8&quot; data-hovercard=&quot;p$b$e7d58ff2738b65fced751a30c51c87b8&quot;&gt;@Ting Shan&lt;/a&gt; 在前几天上线了 &lt;a href=&quot;http://mirrors.zju.edu.cn/hackage/&quot;&gt;Hackage&lt;/a&gt; 和 &lt;a href=&quot;http://mirrors.zju.edu.cn/stackage/&quot;&gt;Stackage&lt;/a&gt;，方便各位 Haskell 用家的使用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;配置可以参考 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/2d8f51b6523e01a8529606f466d98198&quot; data-hash=&quot;2d8f51b6523e01a8529606f466d98198&quot; data-hovercard=&quot;p$b$2d8f51b6523e01a8529606f466d98198&quot;&gt;@Felis sapiens&lt;/a&gt; 的文章，例如&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25005809&quot;&gt;Stackage 镜像使用说明&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>霜月琉璃</author>
<guid isPermaLink="false">2017-11-01-30655525</guid>
<pubDate>Wed, 01 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Finger Tree 的简单介绍和实现</title>
<link>https://henix.github.io/feeds/zhuanlan.zju-lambda/2017-10-30-30589105.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30589105&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e0f19ec073781989a02c6f364831f0c8_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;这篇文章讲了什么&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我将会在这篇文章中提到一点 Finger Tree 的设计思想、Finger Tree 的实现细节、 Finger Tree 的应用等内容。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;我需要看这篇文章吗&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;你需要对数据结构有着简单的了解，并且对 Finger Tree 有一定兴趣但没有深入了解。&lt;/p&gt;&lt;p&gt;你可能需要学会基础的 Haskell 语法&lt;/p&gt;&lt;h2&gt;&lt;b&gt;为什么是 Finger Tree&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;它提供了高效的各种序列操作：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ac2cb9cc296d8cfa67580d33d49af82d_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1125&quot; data-rawheight=&quot;519&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;它在很多方面几乎达到了理论上的极限，这也是我们为什么在很多地方要使用 Finger Tree 来作为储存序列的东西。&lt;/p&gt;&lt;h2&gt;Finger Tree 是什么&lt;/h2&gt;&lt;p&gt;我们首先从简单的二叉树开始谈起&lt;/p&gt;&lt;p&gt;我们在 Haskell 中如何表示一颗二叉树？&lt;/p&gt;&lt;p&gt;这很简单，像这样就可以了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Tree a 
      = Nil
      | Tree (Tree a) a (Tree a)&lt;/code&gt;&lt;p&gt;当然我们也可以这样写（我们把它叫做 leafy 的二叉树）&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Tree a
      = Leaf a
      | Tree (Tree a) (Tree a)&lt;/code&gt;&lt;p&gt;我们可以发现第二种树是无法表达“空树”这个概念的，而且我们每次访问树上的值都需要到达叶子结点才能取到值。&lt;/p&gt;&lt;p&gt;那么如何表示一棵满的 leafy 的二叉树呢？我们可以借鉴自然数的定义。&lt;/p&gt;&lt;p&gt;自然数我们一般会写成这样&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Nat = Z | S Nat&lt;/code&gt;&lt;p&gt;借助它我们可以表达类型的嵌套层数&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Nat s a 
      = Z a
      | S (Nat s (s a))&lt;/code&gt;&lt;p&gt;于是我们只需要定义 leafy 二叉树的结点类型&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Node a = Node a a&lt;/code&gt;&lt;p&gt;就有&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; type Tree a = Nat Node a&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Nat&lt;/code&gt; 每推进一层，&lt;code class=&quot;inline&quot;&gt;Node&lt;/code&gt; 就会多嵌套一层，而 &lt;code class=&quot;inline&quot;&gt;Node&lt;/code&gt; 的定义保证了它一定是一棵满的 leafy 二叉树，比如&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; Z 1 :: Tree Int
  S (Z (Node 1 2)) :: Tree Int
  S (S (Z (Node (Node 1 2) (Node 3 4))))&lt;/code&gt;&lt;p&gt;而不满的二叉树会产生类型错误&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; S (S (Z (Node 1 (Node 2 3)))) -- error&lt;/code&gt;&lt;p&gt;然后我们把二叉树结点换成 2-3 树的结点&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Node23 a 
      = Node2 a a
      | Node3 a a a
  data Tree23 a = Nat Node23 a &lt;/code&gt;&lt;p&gt;这就得到了 Finger Tree 的前身，我们给一个例子 (这个例子是 Paper 上的)&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; S 
      (S 
          (S 
              (Z 
                  (Node2 
                      (Node3 
                          (Node2 t h) 
                          (Node2 i s) 
                          (Node2 i s)
                      ) 
                      (Node3 
                          (Node3 n o t) 
                          (Node2 a t) 
                          (Node3 r e e)
                      )
                  )
              )
          )
      )&lt;/code&gt;&lt;p&gt;画出来是这个样子&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-99efb528caa536e49c98e6de2a596995_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1079&quot; data-rawheight=&quot;229&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这棵树储存的序列是 &quot;thisisnotatree&quot;。&lt;/p&gt;&lt;p&gt;树形结构在访问时对效率很大的一个限制就是深度。大多数情况，平衡树都是单纯通过限制深度来保证访问时间能达到  ，在这里的这棵树中也是一样的。但我们想要更快的访问头尾结点，同时不牺牲随机访问其它结点的效率，于是我们想到的方法是缩短树的头尾结点到根结点的距离。&lt;/p&gt;&lt;p&gt;我们把树最左端和最右端的两条链提起来，变成下面这个样子&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a0556d0b975040f0f43a410789924e28_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;698&quot; data-rawheight=&quot;413&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;然后把这两条链粘在一起，就得到了一棵能  访问头尾结点的树了。&lt;/p&gt;&lt;p&gt;被提起来的那两条链，我们把它们叫做 Digit,  被粘起来之后合成的那些结点我们把它们叫做 Deep，于是我们下面给出 Finger Tree 的定义&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Finger Tree 的定义&lt;/b&gt;&lt;/h2&gt;&lt;code lang=&quot;haskell&quot;&gt; data FingerTree a 
      | Empty
      | Single a
      | Deep (Digit a) (FingerTree (Node a)) (Digit a)
  
  type Digit a = Digit [a]&lt;/code&gt;&lt;p&gt;Digit 这里我们使用 List 来表示。&lt;/p&gt;&lt;p&gt;可以看出，Finger Tree 中的 a 是一个嵌套了 n 次的 &lt;code class=&quot;inline&quot;&gt;Node&lt;/code&gt; ，所以 Finger Tree 每向下一层，结点的数量就会至少增加一倍，所以这棵树的深度显然是 &lt;equation&gt;O(\log n)&lt;/equation&gt; 的。&lt;/p&gt;&lt;p&gt;下面是 &lt;a href=&quot;http://www.staff.city.ac.uk/~ross/papers/FingerTree.html&quot;&gt;这里&lt;/a&gt; 给出的一些例子，其中红色是 &lt;code class=&quot;inline&quot;&gt;Deep&lt;/code&gt; ，绿色是 &lt;code class=&quot;inline&quot;&gt;Node&lt;/code&gt; ，蓝色是数据&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-42ed25ba850e8c60efb828d9ea5986d7_r.jpg&quot; data-caption=&quot;Deep (Digit [a]) (Single (Node3 b c d)) (Digit [e])&quot; data-rawwidth=&quot;109&quot; data-rawheight=&quot;142&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9bb9f1f5b49d1191703085fe62c43e6d_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;209&quot; data-rawheight=&quot;198&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e6e32fa7cd4b135f2593d7733b479421_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;787&quot; data-rawheight=&quot;271&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;为了保证 Finger Tree 的操作效率，我们限制了 &lt;code class=&quot;inline&quot;&gt;Digit&lt;/code&gt; 的大小在 1 到 4 之间。&lt;/p&gt;&lt;p&gt;下面我们就可以开始实现 Finger Tree 的各种操作了。&lt;/p&gt;&lt;h2&gt;Finger Tree 上的操作&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;头尾插入单个结点&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;第一个是 push-front 和 push-back ，即从头/尾插入 &lt;/p&gt;&lt;p&gt;（迫真安利：使用 Fira-Code 可以达到更好的符号显示效果）&lt;/p&gt;&lt;p&gt;push-front 的实现: &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bb889a069b57953b0b41025ed697e807_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;772&quot; data-rawheight=&quot;267&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在插入时我们优先插在 &lt;code class=&quot;inline&quot;&gt;Digit&lt;/code&gt; 上，当 &lt;code class=&quot;inline&quot;&gt;Digit&lt;/code&gt; 满了我们会把 &lt;code class=&quot;inline&quot;&gt;Digit&lt;/code&gt; 分裂并向下一级插入一个新的 &lt;code class=&quot;inline&quot;&gt;Node&lt;/code&gt; 结点。每向下一级需要的 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 的数量会翻  倍，所以插入这个过程是均摊 &lt;equation&gt;\Theta(1)&lt;/equation&gt;  的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;头尾删除单个结点&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;然后是删除头/尾结点。这个过程的效率和插入一样，也是 &lt;equation&gt;\Theta(1)&lt;/equation&gt; 的。&lt;/p&gt;&lt;p&gt;我们(&amp;lt;del&amp;gt;Paper 上&amp;lt;/del&amp;gt;)实现了一个数据类型 &lt;code class=&quot;inline&quot;&gt;ViewL&lt;/code&gt; （实际上是可以使用 &lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt; 的）来储存提取的结果&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data ViewL s a 
      = Nil
      | Cons a (s a)&lt;/code&gt;&lt;p&gt;然后有&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;  viewL :: FingerTree a -&amp;gt; ViewL FingerTree a
  viewL Empty = Nil
  viewL (Single a) = Cons a Empty
  viewL (Deep (Digit l) m r) = Cons (head l) (deepL (tail l) m r)&lt;/code&gt;&lt;p&gt;这里的 &lt;code class=&quot;inline&quot;&gt;deepL&lt;/code&gt; 是处理左 &lt;code class=&quot;inline&quot;&gt;Digit&lt;/code&gt; 不一定存在时的 Finger Tree 构造函数&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; deepL :: 
      [a] -&amp;gt; 
      FingerTree (Node a) -&amp;gt; 
      Digit a -&amp;gt; 
      FingerTree a
  deepL [] m (Digit r) = case viewL m of 
      Nil -&amp;gt; toTree r
      Cons a as -&amp;gt; Deep (nodeToDigit a) as (Digit r)
  deepL l m r = Deep (Digit l) m r&lt;/code&gt;&lt;p&gt;如果为空，就再从中间的子树中分离出一个结点（但在这里是 &lt;code class=&quot;inline&quot;&gt;Node a&lt;/code&gt;），转化为 &lt;code class=&quot;inline&quot;&gt;Digit&lt;/code&gt; 后再放在左边。(转化为 &lt;code class=&quot;inline&quot;&gt;Digit&lt;/code&gt; 的过程是 trivial 的)&lt;/p&gt;&lt;p&gt;有了 &lt;code class=&quot;inline&quot;&gt;viewL&lt;/code&gt; 我们就能得到诸如 &lt;code class=&quot;inline&quot;&gt;headL&lt;/code&gt; , &lt;code class=&quot;inline&quot;&gt;tailL&lt;/code&gt; 这样的函数。&lt;/p&gt;&lt;p&gt;到这里我们就已经拥有一个合格的 &lt;code class=&quot;inline&quot;&gt;Deque&lt;/code&gt; 了，我们不妨封装一下&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; newtype Deque a = Deque (FingerTree a)
  
  pushFront :: a -&amp;gt; Deque a -&amp;gt; Deque a
  pushFront a (Deque xs) = Deque (a &amp;lt;| xs)
  
  pushBack :: Deque a -&amp;gt; a -&amp;gt; Deque a
  pushBack (Deque xs) a = Deque (xs |&amp;gt; a)
  
  popFront :: Deque a -&amp;gt; View Deque a
  popFront (Deque xs) = case viewL xs of
      Nil -&amp;gt; Nil
      Cons a as -&amp;gt; Cons a (Deque as)
  
  popBack :: Deque a -&amp;gt; View Deque a
  popBack (Deque xs) = case viewR xs of
      Nil -&amp;gt; Nil
      Cons a as -&amp;gt; Cons a (Deque as)&lt;/code&gt;&lt;p&gt;看上去还不错。&lt;/p&gt;&lt;p&gt;但还不够，我们需要让两个 Finger Tree 连起来。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;把两棵 Finger Tree 连起来&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考虑两个 Finger Tree ， &lt;code class=&quot;inline&quot;&gt;Deep l1 m1 r1&lt;/code&gt;  和 &lt;code class=&quot;inline&quot;&gt;Deep l2 m2 r2&lt;/code&gt; ，我们需要把它们拼起来。&lt;/p&gt;&lt;p&gt;自然的想法就是把 &lt;code class=&quot;inline&quot;&gt;l1&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;r2&lt;/code&gt; 拿出来，把中间的部分再组装一次成为一棵新树。&lt;/p&gt;&lt;p&gt;那么我们需要这样一个函数：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;appendDigits :: 
      FingerTree (Node a) -&amp;gt;
      Digit a -&amp;gt;
      Digit a -&amp;gt; 
      FingerTree (Node a) -&amp;gt;
      FingerTree (Node a)&lt;/code&gt;&lt;p&gt;但事实上我们可以把 &lt;code class=&quot;inline&quot;&gt;Digit&lt;/code&gt; 都塞到一起（因为它们本质上还是 &lt;code class=&quot;inline&quot;&gt;[a]&lt;/code&gt;），来组成一些 &lt;code class=&quot;inline&quot;&gt;Node a&lt;/code&gt;  ( &lt;code class=&quot;inline&quot;&gt;Node a&lt;/code&gt; 是中间那棵 Finger Tree 的数据类型)，这样我们只需要实现这样两个函数：(conc for concat)&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; conc :: FingerTree a -&amp;gt; [a] -&amp;gt; FingerTree a
  nodes :: [a] -&amp;gt; [Node a]&lt;/code&gt;&lt;p&gt;第二个函数的实现也没什么，每隔 2 / 3 个元素切一刀就好了。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;nodes [a, b] = [Node2 a b]
  nodes [a, b, c] = [Node3 a b c]
  nodes [a, b, c, d] = [Node2 a b, Node2 c d]
  nodes (a: b: c: xs) = Node3 a b c : nodes xs
  nodes _ = error &quot;What the fuck??&quot;&lt;/code&gt;&lt;p&gt;第一个函数则有一些细节需要考虑。&lt;/p&gt;&lt;p&gt;当其中一颗树是空树或者 &lt;code class=&quot;inline&quot;&gt;Single&lt;/code&gt; 时，我们可以直接把 &lt;code class=&quot;inline&quot;&gt;List&lt;/code&gt; 中的元素一个一个塞进去（这个函数的调用者传进来的 &lt;code class=&quot;inline&quot;&gt;List&lt;/code&gt; 大小是常数，所以不会影响时间复杂度）。&lt;/p&gt;&lt;p&gt;当两颗树都是 &lt;code class=&quot;inline&quot;&gt;Deep&lt;/code&gt; 时，情形和直接连接两颗树差不多，只需要把 &lt;code class=&quot;inline&quot;&gt;l2&lt;/code&gt; ，&lt;code class=&quot;inline&quot;&gt;r2&lt;/code&gt; 和加进来的 &lt;code class=&quot;inline&quot;&gt;list&lt;/code&gt; 一起转成 &lt;code class=&quot;inline&quot;&gt;list&lt;/code&gt; 就行了。&lt;/p&gt;&lt;p&gt;所以 &lt;code class=&quot;inline&quot;&gt;conc&lt;/code&gt; 的实现也就很自然了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; conc Empty as xs = listConTree as xs
  conc xs as Empty = treeConList xs as
  conc (Single x) as xs = x &amp;lt;| listConTree as xs
  conc xs as (Single x) = treeConList xs as |&amp;gt; x
  conc (Deep l1 m1 (Digit r1)) as (Deep (Digit l2) m2 r2) = 
      Deep l1 (conc m1 (nodes (r1 ++ as ++ l2)) m2) r2&lt;/code&gt;&lt;p&gt;listConTree和treeConList是两个辅助函数，暴力地把list中的东西一个一个塞到树里&lt;/p&gt;&lt;p&gt;于是我们可以有：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;infixl 5 &amp;gt;&amp;lt;
  (&amp;gt;&amp;lt;) :: FingerTree a -&amp;gt; FingerTree a -&amp;gt; FingerTree a
  a &amp;gt;&amp;lt; b = conc a [] b&lt;/code&gt;&lt;p&gt;显然的，每一次我们调用 &lt;code class=&quot;inline&quot;&gt;conc&lt;/code&gt; 时的 &lt;code class=&quot;inline&quot;&gt;list&lt;/code&gt; 的长度不会大于 ，所以每次调用是均摊  的 ，而每一次会使两颗树同时向下一层，在其中一颗树触底时递归结束，所以递归层数不会超过  。&lt;/p&gt;&lt;p&gt;好的，我们的树现在可以实现 &lt;code class=&quot;inline&quot;&gt;concat&lt;/code&gt; 了，めでたしめでたし。&lt;/p&gt;&lt;h2&gt;实现其它操作的基础&lt;/h2&gt;&lt;p&gt;但上面的数据结构也仅仅只能做到这一步了，如果想要实现其它的功能，我们需要为它加上一些东西。&lt;/p&gt;&lt;p&gt;我们重写 Finger Tree 的各组成部分并添加标注 &lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Node v a
      = Node2 v a a
      | Node3 v a a a
  
  data FingerTree v a
      = Empty
      | Single a
      | Deep v (Digit a) (FingerTree v (Node v a)) (Digit a)&lt;/code&gt;&lt;p&gt;这里的 &lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt; 是 Finger Tree 需要维护的&lt;i&gt;某种&lt;/i&gt;东西，而我们将会限制它的类型为 &lt;code class=&quot;inline&quot;&gt;Monoid&lt;/code&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;为什么是 &lt;code class=&quot;inline&quot;&gt;Monoid&lt;/code&gt; ？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Finger Tree 事实上维护的是一个序列，而这里的 &lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt; 是序列的某种性质，那么它应该对&lt;i&gt;空序列&lt;/i&gt;有对应的值，而且能正确的处理 Finger Tree 中频繁的序列合并的情况。所以我们需要一个有幺元和有结合律的东西。&lt;/p&gt;&lt;p&gt;为了用到我们添加的 &lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt; ，我们可以引入一个 type class :&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; class Monoid v =&amp;gt; Measured a v where
      measure :: a -&amp;gt; v&lt;/code&gt;&lt;p&gt;直接写是会报错的，需要打开 GHC 扩展&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;{-# LANGUAGE MultiParamTypeClasses #-}&lt;/code&gt;&lt;p&gt;我们利用 &lt;code class=&quot;inline&quot;&gt;Measure&lt;/code&gt; 来&lt;i&gt;计算&lt;/i&gt;出我们需要的值&lt;/p&gt;&lt;p&gt;Finger Tree 的各部分都可以实现为 &lt;code class=&quot;inline&quot;&gt;Measured&lt;/code&gt; 的一个实例&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; instance Measured a v =&amp;gt; Measured (Node v a) v where
      measure (Node2 v _ _) = v
      measure (Node3 v _ _ _) = v
  
  instance Measured a v =&amp;gt; Measured (Node v a) v where
      measure (Node2 v _ _) = v
      measure (Node3 v _ _ _) = v
      
  instance Measured a v =&amp;gt; Measured (Digit a) v where
      measure (Digit [a]) = measure a
      measure (Digit (a : as)) = 
          measure a `mappend` measure (Digit as)
      
  instance Measured a v =&amp;gt; Measured (FingerTree v a) v where
      measure Empty = mempty
      measure (Single a) = measure a
      measure (Deep v _ _ _) = v&lt;/code&gt;&lt;p&gt;为了简化 &lt;code class=&quot;inline&quot;&gt;mappend&lt;/code&gt; 的使用，我们把 Semi Group 中的 &lt;code class=&quot;inline&quot;&gt;&amp;lt;&amp;gt;&lt;/code&gt; 借过来用一下&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; infixl 5 &amp;lt;&amp;gt;
  (&amp;lt;&amp;gt;) :: Monoid a =&amp;gt; a -&amp;gt; a -&amp;gt; a
  (&amp;lt;&amp;gt;) = mappend&lt;/code&gt;&lt;p&gt;然后我们就可以愉快的重写之前的代码了 XD&lt;/p&gt;&lt;p&gt;首先是 &lt;code class=&quot;inline&quot;&gt;Node&lt;/code&gt; 的新构造函数需要把 &lt;code class=&quot;inline&quot;&gt;v&lt;/code&gt; 一并计算(只写 node2)：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; node2 :: Measured a v =&amp;gt; a -&amp;gt; a -&amp;gt; Node v a
  node2 a b = Node2 (measure a &amp;lt;&amp;gt; measure b) a b&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Deep&lt;/code&gt; 也一样&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; deep :: 
      Measured a v =&amp;gt; 
      Digit a -&amp;gt; 
      FingerTree v (Node v a) -&amp;gt; 
      Digit a -&amp;gt; 
      FingerTree v a
  deep l m r = Deep (measure l &amp;lt;&amp;gt; measure m &amp;lt;&amp;gt; measure r) l m r&lt;/code&gt;&lt;p&gt;其它的部分也没有很多变化，照着写即可。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;把树分裂成两棵&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;有了 &lt;code class=&quot;inline&quot;&gt;Measured&lt;/code&gt; 我们就能够实现 &lt;code class=&quot;inline&quot;&gt;split&lt;/code&gt; 了。为了合理的表示 &lt;code class=&quot;inline&quot;&gt;split&lt;/code&gt; 的结果，我们定义这么一个数据结构&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Split s a = Split (s a) a (s a)&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Split&lt;/code&gt; 的三个数据域分别存放 &lt;code class=&quot;inline&quot;&gt;split&lt;/code&gt; 目标的左侧部分、目标、右侧部分。&lt;/p&gt;&lt;p&gt;当然这里用 Tuple 也是可以的&lt;/p&gt;&lt;p&gt;假设给出一个函数 &lt;code class=&quot;inline&quot;&gt;f :: v -&amp;gt; Bool&lt;/code&gt; ，对 Finger Tree 所维护的序列使用时结果是单调的，即在越过某个结点之前结果都是 &lt;code class=&quot;inline&quot;&gt;False&lt;/code&gt;  ，我们就能将 Finger Tree 在这个结点分成 3 份。&lt;/p&gt;&lt;p&gt;我们要实现这么一个函数：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; splitTree :: 
      Measured a v =&amp;gt;
      (v -&amp;gt; Bool) -&amp;gt;
      v -&amp;gt;
      FingerTree v a -&amp;gt;
      Split (FingerTree v a) a&lt;/code&gt;&lt;p&gt;显然的，我们不应该在一棵空树上 &lt;code class=&quot;inline&quot;&gt;split&lt;/code&gt; ，所以&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; splitTree _ _ Empty = error &quot;You should not split on an empty tree&quot;&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Single&lt;/code&gt; 的话很简单，问题就在于 &lt;code class=&quot;inline&quot;&gt;Deep&lt;/code&gt; 该如何处理，方法和线段树一样。&lt;/p&gt;&lt;p&gt;分  种情况，分界点在左 &lt;code class=&quot;inline&quot;&gt;Digit&lt;/code&gt; 上、分界点在子树上、分界点在右 &lt;code class=&quot;inline&quot;&gt;Digit&lt;/code&gt; 上。 ,  实际上是一种，我们放在一起考虑。&lt;/p&gt;&lt;p&gt;如果分界点在 &lt;code class=&quot;inline&quot;&gt;Digit&lt;/code&gt; 上，我们可以单独使用一个函数来处理这种情形&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; splitDigit :: Measure a v =&amp;gt; (v -&amp;gt; Bool) -&amp;gt; v -&amp;gt; Digit -&amp;gt; Split [] a&lt;/code&gt;&lt;p&gt;因为 &lt;code class=&quot;inline&quot;&gt;Digit&lt;/code&gt; 实际上就是个 &lt;code class=&quot;inline&quot;&gt;list&lt;/code&gt; ，所以只需要沿着每个结点判断一次就可以了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; splitDigit _ _ (Digit [a]) = Split [] a []
  splitDigit f i (Digit (a : as))
      | f (i &amp;lt;&amp;gt; measure a) = Split [] a as
      | otherwise = 
          let Split l x r = splitDigit f (i &amp;lt;&amp;gt; measure a) (Digit as) 
          in
              Split (a : l) x r
  splitDigit _ _ _ = error &quot;What the fuck ??&quot;&lt;/code&gt;&lt;p&gt;而如果分界点在树上，我们就可以递归调用这个过程，对子树直接使用 &lt;code class=&quot;inline&quot;&gt;splitTree&lt;/code&gt; ，会拿到一个 &lt;code class=&quot;inline&quot;&gt;Node a&lt;/code&gt; 回来，再把它转成 &lt;code class=&quot;inline&quot;&gt;Digit&lt;/code&gt; 并再使用一次 &lt;code class=&quot;inline&quot;&gt;splitDigit&lt;/code&gt; 就能拿到那个元素了。&lt;/p&gt;&lt;p&gt;再者就是 &lt;code class=&quot;inline&quot;&gt;splitDigit&lt;/code&gt; 拿回来的可能是一个空 &lt;code class=&quot;inline&quot;&gt;list&lt;/code&gt; ，所以这里要使用前面提到的 &lt;code class=&quot;inline&quot;&gt;deepL&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;deepR&lt;/code&gt; 来构造新的 Finger Tree&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;splitTree _ _ Empty = error &quot;Split on an empty tree!&quot;
  splitTree _ _ (Single x) = Split Empty x Empty
  splitTree f i (Deep _ l m r)
      | f iml = let Split l&#39; x r&#39; = splitDigit f i l in
          Split (toTree l&#39;) x (deepL r&#39; m r)
      | f imm = let Split l&#39; xs r&#39; = splitTree f iml m
                    Split l&#39;&#39; x r&#39;&#39; = splitDigit f (iml &amp;lt;&amp;gt; measure l&#39;) (nodeToDigit xs) in
          Split (deepR l l&#39; l&#39;&#39;) x (deepL r&#39;&#39; r&#39; r)
      | otherwise = 
          let Split l&#39; x r&#39; = splitDigit f imm r in
              Split (deepR l m l&#39;) x (toTree r&#39;)
      where iml = i &amp;lt;&amp;gt; measure l
            imm = iml &amp;lt;&amp;gt; measure m&lt;/code&gt;&lt;p&gt;于是 &lt;code class=&quot;inline&quot;&gt;split&lt;/code&gt; 也很显然了&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; split :: Measured a v =&amp;gt;
      (v -&amp;gt; Bool) -&amp;gt; 
      FingerTree v a -&amp;gt;
      (FingerTree v a, FingerTree v a)
  split _ Empty = (Empty, Empty)
  split f xs
      | f (measure xs) = (l, x &amp;lt;| r)
      | otherwise = (xs, Empty)
      where Split l x r = splitTree f mempty xs&lt;/code&gt;&lt;p&gt;在整个序列都不满足条件的时候我们直接返回空树&lt;/p&gt;&lt;p&gt;它的时间复杂度与合并两颗 Finger Tree 类似，也是均摊 &lt;equation&gt;\Theta(\min(n, n - m))&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;&lt;b&gt;下标访问&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;为了提供 &lt;code class=&quot;inline&quot;&gt;Seq&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 功能，我们需要为它定制一个 &lt;code class=&quot;inline&quot;&gt;Monoid&lt;/code&gt; 来实现取 size 的功能&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; newtype Sized = Size {getSize :: Int} deriving(Eq, Ord)&lt;/code&gt;&lt;p&gt;这里的 &lt;code class=&quot;inline&quot;&gt;Sized&lt;/code&gt; 就是封装过的 &lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt; ，而整数本身是一个幺半群。&lt;/p&gt;&lt;p&gt;于是有：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; instance Monoid Sized where
      mempty = Size 0
      Size a `mappend` Size b = Size $ a + b&lt;/code&gt;&lt;p&gt;然后可以把它套到 &lt;code class=&quot;inline&quot;&gt;Measure&lt;/code&gt; 上，但这里我们需要对 &lt;code class=&quot;inline&quot;&gt;Seq&lt;/code&gt; 的原始数据进行一次封装，塞到 &lt;code class=&quot;inline&quot;&gt;Elem&lt;/code&gt; 中。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; newtype Elem a = Elem {getElem :: a}
  newtype Seq a = Seq (FingerTree Size (Elem a))&lt;/code&gt;&lt;p&gt;然后实现 &lt;code class=&quot;inline&quot;&gt;Measure&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;instance&lt;/code&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;instance Measure (Elem a) Sized where
      measure _ = Size 1&lt;/code&gt;&lt;p&gt;于是在 &lt;code class=&quot;inline&quot;&gt;FingerTree Size (Elem a)&lt;/code&gt; 的数据域中，存放的就是当前树的大小，所以我们可以轻松地实现 &lt;code class=&quot;inline&quot;&gt;length&lt;/code&gt; ：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; length :: Seq a -&amp;gt; Int
  length (Seq xs) = getSize $ measure xs&lt;/code&gt;&lt;p&gt;还记得我们之前实现的 &lt;code class=&quot;inline&quot;&gt;FingerTree v a&lt;/code&gt; 作为 &lt;code class=&quot;inline&quot;&gt;Measure&lt;/code&gt; 的实例吗，在这里就派上了用场。&lt;/p&gt;&lt;p&gt;然后是 &lt;code class=&quot;inline&quot;&gt;splitAt&lt;/code&gt; ，在特定的下标处分离两个序列&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; splitAt :: Int -&amp;gt; Seq a -&amp;gt; (Seq a, Seq a)
  splitAt i (Seq xs) = (Seq l, Seq r)
      where (l, r) = split (Size i &amp;lt;) xs&lt;/code&gt;&lt;p&gt;在满足 &lt;code class=&quot;inline&quot;&gt;Size i &amp;lt; Size x&lt;/code&gt; 之前的一共有  个元素，所以就是相当于从  处切开。&lt;/p&gt;&lt;p&gt;同时 &lt;code class=&quot;inline&quot;&gt;index&lt;/code&gt; 也类似&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; index :: Seq a -&amp;gt; Int -&amp;gt; a
  index (Seq xs) i = getElem x
      where Split _ x _ = splitTree (Size i &amp;lt;) mempty xs&lt;/code&gt;&lt;h2&gt;&lt;b&gt;实现优先队列&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;类似于 &lt;code class=&quot;inline&quot;&gt;Sized&lt;/code&gt; 这个 Monoid ，我们同样可以借助其它的 Monoid 来使我们的 Finger Tree 支持其它的操作，优先队列就是一个例子。&lt;/p&gt;&lt;p&gt;我们维护的序列性质就变成了序列中的最大值：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Priority a
      = MinusInf
      | Priority a
      deriving(Eq, Ord)&lt;/code&gt;&lt;p&gt;显然，它也是一个 Monoid :&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; instance Ord a =&amp;gt; Monoid (Priority a) where
      mempty = MinusInf
      a `mappend` MinusInf = a
      MinusInf `mappend` a = a
      (Priority a) `mappend` (Priority b) = Priority (a `max` b)&lt;/code&gt;&lt;p&gt;当它用在 Finger Tree 上时表示一个区间上的最大值，我们可以定义：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; newtype PriorityQueue a = PQ (FingerTree (Priority a) (Elem a))&lt;/code&gt;&lt;p&gt;然后定义 &lt;code class=&quot;inline&quot;&gt;Measured&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;instance&lt;/code&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; instance (Ord a) =&amp;gt; Measured (Elem a) (Priority a) where
      measure (Elem a) = Priority a&lt;/code&gt;&lt;p&gt;作为优先队列它可以随意从前面或者后面插入，当删除最大结点时只需要利用 &lt;code class=&quot;inline&quot;&gt;splitTree&lt;/code&gt; 找到最大结点把它拿出来即可&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; pop :: Ord a =&amp;gt; PriorityQueue a -&amp;gt; (a, PriorityQueue a)
  pop (PQ q) = (x, PQ (l &amp;gt;&amp;lt; r))
      where Split l x r = splitTree (measure q &amp;lt;=) mempty q&lt;/code&gt;&lt;h2&gt;&lt;b&gt;实现有序序列&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果再换一个 Monoid 实现，我们又能得到一个类似于有序列表的东西&lt;/p&gt;&lt;p&gt;有序表中较大元素在右边，而我们维护的序列性质仍然是序列最大值，所以 &lt;code class=&quot;inline&quot;&gt;Monoid&lt;/code&gt; 的操作也很显然&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Key a 
      = None
      | Key a
      deriving(Eq, Ord)
  
  instance Monoid (Key a) where
      mempty = None
      None `mappend` None = None
      a `mappend` None = a
      _ `mappend` a = a&lt;/code&gt;&lt;p&gt;然后我们定义&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; newtype Set a = Set (FingerTree (Key a) (Elem a))
  
  instance Measured (Elem a) (Key a) where
      measure (Elem a) = Key a&lt;/code&gt;&lt;p&gt;同样是依赖于 &lt;code class=&quot;inline&quot;&gt;split&lt;/code&gt; ，我们可以实现根据一个元素来划分序列的函数：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; partition :: Ord a =&amp;gt; a -&amp;gt; Set a -&amp;gt; (Set a, Set a)
  partition k (Set xs) = (Set l, Set r)
      where (l, r) = split (&amp;gt;= Key k) xs&lt;/code&gt;&lt;p&gt;于是我们可以实现 &lt;code class=&quot;inline&quot;&gt;Set&lt;/code&gt; 的插入和删除&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; insert :: Ord a =&amp;gt; a -&amp;gt; Set a -&amp;gt; Set a
  insert x (Set xs) = Set (l &amp;gt;&amp;lt; (Elem x &amp;lt;| r))
      where (l, r) = split (&amp;gt;= Key x) xs
  
  delete :: Ord a =&amp;gt; a -&amp;gt; Set a -&amp;gt; Set a
  delete x (Set xs) = Set (l1 &amp;gt;&amp;lt; r2)
      where (l1, r1) = split (&amp;gt;= Key x) xs
            (_ , r2) = split (&amp;gt;  Key x) r1&lt;/code&gt;&lt;p&gt;合并两个 &lt;code class=&quot;inline&quot;&gt;Set&lt;/code&gt; 可以用启发式合并，具体的思路是每次取出其中一棵树的最小值，然后以其为基准把另一棵树分开，随即将“左半部分和该最小值”与“右半部份和取出最小值后剩下的部分继续合并的结果”连接起来。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; merge :: Ord a =&amp;gt; Set a -&amp;gt; Set a -&amp;gt; Set a
  merge (Set xs) (Set ys) = Set (mergeSet xs ys)
      where mergeSet as bs = 
              case viewL bs of
              Nil -&amp;gt; as
              Cons b bs&#39; -&amp;gt; l &amp;gt;&amp;lt; (b &amp;lt;| mergeSet bs&#39; r)
                  where (l, r) = split (&amp;gt; measure b) as&lt;/code&gt;&lt;p&gt;它的时间复杂度是 &lt;equation&gt;O(m\log\frac{n}{m})&lt;/equation&gt;  。这个结果不是那么显然，这里简要的说几句。&lt;/p&gt;&lt;p&gt;两个有序序列 &lt;equation&gt;X&lt;/equation&gt; (长度为 &lt;equation&gt;m&lt;/equation&gt; )和  &lt;equation&gt;Y&lt;/equation&gt; (长度为 &lt;equation&gt;n&lt;/equation&gt; )的合并结果一定可以表示为下个式子的形式&lt;/p&gt;&lt;p&gt;&lt;equation&gt;X_0Y_1X_1\cdots X_{b-1}Y_b&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中 &lt;equation&gt;X_0&lt;/equation&gt;  和  &lt;equation&gt;Y_b&lt;/equation&gt; 可能为空。&lt;/p&gt;&lt;p&gt;而把 &lt;equation&gt;n&lt;/equation&gt;  个大小分别为 &lt;equation&gt;a_1, a_2, a_3, \cdots , a_n&lt;/equation&gt; 的 Finger Tree 直接粘起来的复杂度是 &lt;/p&gt;&lt;p&gt;&lt;equation&gt;O\Big(\sum_{i = 1}^n\log a_i\Big)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;我们把这里 &lt;equation&gt;O(b)&lt;/equation&gt;  个片段粘起来的复杂度是&lt;/p&gt;&lt;p&gt;&lt;equation&gt;O\bigg(\sum_{i=0}^{b-1}\log{|X_i|} + \sum_{i = 1}^b\log {|Y_i|}\bigg)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;而 &lt;/p&gt;&lt;p&gt;&lt;equation&gt;\sum_{i=0}^{b-1}\log{|X_i|} + \sum_{i=1}^b{\log{|Y_i|}} \leq b\log\frac{m}{b} + b\log\frac{n}{b} \leq 2b\log\frac{n}{b} \leq 2m\log\frac{n}{m}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;所以复杂度不高于 &lt;equation&gt;O(m\log\frac{n}{m})&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;&lt;b&gt;继续扩展&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Finger Tree 的可扩展性在于你只需要定制一种需要维护的区间性质的 &lt;code class=&quot;inline&quot;&gt;Monoid&lt;/code&gt; ，你就能轻易地套上去并使用。比如玩烂的区间最大连续和，Finger Tree 套上就能写。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;一点点实现细节&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;事实上，&lt;code class=&quot;inline&quot;&gt;Digit&lt;/code&gt; 我们使用的是 &lt;code class=&quot;inline&quot;&gt;list&lt;/code&gt; 来实现的，这肯定会带来一些效率上的问题，所以在库中，&lt;code class=&quot;inline&quot;&gt;Digit&lt;/code&gt; 都是这么定义的&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data Digit a
      = One a
      | Two a a 
      | Three a a a
      | Four a a a a&lt;/code&gt;&lt;p&gt;这会带来很可怕的代码膨胀，尤其是在实现 &lt;code class=&quot;inline&quot;&gt;appendTree&lt;/code&gt; 这个函数时。&lt;/p&gt;&lt;p&gt;首先我们需要的是&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; addDigits :: Sized a =&amp;gt; 
      FingerTree (Node a) -&amp;gt; 
      Digit a             -&amp;gt; 
      Digit a             -&amp;gt; 
      FingerTree (Node a) -&amp;gt;
      FingerTree (Node a)&lt;/code&gt;&lt;p&gt;种 &lt;code class=&quot;inline&quot;&gt;Digit&lt;/code&gt; ，有两个，共有  种情形，每种都要写一个。&lt;/p&gt;&lt;p&gt;而不同的 &lt;code class=&quot;inline&quot;&gt;Digit&lt;/code&gt; 揉在一起的 &lt;code class=&quot;inline&quot;&gt;Node&lt;/code&gt; 数量也不一样，所以也需要像这样的函数&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; appendTree&#39; :: 
      FingerTree (Node a) -&amp;gt; 
      Node a              -&amp;gt; 
      FingerTree (Node a) -&amp;gt; 
      FingerTree (Node a)&lt;/code&gt;&lt;p&gt;而它的实现又不可避开一个这样的函数：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; addDigits&#39; :: 
      FingerTree (Node (Node a))  -&amp;gt; 
      Digit (Node a)              -&amp;gt; 
      Node a                      -&amp;gt; 
      Digit (Node a)              -&amp;gt; 
      FingerTree (Node (Node a))  -&amp;gt; 
      FingerTree (Node (Node a))&lt;/code&gt;&lt;p&gt;而它又依赖另外一个：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; appendTree&#39;&#39; :: 
      FingerTree (Node a) -&amp;gt; 
      Node a              -&amp;gt; 
      Node a              -&amp;gt; 
      FingerTree (Node a) -&amp;gt; 
      FingerTree (Node a)&lt;/code&gt;&lt;p&gt;如此循环往复，直到参数中间包含  个 &lt;code class=&quot;inline&quot;&gt;Node&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;这些全部实现下来大概有 200 行……我放一张 code map 缩略图给大家看一下&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ddff8a519e6faf7b690845787029f763_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;87&quot; data-rawheight=&quot;581&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;还有就是在真正实现高性能 Haskell 代码时，不可避免的要涉及到 Strictness,  Unpack 等特性，例如在 &lt;code class=&quot;inline&quot;&gt;Data.Seq&lt;/code&gt; 中实现的 Finger Tree,  就使用了 Strictness flag 来防止不必要的延迟求值，并使用了 unpack 来提升性能&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt; data FingerTree a
      = Empty
      | Single a
      | Deep {-# UNPACK #-} !Int !(Digit a) (FingerTree (Node a)) !(Digit a)&lt;/code&gt;&lt;p&gt;在这里不做讨论(不懂)。&lt;/p&gt;&lt;h2&gt;你看完了这篇文章&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;你学到了什么&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;可能学到了一点 Haskell 实现数据结构的姿势&lt;/p&gt;&lt;h2&gt;&lt;b&gt;你觉得这篇文章可能有很多问题&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;欢迎指正&lt;/p&gt;&lt;h2&gt;参考文献 &amp;amp; 推荐阅读&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Finger_tree&quot;&gt;Finger Tree 的维基百科&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://hackage.haskell.org/package/fingertree-0.1.2.1/docs/src/Data-FingerTree.html&quot;&gt;Finger Tree 的 hackage 源码&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.staff.city.ac.uk/~ross/papers/FingerTree.pdf&quot;&gt;Finger Tree 的论文&lt;/a&gt;  （强烈推荐）&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://xueshu.baidu.com/s?wd=paperuri%3A%28bf79af0c1ab7a3574e965f8457c1e424%29&amp;amp;filter=sc_long_sign&amp;amp;tn=SE_xueshusource_2kduw22v&amp;amp;sc_vurl=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.51.4571%26rep%3Drep1%26type%3Dpdf&amp;amp;ie=utf-8&amp;amp;sc_us=6093570767507930986&quot;&gt;Finger Tree 的部分复杂度证明&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.staff.city.ac.uk/~ross/papers/FingerTree.html&quot;&gt;Paper 的网站&lt;/a&gt;&lt;/p&gt;</description>
<author>zjuwyd</author>
<guid isPermaLink="false">2017-10-30-30589105</guid>
<pubDate>Mon, 30 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Lens：从入门到入门</title>
<link>https://henix.github.io/feeds/zhuanlan.zju-lambda/2017-10-29-30544410.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30544410&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-aaf2eb05bd1a9cdd7418bb083208767d_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;概览&lt;/h2&gt;&lt;p&gt;Haskell 语言中操作一个复杂的数据结构往往会成为一个问题。&lt;/p&gt;&lt;p&gt;例如我们用 Haskell 做一个RPG游戏，有下面的定义：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Hero = Hero {
  heroLevel :: Int, weapon :: Weapon
}

data Weapon = Weapon {
  basicAttack :: Int, weaponLevel :: Int, magicGem :: Gem
}
data Gem = Gem {
  gemLevel :: Int,
  gemName :: String
} 
setHeroLevel :: Hero -&amp;gt; Int -&amp;gt; Hero
setWeapon    :: Weapon -&amp;gt; Hero -&amp;gt; Hero
-- and so on. &lt;/code&gt;&lt;p&gt;对于简单的从深层结构中提取出一个值仍然是可接受的：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;gemLevel.magicGem.weapon $ hero
-- Or
hero &amp;amp; (weapon&amp;gt;&amp;gt;&amp;gt;magicGem&amp;gt;&amp;gt;&amp;gt;gemLevel)&lt;/code&gt;&lt;p&gt;但修改内层数据（并返回一个新的对象）则显得过于繁杂：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;hero&#39; = hero {
    weapon = (weapon hero) {
        magicGem = (magicGem.weapon $ hero){
            gemName = &quot;WTF&quot; }}}&lt;/code&gt;&lt;p&gt;可以看到，这里仅仅三层嵌套，一个修改的操作就已经及其复杂了。&lt;/p&gt;&lt;p&gt;为了解决这个问题 Haskell 语言中有一种被称为「Lens」的工具，可是实现下面这样的写法：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;view (weaponLens.magicGemLens.gemLevelLens) hero
hero&#39;  = set (weaponLens.magicGemLens.gemNameLens) &quot;Gem&quot; hero
hero&#39;&#39; = over (weaponLens.magicGemLens.gemLevelLens) (+1) hero

-- 中缀版本
hero .^ weaponLens.magicGemLens.gemLevelLens 
hero&#39;  = hero &amp;amp; weaponLens.magicGemLens.gemNameLens .~ &quot;Gem&quot; 
hero&#39;&#39; = hero &amp;amp; weaponLens.magicGemLens.gemLevelLens) %~ (+1)&lt;/code&gt;&lt;p&gt;这里的代码已经非常接近于普通的命令式语言中的写法了，非常自然、易用。&lt;/p&gt;&lt;p&gt;普通的命令式语言中用 &lt;code class=&quot;inline&quot;&gt;.&lt;/code&gt; 从一个结构中提取它的一个子域，而这里我们在 Haskell 中通过 Lens 实现了类似的效果。同时我们注意到，这里的&lt;code class=&quot;inline&quot;&gt;.&lt;/code&gt; 不是凭空出现的，而是我们熟悉的 Haskell 中的函数复合。即 Lens 完成上面这些复杂操作的一个基本思路是复合。&lt;/p&gt;&lt;h2&gt;简版 Lens   &lt;/h2&gt;&lt;p&gt;实际上，如果我们已经有了这些对象对应的 getter 和 setter 函数，那么我们不难将他们之间互相复合形成操作深层数据的新的 getter 和 setter。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type L a b = (a -&amp;gt; b, b -&amp;gt; a -&amp;gt; a)

(.&amp;gt;) :: L a b -&amp;gt; L b c -&amp;gt; L a c
(g1, s1) .&amp;gt; (g2, s2) = (g2 . g1, \c a -&amp;gt; s1 (s2 c (g1 a)) a)

viewL :: L a b -&amp;gt; a -&amp;gt; b
viewL (g, _) = g

setL :: L a b -&amp;gt; b -&amp;gt; a -&amp;gt; a
setL (_, s) = s

overL :: L a b -&amp;gt; (b -&amp;gt; b) -&amp;gt; a -&amp;gt; a 
overL (g, s) f a = s (f $ g a) a&lt;/code&gt;&lt;p&gt;我们直接将一个 getter 与 setter 包装成二元组。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponL   = (weapon, setWeapon)
gemLevelL = (gemLevel, setGemLevel) &lt;/code&gt;&lt;p&gt;这种情况下，我们定义的“简版 Lens ”的使用与前文演示的 Lens 是极其相似的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;viewL (weaponL.&amp;gt;magicGemL.&amp;gt;gemLevelL) hero
hero&#39; = setL (weaponL.&amp;gt;magicGemL.&amp;gt;gemLevelL) 2 hero&lt;/code&gt;&lt;p&gt;我们的实现仍然借助了复合的思想，但是需要我们自己来实现针对 getter 和 setter 的复合，而前文演示的却是真正的函数复合。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;实现 Lens 的准备工作&lt;/h2&gt;&lt;p&gt;我们已经注意到文章开头的 Lens 有几个特点&lt;/p&gt;&lt;ul&gt;&lt;li&gt;是普通的函数类型，可以互相复合；&lt;/li&gt;&lt;li&gt;与对象类型&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt; 和域类型 &lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; 相关；&lt;/li&gt;&lt;li&gt;可以用来实现看似相反的两个操作 get 和 set。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面我们尝试找出这个类型&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens b a = (???  ) -&amp;gt; (???)&lt;/code&gt;&lt;p&gt;考虑它的复合特点，按照结构的嵌套顺序，从前向后依次是从内向外：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;aL :: Lens b a
cL :: Lens a c
aL.cL :: Lens b c&lt;/code&gt;&lt;p&gt;要实现这样的复合特性，应当是&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type SomeType a = ...

aL :: SomeType a -&amp;gt; SomeType b
cL :: SomeType c -&amp;gt; SoemType a
aL.cL :: SomeType c -&amp;gt; SomeType b&lt;/code&gt;&lt;p&gt;即上面的第一个 (???) 与&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;有关，第二个与&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;有关。&lt;/p&gt;&lt;p&gt;同时，&lt;code class=&quot;inline&quot;&gt;Lens b a&lt;/code&gt;一定会接受一个&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;类型的参数作为要操作的主体对象，我们可以进一步写成&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens b a = (???) -&amp;gt; (b -&amp;gt; ???)&lt;/code&gt;&lt;p&gt;而上面的复合特性要求前后是两个类似的类型&lt;code class=&quot;inline&quot;&gt;SomeType&lt;/code&gt;，我们进一步改写为&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens b a = (a -&amp;gt; ???) -&amp;gt; (b -&amp;gt; ???)&lt;/code&gt;&lt;p&gt;我们可以猜测到，&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt; 等函数调用&lt;code class=&quot;inline&quot;&gt;Lens&lt;/code&gt;，传递进一个函数&lt;code class=&quot;inline&quot;&gt;(a -&amp;gt; ???)&lt;/code&gt;来实现了不同的操作。&lt;/p&gt;&lt;h2&gt;View Lens 的实现&lt;/h2&gt;&lt;p&gt;我们先尝试写出一个特定类型的 Lens ，来只支持&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;操作，根据上文的分析，&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;函数的定义应该形如下：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view :: VLens b a -&amp;gt; b -&amp;gt; a
view lens b = lens ??? b&lt;/code&gt;&lt;p&gt;考虑我们之前的例子&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponVLens   :: (Weapon -&amp;gt; ???) -&amp;gt; (Hero -&amp;gt; ???)
magicGemVLens :: (Gem -&amp;gt; ???)    -&amp;gt; (Weapon -&amp;gt; ???)
gemLevelVLens :: (Int -&amp;gt; ???)    -&amp;gt; (Gem -&amp;gt; ???)&lt;/code&gt;&lt;p&gt;如果我们想要获得英雄的武器上的宝石的宝石等级，那么我们想要的可能是这样的东西：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponVLens.magicGemVLens.gemLevelVLens :: (Int -&amp;gt; Int) -&amp;gt; (Hero -&amp;gt; Int)&lt;/code&gt;&lt;p&gt;这样，&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;函数便可以对这个复合的&lt;code class=&quot;inline&quot;&gt;VLens&lt;/code&gt;传入某个函数，再传入我们的英雄，就可以得到宝石等级了。为了让这样的复合成为可能，上面的所有 ??? 都必须是&lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt;。我们可以想象到那个代表&lt;code class=&quot;inline&quot;&gt;GemLevel&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt;在函数间传递的效果。&lt;/p&gt;&lt;p&gt;同理，如果我们只想得到武器上的宝石的话，我们需要的是这样的东西：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponVLens.magicGemVLens :: (Gem -&amp;gt; Gem) -&amp;gt; (Hero -&amp;gt; Gem)&lt;/code&gt;&lt;p&gt;这时候这些&lt;code class=&quot;inline&quot;&gt;???&lt;/code&gt;又成为了&lt;code class=&quot;inline&quot;&gt;Gem&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;由此可见，在&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;的场合下，这里的类型&lt;code class=&quot;inline&quot;&gt;???&lt;/code&gt;随着提取的东西不同而变化，并且等于我们要提取的东西的类型。这样&lt;code class=&quot;inline&quot;&gt;VLens&lt;/code&gt;的类型定义便得到了：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type VLens b a = forall c. (a -&amp;gt; c) -&amp;gt; (b -&amp;gt; c)&lt;/code&gt;&lt;p&gt;所有的&lt;code class=&quot;inline&quot;&gt;VLens&lt;/code&gt;在复合时都接受内层的一个提取操作，并返回一个嵌套了的提取操作。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponVLens  :: VLens Hero Weapon
weaponVLens f = \h -&amp;gt; f (weapon h)

magicGemVLens :: VLens Weapon Gem
magicGemVLens f = \w -&amp;gt; f (magicGem w)

gemLevelVLens :: VLens Gem Int
gemLevelVLens f = \g -&amp;gt; f (gemLevel g)&lt;/code&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-eb3ff4069ec471c1c69250a6355a85a1_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;503&quot; data-rawheight=&quot;417&quot;&gt;&lt;p&gt;而最终传入我们要操作的外层对象之后，则用相仿的顺序，一层层地完成了提取操作，直到最内层，这时我们只需要使用&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;函数使其原样返回即可。&lt;/p&gt;&lt;p&gt;由此，&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;函数的定义便可以得到了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;viewV vlens b = vlens id b&lt;/code&gt;&lt;h2&gt;Over Lens 的实现&lt;/h2&gt;&lt;p&gt;再次考虑我们的例子&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponOLens   :: (Weapon -&amp;gt; ???) -&amp;gt; (Hero -&amp;gt; ???)
magicGemOLens :: (Gem -&amp;gt; ???)    -&amp;gt; (Weapon -&amp;gt; ???)
gemNameOLens  :: (Int -&amp;gt; ???)    -&amp;gt; (Gem -&amp;gt; ???)&lt;/code&gt;&lt;p&gt;现在我们希望对一个对象的某个域进行修改，并返回修改过了的对象。那么后面的 ??? 则应该与和它紧靠着的类型相同，而为了使这些&lt;code class=&quot;inline&quot;&gt;OLens&lt;/code&gt;可以互相复合，前面的 ??? 应该与紧靠着的前面类型相同。例如：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponOLens.magicGemOLens :: (Gem -&amp;gt; Gem) -&amp;gt; (Hero -&amp;gt; Hero)&lt;/code&gt;&lt;p&gt;可以看到 &lt;code class=&quot;inline&quot;&gt;OLens&lt;/code&gt;的类型比较简单&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type OLens b a =  (a -&amp;gt; a) -&amp;gt; (b -&amp;gt; b)&lt;/code&gt;&lt;p&gt;观察一下便可以得到，第一个参数&lt;code class=&quot;inline&quot;&gt;(a -&amp;gt; a)&lt;/code&gt;便是我们对域进行操作的更新函数了。此时&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;函数不需要再做其他多余的事情，只需要将&lt;code class=&quot;inline&quot;&gt;OLens&lt;/code&gt;原样返回。而各个&lt;code class=&quot;inline&quot;&gt;OLens&lt;/code&gt;的定义也只不过是产生一个新的修改函数，这个修改函数将自己管辖的域修改为已经被修改过了的内层对象。而最内层则会使用用户传入的修改函数f来完成相应的操作。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponOLens ::  OLens Hero Weapon
weaponOLens f = \h -&amp;gt; (`setWeapon` h) $ f (weapon h)

magicGemOLens :: OLens Weapon Gem
magicGemOLens f = \w -&amp;gt; (`setMagicGem` w) $ f (magicGem w)

gemLevelOLens :: OLens Gem Int
gemLevelOLens f = \g -&amp;gt; (`setGemLevel` g) $ f (gemLevel g)&lt;/code&gt;&lt;p&gt;这样，当最终传入需要处理的外层对象时，&lt;code class=&quot;inline&quot;&gt;OLens&lt;/code&gt;便会一层层地完成修改的工作。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;set&lt;/code&gt;而言，只不过是一种特殊的&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;setO vlens s = vlens (const s)&lt;/code&gt;&lt;h2&gt;最终实现 Lens&lt;/h2&gt;&lt;p&gt;现在，我们已经分别实现了&lt;code class=&quot;inline&quot;&gt;VLens&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;OLens&lt;/code&gt;，而且发现他们之间有相似之处。实际上他们都是从一个相同的&lt;code class=&quot;inline&quot;&gt;(a -&amp;gt; ???) -&amp;gt; (b -&amp;gt; ???)&lt;/code&gt; 经过我们一系列对其性质的分析得到的。我们的最终目的是通过单一的&lt;code class=&quot;inline&quot;&gt;Lens&lt;/code&gt;类型，来实现&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;这样不同的行为，即需要某种多态。而下面的类型却无法为这种多态提供帮助。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens b a -&amp;gt; forall c d. (a -&amp;gt; c) -&amp;gt; (b -&amp;gt; d)&lt;/code&gt;&lt;p&gt;我们需要某种类型，我们可以对其中的内容进行操作，并且这种操作的行为随使用者的需求而可以多态变化。符合这样特点的，正是我们熟悉的 Functor 。所以我们便可以这样做了：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type Lens b a = Functor f =&amp;gt; (a -&amp;gt; f a) -&amp;gt; (b -&amp;gt; f b)&lt;/code&gt;&lt;p&gt;这个类型定义非常类似前面的&lt;code class=&quot;inline&quot;&gt;OLens&lt;/code&gt;，同时这里的f具有任意性，又可以满足&lt;code class=&quot;inline&quot;&gt;VLens&lt;/code&gt;的需求。而实际上，如果这里的&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;是 Identity Functor 的话，这个类型所表达的与&lt;code class=&quot;inline&quot;&gt;OLens&lt;/code&gt;毫无区别。我们只需要对原有&lt;code class=&quot;inline&quot;&gt;over&lt;/code&gt;进行一层 Identity Functor 的包装就保证了其语义不变：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;over lens f = runIdentity . lens (Identity . f)&lt;/code&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;VLens&lt;/code&gt;类型&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponOLens ::  (a -&amp;gt; a) -&amp;gt; (b -&amp;gt; b)
weaponOLens f h = (`setWeapon` h) $ f (weapon h)&lt;/code&gt;&lt;p&gt;我们也仅需要对调用的修改本层次域的函数进行升格，上下结构保持了极好的相似性。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;weaponLens ::  Functor f =&amp;gt; (a -&amp;gt; f a) -&amp;gt; (b -&amp;gt; f b)
weaponLens f h = (`setWeapon` h) &amp;lt;$&amp;gt; f (weapon h)&lt;/code&gt;&lt;p&gt;那么我们剩余的问题就在于如何利用 Functor 提供的多态能力来实现&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;的语义了。&lt;/p&gt;&lt;p&gt;我们观察一下先前的&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;实现&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;type VLens b a = forall c. (a -&amp;gt; c) -&amp;gt; (b -&amp;gt; c)
viewV vlens b = vlens id b&lt;/code&gt;&lt;p&gt;我们发现&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;的实现有如下特点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;对象的内容完全没有被改变&lt;/li&gt;&lt;li&gt;每一层的作用是返回内层的内容&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们只要找到一个Functor符合上面的特点就可以实现&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;，而 Const Functor 恰好符合我们的需求。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Const a b = Const {getConst :: a}
instance Functor (Const a) where
  fmap f c = c&lt;/code&gt;&lt;p&gt;Const Functor 的&lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;并不改变值，实际上，其中根本没有值。一个 Const Functor 在创建之后，经历过多次&lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;可能其类型发生变化，但getConst所取出的内容永远不会变化。&lt;/p&gt;&lt;p&gt;考虑下面的&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;定义，最内层的值被应用到&lt;code class=&quot;inline&quot;&gt;Const&lt;/code&gt;构建函数上。之后经历过若干次&lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;，最后&lt;code class=&quot;inline&quot;&gt;getConst&lt;/code&gt;取得的仍是原来的值，于是便实现了&lt;code class=&quot;inline&quot;&gt;view&lt;/code&gt;的行为。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;view :: Lens b a -&amp;gt; b -&amp;gt; a
view lens b = getConst $ lens Const b&lt;/code&gt;&lt;p&gt;到这里为止，我们便实现了文章开头所演示的 Lens 的功能。&lt;/p&gt;&lt;p&gt;附上在Zju Lambda报告的Slides：&lt;a href=&quot;https://github.com/zju-lambda/slides/blob/master/The%20Overview%20of%20Lens.pdf&quot;&gt;The Overview of Lens&lt;/a&gt;&lt;/p&gt;</description>
<author>孙浩然</author>
<guid isPermaLink="false">2017-10-29-30544410</guid>
<pubDate>Sun, 29 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Dafny与程序验证</title>
<link>https://henix.github.io/feeds/zhuanlan.zju-lambda/2017-10-21-30321583.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30321583&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8f49af88768b20c6808b564c74a43abe_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;B大以前写过一个&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25568785&quot;&gt;怎样写出没有 bug 的程序：程序证明的简单例子&lt;/a&gt; ，是用Idris写的，我也来写一个，不过方法不太一样。&lt;/p&gt;&lt;p&gt;Dafny是MSR开发的程序设计语言，它混合了OOP和FP编程范式，并且自带程序验证功能，可以通过霍尔逻辑证明程序正确性。&lt;/p&gt;&lt;p&gt;它的语法非常简单，看起来就像C++，Scala和Haskell的混合。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;变量(scala风格，只是没有val)&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;scala&quot;&gt;var x:Tree;
var y:nat := 0;&lt;/code&gt;&lt;ul&gt;&lt;li&gt;ADT(Haskell风格)&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;scala&quot;&gt;datatype Tree = Empty | Node(left:Tree,value:real,right:Tree)
datatype List&amp;lt;T&amp;gt; = Nil | Cons(head: T, tail: List&amp;lt;T&amp;gt;)
Cons(5,Nil).Cons? &amp;amp;&amp;amp; Cons(5, Nil).head == 5&lt;/code&gt;&lt;ul&gt;&lt;li&gt;Methed/Lemma(命令式风格的函数)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;expr表示表达式，col表示集合&lt;/p&gt;&lt;p&gt;modifies用来标记函数的副作用，requires是前置命题，ensures是后置命题，decreses用来证明递归函数可终止。&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;method/lemma Abs(x: int) returns (y: int)
    modifies &amp;lt;col&amp;gt;
    requires &amp;lt;expr&amp;gt;
    ensures &amp;lt;expr&amp;gt;
    decreases &amp;lt;expr&amp;gt;
{
    if x &amp;lt; 0 { return -x;}
    else {return x;}
}&lt;/code&gt;&lt;ul&gt;&lt;li&gt;Function/Predicate(函数式风格的函数)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;reads用来标记函数捕获的外部变量&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;function abs(x: int):int
    requires &amp;lt;expr&amp;gt;
    ensures &amp;lt;expr&amp;gt;
    reads &amp;lt;col&amp;gt;
    decreases &amp;lt;expr&amp;gt;
{
    if x &amp;lt; 0 then -x else x
}&lt;/code&gt;&lt;ul&gt;&lt;li&gt;Assert用来下断言，只不过这个断言不是运行期的，而是编译期的，支持forall和exist量词以及基本的逻辑运算符。把Assert改为Assume，可以用来假定某些命题成立。&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;scala&quot;&gt;assert forall x :: P(x) ==&amp;gt; Q(x)
assert forall(i | 0 &amp;lt;= i&amp;lt; n - m) { b[i] := a[m + i];}&lt;/code&gt;&lt;ul&gt;&lt;li&gt;模式匹配(Scala风格，match的位置略有差异)&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;scala&quot;&gt;match t
	case Empty =&amp;gt; …
	case Node(l:Empty,v,r) =&amp;gt; …&lt;/code&gt;&lt;ul&gt;&lt;li&gt;循环&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可用invariant标记循环不变量&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;var i:=0
while i&amp;lt;n
	invariant i&amp;lt;=n
	decreases n-i
{}&lt;/code&gt;&lt;ul&gt;&lt;li&gt;支持C++类的写法，支持Lambda表达式，支持Trait，支持yield惰性流，有复杂的模块系统，支持泛型类和高阶类型（都是用&amp;lt;&amp;gt;表达）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以上就是Dafny常用的语法，还有一些不常用的语法可以参考&lt;a href=&quot;https://github.com/Microsoft/dafny/blob/master/Docs/DafnyRef/out/DafnyRef.pdf&quot;&gt;DafnyRef&lt;/a&gt;&lt;/p&gt;&lt;p&gt;一起来看一个稍微复杂一点的例子吧！写一个二叉搜索树的插入函数&lt;/p&gt;&lt;p&gt;定义二叉树&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;datatype Tree = Empty | Node(left:Tree,value:real,right:Tree)&lt;/code&gt;&lt;p&gt;在类里定义变量&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;class BST
{
    var tree:Tree;&lt;/code&gt;&lt;p&gt;定义in_tree和is_ordered函数，分别表示某个元素在树内和树符合二叉搜索树的条件&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;predicate method is_intree(t:Tree,x:real)
{
    match t
        case Empty =&amp;gt; false
        case Node(l,v,r) =&amp;gt; x==v || is_intree(l,x) || is_intree(r,x)
}
predicate is_ordered(t:Tree)
{
    match t
        case Empty =&amp;gt; true
        case Node(l,v,r) =&amp;gt; is_ordered(l) &amp;amp;&amp;amp; is_ordered(r) &amp;amp;&amp;amp;
            (forall x::is_intree(l,x) ==&amp;gt; x&amp;lt;v) &amp;amp;&amp;amp;
            (forall y::is_intree(r,y) ==&amp;gt; y&amp;gt;=v)
}&lt;/code&gt;&lt;p&gt;定义函数insert_into_left和insert_into_right&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;protected function method insert_into_left(t:Tree,x:real):Tree
    requires t!=Empty
    requires is_ordered(t)
    ensures is_ordered(insert_into_left(t,x))
{
    match t.left
        case Empty =&amp;gt; Node(Empty,x,Empty)
        case Node(l,v,r) =&amp;gt;
            if x&amp;gt;=v then
                insert_into_right(t.left,x)
            else
                insert_into_left(t.left,x)
}

protected function method insert_into_right(t:Tree,x:real):Tree
    requires t!=Empty
    requires is_ordered(t)
    ensures is_ordered(insert_into_right(t,x))
{
    match t.right
        case Empty =&amp;gt; Node(Empty,x,Empty)
        case Node(l,v,r) =&amp;gt;
            if x&amp;gt;=v then
                insert_into_right(t.right,x)
            else
                insert_into_left(t.right,x)
}
&lt;/code&gt;&lt;p&gt;以上全是pure function，最后，我们回到oop的世界，定义dirty的类成员函数&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;method insert(x:real)
    requires is_ordered(tree)
    modifies this
    ensures is_ordered(tree)
{
    match tree
        case Empty =&amp;gt; {tree:=Node(Empty,x,Empty);}
        case Node(l,v,r) =&amp;gt; 
        {
            if x&amp;gt;=v
            {
                tree:=insert_into_right(tree,x);
            }
            else
            {
                tree:=insert_into_left(tree,x);
            }
        }
}&lt;/code&gt;&lt;p&gt;编译的时候，编译器会帮你验证你写的那些requires,ensures,assert是否满足，如果不满足，它会告诉你哪些命题无法证明。经过验证之后，你可以选择将Dafny代码编译为C#或编译成dll被其他.Net程序调用。&lt;/p&gt;&lt;p&gt;以上只是一个简单介绍，具体代码在&lt;a href=&quot;https://github.com/NiceKingWei/algorithm/blob/master/dafny/bst.dfy&quot;&gt;bst.dfy&lt;/a&gt;&lt;/p&gt;&lt;p&gt;我的slides &lt;a href=&quot;https://github.com/zju-lambda/slides/blob/master/Verification%20in%20Dafny.pdf&quot;&gt;Verification in Dafny&lt;/a&gt;&lt;/p&gt;&lt;p&gt;关于Dafny的更多精彩内容， 可以关注Dafny的项目主页，里面有一些学习资源 &lt;a href=&quot;https://www.microsoft.com/en-us/research/project/dafny-a-language-and-program-verifier-for-functional-correctness/?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fprojects%2Fdafny%2Freference.aspx&quot;&gt;MSR:Dafny&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>魏王雅望非常</author>
<guid isPermaLink="false">2017-10-21-30321583</guid>
<pubDate>Sat, 21 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>ZJU Lambda2017秋纳笔试</title>
<link>https://henix.github.io/feeds/zhuanlan.zju-lambda/2017-10-08-29943113.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29943113&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先简单介绍一下，ZJU Lambda是我这学期在浙大Google Camp社团办的一个讨论组，目的是聚集起浙大喜欢玩函数式的同学一起学习函数式相关知识。为了纳新，我出了下面这套笔试题，难度我认为差不多就是《趣学指南》前8章的难度，尚未涉及Monad。考出来效果非常好，好几个80+，90+，还有100的。出题人日常被吊打(1/1)。&lt;/p&gt;&lt;p&gt;本人才疏学浅，如果题目出现纰漏，还请各位知友多多指教。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ad3f662181a4d5d4d9eb0ecad1a7c2db_r.jpg&quot; data-rawwidth=&quot;250&quot;&gt;&lt;p&gt;&lt;b&gt;第一部分&lt;br&gt;函数式编程基础（共50分）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1. 以下属于函数式编程理念的是（5分)&lt;/p&gt;&lt;p&gt;A. 过早的优化是万恶之源&lt;/p&gt;&lt;p&gt;B. PHP是最好的语言&lt;/p&gt;&lt;p&gt;C. 代码即数据，函数是一等公民&lt;/p&gt;&lt;p&gt;D. 变量的类型可以在运行时变化&lt;/p&gt;&lt;p&gt;2. 代数数据类型(algebraic data type)是函数式编程中非常重要的概念，请定义Int列表： &lt;/p&gt;&lt;p&gt;data IntList =______。（5分）&lt;/p&gt;&lt;p&gt;3. 若将代数数据类型(algebraic data type)与自然数建立映射，定义一个类型对应的自然数即为其可能的取值个数（以下称作大小）。例如data Bool = True | False，Bool有两个可能的取值True和False，那么Bool的大小就为2；data T = E | S Bool Bool，T的取值有E;S True True;S True False;S False True;S False False一共5种，所以T的大小为5。以下说法错误的是（10分）&lt;/p&gt;&lt;p&gt;A. data C=ConsA A | ConsB B，则C的大小为A的大小和B的大小相加&lt;/p&gt;&lt;p&gt;B. data C=Cons A B，则C的大小为A的大小和B的大小相乘&lt;/p&gt;&lt;p&gt;C. data C=Cons (A-&amp;gt;B)，则C的大小为A的大小和B的大小相乘&lt;/p&gt;&lt;p&gt;D. 存在加法单位元Void和乘法单位元()（在自然数运算中，0为加法单位元，1为乘法单位元）&lt;/p&gt;&lt;p&gt;4. 若两个代数数据类型具有相同的“大小”，那么这两个代数数据类型之间一定存在一一对应关系，我们称这样的两个类型同构(Isomorphism)。以下关于同构的说法错误的是（10分）&lt;/p&gt;&lt;p&gt;A. data Bool = True | False ，data Gender = Boy | Girl，Bool和Gender同构&lt;/p&gt;&lt;p&gt;B. data A = P | Q | R，data B = P | Q，A和B不同构，[A]和[B]也不同构([a]为a的列表)&lt;/p&gt;&lt;p&gt;C. 同构具有自反性（A与A同构），对称性(若A与B同构，则B与A同构)与传递性(若A与B同构，B与C同构，则A与C同构)&lt;/p&gt;&lt;p&gt;D. ((A,B),C)与(A,B,C)同构&lt;/p&gt;&lt;p&gt;5. λ 演算是最小的通用程序设计语言。&lt;/p&gt;&lt;p&gt;(1) 用符号λ来定义函数。例如：λx.x+1定义了一个以x为变量的函数，它的返回值是x+1&lt;/p&gt;&lt;p&gt;λx. λy.x+y定义了一个以x为自变量的函数，返回值是一个函数，那个函数的功能是+x&lt;/p&gt;&lt;p&gt;(2) 两项并置表示函数应用，例如 (λx.x+1) y表示把函数(λx.x+1)应用到y上&lt;/p&gt;&lt;p&gt;(3) λ演算的两条规则：&lt;/p&gt;&lt;p&gt;alpha转换：变换λ表达式中的变量名称不改变函数本身。例: λx.x+1与λy.y+1等价&lt;/p&gt;&lt;p&gt;beta规约：函数应用时，用实际的参数替换λ符号后定义的参数。例：(λx.x+3/x) y经过beta规约后即为y+3/y&lt;/p&gt;&lt;p&gt;计算出下面的Lambda表达式的值，或指出其为无限循环（2+2+3+3=10分）&lt;/p&gt;&lt;p&gt;A. (λx.x+1) 5 =&lt;/p&gt;&lt;p&gt;B. (λf.λx.f (x+1)) (λy.2*y) 3 = &lt;/p&gt;&lt;p&gt;C. (λf.λx.f (f x)) (λy.y+2) 1 =&lt;/p&gt;&lt;p&gt;D.  λf.(λx.f (x x)) (λx.f (x x)) g =&lt;/p&gt;&lt;p&gt;6. 在程序证明领域有一句话叫“类型即命题，程序即证明”，例如，某个函数的类型签名为a-&amp;gt;a，那么它对应的命题为若a为真，则a为真。如果你能写出一个类型签名为a-&amp;gt;a的函数，那么你写的程序就是这个命题的证明。下面关于程序证明的描述，错误的是（10分）&lt;/p&gt;&lt;p&gt;A. 你可以写出一个a-&amp;gt;a类型的通用函数，这表明，若a为真，则a为真&lt;/p&gt;&lt;p&gt;B. 你可以写出一个Two a b-&amp;gt;b类型的通用函数，这表明，若a且b为真，则b为真（Two的定义见2题）&lt;/p&gt;&lt;p&gt;C. 你不能写出一个Either a b-&amp;gt;a类型的通用函数，这表明，若a或b为真，则a不一定为真&lt;/p&gt;&lt;p&gt;D. 你不能写出一个a-&amp;gt;b-&amp;gt;Two a b类型的通用函数，因为这个函数的类型签名没有对应的逻辑命题&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;第二部分 Haskell语言基础（共50分）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1. 下面关于Haskell语言的说法，错误的是（5分）&lt;/p&gt;&lt;p&gt;A. 函数可以作为参数传递&lt;/p&gt;&lt;p&gt;B. []列表类型可以做到常数时间随机访问&lt;/p&gt;&lt;p&gt;C. 没有for和while语句，实现循环应该用递归&lt;/p&gt;&lt;p&gt;D. 默认惰性求值&lt;/p&gt;&lt;p&gt;2. 以下常用函数的类型注解错误的是（5分）&lt;/p&gt;&lt;p&gt;A. foldl :: (Foldable t)=&amp;gt;(a-&amp;gt;b-&amp;gt;b)-&amp;gt;b-&amp;gt;t a-&amp;gt;b&lt;/p&gt;&lt;p&gt;B. id :: a-&amp;gt;a&lt;/p&gt;&lt;p&gt;C. head :: [a]-&amp;gt;a&lt;/p&gt;&lt;p&gt;D. map ::&lt;br&gt;(a-&amp;gt;b)-&amp;gt;[a]-&amp;gt;[b]&lt;/p&gt;&lt;p&gt;3. 表达式 map (+1) [1..10]的结果是____。 （5分）&lt;/p&gt;&lt;p&gt;4. 表达式 ((+1).(*2)) 3的结果是______。（5分）&lt;/p&gt;&lt;p&gt;5. 表达式foldl (\xl _-&amp;gt;[x:xs|x&amp;lt;-[1..n],xs&amp;lt;-xl,x `notElem` xs]) [[]] [1..n] where n=3的结果是___。（5分）&lt;/p&gt;&lt;p&gt;6. 请给出mapWithIndex :: (Int-&amp;gt;a-&amp;gt;b)-&amp;gt;[a]-&amp;gt;[b]的一个实现___________。(5分)&lt;/p&gt;&lt;p&gt;7. 写出所有正偶数的列表t :: [Int] 的定义_____。（10分）&lt;/p&gt;&lt;p&gt;8. Maybe类型常用来表达一个可能存在的数据，它的定义如下&lt;/p&gt;&lt;p&gt;data Maybe a = Nothing | Just a&lt;/p&gt;&lt;p&gt;请完成函数除法函数maybeDiv :: Maybe Int -&amp;gt; Maybe Int -&amp;gt; Maybe&lt;br&gt;Int（5分）&lt;/p&gt;&lt;p&gt;9. 请列出三个与Haskell相关的名词（书、网站、工具链、Haskell的开源项目等）______________________________。（5分）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;第三部分&lt;br&gt;附加题&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1. 用结构归纳法证明（写书面证明，不是写代码），二叉树最多有2^(h-1)-1个节点，h为二叉树高度，定义为从根到所有叶子的路径长度的最大值。二叉树的定义为 data Tree = Nil | Node Tree Tree&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;2. 你之前学过哪些编程语言，你认为用它们解决问题的思路是什么？你认为用Haskell语言来解决问题与其他语言有哪些异同？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;3. 写一段你认为最能体现函数式编程思想的代码，语言不限（函数式与非函数式的语言都可以）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;参考答案&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;第一部分&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1.C&lt;/p&gt;&lt;p&gt;2.Nil | Cons Int IntList&lt;/p&gt;&lt;p&gt;3.C&lt;/p&gt;&lt;p&gt;4.B&lt;/p&gt;&lt;p&gt;5.(1)6 (2)8 (3)5 (4)无限循环&lt;/p&gt;&lt;p&gt;6.D&lt;/p&gt;&lt;p&gt;&lt;b&gt;第二部分&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1.B&lt;/p&gt;&lt;p&gt;2.A&lt;/p&gt;&lt;p&gt;3.[2..11]&lt;/p&gt;&lt;p&gt;4.7&lt;/p&gt;&lt;p&gt;5.[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]&lt;/p&gt;&lt;p&gt;6.mapWithIndex f xs = zipWith f [0..] xs （其它合理实现均可，下同）&lt;/p&gt;&lt;p&gt;7.[2,4...]&lt;/p&gt;&lt;p&gt;8.import Control.Applicative&lt;/p&gt;&lt;p&gt;maybeDiv::Maybe Int -&amp;gt; Maybe Int -&amp;gt; Maybe Int&lt;/p&gt;&lt;p&gt;maybeDiv x y &lt;/p&gt;&lt;p&gt;        | y==Just 0 = Nothing&lt;/p&gt;&lt;p&gt;        | otherwise = (liftA2 div) x y&lt;/p&gt;&lt;p&gt;9.随便写啦&lt;/p&gt;&lt;p&gt;&lt;b&gt;第三部分是面试题，就没有标准答案啦，欢迎各位在评论区畅谈自己的见解。&lt;/b&gt;&lt;/p&gt;</description>
<author>魏王雅望非常</author>
<guid isPermaLink="false">2017-10-08-29943113</guid>
<pubDate>Sun, 08 Oct 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
