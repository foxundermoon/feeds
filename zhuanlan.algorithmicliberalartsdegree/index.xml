<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>算法少女</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/</link>
<description>一些看起来好像很酷的算法结论. 来自于UIUC理论CS PhD学生.</description>
<language>zh-cn</language>
<lastBuildDate>Thu, 29 Mar 2018 19:39:02 +0800</lastBuildDate>
<item>
<title>Search in Rotated Sorted Array的升级</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2018-03-27-34997223.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34997223&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为看到了这个文章 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/34974336&quot;&gt;微软面试题解析 | Search in Rotated Sorted Array&lt;/a&gt; .&lt;/p&gt;&lt;p&gt;让我想到了前段时间才有人和我说一个30年经验应聘高盛的人做不出这道题. &lt;/p&gt;&lt;p&gt;很多人都刷过这个题, 所以如果我面试我会问一个更难的题.  如果array里面同一个数字可以出现多次呢?  可以想象, 这个array里除了一个数字是1其他都是0. 那么就不能期望一个最坏情况下检测这个array n次才能找到这个1的算法. 假如任意数字在array里最多出现m次. 我想要一个 &lt;equation&gt;O(m+\log n)&lt;/equation&gt; 的算法. (而且事先并不知道m是什么)&lt;/p&gt;&lt;p&gt;最简单的方法是用 &lt;equation&gt;O(m+\log n)&lt;/equation&gt;找到最小值, 然后就知道rotation了, 然后利用binary search.&lt;/p&gt;&lt;p&gt;如何找到这个rotated sorted array的最小值? 这让我想到我五年前写的一个博客. &lt;/p&gt;&lt;a href=&quot;http://chaoxuprime.com/posts/2013-08-18-find-the-minimum-of-a-bitonic-sequence.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Find the minimum of a bitonic sequence&lt;/a&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2018-03-27-34997223</guid>
<pubDate>Tue, 27 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>图书馆大妈二分稍微升级</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2018-03-25-34912227.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34912227&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-85d93ca55f7203ec6369c16bbedfb07d_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;以前看过一个图书馆大妈用二分法的老段子. 人人时代就看到过的东西. 以下来自于&lt;a href=&quot;https://twitter.com/xueshudi/status/911375561498357761&quot;&gt;学术状态帝twitter&lt;/a&gt;. &lt;/p&gt;&lt;blockquote&gt;图书馆自习的时候,一女生背着一堆书进阅览室,结果警报响了,大妈让女生看是哪本书把警报弄响了，女生把书倒出来，一本一本的测。大妈见状急了，把书分成两份,第一份过了一下,响了。又把这一份分成两份接着测，三回就找到了，大妈用鄙视的眼神看着女生，仿佛在说 &lt;equation&gt;O(n)&lt;/equation&gt; 和 &lt;equation&gt;O(\log n)&lt;/equation&gt; 都分不清&lt;/blockquote&gt;&lt;p&gt;知乎上看到一些类似的回答. 很多人会提到这个方法有用因为只有一本书. 如果女生有 &lt;equation&gt;k&lt;/equation&gt; 本书可以让警报响呢? (而且还有人问为什么不是离开图书馆的时候才要检测, 这样可以偷出去几本书.)&lt;/p&gt;&lt;p&gt;问题可以抽象成给一个n个元素的集合. 有一个子集H. 可以每次检测一个子集是否包含H中至少一个元素. 用比较少的检测次数找到H. 我们让子集H的大小为k. 因为每次检测我们可以获得1个bit的结果. 因为有 &lt;equation&gt;n\choose k&lt;/equation&gt; 个不同的可能, 所以我们需要 &lt;equation&gt;\log_2 {n\choose k}&lt;/equation&gt; 次检测. &lt;/p&gt;&lt;p&gt;这里的log定义为 &lt;equation&gt;\max(\log n,1)&lt;/equation&gt; . &lt;/p&gt;&lt;p&gt;我们可以给出一个 &lt;equation&gt;O(k \log (n/k))&lt;/equation&gt; 次检测的算法. 因为前面的下限, 所以这个已经是能达到的最好结果了. &lt;/p&gt;&lt;p&gt;&lt;b&gt;新算法:&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;检测整个集合和H是否相交. 有的话二分, 两边都递归. 没有的话停止.&lt;/blockquote&gt;&lt;p&gt;为了简单起见我们考虑 &lt;equation&gt;n&lt;/equation&gt; 是 &lt;equation&gt;2^d&lt;/equation&gt; 的形式.&lt;/p&gt;&lt;p&gt;我们可以在元素上建立一个complete binary tree. 我们mark一个node, 如果我们检测了这个node的subtree的所有leaf组成的集合. 我们要做的是考虑如果有k个leaf, 那么有多少个node被mark. 这个tree的root为 &lt;equation&gt;r&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;对于给定的k个leaf  &lt;equation&gt;L&lt;/equation&gt; , 我们叫一个node为good, 如果对于某一个 &lt;equation&gt;v\in L&lt;/equation&gt; , 这个node在 &lt;equation&gt;rv&lt;/equation&gt;  path上. 被mark的node的个数最多为2倍good node的个数. &lt;/p&gt;&lt;p&gt;那么, 最多有多少个good node? &lt;/p&gt;&lt;p&gt;考虑第i层有多少个good node. 第i层也最多有 &lt;equation&gt;2^{i-1}&lt;/equation&gt; 个元素. 而且good node每一层也不能超过k个. 所以我们得知第i层可以有 &lt;equation&gt;\min(k, 2^{i-1})&lt;/equation&gt; good nodes. 则我们得到good nodes的数量为 &lt;equation&gt;\sum_{i=1}^{1+\log n} \min(k,2^{i-1}) = O(k(\log n - \log k)+k) = O(k\log (n/k))&lt;/equation&gt; .&lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2018-03-25-34912227</guid>
<pubDate>Sun, 25 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>min-cost flow和min-cost (非二分) perfect matching的关系</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2018-02-25-34005918.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34005918&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很多课堂上都会提起来min-cost flow能用来解min-cost perfect &lt;b&gt;bipartite&lt;/b&gt; matching的问题. Flow和bipartite matching的确关系很近. 那么flow和general的matching有什么关系么?&lt;/p&gt;&lt;p&gt;min-cost flow可以被reduce到一个非常强悍的min-cost &lt;b&gt;general&lt;/b&gt; perfect matching. &lt;/p&gt;&lt;p&gt;我最近在做一个问题的时候发现flow做不来, 但是用更高阶的工具可以搞定. &lt;/p&gt;&lt;h2&gt;1. Generalized min-cost flow&lt;/h2&gt;&lt;p&gt;min-cost flow可以写成这样的一个LP.&lt;/p&gt;&lt;p&gt;minimize  &lt;equation&gt;w^T x &lt;/equation&gt; &lt;/p&gt;&lt;p&gt;subject to &lt;equation&gt;Mx=0 &lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;0\leq x\leq c&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这里w是cost. x是每个边上的flow.  &lt;equation&gt;M&lt;/equation&gt; 是这个有向图(除了s和t)的关联矩阵.  &lt;equation&gt;Mx = 0&lt;/equation&gt; 表明flow conservation.&lt;/p&gt;&lt;p&gt;但实际上, 我们完全可以要一个更难一点的问题. 多加一点上界下界. 而且a,b,c,d,w都可以有负数!&lt;/p&gt;&lt;p&gt;minimize  &lt;equation&gt;w^T x &lt;/equation&gt; &lt;/p&gt;&lt;p&gt;subject to &lt;equation&gt;a≤Mx≤b&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;d≤x≤c&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这个问题可以多项式时间内解决. 因为M是totally unimodular的.&lt;/p&gt;&lt;h2&gt;2. Generalize min-cost perfect matching&lt;/h2&gt;&lt;p&gt;我们一般见到的匹配是这样的&lt;/p&gt;&lt;p&gt;minimize  &lt;equation&gt;w^T x &lt;/equation&gt; &lt;/p&gt;&lt;p&gt;subject to &lt;equation&gt;Mx=1&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;0≤x&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这里w是cost, x是边是否被匹配, M是无向图的关联矩阵. &lt;equation&gt;Mx≤1&lt;/equation&gt; 表明每个顶点碰到最多1个边.&lt;/p&gt;&lt;p&gt;但是我们完全可以问个更难的问题. 而且这里a,b,c,d,w都可以是负的!&lt;/p&gt;&lt;p&gt;minimize  &lt;equation&gt;w^T x &lt;/equation&gt; &lt;/p&gt;&lt;p&gt;subject to &lt;equation&gt;a≤Mx≤b&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;d≤x≤c &lt;/equation&gt; &lt;/p&gt;&lt;p&gt;无向图的关联矩阵&lt;b&gt;不是&lt;/b&gt;totally unimodular的. 但是有类似matching polytope的description. 这个问题存在strongly polynomial time algorithm. 问题也可以被规约到正常的min-cost perfect matching的. &lt;/p&gt;&lt;h2&gt;3. Bidirected min-cost flow&lt;/h2&gt;&lt;p&gt;有没有发现上面两个问题一模一样, 除了矩阵换了? 能不能定义一个又有有向边,又有无向边,又有好的关联矩阵的图呢? 这个东西叫做 &lt;a href=&quot;http://rrurl.cn/0llspP&quot;&gt;bidirected graph&lt;/a&gt;. 我们定义下面的优化问题&lt;/p&gt;&lt;p&gt;minimize   &lt;equation&gt;w^T x&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;subject to &lt;equation&gt;a≤Mx≤b&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;d≤x≤c &lt;/equation&gt; &lt;/p&gt;&lt;p&gt;没错, 和前面一模一样, 唯一的区别是 &lt;equation&gt;M&lt;/equation&gt; 是一个bidirected graph的关联矩阵. 我们找的解是一个bidirected flow. 这个问题可以规约到generalized min-cost perfect matching. 所以也就能规约到一般的min-cost perfect matching.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;证明可以看combinatorial optimization: polyhedra and efficiency的chapter 35和36. &lt;/p&gt;&lt;p&gt;如果c=1. 则存在 &lt;equation&gt;O(n^2m)&lt;/equation&gt; 的算法. 也有 &lt;equation&gt;O(m^2\log n)&lt;/equation&gt; 的算法.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;4. 应用&lt;/h2&gt;&lt;p&gt;最近我在做一些设施里的物流问题. 纯粹是有兴趣, 和自己本身领域无关. 我现在很喜欢找其他领域里的问题做, 所以开了一个&lt;a href=&quot;http://algorange.com/&quot;&gt;算法咨询公司&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中有这样一个子问题:&lt;/p&gt;&lt;p&gt;给一个无向图, 上面有普通顶点和特殊顶点 &lt;equation&gt;s_1&lt;/equation&gt; , &lt;equation&gt;t_1&lt;/equation&gt; ,..., &lt;equation&gt;s_k&lt;/equation&gt; , &lt;equation&gt;t_k&lt;/equation&gt; . 要找到一个子图, 使得每个普通顶点的degree是1, 且对于每一个i, &lt;equation&gt;\deg(s_i)=\deg(t_i)&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;怎么做的呢? &lt;/p&gt;&lt;p&gt;一般OR的人可能写出个integer program放到solver里, 跑不出来就去跑一个metaheuristic.&lt;/p&gt;&lt;p&gt;但如果有上面的工具.&lt;/p&gt;&lt;p&gt;把原先的问题写成普通的那个matching的LP的形式. 然后我们给 &lt;equation&gt;s_i&lt;/equation&gt; 和 &lt;equation&gt;t_i&lt;/equation&gt; 之间加一个边, 但是这个边的取值必须是负数. 然后要求新的图里 &lt;equation&gt;\deg(s_i)=0&lt;/equation&gt; 和 &lt;equation&gt;\deg(t_i)=0&lt;/equation&gt; . 这个就是generalized min-cost perfect matching. 一个(比较大的)多项式时间解!&lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2018-02-25-34005918</guid>
<pubDate>Sun, 25 Feb 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>震惊！有向图中的k割之王！背后的秘密居然是这样的！</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2018-01-12-32863460.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32863460&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c6d5b6998a4787b66f0f5296bb0dc304_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;让 &lt;equation&gt;G=(V,E)&lt;/equation&gt; 为一个无向图, 一个集合 &lt;equation&gt;F\subseteq E&lt;/equation&gt; 叫做k-cut(k割), 如果删除这个边的集合, 则新的图里至少有k个连通分量. 2-cut就是图上的割. 割在各种优化问题中都会出现, 比如计算视觉里的图像分割.&lt;/p&gt;&lt;p&gt;我们的目的是找到minimum k-cut. 就是边数最小的k-cut. (或者最小权值的k-cut, 一样的方法), 而边数最小的k割我们称之为&lt;b&gt;k割之王&lt;/b&gt;. &lt;/p&gt;&lt;p&gt;难以置信的是, 无向图上的minimum k-cut竟然是可以在多项式时间内解决的! 有兴趣知道已知算法的话可以看&lt;a href=&quot;http://chaoxu3.web.engr.illinois.edu/paper/hypergraph_k_cut.pdf&quot;&gt;最近的一篇文章里的introduction&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当然, k-cut还有其他的不同的但是在无向图上等价的定义. 比如, 一个边的集合F叫做k-cut, 如果&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;equation&gt;G-F&lt;/equation&gt; 里存在 &lt;equation&gt;k&lt;/equation&gt; 个顶点T, 使得对于任意 &lt;equation&gt;v\in T&lt;/equation&gt; ,  &lt;equation&gt;v&lt;/equation&gt; 最多能达到&lt;equation&gt;T&lt;/equation&gt;中的一个顶点.&lt;/li&gt;&lt;li&gt;&lt;equation&gt;G-F&lt;/equation&gt; 里存在 &lt;equation&gt;k&lt;/equation&gt; 个顶点T, 使得对于任意 &lt;equation&gt;v\in V&lt;/equation&gt; ,  &lt;equation&gt;v&lt;/equation&gt; 最多能达到&lt;equation&gt;T&lt;/equation&gt;中的一个顶点.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这两个定义里的区别只有一个字符,  &lt;equation&gt;T&lt;/equation&gt; 被换成了 &lt;equation&gt;V&lt;/equation&gt; . 这两个定义在无向图里是一模一样的. 但是在&lt;b&gt;有向图&lt;/b&gt;中就不同了. &lt;/p&gt;&lt;p&gt;我们发现如果使用第一个定义的话, 在有向图里, 我们仍未知道2-cut是否是可以多项式时间内解决. 谁能做出来将获得我贡献的$100美元.&lt;/p&gt;&lt;p&gt;但是如果用第二个定义, 却可以证明对于任意常数k, k-cut可以多项式时间内解决. &lt;/p&gt;&lt;p&gt;文章以下都用第二个定义.&lt;/p&gt;&lt;p&gt;正式的说明一下问题. &lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;有向图上的最小k割问题&lt;/b&gt;&lt;br&gt;&lt;b&gt;输入:&lt;/b&gt; 一个有向图 &lt;equation&gt;G=(V,E)&lt;/equation&gt;&lt;br&gt;&lt;b&gt;输出:&lt;/b&gt;  最小的&lt;equation&gt;F\subseteq E&lt;/equation&gt; , 使得 &lt;equation&gt;G-F&lt;/equation&gt; 里存在 &lt;equation&gt;k&lt;/equation&gt; 个顶点 &lt;equation&gt;T&lt;/equation&gt; , 使得对于任意 &lt;equation&gt;v\in V&lt;/equation&gt; ,  &lt;equation&gt;v&lt;/equation&gt; 最多能达到&lt;equation&gt;T&lt;/equation&gt;中的一个顶点. &lt;/blockquote&gt;&lt;p&gt;这个看起来实际上是非常像NP-hard的问题, 但神奇的是竟然可以多项式时间内解决. 注意这里k是常数, 如果k也属于输入则是NP-hard的.&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;定义:&lt;/b&gt; 对于一个有向图G, 一个顶点集合的 &lt;equation&gt;S&lt;/equation&gt; 的值是 &lt;equation&gt;f(S)&lt;/equation&gt; , 定义为有多少条边的头在 &lt;equation&gt;S&lt;/equation&gt; 里, 尾在 &lt;equation&gt;V\setminus S &lt;/equation&gt; 里.&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;定理1:&lt;/b&gt; &lt;equation&gt;G&lt;/equation&gt; 里存在 &lt;equation&gt;k&lt;/equation&gt; 个顶点 &lt;equation&gt;T&lt;/equation&gt; , 使得对于任意 &lt;equation&gt;v\in V&lt;/equation&gt; ,  &lt;equation&gt;v&lt;/equation&gt; 最多只能达到&lt;equation&gt;T&lt;/equation&gt;中的一个顶点. 有且仅有存在k个互不相交的 &lt;equation&gt;V&lt;/equation&gt; 的非空子集, &lt;equation&gt;V_1,...,V_k&lt;/equation&gt; , 使得对于任意 &lt;equation&gt;i&lt;/equation&gt; , &lt;equation&gt;V_i&lt;/equation&gt; 的值为0&lt;/blockquote&gt;&lt;p&gt;k个不相交的非空集合叫做k-subpartition. 这说明了只要我们能找到k个k-subpartition  &lt;equation&gt;V_1,...,V_k&lt;/equation&gt; , 使得 &lt;equation&gt;\sum_{i} f(V_i)&lt;/equation&gt; 最小即可. 那么我们现在要解决的问题就是找最优的k-subpartition, 也就是让里面的集合的值的和最小的k-subpartition.&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;定义:&lt;/b&gt; 一个集合S叫做实心的, 如果对于任意 &lt;equation&gt;\emptyset\subsetneq S&#39;\subsetneq S&lt;/equation&gt;, &lt;equation&gt;f(S) &amp;lt; f(S&#39;)&lt;/equation&gt; .&lt;/blockquote&gt;&lt;p&gt;很明显, 存在一个最优的k-subpartition, 使得里面的每一个集合都是实心的. 整个算法&lt;b&gt;背后&lt;/b&gt;最重要的&lt;b&gt;秘密&lt;/b&gt;是下面的这个定理. &lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;定理2:&lt;/b&gt; 存在一颗树 &lt;equation&gt;T&lt;/equation&gt; , 使得对于任意实心集合 &lt;equation&gt;U&lt;/equation&gt; ,  &lt;equation&gt;T[U]&lt;/equation&gt; 是一颗树. 并且给定有向图G, 这棵树可以多项式时间内找到. [1]&lt;/blockquote&gt;&lt;p&gt;因为存在一个全是实心的最优解. 我们可以假设这个最优解为 &lt;equation&gt;S_1,\ldots,S_k&lt;/equation&gt; . 则我们知道存在 &lt;equation&gt;T &lt;/equation&gt; 的k-1个边, 使得删掉之后得到k个连通分量 &lt;equation&gt;U_1,\ldots,U_k&lt;/equation&gt; . 并且 &lt;equation&gt;S_i\subseteq U_i&lt;/equation&gt; . 所以我们可以尝试所有的 &lt;equation&gt;k-1&lt;/equation&gt; 个边. 最后, 有了下面的定理, 就能在给了 &lt;equation&gt;U_i&lt;/equation&gt; 的情况下找到 &lt;equation&gt;S_i&lt;/equation&gt; .&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;定理3:&lt;/b&gt; 给定G和一个顶点子集U, 则可以在多项式时间找到一个包含在U里的最小值的实心集合.&lt;/blockquote&gt;&lt;p&gt;放在一起就多项式时间了.&lt;/p&gt;&lt;p&gt;定理1和3都很容易证明, 定理2比较难, 还是看paper比较好.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;P.S.&lt;/p&gt;&lt;p&gt;今年不少人觉得SODA的文章质量下降了不少啊.&lt;/p&gt;&lt;p&gt;我现在所知的信息感觉Mathematical Programming似乎是很容易发的journal啊.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;[1] &lt;a href=&quot;http://www.sciencedirect.com/science/article/pii/S0167637704001002&quot;&gt;An algorithm for source location in directed graphs&lt;/a&gt; &lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2018-01-12-32863460</guid>
<pubDate>Fri, 12 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>洁癖朋友吃寿司卷</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2017-10-11-30007391.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30007391&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ab8dd95e6824d6a17543fa68fff03242_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;这是很久远的问题了, 认识我的人应该都听过这题的样子. 但是这次在伯克利碰到两个CS本科生&lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/b81d09436441d8ecbcfc90e1003ed384&quot; data-hash=&quot;b81d09436441d8ecbcfc90e1003ed384&quot; data-hovercard=&quot;p$b$b81d09436441d8ecbcfc90e1003ed384&quot;&gt;@林习习&lt;/a&gt;和另一个人时, 给了他们这个题. 因为我常用的另一个题他们竟然听过了.&lt;/p&gt;&lt;p&gt;我喜欢这种题当做面试题. 因为这题可以看人解决问题的思路. &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现实模型&lt;/p&gt;&lt;p&gt;有两种寿司卷, a个红色寿司卷和b个蓝色寿司卷(a和b都可以被2整除). 填满在一个nxm的矩阵里. 所以nxm=a+b. &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e116e9c2b748b6372b78bebd187b3099_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;960&quot; data-rawheight=&quot;609&quot;&gt;&lt;p&gt;两个有洁癖的人分寿司卷. 因为寿司卷放的很紧. 用筷子夹的时候要么碰到上下两个寿司卷(如果存在的话), 要么会碰到左右两个寿司卷(如果存在的话). 而另一个人是不会吃这个人碰到的寿司卷的. &lt;/p&gt;&lt;p&gt;设计一个算法. 告诉这两个人如何轮流夹寿司卷. 使得每个人都吃到a/2个红色寿司卷b/2个蓝色寿司卷.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;某个解答的方法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们假设 &lt;equation&gt;n\leq m&lt;/equation&gt; . &lt;/p&gt;&lt;p&gt;让 &lt;equation&gt;r_i&lt;/equation&gt; 为第 &lt;equation&gt;i&lt;/equation&gt; 列的红色寿司的个数. 假设对于任意 &lt;equation&gt;i&lt;/equation&gt; , &lt;equation&gt;r_i\leq r_{i+1}&lt;/equation&gt;. 因为我们暂时不会横着夹任何东西, 所以可以有这样的assumption. &lt;/p&gt;&lt;p&gt;我们的目标是让两个人取走一样多的行.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;case 1: 存在 &lt;equation&gt;i\neq j&lt;/equation&gt; 使得 &lt;equation&gt;r_i=r_j&lt;/equation&gt; . 这样两个人各取一列. （这包含了n+1&amp;lt;m的case) 后面case假设case 1不成立.&lt;/p&gt;&lt;p&gt;case 2: 如果 &lt;equation&gt;n+1=m&lt;/equation&gt; , &lt;equation&gt;m\geq 4&lt;/equation&gt; . 则对于任意 &lt;equation&gt;i&lt;/equation&gt; ,  &lt;equation&gt;r_i = i-1&lt;/equation&gt; . 所以我们有 &lt;equation&gt;r_1 + r_m = r_2 + r_{m-1}&lt;/equation&gt; .&lt;/p&gt;&lt;p&gt;case 3: 如果 &lt;equation&gt;n=m&lt;/equation&gt; ,  &lt;equation&gt;m\geq 4&lt;/equation&gt; ,  &lt;equation&gt;r_1\neq 0&lt;/equation&gt; . 则对于任意 &lt;equation&gt;i&lt;/equation&gt; , &lt;equation&gt;r_i=i&lt;/equation&gt; .  &lt;equation&gt;r_1 + r_m = r_2 + r_{m-1}&lt;/equation&gt; . &lt;/p&gt;&lt;p&gt;case 4: 如果 &lt;equation&gt;n=m&lt;/equation&gt; ,  &lt;equation&gt;m\geq 4&lt;/equation&gt; ,  &lt;equation&gt;r_1=0&lt;/equation&gt; . 则矩阵里每行都有一个蓝色的寿司卷. 我们可以红色蓝色对调并且旋转一下矩阵获得case 3.&lt;/p&gt;&lt;p&gt;case 5. n和m之间必须有一个是偶数. 现在只剩下要考虑 &lt;equation&gt;(n,m)&lt;/equation&gt; 为下列三种情况 &lt;equation&gt;\{(1,2),(2,2),(2,3)\}&lt;/equation&gt; . 利用a,b都是偶数这个属性. 可以搞定最后的几个可能.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果足够careful可以利用这个写出一个O(nm)的算法... 有点麻烦就是了...&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;更多问题:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;如果矩阵没有被摆满呢?&lt;/li&gt;&lt;li&gt;如果第一个人想吃到k个红寿司卷, l个蓝寿司卷, 第二个人要吃a-k个红寿司卷, b-l个蓝寿司卷呢? 这时对a,b的偶数要求也没有了. &lt;/li&gt;&lt;li&gt;寿司卷摆在一个nxmxr的cube里, 有两个有洁癖的四维生物用二维的筷子呢?&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;题图是游戏 Asami&#39;s Sushi Shop. &lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2017-10-11-30007391</guid>
<pubDate>Wed, 11 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>亲属术语以及其算法</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2017-08-28-25012875.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25012875&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;美国人的亲属术语非常简单. Read就研究过它的代数结构[2]. 所有的人只有2个维度: 最近的祖先的辈分以及辈分区别. &lt;/p&gt;&lt;p&gt;只要这几个维度一样, 美国的(单个)亲属术语就无法区分他们(特别近的关系还会多一个性别). 比如&lt;b&gt;父亲的哥哥的女儿&lt;/b&gt;和&lt;b&gt;母亲的妹妹的儿子&lt;/b&gt;都是&lt;b&gt;first cousin&lt;/b&gt;. 他们各自的孩子都叫做&lt;b&gt;first cousin once removed&lt;/b&gt;.&lt;/p&gt;&lt;p&gt;在中文中, 这两个不同的关系的术语并不一样. 中文的亲属术语属于&lt;a href=&quot;https://en.wikipedia.org/wiki/Sudanese_kinship&quot;&gt;苏丹型系统&lt;/a&gt;, 也称之为描述型系统. 这个系统里面要考虑到更多的可能. 为此, Read也提出过用一个半群来描述所有&lt;i&gt;描述型系统可能区分的亲属关系.&lt;/i&gt; 叫这个&lt;b&gt;亲属半群&lt;/b&gt;. 注意这里有两个概念, 亲属术语和亲属关系. 亲属术语是用来描述亲属关系的. 可以想象亲属关系是一个抽象概念, 而亲属术语是一个字符串. &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;亲属半群有4个生成元, f,m,s,d. 各自代表父, 母, 儿, 女. &lt;/p&gt;&lt;p&gt;通过这四个元素可以获得所有的亲属关系. 当我们写下一个关系, 比如ffms的时候, 意思是&quot;父亲的父亲的母亲的儿子&quot;. 用这4个生成元的字符串做出的描述叫做&lt;b&gt;标准描述&lt;/b&gt;.&lt;/p&gt;&lt;p&gt;fs就是&quot;父亲的儿子&quot;, 也就是&quot;兄弟&quot;. 当然, ms也代表兄弟. 所以同一个亲属关系的标准描述并不唯一. &lt;/p&gt;&lt;p&gt;对于任意一个定义在f,m,s,d上的字符串, f和m的sign是+, s和d的sign是-. f和s的性别一样. m和d的性别一样. &lt;/p&gt;&lt;p&gt;我们在这里定义一些相同的关系. 对于任意 &lt;equation&gt;a,b,c \in \{f,m,s,d\}&lt;/equation&gt; &lt;/p&gt;&lt;ol&gt;&lt;li&gt;abc = c, 如果abc的sign是+-+或者-+-. 比如 fdf=f (父亲的女儿的父亲=父亲) &lt;/li&gt;&lt;li&gt;ac=bc, 如果ac和bc的sign都是+-或者都是-+. 比如fs=ms (父亲的儿子=母亲的儿子), sf=df(女儿的父亲=儿子的父亲)&lt;/li&gt;&lt;li&gt;abc=a如果abc的sign是--+, 然后a和c的性别相同. 比如 ddm = d (女儿的女儿的母亲=女儿)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所有标准描述, 如果代表相同的关系, 则都能通过使用上面的几个等式获得.  &lt;/p&gt;&lt;p&gt;这个模型有一些问题, 评论里也提到了. 文末有回应. 但是当亲属关系被抽象为亲属半群之后, 就成为了一个&lt;b&gt;纯粹的数学模型&lt;/b&gt;了. 我考虑的一切都是在这模型下的世界. &lt;b&gt;和真实的一个人的亲属一点关系都没有&lt;/b&gt;. (&lt;i&gt;做理论真爽, 都不用关心模型是否正确, 有好玩的题就好...&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;想象一个正在学中文的人去见家长. 他试图描述自己的某个非常成功的亲戚和自己的关系. 由于词汇量有限, 所以只能使用他懂的词汇. 但是他想要用最少的词汇来描述这段关系, 这样可以让对方家长刮目相看. &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;通过这么特定又明确但奇怪motivation, 可以很容易抽象出一个算法问题:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;亲属关系问题&lt;/b&gt; &lt;b&gt;输入&lt;/b&gt;: 给一个目标亲属关系x. 以及可以使用的术语集合S以及它们对应的亲属关系.&lt;br&gt;&lt;b&gt;输出&lt;/b&gt;: 用最少个数的术语描述x. (这称之为最短的描述)&lt;/blockquote&gt;&lt;p&gt;这里我们假设亲属关系的给定方法是标准描述. 也就是每一个亲属关系在输入的时候用半群的那4个生成元来表示.&lt;/p&gt;&lt;p&gt;例子&lt;/p&gt;&lt;p&gt;&lt;b&gt;输入&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;目标关系: ffffm
可用术语: {父亲 =f, 爷爷= ff, 奶奶 = fm, 母亲=m}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;爷爷的父亲的奶奶 &lt;/code&gt;&lt;p&gt;另2个可能, 但是只要能输出任意一个就好了&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;爷爷的爷爷的母亲
父亲的爷爷的奶奶&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;更加极端一点的例子&lt;/p&gt;&lt;p&gt;&lt;b&gt;输入&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;目标关系: ffs
可用术语: {骉=ffddf, 儿子=s, 犇=smm}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;骉的犇的儿子&lt;/code&gt;&lt;p&gt;怎么看出来一样的? (加粗标注了用了哪个相同rule来化简)&lt;/p&gt;&lt;blockquote&gt;ffd&lt;b&gt;dfs&lt;/b&gt;mms = ff&lt;b&gt;dsm&lt;/b&gt;ms = f&lt;b&gt;fdm&lt;/b&gt;s = f&lt;b&gt;ms&lt;/b&gt; =  ffs&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;小米的内置的计算器里就有这样亲属关系的计算器, 但是遇到稍微长一点的input就不行了, 没法找到最短的表示方式.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-41880e91da9e17a2eb9423698926f1a6_r.png&quot; data-rawwidth=&quot;609&quot; data-rawheight=&quot;495&quot;&gt;&lt;p&gt;而文章题图里的三姑六婆 app也是无法解决这个问题的. (&lt;a href=&quot;https://www.zhihu.com/question/28494810/answer/117692322&quot;&gt;三姑六婆的实现方式&lt;/a&gt;)&lt;/p&gt;&lt;p&gt;&lt;b&gt;问题: 是否有一个多项式时间的算法?&lt;/b&gt;&lt;/p&gt;&lt;p&gt;n是输入的总长度. &lt;a href=&quot;http://qianzhang.me/&quot;&gt;Qian Zhang&lt;/a&gt;和我对这个问题做了下研究. 已知 &lt;equation&gt;O(n^3)&lt;/equation&gt; 可以找到一个多项式长度的straight-line grammar, 使得的它能生成这个最短的术语来描述目标关系. 对算法有兴趣可以看文末的appendix.straight-line grammar是一个压缩了的表示方式, 真的把写出答案却可能很长. 而最终的算法复杂度为 &lt;equation&gt;O(n^3 + s)&lt;/equation&gt; , 而 &lt;equation&gt;s&lt;/equation&gt; 是输出的长度. 所以这个问题的算法部分完全完成了. 但是只有s是多项式大小的时候算法才是多项式时间的. 这样只剩下一个纯粹的数学问题了.  &lt;/p&gt;&lt;p&gt;&lt;b&gt;问题: 是否总有一个多项式长度的解?&lt;/b&gt;&lt;/p&gt;&lt;p&gt;抽象一点, 给一个半群S和一个子集B. 我们可以定义一个元素 &lt;equation&gt;x\in S&lt;/equation&gt; 的B长度.  &lt;equation&gt;\|x\|_B= \min \{ k | x_1\ldots x_k = x, x_i\in B\}&lt;/equation&gt; . 对于 &lt;equation&gt;X\subseteq S&lt;/equation&gt; , 它的B长度为所有元素B长度的和.  &lt;equation&gt;\|X\|_B = \sum_{x\in X} \|x\|_B&lt;/equation&gt; . &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;对于一个半群S和生成集合B, 我们可以问以下的问题&lt;/p&gt;&lt;blockquote&gt;找到一个函数g, 使得对于任意有限集合 &lt;equation&gt;T\subseteq S &lt;/equation&gt; 和一个可以被 &lt;equation&gt;T&lt;/equation&gt; 生成的元素 &lt;equation&gt;x&lt;/equation&gt; , 我们都有&lt;br&gt; &lt;equation&gt;\|x\|_{T} \leq g(\|T\|_B + \|x\|_B)&lt;/equation&gt; .&lt;/blockquote&gt;&lt;p&gt;我们想要证明的是&lt;b&gt;对于亲属半群和B={f,m,d,s}, 我们可以取一个多项式g. &lt;/b&gt;而对于很多半群, 甚至群, 这样的函数g根本不存在. 这也就是为什么很多群上的看起来应该很简单的算法问题实际上都是不可判定问题. &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;暂时看起来, 这个问题似乎非常难解决. 首先亲属关系半群看起来和2个生成元的自由群很像. 但是就是对两个生成元的自由群, 上述的问题我都不是很清楚. 如果我的理解是对的, 那么[1]里面的Theorem 5.14就代表对于任意自由群, 存在一个多项式的g. 可惜我实际上不懂为什么, 背景过于薄弱. 而且我感觉并没有办法直接把自由群上的结论用到亲属半群上来.&lt;/p&gt;&lt;p&gt;如果在geometric group theory这方面有背景的人可以来讨论这个问题啊.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Acknowledgements&lt;/b&gt;&lt;/p&gt;&lt;p&gt;感谢&lt;a href=&quot;http://xilinyu2.web.engr.illinois.edu/&quot;&gt;Xilin Yu&lt;/a&gt;读了第一个草稿以及给了有用的建议. 感谢三姑六婆的作者和我讨论过他(们?)的app的实现方式. &lt;/p&gt;&lt;h2&gt;References&lt;/h2&gt;&lt;p&gt;[1] ALEXEI MYASNIKOV, ANDREY NIKOLAEV, AND ALEXANDER USHAKOV, &quot;KNAPSACK PROBLEMS IN GROUPS&quot;, MATHEMATICS OF COMPUTATION&lt;br&gt;Volume 84, Number 292, March 2015, Pages 987–1016. &lt;a href=&quot;https://arxiv.org/abs/1302.5671&quot;&gt;Arxiv&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;[2] Read, Dwight W., et al. “An Algebraic Account of the American Kinship Terminology [and Comments and Reply].” &lt;i&gt;Current Anthropology&lt;/i&gt;, vol. 25, no. 4, 1984, pp. 417–449. &lt;i&gt;JSTOR&lt;/i&gt;, www.jstor.org/stable/2742902.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Appendix&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;没有儿子的男性, 为什么可以用&quot;儿子的母亲“来描述妻子这样一个关系呢? (只考虑血缘的亲属关系. 没有小孩的话妻子和自己就没有任何血缘关系.)&lt;/li&gt;&lt;li&gt;怎么会一个人一生只和另一个人有小孩啊? (可以考虑sm和sm不同的状态... 因为不同的儿子的母亲可能不一样.., 但这样就没有半群了... 就不好玩了... 就没算法题了...) &lt;/li&gt;&lt;li&gt;如果两个人已经有一定亲属关系的人生了小孩呢? (不代表模型给的结论是错的, 只不过可能有更简单的描述. )&lt;/li&gt;&lt;li&gt;年龄呢? 这不被考虑. 模型只能分辨苏丹型系统可以分辨的关系.&lt;/li&gt;&lt;li&gt;同性的关系就不被考虑了? 这不政治正确! (这就是为啥我不敢在Quora上发这样的文章 :)&lt;/li&gt;&lt;li&gt;写小说的时设计新的语言的时候. 可能会发现这个算法有点用吧. 这种motivation至少比某些算法竞赛题里面的“今天是你的生日, 所以想要送你一个整数数组”来的好多了吧. (如Codeforces: &lt;a href=&quot;http://codeforces.com/problemset/problem/351/E&quot;&gt;351E&lt;/a&gt;,  &lt;a href=&quot;http://codeforces.com/problemset/problem/354/C&quot;&gt;354C&lt;/a&gt;, &lt;a href=&quot;http://codeforces.com/problemset/problem/451/B&quot;&gt;451B&lt;/a&gt;, &lt;a href=&quot;http://codeforces.com/problemset/problem/703/D&quot;&gt;703D&lt;/a&gt;)&lt;/li&gt;&lt;li&gt;能不能简单介绍一下算法? 多项式时间生成 straight line grammar很简单. 可以通过目标关系生成一个context-free language(CFL) &lt;equation&gt;L&lt;/equation&gt; (为啥是context free要证), 使得 &lt;equation&gt;L&lt;/equation&gt; 为所有目标关系的标准描述. 而可以使用的术语的标准描述的集合为 &lt;equation&gt;W&lt;/equation&gt; . 我们求 &lt;equation&gt;L\cap W^*&lt;/equation&gt; 里最小weight的string. 用这种方法能做到 &lt;equation&gt;O(n^5)&lt;/equation&gt; , 要达到 &lt;equation&gt;O(n^3)&lt;/equation&gt; 的话时间复杂度则需要做更多. 根本不碰context-free language. 保证一切都在regular language的状态下.  &lt;equation&gt;R(X)&lt;/equation&gt; 为可以从 &lt;equation&gt;X&lt;/equation&gt; 开始, 可以通过apply string rewriting rules  &lt;equation&gt;abc\to d&lt;/equation&gt; 写出来的string(这里要求abc=d). 如果 &lt;equation&gt;X&lt;/equation&gt; 是regular的, 则 &lt;equation&gt;R(X)&lt;/equation&gt; 是regular的 (难度来自于创建数据结构, 对于 &lt;equation&gt;R(X)&lt;/equation&gt; 里每一个string都能输出它的weight). &lt;equation&gt;S(x)&lt;/equation&gt; 为从 &lt;equation&gt;x&lt;/equation&gt; 开始通过apply string rewriting rules  &lt;equation&gt;ac\to bc&lt;/equation&gt; 能写出来的所有string(这里要求ac=bc). 我们求 &lt;equation&gt;S(x) \cap R(W^*)&lt;/equation&gt; 中weight最小的string, 这里x是目标关系的标准描述. 虽然看起来简单 但是有一大堆东西需要证明...&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2017-08-28-25012875</guid>
<pubDate>Mon, 28 Aug 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Weighted linear matroid parity问题</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2017-07-06-27679823.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27679823&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今年的STOC best papers之一是&lt;a href=&quot;http://www.opt.mist.i.u-tokyo.ac.jp/~iwata/&quot; data-editable=&quot;true&quot; data-title=&quot;Satoru Iwata&quot;&gt;Satoru Iwata&lt;/a&gt;和&lt;a href=&quot;http://infoshako.sk.tsukuba.ac.jp/~kobayashi/eindex.html&quot; data-editable=&quot;true&quot; data-title=&quot;Yusuke Kobayashi&quot;&gt;Yusuke Kobayashi&lt;/a&gt;的文章. A weighted linear matroid parity algorithm. &lt;/p&gt;&lt;p&gt;这个实际上2011年Pap和Iwata都独自说已经有算法了, 但是花了这么多年才把paper写出来... Pap的文章还没有发出来... 有兴趣的可以去看那个快60页纸的technical report, 全是算法的描述和证明. &lt;a href=&quot;http://www.keisu.t.u-tokyo.ac.jp/research/techrep/data/2017/METR17-01.pdf&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;u-tokyo.ac.jp 的页面&quot;&gt;http://www.keisu.t.u-tokyo.ac.jp/research/techrep/data/2017/METR17-01.pdf&lt;/a&gt;&lt;/p&gt;&lt;p&gt;那么什么是weighted linear matroid parity(也叫matroid matching)问题, 为什么这文章可以拿STOC best paper呢?&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;b&gt;Input:&lt;/b&gt; 给一些集合&lt;equation&gt;S_1,\ldots,S_n&lt;/equation&gt;. 每个集合里有两个向量(任何域都可以). 集合&lt;equation&gt;S_i&lt;/equation&gt;有weight &lt;equation&gt;w(S_i)&lt;/equation&gt;. 让&lt;equation&gt;S=\bigcup_{i=1}^n S_i&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;&lt;b&gt;Output: &lt;/b&gt;找到&lt;equation&gt;X\subset [n]&lt;/equation&gt;, 使得 &lt;/p&gt;&lt;p&gt;1. 对于任意&lt;equation&gt;i, j\in X&lt;/equation&gt;,&lt;equation&gt;i\neq j&lt;/equation&gt;,不存在向量同时存在于&lt;equation&gt;S_i&lt;/equation&gt;和&lt;equation&gt;S_j
&lt;/equation&gt;中.&lt;/p&gt;&lt;p&gt;2. &lt;equation&gt;\bigcup_{i\in X} S_i&lt;/equation&gt;是&lt;equation&gt;S
&lt;/equation&gt;的一个基.&lt;/p&gt;&lt;p&gt;3. 满足上诉两个条件的&lt;equation&gt;X&lt;/equation&gt;下&lt;equation&gt;\sum_{i \in X} w(S_i)&lt;/equation&gt;最小.&lt;/p&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;一个算法问题, 见得多了之后, 感觉如果有多项式时间算法, 也就那几种.&lt;/p&gt;&lt;p&gt;一般的设计方法, 自然是算法课上的那些常见的设计方法. DP啊, Greedy啊这些常见的小锤子. 不行的话, 就要开始拿稍微强劲一点的锤子来砸了.&lt;/p&gt;&lt;br&gt;&lt;p&gt;有两个稍微常见的锤子&lt;/p&gt;&lt;p&gt;- min-cost (integral) flow&lt;/p&gt;&lt;p&gt;- max weight matching&lt;/p&gt;&lt;br&gt;&lt;p&gt;这两个锤子在无向图上都可以规约到一个更高端的问题, 最大weight的vertex disjoint S-path问题.&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;给一个图G=(V,E), 以及一个一些特殊的顶点&lt;equation&gt;T\subset V&lt;/equation&gt;. &lt;equation&gt;T&lt;/equation&gt;被partition为&lt;equation&gt;\mathcal{S}=\{S_1,\ldots,S_k\}&lt;/equation&gt; , 其中&lt;equation&gt;S_i\subset V&lt;/equation&gt;. 每个边上有一个weight. 一个path叫做&lt;equation&gt;\mathcal{S}&lt;/equation&gt;-path, 如果这个path的起点属于&lt;equation&gt;S_i&lt;/equation&gt;, 终点属于&lt;equation&gt;S_j&lt;/equation&gt;, 中间不通过任何其他&lt;equation&gt;T&lt;/equation&gt;里面的顶点.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\mathcal{S}&lt;/equation&gt; -path问题: 找到一些vertex disjoint的S-paths, 使得weight的和最大.&lt;/p&gt;&lt;p&gt;这个看起来非常NP-hard的问题可以规约到weighted linear matroid parity问题上. 而Iwata和Kobayashi的这个文章就解决了这个问题, 给了我们可以合二为一的大锤子. 现在我挥舞着这个锤子会想我以前的哪些钉子/手机可以用这个来敲...&lt;/p&gt;&lt;br&gt;&lt;p&gt;最近在日本这边交流, 和上诉的作者都见过面聊了聊. 我在想的几个问题被告知是一些我听都没有听过的问题的特殊版本. 不愧是(理论的)组合优化强国啊.&lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2017-07-06-27679823</guid>
<pubDate>Thu, 06 Jul 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>大新闻: 线性时间凸多边形最大内接三角形又变成了未解问题</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2017-06-02-27222683.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27222683&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
昨天arXiv上出现了这篇文章.&lt;a href=&quot;https://arxiv.org/abs/1705.11035&quot; data-editable=&quot;true&quot; data-title=&quot;[1705.11035] Maximum-Area Triangle in a Convex Polygon, Revisited&quot; class=&quot;&quot;&gt;[1705.11035] Maximum-Area Triangle in a Convex Polygon, Revisited&lt;/a&gt;&lt;br&gt;&lt;p&gt;文章中提到那个常见的&lt;equation&gt;O(n)&lt;/equation&gt;时间的找凸多边形里最大的三角形的算法是错误的. 给了一个counterexample, 并且给出了一个新的&lt;equation&gt;O(n\log n)&lt;/equation&gt;时间的算法. &lt;/p&gt;&lt;p&gt;所以&lt;equation&gt;O(n)&lt;/equation&gt;时间找凸多边形里最大的三角形是个open problem了.&lt;/p&gt;&lt;p&gt;有不少算法 比如找凸多边形内最大内接k边形的算法用了找最大三角形的算法做subroutine.&lt;/p&gt;&lt;br&gt;&lt;p&gt;这样看起来下面这个问题里的回答都是有问题(包括我自己的)或者解决了open problem了.&lt;/p&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/46395055&quot; data-editable=&quot;true&quot; data-title=&quot;如何计算凸包的最大内接四边形面积? - 知乎&quot; class=&quot;&quot;&gt;如何计算凸包的最大内接四边形面积? - 知乎&lt;/a&gt;&lt;p&gt;&lt;b&gt;更新 6/6/2017 3:17AM GMT+8:&lt;/b&gt; &lt;a href=&quot;https://www.zhihu.com/people/shi-qi-si/answers&quot; class=&quot;&quot; data-title=&quot;石奇偲&quot;&gt;石奇偲&lt;/a&gt;给了一个简单的文章的描述: &lt;a href=&quot;https://www.zhihu.com/question/60726749/answer/179433208&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;为什么常见的O(n)时间的找凸多边形内最大内接三角形的那个算法是错误的? - 知乎&quot;&gt;为什么常见的O(n)时间的找凸多边形内最大内接三角形的那个算法是错误的? - 知乎&lt;/a&gt;&lt;/p&gt;&lt;p&gt;---&lt;br&gt;&lt;/p&gt;&lt;p&gt;顺便广告一下自己的LaTeX包&lt;a href=&quot;https://github.com/chaoxu/naivemoha&quot; data-editable=&quot;true&quot; data-title=&quot;chaoxu/naivemoha&quot; class=&quot;&quot;&gt;naivemoha&lt;/a&gt;.&lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2017-06-02-27222683</guid>
<pubDate>Fri, 02 Jun 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何利用割来获得一个hypergraph?</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2017-05-10-26812775.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26812775&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于一个hypergraph, &lt;equation&gt;c&lt;/equation&gt;是它的割函数. &lt;equation&gt;c(X)&lt;/equation&gt;是多少条边有一个顶点在&lt;equation&gt;X&lt;/equation&gt;里有一个顶点在&lt;equation&gt;X&lt;/equation&gt;外. 有一个图&lt;equation&gt;G=(V,E)&lt;/equation&gt;, 如果你有一个oracle, input为一个集合&lt;equation&gt;X&lt;/equation&gt;, output为&lt;equation&gt;c(X)&lt;/equation&gt;. 用多少次query可以获得这个图呢? 一个很简单的方法可以得到这个图. &lt;equation&gt;c(\{u\})+c(\{v\})-c(\{u,v\}) = 0&lt;/equation&gt;则不存在边uv, 不然边uv存在. 就算图是有权的, 同样的方法也可以. 所以只用query所有小于等于2的大小的集合的割的值就能获得原来的图. &lt;br&gt;&lt;/p&gt;&lt;p&gt;一个rank r hypergraph为一个所有的边的包含的顶点个数都小于等于r. 对于rank r hypergraph同样的方可行吗? 是否得到所有的满足&lt;equation&gt;|X|\leq r&lt;/equation&gt;的&lt;equation&gt;c(X)&lt;/equation&gt;的值, 就可以唯一确定割函数? (注意只是得到割函数, 因为存在多个hypergraph拥有同样的割函数)&lt;/p&gt;&lt;i&gt;我觉得这并不显然, 但怀疑实际上非常显然. 如果是的话我想知道为什么显然. &lt;/i&gt;&lt;p&gt;我是用了möbius inversion证明的.&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义&lt;/b&gt;: 对于一个函数&lt;equation&gt;f:2^V\to \mathbb{R}&lt;/equation&gt;, &lt;equation&gt;f&lt;/equation&gt;的möbius inversion为&lt;equation&gt;\hat{f}:2^V\to \mathbb{R}&lt;/equation&gt;, 这里&lt;equation&gt;\hat{f}(X) = \sum_{Y\subset X} (-1)^{|X\setminus Y|} f(Y)&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;从定义可以很显然的看出&lt;equation&gt;f+g&lt;/equation&gt;的möbius inversion为&lt;equation&gt;\hat{f}+\hat{g}&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;&lt;b&gt;定义: &lt;/b&gt;一个函数&lt;equation&gt;f&lt;/equation&gt;的möbius rank为r, 如果对于任意&lt;equation&gt;|X|&amp;gt; r&lt;/equation&gt;的集合&lt;equation&gt;X&lt;/equation&gt;, &lt;equation&gt;\hat{f}(X)=0&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;&lt;b&gt;定理&lt;/b&gt;: 获得möbius rank为r的函数&lt;equation&gt;f&lt;/equation&gt;, 只需要query所有小于等于r的集合的&lt;equation&gt;X&lt;/equation&gt;的值就可以了.&lt;/p&gt;&lt;p&gt;&lt;b&gt;证明&lt;/b&gt;: 计算&lt;equation&gt;\hat{f}(X)&lt;/equation&gt;, 就只用query oracle所有的&lt;equation&gt;f(Y)&lt;/equation&gt;, &lt;equation&gt;Y\subseteq X&lt;/equation&gt;即可. &lt;equation&gt;f&lt;/equation&gt;f和&lt;equation&gt;\hat{f}&lt;/equation&gt;是一一对应的, 这样获得了&lt;equation&gt;\hat{f}&lt;/equation&gt;就能获得&lt;equation&gt;f&lt;/equation&gt;. 这个可以看一下&lt;a href=&quot;http://blog.jiaweigao.com/notes/2015/11/21/Zeta-Transform-and-Mobius-Transform/&quot; data-editable=&quot;true&quot; data-title=&quot;高嘉蔚美少女的notes&quot; class=&quot;&quot;&gt;高嘉蔚的notes&lt;/a&gt;. (顺便说这种把note写出来发在网上的都是业界良心)&lt;br&gt;&lt;/p&gt;&lt;p&gt;最后一步就是证明对于只有一条边的rank r hypergraph, 它的möbius rank是r(这很容易证明). 然后用induction on the number of edges就好了. 因为很容易看出möbius rank为r的函数的和也是möbius rank为r的函数.&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;b&gt;Open problem&lt;/b&gt;: Rank 3 free hypergraph为不包含任何大小为3的边的hypergraph. 是否对应一个hypergraph割函数的rank 3 free hypergraph只有一个?&lt;/p&gt;&lt;p&gt;我感觉也应该是个很显然的东西但是没有花时间去证...&lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2017-05-10-26812775</guid>
<pubDate>Wed, 10 May 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>结对编程的分配问题</title>
<link>https://henix.github.io/feeds/zhuanlan.algorithmicliberalartsdegree/2017-03-15-25737917.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25737917&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现实世界:&lt;/p&gt;&lt;p&gt;公司高层学到了结对编程(pair programming)这个概念. 对于每一个任务, 要保证有两个程序员同时在编. 于是此高层下令任何任务必须有两个程序员同时在写. 一个任务要么两个程序员在做, 要么没有人做. 每个任务只能被分配给拥有解决这个任务的能力的程序员. 那么是否可以保证至少k个任务被分配出去呢?&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以得到下面的一个问题:&lt;/p&gt;&lt;p&gt;给一个二分图&lt;equation&gt;G=(A\cup B, E)&lt;/equation&gt;. 找到一个&quot;匹配&quot; &lt;equation&gt;M\subset E&lt;/equation&gt;, 使得在&lt;equation&gt;G&#39;=(A\cup B, M)&lt;/equation&gt;里,&lt;/p&gt;&lt;p&gt;1. 每一个A的顶点&lt;equation&gt;v&lt;/equation&gt;,&lt;equation&gt;\deg(v) \in \{0,t\}&lt;/equation&gt;. 且 &lt;equation&gt;\deg(v)=t&lt;/equation&gt;的顶点至少有k个.&lt;/p&gt;&lt;p&gt;2. 每一个B的顶点&lt;equation&gt;v&lt;/equation&gt;,&lt;equation&gt; \deg(v) \in \{0,1\}&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;这里的M叫做t匹配.&lt;/p&gt;&lt;p&gt;t=1的时候, 是常见的二分图匹配问题.&lt;br&gt;&lt;/p&gt;&lt;p&gt;t=2的时候, 就是我们要解决的问题.&lt;br&gt;&lt;/p&gt;&lt;p&gt;t=3的时候, 这个问题是3-dimensional matching, 是NP-hard的. 所以还好没有什么trio programming...&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么t=2的时候问题可以多项式时间解么? 另一个同样的描述方法, 是找到k个的vertex disjoint的&lt;equation&gt;K_{1,2}&lt;/equation&gt;, 使得center在A里面. 一般人会猜这个是NP-hard的问题. 因为如果同样的问题, &lt;a href=&quot;http://www.sciencedirect.com/science/article/pii/S0167637707000028&quot;&gt;不要求center在A里面的话, 那就是NP-hard的&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这个问题是可以多项式时间解答的. 可以规约到最大权值完美匹配.&lt;/p&gt;&lt;p&gt;方法如下.&lt;/p&gt;&lt;p&gt;创建一个新的图&lt;equation&gt;G&#39;=(V&#39;,E&#39;)&lt;/equation&gt;. 假设&lt;equation&gt;|B|=n&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;C=\{t_1,\ldots,t_{n-2k}\}&lt;/equation&gt;, 是一个有&lt;equation&gt;n-2k&lt;/equation&gt;个新顶点的集合.&lt;/p&gt;&lt;p&gt;&lt;equation&gt;V&#39; = A\cup \{ v_1,v_2 | v\in B\}\cup C&lt;/equation&gt;&lt;/p&gt;&lt;p&gt;对于每一个&lt;equation&gt;v\in A&lt;/equation&gt;, 有一个边&lt;equation&gt;v_1v_2&lt;/equation&gt;, 权值0.&lt;/p&gt;&lt;p&gt;对于每一个&lt;equation&gt;v\in A, u\in B&lt;/equation&gt;, 有边&lt;equation&gt;v_1u&lt;/equation&gt;和&lt;equation&gt;v_2u&lt;/equation&gt;,权值都为1.&lt;/p&gt;&lt;p&gt;对于每一个&lt;equation&gt;v\in A,u\in C&lt;/equation&gt;, 有边&lt;equation&gt;uv&lt;/equation&gt;, 权值为0.&lt;/p&gt;&lt;p&gt;原来的问题有解, 有且仅有在&lt;equation&gt;G&#39;&lt;/equation&gt;上的最大权值完美匹配的值为&lt;equation&gt;2k&lt;/equation&gt;.&lt;/p&gt;&lt;p&gt;原先的问题的有权值的版本也能用类似的方法做出来.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现实世界:&lt;/p&gt;&lt;p&gt;由于结对编程导致程序员强烈不满, 高层允许梨子编程(pear programming).&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Open problems:&lt;/p&gt;&lt;p&gt;1. 如果每一个边上都有权值w, 然后2-匹配 M 的值为 &lt;equation&gt;c(M) = \sum_{a \in V} \min \{ w(e) | a \in b \in M\}&lt;/equation&gt;. 如何找到值最大的2-匹配? 因为pair programming的时会被弱一点的人拉后腿. &lt;b&gt;[几乎解决: NP-hard, 存在2-approximation, APX-hard. 不知道是否存在更好的approximation]&lt;/b&gt; &lt;/p&gt;&lt;p&gt;2. &lt;equation&gt;A&#39;\subseteq A&lt;/equation&gt;叫做nice, 如果存在一个2-匹配,使得&lt;equation&gt;A&#39;&lt;/equation&gt;里每一个顶点的度都是2. 找到最少的nice集合, 使得他们的并集是A. &lt;b&gt;[已解决: OPT+1-approximation!]&lt;/b&gt;&lt;/p&gt;&lt;p&gt;3. &lt;equation&gt;B&#39;\subseteq B&lt;/equation&gt;叫做nice, 如果存在一个2-匹配,使得&lt;equation&gt;B&#39;&lt;/equation&gt;里每一个顶点的度都是1. 找到最少的nice集合, 使得他们的并集是B. &lt;b&gt;[已解决: 存在多项式时间解]&lt;/b&gt; &lt;/p&gt;&lt;p&gt;4. 一个scheduling问题的拓展: scheduling on unrelated parallel machines minimizing makespan allowing preemption, 加上一个新的条件: 任何时候一个job要有两个worker, 而且有些worker不能做某些job. &lt;b&gt;[已解决: 存在多项式时间解]&lt;/b&gt;&lt;/p&gt;</description>
<author>Chao Xu</author>
<guid isPermaLink="false">2017-03-15-25737917</guid>
<pubDate>Wed, 15 Mar 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
