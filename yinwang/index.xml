<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>当然我在扯淡</title>
<link>https://henix.github.io/feeds/yinwang/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Mon, 15 Oct 2018 11:09:48 +0800</lastBuildDate>
<item>
<title>更新一下</title>
<link>https://henix.github.io/feeds/yinwang/2018-10-14-update.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/10/14/update&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;更新一下&lt;/h2&gt;
            &lt;p&gt;我好像正好半年没有写东西了。哦不，我其实写了一些。仔细看我的书的人可能发现，那第一章其实悄悄更新了很多次。但我意识到了问题，我似乎没有动力完成这本书。嗯，我似乎是一个以半途而废著称的人。我从来不觉得必须从头到尾做完什么，除非我一直认为那是正确的方向。&lt;/p&gt;

&lt;p&gt;首先的问题是，写作这本书起初并没有良好的动机。我的意思是，当初想写这本书是出于对现状的“不满”，或者说是：恨。相对于爱，恨不是一个好的动机。&lt;/p&gt;

&lt;p&gt;我的老师 Dan Friedman 写了那么多本“小人书”，每一本都精辟而深刻，专注于一个他当时热爱的主题：函数式编程，逻辑式编程，自动定理证明……&lt;/p&gt;

&lt;p&gt;跟他相比，我自愧不如，因为我的动机不是出于爱。心中的恨，让我很像 Anakin Skywalker。不管恨是如何产生的，如果任其发展，它将把我变成 Darth Vader。我不想成为 Darth Vader。&lt;/p&gt;

&lt;p&gt;动机错了，也就导致了写作这本书的各种困难：设定的目标太高太远，太过注重“精华”，太早的解释过于深刻的原理，语言也啰嗦不流畅，充满了带刺或者负面的字眼…… 我开始担心看了我的书的人会变成什么样子。&lt;/p&gt;

&lt;p&gt;我意识到理解一件事和教会别人这件事，是完全不同的难度。如果我不理解人的心理，我就不会成为一个好的老师。如果我的心灵不够清澈，我就写不出纯美的作品。&lt;/p&gt;

&lt;p&gt;更要命的是，我的生活里有各种似乎更加有趣而有益的事情。所以每次想要写书，马上就会有有趣的事情来打断我……&lt;/p&gt;

&lt;p&gt;因此，写书这个事就被我一拖再拖。我想先研究一下人的心理，我想成为更好的人。只有当我成为一个很好的人，看我的书的人才会成为更好的人。&lt;/p&gt;

&lt;p&gt;但我还不够好。&lt;/p&gt;

&lt;p&gt;*  *  *&lt;/p&gt;

&lt;p&gt;过去的几年我都太关心“教”别人什么东西，以老师自居。可是我最近发现，我最爱的事情其实是从别人那里“学”东西。我喜欢跟人聊天讨论，大大的多过自己看书。经常能体会到“听君一席话，胜读十年书”的道理。&lt;/p&gt;

&lt;p&gt;总之，这半年我就是在学各种新东西。从专家那里学，也从很普通的人那里学。从小说里，电影里，音乐里学。学技术，也学人文。学习和领悟让我快乐。比起把自己封闭在自己的领域和圈子里，写一本旨在“改变现状”的书，学习让我更加快乐。我有了新的朋友和同事，我这才感觉我不再是孤军奋战，感觉新的生活开始了。&lt;/p&gt;

&lt;p&gt;如果只是想教会别人东西，我仍然是原来的我。而从别人那里学东西，我就成为“升级版”的我。学习让我有了朋友，朋友让我心里充满了爱，只有爱才是我前进的动力。&lt;/p&gt;

&lt;p&gt;*  *  *&lt;/p&gt;

&lt;p&gt;过去的王垠，心中充满了批判，然而世界上有远比批判有效而有益的事情。批判难以达到改进世界的效果，我的价值不可能通过批判而得到实现，而且它会让我失去潜在的朋友。价值的实现只能通过把我的技能，通过友好而快乐的途径作用到现实世界，让世界变得更好。不好的方面应该被忘记，而不是花大力气去批判它们。&lt;/p&gt;

&lt;p&gt;过去的王垠，以“天才”自居，天天谈论技术，各种评判；而现在的王垠，更加重视友谊和人性，比较少评判事物。比起冰冷的技术，真心的朋友更加能让我快乐。我希望有更多的朋友，更少的敌人。&lt;/p&gt;

&lt;p&gt;有个朋友引用一句林徽因的诗来赞美我：“你是爱，是暖，是希望，你是人间的四月天。” 目前感觉言过其实，不过我会努力达到这个境界，嗯。&lt;/p&gt;

&lt;p&gt;除了技术，世界上还有那么多有趣而重要的东西：艺术，文学，音乐，美食…… 它们也越来越多的走进我的生活，让我成为一个更加丰富的人。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/les-miserables.jpg&quot; width=&quot;600&quot;&gt;&lt;/p&gt;

&lt;p&gt;我要感谢我的朋友们。真的朋友就像一面镜子，从你们我认识到了自己的问题，拓展了自己的视野。我会不断改进自己。&lt;/p&gt;

&lt;p&gt;我不想再做一个不接地气的神，我的心里对自己的能力没有 pride。我不再是“垠神”，也不要叫我“大神”了。与其让人们崇拜我，畏惧我，恭维我，我更愿意让他们发自内心地喜欢我。我欢迎各种形式的互相学习和交流合作。&lt;/p&gt;

&lt;p&gt;虽然不再继续写那本书，我肯定会写技术方面的博文，而且更新会比书频繁很多。写书让我犯困，几个月写不出来一章，还不如写点短的文章分享一下。所以不用为书遗憾，因为专注于一个主题的短文是更加有效而有价值的东西。&lt;/p&gt;

&lt;p&gt;上海是一个神奇的城市。这里有很多我喜欢的故事，是一个人杰地灵的地方。自从民国年代，许许多多的传奇故事发生在上海。我希望我在上海也有美好的故事。&lt;/p&gt;

&lt;p&gt;最后再次感谢大家的支持。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-10-14-update</guid>
<pubDate>Sun, 14 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>改变</title>
<link>https://henix.github.io/feeds/yinwang/2018-05-28-change.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/05/28/change&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;改变&lt;/h2&gt;
            &lt;p&gt;我最近对博客和微博作了一些调整，也有一段时间没有更新我的书。博客少了一些文章。我会继续写我的书，但我也有很多其它事情做，我需要限制使用电脑的时间。微博用户群的质量值得怀疑，所以微博不会再有“个人稀里糊涂式”的更新，而只用于发布“冠冕堂皇式”的新闻，新闻联播那种。&lt;/p&gt;

&lt;p&gt;由于在美国的工作给了我一些遗留的伤口，这一段时间最重要的用途，应该是用来修复和放松我的身心，而不是用来实现什么伟大目标或者拯救世界。我在中国的着陆并不是平稳的——实际上我着陆在沼泽里。经过了一年，我仍然在试图建立对国内环境和人的信任。我感觉自己像一个穿着宇宙服的外星人，有时候打开面罩透口气。还好，我终于遇到了一些可爱的人。&lt;/p&gt;

&lt;p&gt;名义上是天才，我的生活也跟真正的天才（比如梵高）一样，可以说是破碎的。不管怎样，这与我本来的价值是极不相称的。为了所谓的“真知”，我错过了许多普通人都有的幸福。我需要重新开始体验生活的美好，我不想和历史上的悲剧天才们一样。如果说我有一件有价值的东西，那就是我得到了心的自由。&lt;/p&gt;

&lt;p&gt;在过去的几年，我花费了太多精力来“关心人类”，这使我疲惫。社会有许多的问题，我所在的 IT 领域惨不忍睹，然而批判人性的丑恶不应该是我的职责。生活中总是有丑陋，猥琐，虚伪的人，然而他们应该被忽略，我应该关注那些美好的。把注意力放在批判上，让我白白浪费人生中最美好的时光。&lt;/p&gt;

&lt;p&gt;我不是超人。我没有精力来关心中东的战火，非洲的饥荒，欧洲和美国的恐袭…… 同样的，我没有精力来为 IT 业界的很多丑恶现象忧心。应该有人去帮助他们，但我大概不是那个人。我曾以为那是我应该做的事，我告诉 Dan Friedman 我在做一件拯救 IT 业的事情。他回复说：“我刚写了一本新书，绝妙无比！你把地址给我，我给你寄过去！We are family！” 我喜欢这样鸡同鸭讲的对话。&lt;/p&gt;

&lt;p&gt;当今社会并不是以前那样脆弱。很多事情我指出了也不会起作用，不说它也糟不到哪里去。大街上的小混混知道谁是王垠吗？不知道。同理，技术界的低等生物也不会在乎王垠说什么，虽然他们吸收的一些养料是王垠不知道什么时候排出去的…… 每个人有自己的圈子，我没必要也不可能去跟他们较量。&lt;/p&gt;

&lt;p&gt;我看到的只是一个领域的人，甚至不是他们的全部。稍微往外面一跳，就发现自己以为很重要的事情，在外人看来其实不知所谓，无关紧要。什么 AI，区块链，黑科技…… 出了它们的圈子，真没多少人在乎。吹嘘它们以及批判它们的人，都像傻子一样。&lt;/p&gt;

&lt;p&gt;很多人，不管他们是什么冠冕堂皇的头衔，应该像街头小混混一样被抛在脑后，被忽略，而不是被仔仔细细记录下来，进行深入的批判。这不是一个顶级人才应该做的事。所以停止批判他们，不是妥协，而是彻底的无视，一种井水不犯河水的“和睦相处”关系。虽然被它们咬过，但痛过之后，我不再关心海底有什么丑陋的虫子，我有自己的风景……&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/orca1.jpg&quot; width=&quot;450&quot;&gt;&lt;/p&gt;

&lt;p&gt;“拯救人类”不是我的任务。上天赋予我的才华，应该被用到更有意义的地方。我的目标不是跟完全不在一个层次的人较真，而是发现跟我在一个层次的人。当然这里所谓的“层次”，不是通常意义上的社会等级，而是本质上的“人的质量”。就像 Emily Post 所谓的“Best Society”，它无关出身，财富，社会头衔，技术能力……&lt;/p&gt;

&lt;p&gt;世界是多元化的，每个人都有自己的角落，我会找到本来属于我的角落。从今天开始，不再关心人类，做一个幸福的人。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-05-28-change</guid>
<pubDate>Mon, 28 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>解谜计算机科学（1）</title>
<link>https://henix.github.io/feeds/yinwang/2018-04-13-csbook-chapter1.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/04/13/csbook-chapter1&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;解谜计算机科学（1）&lt;/h2&gt;
            &lt;h1 id=&quot;第一章---初识计算&quot;&gt;第一章 - 初识计算&lt;/h1&gt;

&lt;p&gt;（本书版权归王垠所有，禁止转载。请认准 yinwang.org 为唯一的阅读地址，以获得最近更新。）&lt;/p&gt;

&lt;p&gt;要掌握一个学科的精髓，不能从细枝末节开始。人脑的能力很大程度上受限于信念。一个人不相信自己的时候，他就做不到本来可能的事。信心是很重要的，信心却容易被挫败。如果只见树木不见森林，人会失去信心，以为要到猴年马月才能掌握一个学科。&lt;/p&gt;

&lt;p&gt;所以这本书不从“树木”开始，而是引导读者一起来探索这背后的“森林”。本书把计算机科学最根本的概念用浅显的例子解释，让读者领会到它们的本质。把这些概念稍作发展，你就得到逐渐完整的把握。你一开头就掌握着整个学科，而且一直掌握着它，只不过增添更多细节而已。这就像画画，先勾勒出轮廓，一遍遍的增加细节，日臻完善，却不失去对大局的把握。&lt;/p&gt;

&lt;p&gt;一般计算机专业的学生学了很多课程，可是直到毕业都没能回答一个基础问题：什么是计算？这一章会引导你去发现这个问题的答案。不要小看这基础的问题，它经常是解决现实问题的重要线索。世界上有太多不理解它的人，他们走了很多的弯路，掉进很多的坑，制造出过度复杂或者有漏洞的理论和技术。&lt;/p&gt;

&lt;p&gt;接下来，我们就来理解几个关键的概念，由此接触到计算的本质。&lt;/p&gt;

&lt;h3 id=&quot;自觉付费&quot;&gt;自觉付费&lt;/h3&gt;

&lt;p&gt;跟本书的前言不同，这一章的内容不是免费的。你如果想继续读下去，请自觉进行付费。你的付款将会支持这本书的继续写作和更新。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/csbook1-wechat-pay.jpg&quot; width=&quot;200&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/csbook1-alipay.jpg&quot; width=&quot;200&quot;&gt;&lt;/p&gt;

&lt;h3 id=&quot;手指算术&quot;&gt;手指算术&lt;/h3&gt;

&lt;p&gt;每个人都做过计算，只是大部分人都没有理解自己在做什么。回想一下幼儿园（大概四岁）的时候，妈妈问你：“帮我算一下，4+3 等于几？” 你掰了一会手指，回答：7。当你掰手指的时候，你自己就是一台简单的计算机。&lt;/p&gt;

&lt;p&gt;不要小看了这手指算术，它蕴含着深刻的原理。计算机科学植根于这类非常简单的过程，而不是复杂的高等数学。&lt;/p&gt;

&lt;p&gt;现在我们来回忆一下这个过程。这里应该有一段动画，但现阶段还没有。请你对每一步发挥一下想象力，增加点“画面感”。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当妈妈问你“4+3 等于几”的时候，她是一个程序员，你是一台计算机。计算机得到程序员的输入：4，+，3。&lt;/li&gt;
  &lt;li&gt;听到妈妈的问题之后，你拿出两只手，左手伸出四个指头，右手伸出三个指头。&lt;/li&gt;
  &lt;li&gt;接着你开始自己的计算过程。一根根地数那些竖起来的手指，每数一根你就把它弯下去，表示它已经被数过了。你念道：“1，2，3，4，5，6，7。”&lt;/li&gt;
  &lt;li&gt;现在已经没有手指伸着，所以你把最后数到的那个数作为答案：7！整个计算过程就结束了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;符号和模型&quot;&gt;符号和模型&lt;/h3&gt;

&lt;p&gt;（这个概念太过深入，好像不适合出现在第一章，考虑去掉）&lt;/p&gt;

&lt;p&gt;这里的幼儿园手指算术包含着深刻的哲学问题，现在我们来初步体会一下这个问题。&lt;/p&gt;

&lt;p&gt;当妈妈说“帮我算 4+3”的时候，4，+，3，三个字符传到你耳朵里，它们都是符号（symbol）。符号是“表面”的东西：光是盯着“4”和“3”这两个阿拉伯数字的曲线，一个像旗子，一个像耳朵，你是不能做什么的。你需要先用脑子把它们转换成对应的“模型”（model）。这就是为什么你伸出两只手，一只手表示 4，另一只表示 3。&lt;/p&gt;

&lt;p&gt;这两只手的手势是“可操作”的。比如，你把左手再多弯曲一个手指，它就变成“3”。你再伸开一根手指，它就变成“5”。所以手指是一个相当好的机械模型，它是可以动，可操作的。把符号“4”和“3”转换成手指模型之后，你就可以开始计算了。&lt;/p&gt;

&lt;p&gt;你怎么知道“4”和“3”对应什么样的手指模型呢？因为妈妈以前教过你。十根手指，对应着 1 到 10 十个数。这就是为什么人都用十进制数做算术。&lt;/p&gt;

&lt;p&gt;我们现在没必要深究这个问题。我只是提示你，分清“符号”和“模型”是重要的。&lt;/p&gt;

&lt;h3 id=&quot;计算图&quot;&gt;计算图&lt;/h3&gt;

&lt;p&gt;在计算机领域，我们经常用一些抽象的图示来表达计算的过程，这样就能直观地看到信息的流动和转换。这种图示看起来是一些形状用箭头连接起来。我在这里把它叫做“计算图”。&lt;/p&gt;

&lt;p&gt;对于以上的手指算术 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt;，我们可以用下图来表示它：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/adder.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;图中的箭头表示信息的流动方向。说到“流动”，你可以想象一下水的流动。首先我们看到数字 4 和 3 流进了一个圆圈，圆圈里有一个“+”号。这个圆圈就是你，一个会做手指加法的小孩。妈妈给你两个数 4 和 3，你现在把它们加起来，得到 7 作为结果。&lt;/p&gt;

&lt;p&gt;注意圆圈的输入和输出方向是由箭头决定的，我们可以根据需要调整那些箭头的位置，只要箭头的连接关系和方向不变就行。它们不一定都是从左到右，也可能从右到左或者从上到下，但“出入关系”都一样：4 和 3 进去，结果 7 出来。比如它还可以是这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/adder-topdown.png&quot; width=&quot;180&quot;&gt;&lt;/p&gt;

&lt;p&gt;我们用带加号的圆圈表示一个“加法器”。顾名思义，加法器可以帮我们完成加法。在上个例子里，你就是一个加法器。我们也可以用其他装置作为加法器，比如一堆石头，一个算盘，某种电子线路…… 只要它能做加法就行。&lt;/p&gt;

&lt;p&gt;具体要怎么做加法，就像你具体如何掰手指，很多时候我们是不关心的，我们只需要知道这个东西能做加法就行。圆圈把具体的加法操作给“抽象化”了，这个蓝色的圆圈可以代表很多种东西。抽象（abstraction）是计算机科学至关重要的思维方法，它帮助我们进行高层面的思考，而不为细节所累。&lt;/p&gt;

&lt;h3 id=&quot;表达式&quot;&gt;表达式&lt;/h3&gt;

&lt;p&gt;计算机科学当然不止 4 + 3 这么简单，但它的基本元素确实是如此简单。我们可以创造出很复杂的系统，然而归根结底，它们只是在按某种顺序计算像 4 + 3 这样的东西。&lt;/p&gt;

&lt;p&gt;4 + 3 是一个很简单的表达式（expression）。你也许没听说过“表达式”这个词，但我们先不去定义它。我们先来看一个稍微复杂一些的表达式：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个表达式比 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt; 多了一个运算，我们把它叫做“复合表达式”。这个表达式也可以用计算图来表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/add-mult.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;你知道它为什么是这个样子吗？它表示的意思是，先计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt;，然后把结果（7）传送到一个“乘法器”，跟 2 相乘，得到最后的结果。那正好就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * (4 + 3)&lt;/code&gt; 这个表达式的含义，它的结果应该是 14。&lt;/p&gt;

&lt;p&gt;为什么要先计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt; 呢？因为当我们看到乘法器 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * ...&lt;/code&gt; 的时候，其中一个输入（2）是已知的，而另外一个输入必须通过加法器的输出得到。加法器的结果是由 4 和 3 相加得到的，所以我们必须先计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt;，然后才能与 2 相乘。&lt;/p&gt;

&lt;p&gt;小学的时候，你也许学过：“括号内的内容要先计算”。其实括号只是“符号层”的东西，它并不存在于计算图里面。我这里讲的“计算图”，其实才是本质的东西。数学的括号一类的东西，都只是表象，它们是符号或者叫“语法”。从某种意义上讲，计算图才是表达式的本质或者“模型”，而“2 * (4 + 3)”这串符号，只是对计算图的一种表示或者“编码”（coding）。&lt;/p&gt;

&lt;p&gt;这里我们再次体会到了“符号”和“模型”的差别。符号是对模型的“表示”或者“编码”。我们必须从符号得到模型，才能进行操作。这种从符号到模型的转换过程，在计算机科学里叫做“语法分析”（parsing）。我们会在后面的章节理解这个过程。&lt;/p&gt;

&lt;p&gt;我们现在来给表达式做一个初步的定义。这并不是完整的定义，但你应该试着理解这种定义的方式。稍后我们会逐渐补充这个定义，逐渐完善。&lt;/p&gt;

&lt;p&gt;定义（表达式）：&lt;strong&gt;表达式&lt;/strong&gt;可以是如下几种东西。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数字是一个表达式。比如 1，2，4，15，……&lt;/li&gt;
  &lt;li&gt;表达式 + 表达式。两个表达式相加，也是表达式。&lt;/li&gt;
  &lt;li&gt;表达式 - 表达式。两个表达式相减，也是表达式。&lt;/li&gt;
  &lt;li&gt;表达式 * 表达式。两个表达式相乘，也是表达式。&lt;/li&gt;
  &lt;li&gt;表达式 / 表达式。两个表达式相除，也是表达式。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意，由于我们之前讲过的符号和模型的差别，为了完全忠于我们的本质认识，这里的“表达式 + 表达式”虽然看起来是一串符号，它必须被想象成它所对应的模型。当你看到“表达式”的时候，你的脑子里应该浮现出它对应的计算图，而不是一串符号。这个计算图的画面大概是这个样子，其中左边的大方框里可以是任意两个表达式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/expression-graph.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;是不是感觉这个定义有点奇怪？因为在“表达式”的定义里，我们用到了“表达式”自己。这种定义叫做“递归定义”。所谓&lt;strong&gt;递归&lt;/strong&gt;（recursion），就是在一个东西的定义里引用这个东西自己。看上去很奇怪，好像绕回去了一样。递归是一个重要的概念，我们会在将来深入理解它。&lt;/p&gt;

&lt;p&gt;现在我们可以来验证一下，根据我们的定义，&lt;code class=&quot;highlighter-rouge&quot;&gt;2 * (4 + 3)&lt;/code&gt; 确实是一个表达式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先根据第一种形式，我们知道 4 是表达式，因为它是一个数字。3 也是表达式，因为它是一个数字。&lt;/li&gt;
  &lt;li&gt;所以  &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt; 是表达式，因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 的左右都是表达式，它满足表达式定义的第二种形式。&lt;/li&gt;
  &lt;li&gt;所以 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * (4 + 3)&lt;/code&gt; 是表达式，因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 的左右都是表达式，它满足表达式定义的第四种形式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;并行计算&quot;&gt;并行计算&lt;/h3&gt;

&lt;p&gt;考虑这样一个表达式：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它对应一个什么样的计算图呢？大概是这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/parallel.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;如果妈妈只有你一个小孩，你应该如何用手指算出它的结果呢？你大概有两种办法。&lt;/p&gt;

&lt;p&gt;第一种办法：先算出 4+3，结果是 7。然后算出 1+2，结果是 3。然后算 7*3，结果是 21。&lt;/p&gt;

&lt;p&gt;第二种办法：先算出 1+2，结果是 3。然后算出 4+3，结果是 7。然后算 7*3，结果是 21。&lt;/p&gt;

&lt;p&gt;注意到没有，你要么先算 4+3，要么先算 1+2，你不能同时算 4+3 和 1+2。为什么呢？因为你只有两只手，所以算 4+3 的时候你就没法算 1+2，反之也是这样。总之，你妈妈只有你一个加法器，所以一次只能做一个加法。&lt;/p&gt;

&lt;p&gt;现在假设你还有一个妹妹，她跟你差不多年纪，她也会手指算术。妈妈现在就多了一些办法来计算这个表达式。她可以这样做：让你算 4+3，不等你算完，马上让妹妹算 1+2。等到你们的结果（7 和 3）都出来之后，让你或者妹妹算 7*3。&lt;/p&gt;

&lt;p&gt;发现没有，在某一段时间之内，你和妹妹&lt;em&gt;同时&lt;/em&gt;在做加法计算。这种时间上重叠的计算，叫做&lt;strong&gt;并行计算&lt;/strong&gt;（parallel computing）。&lt;/p&gt;

&lt;p&gt;你和妹妹同时计算，得到结果的速度可能会比你一个人算更快。如果你妈妈还有其它几个孩子，计算复杂的式子就可能快很多，这就是并行计算潜在的好处。所谓“潜在”的意思是，这种好处不一定会实现。比如，如果你的妹妹做手指算数的速度比你慢很多，你做完了 4+3，只好等着她慢慢的算 1+2。这也许比你自己依次算 4+3 和 1+2 还要慢。&lt;/p&gt;

&lt;p&gt;即使妹妹做算术跟你一样快，这里还有个问题。你和妹妹算出结果 7 和 3 之后，得把结果传递给下一个计算 7*3 的那个人（也许是你，也许是你妹妹）。这种“通信”会带来时间的延迟，叫做“通信开销”。如果你们其中一个说话慢，这比起一个人来做计算可能还要慢。&lt;/p&gt;

&lt;p&gt;如何根据计算单元能力的不同和通信开销的差异，来最大化计算的效率，降低需要的时间，就成为了并行计算领域研究的内容。并行计算虽然看起来是一个“博大精深”的领域，可是你如果理解了我这里说的那点东西，就很容易理解其余的内容。&lt;/p&gt;

&lt;h3 id=&quot;变量和赋值&quot;&gt;变量和赋值&lt;/h3&gt;

&lt;p&gt;如果你有一个复杂的表达式，比如&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于它有比较多的嵌套，人的眼睛是难以看清楚的，它要表达的意义也会难懂。这时候，你希望可以用一些“名字”来代表中间结果，这样表达式就更容易理解。&lt;/p&gt;

&lt;p&gt;打个比方，这就像你有一个亲戚，他是你妈妈的表姐的女儿的丈夫。你不想每次都称他“我妈妈的表姐的女儿的丈夫”，所以你就用他的名字“叮当”来指代他，一下子就简单了。&lt;/p&gt;

&lt;p&gt;我们来看一个例子。之前的复合表达式&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其实可以被转换为等价的，含有变量的代码：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// 变量 a 得到 4+3 的值
&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;// 代码块的值
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 是一个名字。&lt;code class=&quot;highlighter-rouge&quot;&gt;a = 4 + 3&lt;/code&gt; 是一个“赋值语句”，它的意思是：用 a 来代表 4 + 3 的值。这种名字，计算机术语叫做&lt;strong&gt;变量&lt;/strong&gt;（variable）。&lt;/p&gt;

&lt;p&gt;这段代码的意思可以简单地描述为：计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt;，把它的结果表示为 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;，然后计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt; 作为最后的结果。&lt;/p&gt;

&lt;p&gt;有些东西可能扰乱了你的视线。两根斜杠 &lt;code class=&quot;highlighter-rouge&quot;&gt;//&lt;/code&gt; 后面一直到行末的文字叫做“注释”，是给人看的说明文字。它们对代码的逻辑不产生作用，执行的时候可以忽略。许多语言都有类似这种注释，它们可以帮助阅读的人，但是会被机器忽略。&lt;/p&gt;

&lt;p&gt;这段代码执行过程会是这样：先计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3&lt;/code&gt; 得到 7，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 记住这个中间结果 7。接着计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt; ，也就是计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * 7&lt;/code&gt;，所以最后结果是 14。很显然，这跟 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * (4 + 3)&lt;/code&gt; 的结果是一样的。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 叫做一个变量，它是一个符号，可以用来代表任意的值。除了 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;，你还有许多的选择，比如 b, c, d, x, y, foo, bar, u21… 只要它不会被误解成其它东西就行。&lt;/p&gt;

&lt;p&gt;如果你觉得这里面的“神奇”成分太多，那我们现在来做更深一层的理解……&lt;/p&gt;

&lt;p&gt;再看一遍上面的代码。这整片代码叫做一个“代码块”（block），或者叫一个“序列”（sequence）。这个代码块包括两条语句，分别是 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 4 + 3&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt;。代码块里的语句会从上到下依次执行。所以我们先执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 4 + 3&lt;/code&gt;，然后执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;最后一条语句 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt; 比较特别，它是这个代码块的“值”，也就是最后结果。之前的语句都是在为生成这个最后的值做准备。换句话说，这整个代码块的值就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * a&lt;/code&gt; 的值。不光这个例子是这样，这是一个通用的原理：代码块的最后一条语句，总是这个代码块的值。&lt;/p&gt;

&lt;p&gt;我们在代码块的前后加上花括号 &lt;code class=&quot;highlighter-rouge&quot;&gt;{...}&lt;/code&gt; 进行标注，这样里面的语句就不会跟外面的代码混在一起。这两个花括号叫做“边界符”。我们今后会经常遇到代码块，它存在于几乎所有的程序语言里，只是语法稍有不同。比如有些语言可能用括号 &lt;code class=&quot;highlighter-rouge&quot;&gt;(...)&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;BEGIN...END&lt;/code&gt; 来表示边界，而不是用花括号。&lt;/p&gt;

&lt;p&gt;这片代码已经有点像常用的编程语言了，但我们暂时不把它具体化到某一种语言。我不想固化你的思维方式。在稍后的章节，我们会把这种抽象的表达法对应到几种常见的语言，这样一来你就能理解几乎所有的程序语言。&lt;/p&gt;

&lt;p&gt;另外还有一点需要注意，同一个变量可以被多次赋值。它的值会随着赋值语句而改变。举个例子：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码执行之后，&lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; 的值是 7，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; 的值是 10。你知道为什么吗？因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 4 + 3&lt;/code&gt; 之后，a 的值是 7。&lt;code class=&quot;highlighter-rouge&quot;&gt;b = a&lt;/code&gt; 使得 &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; 得到值 7。然后 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 2 * 5&lt;/code&gt; 把 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 的值改变了，它现在是 10。所以 &lt;code class=&quot;highlighter-rouge&quot;&gt;c = a&lt;/code&gt; 使得 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; 得到 10。&lt;/p&gt;

&lt;p&gt;对同一个变量多次赋值虽然是可以的，但通常来说这不是一种好的写法，它可能引起程序的混淆，应该尽量避免。只有当变量表示的“意义”相同的时候，你才应该对它重复赋值。&lt;/p&gt;

&lt;h3 id=&quot;编译&quot;&gt;编译&lt;/h3&gt;

&lt;p&gt;一旦引入了变量，我们就可以不用复合表达式。因为你可以把任意复杂的复合表达式拆开成“单操作算术表达式”（像 4 + 3 这样的），使用一些变量记住中间结果，一步一步算下去，得到最后的结果。&lt;/p&gt;

&lt;p&gt;举一个复杂点的例子，也就是这一节最开头的那个表达式：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它可以被转化为一串语句：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后的表达式 &lt;code class=&quot;highlighter-rouge&quot;&gt;e * d&lt;/code&gt;，算出来就是原来的表达式的值。你观察一下，是不是每个操作都非常简单，不包含嵌套的复合表达式？你可以自己验算一下，它确实算出跟原表达式一样的结果。&lt;/p&gt;

&lt;p&gt;在这里，我们自己动手做了“编译器”（compiler）的工作。通常来说，编译器是一种程序，它的任务是把一片代码“翻译”成另外一种等价形式。这里我们没有写编译器，可是我们自己做了编译器的工作。我们手动地把一个嵌套的复合表达式，编译成了一系列的简单算术语句。&lt;/p&gt;

&lt;p&gt;这些语句的结果与原来的表达式完全一致。这种保留原来语义的翻译过程，叫做&lt;strong&gt;编译&lt;/strong&gt;（compile）。&lt;/p&gt;

&lt;p&gt;我们为什么需要编译呢？原因有好几种。我不想在这里做完整的解释，但从这个例子我们可以看到，编译之后我们就不再需要复杂的嵌套表达式了。我们只需要设计很简单的，只会做单操作算术的机器，就可以算出复杂的嵌套的表达式。实际上最后这段代码已经非常接近现代处理器（CPU）的汇编代码（assembly）。我们只需要多加一些转换，它就可以变成机器指令。&lt;/p&gt;

&lt;p&gt;我们暂时不写编译器，因为你还缺少一些必要的知识。这当然也不是编译技术的所有内容，它还包含另外一些东西。但从这一开头，你就已经初步理解了编译器是什么，你只需要在将来加深这种理解。&lt;/p&gt;

&lt;h3 id=&quot;函数&quot;&gt;函数&lt;/h3&gt;

&lt;p&gt;到目前为止，我们做的计算都是在已知的数字之上，而在现实的计算中我们往往有一些未知数。比如我们想要表达一个“风扇控制器”，有了它之后，风扇的转速总是当前气温的两倍。这个“当前气温”就是一个未知数。&lt;/p&gt;

&lt;p&gt;我们的“风扇控制器”必须要有一个“输入”（input），用于得到当前的温度 t，它是一个温度传感器的读数。它还要有一个输出，就是温度的两倍。&lt;/p&gt;

&lt;p&gt;那么我们可以用这样的方式来表达我们的风扇控制器：&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不要把这想成任何一种程序语言，这只是我们自己的表达法。箭头 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt; 的左边表示输入，右边表示输出，够简单吧。&lt;/p&gt;

&lt;p&gt;你可以把 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 想象成从温度传感器出来的一根电线，它连接到风扇控制器上，风扇控制器会把它的输入（t）乘以 2。这个画面像这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/function1.png&quot; width=&quot;400&quot;&gt;&lt;/p&gt;

&lt;p&gt;我们谈论风扇控制器的时候，其实不关心它的输入是哪里来的，输出到哪里去。如果我们把温度传感器和风扇从画面里拿掉，就变成这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/function2.jpg&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;这幅图才是你需要认真理解的函数的计算图。你发现了吗，这幅图画正好对应了之前的风扇控制器的符号表示：&lt;code class=&quot;highlighter-rouge&quot;&gt;t -&amp;gt; t*2&lt;/code&gt;。看到符号就想象出画面，你就得到了符号背后的模型。&lt;/p&gt;

&lt;p&gt;像 &lt;code class=&quot;highlighter-rouge&quot;&gt;t -&amp;gt; t*2&lt;/code&gt; 这样具有未知数作为输入的构造，我们把它叫做函数（function）。其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 这个符号，叫做这个函数的参数。&lt;/p&gt;

&lt;h3 id=&quot;参数变量和电线&quot;&gt;参数，变量和电线&lt;/h3&gt;

&lt;p&gt;你可能发现了，函数的参数和我们之前了解的“变量”是很类似的，它们都是一个符号。之前我们用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;a, b, c, d, e&lt;/code&gt; 现在我们有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;，这些名字我们都是随便起的，只要它们不要重复就好。如果名字重复的话，可能会带来混淆和干扰。&lt;/p&gt;

&lt;p&gt;其实参数和变量这两种概念不只是相似，它们的本质就是一样的。如果你深刻理解它们的相同本质，你的脑子就可以少记忆很多东西，而且它可能帮助你对代码做出一些有趣而有益的转化。在上一节你已经看到，我用“电线”作为比方来帮助你理解参数。你也可以用同样的方法来理解变量。&lt;/p&gt;

&lt;p&gt;比如我们之前的变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它可以被想象成什么样的画面呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/wire.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;我故意把箭头方向画成从右往左，这样它就更像上面的代码。从这个图画里，你也许可以看到变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 和风扇控制器图里的参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;，其实没有任何本质差别。它们都表示一根电线，那根电线进入乘法器，将会被乘以 2，然后输出。如果你把这些都看成是电路，那么变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 和参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 都代表一根电线而已。&lt;/p&gt;

&lt;p&gt;然后你还发现一个现象，那就是你可以把 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 这个名字换成任何其它名字（比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;），而这幅图不会产生实质的改变。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/rename.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;这说明什么问题呢？这说明以下的代码（把 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 换成了 &lt;code class=&quot;highlighter-rouge&quot;&gt;b）&lt;/code&gt;跟之前的是等价的：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;根据几乎一样的电线命名变化，你也可以对之前的函数得到一样的结论：&lt;code class=&quot;highlighter-rouge&quot;&gt;t -&amp;gt; t*2&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;u -&amp;gt; u*2&lt;/code&gt;，和 &lt;code class=&quot;highlighter-rouge&quot;&gt;x -&amp;gt; x*2&lt;/code&gt; 都是一回事。&lt;/p&gt;

&lt;p&gt;名字是很重要的东西，但它们具体叫什么，对于机器并没有实质的意义，只要它们不要相互混淆就可以。但名字对于人是很重要的，因为人脑没有机器那么精确。不好的变量和参数名会导致代码难以理解，引起程序员的混乱和错误。所以通常说来，你需要给变量和参数起好的名字。&lt;/p&gt;

&lt;p&gt;什么样的名字好呢？我会在后面集中讲解。&lt;/p&gt;

&lt;h3 id=&quot;有名字的函数&quot;&gt;有名字的函数&lt;/h3&gt;

&lt;p&gt;既然变量可以代表“值”，那么一个自然的想法，就是让变量代表函数。所以就像我们可以写&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们似乎也应该可以写&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对的，你可以这么做。&lt;code class=&quot;highlighter-rouge&quot;&gt;f = t-&amp;gt;t*2&lt;/code&gt; 还有一个更加传统的写法，就像数学里的函数写法：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;请仔细观察 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 的位置变化。我们在函数名字的右边写一对括号，在里面放上参数的名字。&lt;/p&gt;

&lt;p&gt;注意，你不可以只写&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;你必须明确的指出函数的参数是什么，否则你就不会明白函数定义里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 是什么东西。明确指出 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 是一个“输入”，你才会知道它是函数的输入，是一个未知数，&lt;strong&gt;而不是在函数外面定义的其它变量&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这个看似简单的道理，很多数学家都不明白，所以他们经常这样写书：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有一个函数 y = x*2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是错误的，因为他没有明确指出“&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; 是函数 y 的参数”。如果这句话之前他们又定义过 &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;，你就会疑惑这是不是之前那个 &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;。很多人就是因为这些糊里糊涂的写法而看不懂数学书。这不怪他们，只怪数学家自己对于语言不严谨。&lt;/p&gt;

&lt;h3 id=&quot;函数调用&quot;&gt;函数调用&lt;/h3&gt;

&lt;p&gt;有了函数，我们可以给它起名字，可是我们怎么使用它的值呢？&lt;/p&gt;

&lt;p&gt;由于函数里面有未知数（参数），所以你必须告诉它这些未知数，它里面的代码才会执行，给你结果。比如之前的风扇控制器函数&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它需要一个温度作为输入，才会给你一个输出。于是你就这样给它一个输入：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;你把输入写在函数名字后面的括号里。那么你就会得到输出：4。也就是说 &lt;code class=&quot;highlighter-rouge&quot;&gt;f(2)&lt;/code&gt; 的值是 4。&lt;/p&gt;

&lt;p&gt;如果你没有调用一个函数，函数体是不会被执行的。因为它不知道未知数是什么，所以什么事也做不了。那么我们定义函数的时候，比如&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当看到这个定义的时候，机器应该做什么呢？它只是记录下：有这么一个函数，它的参数是 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;，它需要计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;t*2&lt;/code&gt;，它的名字叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;。但是机器不会立即计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;t*2&lt;/code&gt;，因为它不知道 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 是多少。&lt;/p&gt;

&lt;h3 id=&quot;分支&quot;&gt;分支&lt;/h3&gt;

&lt;p&gt;直到现在，我们的代码都是从头到尾，闷头闷脑地执行，不问任何问题。我们缺少一种“问问题”的方法。比如，如果我想表达这样一个“食物选择器”：如果气温低于 22 度，就返回 “hotpot” 表示今天吃火锅，否则返回 “ice cream” 表示今天吃冰激凌。&lt;/p&gt;

&lt;p&gt;我们可以把它图示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/csbook-images/branch.png&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;中间这种判断结构叫做“分支”（branching），它一般用菱形表示。为什么叫分支呢？你想象一下，代码就像一条小溪，平时它沿着一条路线流淌。当它遇到一个棱角分明的大石头，就分成两个支流，分开流淌。&lt;/p&gt;

&lt;p&gt;我们的判断条件 &lt;code class=&quot;highlighter-rouge&quot;&gt;t &amp;lt; 22&lt;/code&gt; 就像一块大石头，我们的“代码流”碰到它就会分开成两支，分别做不同的事情。跟溪流不同的是，这种分支不是随机的，而是根据条件来决定，而且分支之后只有一支继续执行，而另外一边不会被执行。&lt;/p&gt;

&lt;p&gt;我们现在看到的都是图形化表示的模型，为了书写方便，现在我们要从符号的层面来表示这个模型。我们需要一种符号表示法来表达分支，我们把它叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;（如果）。我们的饮料选择器代码可以这样写：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
     &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;&quot;hotpot&quot;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; 
     &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;&quot;ice cream&quot;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它是一个函数，输入是一个温度。&lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 后面的括号里放我们的判断条件。后面接着条件成立时执行的代码块，然后是一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt;，然后是条件不成立时执行的代码。它说：如果温度低于 22 度，我们就吃火锅，否则就吃冰激凌。&lt;/p&gt;

&lt;p&gt;其中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; 是一个特殊的符号，它表示“否则”。看起来不知道为什么 &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; 要在那里？对的，它只是一个装饰品。我们已经有足够的表达力来分辨两个分支，不过有了 &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; 似乎更加好看一些。很多语言里面都有 else 这个标记词在那里，所以我也把它放在那里。&lt;/p&gt;

&lt;p&gt;这只是一个最简单的例子，其实那两个代码块里面不止可以写一条语句。你可以有任意多的语句，就像这样：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;hotpot&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ice cream&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码和之前是等价的，你知道为什么吗？&lt;/p&gt;

&lt;h3 id=&quot;字符串&quot;&gt;字符串&lt;/h3&gt;

&lt;p&gt;上面一节出现了一种我们之前没见过的东西，我为了简洁而没有介绍它。这两个分支的结果，也就是加上引号的 “hotpot” 和 “ice cream”，它们并不是数字，也不是其它语言构造，而是一种跟数字处于几乎同等地位的“数据类型”，叫做&lt;strong&gt;字符串&lt;/strong&gt;（string）。字符串是我们在计算机里面表示人类语言的基本数据类型。&lt;/p&gt;

&lt;p&gt;关于字符串，在这里我不想讲述更加细节的内容，我把对它的各种操作留到以后再讲，因为虽然字符串对于应用程序很重要，它却并不是计算机科学最关键最本质的内容。&lt;/p&gt;

&lt;p&gt;很多计算机书籍一开头就讲很多对字符串的操作，导致初学者费很大功夫去做很多打印字符串的练习，结果几个星期之后还没学到“函数”之类最根本的概念。这是非常可惜的。&lt;/p&gt;

&lt;h3 id=&quot;布尔值&quot;&gt;布尔值&lt;/h3&gt;

&lt;p&gt;我们之前的 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 语句的条件 &lt;code class=&quot;highlighter-rouge&quot;&gt;t &amp;lt; 22&lt;/code&gt; 其实也是一个表达式，它叫做“布尔表达式”。你可以把小于号 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 看成是跟加法一类的“操作符”。它的输入是两个数值，输出是一个“布尔值”。什么是布尔值呢？布尔值只有两个：true 和 false，也就是“真”和“假”。&lt;/p&gt;

&lt;p&gt;举个例子，如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 的值是 15，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;t &amp;lt; 22&lt;/code&gt; 是成立的，那么它的值就是 true。如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; 的值是 23，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;t &amp;lt; 22&lt;/code&gt; 就不成立，那么它的值就是 false。是不是很好理解呢？&lt;/p&gt;

&lt;p&gt;我们为什么需要“布尔值”这种东西呢？因为它的存在可以简化我们的思维。对于布尔值也有一些操作，这个我也不在这一章赘述，放到以后细讲。&lt;/p&gt;

&lt;h3 id=&quot;计算的要素&quot;&gt;计算的要素&lt;/h3&gt;

&lt;p&gt;好了，现在你已经掌握了计算机科学的几乎所有基本要素。每一个编程语言都包括这些构造：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;基础的数值。比如整数，字符串，布尔值等。&lt;/li&gt;
  &lt;li&gt;表达式。包括基本的算术表达式，嵌套的表达式。&lt;/li&gt;
  &lt;li&gt;变量和赋值语句。&lt;/li&gt;
  &lt;li&gt;分支语句。&lt;/li&gt;
  &lt;li&gt;函数和函数调用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;你也许可以感觉到，我是把这些构造按照“从小到大”的顺序排列的。这也许可以帮助你的理解。&lt;/p&gt;

&lt;p&gt;现在你可以回想一下你对它们的印象。每当学习一种新的语言或者系统，你只需要在里面找到对应的构造，而不需要从头学习。这就是掌握所有程序语言的秘诀。这就像学开车一样，一旦你掌握了油门，刹车，换挡器，方向盘，速度表的功能和用法，你就学会了开所有的汽车，不管它是什么型号的汽车。&lt;/p&gt;

&lt;p&gt;我们在这一章不仅理解了这些要素，而且为它们定义了一种我们自己的“语言”。显然这个语言只能在我们的头脑里运行，因为我们没有实现这个语言的系统。在后面的章节，我会逐渐的把我们这种语言映射到现有的多种语言里面，然后你就能掌握这些语言了。&lt;/p&gt;

&lt;p&gt;但是请不要以为掌握了语言就学会了编程或者学会了计算机科学。掌握语言就像学会了各种汽车部件的工作原理。几分钟之内，初学者就能让车子移动，转弯，停止。可是完了之后你还需要学习交通规则，你需要许许多多的实战练习和经验，掌握各种复杂情况下的策略，才能成为一个合格的驾驶员。如果你想成为赛车手，那就还需要很多倍的努力。&lt;/p&gt;

&lt;p&gt;但是请不要被我这些话吓到了，你没有那么多的竞争者。现在的情况是，世界上就没有很多合格的计算机科学驾驶员，更不要说把车开得流畅的赛车手。绝大部分的“程序员”连最基本的引擎，油门，刹车，方向盘的工作原理都不明白，思维方式就不对，所以根本没法独自上路，一上路就出车祸。很多人把过错归结在自己的车身上，以为换一辆车马上就能成为好的驾驶员。这是一种世界范围的计算机教育的失败。&lt;/p&gt;

&lt;p&gt;在后面的章节，我会引导你成为一个合格的驾驶员，随便拿一辆车就能开好。&lt;/p&gt;

&lt;h3 id=&quot;什么是计算&quot;&gt;什么是计算&lt;/h3&gt;

&lt;p&gt;现在你掌握了计算所需要的基本元素，可是什么是计算呢？我好像仍然没有告诉你。这是一个很哲学的问题，不同的人可能会告诉你不同的结果。我试图从最广义的角度来告诉你这个问题的答案。&lt;/p&gt;

&lt;p&gt;当你小时候用手指算 &lt;code class=&quot;highlighter-rouge&quot;&gt;4+3&lt;/code&gt;，那是计算。如果后来你学会了打算盘，你用算盘算 4+3，那也是计算。后来你从我这里学到了表达式，变量，函数，调用，分支语句…… 在每一新的构造加入的过程中，你都在了解不同的计算。&lt;/p&gt;

&lt;p&gt;所以从最广义来讲，计算就是“机械化的信息处理”。所谓机械化，你可以用手指算，可以用算盘，可以用计算器，或者计算机。这些机器里面可以有代码，也可以没有代码，全是电子线路，甚至可以是生物活动或者化学反应。不同的机器也可以有不同的计算功能，不同的速度和性能……&lt;/p&gt;

&lt;p&gt;有这么多种计算的事实不免让人困惑，总害怕少了点什么，其实你可以安心。如果你掌握了上一节的“计算要素”，那么你就掌握了几乎所有类型的计算系统所需要的东西。你在后面所需要做的只是加深这种理解，并且把它“对应”到现实世界遇到的各种计算机器里面。&lt;/p&gt;

&lt;p&gt;为什么你可以相信计算机科学的精华就只有这些呢？因为计算就是处理信息，信息有它诞生的位置（输入设备，固定数值），它传输的方式（赋值，函数调用，返回值），它被查看的地方（分支）。你想不出对于信息还有什么其它的操作，所以你就很安心的相信了，这就是计算机科学这种“棋类游戏”的全部规则。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-04-13-csbook-chapter1</guid>
<pubDate>Fri, 13 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>中国人的鉴赏力</title>
<link>https://henix.github.io/feeds/yinwang/2018-03-29-appreciation.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/03/29/appreciation&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;中国人的鉴赏力&lt;/h2&gt;
            &lt;p&gt;大部分的中国人都不会鉴别物品的好坏和价值，所以他们只能以“价格”的高低来做判断。你经常听中国人说“穿着一万块一件的衣服”，“开着一百万一辆的车”，“住着二十万一平米的房子”，就是这个原因。他们不懂得这个东西好在哪，只知道它是多少钱买的。他们仿佛认为一万块钱的东西和一万块钱的东西，都是一样的。销售人员最喜欢这种人。&lt;/p&gt;

&lt;p&gt;这种现象跟中国人从小上学就只认数字有关系，他们从小就被当成一个数字。考试成绩是一个数字，期末排名是一个数字。还有竞赛名次啊，金牌总数啊…… 大部分中国人知道数字，但却不知道数字背后的意义。他们不明白，有些东西是不能转化为数字进行比较的。比如我跟有些人说我今天跑步了，他们会问我跑了多少公里，多少圈。我回答：不知道！我只知道沿途的风景很美，我跑了很开心。&lt;/p&gt;

&lt;p&gt;所以一个很简单的愚弄中国人的手段，就是把很普通的东西卖得离谱的贵。只要你卖得贵，就会有人觉得它是好东西，或者觉得买了可以显得自己有钱，于是就会买来招摇过市。买不起的人呢，看到别人有了这个东西，就会产生艳羡的心理，心想等自己有钱就一定要买。这样不知不觉的，他们就把自己的地位降到了东西之下，被狡猾的商家给控制了。&lt;/p&gt;

&lt;p&gt;这就是虚荣心作怪。恐惧和虚荣，是世界上最好卖的两种东西。关于如何卖恐惧，我在之前一篇文章『&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/06/28/yangsheng&quot;&gt;养生节目的危害&lt;/a&gt;』已经讲过了。从小扶植小朋友的虚荣心，等他们长大了，就哭着闹着要买你的东西，逼着父母或者男朋友送那个东西。&lt;/p&gt;

&lt;p&gt;很多中国人花着“土豪价钱”，买着其实不值钱的商品，还顶礼膜拜，受宠若惊的样子。他们不是物品的主人，而是它们的仆人，他们的地位是低于这些物品的。很多商店店员也是那种心理，他们觉得你走进我们这“高大上”的品牌店，就是来膜拜我们的东西的，所以做出一副“你买得起吗”的神情，跟你说“这个很贵”。你要是跟她说这个卖得太贵了，不值那个钱，她就觉得你是买不起。直到客人不爽走了，她也没认出别人身上穿的就是他们家牌子的衣服 :p&lt;/p&gt;

&lt;p&gt;一百年前马克吐温写的『百万英镑』，展现了那个时候英国的情况，跟现在的中国非常类似。&lt;/p&gt;

&lt;p&gt;中国人最爱买宝马车，LV，爱马仕包包，原因很简单：因为它们贵。没有品位，没有鉴别欣赏能力，就只知道一个“贵”字。管它多俗气多丑呢，还搭配不好，贵就是好。LV 还有一个特点，那就是他们家的东西上面都密密麻麻印着“LV”字样，所以拿出去大家都知道你有 LV！可是我每次看到 LV 一类的东西，就想起这个画面 :p&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/tyvek.jpg&quot; width=&quot;300&quot;&gt;&lt;/p&gt;

&lt;p&gt;女人爱 LV，男人爱宝马。宝马曾经是中国男人装逼泡妹的神器。宝马车难开的一塌糊涂做工又糙，但女人只认得宝马啊。不过后来宝马也有点烂大街了，显示不出差距，所以现在他们的新宠是 Tesla。每次看到开 Tesla 的人，几乎都是戴着眼镜，刚赚了点钱，内心有强烈装逼需求的呆子。我认识的气质优雅一点的人，几乎没有人会选择 Tesla。&lt;/p&gt;

&lt;p&gt;只要你骂 Tesla，他们就会说你穷，买不起，所以吃不到葡萄说葡萄酸。可是我骂 Tesla 完全是出于社会责任感：Tesla 的车子威胁了公共安全。整死车主也就算了，可是这东西会伤到其他人，所以匹夫有责来谴责一下 Tesla。你可以把这车卖任意高的价钱，可是它仍然不安全，而且设计得&lt;a href=&quot;http://www.yinwang.org/blog-cn/2015/12/12/tesla-model-s&quot;&gt;一塌&lt;/a&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2015/12/21/tesla-model-x&quot;&gt;糊涂&lt;/a&gt;，用料也不好。多次出事起火，然后吹嘘电池现在用了多么严密的弹道导弹材料保护，结果呢，照样爆炸。&lt;/p&gt;

&lt;p&gt;从没见过有汽车撞了烧成那样，消防队都没办法灭火。整个车头都烧掉消失了，如果人在里面就毁尸灭迹了，怎么出的事证据都找不到。对于湾区交通性命攸关的 101 公路，因为一辆 Tesla 着火爆炸，全部车道被封长达 6 小时。要知道这条路要是塞了，你跑长途基本没有其他路可以绕的。这是我从来没遇到过的，其它车怎么撞也会有一条道可以走的。我在路上见过各种车祸，大型卡车着火，最多一个小时就走走停停过去了，因为还有车道可以走。谁来赔这些人的损失？真像是一颗颗导弹跑在公路上，一碰就爆。&lt;/p&gt;

&lt;p&gt;从来没有汽车公司把“驾驶辅助系统”（driver assistant）吹嘘成“自动驾驶系统”（autonomous driving），Tesla 大言不惭开了这个先河。如此不负责的公司，最后还要把责任都推到用户身上。我认识一个 Tesla 的修车技工，他自己也开了个修车铺，修其他牌子的车。他说在 Tesla 工作特别辛苦，因为这车毛病太多了，感觉公司里的工程师都不知道他们自己在干什么，有些东西根本就不该那样设计，容易出毛病。一个修车工都知道的事情，设计师工程师却不懂……&lt;/p&gt;

&lt;p&gt;所以呢，Tesla 这颗葡萄是真的酸，都烂掉了还敢卖那么贵。你还不能骂它，否则一群脑残粉来攻击你，说你穷买不起。你见过我骂奔驰吗？我骂过法拉利，劳斯莱斯吗？出于一个负责的工程师的态度，我尊敬他们。我尊敬他们是因为他们的工匠精神，制造出一些世界上最优美，最可靠的机器，而不是因为它们的价格昂贵。&lt;/p&gt;

&lt;p&gt;大部分的国人要什么时候才能意识到，并不是贵的就好。能忽略价格看到物品的品质，实现不带有虚荣心的鉴赏，是很重要的能力。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-03-29-appreciation</guid>
<pubDate>Thu, 29 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>扶门的礼仪</title>
<link>https://henix.github.io/feeds/yinwang/2018-03-27-door-etiquette.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/03/27/door-etiquette&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;扶门的礼仪&lt;/h2&gt;
            &lt;p&gt;世界上的很多事情，不是你自己有好意就一定有好的效果，你还必须知道对方的感受，不然你也许会让对方感觉很累。今天我就来讲讲一个看似简单的礼仪：扶门。很多中国人到了国外，特别是美国，看到美国人进了公共场所的大门之后，为了防止门回弹关上，都会礼貌地为后面的人扶住门，等他们接住门才放手。甚至有些先把门拉开，站在门口扶住门，让后面的人都进去了，自己才进去。&lt;/p&gt;

&lt;p&gt;中国人看到美国人这么做，觉得扶门是文明的象征，所以也开始模仿。哪知道，这里面的学问其实比他们想象的要复杂一些。所以你就发现，某些人经常为“谁先进门”这个事情让来让去的，又尴尬又累，那程度胜似吃了饭抢着买单 :p 其中的一些道理，其实很多美国人都不懂。这些道理可能很难在其它地方看到，所以我把它们总结一下。&lt;/p&gt;

&lt;p&gt;显然这些主动为后面人扶门的人，比起那些完全不考虑别人，甚至使劲摔门的人来说，已经很好了。可是我今天要说的不是这个，而是更加深入细致的礼仪。美国作为一个基本文明的国家，在这方面做得已经不错了，可是相对某些欧洲国家还是稍显落后。很多美国人并不懂得完整合理的礼仪规范，只是模仿欧洲的“绅士风度”，所以有些时候做得其实不大对。所以呢，看到美国人那么做，你也不一定完全模仿他们。你应该知道这些礼仪背后的原理，而不是照抄表面现象。&lt;/p&gt;

&lt;p&gt;扶门也许不是你想象的那么简单，无条件扶着门，显示好意就好。很多人懂得应该为后面的人扶门，可是他们忽视了扶门的时机问题，还有人之间的关系问题。正确的作法应该是这样，分好几种情况。&lt;/p&gt;

&lt;p&gt;情况 1：陌生人。进了一扇会自动弹回关上的门，如果回头看到有陌生人紧跟在后面，只有两三步远的地方，就扶住门让他进来，否则就自然把门放开，自己进去就是。原因是，如果后面的人离你还很远，扶住门会迫使他加快脚步。后面的人很可能希望按照自己的节奏走路，可是看到你扶住门等他，不好意思让你久等，或者觉得你一直回头看着他挺尴尬，所以他不得不加快脚步。如果他刚吃了饭不想那么快步走，或者他是在上楼梯，就会更加不舒服。所以呢，出于对他人真正周全的考虑，你不应该扶住门时间太久，迫使后面的人加快脚步。如果你发现自己判断错误，扶住门太久了，你还是可以补救。你只需要微笑着朝后面的人挥挥手，然后放开门自己进去。他会理解你为什么放手，因为他也不会指望你扶太久。这一条原则经常被美国人忽视，遇到扶门太久太早的人，经常感觉挺累。如果你遇到为你扶门太久的人，你也可以朝他挥挥手，示意他先走。&lt;/p&gt;

&lt;p&gt;情况 2：认识的人或者朋友。当然对于认识的人或者朋友同事，第一条就不一定需要严格遵守了。因为后面那个人认识你而且关系不错，所以你可以扶住门比较长时间。他大概不会因为你在那等他而加快脚步，你甚至可以靠着门跟他说句话。当然如果实在太远了，你也同样可以挥挥手，放手进去，别人不会介意这个。&lt;/p&gt;

&lt;p&gt;情况 3：陌生女性。如果身后紧跟的是陌生女性，你可以拉开门，让她先进去，然后自己才进去。你也可以自己先进去，然后把门帮她扶一下。没有规则要你一定让女性先进去，或者扶住门太久。普通的女性完全有能力拉开一扇门，这个不需要你特别照顾。&lt;/p&gt;

&lt;p&gt;情况 4：男性。如果身后紧跟的是男性，不管你是否认识他，你最好自己先进去，然后帮他扶一下门。最好不要请他先走，否则你就会制造“让来让去”的尴尬局面！如果你拉开门让一个男性先进去，自己才进去，会造成这位男性的尴尬。凭什么我需要让另外一个男性，甚至是女性为我开门，让我先走呢？我有哪一点显示出我身体虚弱，需要你帮助呢？他会这样想。他会认为自己的男性气质受到了某种打击，或者感到尴尬，感到欠了你什么。当然，如果你是酒店的礼宾人员，为客人开门让他们先走，不论男女都是天经地义的。所以当男性遇到另一个男性或者女性（非礼宾人员）给他开门，他一般会示意对方先走，可是扶门的这个人却又坚持要他先走，最后就出现了僵持的尴尬局面，跟很多中国人吃了饭抢着买单一样讨厌。所以你开了门，就不要请身后的男性先走，就不会有这回事了。如果开门的人在多次反复之后一定要你先走，而且多次进门都那样，那么请你今后小心这个人了，他似乎很想要你感觉欠他什么 :p&lt;/p&gt;

&lt;p&gt;情况 5：两手被占用的人。两手抱着箱子，或者推着自行车的人，如果跟在你身后，他们需要特殊照顾。你应该扶住门，让他们先走，然后自己才走。这个规则不论男女老幼，不论跟你什么关系都一样适用，因为他们腾不出手来开门，也没有手可以接住你放开的门。&lt;/p&gt;

&lt;p&gt;情况 6：一个推着婴儿车的人。如果是一个人推着一个婴儿车，这个没什么好说的，一定要拉开门，让他先走，确认婴儿车已经进去了，自己才进去。还有一种情况是一家人，其中一个推着婴儿车。因为有人可以开门，这个就不需要你特别照顾了，按情况1处理。&lt;/p&gt;

&lt;p&gt;情况 7：一大群普通关系的人（或者同事）在你后面。如果你身后不是一个人，而是一大群人，而且这群人不是亲密的朋友，只是普通的同学或者同事关系，那么请你先进去，然后帮后面第一个人扶住门，等他接手门之后就放手。他会为后面的人扶一下，这样接力下去。不要站在门口，让一大群人都进去，然后自己才进去。有些人喜欢这样做，以为这样显得很“绅士”，但我觉得这样很装很做作。我见过两三个喜欢扶住门让所有人进去的人，在工作中都是很虚伪的人。他们在工作中可以暗地里捅你几刀，进门的时候却演得像个大好人。让大家进去他才走，得意洋洋的样子，好像每个人走过那道门都欠了他一笔账似的。真的，你没有必要那样做，那种感觉非常的不自然。而且你扶住门，看着后面每个人走向你，可能会让某些人尴尬。其中某些人可能不大喜欢你，不想跟你近距离对视，觉得你在借机打量他们。有些女性甚至会觉得你长时间盯着她们走进去，是一种骚扰。所以如果很多人一起，最好还是你自己先进去，不要站在门口给大家扶门。&lt;/p&gt;

&lt;p&gt;情况 8：跟女性朋友一起。如果是跟熟悉的女性朋友或者女朋友一起，你最好拉开门，让女性朋友先进去，然后自己马上跟进去。注意，跟进去的时机是“马上”。如果她身后紧跟着陌生人，请紧跟你的女性朋友身后进门，不要让陌生人夹到你们中间去。有些刚懂得扶门的男士不知道这个道理。他拉开门，让女性朋友进去了，结果看到她身后又跟着其他陌生人，所以他继续扶着门，让其他人先走。结果门外的人一个个都进去了，他还在那里扶着门。女性朋友在里面，都不知道他哪里去了 :p 这种男士应该明白的是，在这个时候你应该跟女性朋友待在一起，而不应该让陌生人隔在你们之间。没有人会因为你先走而责怪你，他们反而会觉得你让他们先走很奇怪，因为你应该首先照顾自己的朋友。这个对待女性朋友的开门原则，我是从 &lt;a href=&quot;https://en.wikipedia.org/wiki/Emily_Post&quot;&gt;Emily Post&lt;/a&gt; 经典的『Etiquette』（礼仪）一书看到的。&lt;/p&gt;

&lt;p&gt;情况 9：进门马上需要排队的地方。如果你是去邮局或者需要排队下单的咖啡店，除非后面的人真有困难，最好不要拉开门让后面的陌生人先走，即使后面是女性也一样。你应该自己先进去，然后稍微扶一下门。根据先来先服务的原则，你应该排在后面的人前面，不管后面是男是女。如果你拉门让别人先走了，他们自然就排到你前面去了。如果这个人特别懂礼仪而且考虑周到，她可能会让你到前面去排队。但如果你在一个不是每个人都那么懂的地方，她很可能意识不到你应该排在她前面。这样你显示了好意反而吃亏，这会打击你以后继续有礼貌的动机。&lt;/p&gt;

&lt;p&gt;这可能是世界上最全面的关于扶门礼仪的总结，是一个计算机科学家不经常谈论的事情 =) 这些原则看似复杂，其实不需要你死记硬背，只要你看了有印象，就会从实际经验中体会到，不断改进。可惜的是很多人都不知道这里面的道理，也没注意到。这就是我为什么把它们写出来。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-03-27-door-etiquette</guid>
<pubDate>Tue, 27 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>解谜计算机科学（前言）</title>
<link>https://henix.github.io/feeds/yinwang/2018-03-21-csbook-preface.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/03/21/csbook-preface&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;解谜计算机科学（前言）&lt;/h2&gt;
            &lt;p&gt;计算机科学直到今天仍然是一个谜。它简单而美丽的精华，被压在沉重的历史包袱和功利诱惑之下。纷繁复杂的 IT 技术充斥着各种浮夸和忽悠，变成一本本大部头“圣经”，让人不知所措，头脑发涨，让外行尤其是女性望而却步。她们说，学计算机能赚钱，可是计算机知识淘汰速度太快，需要不断学习才能跟上，计算机工作枯燥，伤眼睛，伤皮肤，老得快！去看看各位计算机界前辈的照片，你会发现她们说的好像是对的 :)&lt;/p&gt;

&lt;p&gt;“IT 男”和“极客”的苦逼名声，来源于这个领域创造者们的自大和虚伪。他们认为自己是天才，能够理解复杂的理论，所以他们喜欢把简单的问题搞复杂，然后告诉你“只有天才才能理解这种简单”。最后这种自大蔓延到整个领域。计算机科学虽然名字叫“科学”，但它的从业人员在很大程度上是宗教化的。不同信仰的教徒们盲目轻信，跟风拍马，互相鄙视，甚至掀起圣战。进入这个领域面临的，不仅是高度近视，不修边幅的同事，而且很多还很自大，喜欢显示自己聪明，觉得自己了不起。他们所谓的“聪明”，也就是能折腾那些纷繁复杂的理论和代码。发表论文来显示自己解决了一个问题，但别人看了仍然摸不着头脑。这种不健康的心理，进入了计算机科学的基因，完全违背了科学的精神。&lt;/p&gt;

&lt;p&gt;在这种情况下产生出来的所谓“知识”，当然是淘汰速度很快的，因为他们只给了你浮于表面的东西。IT 业的很多知识就像妈妈告诉你，我把勺子放在这个抽屉里了，你记住啊！第二天她又把勺子换了一个地方，要你重新“学习”。这叫知识吗？他们把精华的东西牢牢地锁了起来，只把衍生出来的副产品给其他人。拿到这些副产品的人一知半解，又在上面加上一些乱七八糟的东西，然后转手倒卖给更下一层的学生。这样几层转手之后，你拿到的东西就只能凑合用了，不能用于产生新的想法，甚至使用中有问题还不能解决。这就是为什么很多码工折腾来折腾去，代码也只是碰巧能工作而已。没有理解原理，就成为了“知识”的奴隶。看不准方向，在错误的道路上越走越远。&lt;/p&gt;

&lt;p&gt;爱因斯坦说：“如果你不能把一个问题跟六岁小孩解释清楚，那你并不真的理解它。” 这句话打了计算机前辈们的耳光。计算机界至今没有出现一本像物理界的『费曼讲义』那样负责任的教材。没有人从日常生活解释清楚那些基本的理论和技术是怎么回事。一方面是因为很多人并不真懂，只会照本宣科，拿别人的代码来拼凑折腾。另外一方面，很多懂了的人为了自己的私利，想掩盖这些简单的精华，故意把事情搞复杂。&lt;/p&gt;

&lt;p&gt;我写这本书，就是为了弥补计算机业界这一空缺，改变行业的现状。它将吸引新鲜干净的血液进入这个行业，并且赋予他们力量。它也可以刷新内行人员的头脑，让他们重新理解和审视已有的知识。这样也许我们能冲破这个行业的重重迷雾，让它变得诚实，获得科学的精神，成为像物理一样踏实的学科。&lt;/p&gt;

&lt;p&gt;很多计算机书籍都喜欢从“数学基础”开始，一开头就是长篇累牍的数学公式，定理，证明…… 结果读者还没读完数学基础就倒下睡着了，再也不想打开这本书。所以我不从数学基础开始，而是从最简单的生活常识。在认识发展的过程中，你会自己去创造出所需要的那些数学。&lt;/p&gt;

&lt;p&gt;这本书不要求读者理解高等数学，而只需要幼稚园或者学前班水平的数学：掰手指头算加法，手算多位数加减法。它不要求，也不会试图教会你中学几何，高等数学或者物理学，你不需要那些来理解计算机科学。它不灌输给你死知识，而是从日常生活的经验出发，引导你去“重新发明”它们。最后你不是学会了知识，而是自己创造了它们。只有这样的知识才是属于自己的，才是可靠安心的，不受别人控制，也不会忘记。我讨厌“学习”这个词，因为它基本代表着死记硬背。我不是在教你，你也不是在学习，因为你自己发明了这一切。&lt;/p&gt;

&lt;p&gt;如果有一天，一场灾难毁灭了世界上所有的计算机和电子产品，以及它们的设计文档，我希望看过这本书的人，能够根据他们的日常经验，重新创造出这些东西。对的，这本书不仅是关于编程和软件，它还会告诉你硬件是怎么回事，并且把软件和硬件统一起来。它不只是教会你一种程序语言，而是教会你所有的程序语言，它告诉你如何发明一种语言。它不要你去“记住”计算机里面有哪些东西，而是让你自己发现“需要”它们：晶体管，寄存器，指令，堆栈…… 你会发现虚拟机（VM）到底是什么，指令系统为什么那个样子，怎么创造它们…… 所有这一切，都以掰手指头的幼稚园算术为基础。&lt;/p&gt;

&lt;p&gt;实际上，计算机科学和逻辑学是统一的，你会不知不觉理解很多看似高深的逻辑学，你会看透白胡子逻辑学家爷爷们的把戏。这种理解会为你提供更好的理解数学的工具，所以这本书不仅会帮助你理解计算机科学，而且会帮助你更好的理解数学。理解了数学你就能更好的理解物理。理解了物理，你就能更好的理解所有的科学……&lt;/p&gt;

&lt;p&gt;有人可能怀疑这么浩大的工程，要什么时候才能完成。不会很久的，因为计算机科学最精华的部分，真的没有很多，我掰着手指头都数的出来。剩下来的都是衍生出来的技术，外加自欺欺人和商业炒作。你会掌握精华，识破忽悠和炒作，你可以衍生出自己的技术。即使你决定不进入这个领域，你也会成为一个火眼金睛的投资人，管理者，或者消费者。你不再能被这些“内行”欺骗。为了达到这个目标，你不需要损害自己的视力或者健康，不需要长出鸡窝一样的胡子，不需要成为一个对异性具有排斥力的呆子 ;)&lt;/p&gt;

&lt;p&gt;这本书不是固定不变的，它会不断地完善和发展。有人看我写的东西就是我最大的动力，所以为了使我自己有动力写书，我会采用“快速迭代”的方法。我是一个很懒的人，我不会等书完全写完才发布它，那样我会打瞌睡以至于不能继续，所以我会分章节发布书的内容。每一章发布之后，还会经过成百上千次的修改。每一章的内容，我会在它“基本可读”之后就进行发布，而不会等到它完美。之后我会反复的思考和修改，接受人们的反馈。&lt;/p&gt;

&lt;p&gt;这种做法对早期的读者有益，也有一定的弊端。弊端就在于，由于这些内容随时可能变化和改进，所以早期读者有时候会遇到看不懂的地方，必须之后再次阅读，才能跟上改进的思路。不过这样做也有好处，读者不用等上一年就能读到这本书，而且能跟着我的写作思路去思考，反复琢磨。俗话说，书读百遍，其义自见。他们可以跟我讨论，给我反馈，向我提问。这些都是后期读到完善作品的人无法体验到的。在某种程度上，这些人对问题的理解会更加深刻一些，因为他们被迫去进行独立思考。另外，早早的有了读者，会让我很开心，满怀着爱去做这件事。&lt;/p&gt;

&lt;p&gt;人的短期记忆只能记住七个东西，所以我会努力让这本书简短。每个知识点都不应该长篇大论之后才能理解，而应该是正中要害。当然这篇前言也应该简短，所以前言就到此结束了。&lt;/p&gt;

&lt;p&gt;计算机的世界，就将被你一个人重新发明出来。它的内容没有很多，真的没有很多……&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-03-21-csbook-preface</guid>
<pubDate>Wed, 21 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>CIIA 苹果报告自觉付费模式</title>
<link>https://henix.github.io/feeds/yinwang/2018-03-08-ciia1.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/03/08/ciia1&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;CIIA 苹果报告自觉付费模式&lt;/h2&gt;
            &lt;p&gt;很多人之前购买了我的第一份设计报告，关于苹果 iPhone 的一些设计问题。那份报告采用了付费销售方式，而且价格不便宜。由于我不想再发表设计方面的东西，但希望它能帮助到更多的人，所以现在将这份报告放在这里，进行“自觉付费”的销售，价格也做了大幅度调整。这份报告仍然不是免费的。由于其中涉及到我多年观察得来的结果，其它地方找不到的，所以收取适当的费用是理所应当的。&lt;/p&gt;

&lt;p&gt;自觉付费的原理就像一个水果摊（这次卖的是苹果）。我懒得去守着这个摊子，我就把水果摆在那里，你们吃了之后自己付钱就行。这跟我其他博文的“&lt;strong&gt;自愿&lt;/strong&gt;付费”形式不同。“自愿付费”的意思是，你看了如果不喜欢，或者你根本没看完，那么你可以不付钱。“&lt;strong&gt;自觉&lt;/strong&gt;付费”的意思是，你如果看了内容，那么你就已经“享用了”它，你就应该付钱。如果你不付，就是有道德过错的。如果你不想付钱，就请不要看。&lt;/p&gt;

&lt;p&gt;这就像我摆个“自觉付费”水果摊，你们吃了自己付钱就好，结果你吃了没付钱，这就不好了。你是否付费，将会影响到我的水果摊是否可以继续营业。我的博客含有代码，会统计这段时间的阅读人数。我会根据阅读人数与付费的比例，来推断是否有很多人没付钱。如果我发现付费的比例太小，我会适当调整作法。&lt;/p&gt;

&lt;p&gt;在我的书第一章还没完成之前，我想先把这份报告放在这里，作为“自觉付费”模式的一种实验。效果不错的话，我的 CS 教材会采用同样的作法。&lt;/p&gt;

&lt;p&gt;虽然在&lt;a href=&quot;http://www.yinwang.org/blog-cn/2017/09/25/apple&quot;&gt;预告片&lt;/a&gt;里，我批评了很多人对于苹果公司的膜拜态度，但这份报告的语气是建设性的。它的目的是帮助广大设计人员，技术人员意识到设计是一个重要的问题，没有任何公司的设计是完美的，我们应该不断地改善产品。我仍然喜欢苹果产品的许多设计，而且会继续使用苹果的产品。如果苹果公司的设计人员需要这份文档，价格也是一样的，我不宰客 :p&lt;/p&gt;

&lt;p&gt;如果你感兴趣的话，可以在这里下载这份文档。由于其中有比较多高清晰度的图片，虽然经过最大限度的压缩，文档的大小仍然是 5M 左右，所以请耐心等待下载完毕。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/resources/ciia1.pdf&quot;&gt;&lt;img src=&quot;http://www.yinwang.org/images/ciia1-icon.jpg&quot; width=&quot;240&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;报告的第一章是免费的。如果你想继续阅读后面的章节，可以扫码付费购买之后继续。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/wechat-ciia1.jpg&quot; width=&quot;240&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/alipay-ciia1.jpg&quot; width=&quot;240&quot;&gt;&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-03-08-ciia1</guid>
<pubDate>Thu, 08 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>关于写书</title>
<link>https://henix.github.io/feeds/yinwang/2018-03-05-book.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/03/05/book&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;关于写书&lt;/h2&gt;
            &lt;p&gt;写书计划已经进入策划阶段。这篇文章是因为之前那篇的最后部分的一些想法越改越长，开始具有独立的价值，所以截取下来放在这里。其中加入的一些想法，也许可以帮助某些人跳出他们心里的“坎”。我觉得这是很有意义的，这些内容也许会成为我的另外一本书的一部分，这本书的名字也许可以叫『怎样解放你自己』。&lt;/p&gt;

&lt;h3 id=&quot;动机&quot;&gt;动机&lt;/h3&gt;

&lt;p&gt;说了挺久要写书，一直没有动力。一方面是由于我觉得国内的出版社都不大靠谱，而且他们出的很多书水平太低，处于“培训班”级别，尽是教流水线工人的死知识，这有损我的品牌形象。另外很大一部分原因，是因为我写东西都是一针见血，容易懂，而且不会留一手。我很怕一不小心说太明白，就让关键的知识点落到道德水平低的人手里，到处装模作样吹牛逼，还反过来说我是吹牛逼。我也许顾虑太多了。其实我只需要提供我愿意提供的知识，而保留我不愿意提供的就行。另外，这些入门知识被广大群众了解，显然对善良的人有好处，而对吹牛逼的人们不是什么好事。这些知识将会帮助他们识破骗局，成为他们对抗这些虚假权威的武器。所以，我真的决定要写书了。&lt;/p&gt;

&lt;p&gt;有些人虽然支持我，可是他们误解了我写书的目的。他们说我写书是要“证明自己”或者“实现自己的价值”，我觉得这些都是有失尊重的说法。他们说那些话的原因，是因为他们自己的觉悟没到位，所以没能理解我的境界和地位。只有地位低的人才需要向别人证明自己，才需要拿“硅谷”，“Google”一类的招牌来撑起自己的自信，才需要写一些“硅谷回忆录”来让别人瞧得起自己。我不一样的。由于我的地位，世界上没有任何人有资格来接受我的“证明”，所以我不需要向任何人证明自己，当然我更不需要向那些说我闲话的人，被洗脑的蠢人证明自己。&lt;/p&gt;

&lt;p&gt;在这个世界上总是有人对你说，你如果真那么厉害，那你高考考个状元来给我们证明一下啊！等你考了状元，他们又会说状元不算什么，你要是能在 ACM 竞赛拿金牌，才是真的厉害！等你拼得头破血流达到了那些目标，他们又说，你要有影响力的开源代码，那才叫厉害。等你有了开源项目，他们拿你的代码去赚了钱，反而对你各种吹毛求疵，贬低价值，好像那代码是他们也能写出来的一样。现在他们改口说，你在开源社区写点代码算什么啊，你要能进 Google，那才是真的厉害！等你进了 Google，他们又换了标准，你要是能修好我们这堆 JS 代码里的 bug，那才叫真的厉害呢！等你成天加班以为熬出头了，出了 Google，他们又说，那么多人都是 Google 出来的，你算什么啊？你要创业，造出 IPO 的独角兽公司，那才是真的厉害……&lt;/p&gt;

&lt;p&gt;于是你就走上了不归路，你的每一次行动都是为了让别人觉得你厉害。你不得不打着“硅谷牛人”的牌子，显示着你的 Google 经历，你的 ACM 奖牌。可是你仍然没有发现，那些要求你给他们“证明”的人，他们真的有资格评价你吗？他们只是一堆虫子而已！他们通过你的虚荣心掌控了你，他们按照他们自己的利益需要，为你定义了什么是“成功”。你接受了他们的定义，并且朝“成功”的方向努力，你就被控制了。你心目中的成功，只是为别人的野心服务的，而这些人并不需要为此做出努力，他们只需要 judge 你！因为你在乎他们怎么说，你成了那些人的奴隶，虫子的奴隶。你觉得自己“厉害”了，可是你只是别人的奴隶，因为你是否厉害，是别人说了算的！你失去了对自己的主权，这就叫做奴隶。&lt;/p&gt;

&lt;p&gt;我需要向小莫奈肚子里的寄生虫证明自己很厉害吗？不需要。我研究一下寄生虫的生命周期，生理规律，给他吃点药打掉就可以了。那些嘲笑我，说我闲话的人，吹牛皮的人，觉得我应该向他们“证明”什么的人，拿我跟其他人比较的人，不就跟寄生虫一样吗？寄生虫嘲笑我，说我闲话，对我来说有伤害吗？寄生虫如何看待我，对我来说有意义吗？我有必要让寄生虫认可我吗？我有必要跟寄生虫对骂吗？那些在乎寄生虫的看法的生命体，我还有必要尊重他们吗？所以请这些人不要再告诉我寄生虫怎么看待我，因为这会有损你们的地位。请你们看看我的文章和书，那就是给你们的打虫药。&lt;/p&gt;

&lt;p&gt;当然我也不需要实现自己的“价值”，我本来就非常有价值。我每天都感受到自己的价值，欣赏着自己的价值，我知道我不会贬值，而且会不断地升值。所以，我写书的目的很简单，是为了传播知识，把我的巨大价值分一点出去，让社会变得更好。另外，我觉得写东西是一种娱乐。我看电影，我打游戏，我寻找美食，我给小莫奈铲屎，是为了证明自己吗？是为了实现自己的价值吗？哎，这些人都在想些什么啊。&lt;/p&gt;

&lt;p&gt;有些自以为厉害的程序员可能会笑我，王垠你不写高级的技术资料，在这里忽悠初学者算什么？那他们就是大大的误解了。我并不缺高级的技术资料，我也不缺代码。去看看我的博文吧，几乎每一篇里面都有全世界最深入的见解。当全世界人都误解一个&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/06/08/java-value-type&quot;&gt;问题&lt;/a&gt;的时候，全世界的学术会议和期刊都在&lt;a href=&quot;http://www.yinwang.org/blog-cn/2013/03/31/purely-functional&quot;&gt;发烧胡扯&lt;/a&gt;的时候，当人们仰慕的大牛们都&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/10/12/compiler-bug&quot;&gt;犯错误&lt;/a&gt;还认为自己是对的时候，王垠的博文仍然是保持清醒，一针见血的。很显然，我不稀罕争夺所谓“高档”的地位。实际上我不想跟人争什么，写这本书是出于一种社会责任感，我觉得大部分人应该得到基本的知识，这样对社会有好处。&lt;/p&gt;

&lt;p&gt;我写“入门书”的另外一个原因，就像爱因斯坦说的：如果你不能向一个六岁小孩解释清楚一个问题，那么你其实并不真的懂。我在大学里见过太多讲不清楚问题的教授，中国的美国的都有，后来我发现那是因为他们自己都没弄明白。没有非常深入的见解，你是不可能把深奥的东西解释清楚的。反过来，试图把一个问题向完全不懂的人讲清楚，也会大大加深你自己的理解。看了我的『&lt;a href=&quot;http://www.yinwang.org/blog-cn/2012/08/01/interpreter&quot;&gt;怎样写一个解释器&lt;/a&gt;』而学会解释器的人都会明白，我的理解程度在全世界处于什么地位。没有成千上万次写各种各样解释器的试验，失败和领悟，你是不可能理解到那种程度的。&lt;/p&gt;

&lt;p&gt;深入理解任何一门学问的关键，不是试图去回答越来越“高级”，越来越复杂的问题，而是试图去回答最基础的问题，反复地问自己最基础的问题…… 爱因斯坦之所以能发现相对论，不是因为他去思索看起来高级的难题，而是因为他去思索一个最基本的问题：时间是什么？其他人觉得这样的问题很傻，时间不就是一秒一秒过去的那个东西吗？现在是半夜两点，那就是时间！然后这些人就永远没机会发现相对论了。同样的，深入理解计算机科学的关键，不是去学习云计算，大数据或者区块链，而是去思索最最基本的问题：“计算是什么？” “程序是什么？” “函数是什么？” “变量是什么？” …… 你觉得自己当然知道这些问题的答案吗？那请你再想一想！&lt;/p&gt;

&lt;p&gt;实际上直到 20 世纪初，全世界没有一个数学家真正的理解“函数是什么？” 这个如此基础的问题。这些人却天天都在用“函数”这个词，以至于他们的定理和证明里面出现各种奇怪的错误。直到 1904 年 &lt;a href=&quot;https://en.wikipedia.org/wiki/Gottlob_Frege&quot;&gt;Frege&lt;/a&gt; 写了这篇论文“What Is A Function?” 这种情况才得到了改善。数学发展了几千年，居然没有人真的理解如此基础的，天天都在用的概念。他们以为自己明白了，所以根本没有仔细思考过它是什么。就像我们从来没思考过什么是时间，却天天都在谈论“需要多少时间”一样。&lt;/p&gt;

&lt;p&gt;为了感受一下这个问题，我请大家来读一读这篇文章的第一句话：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.yinwang.org/images/what-is-a-function.jpg&quot; width=&quot;500&quot;&gt;&lt;/p&gt;

&lt;p&gt;回答最基础，看上去谁都知道的问题，也将会是我这本书的开端。Frege 是一个不幸的人，他的作品在他有生之年都不被人重视。我比他幸运一点，我的博客还有一些读者 :)&lt;/p&gt;

&lt;p&gt;所以这本书虽然被我叫做“普及”或者“入门”读物，但它并不只是针对初学者的：它针对所有人。对我来说，很多“资深”的程序员其实根本就不算入了门。当我进入研究生阶段的时候，偶然发现了 SICP，看了这本所谓“入门书”，我惊讶地发现自己以前其实不会编程。在美国工作的时候，我发现很多高级别的程序员也是一样的情况。他们以为自己懂了，资历很深了，而其实还差很远。由于一些初级问题一开头就没理解清楚，到了关键的时候就会犯错误。这就是我所谓的“入门”的含义。所以这本书也可以作为资深程序员们的进修读物。当然我会降低门槛，努力让初学者都能看懂。&lt;/p&gt;

&lt;h3 id=&quot;与经典书籍的区别&quot;&gt;与经典书籍的区别&lt;/h3&gt;

&lt;p&gt;因为我好像很推崇 Lisp/Scheme 语言。有些人看我想写这种入门读物，可能以为我会写一本“王垠的 Little Schemer”或者“王垠的 SICP”。这是一种比较常见的误解。如果我只是模仿 The Little Schemer （TLS） 或者 &lt;a href=&quot;https://mitpress.mit.edu/sicp/&quot;&gt;SICP&lt;/a&gt;，那是完全没有意义的。你去读那些书的中文版就行了。&lt;/p&gt;

&lt;p&gt;很多年前我就是从 SICP 入门的，但是经过多年的研究，直接跟这些书的作者们学习交流，我发现这些书虽然贡献卓著，是不可磨灭的经典，我尊敬它们的作者，可是它们也有很多不足的地方甚至误导（这句话不要传到某些人耳朵里哈）。这就是为什么有好几个出版社请我翻译 TLS，我最后都拒绝了，因为我想写很不一样的东西。&lt;/p&gt;

&lt;p&gt;很多人曾经问我：“我该看这本书还是那本书？” 我都不想回答，也是类似的原因。因为我的脑子里有一本更好的书，我觉得回答这样的问题有点降低自己的身份。我不再是此类书籍的消费者，而是创造者的级别。出于尊重的原因，你不可以问一个创造者这样的“消费级问题”。这就像你不可以问法拉利的设计者：“我是买奥迪好还是奔驰好？” 出于礼貌他也许会给你一个回答，但他的内心会很受伤 :p 同理的，请我翻译别人的此类书籍，也让我感觉很悲哀。&lt;/p&gt;

&lt;p&gt;我在之前的好几篇文章已经指出了 Scheme 语言的一些设计上的弱点，完全以 Scheme 的方式写书，显然会把很多这样的弱点当成优点，对新手造成误导。从 SICP 或者 TLS 入门的学生，很多偏激的认为 Lisp （或者 Haskell，Scala）是世界上最好的语言，以为 Lisp 的 list 是世界上最好的数据结构，以至于写 Java 代码还要在里面自己造出 Lisp 的 list 结构，搞得又复杂效率还很低。我不希望给我的读者们造成这样的效果，因为很显然我知道 list 的缺点。&lt;/p&gt;

&lt;p&gt;我希望我的书是一本有机融合多种思维方式的精华，它应该本着科学的态度，而不是宗教的。这本书要教会读者的，不是某一种语言或者某一种思维方式，而是所有的语言和所有的思维方式的精华结合在一起，并且提醒你小心它们的缺点。&lt;/p&gt;

&lt;p&gt;另外，我发现 SICP 这样的书籍还有很多写作上的弱点，很多地方有没必要的细节和冗长，导致初学者读起来头痛。书中代码的实现有些时候并不简洁清晰，到了第四章就很难看懂了。TLS 的“孔夫子式”写作方式很精悍，却还是可以很伤脑子看不懂。过度的强调递归和尾递归，会导致学生倾向于在工作中过度使用尾递归代码。另外 TLS 缺少跟实际工作接轨的内容，倒是为 Y combinator 之类完全不实用的东西耗费很多篇幅，这会让读者看了书却不知道怎么改善工作要用的代码，以至于失去动力，半途而废。我曾经很推崇费曼的物理学讲义，可是实话说吧我真想再学点物理，所以看了一些费曼的讲义。感觉开头好玩，到后来还是很累很痛苦想睡觉…… 所以我需要探索更好的方式来表达这些内容。这本书不会再号称“计算机科学的费曼讲义”，它应该更好！如果它不是更好，我就继续改进它 :)&lt;/p&gt;

&lt;p&gt;为了知识的民主和社会的文明，提高普通大众的技术教育水平迫在眉睫。这些事情我不放心其它人来做，更害怕发言权落到吹牛扯淡的野心家手里。仔细看过我的技术文章的人，都应该知道它们的见识深度是很难超越的。所以很希望大家能够支持我开张写书。祝愿大家走出迷茫，获得真知！&lt;/p&gt;

&lt;h3 id=&quot;启动经费和投票支持&quot;&gt;启动经费和投票支持&lt;/h3&gt;

&lt;p&gt;我希望在书的第一章发布之前，也就是现在，收集一些“启动经费”，来开始写作的过程。这些经费用于建立工作环境，也用于“估算”有多少人会想买我的书。&lt;/p&gt;

&lt;p&gt;如果你喜欢这篇文章，而且有意要买我将要写的书，可以点击这个&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/04/13/pay-blog&quot;&gt;付费&lt;/a&gt;页面，对本文进行少量的付费（30元），留言就写“期待CS入门书”。之前已经付过类似费用的就不用了。我会根据付费的人数来估计图书将来的销量，所以你如果感兴趣的话，请一定向我发出你的支持。但是请注意，这个付费不代表你付了买书的钱。我的书显然不会这么便宜的。由于这篇文章本身的价值，你是在给这篇文章付费 :)&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-03-05-book</guid>
<pubDate>Mon, 05 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>真相</title>
<link>https://henix.github.io/feeds/yinwang/2018-03-01-truth.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/03/01/truth&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;真相&lt;/h2&gt;
            &lt;p&gt;金钱，是万恶之源。容易得来的金钱，就更加吸引愚蠢的人。这一句，解释了我在美国硅谷看到的一切怪异现象。那些现象在中国也很猖獗。&lt;/p&gt;

&lt;p&gt;每当我批评像 Google 这样的公司里面的风气，就有人把我包装成一个自高自大的人，仿佛错的人是我。作为一个善良的人，我也曾经以为我在某些方面做得不对。然而看透了这一切之后我才发现，我对于那些经历发表的一切感受，几乎全都没有错。&lt;/p&gt;

&lt;p&gt;容易得来的金钱，导致了硅谷公司的平庸化，它已经不再是当年车库里创业的那个硅谷。过度容易得来的发财梦，引来了许许多多一知半解，甚至完全外行的人。他们打着各种绚丽的招牌，来到硅谷，为的就是钱。&lt;/p&gt;

&lt;p&gt;真正爱好计算机技术的人们，遇到这些蜂拥而来的假货，可以说是措手不及。这些吹牛大王们提出这样那样新鲜的口号，却从来没有受到过正规的计算机科学教育。太容易得来的钱，还吸引了大批不合格的人员流入大学相关专业，蒙混过关，导致学术腐败，导致整个大学系统质量体系的瘫痪。&lt;/p&gt;

&lt;p&gt;这就是我在硅谷的时候所面对的。一个受过最艰深的计算机科学教育的人，给吹牛大王们打工，被各种打压。他最后忍无可忍，终于爆发出来，他说：“我就是比你强！我凭什么要被你打压！” 于是乎，他的前半句话就被吹牛大王的同伴们拿过去，断章取义，到处宣扬：“看那，王垠是多么自大的人！竟然说出这样的话来！这种爱吹牛逼的人，跟谁都合作不好！”&lt;/p&gt;

&lt;p&gt;这种说法是非常有效的。任何有良知的人，听到有人这样说自己，都不免产生疑惑和自省：难道我做的过分了一点？这种疑惑由于强大的舆论压力，越来越深，最后导致了精神混乱。他居然以为自己做错了，他以为自己是有点自大，他开始可怜起被自己骂过的人……&lt;/p&gt;

&lt;p&gt;可是他没有发现，吹牛大王们和打压过他的人，正在为他的迷惑而庆祝。他们打着“Google校友”的招牌，回到中国，招摇过市，对 Google 的牛逼和幼稚园式的企业文化各种宣扬。他们开始打起“硅谷”的招牌，进行各种”知识付费“。言之无物，却有千万的收入滚滚而来。他们数着钱，大笑着那些被他们迷惑的人。&lt;/p&gt;

&lt;p&gt;一个善良的人，他需要莫大的支持和勇气，才能冲破这样的迷雾，冲破对自己的怀疑：“我是不是那个错的人？” “我是不是伤害了其他人？” 他反复的问自己…… 可惜他的家人，他心爱的人，都不同程度的被舆论所洗脑，甚至对他进行反向灌输，否认他的价值。这经常使得他头脑胀痛……&lt;/p&gt;

&lt;p&gt;他反反复复的琢磨自己的言论，出尔反尔的删除自己的微博。因为在他的心中，装载着对其他人的关怀。对自己的怀疑，使得他的内心矛盾重重，压力山大。&lt;/p&gt;

&lt;p&gt;可是终于有一天，他看破了这一切。他所经历过的硅谷的一切，原来是一个骗局，一个在强大的金融机构支持下进行的巨大骗局，一场财富转移的浩劫。美联储（Federal Reserve）滥印了大量的美元，通过各种渠道泛滥地投放给硅谷的创业公司。不管这些公司看上去有多傻，不管他们是否可以盈利，都可以拿到很多的投资。可以说是投资人争先恐后在送钱，还生怕别人不要他们的钱了。为什么会这样呢？因为那些钱是不费吹灰之力用印钞机印出来的！&lt;/p&gt;

&lt;p&gt;当然，大部分的创业公司都因为愚蠢而倒闭，而他们其中少数人却会抓住这些投资，成为亿万富翁。极少的创业公司的盈利，其实无法弥补泛滥的投资开销。所以这没有带来社会财富的增加，而只带来社会财富的转移和消耗。这就是所谓“第二次dotcom泡沫”，它终究是会破灭的。&lt;/p&gt;

&lt;p&gt;这是一场没有刀枪的抢劫。大量的印刷美钞，导致了其它地区，其他领域人们的贫穷。很多人做着对社会有贡献的工作，他们的收入却由于通货膨胀，房价上涨而变相的降低，变得生活困窘，不得不卖掉房子，背井离乡。抢劫，让硅谷的吹牛大王们成为了亿万富翁。&lt;/p&gt;

&lt;p&gt;在这样的洗劫运动中，冲在最前面的，当然是人性最丑恶的一面。哪里有容易钱，哪里就必然有愚蠢和虚伪。拿着好几倍高工资的所谓“管理层”，号称 JS 专家，每天开着最新型号的 Tesla 上班，却连几十行 JavaScript 代码都会写的乱七八糟，漏洞百出。&lt;/p&gt;

&lt;p&gt;为什么呢？你们钱太多了，太容易混了！所以一个劣质的人，他只需要稍加伪装，就能混到那样的职位，骑在手下人的头上，各种瞎指挥，各种邀功。我看到整个的公司，建立在这种虚无的基础上，进行非常不公平的管理和分配。真正有能力的人被打压，拿着低廉的工资，加班到深夜。&lt;/p&gt;

&lt;p&gt;各个大公司也因为有太多的“容易钱”，而变得毫无道德底线。每一家都在吹嘘自己有“黑科技”，很多这些项目一开头就明显是不可能成功的，却要利用媒体的洗脑，让外行大众以为有希望成功。其实他们的目的只有一个，那就是把大家辛苦挣来的钱，转移到极少数人的手里。不要忘了，这整个运动完全就是为了“财富转移”，而不是为了制造财富。我很惊讶，这样的行为居然不构成“诈骗罪”！&lt;/p&gt;

&lt;p&gt;看清了这一点之后，人也许就知道该怎么做了，知道该如何对待各种观点。是的，我明白了，我说过的做过的一切，都是没有大错的。我应该挺直腰杆，继续直言不讳。我应该得到我应有的尊重和报酬，我应该得到我应有的生活，我应该有机会做我喜欢的事情。我作为一个世界顶级的专家，当仁不让。&lt;/p&gt;

&lt;p&gt;那些被金钱的大潮引来的浅薄的人们，我无意跟他们指名道姓地较劲，就像我不想亲自去捅一个马蜂窝一样。我的地位不允许我那样伤害自己。我需要保护好自己，保护我关心的，善良的人们，而不应该把注意力集中在打击那些垃圾人类。过度注意低级人类，其实不知不觉降低了我自己的地位。&lt;/p&gt;

&lt;p&gt;所以呢，从今天起，我决定给自己一个转折点。我要让善良的人们知道，什么叫做王者归来！为此，我决定对回国之后的一些做法做出改变。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;我不会再向邪恶的势力妥协，我不会再帮助吹牛大王们。一旦我发现对我不诚恳的人，自以为是的人，或者想利用和诱导我的人，即会终止与他的一切交流与合作。我不会与吹牛大王们掌权的公司合作。我会在与人合作中维护严格的职业道德和科学精神。&lt;/li&gt;
  &lt;li&gt;由于我的学术水平处于世界顶级的高度，我必须维护品牌的尊严，不能让它与低档货在同样的地点出现。我不会再采用“知识付费”，“付费问答”一类的 app 或者服务。现有的知识付费服务里面，存在太多的低档次信息。我自己都不用那些东西，觉得不但毫无收获，反而受到各种洗脑。我不愿意让我的名字出现在低级别的人甚至吹牛大王的名字旁边。一直都有出版社找我写书，而我一直都拒绝，也是同样的原因。因为这些出版社联系我的时候，方式让我觉得不够尊重。他们喜欢列举为他们出书的另外一些作者，而他们跟我完全不是一个档次，有些甚至是吹牛皮的。所以我一直都未能与国内出版社合作。另外，我还会严格实行通信的高水准，不回低水准或者语气不尊重的来信，不看微博的评论。&lt;/li&gt;
  &lt;li&gt;我自己的软件项目进入保密阶段，自由发展。我不会再宣扬我自己在写什么代码，我也没有必要一直做我曾经说我要做的事情。我可以告诉人们我的兴趣，但我没必要用代码来证明什么。地位低的人才需要用代码来换取别人的认可。我不吃“Talk is cheap. Show me the code!” 那套，那是错误的想法。应该是反过来，应该是其他人向我证明他们的能力才对 :)&lt;/li&gt;
  &lt;li&gt;入门书籍准备动工。对抗吹牛大王们的攻击，最有效的一个手段就是教育。只有让大多数人得到精髓的知识，才可能让他们看清楚很多东西。当我批评“AI 浮夸风”的时候，显然很多人是看不懂我在说什么的，只好任凭他们忽悠。甚至很多高级别的工程师，都在问我要不要用 AlphaGo 的方法来实现“自动编程”，这说明他们的知识其实很不到位。如果人们都理解我所掌握的计算机科学原理，就不会这样被忽悠了。为了提高人们的认知水平，我决定开始写计算机科学的入门读物。我曾经考虑过找一些“小白鼠”来测试我的读物是否容易懂，但现在我觉得那样太麻烦，没有那个必要。我会直接把正在进行中的草稿放在这里，让大家随意浏览。有问题或者不懂的人跟我联系就行了，我会考虑作出改进。&lt;/li&gt;
  &lt;li&gt;书籍的收费。我不想再采用之前的“付费+发货”方式，寄出 PDF 文件的做法非常不方便。这些书的章节，会被陆续撰写出来贴在博客上，这样大家随时都可以得到最新的版本。我打算最开头的时候进行“自觉付费”，这跟我其他博文的“自愿付费”形式不同。“自愿付费”的意思是，你看了我的文章，如果你不喜欢，或者你根本没看完，那么你可以不付钱。“自觉付费”的意思是，你如果仔细看完了书的内容，那么你就已经“享用了”它，你就“应该”付钱。如果你不付，就是有道德过错的，如果你不想付钱，就请不要看。这就像我摆个“自觉付费”水果摊，我不看着这摊子，你们吃了自己付钱就好，结果你吃了没付钱，这就不好了。你是否付费，将会影响到我的水果摊是否可以继续营业，会影响我继续写书的动力。我的博客含有代码，会统计这段时间的阅读人数。我会根据阅读人数与付费的比例，来推断是否有很多人没付钱。如果我发现付费的比例太小，我会适当调整作法。&lt;/li&gt;
  &lt;li&gt;书籍的启动经费。我希望在书的第一章发布之前，也就是现在，收集一些“启动经费”，来开始写作的过程。这些经费用于建立必须的工作环境。这些经费也用于“估算”有多少人会买我的书。如果你看到这篇文章而且有意要买这本书，可以点击这个&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/04/13/pay-blog&quot;&gt;付费&lt;/a&gt;页面进行少量的付费（30元），留言就写“期待CS入门书”。我会根据付费的人数来估计图书将来的销量，所以你如果感兴趣的话，请一定向我发出你的支持。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;说了挺久要写书，一直没有动力动笔。一方面是由于我觉得国内的出版社都不大靠谱，而且他们出的很多书水平太低，有损我的品牌形象。另外很大一部分原因，是因为我写东西都是一针见血，容易懂，而且不会“留一手”。我很怕一不小心说太明白，就让关键的知识落到道德水平低的人手里。我也许顾虑太多了。其实我只需要提供我愿意提供的知识，而保留我不愿意提供的就行。另外，这些入门知识被广大群众了解，显然对善良的人有好处，而对吹牛逼的人们不是什么好事。这些知识将会帮助他们识破骗局，成为他们对抗这些虚假权威的武器。所以，我真的决定要写书了。&lt;/p&gt;

&lt;p&gt;这本书虽然被我叫做“普及”或者“入门”读物，而其实它将会包含最精髓的计算机科学。我敢打赌，很多工作多年的资深程序员，对于其中的很多东西都不会很清楚。所以它也可以作为资深程序员们的进修读物。当然我会降低门槛，努力让初学者都能看懂。&lt;/p&gt;

&lt;p&gt;为了知识的民主和社会的文明，提高普通大众的技术教育水平迫在眉睫。这些事情我不放心其它人来做，更害怕发言权落到吹牛扯淡的野心家手里。仔细看过我的技术文章的人，都应该知道它们的见识深度，是很难超越的。所以很希望大家能够支持我开张写书。祝愿大家走出迷茫，获得真知！&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-03-01-truth</guid>
<pubDate>Thu, 01 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>对某领导离任有感</title>
<link>https://henix.github.io/feeds/yinwang/2018-02-26-fired.html</link>
<description>&lt;p&gt;&lt;a href=&quot;http://www.yinwang.org/blog-cn/2018/02/26/fired&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add(&#39;mobile&#39;);
            }
        &lt;/script&gt;&lt;div class=&quot;inner&quot;&gt;
            &lt;h2&gt;对某领导离任有感&lt;/h2&gt;
            &lt;p&gt;最近听老同事说，之前任职的某公司的 VP Engineering，被公司“赶走”了。我吃了一惊，然后却有一股莫名的幸福感涌上心头。这是多么奇怪的感觉！&lt;/p&gt;

&lt;p&gt;离任后的主页，显示着他的“光辉业绩”，把大家的功劳全都拉到了自己身上。在我任职期间，公司增长了xx，提升了xx，培养了xx…… 只有知道内幕的人，才知道那些业绩是谁做出来的！实际上同事们对于他的离去，评价是：“众望所归”。为什么会这个样子呢？&lt;/p&gt;

&lt;p&gt;一个公司的一把手看人不准，就很可能引进这样不靠谱的人。不但没有任何贡献，给同事们制造的障碍和伤害，帮的倒忙，打压的人却不少。最恶心的是，因为这个人而慕名而来的那一大帮光说不做，瞎指挥的害虫。在 IT 领域似乎有很多这样的帮派，他们就像蝗虫一样，穿着迷惑性的外衣，从一块稻田飞到另外一块……&lt;/p&gt;

&lt;p&gt;我也是被打压的人其中之一，不但被他的下属打压，还曾经被他直接攻击。我永远都不会忘记那个危难的时刻，他的一个完全无脑的瞎政策，让我们几乎完全无法工作，大家却都忍气吞声。我又是那个第一个站出来，指出问题所在的人，那个被枪打的出头鸟。幸运的是，顶着压力持续抗争两个星期之后，我终于联合了全组人的力量，扭转了这无脑的作法，让大家的工作可以继续。&lt;/p&gt;

&lt;p&gt;（关于这件事，可以参考这篇&lt;a href=&quot;http://www.yinwang.org/blog-cn/2017/05/17/practical-idealism&quot;&gt;博文&lt;/a&gt;的“个人兴趣与企业兴趣”一节）&lt;/p&gt;

&lt;p&gt;我离开公司的时候，一位经历过此事件的同事发来 email 对我说：“谢谢你，为我们做出的一切。你会被怀念的！” 我很欣慰。我没有什么光辉业绩可以写在自己的简历上，可是我被有正义感的同事们怀念。这对于我来说就是最大的成就。&lt;/p&gt;


        &lt;/div&gt;</description>
<author>yinwang0</author>
<guid isPermaLink="false">2018-02-26-fired</guid>
<pubDate>Mon, 26 Feb 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
