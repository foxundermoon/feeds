<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>全同态加密与区块链</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Mon, 12 Feb 2018 16:31:05 +0800</lastBuildDate>
<item>
<title>全同态加密释疑（四）：转折点：LWE上全同态加密的诞生</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2017-03-29-26078068.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26078068&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gentry构造全同态加密方案的思想是非常“规则”的，是按照数学的思维来考虑问题的，就是围绕理想这一概念，因为只有这样才能产生密文的加法和乘法算。Gentry第一个全同态加密方案是基于理想格构造的。方案所选择的代数结构是理想格，是因为在格里解密操作比较简单，绝大多数都是矩阵向量乘或是内积，它们都属于NC1，具有低的解密电路复杂度，此外理想格像格一样具有加法结构，同时它还具有乘法结构的特性，可以说两全其美。&lt;/p&gt;&lt;p&gt;所有后面沿着Gentry的构造思路都是按照这个思想来的。直到LWE上的全同态加密方案的出现。&lt;/p&gt;&lt;p&gt;Gentry构造全同态加密方案的思想可以抽象概述为：首先在环R上构造一个线性纠错码&lt;em&gt;C&lt;/em&gt;，“线性”意味着保证加法同态性，“纠错”意味着码字中存在错误，如果该错误在一定范围内就可以纠错。而且&lt;em&gt;C&lt;/em&gt;是环上的一个理想，其基有两种表示，一种是“好”的表示，用来做密钥，可以对大的错误进行纠错（相当于解密），当错误超过上限后将无法纠错（即无法解密）。另外一种表示是“坏”的表示，用来做公钥，可以产生随机的码字，用于加密。由于线性纠错码&lt;em&gt;C&lt;/em&gt;的线性特性决定了其具有加法同态特性，另外&lt;em&gt;C&lt;/em&gt;是环上的一个理想，所以其乘法也具有同态特性，然而由于错误存在上限，因此仅对有限次的乘法计算保持其同态特性。该思想形成的方案就是部分（Somewhat）同态加密方案，由于密文计算中错误增长的原因，该方案只能对密文进行有限次的运算。最初的方案都可以用这种思想解释。&lt;/p&gt;&lt;p&gt;上述构造思想中的环结构保证了乘法计算，但是对于LWE（环LWE）上的加密方案由于没有环结构，所以无法提供密文向量的乘法，一度成为LWE（环LWE）上构造全同态加密的最大障碍。Brakerski在论文Bv11中引入了再线性化技术与维数模约减技术，成功的解决了在没有环结构的方案中进行密文乘积的问题。后来在BGV方案中经过改进形成了密钥交换技术和模交换技术。&lt;/p&gt;&lt;p&gt;在基于LWE（环LWE）的全同态加密方案中，密文乘积定义为两个密文&lt;strong&gt;&lt;em&gt;c&lt;/em&gt;&lt;/strong&gt;1和&lt;strong&gt;&lt;em&gt;c&lt;/em&gt;&lt;/strong&gt;2的张量&lt;strong&gt;&lt;em&gt;c&lt;/em&gt;&lt;/strong&gt;1&lt;strong&gt;&lt;em&gt;c&lt;/em&gt;&lt;/strong&gt;2，对应的密钥为&lt;strong&gt;&lt;em&gt;s.  &lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;按照这种形式的乘法定义，一方面，密文乘积将导致密文维数的膨胀，只能进行常数次的密文乘法计算；另一方面，同样面临着噪音在乘法中急剧增长的问题。解决这些问题，一方面通过使用密钥交换技术，可以将密文的维数还原到原来的维数，因此可以进行下一次密文的乘积；另一方面使用模交换技术，可以将增长的噪音约减回原来的噪音大小上。因此，不需要启动就可以获得层次型全同态加密方案(可以执行任意多项式深度的电路)，所以不再需要稀疏子集和问题假设和循环安全假设，这是全同态加密思想上的一次飞跃，打破了原有的Gentry构造框架，效率上也得到了极大地提升。目前效率最高的环-LWE上的BGV方案使用的就是这种构造方法&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2017-03-29-26078068</guid>
<pubDate>Wed, 29 Mar 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密释疑（三）：为什么不能运行自己的解密电路</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2017-03-10-25678103.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25678103&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面说过，要想降低密文计算带来的噪音，可以通过同态解密的方式得到一个新的密文，这个新密文的噪音是恒定的，所以使得我们可以进行下一次计算，每次计算后都通过同态解密约减噪音，就能够获得全同态加密了。然而同态解密是需要Evaluate算法能够运行自己的解密函数的，在早期的全同态加密方案中（Gentry09，DGHV），包括BV11方案如果最后一步不使用模维数约减的话，Evaluate都不能够运行自己的解密函数。&lt;/p&gt;&lt;p&gt;很多同学学到这里的时候，都很纳闷，解密函数不就是一些加法乘法模运算么，为什么计算不了，难道还有计算不了的函数？这个问题是问我的人最多的，今天给大家好好解释一下。&lt;/p&gt;&lt;p&gt;所谓的运行不了自己的解密函数，是有语境的，准确的说是“Evaluate算法不能够运行自己的解密函数”，而Evaluate算法的输入是什么？同态解密时，Evaluate算法输入的是解密电路，还有往解密电路里输入的一些密文，这些密文是由密钥和密文的每一位加密而成的，上次博文详细说过这事。那么Evaluate算法做的工作是什么呢？&lt;/p&gt;&lt;p&gt;Evaluate算法做的工作就是让这些密文在解密电路里计算，是密文的计算，记住了！由于密文计算过程会产生噪音，所以密文只能够进行有限次的计算，超过这个界就会产生解密的错误。所以如果&lt;strong&gt;解密电路的深度小于方案所允许计算的深度&lt;/strong&gt;（这里方案所允许计算的深度指的是Somewhat同态方案的计算能力），那么就可以完成同态解密的工作。但是如果解密电路的深度大于方案所允许计算的深度，那么就悲催了，我们就不能够使用同态解密这个方法去降低密文的噪音。怎么办？&lt;/p&gt;&lt;p&gt;Gentry在他的论文里发明了一种方法叫“压缩解密电路”，就是把解密电路的深度降低，从而满足“解密电路的深度小于方案所允许计算的深度”，这样就可以使用同态解密技术了，方案就可以启动了！压缩解密电路是要付出代价的，同时需要一个假设“稀疏子集和问题”，该问题没有被很好的研究过，所以是假设。不过目前的方案已经不需要压缩解密电路了，例如BGV方案，Bra12方案，这些方案都能够运行自己的解密电路，所以不需要压缩的方法了。&lt;/p&gt;&lt;p&gt;同态解密的技术成就了全同态加密的诞生，然而其效率却非常低，所以后面诞生了模交换技术。至于什么是模交换技术，下回分解。&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2017-03-10-25678103</guid>
<pubDate>Fri, 10 Mar 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>即生瑜，何生亮—MAC 地址与IP地址</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2017-03-05-25576156.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25576156&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      在教计算机网络课程中，经常会碰到这样的问题，为什么需要两个地址：一个是MAC(物理地址)，另一个是IP地址。各种解释都有，基本上一个观点就是一个是物理地址，一个是逻辑地址。然而，这样的解释太抽象，什么是物理，什么是逻辑。这些抽象的表述会让人无法理解到其本质。下面我就谈谈这个问题。&lt;/p&gt;&lt;p&gt;    要想说明这个问题，首先得说说计算机网络的目标是什么。计算机网络的根本目标就是将数据从一点传送到另外一点。听起来很简单，但是里面包含的意思很多。例如，两个点之间是在同一个网络还是跨网络连接的，如何才能将数据正确的传送到对方，如果出现错误怎么办等等。&lt;/p&gt;&lt;p&gt;     为了说明问题的本质，我们首先将问题简化：假设两点在一个网络内。在这种情况下，只需要MAC地址就可以了。例如通过交换机将多台电脑组成一个网络，为了找到对方，必须通过一个地址来标识。就像寄快递一样，如果没有地址，快递员是无法将快递送到对方的所在地的。这就是我们所说的MAC地址。当A点要将数据传递给B点时，会在数据的首部添加B的MAC地址，即目标地址。当然在首部中也有源地址，即发送方的MAC地址，还有其它一些信息，例如用于校验的等等。组装好的这个数据称为帧。然后A点就将帧通过网卡发送出去。&lt;/p&gt;&lt;p&gt;此时交换机收到这个帧后，查找自己的转发表。转发表主要有两列，一列是MAC地址，另外一列是该MAC地址对应的端口。查找的结果只有两种情况：找到或没找到。如果找到就将数据从该MAC对应的端口转发出去。如果没找到，很简单，交换机会把帧向所有端口广播（除了该帧进入的端口），因此肯定会有一个合适的端口收到的。这个广播的方法很粗暴，也很奏效。&lt;/p&gt;&lt;p&gt; 这就是MAC地址的作用。MAC地址是刻录在网卡这个物理设备上的，一般是无法改变的。&lt;/p&gt;&lt;p&gt;     然而，如果两点不在一个网络内。这时就需要IP地址了。因为IP地址含有两个部分，一个是网络地址，一个是主机地址。因此，通过对方的IP地址，是可以判断出对方是否和本机在一个网络内。如果在一个网络内，如上所述，只需要知道对方的MAC地址即可通信。&lt;/p&gt;&lt;p&gt;如果不在一个网络内，本机的网络层就认为数据应该发送给网关。道理是显然的，如果不在一个网络内，首先得把数据发送出网络才可以。如何发出网络，当然是发给网关，因为网关就相当于网络的门卫。要想把数据发给网关，同样需要知道网关的MAC地址，如何知道网关的MAC地址呢？这就涉及到ARP协议。&lt;/p&gt;&lt;p&gt;电脑缓存里有一张ARP表，该表主要有两列：一列是IP地址，另外一列是MAC地址。这张表不是天生就有的，是随着网卡收到网络中的各种通信数据，不断学习增加的。&lt;/p&gt;&lt;p&gt;话说回来，如果ARP表中有网关IP地址对应的MAC地址，则问题就转化为网内数据发送，上面已经讲的很清楚了。如果ARP表中没有网关IP地址对应的MAC地址，则启动ARP协议，即向网内广播，询问该IP地址的MAC地址。广播询问的结果是网关收到广播后，发现是问自己的MAC地址，所以就回复询问方自己的MAC地址。然后数据发给网关的问题，也转化为网内数据发送，上面已经讲的很清楚了。&lt;/p&gt;&lt;p&gt;大家发现没有，在跨网通信时是需要IP地址的。因为需要通过IP地址来判断是网内通信还是网外通信。有人可能会说，让MAC地址也具有能够区分网络的特征不就可以不需要IP了么。事实上这样做是不实际的。每个网卡出厂时就有一个独一无二的MAC地址，出场时是不可能知道你用它时是在哪一个网络里，也就是天生它就不具有能够区分网络的特性。而且也不需要它具有这种特性。因为MAC只负责设备到设备的通信就够了。这层通信是真正的通信，所以称为物理通信。&lt;/p&gt;&lt;p&gt;而跨网络传输数据时，需要考虑传输的路径，即为了到达目的地，下一跳应该去哪儿，从而一跳一跳的传输到目的地。而网内传输，不需要考虑传输路径，只要发出去一定可以到达。最坏情况下就是通过广播传输也能到达。而跨网络传输时，这一招不灵了。因此，跨网传输时需要考虑网络之间的传输，需要使用能够表示网络特征的地址，即IP地址。所以IP地址是负责网络到网络传输的。&lt;/p&gt;&lt;p&gt;至于发给网关后，下一步发给谁，本机就管不着了。本机只能保证在网络内传输，即下一跳的概念。下下一跳，只能由网关来负责了。其实网关就是路由器的一个接口。网关通过IP地址来确定路由，通过查找路由表来确定下一跳应该去往哪个网络，然后就将数据从连接那个网络的路由器的接口发送出去。发送出去同样要判断目标IP是和当前路由接口的网络是否同一网络。问题又回到上面讲的过程了。所以周而复始。&lt;/p&gt;&lt;p&gt;可见IP地址和MAC地址的概念并不矛盾。他们之间是不同层次的，就像有了领导还必须有群众才可以，谁也离不开谁。数据从一点传到另外一点，要经过几个网络，网络路线是怎样的，需要使用IP地址来解决。而网内传输需要使用MAC地址来传输。可见没有网内真正的通信传输，何以实现网络之间的通信。而如果没有网络路由的路径的话，数据是不可能到达目的地的，因为方向都没有。&lt;/p&gt;&lt;p&gt;如果再往深里挖掘，地址的概念还可以包括网址。就像百度的网址，我们为什么有了IP还需要网址呢？这超过了我们的题目范围，下次再说。&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2017-03-05-25576156</guid>
<pubDate>Sun, 05 Mar 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密释疑（二）：一个技术</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2017-02-19-25318032.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25318032&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在全同态加密（Fully Homomorphic Encryption）方案中，有一个非常重要技术：同态解密。&lt;/p&gt;&lt;p&gt;为什么要同态解密，前面说过噪音问题是实现全同态加密方案的最大障碍。Gentry在实现全同态加密方案时，注意到可以在Evaluate算法中执行自己的解密函数，那么输入的数据是什么呢？&lt;/p&gt;&lt;p&gt;解密函数当然输入的是密钥sk和密文c。但是不要忘了Evaluate算法是如何定义的。Evaluate算法是对输入的密文c1,c2,…执行函数 &lt;em&gt;f &lt;/em&gt;的操作，也就是对密文进行计算，其实隐含在其中的本质是对密文做同态计算，即计算后的密文解密后要等于对明文做同样的计算，如果这点做不到，那么Evaluate算法即使能对密文做很多次运算，也是没有意义的，这点一定要清楚。&lt;/p&gt;&lt;p&gt;这就是两种形态，明文态和密文态，两种形态对应的是同一个计算电路。在明文态，输入电路的是明文，而这些明文都是位（因为是布尔电路）。在密文态，输入电路的就是把每一个明文变成密文就可以了（算术电路）。这是我的独家比喻，版权所有。&lt;/p&gt;&lt;p&gt;而现在如果 &lt;em&gt;f &lt;/em&gt;是解密函数，那么输入的密文是什么呢？&lt;/p&gt;&lt;p&gt;只要看看明文态的时候输入的什么就知道了。&lt;/p&gt;&lt;p&gt;在明文态，对于解密电路，输入的肯定是密钥sk的每一位二进制位，以及密文c的每一位二进制位，因为是布尔电路，所以输入的数据都要化成二进制位的形式。&lt;/p&gt;&lt;p&gt;好了，现在在密文态，相应的把明文位变成密文就可以了，原来是一个位的地方现在变成了一个密文，那么将这些密文输入到解密电路中，结果是什么呢？是一个密文，这个密文解密后等于在明文态对明文做同样计算的结果。&lt;/p&gt;&lt;p&gt;现在我们关心的是这个从解密电路里出来的新密文和原来的密文c之间有什么关系？&lt;/p&gt;&lt;p&gt;这两个密文对应的是同样的明文。&lt;/p&gt;&lt;p&gt;而我们关心的是两个密文的噪音一样么？&lt;/p&gt;&lt;p&gt;肯定是不一样的，因为密文计算的噪音会随着计算次数不断增长。而从解密电路里出来的密文的噪音是一个固定值，是保持不变的。惊讶吧？&lt;/p&gt;&lt;p&gt;我们希望的是什么？是解密电路里出来的密文的噪音比原密文的噪音小么？&lt;/p&gt;&lt;p&gt;NO！我们要求没有这么高。我们只要求解密电路里出来的密文的噪音，还允许再进行一次乘法计算就可以了。&lt;/p&gt;&lt;p&gt;为什么？因为如果上面的要求成立的话，那么每次密文计算前，只要通过同态解密，出来的密文就可以保证再进行一次计算，不断循环下去，就可以做无限次计算了。当然要想做无限次计算还需要一个假设条件就是：循环安全。如果不做这个假设，我们只能做深度为L的电路计算。总之能够保证对密文做我们想要的计算了。&lt;/p&gt;&lt;p&gt;所以同态解密这个技术，是实现全同态加密的一个关键技术，Gentry就通过它实现了全同态加密。&lt;/p&gt;&lt;p&gt;要想使用同态解密，必须在Evaluate算法中能够执行自己的解密函数才可以。很多人都纳闷，解密函数不就是计算一下么，例如在整数方案里解密函数就是：(c mod p) mod2，在LWE或环-LWE上解密函数是：(&amp;lt;&lt;strong&gt;&lt;em&gt;c&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt;&amp;gt; mod &lt;em&gt;q&lt;/em&gt;) mod 2，难道不能够执行这些函数？&lt;/p&gt;&lt;p&gt;事情往往没有想象的那么简单，且听下回分解。&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2017-02-19-25318032</guid>
<pubDate>Sun, 19 Feb 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>何谓“格上最坏情况的困难性与平均情况的困难性”</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2017-02-19-25318016.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25318016&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;格上构建密码学方案的吸引力:最坏情况困难性与平均情况困难性的连接，Ajtai,96&lt;/h2&gt;&lt;br&gt;&lt;p&gt; 而密码学中的困难性需要的是：平均情况下的困难性。例如，如果随机选择的key，没有概率多项式时间的算法能够以不可忽略的概率破解该key。&lt;/p&gt;&lt;br&gt;&lt;p&gt; 而计算复杂论中的困难性是：最坏情况下的困难性。例如，没有多项式时间算法能够解决该问题的所有实例。即，任何多项式时间算法，存在某个实例无法解决。这对密码学是不够的：存在某个key其破解是困难的。即使不可忽略的很小一部分key能被破解，该方案也被认为是不安全的。&lt;/p&gt;&lt;br&gt;&lt;p&gt; 密码学函数的构造要求：在最坏情况下的标准计算复杂度假设下，密码学函数在平均情况下是可证明困难的。然而，对于目前的一些密码学方案，不仅要要在最坏情况下假设其困难，而且要在平均情况下假设其困难。例如，基于大整数分解的密码学方案。&lt;/p&gt;&lt;br&gt;&lt;p&gt; 最坏情况困难性与平均情况困难性的连接，Ajtai,96。说的是：对任何格及某个近似因子，如果没有算法能够解决近似SVP问题，则从一个特定的容易选取的分布中随机选取格时，SVP问题是困难的。而这里最重要的是发现了一个随机格（q元格），从随机格里选取的格，其上的格上标准困难问题例如SVP是困难的。&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2017-02-19-25318016</guid>
<pubDate>Sun, 19 Feb 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密释疑（一）：四个算法（2）</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2017-02-08-25134045.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25134045&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;继续说全同态加密中的其他三个算法。&lt;/p&gt;&lt;br&gt;&lt;p&gt;Enc算法（加密）和我们平常意义的加密是一样的，但是在全同态加密的语境里，使用Enc算法加密的密文，一般称之为新鲜密文，即该密文是一个初始密文，没有和其他密文计算过。所以新鲜密文的噪音称之为初始噪音。这个相当重要。&lt;/p&gt;&lt;p&gt;Dec算法（解密）也和我们平常理解的一样，就是对密文的解密，但是这里解密算法不仅能对初始密文解密，还能够对计算后的密文解密。但是由于部分同态加密方案中密文存在噪音，例如在整数上的全同态加密方案里，密文乘积的噪音是噪音之积，密文加法的噪音是噪音之和。所以当密文计算到一定程度，其噪音将超过上限，所以对这样的密文解密将可能失败。全同态加密的关键就是对噪音的控制，使之能对任何密文解密。&lt;/p&gt;&lt;p&gt;最后一个算法：&lt;strong&gt;Evaluate&lt;/strong&gt;&lt;strong&gt;算法（密文计算），这个算法是整个全同态加密四个算法中的核心。&lt;/strong&gt;可以做个这样的比喻：前面三个算法是大楼的地基，后面这个Evaluate算法就是大楼。这个比喻在后面会体会到它的用意。密文的计算是在电路里进行的，电路是分层的，电路深度越深，层数越多，密文就能够进行更多次的计算。随便提一句，密文计算的次数等于电路深度的对数。什么是计算次数？例如c1*c2，就是进行了一次计算，次数为2，c1*c2*c3就是进行了两次计算，次数为3。在全同态加密中，我们一般用乘法次数来衡量计算次数，这是因为乘法的噪音比加法噪音增长的快很多。&lt;/p&gt;&lt;p&gt;Evaluate算法有三个输入，第一个输入是计算公钥Evk，就是我们在上次博文里讲到的。Evk可以没有。第二个输入是函数&lt;em&gt;f&lt;/em&gt;，就是Evaluate算法所要执行的函数，可以是任意函数，因为全同态加密的目标就是对密文能够进行任意计算。当然这个函数也可以是“解密函数”，Gentry通过观察发现了一个秘密，等会我们说。第三个输入是密文，理论上可以有无穷多个密文，但是这是不可能的。&lt;/p&gt;&lt;p&gt;所以Evaluate算法就是将密文输入到函数&lt;em&gt;f&lt;/em&gt;里进行计算。我们知道在全同态加密的方案里，密文都是含有噪音的，密文的计算会导致噪音的增长，如果把函数&lt;em&gt;f&lt;/em&gt;表示成电路，那么Evaluate算法实际上只能够对有限深度&lt;em&gt;L&lt;/em&gt;的电路进行计算，超过这个深度&lt;em&gt;L&lt;/em&gt;的电路就不行了。&lt;strong&gt;所以我们把这样的方案称之为部分同态加密方案&lt;/strong&gt;。由此可见Evaluate算法的重要性，全同态加密就靠它了。还记得刚才的比喻么？Evaluate算法相当于大楼，这个大楼的层数是有限的，而全同态加密的目标是无限高！&lt;/p&gt;&lt;p&gt;所以噪音问题导致了Evaluate算法不能够对任意电路（函数）进行计算。&lt;/p&gt;&lt;p&gt;而全同态加密追求的就是Evaluate算法能够对任意电路进行计算，怎么办？那只有控制噪音问题了。如何控制噪音呢？下回分解。&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2017-02-08-25134045</guid>
<pubDate>Wed, 08 Feb 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密释疑（一）：四个算法（1）</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2017-02-07-25129937.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25129937&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        2009年全同态加密（Fully Homomorphic Encryption）的诞生，不仅是密码学界的一个大的突破（Breakthrough）,而且是计算机理论界的一个突破。自从2011年创建了全同态加密QQ群，从几十号人到现在的将近200人，来自各个大学，包括国外。可见人们对全同态加密研究的热情。&lt;/p&gt;&lt;p&gt;另外在网上有许多同学问我一些问题，有些问题很雷同，可能也是初学者必经之路。全同态加密的入门确实比较难。作为一个过来者，非常愿意分享我的一些心得，所以这里我会把一些共性的问题，用一种深入浅出的方法讲述，希望每个人都能看懂。&lt;/p&gt;&lt;p&gt;其实在全同态加密论文的背后，有许多可以说出来的秘密，只不过这个秘密在论文里没空间也不适合讲，那么这里就搞一个专题“全同态加密释疑”，细说从头每个让你困惑的秘密。如果有愿意加入的朋友，可以一起分享心得体会。&lt;/p&gt;&lt;p&gt;今天说说全同态加密的四个算法。可能有些人会说，这个谁不知道，但是知道并不意味着清楚，只有深刻理解了这四个算法的含义，尤其是第四个算法的含义，才能清楚什么是部分同态加密方案，什么是执行自己的解密电路等等概念。&lt;/p&gt;&lt;p&gt;通常一个公钥加密方案有三个算法：KeyGen算法（密钥生成），Enc算法（加密），Dec算法（解密）。但是在全同态加密中，除了上述三个算法之外，还包含第四个算法：Evaluate算法（密文计算），这个算法的功能是对输入的密文进行计算。&lt;/p&gt;&lt;p&gt;首先说说KeyGen算法（密钥生成）。该算法用于生成公钥和密钥，公钥用于加密，私钥用于解密，这个地球人都知道。但是还可能生成另外一种公钥，即密文计算公钥，我们把它称之为Evk。&lt;/p&gt;&lt;p&gt;密文计算公钥Evk的作用是在执行Evaluate算法时用到，而且Evk的形式与使用的全同态方案直接相关。例如，如果是通过启动技术（Bootstrapple）获得全同态加密，即每次密文计算前要用同态解密约减密文的噪音，这时Evk就是对密钥的每一位加密后生成的密文，即密钥有多少位，Evk里包含的公钥就有多少个。Evk中每个公钥的大小就是使用Enc加密后产生密文的大小。典型的代表就是Gentry的理想格方案以及后续的整数上的方案。&lt;/p&gt;&lt;p&gt;当然还有其他情况，例如，如果使用密钥交换与模交换技术获得全同态加密，典型代表就是BGV方案。这时Evk中包含的就是&lt;em&gt;L&lt;/em&gt;–1个矩阵，&lt;em&gt;L&lt;/em&gt;是方案中电路的深度，该矩阵用于密钥转换。每次密文计算后，都需要使用Evk中的公钥将维数扩张的密文向量转换成正常维数的密文向量。&lt;/p&gt;&lt;br&gt;&lt;p&gt;当然还有一种情况就是不需要Evk，例如在Crypto13会议的论文GSW13中，Gentry使用的密文是矩阵（方阵），所以密文乘积或相加不会产生密文维数改变的事情，所以在密文计算时没有用到公钥，这也是该论文可以产生基于身份或基于属性全同态加密方案的根本原因。&lt;/p&gt;&lt;p&gt;关于Evk就说了这么多，你觉得简单么？一个成功男人的背后，有多少……，那么一个概念的背后就有多少个概念在支撑。千万别小看了概念，只有善于抓概念，才能体会方案的脉络。&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2017-02-07-25129937</guid>
<pubDate>Tue, 07 Feb 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
