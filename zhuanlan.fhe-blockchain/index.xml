<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>全同态加密与区块链</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/</link>
<description>全同态加密具有神奇的功能，在不解密的情况下能够对密文进行任意计算。区块链能够在去中心化的环境下，保证数据的不可篡改、可追溯等。区块链+全同态加密=让我的数据属于我掌控。</description>
<language>zh-cn</language>
<lastBuildDate>Sat, 08 Sep 2018 16:45:55 +0800</lastBuildDate>
<item>
<title>最清晰的比特币白皮书解析4－网络</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2018-09-08-44050389.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/44050389&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d77484395746a6d77e841733fb50dcd3_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;5. 网络&lt;/b&gt;&lt;/p&gt;&lt;p&gt;白皮书前面说了，为了构造一个分布式时间戳，需要对一个区块去求解满足要求的哈希值。求解哈希值时，唯一可以调整的参数是随机数（nounce）。交易就存放在这个区块里。那么问题就来了，各个节点是如何收到交易的呢？如何把交易放到区块里呢？所有这一切都是依赖于互联网的。这节就讲了交易如何在网络中的传播以及如何形成区块。&lt;/p&gt;&lt;p&gt;白皮书第一段如下：&lt;/p&gt;&lt;p&gt;The steps to run the network are as follows: &lt;/p&gt;&lt;p&gt;. 1)  New transactions are broadcast to all nodes.  &lt;/p&gt;&lt;p&gt;. 2)  Each node collects new transactions into a block.  &lt;/p&gt;&lt;p&gt;. 3)  Each node works on finding a difficult proof-of-work for its block.  &lt;/p&gt;&lt;p&gt;. 4)  When a node finds a proof-of-work, it broadcasts the block to all nodes.  &lt;/p&gt;&lt;p&gt;. 5)  Nodes accept the block only if all transactions in it are valid and not already spent.  &lt;/p&gt;&lt;p&gt;. 6)  Nodes express their acceptance of the block by working on creating the next block in the  chain, using the hash of the accepted block as the previous hash.  &lt;/p&gt;&lt;p&gt; 比特币网络运行的步骤如下： &lt;/p&gt;&lt;p&gt;1) 新的交易通过全网向所有节点广播； &lt;/p&gt;&lt;p&gt;2) 每一个节点将收到的新的交易信息放入一个区块中； &lt;/p&gt;&lt;p&gt;3) 每个节点都为自己的区块执行工作量证明，以发现一个满足难度要求的哈希值；&lt;/p&gt;&lt;p&gt;4) 当一个节点发现了一个满足难度要求的哈希值，它就向全网进行广播该区块； &lt;/p&gt;&lt;p&gt;5) 当且仅当包含在该区块中的所有交易都是有效的且之前没有双花过，其他节点才接受承认该区块； &lt;/p&gt;&lt;p&gt;. 6) 其他节点接受该区块后，就在该区块之后制造新的区块以延长该链条。并将被接受区块的哈希值写入新区块中前一区块哈希值（previous hash  &lt;/p&gt;&lt;p&gt;）的位置。 &lt;/p&gt;&lt;p&gt;上述过程把交易的传播和块的形成，描述的非常简洁和清楚。由于网络的传播是有时延的，如果两个节点同时广播自己的区块，那么有些节点可能收到的是这个区块，另外节点可能收到的是另一个区块，那么就会造成链的分叉，如何处理呢？&lt;/p&gt;&lt;p&gt;白皮书紧接着说&lt;/p&gt;&lt;p&gt;Nodes always consider the longest chain to be the correct one and will keep working on extending it. If two nodes broadcast different versions of the next block simultaneously, some nodes may receive one or the other first. In that case, they work on the first one they received, but save the other branch in case it becomes longer. The tie will be broken when the next proof- of-work is found and one branch becomes longer; the nodes that were working on the other branch will then switch to the longer one. &lt;/p&gt;&lt;p&gt;所有节点都将最长的链条视为正确的链条，并在最长的链条上继续工作从而延长它。如果有两个节点同时广播了不同的新区块，那么先收到哪个新区块，对于有些节点是有差异的。在此情况下，节点将在自己收到的第一个新区块上进行工作，但也会保留另外一个产生分叉的链，以防后者变成最长的链。当下一个新区块诞生后，其中一个链将会被延长，从而分叉的局面被打破。而在另一条链上的节点将转移到最长链上工作。&lt;/p&gt;&lt;p&gt;到这里有个问题，原本以为节点不知道除了自己工作的链以外还有其它的分支链。但是从上面的叙述可知，当出现分叉的时候，节点会知道有分叉出现的，而且还会保存另外的分叉链，以备将来转换。&lt;/p&gt;&lt;p&gt;交易在网络中的广播，是不是必须所有节点都收到后才可能被装入到新区块中（注意新区块诞生的方法）？同样，新区块的广播是不是所有节点都必须收到才可以，如果新区块在传播过程中丢失了，有的节点没收到怎么办？白皮书下面说了这个问题。&lt;/p&gt;&lt;p&gt;New transaction broadcasts do not necessarily need to reach all nodes. As long as they reach many nodes, they will get into a block before long. Block broadcasts are also tolerant of dropped messages. If a node does not receive a block, it will request it when it receives the next block and realizes it missed one. &lt;/p&gt;&lt;p&gt;新交易在广播过程中，未必需要到达全部的节点。只要它们能够到达大多数的节点，那么这些新交易很快会出现在链上的一个新区块中。为什么呢？因为大多数节点收到了新交易，那么节点挖出区块的概率也会以极大的可能落到大多数节点中的某个节点。所以很快该新交易就会出现在链上。如果挖出区块的节点碰巧不在这些大多数节点中，那么该新交易就不会出现在链上的新区块中。但是同样以极大的概率出现在下一个新区块中。&lt;/p&gt;&lt;p&gt;而区块的广播对于传播过程中丢失区块也具有容错能力。如果一个节点没有收到新区块，那么该节点在收到新区块之后的区块到来时，将会发现自己缺少前一个区块，从而会请求接收那个缺少的区块。&lt;/p&gt;&lt;p&gt;以上给出了交易和区块在网络中广播可能出现的一些情况及对策。但是细节并没有讲到，只是给出了大致的框架。如果学过计算机网络原理，对以上的过程就不会陌生。根据一些资料显示，比特币网络采用的是P2P网络架构，节点之间连接使用的是TCP协议。TCP协议是一种面向连接的可靠协议，它具有处理网络丢包，重传，校验等功能。&lt;/p&gt;&lt;p&gt;文章首发在微信公众号：btc201800&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&quot;&gt;http://weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&lt;/a&gt; (二维码自动识别)&lt;/p&gt;&lt;p&gt;相应的音频，已发布到喜马拉雅“解读区块链白皮书”上，欢迎收听。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//m.ximalaya.com/42927243/sound/119777482&quot;&gt;http://m.ximalaya.com/42927243/sound/119777482&lt;/a&gt;(二维码自动识别) &lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2018-09-08-44050389</guid>
<pubDate>Sat, 08 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>最清晰的比特币白皮书解析3-工作量证明</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2018-09-08-44050124.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/44050124&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d77484395746a6d77e841733fb50dcd3_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;4. 工作量证明&lt;/b&gt;&lt;/p&gt;&lt;p&gt;先看本节要讲什么。白皮书第一句话就点明了该节的目的。&lt;/p&gt;&lt;p&gt;To implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proof- of-work system similar to Adam Back&#39;s Hashcash [6], rather than newspaper or Usenet posts. &lt;/p&gt;&lt;p&gt;为了在点对点的去中心化环境下实现分布式时间戳服务，我们使用类似于Adam在Hashcash中提出的一个工作量证明系统，而不是使用报纸或者新闻组这样的方法。&lt;/p&gt;&lt;p&gt;所以本节全部围绕着如何具体实现上节的时间戳。由于是在点对点的环境下，所以该时间戳是一个分布式时间戳。本节讨论的就是分布式时间戳实现的方法，是对上节时间戳概念的落实。（为什么要实现时间戳呢？因为要解决双花问题。时间戳为什么能够解决双花问题呢？因为要形成一个唯一的不可更改的交易记录账本）&lt;/p&gt;&lt;p&gt;注意Hashcash也是一个电子现金系统，是由Adam提出的。中本聪受到该系统的启发，并且在白皮书中引用了该论文。此外，上面说了不使用在上节说的报纸或者新闻组来实现时间戳。那么通过什么方法来实现呢？白皮书上说了，通过一个叫“工作量证明”的方法。什么是工作量证明呢？紧接着白皮书给出了说明。&lt;/p&gt;&lt;p&gt;The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, the hash begins with a number of zero bits. The average work required is exponential in the number of zero bits required and can be verified by executing a single hash. &lt;/p&gt;&lt;p&gt;工作量证明就是求解一个哈希值（例如通过SHA-256求解哈希值），要求该哈希值的最高位含有若干个0。平均情况下，该工作量与0的个数呈指数级关系，即哈希值中0的个数的增加将会让求解工作量呈指数级增长。而验证该哈希值的正确性可以通过执行哈希函数来进行。&lt;/p&gt;&lt;p&gt;上面说明了工作量证明的难度，即求解满足要求的哈希值所花费的时间，与哈希值的最高位含有多少个0有直接关系。这样就把工作量证明与时间挂上了钩。那么具体如何实现工作量证明呢？白皮书紧接着说了。&lt;/p&gt;&lt;p&gt;For our timestamp network, we implement the proof-of-work by incrementing a nonce in the block until a value is found that gives the block&#39;s hash the required zero bits. Once the CPU effort has been expended to make it satisfy the proof-of-work, the block cannot be changed without redoing the work. As later blocks are chained after it, the work to change the block would include redoing all the blocks after it. &lt;/p&gt;&lt;p&gt;为了构建我们的时间戳网络，我们需要实现工作量证明机制，而该机制是通过不断递增一个区块中的随机数，直到发现一个满足要求的区块哈希值。所以工作量证明就是不断的取一个随机数去求解区块的哈希值，没有捷径可言，就是不断的尝试，不断的计算。一旦CPU的算力用于完成了工作量证明，即发现了一个满足要求的哈希值，也就是找到了放到区块中的那个随机数，则如果想改变该区块中的数据的话，必须再做同样的事情，即花费CPU的算力去完成工作量证明。如果该区块后面又有新的区块，则改变该区块中的数据所花费的工作量将包括后面的所有区块，所以工作量大大增加。&lt;/p&gt;&lt;p&gt;看到这里，是不是想到了时间戳服务那节所说的：如果想篡改某一个区块的时间戳，必须篡改其后的所有时间戳才可以。而这里恰好通过工作量证明机制实现了时间戳服务。至此，你清楚了吗？工作量证明机制是干吗的。&lt;/p&gt;&lt;p&gt;工作量证明机制还有另外一个特性，紧接着白皮书说到：&lt;/p&gt;&lt;p&gt;The proof-of-work also solves the problem of determining representation in majority decision making. If the majority were based on one-IP-address-one-vote, it could be subverted by anyone able to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote. The majority decision is represented by the longest chain, which has the greatest proof-of-work effort invested in it. If a majority of CPU power is controlled by honest nodes, the honest chain will grow the fastest and outpace any competing chains. To modify a past block, an attacker would have to redo the proof-of-work of the block and all blocks after it and then catch up with and surpass the work of the honest nodes. We will show later that the probability of a slower attacker catching up diminishes exponentially as subsequent blocks are added. &lt;/p&gt;&lt;p&gt;工作量证明机制还解决了谁是大多数的问题。如果决定大多数的方式是基于IP地址的，即一IP地址一票，则该机制将被能够分配大量IP地址的人所破坏。而工作量证明机制的本质则是一CPU一票。大多数人的决定被表达为最长的链，因为最长的链包含了最大的工作量。如果大多数的CPU为诚实的节点控制，那么诚实的链条将以最快的速度延长，并超越其他的竞争链条。如果想要对以往的区块进行修改，攻击者必须完成该区块以及其后所有区块的工作量证明，然后才能赶上和超越诚实节点的工作量。我们将在后面说明，当随后的块不断增加时，一个较慢的攻击者追赶上的概率将呈指数级递减。&lt;/p&gt;&lt;p&gt;To compensate for increasing hardware speed and varying interest in running nodes over time, the proof-of-work difficulty is determined by a moving average targeting an average number of blocks per hour. If they&#39;re generated too fast, the difficulty increases. &lt;/p&gt;&lt;p&gt;随着时间的推移，为了应对硬件速度的日益增长以及网络中各个节点参与的不同利益，工作量证明的难度以平均每小时出块数作为波动平均值。如果每小时的出块数太快，将增加工作量证明的难度。&lt;/p&gt;&lt;p&gt;文章首发在微信公众号：btc201800&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&quot;&gt;http://weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&lt;/a&gt; (二维码自动识别)&lt;/p&gt;&lt;p&gt;相应的音频，已发布到喜马拉雅“解读区块链白皮书”上，欢迎收听。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//m.ximalaya.com/42927243/sound/119777482&quot;&gt;http://m.ximalaya.com/42927243/sound/119777482&lt;/a&gt;(二维码自动识别)&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2018-09-08-44050124</guid>
<pubDate>Sat, 08 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>最清晰的比特币白皮书解析2-时间戳服务</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2018-09-03-43589810.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43589810&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d77484395746a6d77e841733fb50dcd3_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;3. 时间戳服务&lt;/b&gt;&lt;/p&gt;&lt;p&gt;通过上节知道，解决双花问题成为了去中心化点对点系统的核心问题。上一节指出为了解决双花问题，需要系统能够对交易的先后顺序达成一致共识。但是如何做并没有说。显然顺序和时间有关，那么在系统内如何体现时间呢？&lt;/p&gt;&lt;p&gt;首先要清楚什么是时间戳。时间戳就是为某个文档的时间提供证明。在某些商务场合很重要，例如签合同，时间是具有法律意义的。在电子文档环境下要提供时间戳，需要保证两件事情：&lt;/p&gt;&lt;p&gt;一是文档没有被修改；&lt;/p&gt;&lt;p&gt;二是为该文档添加的时间戳具有信用背书。也就是需要一个可信的第三方机构来发布时间戳。&lt;/p&gt;&lt;p&gt;第一点可以通过对文档的哈希来解决，第二点如果在可以有中心化的场景，可以通过专业的可信第三方提供时间戳服务。但是现在是点对点的去中心化环境，如何提供时间戳呢？&lt;/p&gt;&lt;p&gt; 所以白皮书的第一句话，就说为了提出解决方案，我们先从时间戳服务说起。&lt;/p&gt;&lt;p&gt;The solution we propose begins with a timestamp server. &lt;/p&gt;&lt;p&gt; 紧接着白皮书解释了如何提供时间戳。&lt;/p&gt;&lt;p&gt;A timestamp server works by taking a hash of a block of items to be timestamped and widely publishing the hash, such as in a newspaper or Usenet post [2-5]. &lt;/p&gt;&lt;p&gt; 时间戳服务可以通过计算区块数据的哈希值，并且广而告之该哈希值，例如刊登在报纸或者其它媒体上来提供。&lt;/p&gt;&lt;p&gt;上述方法通过哈希解决了数据的不可篡改性，通过报纸等媒体解决了时间性。因为报纸等媒体是按照时间发行，具有时间特征的。而且哈希值一旦在报纸等公开媒体发布，其时间和哈希值就牢牢绑定无法更改了，被永远记录在媒体上。从而实现了分布式时间戳的目的（即不需要一个可信的机构来发布时间戳）。&lt;/p&gt;&lt;p&gt;所以白皮书紧接着说&lt;/p&gt;&lt;p&gt;The timestamp proves that the data must have existed at the time, obviously, in order to get into the hash. Each timestamp includes the previous timestamp in its hash, forming a chain, with each additional timestamp reinforcing the ones before it. &lt;/p&gt;&lt;p&gt;显然通过计算区块数据的哈希值来提供时间戳服务，该时间戳证明了区块数据在某个时间的存在性。在计算区块的哈希时，包含了前一区块的时间戳，从而形成了一个链条，即每一个区块的时间戳都包含了它之前区块的时间戳。通俗的讲，前面所有区块的特征都被遗传到了后面的时间戳中。如果想篡改某一个区块的时间戳，必须篡改其后的所有时间戳才可以。这是一个非常好的特性，使得时间戳链条越长，安全性越好。&lt;/p&gt;&lt;p&gt;从而时间戳链条越长，就越能增强前面时间戳的不可篡改性。因为要花更大的代价去篡改其后的所有时间戳。这就是这句话的本质含义Each timestamp includes the previous timestamp in its hash, forming a chain, with each additional timestamp reinforcing the ones before it. 目前的中文版都没有对背后的意思进行解读，这是需要功力的。如果不对比特币系统有深入的理解，很难读懂其白皮书。&lt;/p&gt;&lt;p&gt; 整个白皮书一环套一环，很紧凑，很简洁，但是也造成了理解上的困难。相信经过我们这样的深入解析，会让您豁然开朗。&lt;/p&gt;&lt;p&gt;到此，上述论述的时间戳本质上就是一个哈希链，而且每个哈希值都被打了时间戳的一个链。要在点对点的分布式环境下，实现该时间戳是需要一种新机制的。&lt;/p&gt;&lt;p&gt;这里存在一个问题，哈希只是解决了数据不可篡改的目的，如何和时间挂上钩呢？可以通过可信的第三方来提供时间戳服务，也可以把哈希值记录在报纸等公开的媒体上。但是现在是一个点对点的网络，即不存在中心化的第三方。那么如何体现可信时间这个概念呢？&lt;/p&gt;&lt;p&gt;由于是点对点的网络，所以时间必须是随机的由网络中的某个节点提供。如果不是随机的，就不能体现点对点网络的去中心化特征，时间就可能被提供者控制。有些人可能会想，那就由随机选定的节点提供时间就可以了。这样做不能保证时间的真实性（因为可能会被篡改），因为不能保证每个节点都是诚实的。那么既要保证时间提供者的随机性，又不能让提供者直接提供时间，这不是矛盾吗？如何解决呢？&lt;/p&gt;&lt;p&gt;办法总是人想出来了的。中本聪想的办法是通过事件来体现时间，即把事件和时间关联起来。就像把哈希值记录在报纸上一样。只要事件是随机的，那么完成该事件就意味着在某个时间完成了该事件，从而体现了时间。关键是体现了交易的先后顺序。&lt;/p&gt;&lt;p&gt;文章首发在微信公众号：btc201800&lt;/p&gt;&lt;p&gt;http://weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK (二维码自动识别)&lt;/p&gt;&lt;p&gt;相应的音频，已发布到喜马拉雅“解读区块链白皮书”上，欢迎收听。&lt;/p&gt;&lt;p&gt;http://m.ximalaya.com/42927243/sound/119777482 (二维码自动识别)&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2018-09-03-43589810</guid>
<pubDate>Mon, 03 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>最清晰的比特币白皮书解析—交易</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2018-09-01-43483805.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43483805&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d77484395746a6d77e841733fb50dcd3_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;       前面给大家解析了摘要和引言，今天给大家解析白皮书的下一部分：交易。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. 交易&lt;/b&gt;&lt;/p&gt;&lt;p&gt;        第一句话，We define an electronic coin as a chain of digital signatures.目前的中文版都翻译错了。 &lt;/p&gt;&lt;p&gt;       这句话的意思是：在比特币系统中，一个数字货币被看作是由数字签名构成的链。而数字签名是干什么的？是用于对交易的签名。所以一个数字货币被看作是由交易构成的链。&lt;/p&gt;&lt;p&gt;       注意比特币系统是一个点对点的数字货币系统，所以在该系统中“币”是一个非常重要的概念。如何在系统中体现币呢？&lt;/p&gt;&lt;p&gt;       事实上，币是在交易中流动的。每一次交易，币就从一个人的手中转移到另外一个人的手中，不断循环流动。根据上面的定义，在比特币系统中，一个数字货币被看作是一个由交易构成的链，该链反映了该币的每一次交易。注意，这里的链与区块链不是一个意思。&lt;/p&gt;&lt;p&gt;       这就是为什么经常说，比特币里面没有币，而只有交易的原因。在比特币系统中，所有体现币的地方，都用该币的最近一次交易来代替说明。&lt;/p&gt;&lt;p&gt;        那么这里的数字签名是干什么的？这需要知道数字签名的功能是什么？&lt;/p&gt;&lt;p&gt;       数字签名功能有三个：&lt;/p&gt;&lt;p&gt;第一，证明该消息来自于发送者，该功能称为认证；&lt;/p&gt;&lt;p&gt;第二，发送者不能否认自己发过该消息，该功能称为不可抵赖；&lt;/p&gt;&lt;p&gt;第三，发送的消息在传输的过程中没有改变，该功能称为消息的完整性。&lt;/p&gt;&lt;p&gt;      那么交易的内容是什么呢？交易的内容就是：付款人将该币支付给收款人。 &lt;/p&gt;&lt;p&gt;      为了证明付款人能够将该币支付给收款人，必须说明四个问题：&lt;/p&gt;&lt;p&gt;第一， 该币属于付款人；&lt;/p&gt;&lt;p&gt;第二， 付款人同意将该币支付给收款人；&lt;/p&gt;&lt;p&gt;第三， 付款地址必须是收款人的地址；&lt;/p&gt;&lt;p&gt;第四， 该币没有被双花。&lt;/p&gt;&lt;p&gt;       那么如何保证上面的前三点的呢？白皮书紧接着说：&lt;/p&gt;&lt;p&gt;Each owner transfers the coin to the next by digitally signing a hash of the previous transaction and the public key of the next owner and adding these to the end of the coin. &lt;/p&gt;&lt;p&gt;       就是付款人（数字货币的所属人）通过将上一笔交易以及收款人的公钥（即收款地址）进行哈希函数计算，然后对该哈希值进行数字签名，最后将签名附在该币的后面，以达到证明付款人能够将该币支付给收款人的目的。&lt;/p&gt;&lt;p&gt;       为什么付款人要对上一笔交易签名呢？因为要保证该币属于付款人（币的所属权）。由于比特币系统中，币是由交易体现的，所以该币应该是之前由某人支付给了当前付款人（即产生了一笔交易），也就是追溯币的来源，从而说明该币属于付款人。如果不能追溯到该币的上一笔交易，则无法说明该币属于当前付款人。&lt;/p&gt;&lt;p&gt;       公钥在这里代表收款人的地址。对上一笔交易和公钥进行哈希计算，是为了缩短签名内容的长度。&lt;/p&gt;&lt;p&gt;       紧接着白皮书说：&lt;/p&gt;&lt;p&gt;A payee can verify the signatures to verify the chain of ownership. &lt;/p&gt;&lt;p&gt;       即收款人通过验证数字签名来达到验证币的所属权的目的。&lt;/p&gt;&lt;p&gt;       紧接着白皮书说：&lt;/p&gt;&lt;p&gt;The problem of course is the payee can&#39;t verify that one of the owners did not double-spend the coin. &lt;/p&gt;&lt;p&gt;       前面说了，为了证明付款人能够将该币支付给收款人，必须说明四个问题，前三个问题都有了着落，而第四个问题“该币没有被双花”却没有说如何解决。即收款人无法验证在这些交易中，该币没有被双花。&lt;/p&gt;&lt;p&gt;A common solution is to introduce a trusted central authority, or mint, that checks every transaction for double spending. After each transaction, the coin must be returned to the mint to issue a new coin, and only coins issued directly from the mint are trusted not to be double-spent. The problem with this solution is that the fate of the entire money system depends on the company running the mint, with every transaction having to go through them, just like a bank. &lt;/p&gt;&lt;p&gt;        解决双花问题的一个通常解决办法是引入一个可信的中心，或者货币发行方，通过它们检查每一笔交易。每次交易完后，货币发行方从付款人那里减掉相应的货币，并且从收款人那里增加相应的新币。只有通过货币发行方发行的货币才被认为没有被双花的。显然这种解决方法使得整个货币系统依赖于一个中心，即货币发行方，就像我们现在的银行，每一笔交易都是由它来处理。&lt;/p&gt;&lt;p&gt;We need a way for the payee to know that the previous owners did not sign any earlier transactions. For our purposes, the earliest transaction is the one that counts, so we don&#39;t care about later attempts to double-spend. The only way to confirm the absence of a transaction is to be aware of all transactions. In the mint based model, the mint was aware of all transactions and decided which arrived first. To accomplish this without a trusted party, transactions must be publicly announced [1], and we need a system for participants to agree on a single history of the order in which they were received. The payee needs proof that at the time of each transaction, the majority of nodes agreed it was the first received. &lt;/p&gt;&lt;p&gt;       所以我们需要一种方法让收款人知道，在此之前该币并没有被双花过。双花什么意思？就是该币被当前付款人使用后，又被付款人第二次使用。从交易角度来说，对当前付款人该币产生了2笔交易，这两币交易是有先后顺序的。第一笔交易是合法的，而第2笔交易就是双花，是非法的。理解到这个层次，才能对白皮书中的这句话理解：For our purposes, the earliest transaction is the one that counts, so we don&#39;t care about later attempts to double-spend. 即对当前付款人来说，该币产生的第一次交易（最早的一笔交易）才是我们关注的，因为这笔交易是合法交易。而对于该币产生的后面交易都属于双花，所以并不需要关注（因为这些双花交易都是要被废掉的）。注意这里的语境都是对当前付款人来说的，即该币的所属人。很多翻译都是直接按照字面意思翻译，读者会读起来感到莫名其妙，前词不达后语。&lt;/p&gt;&lt;p&gt;       为此，我们必须知道交易的先后顺序，这样才能确定每一笔交易是否合法或者双花，从而把不该存在的交易剔除。就是这句话的含义：The only way to confirm the absence of a transaction is to be aware of all transactions. 这句话很多人不能够理解。确实单从字面上很难理解其含义。&lt;/p&gt;&lt;p&gt;       紧接着白皮书对比了中心化系统下采用的方法。在基于中心化的货币发行方的模型下，货币发行方知道所有的交易，从而可以判断交易的先后顺序，故而避免双花。&lt;/p&gt;&lt;p&gt;       而在去中心化环境下，由于没有中心，如何形成一个唯一的且交易具有先后顺序 的账本呢？方法是交易在系统内公开广播，从而让所有参与者都知道交易。光是知道交易是不够的，关键是对交易的顺序达成一致共识。因此需要构建一个系统，让系统内的所有参与者能够对交易的先后顺序达成共识（注意这里再次说明交易的先后顺序是多么重要。为什么重要？因为可以解决双花。为什么能够解决双花？因为可以确定该币的第一笔交易。），即系统内每个参与者手上都具有唯一的相同的交易链（避免了交易链的不一致）。&lt;/p&gt;&lt;p&gt;      收款人需要证实他收到的每一笔交易都是系统内大多数节点认可的不是双花的交易，即在此之前对该收款人来说，该币没有被花费过，即第一笔交易。所有这一切都是为了解决双花问题。注意上面只是提出了需求（因此需要构建一个系统……），并没有给出如何做到对交易顺序达成一致共识的方法。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;     本文首发在微信公众号：btc201800&lt;/p&gt;&lt;p&gt;http://weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK (二维码自动识别)&lt;/p&gt;&lt;p&gt;     该文章的音频，发在喜马拉雅“区块链杂谈”节目中。&lt;/p&gt;&lt;p&gt;http://m.ximalaya.com/42927243/sound/119777482 (二维码自动识别)&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2018-09-01-43483805</guid>
<pubDate>Sat, 01 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密释疑（四）：转折点：LWE上全同态加密的诞生</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2017-03-29-26078068.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26078068&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gentry构造全同态加密方案的思想是非常“规则”的，是按照数学的思维来考虑问题的，就是围绕理想这一概念，因为只有这样才能产生密文的加法和乘法算。Gentry第一个全同态加密方案是基于理想格构造的。方案所选择的代数结构是理想格，是因为在格里解密操作比较简单，绝大多数都是矩阵向量乘或是内积，它们都属于NC1，具有低的解密电路复杂度，此外理想格像格一样具有加法结构，同时它还具有乘法结构的特性，可以说两全其美。&lt;/p&gt;&lt;p&gt;所有后面沿着Gentry的构造思路都是按照这个思想来的。直到LWE上的全同态加密方案的出现。&lt;/p&gt;&lt;p&gt;Gentry构造全同态加密方案的思想可以抽象概述为：首先在环R上构造一个线性纠错码&lt;em&gt;C&lt;/em&gt;，“线性”意味着保证加法同态性，“纠错”意味着码字中存在错误，如果该错误在一定范围内就可以纠错。而且&lt;em&gt;C&lt;/em&gt;是环上的一个理想，其基有两种表示，一种是“好”的表示，用来做密钥，可以对大的错误进行纠错（相当于解密），当错误超过上限后将无法纠错（即无法解密）。另外一种表示是“坏”的表示，用来做公钥，可以产生随机的码字，用于加密。由于线性纠错码&lt;em&gt;C&lt;/em&gt;的线性特性决定了其具有加法同态特性，另外&lt;em&gt;C&lt;/em&gt;是环上的一个理想，所以其乘法也具有同态特性，然而由于错误存在上限，因此仅对有限次的乘法计算保持其同态特性。该思想形成的方案就是部分（Somewhat）同态加密方案，由于密文计算中错误增长的原因，该方案只能对密文进行有限次的运算。最初的方案都可以用这种思想解释。&lt;/p&gt;&lt;p&gt;上述构造思想中的环结构保证了乘法计算，但是对于LWE（环LWE）上的加密方案由于没有环结构，所以无法提供密文向量的乘法，一度成为LWE（环LWE）上构造全同态加密的最大障碍。Brakerski在论文Bv11中引入了再线性化技术与维数模约减技术，成功的解决了在没有环结构的方案中进行密文乘积的问题。后来在BGV方案中经过改进形成了密钥交换技术和模交换技术。&lt;/p&gt;&lt;p&gt;在基于LWE（环LWE）的全同态加密方案中，密文乘积定义为两个密文&lt;strong&gt;&lt;em&gt;c&lt;/em&gt;&lt;/strong&gt;1和&lt;strong&gt;&lt;em&gt;c&lt;/em&gt;&lt;/strong&gt;2的张量&lt;strong&gt;&lt;em&gt;c&lt;/em&gt;&lt;/strong&gt;1&lt;strong&gt;&lt;em&gt;c&lt;/em&gt;&lt;/strong&gt;2，对应的密钥为&lt;strong&gt;&lt;em&gt;s.  &lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;按照这种形式的乘法定义，一方面，密文乘积将导致密文维数的膨胀，只能进行常数次的密文乘法计算；另一方面，同样面临着噪音在乘法中急剧增长的问题。解决这些问题，一方面通过使用密钥交换技术，可以将密文的维数还原到原来的维数，因此可以进行下一次密文的乘积；另一方面使用模交换技术，可以将增长的噪音约减回原来的噪音大小上。因此，不需要启动就可以获得层次型全同态加密方案(可以执行任意多项式深度的电路)，所以不再需要稀疏子集和问题假设和循环安全假设，这是全同态加密思想上的一次飞跃，打破了原有的Gentry构造框架，效率上也得到了极大地提升。目前效率最高的环-LWE上的BGV方案使用的就是这种构造方法&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2017-03-29-26078068</guid>
<pubDate>Wed, 29 Mar 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密释疑（三）：为什么不能运行自己的解密电路</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2017-03-10-25678103.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25678103&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面说过，要想降低密文计算带来的噪音，可以通过同态解密的方式得到一个新的密文，这个新密文的噪音是恒定的，所以使得我们可以进行下一次计算，每次计算后都通过同态解密约减噪音，就能够获得全同态加密了。然而同态解密是需要Evaluate算法能够运行自己的解密函数的，在早期的全同态加密方案中（Gentry09，DGHV），包括BV11方案如果最后一步不使用模维数约减的话，Evaluate都不能够运行自己的解密函数。&lt;/p&gt;&lt;p&gt;很多同学学到这里的时候，都很纳闷，解密函数不就是一些加法乘法模运算么，为什么计算不了，难道还有计算不了的函数？这个问题是问我的人最多的，今天给大家好好解释一下。&lt;/p&gt;&lt;p&gt;所谓的运行不了自己的解密函数，是有语境的，准确的说是“Evaluate算法不能够运行自己的解密函数”，而Evaluate算法的输入是什么？同态解密时，Evaluate算法输入的是解密电路，还有往解密电路里输入的一些密文，这些密文是由密钥和密文的每一位加密而成的，上次博文详细说过这事。那么Evaluate算法做的工作是什么呢？&lt;/p&gt;&lt;p&gt;Evaluate算法做的工作就是让这些密文在解密电路里计算，是密文的计算，记住了！由于密文计算过程会产生噪音，所以密文只能够进行有限次的计算，超过这个界就会产生解密的错误。所以如果&lt;strong&gt;解密电路的深度小于方案所允许计算的深度&lt;/strong&gt;（这里方案所允许计算的深度指的是Somewhat同态方案的计算能力），那么就可以完成同态解密的工作。但是如果解密电路的深度大于方案所允许计算的深度，那么就悲催了，我们就不能够使用同态解密这个方法去降低密文的噪音。怎么办？&lt;/p&gt;&lt;p&gt;Gentry在他的论文里发明了一种方法叫“压缩解密电路”，就是把解密电路的深度降低，从而满足“解密电路的深度小于方案所允许计算的深度”，这样就可以使用同态解密技术了，方案就可以启动了！压缩解密电路是要付出代价的，同时需要一个假设“稀疏子集和问题”，该问题没有被很好的研究过，所以是假设。不过目前的方案已经不需要压缩解密电路了，例如BGV方案，Bra12方案，这些方案都能够运行自己的解密电路，所以不需要压缩的方法了。&lt;/p&gt;&lt;p&gt;同态解密的技术成就了全同态加密的诞生，然而其效率却非常低，所以后面诞生了模交换技术。至于什么是模交换技术，下回分解。&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2017-03-10-25678103</guid>
<pubDate>Fri, 10 Mar 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>即生瑜，何生亮—MAC 地址与IP地址</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2017-03-05-25576156.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25576156&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      在教计算机网络课程中，经常会碰到这样的问题，为什么需要两个地址：一个是MAC(物理地址)，另一个是IP地址。各种解释都有，基本上一个观点就是一个是物理地址，一个是逻辑地址。然而，这样的解释太抽象，什么是物理，什么是逻辑。这些抽象的表述会让人无法理解到其本质。下面我就谈谈这个问题。&lt;/p&gt;&lt;p&gt;    要想说明这个问题，首先得说说计算机网络的目标是什么。计算机网络的根本目标就是将数据从一点传送到另外一点。听起来很简单，但是里面包含的意思很多。例如，两个点之间是在同一个网络还是跨网络连接的，如何才能将数据正确的传送到对方，如果出现错误怎么办等等。&lt;/p&gt;&lt;p&gt;     为了说明问题的本质，我们首先将问题简化：假设两点在一个网络内。在这种情况下，只需要MAC地址就可以了。例如通过交换机将多台电脑组成一个网络，为了找到对方，必须通过一个地址来标识。就像寄快递一样，如果没有地址，快递员是无法将快递送到对方的所在地的。这就是我们所说的MAC地址。当A点要将数据传递给B点时，会在数据的首部添加B的MAC地址，即目标地址。当然在首部中也有源地址，即发送方的MAC地址，还有其它一些信息，例如用于校验的等等。组装好的这个数据称为帧。然后A点就将帧通过网卡发送出去。&lt;/p&gt;&lt;p&gt;此时交换机收到这个帧后，查找自己的转发表。转发表主要有两列，一列是MAC地址，另外一列是该MAC地址对应的端口。查找的结果只有两种情况：找到或没找到。如果找到就将数据从该MAC对应的端口转发出去。如果没找到，很简单，交换机会把帧向所有端口广播（除了该帧进入的端口），因此肯定会有一个合适的端口收到的。这个广播的方法很粗暴，也很奏效。&lt;/p&gt;&lt;p&gt; 这就是MAC地址的作用。MAC地址是刻录在网卡这个物理设备上的，一般是无法改变的。&lt;/p&gt;&lt;p&gt;     然而，如果两点不在一个网络内。这时就需要IP地址了。因为IP地址含有两个部分，一个是网络地址，一个是主机地址。因此，通过对方的IP地址，是可以判断出对方是否和本机在一个网络内。如果在一个网络内，如上所述，只需要知道对方的MAC地址即可通信。&lt;/p&gt;&lt;p&gt;如果不在一个网络内，本机的网络层就认为数据应该发送给网关。道理是显然的，如果不在一个网络内，首先得把数据发送出网络才可以。如何发出网络，当然是发给网关，因为网关就相当于网络的门卫。要想把数据发给网关，同样需要知道网关的MAC地址，如何知道网关的MAC地址呢？这就涉及到ARP协议。&lt;/p&gt;&lt;p&gt;电脑缓存里有一张ARP表，该表主要有两列：一列是IP地址，另外一列是MAC地址。这张表不是天生就有的，是随着网卡收到网络中的各种通信数据，不断学习增加的。&lt;/p&gt;&lt;p&gt;话说回来，如果ARP表中有网关IP地址对应的MAC地址，则问题就转化为网内数据发送，上面已经讲的很清楚了。如果ARP表中没有网关IP地址对应的MAC地址，则启动ARP协议，即向网内广播，询问该IP地址的MAC地址。广播询问的结果是网关收到广播后，发现是问自己的MAC地址，所以就回复询问方自己的MAC地址。然后数据发给网关的问题，也转化为网内数据发送，上面已经讲的很清楚了。&lt;/p&gt;&lt;p&gt;大家发现没有，在跨网通信时是需要IP地址的。因为需要通过IP地址来判断是网内通信还是网外通信。有人可能会说，让MAC地址也具有能够区分网络的特征不就可以不需要IP了么。事实上这样做是不实际的。每个网卡出厂时就有一个独一无二的MAC地址，出场时是不可能知道你用它时是在哪一个网络里，也就是天生它就不具有能够区分网络的特性。而且也不需要它具有这种特性。因为MAC只负责设备到设备的通信就够了。这层通信是真正的通信，所以称为物理通信。&lt;/p&gt;&lt;p&gt;而跨网络传输数据时，需要考虑传输的路径，即为了到达目的地，下一跳应该去哪儿，从而一跳一跳的传输到目的地。而网内传输，不需要考虑传输路径，只要发出去一定可以到达。最坏情况下就是通过广播传输也能到达。而跨网络传输时，这一招不灵了。因此，跨网传输时需要考虑网络之间的传输，需要使用能够表示网络特征的地址，即IP地址。所以IP地址是负责网络到网络传输的。&lt;/p&gt;&lt;p&gt;至于发给网关后，下一步发给谁，本机就管不着了。本机只能保证在网络内传输，即下一跳的概念。下下一跳，只能由网关来负责了。其实网关就是路由器的一个接口。网关通过IP地址来确定路由，通过查找路由表来确定下一跳应该去往哪个网络，然后就将数据从连接那个网络的路由器的接口发送出去。发送出去同样要判断目标IP是和当前路由接口的网络是否同一网络。问题又回到上面讲的过程了。所以周而复始。&lt;/p&gt;&lt;p&gt;可见IP地址和MAC地址的概念并不矛盾。他们之间是不同层次的，就像有了领导还必须有群众才可以，谁也离不开谁。数据从一点传到另外一点，要经过几个网络，网络路线是怎样的，需要使用IP地址来解决。而网内传输需要使用MAC地址来传输。可见没有网内真正的通信传输，何以实现网络之间的通信。而如果没有网络路由的路径的话，数据是不可能到达目的地的，因为方向都没有。&lt;/p&gt;&lt;p&gt;如果再往深里挖掘，地址的概念还可以包括网址。就像百度的网址，我们为什么有了IP还需要网址呢？这超过了我们的题目范围，下次再说。&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2017-03-05-25576156</guid>
<pubDate>Sun, 05 Mar 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密释疑（二）：一个技术</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2017-02-19-25318032.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25318032&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在全同态加密（Fully Homomorphic Encryption）方案中，有一个非常重要技术：同态解密。&lt;/p&gt;&lt;p&gt;为什么要同态解密，前面说过噪音问题是实现全同态加密方案的最大障碍。Gentry在实现全同态加密方案时，注意到可以在Evaluate算法中执行自己的解密函数，那么输入的数据是什么呢？&lt;/p&gt;&lt;p&gt;解密函数当然输入的是密钥sk和密文c。但是不要忘了Evaluate算法是如何定义的。Evaluate算法是对输入的密文c1,c2,…执行函数 &lt;em&gt;f &lt;/em&gt;的操作，也就是对密文进行计算，其实隐含在其中的本质是对密文做同态计算，即计算后的密文解密后要等于对明文做同样的计算，如果这点做不到，那么Evaluate算法即使能对密文做很多次运算，也是没有意义的，这点一定要清楚。&lt;/p&gt;&lt;p&gt;这就是两种形态，明文态和密文态，两种形态对应的是同一个计算电路。在明文态，输入电路的是明文，而这些明文都是位（因为是布尔电路）。在密文态，输入电路的就是把每一个明文变成密文就可以了（算术电路）。这是我的独家比喻，版权所有。&lt;/p&gt;&lt;p&gt;而现在如果 &lt;em&gt;f &lt;/em&gt;是解密函数，那么输入的密文是什么呢？&lt;/p&gt;&lt;p&gt;只要看看明文态的时候输入的什么就知道了。&lt;/p&gt;&lt;p&gt;在明文态，对于解密电路，输入的肯定是密钥sk的每一位二进制位，以及密文c的每一位二进制位，因为是布尔电路，所以输入的数据都要化成二进制位的形式。&lt;/p&gt;&lt;p&gt;好了，现在在密文态，相应的把明文位变成密文就可以了，原来是一个位的地方现在变成了一个密文，那么将这些密文输入到解密电路中，结果是什么呢？是一个密文，这个密文解密后等于在明文态对明文做同样计算的结果。&lt;/p&gt;&lt;p&gt;现在我们关心的是这个从解密电路里出来的新密文和原来的密文c之间有什么关系？&lt;/p&gt;&lt;p&gt;这两个密文对应的是同样的明文。&lt;/p&gt;&lt;p&gt;而我们关心的是两个密文的噪音一样么？&lt;/p&gt;&lt;p&gt;肯定是不一样的，因为密文计算的噪音会随着计算次数不断增长。而从解密电路里出来的密文的噪音是一个固定值，是保持不变的。惊讶吧？&lt;/p&gt;&lt;p&gt;我们希望的是什么？是解密电路里出来的密文的噪音比原密文的噪音小么？&lt;/p&gt;&lt;p&gt;NO！我们要求没有这么高。我们只要求解密电路里出来的密文的噪音，还允许再进行一次乘法计算就可以了。&lt;/p&gt;&lt;p&gt;为什么？因为如果上面的要求成立的话，那么每次密文计算前，只要通过同态解密，出来的密文就可以保证再进行一次计算，不断循环下去，就可以做无限次计算了。当然要想做无限次计算还需要一个假设条件就是：循环安全。如果不做这个假设，我们只能做深度为L的电路计算。总之能够保证对密文做我们想要的计算了。&lt;/p&gt;&lt;p&gt;所以同态解密这个技术，是实现全同态加密的一个关键技术，Gentry就通过它实现了全同态加密。&lt;/p&gt;&lt;p&gt;要想使用同态解密，必须在Evaluate算法中能够执行自己的解密函数才可以。很多人都纳闷，解密函数不就是计算一下么，例如在整数方案里解密函数就是：(c mod p) mod2，在LWE或环-LWE上解密函数是：(&amp;lt;&lt;strong&gt;&lt;em&gt;c&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt;&amp;gt; mod &lt;em&gt;q&lt;/em&gt;) mod 2，难道不能够执行这些函数？&lt;/p&gt;&lt;p&gt;事情往往没有想象的那么简单，且听下回分解。&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2017-02-19-25318032</guid>
<pubDate>Sun, 19 Feb 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>何谓“格上最坏情况的困难性与平均情况的困难性”</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2017-02-19-25318016.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25318016&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;格上构建密码学方案的吸引力:最坏情况困难性与平均情况困难性的连接，Ajtai,96&lt;/h2&gt;&lt;br&gt;&lt;p&gt; 而密码学中的困难性需要的是：平均情况下的困难性。例如，如果随机选择的key，没有概率多项式时间的算法能够以不可忽略的概率破解该key。&lt;/p&gt;&lt;br&gt;&lt;p&gt; 而计算复杂论中的困难性是：最坏情况下的困难性。例如，没有多项式时间算法能够解决该问题的所有实例。即，任何多项式时间算法，存在某个实例无法解决。这对密码学是不够的：存在某个key其破解是困难的。即使不可忽略的很小一部分key能被破解，该方案也被认为是不安全的。&lt;/p&gt;&lt;br&gt;&lt;p&gt; 密码学函数的构造要求：在最坏情况下的标准计算复杂度假设下，密码学函数在平均情况下是可证明困难的。然而，对于目前的一些密码学方案，不仅要要在最坏情况下假设其困难，而且要在平均情况下假设其困难。例如，基于大整数分解的密码学方案。&lt;/p&gt;&lt;br&gt;&lt;p&gt; 最坏情况困难性与平均情况困难性的连接，Ajtai,96。说的是：对任何格及某个近似因子，如果没有算法能够解决近似SVP问题，则从一个特定的容易选取的分布中随机选取格时，SVP问题是困难的。而这里最重要的是发现了一个随机格（q元格），从随机格里选取的格，其上的格上标准困难问题例如SVP是困难的。&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2017-02-19-25318016</guid>
<pubDate>Sun, 19 Feb 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>全同态加密释疑（一）：四个算法（2）</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2017-02-08-25134045.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25134045&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;继续说全同态加密中的其他三个算法。&lt;/p&gt;&lt;br&gt;&lt;p&gt;Enc算法（加密）和我们平常意义的加密是一样的，但是在全同态加密的语境里，使用Enc算法加密的密文，一般称之为新鲜密文，即该密文是一个初始密文，没有和其他密文计算过。所以新鲜密文的噪音称之为初始噪音。这个相当重要。&lt;/p&gt;&lt;p&gt;Dec算法（解密）也和我们平常理解的一样，就是对密文的解密，但是这里解密算法不仅能对初始密文解密，还能够对计算后的密文解密。但是由于部分同态加密方案中密文存在噪音，例如在整数上的全同态加密方案里，密文乘积的噪音是噪音之积，密文加法的噪音是噪音之和。所以当密文计算到一定程度，其噪音将超过上限，所以对这样的密文解密将可能失败。全同态加密的关键就是对噪音的控制，使之能对任何密文解密。&lt;/p&gt;&lt;p&gt;最后一个算法：&lt;strong&gt;Evaluate&lt;/strong&gt;&lt;strong&gt;算法（密文计算），这个算法是整个全同态加密四个算法中的核心。&lt;/strong&gt;可以做个这样的比喻：前面三个算法是大楼的地基，后面这个Evaluate算法就是大楼。这个比喻在后面会体会到它的用意。密文的计算是在电路里进行的，电路是分层的，电路深度越深，层数越多，密文就能够进行更多次的计算。随便提一句，密文计算的次数等于电路深度的对数。什么是计算次数？例如c1*c2，就是进行了一次计算，次数为2，c1*c2*c3就是进行了两次计算，次数为3。在全同态加密中，我们一般用乘法次数来衡量计算次数，这是因为乘法的噪音比加法噪音增长的快很多。&lt;/p&gt;&lt;p&gt;Evaluate算法有三个输入，第一个输入是计算公钥Evk，就是我们在上次博文里讲到的。Evk可以没有。第二个输入是函数&lt;em&gt;f&lt;/em&gt;，就是Evaluate算法所要执行的函数，可以是任意函数，因为全同态加密的目标就是对密文能够进行任意计算。当然这个函数也可以是“解密函数”，Gentry通过观察发现了一个秘密，等会我们说。第三个输入是密文，理论上可以有无穷多个密文，但是这是不可能的。&lt;/p&gt;&lt;p&gt;所以Evaluate算法就是将密文输入到函数&lt;em&gt;f&lt;/em&gt;里进行计算。我们知道在全同态加密的方案里，密文都是含有噪音的，密文的计算会导致噪音的增长，如果把函数&lt;em&gt;f&lt;/em&gt;表示成电路，那么Evaluate算法实际上只能够对有限深度&lt;em&gt;L&lt;/em&gt;的电路进行计算，超过这个深度&lt;em&gt;L&lt;/em&gt;的电路就不行了。&lt;strong&gt;所以我们把这样的方案称之为部分同态加密方案&lt;/strong&gt;。由此可见Evaluate算法的重要性，全同态加密就靠它了。还记得刚才的比喻么？Evaluate算法相当于大楼，这个大楼的层数是有限的，而全同态加密的目标是无限高！&lt;/p&gt;&lt;p&gt;所以噪音问题导致了Evaluate算法不能够对任意电路（函数）进行计算。&lt;/p&gt;&lt;p&gt;而全同态加密追求的就是Evaluate算法能够对任意电路进行计算，怎么办？那只有控制噪音问题了。如何控制噪音呢？下回分解。&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2017-02-08-25134045</guid>
<pubDate>Wed, 08 Feb 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
