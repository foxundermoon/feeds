<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>全同态加密与区块链</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/</link>
<description>全同态加密具有神奇的功能，在不解密的情况下能够对密文进行任意计算。区块链能够在去中心化的环境下，保证数据的不可篡改、可追溯等。区块链+全同态加密=让我的数据属于我掌控。</description>
<language>zh-cn</language>
<lastBuildDate>Mon, 22 Oct 2018 06:02:37 +0800</lastBuildDate>
<item>
<title>200行代码编写自己的区块链－2</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2018-10-21-47289448.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/47289448&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-efd514c0c42c2fbd0a7de77a9427c205_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;这篇文章向您展示了如何编写自己的区块链，并完成哈希和每个新块的验证。但这一切都在一个单独的终端（节点）中运行。我们如何让另一个节点连接到我们的main中并让它们贡献新的块，我们如何将更新的区块链广播到所有其他节点？&lt;/p&gt;&lt;p&gt;我们马上回告诉你&lt;/p&gt;&lt;p&gt;工作流程&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4ddd49d6a04705b3350ebd956c2bdd7c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1730&quot; data-rawheight=&quot;1059&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-4ddd49d6a04705b3350ebd956c2bdd7c&quot; data-watermark-src=&quot;v2-e6fa186fb2fba5f6218d29809ec08d50&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;第一个终端创建一个创世建块和一个新节点可以连接的TCP服务器&lt;/p&gt;&lt;p&gt;第一步&lt;/p&gt;&lt;p&gt;打开其它终端，并与第一个终端建立TCP连接&lt;/p&gt;&lt;p&gt;新的终端给第一个终端写入一个块&lt;/p&gt;&lt;p&gt;第二步&lt;/p&gt;&lt;p&gt;第一个终端验证这个块&lt;/p&gt;&lt;p&gt;第一个终端将新的区块链广播给其它节点&lt;/p&gt;&lt;p&gt;第三步&lt;/p&gt;&lt;p&gt;所有的终端现在都又同步的区块链&lt;/p&gt;&lt;p&gt;在本教程之后，请自行尝试：让每个新终端充当具有不同TCP端口的“第一个”终端，并让其他终端连接到它以获得真正的网络！&lt;/p&gt;&lt;p&gt;你将可以做到&lt;/p&gt;&lt;p&gt;运行一个提供了创世区块的终端&lt;/p&gt;&lt;p&gt;根据需要启动多个附加终端，并让它们向第一个终端写入块&lt;/p&gt;&lt;p&gt;让第一终端广播更新的块给其它终端&lt;/p&gt;&lt;p&gt;你不能做到的&lt;/p&gt;&lt;p&gt;与上一篇文章一样，本教程的目的是让节点的基本网络正常工作，这样您就可以决定区块链之旅的位置。您将无法将其他网络中的计算机写入您的第一个终端，但这可以通过将您的二进制文件放入云端来实现。此外，区块链广播将被模拟到每个节点。别担心，我们很快就会解释所有这些。&lt;/p&gt;&lt;p&gt;让我们开始编码吧！&lt;/p&gt;&lt;p&gt;其中一些将是对最后一篇文章的回顾。我们将使用一些相同的块生成，哈希和验证函数。但我们不会使用任何的HTTP功能，因为我们将在控制台中查看结果，我们将使用TCP进行网络连接。&lt;/p&gt;&lt;p&gt;TCP和HTTP之间有什么不同&lt;/p&gt;&lt;p&gt;我们在这并不会详细介绍，但您需要知道的是TCP是一种传输数据的基本协议。HTTP建立在TCP之上，以在Web和浏览器中利用此数据传输。当您查看网站时，您正在使用HTTP，它受基础数据传输协议支持，我们称之为TCP。&lt;/p&gt;&lt;p&gt;在本教程中，我们将使用TCP，因为我们不需要在浏览器中查看任何内容。Go有一个很好的net包，它提供了我们需要的所有TCP的连接函数。&lt;/p&gt;&lt;p&gt;设置、导入和回顾&lt;/p&gt;&lt;p&gt;其中一些将是第1部分的评论。对于区块链生成和验证，我们将使用上一篇文章中的相同函数。在我们进行回顾时请耐心等待。别担心，我们很快就会看到新的东西！&lt;/p&gt;&lt;p&gt;设置&lt;/p&gt;&lt;p&gt;在根目录中创建一个.env文件并添加一行：&lt;/p&gt;&lt;p&gt;ADDR=9000&lt;/p&gt;&lt;p&gt;我们将要使用的TCP端口号（在本例中为9000）存储在一个名为ADDR的环境变量中。&lt;/p&gt;&lt;p&gt;如果你还没有做过，就去获取下列软件包：&lt;/p&gt;&lt;p&gt;go get github.com/davecgh/go-spew/spew 将我们的区块链打印到控制台&lt;/p&gt;&lt;p&gt;go get github.com/joho/godotenv在我们的.env文件中加载变量 &lt;/p&gt;&lt;p&gt;创建一个空的main.go文件。我们将把所有代码放在这里。&lt;/p&gt;&lt;p&gt;导入&lt;/p&gt;&lt;p&gt;让我们做我们的标准程序包声明并写入我们需要的输入。&lt;/p&gt;&lt;p&gt;package main&lt;/p&gt;&lt;p&gt;import (&lt;/p&gt;&lt;p&gt;&quot;bufio&quot;&lt;/p&gt;&lt;p&gt;&quot;crypto/sha256&quot;&lt;/p&gt;&lt;p&gt;&quot;encoding/hex&quot;&lt;/p&gt;&lt;p&gt;&quot;encoding/json&quot;&lt;/p&gt;&lt;p&gt;&quot;io&quot;&lt;/p&gt;&lt;p&gt;&quot;log&quot;&lt;/p&gt;&lt;p&gt;&quot;net&quot;&lt;/p&gt;&lt;p&gt;&quot;os&quot;&lt;/p&gt;&lt;p&gt;&quot;strconv&quot;&lt;/p&gt;&lt;p&gt;&quot;time&quot;&lt;/p&gt;&lt;p&gt;&quot;github.com/davecgh/go-spew/spew&quot;&lt;/p&gt;&lt;p&gt;&quot;github.com/joho/godotenv&quot;&lt;/p&gt;&lt;p&gt;)&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/72395bcc58175a7beab520b005cc6879/raw/a73625f1d84c8cc372d888c0fa66c4835f92cc78/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/72395bcc58175a7beab520b005cc6879#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;以下代码片段在第1部分中有更详细的解释。如果您需要复习，请参考它。我们将快速通过这段。&lt;/p&gt;&lt;p&gt;让我们创建我们的块结构并声明区块链是一种块的累积。&lt;/p&gt;&lt;p&gt;// Block represents each &#39;item&#39; in the blockchain&lt;/p&gt;&lt;p&gt;type Block struct {&lt;/p&gt;&lt;p&gt;Index int&lt;/p&gt;&lt;p&gt;Timestamp string&lt;/p&gt;&lt;p&gt;BPM int&lt;/p&gt;&lt;p&gt;Hash string&lt;/p&gt;&lt;p&gt;PrevHash string&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;// Blockchain is a series of validated Blocks&lt;/p&gt;&lt;p&gt;var Blockchain []Block&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/669357dabf97ea74d5bed574fd139683/raw/22c048323c892779b7b9f64522eb5aa7c2b91ceb/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/669357dabf97ea74d5bed574fd139683#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;现在创建我们在生成新块时需要的哈希函数。&lt;/p&gt;&lt;p&gt;// SHA256 hashing&lt;/p&gt;&lt;p&gt;func calculateHash(block Block) string {&lt;/p&gt;&lt;p&gt;record := string(block.Index) + block.Timestamp + string(block.BPM) + block.PrevHash&lt;/p&gt;&lt;p&gt;h := sha256.New()&lt;/p&gt;&lt;p&gt;h.Write([]byte(record))&lt;/p&gt;&lt;p&gt;hashed := h.Sum(nil)&lt;/p&gt;&lt;p&gt;return hex.EncodeToString(hashed)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/012ac62ee08fafb86c14b1ed9ee7648b/raw/d350ea711fbe6c5fdb7aa1f6a67c6bc796bb8f05/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/012ac62ee08fafb86c14b1ed9ee7648b#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们的块生成函数：&lt;/p&gt;&lt;p&gt;// create a new block using previous block&#39;s hash&lt;/p&gt;&lt;p&gt;func generateBlock(oldBlock Block, BPM int) (Block, error) {&lt;/p&gt;&lt;p&gt;var newBlock Block&lt;/p&gt;&lt;p&gt;t := time.Now()&lt;/p&gt;&lt;p&gt;newBlock.Index = oldBlock.Index + 1&lt;/p&gt;&lt;p&gt;newBlock.Timestamp = t.String()&lt;/p&gt;&lt;p&gt;newBlock.BPM = BPM&lt;/p&gt;&lt;p&gt;newBlock.PrevHash = oldBlock.Hash&lt;/p&gt;&lt;p&gt;newBlock.Hash = calculateHash(newBlock)&lt;/p&gt;&lt;p&gt;return newBlock, nil&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/6b5835fb9872b4fb832aa00243afba07/raw/aaa3ed0f2fc858ef9c87e9c7775211bc917dec89/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/6b5835fb9872b4fb832aa00243afba07#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;通过检查区块的PrevHash值和前一个区块的Hsah值来确保我们的区块是有效的&lt;/p&gt;&lt;p&gt;// make sure block is valid by checking index, and comparing the hash of   the previous block&lt;/p&gt;&lt;p&gt;func isBlockValid(newBlock, oldBlock Block) bool {&lt;/p&gt;&lt;p&gt;if oldBlock.Index+1 !=   newBlock.Index {&lt;/p&gt;&lt;p&gt;return false&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;if oldBlock.Hash !=   newBlock.PrevHash {&lt;/p&gt;&lt;p&gt;return false&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;if calculateHash(newBlock) != newBlock.Hash   {&lt;/p&gt;&lt;p&gt;return false&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;return true&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/2fadb1ccb5da8307df9bd614bfb9524b/raw/827a647b8471efaedcaae84e6575e066368a6f9f/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/2fadb1ccb5da8307df9bd614bfb9524b#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;现在我们确保将最长的链作为真正的区块链：&lt;/p&gt;&lt;p&gt;/ make sure the chain we&#39;re checking is longer than the current blockchain&lt;/p&gt;&lt;p&gt;func replaceChain(newBlocks []Block) {&lt;/p&gt;&lt;p&gt;if len(newBlocks) &amp;gt; len(Blockchain)   {&lt;/p&gt;&lt;p&gt;Blockchain = newBlocks&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/3a9b9a2cd3fa225f18ed710e34d2f1ad/raw/405ebdd1e431a1922d98927f92fdc522ff59ffb3/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/3a9b9a2cd3fa225f18ed710e34d2f1ad#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;太好了！我们基本上已经获得了需要的的所有与区块链相关的函数，并且第1部分中的所有HTTP相关内容都被删除了。我们现在可以进入网络。&lt;/p&gt;&lt;p&gt;网络通信&lt;/p&gt;&lt;p&gt;最后！我么已经准备的差不多了。让我们建立一个网络，它可以传递新的块，将它们整合到我们的区块链中，并将新的区块链广播回网络。&lt;/p&gt;&lt;p&gt;让我们从我们的main函数开始，因为这是一个很好的概念，可以帮助我们理解整体流程。&lt;/p&gt;&lt;p&gt;在我们这样做之前，让我们在我们的其他结构声明下声明一个名为bcServer（区块链服务器的简称）的全局变量，这是一个接收传入块的channel。&lt;/p&gt;&lt;p&gt;// bcServer handles incoming concurrent Blocks&lt;/p&gt;&lt;p&gt;var bcServer chan []Block&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/d64fafebd1b45e57587ce1a9d73ffd65/raw/0b6934b99a97e509f2c03d9d0a3ffd6a9cce7f38/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/d64fafebd1b45e57587ce1a9d73ffd65#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;旁注：channel是Go最受欢迎的功能之一，可以优雅地简化数据读/写，最常用于防止数据竞争。它们在并发使用时变得特别强大，因为多个Goroutine可以写入同一个channel。传统上使用Java和其他类C语言，您必须通过互斥体打开和关闭传入数据的“门”。Go中的channel使这更容易，尽管Go中的某些位置仍然存在互斥体。学习更多关于channel的知识可以点这里。&lt;/p&gt;&lt;p&gt;现在让我们声明我们的main函数并从我们位于根目录中的.env文件中加载环境变量 。请记住，唯一的环境变量就是ADDR，它的TCP端口号9000，我们将很快使用它。另外，让我们在main函数中实例化我们的bcServer。&lt;/p&gt;&lt;p&gt;func main() {&lt;/p&gt;&lt;p&gt;err := godotenv.Load()&lt;/p&gt;&lt;p&gt;if err != nil {&lt;/p&gt;&lt;p&gt;log.Fatal(err)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;bcServer = make(chan []Block)&lt;/p&gt;&lt;p&gt;// create genesis block&lt;/p&gt;&lt;p&gt;t := time.Now()&lt;/p&gt;&lt;p&gt;genesisBlock := Block{0, t.String(), 0, &quot;&quot;, &quot;&quot;}&lt;/p&gt;&lt;p&gt;spew.Dump(genesisBlock)&lt;/p&gt;&lt;p&gt;Blockchain = append(Blockchain, genesisBlock)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/5dd05d1ca28778ae46297048bb8554d2/raw/cea2768c0a198b146c595282fa605baf79b0d499/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/5dd05d1ca28778ae46297048bb8554d2#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;现在我们需要编写我们的TCP服务器。请记住，您可以将TCP服务器视为与HTTP服务器类似，但没有浏览器组件。所有数据传输都将通过我们的终端在控制台中完成。我们将处理与TCP端口的多个连接。将这些添加到main函数的最后一行下方。&lt;/p&gt;&lt;p&gt;// start TCP and serve TCP server&lt;/p&gt;&lt;p&gt;server, err := net.Listen(&quot;tcp&quot;, &quot;:&quot;+os.Getenv(&quot;ADDR&quot;))&lt;/p&gt;&lt;p&gt;if err != nil {&lt;/p&gt;&lt;p&gt;log.Fatal(err)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;defer server.Close()&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/6a1f412a6fe80dc15b82587862876370/raw/c1f742d4a3489f3127a8f4c6c15d85def9c76c2d/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/6a1f412a6fe80dc15b82587862876370#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这将在端口9000处激活我们的TCP服务器。重要的是defer server.Close()，当我们不再需要它时，它会把连接快速关闭。在此了解更多defer 信息。&lt;/p&gt;&lt;p&gt;现在我们需要在每次收到连接请求时创建一个新连接，我们需要提供它。在最后一行下面添加这个。&lt;/p&gt;&lt;p&gt;for {&lt;/p&gt;&lt;p&gt;conn, err := server.Accept()&lt;/p&gt;&lt;p&gt;if err != nil {&lt;/p&gt;&lt;p&gt;log.Fatal(err)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;go handleConn(conn)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/40a8c240b5f941369f2a8cfb3e11a2bd/raw/63b0e1ed92306e852cdd5c9d014bda7838a9ab50/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/40a8c240b5f941369f2a8cfb3e11a2bd#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们只是在一个无限循环中接受新的连接。我们希望通过GoRoutine中的go handleConn(conn)单独处理程序同时处理每个连接，因此我们不会阻塞我们的for循环。这就是我们如何同时提供多个连接。&lt;/p&gt;&lt;p&gt;敏锐的读者会跳起来说，“嘿等等！我们没有handleConn函数！“ 你说的对。但是，让我们缓一下。你做的很棒，我们刚写完了整个主函数。它看起来像这样：&lt;/p&gt;&lt;p&gt;func main() {&lt;/p&gt;&lt;p&gt;err := godotenv.Load()&lt;/p&gt;&lt;p&gt;if err != nil {&lt;/p&gt;&lt;p&gt;log.Fatal(err)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;bcServer = make(chan []Block)&lt;/p&gt;&lt;p&gt;// create genesis block&lt;/p&gt;&lt;p&gt;t := time.Now()&lt;/p&gt;&lt;p&gt;genesisBlock := Block{0, t.String(), 0, &quot;&quot;, &quot;&quot;}&lt;/p&gt;&lt;p&gt;spew.Dump(genesisBlock)&lt;/p&gt;&lt;p&gt;Blockchain = append(Blockchain, genesisBlock)&lt;/p&gt;&lt;p&gt;// start TCP and serve TCP server&lt;/p&gt;&lt;p&gt;server, err := net.Listen(&quot;tcp&quot;, &quot;:&quot;+os.Getenv(&quot;ADDR&quot;))&lt;/p&gt;&lt;p&gt;if err != nil {&lt;/p&gt;&lt;p&gt;log.Fatal(err)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;defer server.Close()&lt;/p&gt;&lt;p&gt;for {&lt;/p&gt;&lt;p&gt;conn, err := server.Accept()&lt;/p&gt;&lt;p&gt;if err != nil {&lt;/p&gt;&lt;p&gt;log.Fatal(err)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;go handleConn(conn)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/b50624054da55d036b150bac88242013/raw/690f8c5acf388a7917cf6ea36d5d17421184e177/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/b50624054da55d036b150bac88242013#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们现在写下这个handleConn函数吧。它只需要一个参数，一个打包好的net.Conn接口。Go中的接口是让人惊奇的，在我们看来，这就是Go与其他所有基于C语言的区别。并发和GoRoutine得到了所有的宣传，但接口隐含满足的事实是它们才是这个语言最强大的功能。如果您尚未在Go中使用接口，请尽快熟悉它们。接口是您成为10x Go开发人员的下一步！&lt;/p&gt;&lt;p&gt;放入函数的框架，并使用干净的defer语句将其启动，以便在完成后关闭每个连接。&lt;/p&gt;&lt;p&gt;func handleConn(conn net.Conn) {&lt;/p&gt;&lt;p&gt;defer conn.Close()&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/97f59bb622dd70294fef5c90c285ea61/raw/97e5ab845ef9f0547c1a32f199b6de4f1643eeb6/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/97f59bb622dd70294fef5c90c285ea61#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;现在我们需要允许用户端添加新块以便我们整合到区块链中。我们将使用第1部分中相同的脉冲速率。记下你每分钟的脉搏速率并将这个数字保留在脑中。这将是我们的BPM（每分钟心脏跳动数）。&lt;/p&gt;&lt;p&gt;要实现上述目标，我们需要：&lt;/p&gt;&lt;p&gt;提示用户输入他们的BPM&lt;/p&gt;&lt;p&gt;扫描来自stdin的用户输入&lt;/p&gt;&lt;p&gt;使用之前创建的generateBlock，isBlockValid和replaceChain函数，用这个数据创造一个新的区块&lt;/p&gt;&lt;p&gt;将新的区块链放在我们创建的channel中，以便向网络广播&lt;/p&gt;&lt;p&gt;允许用户输入新的BPM&lt;/p&gt;&lt;p&gt;以下是按照上述确切顺序执行此操作的代码&lt;/p&gt;&lt;p&gt;io.WriteString(conn, &quot;Enter   a new BPM:&quot;)&lt;/p&gt;&lt;p&gt;scanner := bufio.NewScanner(conn)&lt;/p&gt;&lt;p&gt;// take in BPM from stdin and add it to blockchain after conducting   necessary validation&lt;/p&gt;&lt;p&gt;go func() {&lt;/p&gt;&lt;p&gt;for scanner.Scan() {&lt;/p&gt;&lt;p&gt;bpm, err := strconv.Atoi(scanner.Text())&lt;/p&gt;&lt;p&gt;if err != nil {&lt;/p&gt;&lt;p&gt;log.Printf(&quot;%v not a number: %v&quot;, scanner.Text(), err)&lt;/p&gt;&lt;p&gt;continue&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;newBlock, err := generateBlock(Blockchain[len(Blockchain)-1], bpm)&lt;/p&gt;&lt;p&gt;if err != nil {&lt;/p&gt;&lt;p&gt;log.Println(err)&lt;/p&gt;&lt;p&gt;continue&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;if isBlockValid(newBlock,   Blockchain[len(Blockchain)-1]) {&lt;/p&gt;&lt;p&gt;newBlockchain := append(Blockchain, newBlock)&lt;/p&gt;&lt;p&gt;replaceChain(newBlockchain)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;bcServer &amp;lt;- Blockchain&lt;/p&gt;&lt;p&gt;io.WriteString(conn, &quot;\nEnter   a new BPM:&quot;)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;}()&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/54d871590137d5ed12edd2b8b755e1eb/raw/2ff4bbeef97b12c47a590e26b8fb00aed6e522b9/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/54d871590137d5ed12edd2b8b755e1eb#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们创建了一个新的scanner，该for scanner.Scan()循环隐藏在自己的Go routine中，因此它可以从其他连接处并行或单独运行。我们对BPM进行快速字符串转换（它总是一个整数，所以我们检查一下）。我们做了我们的标准块生成和验证检查，并使用新块创建新的区块链。&lt;/p&gt;&lt;p&gt;bcServer &amp;lt;- Blockchain语句只是意味着我们将新的区块链扔进我们创建的channel。然后我们提示用户输入新的BPM以创建下一个块。&lt;/p&gt;&lt;p&gt;广播&lt;/p&gt;&lt;p&gt;我们需要将新的区块链广播到我们的TCP服务器所服务的所有连接。由于我们在一台计算机上对其进行编码，因此我们将模拟数据如何传输到所有客户端。在最后一行代码下的相同的handleConn函数中，我们需要：&lt;/p&gt;&lt;p&gt;将我们的新区块链转换为JSON，以便我们可以很好地阅读它&lt;/p&gt;&lt;p&gt;将新的区块链写入我们每个连接的控制台&lt;/p&gt;&lt;p&gt;设置一个定时器来定期执行此操作，这样我们就不会被区块链数据所淹没。这也是您在实时区块链网络中看到的，每隔X分钟就会广播新的区块链。我们将使用30秒&lt;/p&gt;&lt;p&gt;将主要区块链打印到第一个终端，这样我们就可以看到正在发生的事情并确保不同节点添加的块确实被集成到主区块链中&lt;/p&gt;&lt;p&gt;下面的就是按照这个准确顺序的编码：&lt;/p&gt;&lt;p&gt;// simulate receiving broadcast&lt;/p&gt;&lt;p&gt;go func() {&lt;/p&gt;&lt;p&gt;for {&lt;/p&gt;&lt;p&gt;time.Sleep(30 * time.Second)&lt;/p&gt;&lt;p&gt;output, err := json.Marshal(Blockchain)&lt;/p&gt;&lt;p&gt;if err != nil {&lt;/p&gt;&lt;p&gt;log.Fatal(err)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;io.WriteString(conn, string(output))&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;}()&lt;/p&gt;&lt;p&gt;for _ = range bcServer {&lt;/p&gt;&lt;p&gt;spew.Dump(Blockchain)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/a25e740219c2329a8c3f2da65e797357/raw/62e0673284fed85375a14a30e06849e8e8cf97c1/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/a25e740219c2329a8c3f2da65e797357#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;太好了！我们的handleConn函数也已经完成。事实上，整个计划已经完成，我们已将其保持在200行以下。这一点都不错，是吗？&lt;/p&gt;&lt;p&gt;在这里查看完成的代码！&lt;/p&gt;&lt;p&gt;有意思的地方&lt;/p&gt;&lt;p&gt;我们来试试吧！让我们通过转到我们的目录启动我们的应用程序go run main.go&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ae0cf47fb550dc76b384d07e7273643f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1729&quot; data-rawheight=&quot;376&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ae0cf47fb550dc76b384d07e7273643f&quot; data-watermark-src=&quot;v2-3f3b745bdc431e763dfcdd5550bec84a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;正如所料，我们看到了我们的创世块。同时发生的事情是我们在端口9000启动了一个可以接入多个连接的TCP服务器。所以，让我们这样做。&lt;/p&gt;&lt;p&gt;打开一个新的终端窗口并用nc localhost 9000连接到我们的TCP服务器 。我们将使用不同的颜色终端来明确这些不同的客户端。通过几个终端会话执行此操作几次以激活多个客户端。&lt;/p&gt;&lt;p&gt; 现在输入BPM到任意客户端。真棒！我们看到新的块添加到第一个终端！网络在运行！&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-986aa0345d058db73653afc5fe281394_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1728&quot; data-rawheight=&quot;651&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-986aa0345d058db73653afc5fe281394&quot; data-watermark-src=&quot;v2-ff65e2af73457f5f77526cca4b5009bc&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;从这得到的结果真的很酷。等30秒，转到其他客户端，您将看到新的区块链广播给所有客户，即使这些客户从未输入过BPM！&lt;/p&gt;&lt;p&gt;下一步&lt;/p&gt;&lt;p&gt;恭喜！您不仅可以从上一个教程创建自己的区块链，现在还可以为其添加网络功能。你可以从下面的建议里再学习：&lt;/p&gt;&lt;p&gt;要在本地环境中运行更大的网络，请创建多个目录，这些目录包含每个具有不同TCP端口的应用程序副本。对于每个终端会话，请提供TCP端口并连接到另一个端口，以便您可以接收和发送数据。&lt;/p&gt;&lt;p&gt;连接从多个端口流式传输的数据。这是另一个教程的主题，但很容易完成。&lt;/p&gt;&lt;p&gt;这都是区块链网络。它需要接收输入数据并在外部广播数据。在单个终端会话中进行这两种操作都是一种有效的挖矿设置。&lt;/p&gt;&lt;p&gt;如果您想与朋友一起尝试，请使用您最喜欢的托管服务提供商在云端设置服务器。让你的朋友连接到它并发送数据。此处还有一些额外的安全注意事项。如果有需求，我们也会为此编写一个教程。&lt;/p&gt;&lt;p&gt;您正在密切了解区块链的多个方面。从这里开始，我们建议您阅读共识机制的算法，如工作量证明或权益证明。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;===============================================================&lt;br&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&quot;&gt;http://weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&lt;/a&gt;&lt;/b&gt; &lt;b&gt;(二维码自动识别)&lt;/b&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)“&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2018-10-21-47289448</guid>
<pubDate>Sun, 21 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>200行代码编写自己的区块链</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2018-10-21-47289171.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/47289171&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-efd514c0c42c2fbd0a7de77a9427c205_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt; 世界上几乎每个开发人员都听说过区块链，但大多数仍然不知道它是如何工作的。他们可能仅仅是因为比特币才知道它，因为他们听说过智能合约之类的东西。这篇文章试图帮助你用Go语言来写一个简单的区块链来弄清楚区块链，而这只需要不到200行代码。在这篇教程结束时，你将能够在本地运行和写入区块链并且用Web浏览器查看它。&lt;/p&gt;&lt;p&gt;有什么能比开发一个自己的区块更好学习了解区块链的方法？&lt;/p&gt;&lt;p&gt;你将可以做到&lt;/p&gt;&lt;p&gt; 建造你自己的区块链&lt;/p&gt;&lt;p&gt; 了解hash如何在保持区块完整性&lt;/p&gt;&lt;p&gt; 了解如何添加新区快&lt;/p&gt;&lt;p&gt;了解多个节点如何竞争生成块&lt;/p&gt;&lt;p&gt;用web浏览器查看你的区块链&lt;/p&gt;&lt;p&gt;写新的区块&lt;/p&gt;&lt;p&gt;了解区块链的基本知识，以便你可以从这里决定你的旅程&lt;/p&gt;&lt;p&gt;你将无法做到的&lt;/p&gt;&lt;p&gt;为了使这篇文章变得简单，我们将不会处理更高级的共识概念，例如工作证明与权益证明。将模拟网络交互，以便您可以查看区块链并查看添加的块，但网络广播将保留用于下一篇的文章里。&lt;/p&gt;&lt;p&gt;让我们开始吧&lt;/p&gt;&lt;p&gt;设置&lt;/p&gt;&lt;p&gt;由于我们将在Go中编写代码，因此我们假设您已经拥有Go的一些开发经验。经过安装和配置Go语言，我们还想获取以下软件包：&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;go get github.com/davecgh/go-spew/spew&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Spew允许我们在console中清楚地查看structs和slices地格式，这很好。&lt;/p&gt;&lt;p&gt;go get github.com/gorilla/mux&lt;/p&gt;&lt;p&gt;Gorilla / mux是一个流行的用于编写Web处理器的程序包，我们需要这个。&lt;/p&gt;&lt;p&gt;go get github.com/joho/godotenv&lt;/p&gt;&lt;p&gt;Godotenv允许我们读取保存在根目录中的.env文件，这样我们就不必硬编码如http端口之类的东西。我们也需要这个。&lt;/p&gt;&lt;p&gt;让我们在根目录中创建一个.env文件，定义了将为HTTP请求服务的端口。就只要在这个文件中加一行：&lt;/p&gt;&lt;p&gt;  ADDR=8080&lt;/p&gt;&lt;p&gt;创建一个main.go文件。从现在开始，所有内容都将写入此文件，并且将少于200行代码。让我们来编码吧！&lt;/p&gt;&lt;p&gt;输入&lt;/p&gt;&lt;p&gt;以下是我们需要的输入以及我们的程序包说明。让我们把这些写进main.go里。&lt;/p&gt;&lt;p&gt;package main&lt;/p&gt;&lt;p&gt;import (&lt;/p&gt;&lt;p&gt;&quot;crypto/sha256&quot;&lt;/p&gt;&lt;p&gt;&quot;encoding/hex&quot;&lt;/p&gt;&lt;p&gt;&quot;encoding/json&quot;&lt;/p&gt;&lt;p&gt;&quot;io&quot;&lt;/p&gt;&lt;p&gt;&quot;log&quot;&lt;/p&gt;&lt;p&gt;&quot;net/http&quot;&lt;/p&gt;&lt;p&gt;&quot;os&quot;&lt;/p&gt;&lt;p&gt;&quot;time&quot;&lt;/p&gt;&lt;p&gt;&quot;github.com/davecgh/go-spew/spew&quot;&lt;/p&gt;&lt;p&gt;&quot;github.com/gorilla/mux&quot;&lt;/p&gt;&lt;p&gt;&quot;github.com/joho/godotenv&quot;&lt;/p&gt;&lt;p&gt;)&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/31eb4dea07973985c05ab61860ba11c8/raw/3244b4ec43fd7d4fd7b5e133a4aa86ade3329de1/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/31eb4dea07973985c05ab61860ba11c8#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;数据模型&lt;/p&gt;&lt;p&gt;让我们定义要组成区块链的每一个块的struct。别担心，我们将在一分钟内解释所有这些字段的含义。&lt;/p&gt;&lt;p&gt;type Block struct {&lt;/p&gt;&lt;p&gt;Index int&lt;/p&gt;&lt;p&gt;Timestamp string&lt;/p&gt;&lt;p&gt;BPM int&lt;/p&gt;&lt;p&gt;Hash string&lt;/p&gt;&lt;p&gt;PrevHash string&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/6319c092b8a8c49a101318158d50efb6/raw/bc4054c8caa363f8a16a94d2b4461d77418864ec/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/6319c092b8a8c49a101318158d50efb6#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;每个区块都包含将要被写入区块链的数据并且代表了当你采用脉搏速率时的每一种情况（还记得你在文章开头时做的吗？）&lt;/p&gt;&lt;p&gt;Index 是这个块在区块链中的位置&lt;/p&gt;&lt;p&gt;Timestamp 是自动确定的，也是数据写入的时间&lt;/p&gt;&lt;p&gt;BPM 或每分钟心脏跳动，是你的脉搏速率&lt;/p&gt;&lt;p&gt;Hash 是表示此数据记录的SHA256标识符&lt;/p&gt;&lt;p&gt;PrevHash 是链中先前记录的SHA256标识符&lt;/p&gt;&lt;p&gt;让我们来模拟区块链本身，这是一个简单区块的slice&lt;/p&gt;&lt;p&gt;var Blockchain []Block&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/9668956ac40a7098cf2bab6379ec9266/raw/1d0b30ebe665ebc8f9ea419ec455580552057c3c/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/9668956ac40a7098cf2bab6379ec9266#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;那么散列值如何适应区块和区块链？我们用hash来确认和保持区块在一个正确的顺序当中。通过确定每个区块的父区块哈希值与之前一个区块的哈希值是完全相同的，我们就知道区块以正确的顺序组成了块链。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-db3f6e5982ce6e4b565fdb689ffa0a27_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;429&quot; data-rawheight=&quot;130&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-db3f6e5982ce6e4b565fdb689ffa0a27&quot; data-watermark-src=&quot;v2-5f98ff640c4464429c153c41a3916317&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;散列和生成新的区块&lt;/p&gt;&lt;p&gt;那么为什么我们需要哈希？我们哈希数据有两个主要原因：&lt;/p&gt;&lt;p&gt;为了节省空间。哈希值来自区块上的所有数据。在我们的例子中，我们只有几个数据点，但想象若我们有数百，数千或数百万个先前块的数据。将数据散列到单个SHA256字符串或散列哈希将比一遍又一遍地复制前面块中的所有数据要高效得多。&lt;/p&gt;&lt;p&gt;保持区块链的完整性。通过像我们在上图中那样存储先前的哈希值，我们能够确保区块链中的块的顺序正确。如果恶意的一方进入并试图操纵数据（例如，改变我们的心率来修复人寿保险价格），哈希会迅速变化，链条会“破裂”，每个人都会知道不信任恶意链。&lt;/p&gt;&lt;p&gt;让我们编写一个函数来获取我们的区块数据并创建它的SHA256哈希值。&lt;/p&gt;&lt;p&gt;func calculateHash(block Block) string {&lt;/p&gt;&lt;p&gt;record := string(block.Index) + block.Timestamp + string(block.BPM) + block.PrevHash&lt;/p&gt;&lt;p&gt;h := sha256.New()&lt;/p&gt;&lt;p&gt;h.Write([]byte(record))&lt;/p&gt;&lt;p&gt;hashed := h.Sum(nil)&lt;/p&gt;&lt;p&gt;return hex.EncodeToString(hashed)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/a4953a59257c21fc706319fadc6b9ac1/raw/976a0d992a0f8bac7ddc57a743a15ce1bf1ce377/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/a4953a59257c21fc706319fadc6b9ac1#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这个calculateHash函数连接了我们提供的Index，Timestamp，BPM，和区块的PrevHash作为参数，并计算出SHA256哈希值。现在我们可以用一个新的generateBlock函数生成一个包含我们所有需要元素的区块。我们需要提供一个以前的区块以便我们可以在BPM里得到它的哈希值和我们的脉搏速率。不用担心 BPM int 参数的传入。我们将在之后处理它。&lt;/p&gt;&lt;p&gt;func generateBlock(oldBlock Block, BPM int) (Block, error) {&lt;/p&gt;&lt;p&gt;var newBlock Block&lt;/p&gt;&lt;p&gt;t := time.Now()&lt;/p&gt;&lt;p&gt;newBlock.Index = oldBlock.Index + 1&lt;/p&gt;&lt;p&gt;newBlock.Timestamp = t.String()&lt;/p&gt;&lt;p&gt;newBlock.BPM = BPM&lt;/p&gt;&lt;p&gt;newBlock.PrevHash = oldBlock.Hash&lt;/p&gt;&lt;p&gt;newBlock.Hash = calculateHash(newBlock)&lt;/p&gt;&lt;p&gt;return newBlock, nil&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/962b6150bd204c5c9ed83d8b58912256/raw/7e238484bf7e4431671ea06653c04bce9f5627db/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/962b6150bd204c5c9ed83d8b58912256#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 请注意，当前时间会自动写入区块中的time.Now()。还要注意我们之前的calculateHash函数被调用了。PrevHash从前一个块的哈希值中复制而来。Index则是从前一个块的索引递增而得出。&lt;/p&gt;&lt;p&gt;块验证&lt;/p&gt;&lt;p&gt;现在我们需要编写一些函数来确保块没有被篡改。我们通过检查Index来确保它们按预期增加。我们还检查以确保我们的PrevHash确实与前一个块的Hash相同。最后，我们想通过在当前块上再次运行calculateHash函数来仔细检查当前块的哈希值。让我们编写一个isBlockValid函数来完成所有这些事情并返回一个bool。如果通过我们的所有检查，它将返回一个真值：&lt;/p&gt;&lt;p&gt;func isBlockValid(newBlock, oldBlock Block) bool {&lt;/p&gt;&lt;p&gt;if oldBlock.Index+1 !=   newBlock.Index {&lt;/p&gt;&lt;p&gt;return false&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;if oldBlock.Hash !=   newBlock.PrevHash {&lt;/p&gt;&lt;p&gt;return false&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;if calculateHash(newBlock) !=   newBlock.Hash {&lt;/p&gt;&lt;p&gt;如果我们遇到一个问题，即我们的区块链生态系统的两个节点都在其链条中添加了块，而我们都收到了它们。我们选择哪一个作为真相的来源？我们选择最长的链条。这是一个经典的区块链问题，与恶意的人员没有任何关系。&lt;/p&gt;&lt;p&gt;两个具有良好意义的节点可能只是具有不同的链长，因此自然地，较长的节点将是最新的并且具有最新的块。因此，让我们确保我们所采用的新链比我们现有的链更长。如果是，我们可以使用具有新块的新链覆盖我们的链。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c20f20251bdcd0d81cfaa706bfa981ec_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;416&quot; data-rawheight=&quot;198&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c20f20251bdcd0d81cfaa706bfa981ec&quot; data-watermark-src=&quot;v2-724bf40782611eec79e88913f6213561&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们只需比较链的slice的长度即可：&lt;/p&gt;&lt;p&gt;func replaceChain（newBlocks [] Block）{&lt;/p&gt;&lt;p&gt;if len（newBlocks）&amp;gt; len（Blockchain）{&lt;/p&gt;&lt;p&gt;Blockchain = newBlocks&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/1b440f7c2be24140c45a9bf0ed8a9520/raw/f96ee91c97141f495ae2fade1b658e6df961ec19/main.go&quot;&gt;查看&lt;/a&gt;&lt;/b&gt;由&lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;用❤托管的&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/1b440f7c2be24140c45a9bf0ed8a9520/raw/f96ee91c97141f495ae2fade1b658e6df961ec19/main.go&quot;&gt;raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/1b440f7c2be24140c45a9bf0ed8a9520#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果你已经做到了这一步，那就赞扬一下自己吧！我们已经基本上写出了区块链的精髓和我们需要的各种函数。&lt;/p&gt;&lt;p&gt;现在我们想要一种方便的方式来查看我们的区块链并写入它，理想情况是在web浏览器中，这样我们就可以向朋友展示！&lt;/p&gt;&lt;p&gt; web服务器&lt;/p&gt;&lt;p&gt; 我们假设你已经熟悉web服务器是如何运作的，并且在Go语言中有一些经验。我们现在讲给你解释整个过程。&lt;/p&gt;&lt;p&gt;我们将使用您之前下载的Gorilla / mux软件包来为我们做些繁重的工作。&lt;/p&gt;&lt;p&gt;让我们在稍后调用的run函数中创造我们的服务器。&lt;/p&gt;&lt;p&gt;func run() error {&lt;/p&gt;&lt;p&gt;mux := makeMuxRouter()&lt;/p&gt;&lt;p&gt;httpAddr := os.Getenv(&quot;ADDR&quot;)&lt;/p&gt;&lt;p&gt;log.Println(&quot;Listening on &quot;, os.Getenv(&quot;ADDR&quot;))&lt;/p&gt;&lt;p&gt;s := &amp;amp;http.Server{&lt;/p&gt;&lt;p&gt;Addr: &quot;:&quot; + httpAddr,&lt;/p&gt;&lt;p&gt;Handler: mux,&lt;/p&gt;&lt;p&gt;ReadTimeout: 10 * time.Second,&lt;/p&gt;&lt;p&gt;WriteTimeout: 10 * time.Second,&lt;/p&gt;&lt;p&gt;MaxHeaderBytes: 1 &amp;lt;&amp;lt; 20,&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;if err := s.ListenAndServe(); err != nil {&lt;/p&gt;&lt;p&gt;return err&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;return nil&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/7b179dce15f0a78e72e23f53341eaab0/raw/b98250ba7068827e9ef6294834fb8726e5cd9600/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/7b179dce15f0a78e72e23f53341eaab0#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;要注意的是我们选的这个端口是来自于我们之前创建的.env文件。我们用log.Println给我们一个快速的console消息让我们知道服务器已经启动并运行。我们稍微配置服务器ListenAndServe。这是个很标准的Go语言。&lt;/p&gt;&lt;p&gt;现在我们需要编写makeMuxRouter函数定义所有的handler程序。要在浏览器中查看和写入我们的区块链，我们只需要2条路线并且保证他们足够简单。如果我们发送GET请求给localhost，我们将可以查看我们的区块链。如果我们发送一个POST请求给它，我们可以对它写入。&lt;/p&gt;&lt;p&gt;func makeMuxRouter() http.Handler {&lt;/p&gt;&lt;p&gt;muxRouter := mux.NewRouter()&lt;/p&gt;&lt;p&gt;muxRouter.HandleFunc(&quot;/&quot;, handleGetBlockchain).Methods(&quot;GET&quot;)&lt;/p&gt;&lt;p&gt;muxRouter.HandleFunc(&quot;/&quot;, handleWriteBlock).Methods(&quot;POST&quot;)&lt;/p&gt;&lt;p&gt;return muxRouter&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/2215e094e80d0e988fb6852010c7658a/raw/339e9e5354b681cf491b5e87c2a6686ed2180f88/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/2215e094e80d0e988fb6852010c7658a#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这是我们GET请求的handler&lt;/p&gt;&lt;p&gt;func handleGetBlockchain(w http.ResponseWriter, r *http.Request) {&lt;/p&gt;&lt;p&gt;bytes, err := json.MarshalIndent(Blockchain, &quot;&quot;, &quot;   &quot;)&lt;/p&gt;&lt;p&gt;if err != nil {&lt;/p&gt;&lt;p&gt;http.Error(w, err.Error(), http.StatusInternalServerError)&lt;/p&gt;&lt;p&gt;return&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;io.WriteString(w, string(bytes))&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/d8a4b5e705d1c5fe14531ad1c89ee12a/raw/9bf26d6bc92d8c605d74283a716b303cb258f2e2/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/d8a4b5e705d1c5fe14531ad1c89ee12a#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们简单地以JSON格式回写完整的区块链，我们可以通过在任何浏览器中访问localhost:8080查看。我们将在.env文件中的ADDR变量设置为8080，因此如果您更改它，请确保访问正确的端口。&lt;/p&gt;&lt;p&gt;我们的POST要求有点复杂，但也不是很复杂。首先，我们需要一个新的Messagestruct。我们将在很短时间内解释为什么需要它。&lt;/p&gt;&lt;p&gt;type Message struct {&lt;/p&gt;&lt;p&gt;BPM int&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/1cede3e517cfb3c37c21e602571ff327/raw/6e792b378b0f037312a685a839e30f567e4cf3bb/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/1cede3e517cfb3c37c21e602571ff327#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这是编写新块的处理程序的代码。在您阅读完毕后我们会给你解释这个过程。&lt;/p&gt;&lt;p&gt;func handleWriteBlock(w http.ResponseWriter, r *http.Request) {&lt;/p&gt;&lt;p&gt;var m Message&lt;/p&gt;&lt;p&gt;decoder := json.NewDecoder(r.Body)&lt;/p&gt;&lt;p&gt;if err := decoder.Decode(&amp;amp;m); err != nil {&lt;/p&gt;&lt;p&gt;respondWithJSON(w, r,   http.StatusBadRequest, r.Body)&lt;/p&gt;&lt;p&gt;return&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;defer r.Body.Close()&lt;/p&gt;&lt;p&gt;newBlock, err := generateBlock(Blockchain[len(Blockchain)-1], m.BPM)&lt;/p&gt;&lt;p&gt;if err != nil {&lt;/p&gt;&lt;p&gt;respondWithJSON(w, r,   http.StatusInternalServerError, m)&lt;/p&gt;&lt;p&gt;return&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;if isBlockValid(newBlock,   Blockchain[len(Blockchain)-1]) {&lt;/p&gt;&lt;p&gt;newBlockchain := append(Blockchain, newBlock)&lt;/p&gt;&lt;p&gt;replaceChain(newBlockchain)&lt;/p&gt;&lt;p&gt;spew.Dump(Blockchain)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;respondWithJSON(w, r,   http.StatusCreated, newBlock)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/c5bc5adb5c879fa56226c6b1e697b4fd/raw/a29c70be9b6bc92e0a056bb787f47a5240ec4b2d/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/c5bc5adb5c879fa56226c6b1e697b4fd#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们使用单独Message结构的原因是接受了将用于编写新块的JSON POST请求的请求体。这允许我们简单地发送一个带有以下主体的POST请求并且我们的handler将为我们填写块的其余部分：&lt;/p&gt;&lt;p&gt;{&quot;BPM&quot;:50}&lt;/p&gt;&lt;p&gt;这50是以每分钟心脏跳动为单位的脉搏速率示例。通过改变这个整数来使用自己的脉搏速率为这个整数。&lt;/p&gt;&lt;p&gt;在我们将请求主体解码到我们的var m Message结构中之后，我们通过将前一个块和我们的新脉冲速率传入我们之前编写的generateBlock函数来创建一个新块。这是创建新块所需的功能。我们做了一个快速检查来确定新块是合适使用我们之前创建的isBlockValid函数的。&lt;/p&gt;&lt;p&gt;几个注解：&lt;/p&gt;&lt;p&gt;spew.Dump是一个很便利的函数，可以将我们的结构打印到console中，它对调试很有用。&lt;/p&gt;&lt;p&gt;测试POST请求时，我们喜欢使用Postman。如果你不能远离终端，curl也很有效。&lt;/p&gt;&lt;p&gt;当我们的POST请求成功或不成功时，我们都希望得到相应的警报。我们使用一些打包函数respondWithJSON让我们知道发生了什么。请记住，在Go中，永远不要忽略错误。优雅地处理它们。&lt;/p&gt;&lt;p&gt;func respondWithJSON(w http.ResponseWriter, r *http.Request, code int, payload interface{}) {&lt;/p&gt;&lt;p&gt;response, err := json.MarshalIndent(payload, &quot;&quot;, &quot;   &quot;)&lt;/p&gt;&lt;p&gt;if err != nil {&lt;/p&gt;&lt;p&gt;w.WriteHeader(http.StatusInternalServerError)&lt;/p&gt;&lt;p&gt;w.Write([]byte(&quot;HTTP 500: Internal Server   Error&quot;))&lt;/p&gt;&lt;p&gt;return&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;w.WriteHeader(code)&lt;/p&gt;&lt;p&gt;w.Write(response)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/1ef1a7b9f139250fc0f9bad6d741d582/raw/1220fc1c36bde46f6b8dea293ded29f3fe5f9e01/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/1ef1a7b9f139250fc0f9bad6d741d582#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;几乎要完成了！&lt;/p&gt;&lt;p&gt;让我们将所有这些不同的区块链函数，网络处理程序和Web服务器连接到一个简短，干净的main函数中：&lt;/p&gt;&lt;p&gt;func main() {&lt;/p&gt;&lt;p&gt;err := godotenv.Load()&lt;/p&gt;&lt;p&gt;if err != nil {&lt;/p&gt;&lt;p&gt;log.Fatal(err)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;go func() {&lt;/p&gt;&lt;p&gt;t := time.Now()&lt;/p&gt;&lt;p&gt;genesisBlock := Block{0, t.String(), 0, &quot;&quot;, &quot;&quot;}&lt;/p&gt;&lt;p&gt;spew.Dump(genesisBlock)&lt;/p&gt;&lt;p&gt;Blockchain = append(Blockchain, genesisBlock)&lt;/p&gt;&lt;p&gt;}()&lt;/p&gt;&lt;p&gt;log.Fatal(run())&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/b6e5c021c123225d77d84ff778790c11/raw/e706b87ee93283c238c51033c41302c3232646db/main.go&quot;&gt;view raw&lt;/a&gt;&lt;a href=&quot;https://gist.github.com/nosequeldeebee/b6e5c021c123225d77d84ff778790c11#file-main-go&quot;&gt;main.go&lt;/a&gt;&lt;/b&gt; hosted with ❤ by &lt;b&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;那这里发生了什么&lt;/p&gt;&lt;p&gt;godotenv.Load()允许我们从我们放置在根目录中的.env文件中读取像端口号之类的变量，这样我们就不必在整个应用程序中对它们进行硬编码。&lt;/p&gt;&lt;p&gt;genesisBlock是main函数中最重要的部分。我们需要为区块链提供一个初始块，否则新块将无法将其先前的哈希与任何内容进行比较，因为先前的哈希值并不存在。&lt;/p&gt;&lt;p&gt;我们将创世区块隔离到它自己的goroutine中，这样我们有一个从区块链逻辑和Web服务器逻辑分开的关注。这将在没有go routine的情况下工作，但这使这种方式更清爽。&lt;/p&gt;&lt;p&gt;耶！ 我们完成了&lt;/p&gt;&lt;p&gt;这里有完整的代码&lt;/p&gt;&lt;p&gt;为了一些有趣的东西，让我们试试吧。&lt;/p&gt;&lt;p&gt;在终端用go run main.go启动你的应用程序。&lt;/p&gt;&lt;p&gt;在终端中，我们看到Web服务器已启动并正在运行，我们将获得一个创世块的打印输出。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9a7810c558afa6c97fbd0b7922406319_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;96&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9a7810c558afa6c97fbd0b7922406319&quot; data-watermark-src=&quot;v2-25ef4eefce718377fd7700b15cd4ca7a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现在用你的端口号访问localhost，对于我们来说这个号是8080。正如我们所预料的，我们见到了相同的创世区块。&lt;/p&gt;&lt;p&gt;现在，让我们发送一些POST请求来添加块。使用Postman，我们将可以添加一些带有各种BPM的新块。&lt;/p&gt;&lt;p&gt;让我们刷新我们的浏览器。你看，我们在链中看到的新区块的PrevHash与老区块里的Hash是匹配的，就像我们预期的那样！&lt;/p&gt;&lt;p&gt;下一步&lt;/p&gt;&lt;p&gt;恭喜！！您刚刚使用适当的哈希和块验证编写了自己的区块链。您现在应该能够控制自己的区块链之旅，并探索更复杂的主题，如工作证明，股权证明，智能合约，Dapps，侧链等。&lt;/p&gt;&lt;p&gt;本教程未解决的问题是如何使用工作量证明挖掘新块。这将是一个单独的教程，但大量的区块链的存在没有工作证明机制。此外，当前通过在网络服务器中编写和查看区块链来模拟网络广播。本教程中没有P2P的部分。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;===============================================================&lt;br&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&quot;&gt;http://weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&lt;/a&gt;&lt;/b&gt; &lt;b&gt;(二维码自动识别)&lt;/b&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)“&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2018-10-21-47289171</guid>
<pubDate>Sun, 21 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>加密货币中的隐私概述</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2018-10-21-47288900.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/47288900&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4826f06bdcc6d07dbe085e8aaf1a5318_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;“我认为隐私是一种方式，可以预防涵盖我们所有活动的信令问题，并创造出我们可以自由追求最大化幸福的并且仅仅是自己幸福的空间，而不是其他人对我们的看法。”——Vitalik Buterin &lt;/p&gt;&lt;p&gt;如今，隐私在加密货币中是一个重要主题，这已经不是什么秘密了。无论是公司还是个人都不希望将自己的所有信息发布到公共区块链上，因为这些信息可以在不受本国政府、外国政府、家庭成员、同事或商业竞争对手的任何限制下被任意读取。 &lt;/p&gt;&lt;p&gt;目前有很多实验和研究涉及区块链的各种隐私保护方法，但我们还没有看到该类别的全面概述。在这篇文章中，我们将涵盖隐私领域四个方面的最新实验和研究：1）隐私加密货币，2）智能合约中的隐私，3）隐私基础设施，4）隐私保护研究。 &lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c378aa39de960c4b4603ff496e51e169_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;899&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c378aa39de960c4b4603ff496e51e169&quot; data-watermark-src=&quot;v2-4b2e4e3fd7aa683922be7282663ee9ba&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;比特币中的隐私（或缺乏隐私） &lt;/p&gt;&lt;p&gt;比特币最初是作为一种匿名加密货币开发的，只要现实世界的身份不能与比特币地址联系起来，它就能保证隐私。然而，由于比特币区块链的公共性，很容易就可以根据某些特定地址和交易的使用模式来识别个人。此外，节点在广播交易时泄漏其IP地址。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;每个节点代表一个地址，每个边代表一个交易。许多节点，如Mt. Gox、Silk Road和Satoshi Dice等都已取消了匿名交易模式。 &lt;/p&gt;&lt;p&gt;2013年，Meiklejohn等人成功识别出了属于在线钱包、商家和其他服务提供商的集群。如今，像Chainalysis和Elloptic等服务商都将区块链去匿名化，以检测洗钱、欺诈和违规行为。 &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f4fb20a2daf5131e7f3c349b8aac047c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;785&quot; data-rawheight=&quot;584&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f4fb20a2daf5131e7f3c349b8aac047c&quot; data-watermark-src=&quot;v2-439828eb0f20b4730b1bdefbe57e049f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在这个例子中，一个观察者可以看到{Alice，Bob}将比特币发送给{Carol，Ted}，但无法准确地说出谁向谁汇款。对不同的用户多次重复这个过程，匿名集增长。 &lt;/p&gt;&lt;p&gt;为了应对比特币隐私受到的侵蚀，Tumbler服务应运而生，例如CoinJoin等，用于提高比特币的匿名性。在CoinJoin中，用户共同创建用于换取其加密货币所有权的交易，使整组中的每个用户都匿名。然后在不同的用户间重复这个过程来增长匿名集。犯罪分子一直使用Tumbler服务将可识别的比特币与其他基金混合在一起，来掩盖追溯到基金原始来源的踪迹。 &lt;/p&gt;&lt;p&gt;然而，CoinJoin也有其缺陷。CoinJoin的隐私依赖于庞大的匿名集。但实际上，每次CoinJoin交易平均只有2-4名参与者，因此研究人员能够对67%的CoinJoin交易实现去匿名。后来在对CoinJoin的改进中激发了更好的加密货币Tumbler的设计，例如TumbleBit，但是TumbleBit也有局限性。 &lt;/p&gt;&lt;p&gt;&lt;b&gt;隐私加密货币&lt;/b&gt; &lt;/p&gt;&lt;p&gt;由于比特币缺乏隐私，而且目前并没有计划在协议层面上改善其隐私，因此一些新的加密货币孕育而生，用来支持私人交易。 &lt;/p&gt;&lt;p&gt;Zcash是由一个强大的学术型密码团队使用zk-SNARKs构建的。Goldwasser、Micali和Rackoff在1985年提出了“零知识证明”。zk-SNARKs是由Eli Ben-Sasson等人在2015年开发的，它是对零知识证明的一种改进，它允许人们在不透露信息的情况下简洁而非交互地证明自己知道某件事。zk-SNARKs为许多与隐私相关的项目提供了技术支持，还可以使用一种名为递归组合（recursive composition）的技术压缩区块链的大小。 &lt;/p&gt;&lt;p&gt;目前，Zcash团队正在致力于Sapling项目，这是对网络的性能升级，将改善加密交易的性能和功能，并计划于2018年10月启动。由于发送加密交易的计算开销非常大，因此大约85%的Zcash交易仍以明文形式发送，而Sapling项目有望提高加密交易的数量。 &lt;/p&gt;&lt;p&gt;Monero是另一种使用ring signatures而不是zk-SNARKs的隐私加密货币。目前，Monero团队正在构建Kovri来实现一种保护隐私数据包的路由，以便用户可以隐藏其地理位置和IP地址。匿名用户的网络流量将大大提高Monero网络的安全性，并保护用户不因使用Monero而被逮捕或遭受人身伤害。 &lt;/p&gt;&lt;p&gt;Zcash和Monero经常被拿来比较。这两个社区都是由Twitter的名人领导的——Zooko Wilcox代表Zcash，Riccardo“fluffypony”Spagni代表Monero，但不同于Zcash（Zcash是由一家公司和一家基金会支持的），Monero只有一个由核心开发者组成的系统社区。这两个项目的匿名性甚至都存在缺陷，这些缺陷现已被修复——研究人员能够将69%的Zcash加密交易与创始人/矿工联系起来，也能将62%的Monero交易去匿名。 &lt;/p&gt;&lt;p&gt;然而，这两个项目在本质上采用了截然不同的隐私保护方法，并采用了不同的权衡方式，到目前为止，还没有明确的案例说明，为什么一个项目会在长期内胜过另一个项目。在我看来，Zcash和Monero将继续像可口可乐和百事可乐一样共存。 &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-701c4f0b3f9de3ad3a3f78abce51eadd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;603&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-701c4f0b3f9de3ad3a3f78abce51eadd&quot; data-watermark-src=&quot;v2-cea52b67be2a47b1886b084be22ec823&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;Mimblewimble指的是《哈利波特》中使人舌头打结的咒语。Tom Elvis Jedusor是伏地魔的法文名字，Ignotus Peverell是隐形斗篷的原主人。 &lt;/p&gt;&lt;p&gt;Mimblewimble是一个新的专注于隐私的区块链项目，它是基于比特币所设计出来的。2016年7月19日，“Tom Elvis Jedusor”把白皮书丢进了一个比特币研究频道，消失了。后来，“Ignotus Peverell”开始了一个名为Grin的Github项目，并开始将Mimblewimble论文从理论转向真正的实现。Blockstream公司的Andrew Poelstra在2017年斯坦福BPASE会议上展示了这项工作，之后Grin开始得到了主流的关注。Grin的第三个测试网已经发布，主网预计在2019年初发布。 &lt;/p&gt;&lt;p&gt;Mimblewimble/Grin是对比特币的保密交易和CoinJoin的改进。主要功能包括无需公共地址，完全的隐私，和一个紧凑的区块链。最近，Grin币的开采引起了很多关注，因为Grin币类似于比特币，只能通过PoW挖矿来铸币。Grin使用Cuckoo Cycle PoW算法，该算法最初是为抗ASIC而设计的算法，但现在被认为是ASIC友好的。 &lt;/p&gt;&lt;p&gt;总的来说，Grin结合了令比特币如此强大的社会特性——匿名创始人、无领导的开发团队、PoW共识、没有ICO，没有链上治理，以及对Zcash和Monero的技术改进。与比特币不同的是，Grin币的发行量是无限的，其货币政策是线性供应计划，这意味着通货膨胀在早期非常高，但随着时间的推移逐渐接近（而不是达到）零。在网络启动后，早期的通货膨胀是一种激励措施而不是投机。尽管持续的通货膨胀使Grin并不能成为一种理想的价值储存手段，但一旦比特币的区块奖励消失、矿工只能赚取交易费，此时它就避免了比特币的不稳定性。 &lt;/p&gt;&lt;p&gt;Grin新颖的货币政策避免了有争议的Zcash创始人的报酬问题，即20%的新铸造的ZECs在最初的4年里给予项目开发者。MimbleWimble区块链的大小也与用户数量而不是交易数量成比例，从而避免了使用Monero的ring signatures的UTXO集的缩放问题。 &lt;/p&gt;&lt;p&gt;其他有趣的隐私加密货币仍处于早期开发阶段，包括MobileCoin和BEAM。 &lt;/p&gt;&lt;p&gt;&lt;b&gt;智能合约中的隐私&lt;/b&gt; &lt;/p&gt;&lt;p&gt;智能合约中的隐私与支付中的隐私不同，因为智能合约公开包含的程序代码。不幸的是，程序混淆被证明是不可能的，因此智能合约目前既缺乏保密性（隐藏付款金额），也缺乏匿名性（隐藏发送方和接收方的身份）。 &lt;/p&gt;&lt;p&gt;在我看来，当企业准备大规模开发dApps并需要隐藏客户的活动时，对智能合约隐私的强烈需求就会到来；目前，对所有人来说，使用CryptoKitties这样的dApps并没有什么不好的地方。这可能类似于互联网最初是如何在基础网站上使用HTTP启动的，后来又为需要加密网络流量的网站（如电子商务）引入了HTTPS。 &lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-defdf3a342a52ef53d3e1cc65d064d85_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;892&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-defdf3a342a52ef53d3e1cc65d064d85&quot; data-watermark-src=&quot;v2-73933a892be7dc45d62a5dbc1e406eaf&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;如果在以太坊中没有隐私，每个人都可以在DappRadar上看到dApps的使用情况。 &lt;/p&gt;&lt;p&gt;在以太坊的案例中，Zether是斯坦福大学Benedikt Bunz正在进行的一项研究，研究的是一种完全与以太坊相兼容、能够为以太坊的智能合约提供保密和匿名的私人支付机制。Zether将作为以太坊智能合约的实施条件，并将使用最少的gas。Zether还具有多种用途，可以为支付渠道等常见应用程序添加可证明的隐私。 &lt;/p&gt;&lt;p&gt;Keep是另一个通过创建私有数据的离线容器来为以太坊构建隐私层的项目。这允许合约管理和使用私有数据，而不将数据暴露给公共区块链。 &lt;/p&gt;&lt;p&gt;虽然在Casper之后，隐私是以太坊的首要任务，但是以太坊基金会实施Casper的速度很慢，而且风险在于，隐私不会在多年以后成为以太坊的核心功能。如果智能合约中的隐私成为加密社区迫切需要的东西，那么新的隐私智能合约平台就会出现，填补这一空白，就像Zcash和Monero的出现一样，它们是为私人支付而不是比特币。Enigma，Origo和Covalent都是新的智能合约平台，它们试图将隐私原生地实现到区块链中。 &lt;/p&gt;&lt;p&gt;Oasis Labs是另一个激动人心的隐私项目，它构建了Ekiden，这是一个新的智能合约平台，将智能合约执行与基础共识机制分开。智能合约运行在一个被称为安全区的独立硬件（如英特尔SGX）内。enclave就像一个黑盒，使计算对于其他应用程序是不可见的。它还生成一个密码证明，证明程序是正确执行的，然后该证明存储在区块链中。通过将智能合约执行与共识分离，Ekiden与不同的底层区块链兼容，包括以太坊。 &lt;/p&gt;&lt;p&gt;&lt;b&gt;隐私的基础设施&lt;/b&gt; &lt;/p&gt;&lt;p&gt;除了隐私加密货币和私有智能合约之外，Web 3堆栈还有其他重要的隐私基础设施项目值得一提。 &lt;/p&gt;&lt;p&gt;Orchid正在尝试构建一个更好的Tor版本，在这个版本中，用户从出租额外带宽作为Orchid网络中的中继器中获取token。Tor的问题是只有6000个中继节点，不到2000个桥接节点，所以中国政府可以把所有中继节点和桥接节点都列入黑名单，从而阻止公民访问Tor。使用token奖励来激励更多人成为中继者，这使得阻止Orchid变得更加困难，因为总不能阻止互联网的大部分节点。 &lt;/p&gt;&lt;p&gt;BOLT正在构建一个私人支付渠道，使用盲签名和零知识证明来隐藏参与者在打开、交易和关闭支付渠道时的身份。最初的支付渠道建立在Zcash之上，但之后将能够与比特币和以太坊进行互操作。 &lt;/p&gt;&lt;p&gt;NuCypher正在使用proxy re-encryption来构建一个去中心化的密钥管理系统，用于提供与HTTPS相同的功能。Proxy re-encryption是一种公钥加密，它允许用户在不了解底层消息的情况下将密文从一个公钥转换到另一个公钥。 &lt;/p&gt;&lt;p&gt;Starkware正在包括以太坊在内的各种区块链中实现zk-STARKs。与zk- SNARK相比，zk-STARKs的优势在于，它不需要可信的设置，尽管加密证明的密钥尺寸变得更大了。 &lt;/p&gt;&lt;p&gt;&lt;b&gt;隐私保护研究&lt;/b&gt; &lt;/p&gt;&lt;p&gt;密码学的学术研究推动了隐私保护领域的创新。隐私保护研究主要涉及到零知识、多方计算、全同态加密等领域。 &lt;/p&gt;&lt;p&gt;除了zk- SNARKs和zk-STARKs之外，Bulletproofs是一种新的简短的非交互式的零知识证明形式。与zk-STARKs一样，Bulletproofs不需要可信的设置，但是验证Bulletproofs比验证zk-SNARK文件更耗时。Bulletproofs的设计目的是为了能够以加密货币进行高效的保密交易，并将Bulletproofs文件的大小从10 KB以上缩小到1-2 KB。如果所有比特币交易都是保密的，并且使用了Bulletproofs，那么UTXO集的总大小将只有17 GB，而目前的大小是160 GB。 &lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-34f06f72332d94f23d7979d24a6d53e9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;491&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-34f06f72332d94f23d7979d24a6d53e9&quot; data-watermark-src=&quot;v2-96d10a643ed91fb769029515caf8b0cb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;                                           不同的零知识证明系统的比较&lt;/p&gt;&lt;p&gt;多方计算允许一组人在他们的输入上联合计算一个函数，而不需要每个人透露他们自己的输入。例如，Alice和Bob想要知道谁拥有更多的比特币，而不是每个人都透露他/她拥有多少比特币。不幸的是，当前多方计算的限制是，在实践中使用它的效率非常低。 &lt;/p&gt;&lt;p&gt;全同态加密允许在加密数据上进行计算。几十年来，这一直是密码学领域的一个开放性问题，直到2009年，斯坦福大学博士生Craig Gentry使用格构造了第一个全同态加密方案。如果Bob想在Alice的数据上执行任意计算（比如训练机器学习模型），而Alice不需要显示明文数据，那么这个例子就很有用。全同态加密，像多方计算一样，目前仍然是很理论化的，而且在实践中效率很低。 &lt;/p&gt;&lt;p&gt;&lt;b&gt;那又怎样?&lt;/b&gt; &lt;/p&gt;&lt;p&gt;总的来说，隐私是目前密码学研究中最令人兴奋的领域之一，并且优化这些理论技术的效率以使其在现实中实际应用还有很多工作要做。研究型实验室，如斯坦福大学区块链研究中心，正积极在这一领域取得进展，未来几年将会有哪些重大突破将是令人兴奋的。 &lt;/p&gt;&lt;p&gt;加密货币的好处是它为最新的隐私研究提供了一个直接的用例。许多用于加密货币、智能合约和基础设施的隐私技术都是近几年才发明出来的。考虑到这个领域发展速度之快，隐私将继续成为加密项目设计中不可或缺的一部分。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;===============================================================&lt;br&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&quot;&gt;http://weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&lt;/a&gt;&lt;/b&gt; &lt;b&gt;(二维码自动识别)&lt;/b&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)“&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2018-10-21-47288900</guid>
<pubDate>Sun, 21 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>世界50+区块链经典案例</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2018-10-21-47288298.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/47288298&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c16e1a2d85c716a55e55ac3af3050f55_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c16e1a2d85c716a55e55ac3af3050f55_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2000&quot; data-rawheight=&quot;1513&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c16e1a2d85c716a55e55ac3af3050f55&quot; data-watermark-src=&quot;v2-4452aad37cdd79269954f980346ad8a4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;谈到区块链，我们通常会考虑它在未来的应用。“区块链将解决这个问题，区块链将实现这一目标”。很容易忘记区块链已经在当下实施部署。选择一个行业，从汽车到人工智能，你可能会发现一些区块链的用例。在所有的领域和圈子里，区块链都在发挥着作用。甚至美国财政部也在采取行动，倡导更多的试点和测试项目。&lt;/p&gt;&lt;p&gt;本文作者Matteo Gianpietro Zago，由格密链的马佳敏翻译。&lt;/p&gt;&lt;p&gt;“世界经济论坛”预计，到2025年，全球GDP的10%将储存在区块链上。这意味着，全球高管们正在为这一巨大转变做准备，并完全支持其实施。分布式账本技术的影响可能与互联网革命本身一样宏大。&lt;/p&gt;&lt;p&gt;用例各不相同，但使用该技术所带来的好处是不变的：透明性、不可变性、冗余和安全性。在2018年，每天都有新的区块链计划启动。以下是50个在全球范围内使用区块链的例子。&lt;/p&gt;&lt;p&gt;&lt;b&gt;政府&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一些政府表示对区块链技术感兴趣，因为它可以将公共记录存储在去中心化的数据管理机构中。Essentia正在与由农业生产者和森林所有者所组成的芬兰中央联盟合作开发一个电子政务试点项目。区块链将使全芬兰的城市和农村公民能够访问记录。其他包含政府应用用例的有教育、公共记录和投票。&lt;/p&gt;&lt;p&gt;&lt;b&gt;废品管理&lt;/b&gt;&lt;/p&gt;&lt;p&gt;中国的一个智能废品管理系统采用了Waltonchain的RFID技术。通过Walton的区块链，该项目将能够监督废品等级，以提高运营效率和优化资源。&lt;/p&gt;&lt;p&gt;&lt;b&gt;识别&lt;/b&gt;&lt;/p&gt;&lt;p&gt;瑞士的Zug被称为“Crypto Valley”，它与Uport合作开发了一个区块链项目，用来注册居民的身份证，使他们能够参与网上投票，并证明他们的居住权。&lt;/p&gt;&lt;p&gt;&lt;b&gt;边境控制&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Essentia一直在与荷兰政府进行接触，希望建立一个新的系统，用于检查来往阿姆斯特丹和伦敦的旅客。目前，两国间的欧洲之星列车上的乘客在多个地点接受边防检查。Essentia正在研究一个基于区块链的解决方案，该方案将安全存储乘客数据，使在荷兰记录的数据能够由英国的机构进行审计。区块链将提供一种确保数据没有被篡改，并且具有高准确度的可验证方法。&lt;/p&gt;&lt;p&gt;&lt;b&gt;医疗保健&lt;/b&gt;&lt;/p&gt;&lt;p&gt;总所周知，医疗记录通常是分散的、不准确的，数据处理过程不一致意味着医院和诊所常常被迫处理不正确或不完整的患者记录。目前，MedRec等医疗保健项目正在使用区块链用于促进数据共享，同时提供身份验证和数据保密服务。&lt;/p&gt;&lt;p&gt;&lt;b&gt;企业&lt;/b&gt;&lt;/p&gt;&lt;p&gt;作为一种服务，Microsoft Azure Enterprise的客户端可以访问以太坊区块链。这使企业能够在安全的托管环境中访问智能合约和区块链应用程序。&lt;/p&gt;&lt;p&gt;据报道，谷歌也在开发专有的区块链，以支持其基于云的业务。Alphabet正在开发一种分布式账本，第三方可以使用它来存储数据（据可靠信息，这些数据与谷歌的企业云服务有关），同时也为企业开发了一个white label版本。&lt;/p&gt;&lt;p&gt;&lt;b&gt;医疗&lt;/b&gt;&lt;/p&gt;&lt;p&gt;通常医疗中心不会将患者的数字化记录分布式存储在多个设施中，而是将数据集中存放在中心化的服务器上。这样就成为了黑客攻击的主要目标，英国NHS医院遭受勒索软件攻击就是明证。即使忽略了安全风险，仍然存在分散问题。目前有超过50种不同的电子医疗记录软件系统在不同的医院中运行，通常在同一个城市有几十个不同的软件包。这些中心化的系统不能相互操作，患者的数据最终分散在不同的中心之间。&lt;/p&gt;&lt;p&gt;在生死攸关的环境中，缺乏可靠的数据和缓慢的接口可能会带来毁灭性的打击。Essentia框架通过使用区块链驱动的系统来解决所有这些问题，该系统将存储与临床相关的患者数据，并且可以立即访问这些数据，而不受地理边界的限制。在一个安全的分布式网络中，患者的隐私得以维护，因为只有经过医学授权的人员才能访问，而且只能在需要数据期间内访问。&lt;/p&gt;&lt;p&gt;&lt;b&gt;音乐&lt;/b&gt;&lt;/p&gt;&lt;p&gt;区块链技术的主要好处之一是它消除中间商或中间商的方式。音乐行业是一个典型的例子，这个行业效率低下，艺术家们付出的努力得不到回报。大量基于区块链的项目涌现出来，为音乐创作者寻求更公平的交易，其中包括由前枪炮玫瑰乐队鼓手Matt Sorum监督的Artbit。&lt;/p&gt;&lt;p&gt;&lt;b&gt;碳补偿&lt;/b&gt;&lt;/p&gt;&lt;p&gt;作为一个高度工业化的国家，中国的环境足迹是巨大的。2017年3月，IBM与energy blockchain Labs联合在Hyperledger Fabric区块链上开发，以跟踪中国的碳资产。这为跟踪排放创造了一个可测量和可审计的系统，并为寻求抵消其能源消耗的公司提供了一个可交易的市场，同时鼓励更环保的工业实践。&lt;/p&gt;&lt;p&gt;&lt;b&gt;供应链&lt;/b&gt;&lt;/p&gt;&lt;p&gt;供应链管理被认为是区块链最有利的用例之一，因为它适用于货物通过各种方式，从头到尾，或从制造商到商店的行业。IBM和沃尔玛已联手在中国推出区块链食品安全联盟。该项目与《财富》500强企业京东联合运营，旨在改善食品跟踪和安全，从而更容易验证食品是否安全。&lt;/p&gt;&lt;p&gt;事实证明，中国是区块链项目的成熟试验田，因为中国也是全球首个农业商品区块链的发源地。主食交易商路易达孚公司（Louis Dreyfus Co）已经与荷兰和法国的银行建立了一个项目，用于向中国出售大豆，由于采用区块链技术，交易结算速度比传统方式更快。&lt;/p&gt;&lt;p&gt;&lt;b&gt;钻石&lt;/b&gt;&lt;/p&gt;&lt;p&gt;全球最著名的钻石公司戴比尔斯集团（De Beers Group）目前已建立并运营了自己的区块链，旨在“为平台上注册的每一颗钻石建立数字记录”。考虑到对钻石来源的担忧，以及对钻石原产地的道德规范，再加上生产线上钻石可能被换成价值更低的钻石的风险，区块链是一个天然的选择。因为每条记录都是不可磨灭的，它将确保每一颗钻石的数据能和钻石本身一样持久。&lt;/p&gt;&lt;p&gt;&lt;b&gt;房地产&lt;/b&gt;&lt;/p&gt;&lt;p&gt;乌克兰有幸成为第一个使用区块链促进房地产交易的国家。基辅的一处房产被著名的加密货币倡导者和TechCrunch创始人Michael Arrington出售。这笔交易是在以太坊区块链的智能合约的帮助下实现的，并且打算成为Propy创建的众多交易的首批交易。Propy是一家专门从事区块链房地产交易的初创企业。&lt;/p&gt;&lt;p&gt;&lt;b&gt;渔业&lt;/b&gt;&lt;/p&gt;&lt;p&gt;区块链现在被用来支持可持续捕鱼。非法捕鱼是行业内普遍存在的问题，分布式账本技术提供了一种证明鱼在哪里被捕捞、加工和销售的方法。这种“从网到板”的链条使检查员能够判断出鱼是来自因侵犯人权而臭名昭著的地区，还是来自受到经济制裁影响的国家。&lt;/p&gt;&lt;p&gt;&lt;b&gt;美术&lt;/b&gt;&lt;/p&gt;&lt;p&gt;与钻石贸易类似，艺术品行业也依赖于艺术品的来源和真实性。虽然区块链不能鉴定一幅画是原作还是赝品，但它可以用来证明这幅画以前的主人。此外，区块链现在被用作获得艺术品的一种手段。这是区块链技术如何能够在世界任何地方轻松交易和交换实物的另一个例子，而不需要从安全存储中实际转移它们。&lt;/p&gt;&lt;p&gt;&lt;b&gt;公共设施&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在澳大利亚的Fremantle市，一个专注于分布式能源和水系统的雄心勃勃的项目正在使用区块链技术。太阳能电池板正在阳光充足的地区用于收集电力，然后用来加热水并提供电力，并将数据记录在区块链上。&lt;/p&gt;&lt;p&gt;智利国家能源委员会已经开始使用区块链技术作为该国能源使用相关数据的认证手段。也是帮助南美国家实现电力基础设施现代化和安全举措的一部分，敏感数据将存储在区块链上。&lt;/p&gt;&lt;p&gt;&lt;b&gt;同性恋的权利&lt;/b&gt;&lt;/p&gt;&lt;p&gt;区块链可以帮助建立“粉红经济”，并帮助LGBT群体在不暴露身份的情况下争取自己的权利。后者是一个极其重要的问题，因为仇恨犯罪在同性恋群体中是一个反复出现的问题，尤其是在那些因侵犯人权而臭名昭著的国家，因为在这些国家，同性恋是非法的，或者至少是不受欢迎的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Cat债券&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对于遭受地震、海啸和其他自然灾害的受害者来说，Cat债券是唯一的希望。区块链允许各方之间快速、透明的结算，并确保即使没有人为操作，该系统也将继续运行。区块链目前已被成功用作Cat债券结算机制。&lt;/p&gt;&lt;p&gt;&lt;b&gt;旅游&lt;/b&gt;&lt;/p&gt;&lt;p&gt;人们正在研究区块链，就是通过让游客有机会用比特币和其他加密货币购买当地商品和服务的方式来改善夏威夷的经济。通过这种方式，夏威夷政府希望吸引游客，特别是来自亚洲的游客，从而花更多的钱，最终帮助夏威夷发展经济。&lt;/p&gt;&lt;p&gt;&lt;b&gt;国家安全&lt;/b&gt;&lt;/p&gt;&lt;p&gt;2016年，美国国土安全部（DHS）宣布了一个项目，该项目将使用区块链作为安全存储和传输其捕获的数据的手段。使用Factom区块链，将从安全摄像头和其他传感器中检索到的数据加密并存储，使用区块链作为降低数据泄露风险的一种手段。该项目仍在进行中。&lt;/p&gt;&lt;p&gt;&lt;b&gt;航运&lt;/b&gt;&lt;/p&gt;&lt;p&gt;区块链适合记录运输数据是不言而喻的。许多项目在这一领域采用了分布式账本技术，在海运物流业中使用它来为国际贸易中不可避免的官僚机构带来透明度。马士基是全球最大的托运公司之一，是率先使用区块链的公司，如今ZIM已经接过了火炬。&lt;/p&gt;&lt;p&gt;&lt;b&gt;税收&lt;/b&gt;&lt;/p&gt;&lt;p&gt;作为世界上技术最先进的国家之一，中国成为区块链及其提供的一切产品的首批和最重要的使用者之一，也就不足为奇了。一个由瞄财网（Miaocai Network）牵头、国家税务总局的项目利用区块链技术为税务和电子发票开具提供了便利。&lt;/p&gt;&lt;p&gt;&lt;b&gt;移动支付&lt;/b&gt;&lt;/p&gt;&lt;p&gt;基于区块链技术的加密货币正被用于促进各类项目中的移动支付。计划于2018年秋季推出的最新举措之一，将涉及一个由日本银行组成的财团。他们将使用Ripple的技术实现即时移动支付。&lt;/p&gt;&lt;p&gt;&lt;b&gt;土地登记&lt;/b&gt;&lt;/p&gt;&lt;p&gt;区块链再次证明它不仅适用于加密圈和小公司。Georgia政府用它来登记土地所有权。他们创建了一个定制设计的区块链系统，并将其集成到国家公共注册局（NAPR）的数字记录系统中。Georgia正在利用区块链技术提供的透明度和减少欺诈的优势。&lt;/p&gt;&lt;p&gt;&lt;b&gt;计算&lt;/b&gt;&lt;/p&gt;&lt;p&gt;亚马逊网络服务公司与数字货币集团（DCG）合作，在区块链的帮助下提高其数据库安全性。他们将为DCG的初创公司提供一个工作平台，并为他们的项目提供技术支持。&lt;/p&gt;&lt;p&gt;&lt;b&gt;保险&lt;/b&gt;&lt;/p&gt;&lt;p&gt;区块链在保险业中经常被提及，但很多人并不知道这项技术已经被实施。例如，保险公司美国国际集团（American International Group Inc .）与国际商业机器公司（International Business Machines Corp）合作，为渣打银行完成了一项所谓的“智能合约”多国政策试点，并计划通过区块链管理复杂的国际业务。&lt;/p&gt;&lt;p&gt;&lt;b&gt;濒危物种保护&lt;/b&gt;&lt;/p&gt;&lt;p&gt;A man is a wolf to another man, and an even bigger wolf to animals（拉丁格言，有点类似于“他人即地狱”）。“Care for the Uncared”是一个非政府组织，它正在与主要的开发人员合作，寻找一种利用区块链技术来保护濒危物种的方法。&lt;/p&gt;&lt;p&gt;&lt;b&gt;广告&lt;/b&gt;&lt;/p&gt;&lt;p&gt;纽约互动广告交易所（New York Interactive Advertising Exchange）与纳斯达克（Nasdaq）合作，利用区块链创建了一个市场，品牌、出版商和广告代理可以在这里购买广告。这个过程很简单，但尽可能安全，使用的是以太坊区块链的开放协议。&lt;/p&gt;&lt;p&gt;&lt;b&gt;新闻&lt;/b&gt;&lt;/p&gt;&lt;p&gt;持久性现在是新闻行业的一个热门话题。一个错误的举动，多年的辛勤工作和研究可能会付诸东流。区块链是解决这个问题的一个明智之选。一个去中心化的新闻市场，除了显而易见的区块链自身利益外，它还为高质量的新闻内容提供了一种经济激励模型，同时还能永久保存内容，这些内容随时都可以访问。&lt;/p&gt;&lt;p&gt;&lt;b&gt;智慧城市&lt;/b&gt;&lt;/p&gt;&lt;p&gt;智慧城市不再是科幻小说的内容。台北正试图借助分布式账本技术，将自己定位为未来之城。现已宣布与IOTA建立合作关系，他们正在致力于开发具有光、温度、湿度和污染检测功能的芯片。&lt;/p&gt;&lt;p&gt;&lt;b&gt;石油行业&lt;/b&gt;&lt;/p&gt;&lt;p&gt;标准普尔全球普氏能源公司（S&amp;amp;P Global Platts）是石油市场的主要参与者之一，该公司正在试验一种区块链解决方案，这种方案被用来记录石油储存数据。每周的库存将存储在区块链上，减少了需要手动数据管理的过程，并最大限度地降低了人为错误的可能性。&lt;/p&gt;&lt;p&gt;&lt;b&gt;铁路&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在俄罗斯，铁路运营商Novotrans正在使用区块链技术，其目标是提高运营速度。该公司是该国最大的铁路车辆运营商之一，将使用区块链记录与维修请求、库存和与运营相关的其他事项的数据。它的想法是区块链记录将更能抵御篡改和数据损坏。&lt;/p&gt;&lt;p&gt;&lt;b&gt;游戏&lt;/b&gt;&lt;/p&gt;&lt;p&gt;育碧是游戏行业最具影响力的公司之一，该公司正在研究如何将区块链应用到其视频游戏中。具体来说，它关注的是游戏内物品的所有权和转让，比如奖励和数字收藏品。这些已经使用以太坊区块链成功演示了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;汽车租赁&lt;/b&gt;&lt;/p&gt;&lt;p&gt;区块链的分布式账本技术非常适合以安全且不可更改的方式注册任何类型的记录。Essentia开发的一个这样的用例是汽车租赁行业。大型租赁公司将能够利用Essentia公司的区块链协议存储客户数据，并在征得相关方许可的基础上对数据进行完全加密和共享。&lt;/p&gt;&lt;p&gt;&lt;b&gt;能源分配&lt;/b&gt;&lt;/p&gt;&lt;p&gt;能源行业面临的最大挑战之一是，经常处于过剩供应交易的企业需要准确无误的记录。实时跟踪能源分配，确保供应链的高效分配需要多个数据点，并且要求所有实体之间的密切合作。Essentia正在和一些主要的能源供应商开发一个测试项目，以帮助他们实时跟踪能源分配，同时保持数据机密性。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6b54bf5a60bde7128c52013d12ecad75_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1730&quot; data-rawheight=&quot;1061&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6b54bf5a60bde7128c52013d12ecad75&quot; data-watermark-src=&quot;v2-04035d0decfffa3d7e13d7b448f68bce&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;现实世界中的区块链用例的数量每天都在增加。从物流到美术，很难找到一个领域不被这种革命性技术所触动。我们已经达到了这一点，技术已经证明自己优于目前的运作方式。&lt;/p&gt;&lt;p&gt;世界经济论坛预测，到2025年，全球将采用区块链。但是观察了已经在实施阶段的用例之后，我们不得不问，它真的需要那么长的时间吗？&lt;/p&gt;&lt;p&gt;想想在过去的15年里，一条平静流淌的河流，突然间，一场暴风雨出现了，连续下了几周的雨，把河流变成了汹涌的急流，冲走了沿途的一切。这条河就是Web 2.0，区块链的风暴已经改变了互联网的格局。还剩下什么？当雨停了，洪水退去，旧树叶被冲走，大片肥沃的土地等待耕种。&lt;/p&gt;&lt;p&gt;这条促进自然生态系统内部流动和相互作用的河流消失了。Web 3.0也是如此，我们可以看到各个领域的增长，但它们之间仍然存在很大的不兼容。但“嘿，很快”就有了解决方案。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;===============================================================&lt;br&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&quot;&gt;http://weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&lt;/a&gt;&lt;/b&gt; &lt;b&gt;(二维码自动识别)&lt;/b&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)“&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2018-10-21-47288298</guid>
<pubDate>Sun, 21 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何将真实世界资产上链</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2018-10-21-47288112.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/47288112&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c0a84f6fb557e13a721bd69585a16a71_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通证化是将资产的权利转换为区块链上的数字通证的过程。世界各地的金融中介机构和技术专家对如何将现实世界的资产转移到区块链上，以获得比特币的优势，同时保持资产的特性产生了了极大的兴趣。&lt;/p&gt;&lt;p&gt;为什么要将“真实世界”的资产进行通证？&lt;/p&gt;&lt;p&gt;我们的世界充满了资产：股票、房地产、黄金、碳信用、石油等等。这些资产中有许多难以进行实物转移或细分，因此买家和卖家转而使用代表部分或全部资产的交易票据。但是，纸张和复杂的法律协议很繁琐，很难转移，而且很难追踪。一种解决方案是，在比特币的基础上切换到数字系统，但与一项资产挂钩。&lt;/p&gt;&lt;p&gt;大宗商品交易所在很大程度上用电子交易和标准化协议取代了实体纸张，但这些系统的开销是巨大的，它们通常依赖于可信的参与者。世界各地的创业公司和主要金融公司都在竞相开发这一系统的下一进化阶段：通证化资产。但是为什么会有人想要一个表示物理资产的数字通证，这是怎么做到的呢？&lt;/p&gt;&lt;p&gt;想象一下，简是一个钻石批发商，拥有1500万美元的钻石。钻石很难转移到买家手中，因为它们需要安全和仔细的检查，以确保在供应链的某个地方不引入假货。乔想要投资几千美元的钻石，但又不想处理实际接受钻石的麻烦。在任何情况下，乔都希望拥有一小块钻石来分散他的钻石位置，因为钻石有各种各样的等级和切割，并且随着时间的推移，每一种钻石的需求都会发生变化。&lt;/p&gt;&lt;p&gt;简没有时间去找乔并且卖给他几颗钻石;她只是想要一种简单的方法来细分她的钻石存货，然后把它的一部分卖给各种各样的人。乔想要能够轻松地将他的部分所有权交易给其他人（而不仅仅是和简进行交易）。在这种情况下，让所有各方都满意的能力是区块链通证的承诺，它代表现实世界的资产，并有机会让令人关注的资产类别的所有权民主化。&lt;/p&gt;&lt;p&gt;有许多建议的方法可以将现实世界的资产和“把它们放在区块链上”。我们的目标是实现比特币的安全、速度和便捷，和现实世界的资产结合起来。这是旧概念的一种新形式：“证券化”（将一组资产转换为证券），在某些情况下，通证化是证券化资产。本文的其余部分将探讨可在区块链上放置的资产类型，以及一些由初创公司、金融中介机构和政府进行试点的模型。&lt;/p&gt;&lt;p&gt;无形资产&lt;/p&gt;&lt;p&gt;许多资产是律师所说的“无形资产”。它们的存在仅仅是由于法律的运作，而且没有物理对象。无形资产的例子包括专利、碳信用、品牌名称、版权等。无形资产，缺乏实体形式，可能更容易与数字区块链系统相结合。&lt;/p&gt;&lt;p&gt;无形资产面临的挑战是，确保区块链系统的资产转移模式与现实世界的转移法律模式相一致。也可能存在司法上的差异，这可能会使转移变得困难（尽管类似，版权法在世界各地有所不同）。也就是说，无形资产往往比实物更容易被进行通证，因为对存储和运输的担忧较少。&lt;/p&gt;&lt;p&gt;可替代资产&lt;/p&gt;&lt;p&gt;律师对可替代的资产和不可替代的资产进行区分。可替换的物品可以被另一种相同的物品所取代。想想小麦、黄金或水。可替代资产更容易转换为通证,因为他们通常可以被分解成更小的单位(如比特币),和一个通证可以代表一组对象(例如,一堆黄金),而不是一组单个对象(比如,一个仓库充满了独特的艺术作品)。&lt;/p&gt;&lt;p&gt;不可替代的资产需要一个抽象层来进行通证化。例如，一家公司将这些资产组合在一起，并将其作为一个包提供。这是一种用于证券化抵押贷款的方法，即一套具有独特特征的抵押贷款组合成一组具有近似相似特征的抵押贷款。&lt;/p&gt;&lt;p&gt;可替换资产通常更容易通证化，因为一般的通证与一组可互换的资产组件（例如10公斤的黄金）相关联。&lt;/p&gt;&lt;p&gt;所有权转让和有限权利转让&lt;/p&gt;&lt;p&gt;资产的转移和许多类型的资产权利有很多种。有时，与资产相关的有限权利被转移，比如在有限的时间内租用土地，而不是转让土地所有权。数千年的财产所有权导致了各种类型的所有权和控制权，例如代表另一个人持有财产（“保释”）。具体细节取决于司法管辖权、法律类型（普通法与民法）、资产以及打算转移的权利。&lt;/p&gt;&lt;p&gt;一些无形资产可以同时获得数百万人的许可，比如音乐版权。当顾客从iTunes“购买”歌曲时，他们并没有获得对歌曲的所有权（所有权的改变），他们购买的是权利，许可，在特定条件下听音乐。&lt;/p&gt;&lt;p&gt;区块链项目通常可以划分为那些涉及部分权利的内容，比如音乐许可，以及那些涉及到完全所有权的通证，例如出售房地产。&lt;/p&gt;&lt;p&gt;关键的法律问题：确保通证一致性&lt;/p&gt;&lt;p&gt;在像比特币这样的数字系统中，总是有一致性的。事务遵守软件的规则，并且没有例外。在现实世界中，也有例外。金条被偷，房子被烧毁，音乐样本被证明没有得到适当的许可，钻石也不能被运送——人类有时不遵守规则。因此，任何涉及对真实世界资产进行通证的系统的关键挑战是确保数字通证与真实世界的资产保持联系。&lt;/p&gt;&lt;p&gt;想象一下，一个通证代表了金库中一组金条的部分利益。如果从保险库中取出一个金条，它将如何反映在数字通证中？谁将确保通证价值与金库中应该存在的金条联系在一起，而不是金库中的金条？谁来承担风险，如何来承担？&lt;/p&gt;&lt;p&gt;如果通证的购买者不能确定通证是否与真实世界的资产相关联，那么通证的值将下降或变为零（如果没有人对它有信心）。&lt;/p&gt;&lt;p&gt;法律模型&lt;/p&gt;&lt;p&gt;1. 许可&lt;/p&gt;&lt;p&gt;音乐许可严重依赖于文书工作和信任。音乐家们希望他们的音乐和商品的销售能够得到适当的计算并向他们报告。由于流媒体和数字下载消除了包含歌曲的媒体的实体销售，音乐似乎是一个很好的通证化的候选对象。如果音乐所有权是用区块链来表示的，那么许多参与创作音乐的人都可以通过电子方式来设定他们的股份。他们的梦想是让每一次听他们的音乐都需要“解锁”和支付，然后支付给合适的持有者。然后，持有者可以将他们对音乐的兴趣转移到其他人身上（例如，如果鼓手想把他们的所有权转换成一套房子的首付），那么他们就可以得到支付流。&lt;/p&gt;&lt;p&gt;更准确的报告对每个人都有好处，但是通证化可能会引发其他的变化。对音乐所有权的通证化可以允许新的商业模式，比如投资于公众的音乐创作。如果一个新乐队能把他们的新歌的20%卖给粉丝，那对音乐的创作会有什么影响呢？这将如何影响中介机构？&lt;/p&gt;&lt;p&gt;音乐所有权/许可通证化的一个例子是SingularDTV。&lt;/p&gt;&lt;p&gt;2. 贸易系统&lt;/p&gt;&lt;p&gt;想象一下，一群想要相互交易石油的公司。通常情况下，他们会交换文件，并保留自己的交易清单。如果他们能搬到一个以区块链为基础的系统来交易他们的石油，他们就有可能减少文书工作，并拥有更健全的记录。有许多财团正在涌现，目的是用区块链交易系统取代纸质交易系统。它们通常不打算直接对现实世界的资产进行通证，而是使用区块链系统来实现真实世界资产的交易。这是旧的纸质记录方法和新的区块链方法的混合体。通证只有在涉及所有过去和未来参与者的契约系统的上下文中才有价值。&lt;/p&gt;&lt;p&gt;这种形式的通证化的一个例子是IBM-Natixis-Trafigura石油交易项目。还有一些通证化方案，包括使用数字锁强制执行的属性，比如Slock It。&lt;/p&gt;&lt;p&gt;3. 赎回&lt;/p&gt;&lt;p&gt;想象一下，一个有1000幅画的著名艺术家的作品。可以通证化的艺术打印通过所有权由公司站向公众提供兑换为一个艺术打印或通证,如果赎回通证小于某个阈值,评估价值的一小部分的艺术打印。这些印刷品的实际交付可以在某个地点进行，也可以发送到指定的地址。通过这种方式，买家可以获得一种易于转让的通证，第三方市场可以用部分艺术品进行交易。这可能是艺术家的资金来源，也是更广泛的公众参与艺术市场的一种方式。&lt;/p&gt;&lt;p&gt;上述模式依赖于持有艺术品的公司继续提供赎回。通证持有者面临的一个明显风险是，该公司将不再履行其承诺，即为其拥有的真实世界商品交换数字代币。另一个问题是，持有艺术品的公司将如何补偿存储成本。&lt;/p&gt;&lt;p&gt;这一模式为外国货币采取行动的一个例子是Tether，尽管注意到服务条款的第3节表明，赎回是不保证的。&lt;/p&gt;&lt;p&gt;4. 保险库和智能合约&lt;/p&gt;&lt;p&gt;想象一个金库里。黄金的所有者是“Goldowner Inc.”，金库由“Vault Inc.”所有。保险库公司拥有良好的声誉和第三方审计员，他们可以核实其保险库中的黄金数量。&lt;/p&gt;&lt;p&gt;Goldowner inc.可以向公众提供一种数字通证，代表黄金的所有权，并通过与Vault公司的一份智能合约，维持一个公开的链下注册表，将黄金的部分权益与通证联系起来。每卖出一件通证，Goldowner inc.将所有权转让给保险公司，后者代表代币持有者持有该公司的所有权。保险库公司保证任何通过数字签名证明所有权的人都能赎回黄金。&lt;/p&gt;&lt;p&gt;Goldowner inc.可以利用这个事实，即保险库公司是受信任的（并且是经过审计的）。通证的所有者依赖于Vault inc.的陈述，而不是Goldowner inc.（尽管Goldowner inc.是象征性的发行方）。&lt;/p&gt;&lt;p&gt;显然，上面的例子有很多风险，如果黄金是一种可以通过电子方式传输的数字产品，就不存在了。黄金有一个物理实体，它需要物理存储（这也需要花钱）。那么，为什么要把黄金做记号呢？一个优点是，通证的购买者可以知道，他们是唯一收到过通证的人，而纸质证书的购买者却无法知道同样的证书没有被卖给多个人。&lt;/p&gt;&lt;p&gt;两个黄金通证化创业公司的例子是Vaultoro和Orebits。也有许多相关的项目试图使用数字通证来跟踪在供应链中移动的真实项目，在那里，通证用于来源而不是价值。&lt;/p&gt;&lt;p&gt;与全球证券法的交叉&lt;/p&gt;&lt;p&gt;证券法律经常禁止向公众出售资产的部分权益（未经政府许可）。考虑到区块链的全球默认特性，这可能会给参与通证化的实体或这些通证交易的市场的运营者带来问题。这些问题特别复杂，因为它们往往涉及重叠的司法管辖区（例如，中国的卖方和美国的买方）。&lt;/p&gt;&lt;p&gt;数字通证与现实世界的资产相关联，最终涉及一个具有价值的现实世界实体，并可由相关监管机构追踪。这使得它比一个纯粹的软件平台更难以避免监管，或者涉及到点对点的活动（比如BitTorrent和一家销售盗版电影的商店）。&lt;/p&gt;&lt;p&gt;一些有远见的监管机构正在考虑进行法律改革，以使资产转移能够通过数字代币转移实现。美国特拉华州已经开始立法，允许企业使用区块链来获取有关股东的账簿和记录。这些努力是摆脱美国复杂的间接证券所有权计划的一部分，该计划需要中介机构。美国最大的中介机构——美国存托信托与结算公司（DTCC）目前拥有价值超过37万亿美元的股票。&lt;/p&gt;&lt;p&gt;举一个例子，关于当前的股票间接所有权制度的失败，请看上个月特拉华州法院的判决：在Re: Dole Foods Company, Inc., C.A. No. 8703-VCL。想看看债券市场所面临的挑战，请看2014年纽约时报杂志的文章“Paper Boys”。&lt;/p&gt;&lt;p&gt;中心化问题&lt;/p&gt;&lt;p&gt;比特币在非区块链系统上的主要优势之一是它是去中心化的。但现实世界的资产通常只有一个所有者，或者一小部分所有者。&lt;/p&gt;&lt;p&gt;许多资产支持通证的模型都包含了一个持有真实世界资产的公司的公开报价。如果中央资产持有人失败，整个通证可能会失败。&lt;/p&gt;&lt;p&gt;任何通证化方案的挑战是如何将真实世界资产的单一所有者与通证的许多所有者连接起来。如何减轻中心化的风险？答案通常是巧妙的数字通证方案、合同、保险、审计和第三方担保的组合。&lt;/p&gt;&lt;p&gt;对中心化问题的一个解决办法是依靠一个有信任的中央集权的政党，因为它是决定谁拥有什么东西的政府权力机构。瑞典的土地登记系统一直在试行一个基于区块链的财产转移系统。英国皇家铸币厂也在推行一项数字通证计划，该计划依赖于其作为一个受信任的中央政党的地位。&lt;/p&gt;&lt;p&gt;法律需要改变吗?&lt;/p&gt;&lt;p&gt;在法定的改变允许数字传输之前，不可能将某些类型的物理资产转移到区块链上。在一些国家，有一些法律规定，要求以某种形式进行转移，或者以某种方式注册，而政府当局不适合基于通证的系统。例如，有担保的贷款法律可能会优先授予一个贷款的人，并将其利息登记在拥有一个表示所有权的通证的人身上。&lt;/p&gt;&lt;p&gt;对现实世界的资产进行通证是一个具有挑战性的问题，需要超越技术的创新解决方案。在某些情况下，这将需要法律改革，在其他情况下，它将涉及现有法律规则、新的商业结构和新的数字通证系统的巧妙组合。&lt;/p&gt;&lt;p&gt;这篇客座文章是由Addison Cameron-Huff提供的。所表达的观点是他自己的，并不一定代表分布式账本的那些观点。&lt;/p&gt;&lt;p&gt;本文所表达的是作者的观点，并不一定反映出Nasdaq, Inc.的观点。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;===============================================================&lt;br&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;br&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&quot;&gt;http://weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&lt;/a&gt;&lt;/b&gt; &lt;b&gt;(二维码自动识别)&lt;/b&gt;&lt;br&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)“&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2018-10-21-47288112</guid>
<pubDate>Sun, 21 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>区块链中的随机性</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2018-10-21-47287847.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/47287847&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ee4cc551266723203b679ad6fc03d04e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;随机事件在我们身边无处不在。比如，运气，概率和命运就与随机性密不可分。人类不理解或无法预测的一切事物往往被归类为随机事件。物理世界中也有很多随机事件，比如云的运动、粒子和波的轨迹等。&lt;/p&gt;&lt;p&gt;然而，尽管它是那么的令人熟悉，人类却很难将周围的随机性转化为计算机可以计算的东西。当我们谈论计算机系统中的随机性时，我们指的是伪随机性，这是一种对现实世界随机性的模拟产物。不过，这两种随机性很难区分。我们在这里要讨论的是非常强大的模拟性随机（伪随机）。&lt;/p&gt;&lt;p&gt;随机性在隐私技术和密码学中发挥着重要作用。值得惊叹的是通过一个随机值与一条信息就能提供一种简单而强大的加密方案。比如对称密钥加密技术，两方进行交流时需要事先共享一个保密密钥，但即使是进行最简单的交流也需要确保共享密钥是随机的。如果此共享密钥不随机，则任何人都可以通过已知的密码算法与信息内容窃取保密密钥，加密也就失去了意义。&lt;/p&gt;&lt;p&gt;随机性的作用：&lt;/p&gt;&lt;p&gt;利用随机性可以在两个人之间构建一个安全的通信渠道，也可以用来确认通信双方的身份。此外，如果同时有很多人想通过有限带宽的通信渠道彼此通信，则可以使用随机性来公平地确定消息传递的顺序。随机性也可以用来帮助一群人或计算机达成一致。随机共识协议就是这样一个例子。这篇文章将探讨随机性在区块链中的作用。&lt;/p&gt;&lt;p&gt;区块链是帮助多方在全球层面上就某种程度的更新达成共识的完美例子。更新通常按照回合的方式完成，每个回合是一个周期性的离散时间段。&lt;/p&gt;&lt;p&gt;一般限制共识的的因素有两个：吞吐量（在互联网上的特定时间段内可以发送的消息数量上限）以及延迟（消息通过互联网发送所需的时间）。任何区块链共识协议的目标都是克服上述限制因素达成共识。在公链中，数千个节点参与维护区块链，如果每个节点都需要向其他所有节点发送消息并等待来自所有其他节点的响应，吞吐量与延迟将会让达成共识的成本大幅增加。成本高昂是因为一个回合中传递的信息数量太过庞大，因此为了达成共识而优化网络沟通方案的一个方式就是削减信息的数量。&lt;/p&gt;&lt;p&gt;比特币达成共识的方式（中本聪共识）是使用工作量证明（PoW）作为随机源确定每轮中哪一个区块将被添加到区块链中，从而减少消息传递的开销。因为PoW的计算非常复杂，且只有第一个解决难题的人拥有记账的权利，再加之多人同时解答出难题的概率极低，PoW机制就通过这种方式限制了网络中的信息数量。&lt;/p&gt;&lt;p&gt;当然，任何试图取代PoW的共识机制同样需要一种方法来限制网络传递的消息。大多数的权益证明协议（PoS）解决此问题的方法是选择验证者（即维护/管理区块链的节点），并根据他们抵押代币的数量成立一个委员会小组。然后，该验证小组可以在网络限制下合理地来回通信，最终高效地达成共识。&lt;/p&gt;&lt;p&gt;什么是理想的随机源：&lt;/p&gt;&lt;p&gt;当然，为了公平地选择这个委员会小组的成员并且保证没有人提前知道成员名单，算法必须要得到一些公平且不可篡改的随机源。一旦该验证小组在新区块上达成一致，该区块就会被广播给网络中的其他所有节点。&lt;/p&gt;&lt;p&gt;PoS协议中用于选择委员会成员的理想随机源应确保不可被篡改，随机性协议则需要确保以下两点：&lt;/p&gt;&lt;p&gt;i）随机性函数持续有输出&lt;/p&gt;&lt;p&gt;ii）随机性函数的输出尚未被操纵（注意：我们将在以后的文章中探讨如何平衡第一第二点，以及这与网络同步模型的关系）&lt;/p&gt;&lt;p&gt;我们机械实验室（Mechanism Labs）分析了当下所有的委员会成员选举协议，结论是没有一个协议能同时实现高性能与不可篡改。我们的看法是，鉴于上述权衡，区块链共识协议应选择一个始终有输出的随机源，而不是单单产生无篡改输出的随机源。这是因为区块链协议需要确保链持续增长且不能让随机源成为限制发展的因素。即使对于一致性协议，随机源也不应该是限制区块链发展的原因。总之，随机源应该为协议减轻负担，使协议能够专注于减轻其他攻击，如针对委员会小组的DoS攻击。&lt;/p&gt;&lt;p&gt;如果区块链由于随机性函数停止输出而完全停止，在社会层面上将需要巨大的协调成本来重新启动区块链。社群需要花费大量的时间通过外部社交媒体平台就区块链的形式达成一致，这样做的成本与解决DAO黑客的成本相当。这种巨额成本也会动摇社区对区块链协议安全性的信心。&lt;/p&gt;&lt;p&gt;另一方面，只要偏差很小并且存在修正偏差的机制，仅仅几轮的轻微偏差带给区块链安全性的影响也会很小。这是因为在每一轮公共区块链协议中给予验证者的协议内奖励相对较小。但是由于每轮或每个时期（一组轮次）都会选择新的小组委员，因此在随机性函数中总会存在某个显著的偏差，让验证者可以钻空子赚钱并导致区块链协议的安全性降低。此外，主打随机性的彩票游戏需要确保随机源不被操纵，因为即使一点偏差也会改变彩票的赢家。这是因为篡改彩票结果的效果是巨大的，可以获得了大量的即时奖励。因此，这样的游戏适合仅保证无篡改输出的随机性函数，即使这意味着随机函数的输出有时会停止。&lt;/p&gt;&lt;p&gt;不可篡改随机源的重要性：&lt;/p&gt;&lt;p&gt;接下来我们将讨论在设计区块链协议时不可篡改的随机源的重要性。下文开始，我们提到的协议默认都是不会停止的协议。&lt;/p&gt;&lt;p&gt;理想的委员会选举方案须具备以下两点：&lt;/p&gt;&lt;p&gt;1.不可篡改&lt;/p&gt;&lt;p&gt;2.只在新一轮的开始时显示随机种子。&lt;/p&gt;&lt;p&gt;鉴于上述两点，随机函数也需要具有不可篡改性。如果随机性可以被操纵（并且存在协议奖励分配机制），就会导致奖励的不公平分配。不公平的奖励分配意味着一些人获得更多的奖励。由于只有那些有抵押的人才能成为验证者，并且投票权与验证者所拥有的权益资产成正比，结果将导致区块链最终被某些人掌控。&lt;/p&gt;&lt;p&gt;可以说，哪个协议抗篡改的程度高，它就能在长远中获得维持部分网络的权力。另外，在新一轮回合开始之前公布种子的时间提前量决定了谁可以首先成为网络的一部分。因此，上述两个属性将决定区块链的去中心化程度。&lt;/p&gt;&lt;p&gt;用于选择委员会小组的协议是每一轮或每几轮运行的，因此从该随机函数的输出发布的时间到回合开始的时间是至关重要的。在此时间范围内，攻击者可以使用随机函数的输出来确定哪个验证节点会被选中。如果这个输出被隐藏，则试图攻击区块链协议的攻击者将无法提前确定验证节点。此时间范围的长度决定了协议可以承受的攻击者的强度。强大的攻击者（即具有更多算力和资源攻击网络的人）能够在很短的时间内算出验证节点。如果攻击者有足够的时间，通过委员会成员选择算法和给定轮次的随机种子，就能够确定验证节点。确定验证节点后，攻击者就能够对验证节点发起DoS攻击，从而导致空块以及步骤缺失。&lt;/p&gt;&lt;p&gt;区块链即使只停止一轮也会有非常可怕的后果。想想如果世界上所有人在几个小时内无法进行任何交易，比特币会发生什么！因此，应该选择抗DoS攻击的节点成为验证节点。另一方面，提前揭示随机种子意味着共识协议只能抵抗较弱的攻击，这减弱了区块链的去中心化属性。&lt;/p&gt;&lt;p&gt;现有随机性生成机制：&lt;/p&gt;&lt;p&gt;下面我们将详细介绍各种随机性生成机制。以下内容基于我们在《替代共识协议的元分析》中分析的区块链协议：&lt;/p&gt;&lt;p&gt;&lt;b&gt;Tendermint&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Tendermint共识机制使用确定性循环协议方案来选择提议者; 协议不具有随机性，提议者基于投票权和被选为验证者的次数确定。攻击者只能通过绑定或解除绑定权益对协议施加影响，因为这是对于协议的唯一输入手段。同时，协议不会在短时间内出现偏差，因为验证者需要很长时间才能绑定（即向系统抵押保证金）或者解除绑定（即从系统中&lt;u&gt;撤回保证金&lt;/u&gt;）。不过，在这种机制下攻击者可以提早很久作出计划，误导提议者作出错误选择。&lt;/p&gt;&lt;p&gt;使用确定性随机算法意味着在每轮投票之前可以公开随机种子，不过提议者也会被提前确定。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Algorand&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Algorand共识机制中的随机性方案如下：每轮被选为验证者的v会为回合r计算出种子，公式为&amp;lt; seedr, π &amp;gt; ← VRFskv (seedr−1||r)，公式中skv是验证者v的密钥，seedr−1是前一轮的随机种子。&lt;/p&gt;&lt;p&gt;r-1轮接受的块中包含VRF证明π和r轮的种子。如果给定的VRF证明未验证给定的种子，每个人将用加密哈希函数来计算新一轮的种子，公式为seedr=H（seedr-1） || r）。这意味着每位验证者必须选择好自己的密钥，以确保种子不会发生偏差。&lt;/p&gt;&lt;p&gt;当网络不是强同步时，如果攻击者完全地控制住消息传递链接，进而删除区块提议并强制用户就空块达成一致，就能借此计算出后续的随机种子。因此，Algorand需要弱同步，即在每个长度为u的周期中，必须存在长度为s &amp;lt;u的强同步周期，使协议具有抗偏差性。只要强同步时期s足够长使得b时间段内产生至少一个诚实的区块，选择密钥的攻击者v&#39;就不能使r轮的随机性种子产生偏差。&lt;/p&gt;&lt;p&gt;只有当一个块被提出时，新种子和VRF证明才会去公开地验证它。这确保了提议者和随机种子不会提前泄露。这确保Algorand能够抵御针对提议者的DoS攻击，并且在擦除与瞬时腐化中保持自适应安全性。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Dfinity:&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在几个协议中，攻击者通常会通过中止协议来调用回退机制，从而引入偏差。Dfinity使用的阈值方案是抗偏差的，因为阈值的选择是为了防止攻击者通过阻止阙值签名（阙值签名是随机种子的创造来源）来中止协议。这使得阙值需要符合以下公式：t∈[f + 1，n - f] 其中f是攻击者控制的签名数，n是方案中的签名总数，t是生成随机性所需的签名阈值。符合条件的阈值确保了攻击者无法预测签名创建的结果，更无法阻止签名的创建。&lt;/p&gt;&lt;p&gt;需要注意的是，如果攻击者拥有任何BLS方案中所有存款的50％以上，就能够操纵最终的签名和随机性。但是，如果攻击者真的拥有如此大的股权占比，他们也会有其他的攻击选择，这就打破了Dfinity协议的基本假设。&lt;/p&gt;&lt;p&gt;只要有诚实的验证者前进到第r轮，随机种子就会被公布。虽然诚实的验证者到达r轮与新一轮正式启动之间的时间差距很小，但这个差距足以让拥有大量算力的攻击者找到提议者并发起DoS攻击。这就是Dfinity只能承受轻度适应性攻击而不能承受瞬时腐化的原因。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Thunderella:&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在哈希函数实例化的随机预言方案中，提议者由以下公式确定：H_nonce（pk，q）&amp;lt;Dp 其中H是作为随机预言的哈希函数，pk是验证者的公钥， q是给定的时间步骤，而nonce是哈希函数的熵来源。nonce由前一个块的提议者决定。设定难度参数D_p使得在单个时间步骤中，委员会成员被选为提议者的概率为w。&lt;/p&gt;&lt;p&gt;如果攻击者提出了一个块，他就可以影响下一轮哈希函数的熵来源（nonce），进而影响下一个块中选出的提议者。这种情况下，为了减少随机性方案的偏差值，哈希函数会使用相同的熵来源选择r轮的提议者而不是下一轮提议者。因此攻击者很难暴力改变熵来源，也就无从成为下一轮的提议者。不过这种策略仅能保证多项式安全损失，它伴随着对可预测的妥协，这一点将在后文讨论。总之，该方案导致这个协议仅能够承受慢速适应攻击。&lt;/p&gt;&lt;p&gt;在上述算法中，当重复使用相同的熵来源为哈希函数提供种子时，会导致攻击者能够提前预测出提议者。在一个时期内相同的熵来源被重新用作熵，会导致随机种子在新一轮的开始之前被泄露。造成的后果为攻击者可以腐化提议者或者发起DoS攻击。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Casper FFG:&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Casper FFG计划使用的randao方案采用以下算法：&lt;/p&gt;&lt;p&gt;在轮次开始时每个验证者都提交H（H（H（... Sv）））），其中S是验证者提交的种子。R：=R⊕双层哈希表内层的原像。在一个回合中，验证者可以生成或中止一个区块。&lt;/p&gt;&lt;p&gt;如果在回退机制中不具有随机性，这似乎是比随机性可预测或可偏差更严重的问题，因为那样你不再需要1/3的恶意节点才能中止协议，而是1个人就足够。只需要满足，那个人验证者当前是提议者，且下一轮的种子已经公布，即可1个人中止协议。&lt;/p&gt;&lt;p&gt;随机性是密码学和区块链的关键部分。不良的随机性方案造成的后果有两个：1.中止区块链协议 2.导致中心化，这些后果可能颠覆区块链的所有安全概念。因此，了解随机性在区块链协议中的作用有助于真正理解区块链安全性的本质。&lt;/p&gt;&lt;p&gt;感谢Alexis Gauba和Zubin Koticha提供的宝贵意见。&lt;/p&gt;&lt;p&gt;===============================================================&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&quot;&gt;http://weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&lt;/a&gt;&lt;/b&gt; &lt;b&gt;(二维码自动识别)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)“&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt; &lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2018-10-21-47287847</guid>
<pubDate>Sun, 21 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>比特币必须灭亡</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2018-10-21-47287398.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/47287398&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b3ffc9c53ac33408e1cadd79c9250e5d_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;联合国本周发布了一份报告，敦促各国政府立即采取行动，减轻即将到来的气候灾难的影响。这不再是灾难即将来临的一个问题，而是它将会变得多么糟糕。在解决任何问题时，可以采取两种方法，这通常是互补的。长期的方法是对根本原因进行重组，从而为持久的变革奠定基础。这需要政治意愿、牺牲和努力工作。但也有一些唾手可得的方法，可以立即采取行动，让球滚动起来，立即产生影响。&lt;/p&gt;&lt;p&gt;比特币的崛起让区块链技术受到了全世界的关注。区块链账本是对分布式计算问题的一个重要（经常被夸大的）类别的真正解决方案。但比特币的核心是另一种被称为“工作量证明”（PoW）的老技术，由于这一遗留问题，比特币现在是全球能源消耗的重要贡献者。与其他形式的能源消耗不同，比如航空燃油或取暖油，比特币可能会在明天被关闭，而不会损害个人生活或整体经济。&lt;/p&gt;&lt;p&gt;事实上，将比特币置于死地将有助于拯救经济和环境。&lt;/p&gt;&lt;p&gt;我们必须谨慎地区分区块链账本和工作量证明，因为它们是独立的东西，恰好被合并成比特币。有一些节能的方法来管理区块链分类，比如权益证明算法。其中一些算法已经被竞争对手的加密货币计划所实施，而这些方案并不是这篇文章的主题。然而，PoW是最常用的，主要是因为它更易于实现，也因为区块链生态系统的大部分建立在比特币之上，这是第一个成功的实现。&lt;/p&gt;&lt;p&gt;PoW是一种极其浪费的资源，消耗的电力比整个爱尔兰都要多，产生了无穷无尽的数学垃圾。要理解其中的原因，我们需要了解这种垃圾是如何产生的。&lt;/p&gt;&lt;p&gt;猜谜游戏&lt;/p&gt;&lt;p&gt;工作量证明是基于类似于加密的数学哈希操作，只是不可逆转的。把加密想象成一个魔方——一个操作序列将把一个已解决的立方体变成一个混乱的立方体，而操作的逆序将会解开它。这个过程中的每一步都是完全可逆的。&lt;/p&gt;&lt;p&gt;哈希运算故意避免可逆过程。一个好的哈希算法是一个数学铣刀，咀嚼它的输入，直到它不仅被打乱，而且被有效地破坏。但是如果你看一下肉糜生产的细微细节，不同的输入将（几乎）永远不会产生两次相同的输出。因为这是一个精确的数学铣刀，两个相同的输入总是会产生相同的输出。人们可以说他们以前是一样的，可是他们以前不一样。我们可以识别什么输入产生特定的输出——但是只有通过猜测，将其进行分析，并比较这些混乱的输出。这种蛮力猜游戏很快就会变得单调乏味，随着输入的大小增加，它的难度会成倍增长。&lt;/p&gt;&lt;p&gt;因此，只存储和比较少量的哈希输出通常是足够的。这增加了两个不同输入产生相同输出（哈希碰撞）的几率，但是任意两个随机选择的输入的碰撞概率很小。就像部分指纹足以识别一个嫌疑犯一样，即使是一个短的哈希也足以识别出一个高度自信的输入。随机找到一个三位数哈希的概率是999:1。对于6位数字，是999999:1。对于目前常用的最安全的哈希，它是2 256:1（1后面是77个零）。&lt;/p&gt;&lt;p&gt;然而，这些高安全性的哈希仍然只有78位长，并且可以从无限大小的输入中计算出来。因此，在任何一个人想要比较两件事情的地方，都不需要提前说明什么是比较，也不需要存储完整的加密副本。数字签名、密码数据库、完整性检查，都依赖于哈希的存储效率，以及它对蛮力猜测的抵制。&lt;/p&gt;&lt;p&gt;但如果这是一场游戏，我们想让别人猜出答案呢？那么，我们将减少哈希输出的大小，直到找到一个解决方案，然后依次尝试每一个有效的输入。我们通过一些预先安排的方法生成目标输出，并向我们的玩家发起挑战，让他们找到产生它的输入。这个解决方案不是唯一的——因为每个输出都有无数个可能的输入，因为我们没有指定一个特定的大小，这样做可能会在无意中使这个难题变得不可能。关键的特征是，解决方案很难找到，但是一旦发现很容易检查。&lt;/p&gt;&lt;p&gt;解决方案本身就是毫无价值的琐事，除了证明你确实在努力寻找它之外，没有任何用处。&lt;/p&gt;&lt;p&gt;用百元钞票点燃一支雪茄&lt;/p&gt;&lt;p&gt;这种工作量证明的游戏只提供一个目的：作为计算过剩的公开演示。一个名为Hashcash的早期反垃圾邮件建议，建议每发送一封电子邮件都应该有一个PoW解决方案。这个谜题将取决于电子邮件的全部细节，这意味着它必须重新计算每条信息和每一个收件人。任何没有有效的PoW解决方案的电子邮件都将被视为垃圾邮件。这一困难将被校准，以便发送少量的电子邮件会带来轻微的不便，但高利润率的低利润垃圾邮件活动将会非常昂贵。&lt;/p&gt;&lt;p&gt;Hashcash从未被用于反垃圾邮件，但它在10年后获得重生，作为一种确保每次只能将一大块交易写入比特币公共账本的方法。为了增加一个新的区块，一个自封的比特币会计师必须解决使用前几个区块的内容生成的Hashcash难题。然后，解决方案成为下一个区块的难题的一部分，确保交易以严格的顺序被附加，并且可以立即检测到不一致。只要没有人拥有足够的计算能力在比其他人花费更少的时间内找到两个有效但矛盾的解决方案，就可以立即检测和删除不一致（即欺诈）交易。&lt;/p&gt;&lt;p&gt;至关重要的是，作为第一个解决这个难题的人，胜利者有权创造（或“我的”）一些新的比特币，这是一个利润丰厚的奖品。这就是经济学所占据的位置。如果你给人们钱来解决无用的谜题，他们就会夜以继日地解决无用的谜题，只要奖金超过了成本。随着比特币价格的飙升，越来越多的人决定玩“hashcash”游戏，投资于规模更大、越来越需要电力的采矿电脑。&lt;/p&gt;&lt;p&gt;当全球每天开采的比特币的总价值与运行设备的总成本相匹配时，就达到了平衡。而且，由于比特币的设计初衷是为了自我调节，因此新币的生产速度大致保持不变，所以开采的比特币的总价值几乎完全取决于比特币的汇率。比特币的价格越高，开采的越多，消耗的电力就越多，计算出的数学垃圾也越多。&lt;/p&gt;&lt;p&gt;由此带来的意想不到的后果是，比特币区块链将在今年年底消耗相当于奥地利一整年的电力。&lt;/p&gt;&lt;p&gt;遥遥无期&lt;/p&gt;&lt;p&gt;如果你把黄金变成一枚硬币，黄金仍然存在。资源没有被破坏，只是改变了。如果你把纸变成钞票，你会花一些资源去印刷，但比它的面值要少很多倍，当银行系统崩溃时，你可以用钞票来做厕纸——因为这就是它曾经的全部。如果你用电力来解决一个hashcash难题，那么被烧成的有价值的（和污染的）燃料将永远消失，但这个谜题解决方案在比特币系统之外没有任何价值。因此，它结合了黄金支持和法定货币的最坏情况。&lt;/p&gt;&lt;p&gt;不像金币，它的生产成本很高，但也代表了独立的财富储备，或者是没有内在价值但生产成本低廉的法定货币，比特币既不便宜，也不可靠。它在现代货币中是独一无二的，因为它的价值不在于它的支持者在保险箱里藏了多少财富，也不在于他们的国民经济中有多少财富，而在于他们在多大程度上燃烧了他们的财富。&lt;/p&gt;&lt;p&gt;然而，有一个历史先例。在许多工业化前的社会中，壳类被用作货币。这有一个不幸的副作用，你可以从海里捞到钱。在更先进的壳类货币中，收集壳的人不得不辛辛苦苦地工作，以使它们更有价值。这稳定了货币，但只有把它直接固定在手工研磨壳所花的时间的价值上，而这些时间本来可以在其他地方得到更有效的利用。&lt;/p&gt;&lt;p&gt;这就是为什么比特币和其他所有的工作量证明计划都必须消亡的原因。这是一种类似于贝壳货币的计算等价物，唯一的区别在于，它的价值依赖于电力消耗，而不是工作时间。像犀牛角和虎骨这样的空壳货币，客观上是毫无价值的，对它们的非理性需求是对人类和环境资源的不道德的浪费。&lt;/p&gt;&lt;p&gt;Hashcash谜题客观上毫无价值，但对它们的非理性需求正在毁灭地球。&lt;/p&gt;&lt;p&gt;通话时间&lt;/p&gt;&lt;p&gt;像比特币这样的加密货币在政治上和实际上都是脆弱的。它们在政治上受到了影响，因为包括中国在内的许多国家已经开始打击比特币的使用，原因多种多样，而不仅仅是浪费。他们实际上也很脆弱，因为你不可能在没有银行账户或信用卡的情况下轻易地购买比特币，银行也可以简单地拒绝（或被禁止）与工作量证明计划做生意。因此，关闭比特币可以在现有的国际银行监管框架内完成。&lt;/p&gt;&lt;p&gt;如果比特币明天停止交易，世界上0.5%的电力需求将会消失。这大致相当于10个燃煤电厂的产出，每年排放5000万吨二氧化碳——这将覆盖一年内的碳排放削减，以限制本世纪气温上升到2摄氏度。这不是一个解决方案，但这将是一个好的一年的工作。&lt;/p&gt;&lt;p&gt;比特币是由灰烬制成的，如果骨灰是法定货币，人类就会把所有的东西都烧光，称之为进步。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;文章首发在微信公众号：btc201800&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&quot;&gt;http://weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&lt;/a&gt; (二维码自动识别)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;音频发布在喜马拉雅上“区块链杂谈 (第2季)“&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;宁波格密链网络科技有限公司，专注于区块链上的密码技术研发。&lt;/b&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2018-10-21-47287398</guid>
<pubDate>Sun, 21 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>私有链谬论</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2018-10-07-46112778.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/46112778&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7519ea10c8b959491a7910302deea534_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;由格密链社区翻译&lt;/p&gt;&lt;p&gt;在所有被炒作的区块链中，一个简单但自我反驳的想法不断涌现：私有链。&lt;/p&gt;&lt;p&gt;为了理解为什么私有链是无意义的，我们必须首先定义什么是区块链（block chain），什么不是。既然中本聪创造了这个词，我们来看看他的描述是否我们有帮助：&lt;/p&gt;&lt;p&gt;一个点对点的分布式时间戳服务，用于生成交易时间顺序的计算证明。&lt;/p&gt;&lt;p&gt;它确实体现了“区块链”的一些重要特征（中本聪在block和chain这两个词之间加了一个空格，但我使用了当前流行的术语——blockchain）：&lt;/p&gt;&lt;p&gt;·点对点：暗示分布；至少排除了中央集权的可能性&lt;/p&gt;&lt;p&gt;·计算证明：意味着它是可验证的&lt;/p&gt;&lt;p&gt;·时间戳服务/时间顺序：这是目标，但也意味着永久&lt;/p&gt;&lt;p&gt;Marco Iansiti和Karim R Lakhani有一个更容易理解的解释：&lt;/p&gt;&lt;p&gt;一种公开的、分布式账本，可以有效地、可核查的、永久地记录双方之间的交易。&lt;/p&gt;&lt;p&gt;·公开的（通常称为无需许可的）&lt;/p&gt;&lt;p&gt;·分布式的（通常称为去中心化的）&lt;/p&gt;&lt;p&gt;·可验证的&lt;/p&gt;&lt;p&gt;·永久的（通常称为不可变的）&lt;/p&gt;&lt;p&gt;换句话说：任何不符合这些标准的东西，根据定义，都不是区块链。它可能是类似的，或者使用类似的技术，但不是区块链。这是很重要的。&lt;/p&gt;&lt;p&gt;我们也可以从另一方面来看：如果区块链提供了这些特性，我们什么时候需要区块链呢？&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ce801bb49710bf700079fa444e1ce1aa_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;337&quot; data-rawheight=&quot;276&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ce801bb49710bf700079fa444e1ce1aa&quot; data-watermark-src=&quot;v2-4b5846aac20bcb1f6bba607d4a3ec388&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这有相同的看法，但将争论的焦点转向：如果您的需求不符合区块链提供的确切内容，您不需要区块链。对于私有链：如果它不公开，则不需要区块链。我们可以就此打住。&lt;/p&gt;&lt;p&gt;&lt;b&gt;想要一个私有链的理由&lt;/b&gt;&lt;/p&gt;&lt;p&gt;那么，为什么人们会首先想到私有链呢？我们可以把论点分成三个主要论点（再加上第四个）。&lt;/p&gt;&lt;p&gt;1、我们可以存储私人数据或其他不应该公开的数据。（我们放弃了公开和可验证部分来保护隐私）&lt;/p&gt;&lt;p&gt;2、我们可以控制谁拥有读写权限（我们放弃了公开性来进行控制）&lt;/p&gt;&lt;p&gt;3、我们可以更好地扩展（我们放弃了分布式部分以提高速度）。&lt;/p&gt;&lt;p&gt;4、我们对在公共平台上发布的安全性和确切特性还不够自信（我们放弃了永久性以获得灵活性）&lt;/p&gt;&lt;p&gt;第四个是使用私有链的唯一有效论据：作为临时阶段，因为你仍在开发并查找区块链应用程序的内容：非常类似于你首次向五个朋友发布应用程序的方式，而不是立即上传到应用程序商店。&lt;/p&gt;&lt;p&gt;所有其他的原因都是纯粹的废话，因为他们不需要区块链来获得完全相同的结果。或者因为根据定义，这样部署，它就不是区块链。可以这样说，在私有环境中部署区块链，它就不再是区块链了。&lt;/p&gt;&lt;p&gt;但是，这不仅仅是文字游戏。请继续关注下文。&lt;/p&gt;&lt;p&gt;&lt;b&gt;私人数据：公开&lt;/b&gt;&lt;/p&gt;&lt;p&gt;区块链必须是公开的，以确保持久性或不变性。&lt;/p&gt;&lt;p&gt;让我们将区块链比作一本家庭书籍（用于记录生活的点滴）。当我有这样一本书，并且它存放在我办公室的抽屉里，我是唯一一个可以查看和修改它的人。&lt;/p&gt;&lt;p&gt;所以，当我因为某种原因买了一双昂贵的鞋子，一个星期后我想隐藏这个事实，我可以简单地从书中删除这一行。或者用“剪刀”把它覆盖。boom，我从未买过鞋（根据书中所说）。&lt;/p&gt;&lt;p&gt;但如果家庭成员可以访问这本书，每个人都可以查看或复制，它就会变得更加“不可改变”。我仍然可以删除“昂贵的鞋子”的记录，但人们可能知道，家人可以打电话给我。如果有更多的人可以查看这本书（为什么不将每周的副本邮寄给所有的家人和朋友？），之后更改内容变得越来越困难。&lt;/p&gt;&lt;p&gt;然而，区块链还有一个特点：通过应用密码学技术，它可以让人们轻松检测出书中的一行被更改了。因此，拥有副本的所有人都可以轻松地察觉到一些不应该被改变的事情已经发生了。但只有在其他利益相关者可以获得副本时，这种特性才有用。在私有链中，很容易改变一些东西，即使这种改变会带来很大的、明显的影响。仅仅是因为没有人见证这显而易见的影响!&lt;/p&gt;&lt;p&gt;公开，是确保永久性的因素。不是因为改变某件事是不可能的（这是完全可行的），而是因为其他参与者可以看到这种改变或其加密效应。&lt;/p&gt;&lt;p&gt;例如，从理论上讲，比特币也不是永久性的。如果有足够多的参与者决定把你一年前付给John的0.01btc送给Mallory，那就会发生这样的事情：历史将被改写。比特币的不变性源于这样一个事实：任何人都能察觉到这种变化，而绝大多数人都需要承认这种变化。&lt;/p&gt;&lt;p&gt;此外，公开还确保了参与者在进行这种回溯性改变时将受到损害：他们与（比特币）区块链有利害关系，因为他们刚刚证明了这个区块链可以被回溯，所以它会跌价。&lt;/p&gt;&lt;p&gt;在区块链中，无论是公开的还是私人的，不可变性更多的是所有参与者的共识，即我们不会改变历史。承诺!这并不是什么神奇的“来自密码学的东西”。在私有链中，这个承诺很容易实现。甚至更容易执行：如果Mallory改变了一些旧记录，就把他扔出去!&lt;/p&gt;&lt;p&gt;记住这一点：不可变性是一种协议（共识），因此您可以选择任何数据库，甚至共享excel表，然后彼此承诺不会更改任何内容。您所需要的只是检测某些内容发生了更改，这是大多数数据库系统（或日志记录）将提供的。您甚至可以在其中添加一些密码学技术，使篡改更明显或更容易恢复（或处理）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;无需许可，因为我们需要控制。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;区块链必须是无需许可的（无权限），以确保永久性。&lt;/p&gt;&lt;p&gt;这其实很简单。如果你能控制谁有权限，你就能控制谁来决定事实。因此，你掌握着以任何你想要的方式改变历史的钥匙。&lt;/p&gt;&lt;p&gt;在家庭用书的类比中，谁可以控制书的读写，延伸开来，就是可以决定书中内容的人。&lt;/p&gt;&lt;p&gt;推而广之，那个人也就完全拥有改写历史的权限。因为当访问控制器想要更改某些内容时，他可以简单地将反对更改的任何人从写（和读）访问中删除，然后将自己（或代理）权限提升为能够写入。然后改变它。&lt;/p&gt;&lt;p&gt;如果其他人还能查看，他们可能会注意到历史被改写了，但却没有能力对此做些什么。事实是区块链中的内容，由于缺乏权限，他们无法更改。这样一个回溯性的改变是多么笨拙或多么明显：拥有访问控制权的人可以通过该权力进行这些变更。&lt;/p&gt;&lt;p&gt;区块链中的不变性并非来自于一种神奇的技术。但它来自于区块链所需的条件：运行它的环境或“世界”使其不可变。&lt;/p&gt;&lt;p&gt;具有讽刺意味的是，实际上，有一种神奇的技术可以确保不变性。这种技术被称为区块链。同时必须是公有链。我们回到原点。&lt;/p&gt;&lt;p&gt;&lt;b&gt;不采用分布式，因为扩展或速度。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;区块链必须是分布式的，以确保可验证的事实。&lt;/p&gt;&lt;p&gt;分布式的反面是中心化。按照“家庭用书”的比喻，分布式意味着每天会有好几次（甚至在每次更改之后）都会在人们之间复印和交换副本。然而，更重要的是，这些副本都不被视为“事实”。&lt;/p&gt;&lt;p&gt;如果只有一本家庭用书，那么改变里面的内容（比如撕掉一页纸）是微不足道的，如果做的好，是无法被察觉的。&lt;/p&gt;&lt;p&gt;显而易见的解决方案是复印每一页（例如每天），并将这些副本保存在多个地方。这就是分布式。这是低效的、缓慢的和昂贵的，而不是简单地相信持有的一个副本。但实际上这就是区块链的作用。因为信任的确切原因：这样我们就不必相信一个副本持有人告诉我们的事实。这就是区块链无需信任的本质。&lt;/p&gt;&lt;p&gt;当所有的副本在任何时刻都可以被认为是真实的，任何副本之间的任何差异都将被检测到，并能够触发警报。那么，我们就需要一个冲突解决方案：哪一个才是事实。&lt;/p&gt;&lt;p&gt;在比特币中，他们只是简单地说：大多数副本持有者拥有的是事实。如果你的书被五个人抄写，其中有两个人的书中包含&quot;伯克买了昂贵的鞋子&quot;，但另外三个没有，则伯克没有买昂贵的鞋子。&lt;/p&gt;&lt;p&gt;如果只有一本书被选为真理，而所有其他的书都只是用来证明某些东西在某个时候存在的副本，那真的证明不了什么：谁能说持有副本的人没有在里面伪造一些记录？&lt;/p&gt;&lt;p&gt;所有参与者之间的分配至关重要，因为任何中央权威机构都可以随意改变历史而不被发现：验证是不可能的，并且需要对权威机构甚至是一小部分权威机构信任。&lt;/p&gt;&lt;p&gt;回过头来：当你不需要这种不信任感，当你可以信任一个中央权威时，你根本就不需要区块链。或者如果需要信任，有权威，从本质上讲，它不是区块链。&lt;/p&gt;&lt;p&gt;&lt;b&gt;我最喜欢的加密货币是怎样的？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果它有一个“私有的”或“需要许可的”区块链，其实它根本就不需要使用区块链。它可能仍然是一个非常现代的数据库（由加密支撑的数据库）所支撑的加密货币，但它只是没有使用区块链。因为它没有使用区块链，所以它缺少一个或多个关键特征。&lt;/p&gt;&lt;p&gt;这意味着一家公司可以随时拿走你的加密货币(例如，Ripple)。或者这意味着它从根本上是不安全的。或者它可能会提供非常有趣的解决方案。&lt;/p&gt;&lt;p&gt;我可能会基于信任和谷歌电子表格构建一个非常有用和有趣的货币兑换系统。但它不是区块链。它只是谷歌服务器上的一个电子表格（围绕它有一个非常新颖的想法）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;&quot;你说番茄，我说番茄&quot;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;确定。如果您想将任何数据库称为区块链，请继续。如果您坚持称一个谷歌电子表格为区块链:好的。它不是一些受保护的或商标的术语。你甚至可以称我的自行车为区块链。毕竟它有一条链子。&lt;/p&gt;&lt;p&gt;但这对谁都没有帮助。因为你要么是在重新发明一个轮子，要么是在一个更合适的地方使用一种非常低效的技术，更高效的技术会帮助你做得更好。&lt;/p&gt;&lt;p&gt;一些私有链不是区块链，因为它们只是其他技术。&lt;/p&gt;&lt;p&gt;但遗憾的是，大多数私有链实际上只是低效的、不安全的或仅仅是愚蠢的实现，在这种实现中，公有链的相关设置并未被采用。这没有提供公共版本的任何好处，但具有所有的缺点。&lt;/p&gt;&lt;p&gt;以git为例：git不是区块链；git是DAG；所以别叫它区块链。DAG是一种非常优雅、高效的数据结构。这甚至可以用于在一小群需要对其数据进行加密安全篡改检测的参与者中进行分布式数据存储。我之所以提到git，是因为有些加密货币正是这样做的：使用DAG在一组私有参与者之间共享“真理”。&lt;/p&gt;&lt;p&gt;或者以BitTorrent为例：BitTorrent不是区块链；所以请不要这样称呼它。BitTorrent是Merkle树的一种非常巧妙的实现，并且非常适合在大量参与者之间分发大量数据。它并不是区块链。我之所以提到它，是因为如果您需要确保所有参与者都有数据的副本，这项技术通常就足够了。&lt;/p&gt;&lt;p&gt;实际上有成千上万种数据库类型，有些允许极其简单的同步，有些允许惊人的吞吐量，还有一些允许真正彻底的一致性检查。或者用密码签名的日志。或加密数据，或共享部分数据，或…。我们不会因为炒作而称所有这些为“区块链”。它们不是：它们只是特定用例的适当解决方案。区块链就是这样一种解决方案，和大多数技术一样，它适用于非常小的用例子集。然而，私有版本永远不可能是这样的子集。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;文章首发在微信公众号：btc201800&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&quot;&gt;http://weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&lt;/a&gt; (二维码自动识别)&lt;/p&gt;&lt;p&gt;相应音频发布在喜马拉雅上“区块链杂谈 (第2季)“&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2018-10-07-46112778</guid>
<pubDate>Sun, 07 Oct 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>zkSNARK零知识证明(未完待续)</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2018-09-24-45038515.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45038515&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;证明有一个多元多项式的解。&lt;/p&gt;&lt;h2&gt;同态隐藏Homomorphic Hidings(HH)&lt;/h2&gt;&lt;p&gt;函数 &lt;equation&gt;E(x)&lt;/equation&gt; 如果满足以下条件:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;知道 &lt;equation&gt;E(x)&lt;/equation&gt; ,几乎不可能解出 &lt;equation&gt;x&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;如果 &lt;equation&gt;x \neq y&lt;/equation&gt; ,则 &lt;equation&gt;E(x)\neq E(y)&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;如果知道 &lt;equation&gt;E(x),E(y)&lt;/equation&gt; ，可以推算出 &lt;equation&gt;E(x+y)&lt;/equation&gt; 等&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;则 &lt;equation&gt;E(x)&lt;/equation&gt; 为 &lt;equation&gt;x&lt;/equation&gt; 的Homomorphic Hidings(HH)&lt;/p&gt;&lt;p&gt;例如Alice想向Bob证明自己有 &lt;equation&gt;x+y=7&lt;/equation&gt; 的可行解：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Alice计算 &lt;equation&gt;E(x),E(y)&lt;/equation&gt; ,然后发给Bob&lt;/li&gt;&lt;li&gt;Bob通过 &lt;equation&gt;E(x),E(y)&lt;/equation&gt; 计算出 &lt;equation&gt;E(x+y)&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;Bob检查是否满足 &lt;equation&gt;E(x+y)=E(7)&lt;/equation&gt; ,如果等式成立，那么Bob接收Alice有 &lt;equation&gt;x+y=7&lt;/equation&gt; 的解&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;通过这个过程，Alice并没有暴露可行解，但又可以向Bob证明自己有可行解&lt;/p&gt;&lt;h2&gt;Blind evaluation of a polynomial&lt;/h2&gt;&lt;p&gt;在 &lt;equation&gt;\mathbb{F}_p&lt;/equation&gt; 上的d次多项式 &lt;equation&gt;P&lt;/equation&gt; :&lt;/p&gt;&lt;p&gt;&lt;equation&gt;P(X)=a_0+a_1\cdot X +a_2\cdot X^2 + a_3\cdot X^3+...+a_d\cdot X^d, \text{其中}a_0,...a_d\in \mathbb{F}_p&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;我们想用 &lt;equation&gt;s\in \mathbb{F}_p&lt;/equation&gt; 隐藏起来，例如这里我们用HH函数 &lt;equation&gt;E(x)=g^x&lt;/equation&gt; ，则有:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;E(ax+by)=g^{ax+by}=g^{ax}\cdot g^{by}=E(x)^a\cdot E(y)^b&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以看到 &lt;equation&gt;x,y&lt;/equation&gt; 线性组合的同态隐藏可以通过 &lt;equation&gt;E(x),E(y)&lt;/equation&gt;算出来，那么：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;P(s)=a_0+a_1\cdot s + a_2\cdot s^2+...+a_d\cdot s^d &lt;/equation&gt; &lt;equation&gt; 因为P(s)是s^1,...,s^d的线性组合，所以E(P(s))\text{可以通过}E(s),E(s^2),...E(s^d)算出来&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们得到以下协议：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Bob选出 &lt;equation&gt;s\in \mathbb{F}_p&lt;/equation&gt; 并计算出 &lt;equation&gt;E(s),E(s^2),...E(s^d)&lt;/equation&gt; ，发给Alice&lt;/li&gt;&lt;li&gt;Alice通过 &lt;equation&gt;E(s),E(s^2),...E(s^d)&lt;/equation&gt; 计算出 &lt;equation&gt;E(P(s))&lt;/equation&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这里的多项式盲求值（Blind evaluation of a polynomial），表现在Alice不需要知道 &lt;equation&gt;s&lt;/equation&gt; 就可以计算 &lt;equation&gt;P(s)&lt;/equation&gt; 的同态隐藏&lt;/p&gt;&lt;p&gt;但现在出现了一个问题，Alice可以随意发一个并不是 &lt;equation&gt;E(P(s))&lt;/equation&gt; 的结果。在这种情况下Bob怎么检查Alice发的确实是 &lt;equation&gt;E(P(s))&lt;/equation&gt; 呢？&lt;/p&gt;&lt;h2&gt;Verifiable blind evaluation of a polynomial&lt;/h2&gt;&lt;p&gt;先看case1:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Bob发给Alice, &lt;equation&gt;(a,b)&lt;/equation&gt; ,其中 &lt;equation&gt;b=\alpha\cdot a&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;Alice需要计算并发送 &lt;equation&gt;(a&#39;,b&#39;)&lt;/equation&gt; 给Bob，必须满足 &lt;equation&gt;b&#39;=\alpha\cdot a&#39;&lt;/equation&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;因为Bob推算不出 &lt;equation&gt;\alpha&lt;/equation&gt; ,所以只能取 &lt;equation&gt;a&#39;=\gamma\cdot a, b&#39;=\gamma\cdot b&lt;/equation&gt; ,才能满足要求&lt;/p&gt;&lt;p&gt;再看case2:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Bob发送 &lt;equation&gt;(a_1, b_1),(a_2, b_2),\ b_1=\alpha\cdot a_1,b_2=\alpha\cdot a_2,&lt;/equation&gt; 给Alice&lt;/li&gt;&lt;li&gt;Alice需要计算并发送 &lt;equation&gt;(a&#39;,b&#39;)&lt;/equation&gt; 给Bob，必须满足 &lt;equation&gt;b&#39;=\alpha\cdot a&#39;&lt;/equation&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这种情况下,Alice可以选择 &lt;equation&gt;a&#39;=c_1\cdot a_1 + c_2\cdot a_2,\  b&#39; = c_1\cdot b_1 + c_2\cdot b_2&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;可以看到只要Bob只要检查 &lt;equation&gt;b&#39;=\alpha\cdot a&#39;&lt;/equation&gt; 可以保证 &lt;equation&gt;a&#39;&lt;/equation&gt; 是 &lt;equation&gt;a&lt;/equation&gt; 的线性组合&lt;/p&gt;&lt;p&gt;case3:&lt;/p&gt;&lt;p&gt;再回到多项式的情况,&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Bob发送 &lt;equation&gt;(E(s),  E(\alpha\cdot s)), (E(s^2),  E(\alpha\cdot s^2)),...,(E(s^d), E(\alpha\cdot s^d)),  &lt;/equation&gt; 给Alice,设 &lt;equation&gt;E(x)=x\cdot g&lt;/equation&gt; ,也就是 &lt;equation&gt;(s\cdot g,s^2\cdot g,...,s^d\cdot g), (\alpha s\cdot g,\alpha s^2\cdot g,...,\alpha s^d\cdot g)&lt;/equation&gt;&lt;/li&gt;&lt;li&gt;Alice选择 &lt;equation&gt;a&#39;=\sum_{i=0}^{d}{c_i s^i\cdot g}=P(s)\cdot g=\sum_{i=0}^{d}{c_i E(s^i)},&lt;/equation&gt;&lt;equation&gt; b&#39;=\sum_{i=0}^{d}{c_i \alpha s^i\cdot g}=\alpha P(s)\cdot g=\sum_{i=0}^{d}{c_i \alpha E(s^i)},&lt;/equation&gt; 发给bob&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Bob检查 &lt;equation&gt;b&#39;=\alpha\cdot a&#39;&lt;/equation&gt; 后，可以认定 &lt;equation&gt;a&#39;=E(P(s)), &lt;/equation&gt; 其中 &lt;equation&gt;P(s)=c_0+c_1\cdot s + c_2\cdot s^2+...+c_d\cdot s^d &lt;/equation&gt; &lt;/p&gt;&lt;p&gt;也就是Bob可以验证Alice发过来的是之前Bob发给Alice的同态隐藏的线性组合的同态隐藏&lt;/p&gt;&lt;h2&gt;Quadratic Arithmetic Program(QAP)&lt;/h2&gt;&lt;p&gt;设一个QAP为 &lt;equation&gt;Q&lt;/equation&gt; ，size为m, degree为d，包含 &lt;equation&gt;L_1,L_2,L_3,...,L_m,\ R_1,R_2,R_3,...,R_m,\ O_1,O_2,O_3,...,O_m,\text{和一个d次目标多项式}T&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一组 &lt;equation&gt;\{c_0, c_1, c_2,...,c_m\}&lt;/equation&gt; 如果满足:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;L=\sum_{i=1}^{m}{c_i\cdot L_i},\  R=\sum_{i=1}^{m}{c_i\cdot R_i},\  O=\sum_{i=1}^{m}{c_i\cdot O_i}, \text{和 }P:=L\cdot R - O, \text{并且有}T\text{ 整除}P   &lt;/equation&gt; &lt;/p&gt;&lt;p&gt;则称这组 &lt;equation&gt;\{c_0, c_1, c_2,...,c_m\}&lt;/equation&gt;满足 &lt;equation&gt;Q&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;Pinocchio协议&lt;/h2&gt;&lt;p&gt;如果Alice有满足 &lt;equation&gt;Q&lt;/equation&gt; 的一组解，那么一定有d次多项式 &lt;equation&gt;H&lt;/equation&gt; 满足:&lt;/p&gt;&lt;p&gt;&lt;equation&gt;P = H\cdot T\text{ 等价于：对于}\forall s \in \mathbb{F}_p\text{有}P(s)=H(s)\cdot T(s)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们看一下Alice怎么向Bob证明自己有满足 &lt;equation&gt;Q&lt;/equation&gt; 的解&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Alice算出满足 &lt;equation&gt;Q&lt;/equation&gt; 的 &lt;equation&gt;L,R,O,H&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;Bob选择 &lt;equation&gt;s \in \mathbb{F}_p&lt;/equation&gt; ,计算出 &lt;equation&gt;E(T(s))&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;Alice计算出 &lt;equation&gt;E(L(s)),E(R(s)),E(O(s)),E(H(s))&lt;/equation&gt; 发给Bob&lt;/li&gt;&lt;li&gt;Bob检查 &lt;equation&gt;E(L(s)\cdot R(s)-O(s))=E(H(s)\cdot T(s))&lt;/equation&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这里的&lt;b&gt;第一个问题&lt;/b&gt;是:只检查 &lt;equation&gt;s&lt;/equation&gt; 一个点，会不会有问题？&lt;/p&gt;&lt;p&gt;两个不同的 &lt;equation&gt;2d&lt;/equation&gt; 次多项式，不可能超过 &lt;equation&gt;2d&lt;/equation&gt; 个点相同，所以只要 &lt;equation&gt;\mathbb{F}_p&lt;/equation&gt; 的size比 &lt;equation&gt;2d&lt;/equation&gt; 大很多就没有问题，取到相同点的概率非常的小&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里会有&lt;b&gt;第二个个问题&lt;/b&gt;: Alice可以随意构造出 &lt;equation&gt;L,R,O,H&lt;/equation&gt; 满足 &lt;equation&gt;L\cdot R-O =T\cdot H&lt;/equation&gt; ,但是并不能满足 &lt;equation&gt;L=\sum_{i=1}^{m}{c_i\cdot L_i},\  R=\sum_{i=1}^{m}{c_i\cdot R_i},\  O=\sum_{i=1}^{m}{c_i\cdot O_i}&lt;/equation&gt; 。我们可以想一个办法把这个限制条件也加进去:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;利用Verifiable blind evaluation of a polynomial，直观的方法是对于 &lt;equation&gt;L_i&lt;/equation&gt; ：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Bob计算并发送 &lt;equation&gt;(E(L_0(s)), \alpha\cdot E(L_0(s))), (E(L_1(s)), \alpha\cdot E(L_1(s))),...,(E(L_m(s)), \alpha\cdot E(L_m(s))),  &lt;/equation&gt; &lt;/li&gt;&lt;li&gt;Alice &lt;equation&gt;a&#39;=\sum_{i=0}^{m}{c_i E(L_i(s))}, b&#39;=\sum_{i=0}^{m}{c_i \alpha E(L_i(s))}&lt;/equation&gt; ,其中 &lt;equation&gt;a&#39;=\sum_{i=0}^{m}{c_i\ E(L_i(s))}=E(L(s))&lt;/equation&gt; &lt;/li&gt;&lt;li&gt;Bob接收到之后检查是否满足 &lt;equation&gt;b&#39;=\alpha\cdot a&#39;&lt;/equation&gt; ,同时检查 &lt;equation&gt;a&#39;=E(L(s))&lt;/equation&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这样可以确保 &lt;equation&gt;L,&lt;/equation&gt; 是 &lt;equation&gt;L_0,L_1,...,L_m&lt;/equation&gt; 的线性组合。&lt;/p&gt;&lt;p&gt;同样对于 &lt;equation&gt;R_i,O_i&lt;/equation&gt; 也是一样&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这样弄完之后，还会有问题: &lt;equation&gt;L,R,O&lt;/equation&gt; 用的 &lt;equation&gt;c_0,c_1,...,c_m&lt;/equation&gt; 不是一组。用下面的方法解决:&lt;/p&gt;&lt;p&gt;令&lt;equation&gt;F=L+X^{d+1}\cdot R + X^{2(d+1)}\cdot O&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;F_i=L_i+X^{d+1}\cdot R_i + X^{2(d+1)}\cdot O_i&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;证明 &lt;equation&gt;F&lt;/equation&gt; 是 &lt;equation&gt;F_i&lt;/equation&gt; 的线性组合(这样肯定用的是一组 &lt;equation&gt;c_0,c_1,...,c_m&lt;/equation&gt; )，并且 &lt;equation&gt;E(F(s))=E(L(s)+s^{d+1}\cdot R(s) + s^{2(d+1)}\cdot O(s))&lt;/equation&gt; ,到此问题二彻底解决&lt;/p&gt;&lt;h2&gt;Elliptic Curves Pairings(椭圆曲线配对)&lt;/h2&gt;&lt;p&gt;我看到我们需要处理乘法的情况,例如证明 &lt;equation&gt;E(L(s)\cdot R(s)-O(s))=E(H(s)\cdot T(s))&lt;/equation&gt; 和 &lt;equation&gt;E(F(s))=E(L(s)+s^{d+1}\cdot R(s) + s^{2(d+1)}\cdot O(s))&lt;/equation&gt; 的时候，需要把 &lt;equation&gt;E(x\cdot y)&lt;/equation&gt; 拆成 &lt;equation&gt;E(x),E(y)&lt;/equation&gt; ，而我们现在只有 &lt;equation&gt;E(x+ y)&lt;/equation&gt; 可以拆成 &lt;equation&gt;E(x),E(y)&lt;/equation&gt;。&lt;/p&gt;&lt;p&gt;这里我们除了借助cyclic group来处理加法的情况，还需要借助Elliptic Curves Pairing来处理乘法的情况。Elliptic Curves Pairings本身涉及比较复杂的数学证明，后面会专门开篇写。这里只需要知道Elliptic Curves Pairing其中的Tate Pairing的一个结论就行了：&lt;/p&gt;&lt;p&gt;&lt;equation&gt; Tate: \mathbb{G}_{1} \times \mathbb{G}_{2} \rightarrow \mathbb{G}_{T}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;Tate(g,h)=g_{T}&lt;/equation&gt; ,其中 &lt;equation&gt;g\in \mathbb{G_1},h\in \mathbb{G_2},g_T \in \mathbb{G}_T&lt;/equation&gt; , &lt;equation&gt;g,h,g_T,&lt;/equation&gt; 分别是这几个group的生成器&lt;/p&gt;&lt;p&gt;&lt;equation&gt;Tate(a\cdot g, b\cdot h)={g_T}^{ab}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;有了这个工具之后 &lt;equation&gt;E(xy)={g_T}^{xy}=Tate(x\cdot g,y\cdot h )=Tate(E_1(x),E_2(y))&lt;/equation&gt; ,这样我们就找到了乘法的同态隐藏的方法。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;未完待续。。。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Caprice</author>
<guid isPermaLink="false">2018-09-24-45038515</guid>
<pubDate>Mon, 24 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>黎曼猜想是否会对密码学的安全产生影响</title>
<link>https://henix.github.io/feeds/zhuanlan.fhe-blockchain/2018-09-23-45186127.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45186127&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-50e3aa3d36cec7d4a5dc149e502e4846_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;黎曼猜想是否会对密码学的安全产生影响&lt;/b&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;致远博士&lt;/b&gt; &lt;/p&gt;&lt;p&gt;最近由于黎曼猜想可能会被证明，网上充满了讨论，甚至波及到了区块链。有新闻说如果黎曼猜想被证实的话，将危及公钥密码学的安全。由于互联网上使用的都是公钥密码，所以互联网也都不安全了。&lt;/p&gt;&lt;p&gt;更具体的猜测是，由于黎曼猜想和素数有关，所以RSA密码体质将会被攻破。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b92c72c22f2438d3b9454ffe39793ed9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1058&quot; data-rawheight=&quot;981&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b92c72c22f2438d3b9454ffe39793ed9&quot; data-watermark-src=&quot;v2-21d0339de0986ecdacccb98dbbb24eb1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;以上猜测搞得人心惶惶，皆因大家的好奇心，说来也是好事。一个数学界的新闻能让大家如此关注。我也查了国外一些网站的说法。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-eb40a9c79baa851a943d27c0c22d8fff_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1375&quot; data-rawheight=&quot;818&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-eb40a9c79baa851a943d27c0c22d8fff&quot; data-watermark-src=&quot;v2-12bbdf59fdfb4c1002d4938e2db3f93d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;由于我是搞密码学的，又涉足区块链界，所以有些群友不断在问我。为此我以我的理解及所查的资料，对以上说法进行正本清源。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.&lt;/b&gt; &lt;b&gt;首先我说结论。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;第一，黎曼猜想早在1859年就提出，而我们用的公钥密码是在70年代末提出的。所以，如果黎曼猜想会对破解RSA加密算法有什么帮助的话，一定会早有论文提出。然而，至今为止也没有看到有相关论文显示黎曼猜想会对破解RSA有什么直接效果。&lt;/p&gt;&lt;p&gt;第二，区块链上用的密码算法只有两个：哈希函数和数字签名。哈希函数和素数没有关系，所以和黎曼猜想没有关系。数字签名使用的是椭圆曲线上的方案，所以与大整数分解没有关系，从而和黎曼猜想也没有关系。&lt;/p&gt;&lt;p&gt;所以，黎曼猜想对公钥密码没有直接的任何威胁。对区块链的安全也没有任何影响。&lt;/p&gt;&lt;p&gt;为了让大家更好地理解上述结论，我们先来解释一下什么是黎曼猜想。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.&lt;/b&gt; &lt;b&gt;什么是黎曼猜想&lt;/b&gt;&lt;/p&gt;&lt;p&gt;要说清黎曼猜想，首先得说素数。素数在自然数中是一种特别的数，它只能被1和自己整除。说白了，素数没有因子，就像一个人没有后代（比喻略显不恰当）。素数的这种孤零零的特性，使得它是整个自然数的“基石”。因为它不能再被分解了，所以只能去构造其他数。&lt;/p&gt;&lt;p&gt;因此有个结论，每个自然数都可以唯一地分解成有限个素数的乘积。而且素数的个数是无限的。&lt;/p&gt;&lt;p&gt;素数如此特别，数学家们试图搞清楚如何判断一个数是素数。给你一个小的数，例如7，你很容易判断它是素数。但是当给你一个很大的数字时，判断一个数是否为素数，是需要方法的。由此产生了素数判定的算法。&lt;/p&gt;&lt;p&gt;为了更好地理解素数，数学家们在 19 世纪便不再尝试预测素数的精确位置，转而将素数的现象视为一个整体。这种分析的方法就是黎曼所擅长的，他著名的猜想也由此得出。&lt;/p&gt;&lt;p&gt;为了理解素数是如何分布的，高斯给出了一个素数计数函数 π(x) ，它能够给出某个数之前的素数的数量（即有多少个素数）。&lt;/p&gt;&lt;p&gt;随后，高斯（和勒让德独立地）提出了&lt;b&gt;素数定理&lt;/b&gt;：当x增长到无穷大时，素数计数函数 π(x) 会近似于 x/ln(x) 函数。这意味着前x个整数中连续素数之间的平均间隙约为 ln(x)。换句话说可以用x/ln(x)近似π(x)。&lt;/p&gt;&lt;p&gt;然后又出现了对数积分函数 Li(x)，数学家发现 Li(x)能够比x/ln(x)更好的近似π(x)。说明 Li(x) 能够更好的刻画素数的个数。&lt;/p&gt;&lt;p&gt;然而，素数定理所预测的分布规律与实际仍然有所偏差，而且时大时小。这一切引起了黎曼的注意。&lt;/p&gt;&lt;p&gt;1859年，年仅33岁的黎曼发表了论文《论小于已知数的素数个数》。在该文章中，黎曼定义了一个函数：黎曼 zeta 函数。在论文中黎曼给出了一个推测：黎曼 zeta 函数的所有非平凡零点可能都全部位于实部等于1/2的直线上。&lt;/p&gt;&lt;p&gt;具体内容各位可以忽略。那么黎曼 zeta 函数的非平凡零点有什么用呢？&lt;/p&gt;&lt;p&gt;&lt;b&gt;黎曼用 Li(x)以及zeta 函数的非平凡零点，给出了自己的素数定理，即更准确地估计数字 x 以内有多少个素数。&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-76bd4bc386a9b0badb92e199765b640e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1394&quot; data-rawheight=&quot;216&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;这一精确的刻画素数个数的定理，让黎曼大放光彩。上述公式中的第二项，x 的 ρ 次幂的ρ就是&lt;i&gt;黎曼 zeta 函数非平凡零点。&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;这就是黎曼 zeta 函数非平凡零点的意义所在！这就是黎曼 zeta 函数非平凡零点的意义所在！&lt;/i&gt;&lt;/p&gt;&lt;p&gt;到此为止，我们说了黎曼猜想是什么？&lt;/p&gt;&lt;p&gt;&lt;b&gt;简而言之，就是给出了数字 x 以内更精确的素数个数的公式。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.&lt;/b&gt; &lt;b&gt;RSA基于的困难问题&lt;/b&gt;&lt;/p&gt;&lt;p&gt;RSA所基于的困难问题是“大整数分解困难问题”。即给你一个大的整数，对其分解为素数之积是困难的。这是RSA加密算法的安全性基础。&lt;/p&gt;&lt;p&gt;目前对大整数分解用的方法主要是数域筛法，但是这些方法都不能有效的分解大整数。&lt;/p&gt;&lt;p&gt;黎曼猜想是宏观上对素数的分布有个判断，它不能直接求素数，也不能对一个整数进行素数分解。目前根据文献，黎曼猜想对于生成素数，例如RSA中的密钥生成算法，是有帮助的。但是对于整数分解算法并没有直接的提升。所以不会对RSA加密体质有任何影响。&lt;/p&gt;&lt;p&gt;大家一定要区分&lt;b&gt;素数检测&lt;/b&gt;和&lt;b&gt;整数分解&lt;/b&gt;是两回事。很多人都认为是一回事，这是产生错误的根源。&lt;/p&gt;&lt;p&gt;对于黎曼猜想的证明，大家更多的认为可能会对数域的结构有个更好的认知。从某些方面，可能会对密码学有所启示。&lt;/p&gt;&lt;p&gt;文章首发在微信公众号：btc201800&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&quot;&gt;http://weixin.qq.com/r/GC8UDDjEjmXxrXxv93oK&lt;/a&gt; (二维码自动识别) &lt;/p&gt;</description>
<author>致远</author>
<guid isPermaLink="false">2018-09-23-45186127</guid>
<pubDate>Sun, 23 Sep 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
