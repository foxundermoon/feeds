<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>babyquant谈量化金融</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Fri, 03 Aug 2018 21:24:53 +0800</lastBuildDate>
<item>
<title>策略||白马股</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-08-03-41207512.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41207512&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;绩优白马股&lt;/b&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;绩优白马股相关研究简介&lt;br&gt;&lt;/p&gt;&lt;p&gt;按字面理解，绩优白马股是指业绩优秀、稳定成长的公司。围绕公司业绩：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;PB-ROE 模型对 A 股市场的行业层面约束效果不明显；所以用 ROE 指标截面比较，行业内选股。&lt;/li&gt;&lt;li&gt;将 ROE 分解为杜邦三因子，通过因子收益归因发现，销售利润率和资产周转率是显著的收益来源，而财务杠杆在 A 股市场范围内，对收益无明显的解释作用。因此，分别通过销售利润率，资产周转率和 ROE 三部分来 对公司经营质量进行评价打分。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;绩优白马股的反思与启示&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对绩优白马股的定义并无统一标准，本报告将用两类特征作为切入点，研究绩优白马股：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;ROE长期水平，以及波动特征。&lt;/li&gt;&lt;li&gt;利润长期水平。 &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;从ROE到净利润，再到股票收益率&lt;/p&gt;&lt;p&gt;&lt;b&gt;绩优白马股:从基本面到二级市场的传导&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;长期高 ROE的公司研究&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们采用 2007 年至 2016 年年报数据，对过去十年的上市公司年报，按照长期ROE 的高低进行了梳理。首先我们将全市场上市 10 年以上的股票，按照 ROE的长期波动率分为两类，即 ROE 稳定组和 ROE 高波动组。其中，ROE 稳定组的列表如下: &lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-414740c7e86aa1f0b670da205c4d724f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;266&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-414740c7e86aa1f0b670da205c4d724f&quot; data-watermark-src=&quot;v2-0e8cf00499c0f7371406df42c0cc360f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f860f88055d4103aa134e110eed32bd5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;461&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f860f88055d4103aa134e110eed32bd5&quot; data-watermark-src=&quot;v2-e9d6a9d9b3e07922fd6210ae0387e8a7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上表共有 237 家公司，这些公司过去 10 年的 ROE 波动率均未超过 ROE 均值水平。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;ROE 与净利润增长的关系&lt;/b&gt;&lt;br&gt;ROE 波动组中，长期 ROE 和净利润复合年增长率的关系，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e2346be96604c2e27096cc005b651517_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;408&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e2346be96604c2e27096cc005b651517&quot; data-watermark-src=&quot;v2-942a1eea87c58c55372b9d325756279e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE高波动组中，长期 ROE和净利润复合年增长率 &lt;/p&gt;&lt;p&gt;图中显示，在 ROE 高波动组中，净利润在 ROE 每个固定位臵上的分布较为分散，长期 ROE 对净利润复合年增长率的解释度不强。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE 稳定组中，长期 ROE 和净利润复合年增长率的关系，如下表所示：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-73c0a402238d88394b261605bc585abe_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;448&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-73c0a402238d88394b261605bc585abe&quot; data-watermark-src=&quot;v2-81b5e67ef2801b2f0e3fbf1ca2e59fe3&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE 稳定组中，长期 ROE 和净利润复合年增长率 &lt;/p&gt;&lt;p&gt;如上图所示，在 ROE 稳定组中，长期 ROE 较好的解释了净利润复合年增长率。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;净利润增长与股票收益率的关系&lt;/b&gt;&lt;/p&gt;&lt;p&gt;ROE 波动组中，净利润复合年增长率与股票收益率的关系，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e28564cb3d10938bd73e7119be256831_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;398&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e28564cb3d10938bd73e7119be256831&quot; data-watermark-src=&quot;v2-6468e029818749d23da369066cabddaa&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE高波动组中，净利润复合年增长率和股票年化收益率 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图显示，随着净利润复合年增长率上升，股票十年年化收益率也上升。即便在 ROE 高波动组当中，长期净利润增长也能较好地解释不同股票长期收益率的差异。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE 稳定组中，净利润复合年增长率与股票收益率的关系，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c1a21170ba835c9fe5f92d1e5f206ab8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;401&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c1a21170ba835c9fe5f92d1e5f206ab8&quot; data-watermark-src=&quot;v2-97e763c6935e5dee3427f3aa0ff69f65&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE稳定组中，净利润复合年增长率和股票年化收益率 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图显示，净利润复合年增长率和股票年化收益率正相关。在 ROE 稳定组当中，股票之间长期净利润增长的差异解释了股票长期收益率的差异。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;至此，我们总结出在 ROE 不同组当中的传导逻辑:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在 ROE 稳定组中，长期 ROE 较好地解释了长期净利润增长，而长期净利润又显著影响了股票长期收益率。从而，此类股票的长期收益主要取决于长期 ROE 水平的差异。&lt;/li&gt;&lt;li&gt;在 ROE 高波动组中，ROE 本身对长期净利润增长无显著解释。此类股票的长期收益主要受到长期净利润增长率的影响。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;ROE 稳定组中寻找绩优白马股&lt;/b&gt;&lt;br&gt;在 ROE 稳定组中，我们选择长期 ROE 综合水平最高的前 20 名，分析这类公司 ROE，净利润和二级市场十年收益率的情况，如下表所示:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE稳定组中，ROE均值最高top20的年报 ROE(单位:%) &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0295b0e22ef98f7ef44e72f9b1c57ce2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;257&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0295b0e22ef98f7ef44e72f9b1c57ce2&quot; data-watermark-src=&quot;v2-4f2afeb19cc164e05acc4ce6e22cd71d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e9e63d94181e7995b507ad8252acb46a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;63&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上表中这 20 家公司，从 2007 年至 2016 年的 ROE 来看，呈现出“ROE 波动小，整体水平高”的特征。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE 稳定组中，ROE 最高 top 20 的业绩指标和股票收益率统计(单位: %) &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-26349f8ef3a3847245e96f9b0a687f01_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;175&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-26349f8ef3a3847245e96f9b0a687f01&quot; data-watermark-src=&quot;v2-eed143f738e1afa339f8ab26dfe0945d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;表中显示这类公司的长期 ROE 能够保持较高水平，长期净利润复合增长率较高， 二级市场长期收益率也显著高于市场平均水平。值得一提的是，这类公司的长期 ROE 水平，与其长期净利润复合增长率基本相当(长期净利润增长既没有过高，保证了可持续性;也显著比多数公司高，反映了公司良好的成长能力)。此外，此类公司的长期负债结构也呈现出稳定的态势: &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE 稳定组中，ROE 均值最高 top 20 的资产负债率(单位: %)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f5efc759be986a21e3629d5fe6e74663_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;315&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f5efc759be986a21e3629d5fe6e74663&quot; data-watermark-src=&quot;v2-ebe4ded6eeedda9678d489f1e9077c3d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上表显示，无论宏观或行业景气或不景气时，公司的负债率都比较稳定。负债率稳定是公司经营稳定的体现，比一般公司更能抵御经济周期风险。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;绩优白马股在 ROE，利润等方面所展现出的特征，有助于我们去理清选股的目 标。更有针对性地制定选股模型。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;茅台魔咒：注定还是巧合？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;多年以来，A 股市场的股票存在“茅台魔咒”。那么这是巧合?还是其中另有原因?本章我们从绩优白马股的角度，来就此进行一番探讨。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;茅台魔咒:股价超越茅台，就意味着要调整?&lt;/b&gt;&lt;/p&gt;&lt;p&gt;每当一只股票价格超越贵州茅台之后，随之而来都会经历一波显著的调整。我们选取了 2007 年至 2017 年的 A 股市场具有代表性的 25 个例子: &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;2007-2017 年股价超越茅台的典型案例 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-338f9a8ab848e77663d72fd08502358b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;302&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-338f9a8ab848e77663d72fd08502358b&quot; data-watermark-src=&quot;v2-3384b0e9ae552aa5b65bbf4cfe6a2f2c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上表显示，多数股票都是在牛市当中，股价超越茅台的。07 年底附近，牛市有两只股票股价超过茅台，分别是中国船舶和山东黄金;10 年和 15 年两轮牛市中，上表共有 20 家公司股价超过茅台；之后 16 年有两家，17 年有一家。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;股价超越茅台是否合理?&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们将上述在过去十年股价曾超越茅台的公司，剔除 2016 年以后上市的股票，与 茅台从基本面和二级市场两方面的客观数据进行对比: &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;超越茅台的公司基本面和股价近期表现 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5e91b44baff9993ee5f9cde77efbab2a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;460&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5e91b44baff9993ee5f9cde77efbab2a&quot; data-watermark-src=&quot;v2-4700b4a017618878025ad7ebbcc8948a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6638423c8046fa351fc19d948b52e80c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;65&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上表显示，过去股价超越茅台的公司按照基本面大致分为两类：其中多数属于 “基本面看，无法称作白马股”这一类。无论从长期 ROE 水平，还是长期净利润复合增长，这些公司 2007 至 2016 年所体现出成长的可持续性、经济周期抗风险能力，尚未具有白马股的特征；另有少部分诸如碧水源、东方园林、洋河股份属于拥有较好的基本面，但长期 ROE 整体水平低于茅台，从而公司的长期盈利质量难以超越茅台。成长性欠佳则长期净利润增速不高，进而长期股票收益率不可能太高。另一方面，考虑到茅台过去十年股本并无大幅度的扩张，所以综合公司基本面和股本扩张两方面因素考虑，股价想超越茅台的机会就微乎其微。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;白马股量化选股模型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;绩优白马股的特征鲜明:长期 ROE 保持较高水平;公司业绩长期具有较高的成长性。并且绩优白马股的长期收益率也比较显著。因为，我们制作了以下绩优白马股量化选股模型，仅供参考。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;模型目标&lt;/b&gt;&lt;/p&gt;&lt;p&gt;寻找下一年 ROE 仍能保持高水平;且下个季度业绩增速显著高于市场平均水平的公司。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;选股逻辑&lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;按照 ROE 波动率，将全市场分为 ROE 稳定组和高波动组。&lt;/li&gt;&lt;li&gt;在 ROE 稳定组中，过去三年 ROE 每年均在 10%以上的公司。&lt;/li&gt;&lt;li&gt;营业收入同比 /环比 改善。&lt;/li&gt;&lt;li&gt;净利润同比/环比改善。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;回测结果&lt;/b&gt;&lt;br&gt;对 2007 年至 2017 年进行了回测，每年 5/1，9/1，11/1 日换仓。结果如下: &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-02735ee1517889edc47eb2e3dd4c4ccf_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;351&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-02735ee1517889edc47eb2e3dd4c4ccf&quot; data-watermark-src=&quot;v2-c67432aa73f6ea91672cdbdff1360014&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;模型月度超额收益时间序列分布 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图显示，模型收益分布均匀。最大回撤出现在 2014 年 12 月，市场行情出现金融和非金融板块极端分化的时候。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;国信白马股量化选股模型主要绩效评价指标 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d700873649fd7f5fa4c2347cec6bc378_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;101&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;无论从月度还是年度，绩优白马股模型胜率还是不错的。过去 12 年，年化绝对收益超过 30%。换手率也不算特别高。 &lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-aaa00e980ab3907cbb43118eca40cafd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;343&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-aaa00e980ab3907cbb43118eca40cafd&quot; data-watermark-src=&quot;v2-7e083035f93c44a93b50f3c45a4867d0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;模型绝对收益净值图 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图显示，绩优白马股模型长期持续跑赢沪深 300 等权指数，在每轮牛市(或者结构性牛市)中净值都创出了新高。第一波高点出现在 07 年底;第二波高点在 2011 年初，第三波高点出现在 15 年中期。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-038e2842e570694b4221fcd8f6658b14_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;354&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-038e2842e570694b4221fcd8f6658b14&quot; data-watermark-src=&quot;v2-624c90522f32447a912b9882d173158f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;模型累计超额收益净值图 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图显示，绩优白马股模型超额收益净值不断创新高，且整体回撤较小。三次较大的回撤分别出现在 2009 年 8 月，2014 年 12 月和 2016 年 1 月。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;基本面实证( ROE 和净利润兑现) &lt;/b&gt;&lt;/p&gt;&lt;p&gt;逻辑上讲，本模型的收益主要来自于公司业绩的增长。为了检验这一目标的兑现情况，我们对每期组合下期的业绩状况进行了验证。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先我们验证，下期年报模型组合 ROE 的情况: &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-90e87c3d8980da54a2fe1d7002a882b3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;335&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-90e87c3d8980da54a2fe1d7002a882b3&quot; data-watermark-src=&quot;v2-fed58ab186a1f6ed266fdd479894206c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;模型与全市场整体在下期年报 ROE 水平的比较 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以看到，每年模型组合下期年报整体的 ROE 水平介于 15%以上，25%以下；大幅高于市场整体水平。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;然后我们验证，下期季报模型组合净利润增长的情况: &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d19ed9f11bed6886121dde6ef92736b4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;349&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d19ed9f11bed6886121dde6ef92736b4&quot; data-watermark-src=&quot;v2-79f2805cb042923fd6f17aeb8a0b48a2&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;模型与全市场整体在下期净利润同比增速的比较 &lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图显示，每年模型组合下期净利润增长介于 25%至 70%之间，大幅跑赢市场。 综合上述 ROE 和净利润增速的兑现情况，则不难理解本模型长期收益显著跑赢市场的原因。所以，本模型基本达成了所需目标，选择绩优白马股，坚持基本面驱动的价值投资风格。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;总结&lt;/p&gt;&lt;p&gt;本篇报告核心探讨了一个问题:虽然全市场股票的长期收益率是由长期业绩增长驱动;但绩优白马股的长期收益率可能更加直接地由长期稳定的高 ROE 驱动。 绩优白马股通过长期兑现未来的 ROE，兑现未来的利润增长，以实现长期高于市场平均 水平的股票收益率。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;本模型的预测指标仅包含 ROE，营业收入和净利润增长三项。在报告中我们也有提到过，我们猜测绩优白马股的负债结构可能相对比较稳定，这可能是一个区分绩优白马股的潜在指标。如果有其它对区分绩优白马股有辨识力的指标，也会对模型产生增量贡献。&lt;/p&gt;</description>
<author>量化家</author>
<guid isPermaLink="false">2018-08-03-41207512</guid>
<pubDate>Fri, 03 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>策略||隐马尔可夫模型</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-07-31-40962600.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40962600&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;隐马尔可夫模型 &lt;/b&gt;(Hidden Markov Model，HMM) 最初由 L. E. Baum 和其它一些学者发表在一系列的统计学论文中，随后在语言识别，自然语言处理以及生物信息等领域体现了很大的价值。平时，经常能接触到涉及 &lt;b&gt;HMM &lt;/b&gt;的相关文章，一直没有仔细研究过，都是蜻蜓点水，因此，想花一点时间梳理下，加深理解，在此特别感谢 52nlp 对 &lt;b&gt;HMM&lt;/b&gt; 的详细介绍。&lt;/p&gt;&lt;p&gt; 考虑下面交通灯的例子，一个序列可能是红-红/橙-绿-橙-红。这个序列可以画成一个状态机，不同的状态按照这个状态机互相交替，每一个状态都只依赖于前一个状态，如果当前的是绿灯，那么接下来就是橙灯，这是一个确定性系统，因此更容易理解和分析，只要这些状态转移都是已知的。但是在实际当中还存在许多不确定性系统。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1ecd8683bb77c40341371fd17c391227_r.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;297&quot; data-rawheight=&quot;113&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-1ecd8683bb77c40341371fd17c391227_b.jpg&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 在日常生活当中，我们总是希望根据当前天气的情况来预测未来天气情况，和上面的交通灯的例子不同，我们不能依靠现有知识确定天气情况的转移，但是我们还是希望能得到一个天气的模式。一种办法就是假设这个模型的每个状态都只依赖于前一个的状态，这个假设被称为&lt;b&gt;马尔科夫假设&lt;/b&gt;，这个假设可以极大简化这个问题。显然，这个假设也是一个非常糟糕的假设，导致很多重要的信息都丢失了。&lt;br&gt;&lt;/p&gt;&lt;p&gt; 当涉及到天气的时候，&lt;b&gt;马尔科夫假设&lt;/b&gt;描述为，假设如果我们知道之前一些天的天气信息，那么我们就能预测今天的天气。当然，这个例子也是有些不合实际的。但是，这样一个简化的系统可以有利于我们的分析，所以我们通常接受这样的假设，因为我们知道这样的系统能让我们获得一些有用的信息，尽管不是十分准确的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f96e315dce171b1c29831c733878cc9d_r.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;41&quot; data-rawheight=&quot;41&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-f96e315dce171b1c29831c733878cc9d_b.jpg&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d551404091b8f1df73e1150d121f4b5d_r.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;41&quot; data-rawheight=&quot;41&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot; data-thumbnail=&quot;https://pic4.zhimg.com/v2-d551404091b8f1df73e1150d121f4b5d_b.jpg&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6dc602bda819c6d591c87b84ea4331c2_r.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;41&quot; data-rawheight=&quot;41&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-6dc602bda819c6d591c87b84ea4331c2_b.jpg&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;       谈到 &lt;b&gt;HMM&lt;/b&gt;，首先简单介绍一下&lt;b&gt;马尔可夫过程 &lt;/b&gt;(Markov Process)，它因俄罗斯数学家安德烈·马尔可夫而得名，代表数学中具有&lt;b&gt;马尔可夫性质&lt;/b&gt;的离散随机过程。该过程中，每个状态的转移只依赖于之前的 n 个状态，这个过程被称为1个 n 阶的模型，其中 n 是影响转移状态的数目。最简单的马尔科夫过程就是一阶过程，每一个状态的转移只依赖于其之前的那一个状态。注意这和确定性系统不一样，因为这种转移是有概率的，而不是确定性的。&lt;br&gt;&lt;/p&gt;&lt;p&gt; 马尔可夫链是随机变量 &lt;i&gt;X&lt;/i&gt;1, … , &lt;i&gt;Xn&lt;/i&gt; 的一个数列。这些变量的范围，即他们所有可能取值的集合，被称为“状态空间”，而 &lt;i&gt;Xn  &lt;/i&gt;的值则是在时间 &lt;i&gt;n &lt;/i&gt;的状态。如果 &lt;i&gt;Xn&lt;/i&gt;+1 对于过去状态的条件概率分布仅是 &lt;i&gt;Xn &lt;/i&gt;的一个函数，则&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-41f3af3fbaf50d11913f537577899a1e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;434&quot; data-rawheight=&quot;48&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 这里 &lt;i&gt;x &lt;/i&gt;为过程中的某个状态。上面这个恒等式可以被看作是&lt;b&gt;马尔可夫性质&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　马尔可夫链&lt;/b&gt;的在很多应用中发挥了重要作用，例如，谷歌所使用的网页排序算法（PageRank）就是由&lt;b&gt;马尔可夫链&lt;/b&gt;定义的。&lt;/p&gt;&lt;p&gt; 下图展示了天气这个例子中所有可能的一阶转移：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6e613f9799e1e770b4a9a5c4b888e75d_r.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;320&quot; data-rawheight=&quot;137&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-6e613f9799e1e770b4a9a5c4b888e75d_b.jpg&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 注意一个含有 N 个状态的一阶过程有 N2 个状态转移。每一个转移的概率叫做&lt;b&gt;状态转移概率 &lt;/b&gt;(state transition probability)，就是从一个状态转移到另一个状态的概率。这所有的 N2 个概率可以用一个&lt;b&gt;状态转移矩阵&lt;/b&gt;来表示，其表示形式如下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;b&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-cea8745b8712d6ea9d95c61662c1a97f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;585&quot; data-rawheight=&quot;248&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-cea8745b8712d6ea9d95c61662c1a97f&quot; data-watermark-src=&quot;v2-260a8429660f81d28668e59d5926f5a1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;/b&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 对该矩阵有如下约束条件：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a737652b07e8bbef859a1db284bb7f0b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;153&quot; data-rawheight=&quot;122&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 下面就是海藻例子的&lt;b&gt;状态转移矩阵&lt;/b&gt;：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ba908784eeab9bd78055a9d675d5c78b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;351&quot; data-rawheight=&quot;166&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ba908784eeab9bd78055a9d675d5c78b&quot; data-watermark-src=&quot;v2-fbd21207deef2cdd176cd62307087d73&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt; 这个矩阵表示，如果昨天是晴天，那么今天有50%的可能是晴天，37.5%的概率是阴天，12.5%的概率会下雨，很明显，矩阵中每一行的和都是1。&lt;/p&gt;&lt;p&gt; 为了初始化这样一个系统，我们需要一个初始的概率向量：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fe47981cc1537b7a9bbc8139a88df9e7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;193&quot; data-rawheight=&quot;64&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 这个向量表示第一天是晴天。&lt;/p&gt;&lt;p&gt; 到这里，我们就为上面的一阶&lt;b&gt;马尔科夫过程&lt;/b&gt;定义了以下三个部分：&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　状态&lt;/b&gt;：晴天、阴天和下雨&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　初始向量&lt;/b&gt;：定义系统在时间为0的时候的状态的概率&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　状态转移矩阵&lt;/b&gt;：每种天气转换的概率&lt;/p&gt;&lt;p&gt; 所有的能被这样描述的系统都是一个&lt;b&gt;马尔科夫过程&lt;/b&gt;。&lt;/p&gt;&lt;p&gt; 然而，当&lt;b&gt;马尔科夫过程&lt;/b&gt;不够强大的时候，我们又该怎么办呢？在某些情况下，&lt;b&gt;马尔科夫过程&lt;/b&gt;不足以描述我们希望发现的模式。&lt;/p&gt;&lt;p&gt; 例如，一个隐居的人可能不能直观的观察到天气的情况，但是民间传说告诉我们海藻的状态在某种概率上是和天气的情况相关的。在这种情况下我们有两个状态集合，一个可以观察到的状态集合（海藻的状态）和一个隐藏的状态（天气状况）。我们希望能找到一个算法可以根据海藻的状况和&lt;b&gt;马尔科夫假设&lt;/b&gt;来预测天气的状况。&lt;/p&gt;&lt;p&gt; 一个更现实的例子是语音识别，我们听到的声音是声带、喉咙和一起其他的发音器官共同作用的结果。这些因素相互作用，共同决定了每一个单词的声音，而一个语音识别系统检测的声音（可以观察的状态）是人体内部各种物理变化（隐藏的状态、引申一个人真正想表达的意思）产生的。&lt;/p&gt;&lt;p&gt; 某些语音识别设备把内部的发音机制作为一个隐藏的状态序列，把最后的声音看成是一个和隐藏的状态序列十分相似的可以观察到的状态的序列。在这两个例子中，一个非常重要的地方是&lt;b&gt;隐藏状态的数目和可以观察到的状态的数目可能是不一样的&lt;/b&gt;。在一个有3种状态的天气系统（sunny、cloudy、rainy）中，也许可以观察到4种潮湿程度的海藻（dry、dryish、damp、soggy）。在语音识别中，一个简单的发言也许只需要80个语素来描述，但是一个内部的发音机制可以产生不到80或者超过80种不同的声音。&lt;/p&gt;&lt;p&gt; 在上面的这些情况下，&lt;b&gt;可以观察到的状态序列和隐藏的状态序列是概率相关的&lt;/b&gt;。于是我们可以将这种类型的过程建模为有一个隐藏的&lt;b&gt;马尔科夫过程&lt;/b&gt;和一个与这个&lt;b&gt;隐藏马尔科夫过程&lt;/b&gt;概率相关的并且可以观察到的状态集合。这就是本文重点介绍的&lt;b&gt;隐马尔可夫模型。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　隐马尔可夫模型 &lt;/b&gt;(Hidden Markov Model) 是一种统计模型，用来描述一个含有隐含未知参数的&lt;b&gt;马尔可夫过程&lt;/b&gt;。其难点是从可观察的参数中确定该过程的隐含参数，然后利用这些参数来作进一步的分析。下图是一个三个状态的&lt;b&gt;隐马尔可夫模型&lt;/b&gt;状态转移图，其中x 表示隐含状态，y 表示可观察的输出，a 表示状态转换概率，b 表示输出概率。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-15ee8d97a4f0181db094bac01e15b5b0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;439&quot; data-rawheight=&quot;312&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-15ee8d97a4f0181db094bac01e15b5b0&quot; data-watermark-src=&quot;v2-47f86b462317e0ea4a2242a45df5ece0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 下图显示了天气的例子中隐藏的状态和可以观察到的状态之间的关系。我们假设隐藏的状态是一个简单的一阶&lt;b&gt;马尔科夫过程&lt;/b&gt;，并且他们两两之间都可以相互转换。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-168521291b6ce88e84aa37550b777995_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;426&quot; data-rawheight=&quot;265&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-168521291b6ce88e84aa37550b777995&quot; data-watermark-src=&quot;v2-935ebb9bdbdd808e2a00fc8945ad3059&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　对 HMM 来说，有如下三个重要假设，尽管这些假设是不现实的。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　假设1：马尔可夫假设（状态构成一阶马尔可夫链）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;b&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ad3227eb78db54bf477ad297b5f30adf_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;350&quot; data-rawheight=&quot;35&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;/b&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　假设2：不动性假设（状态与具体时间无关）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;b&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-63b57b495f9f2199cd870d409b16cf08_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;407&quot; data-rawheight=&quot;40&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;/b&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　假设3：输出独立性假设（输出仅与当前状态有关）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;b&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-96f96a84dc36ee97cd3337564bb611e8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;438&quot; data-rawheight=&quot;36&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;/b&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　隐藏的状态和可观察到的状态之间有一种概率上的关系，也就是说某种隐藏状态 H 被认为是某个可以观察的状态 O1 是有概率的，假设为 P(O1 | H)。如果可以观察的状态有3种，那么很显然 &lt;b&gt;P(O1 | H)+P(O2 | H)+ P(O3 | H) = 1&lt;/b&gt;。&lt;/p&gt;&lt;p&gt; 这样，我们也可以得到一个另一个矩阵，称为&lt;b&gt;混淆矩阵 &lt;/b&gt;(confusion matrix&lt;b&gt;)&lt;/b&gt;。这个矩阵的内容是某个隐藏的状态被分别观察成几种不同的可以观察的状态的概率，在天气的例子中，这个矩阵如下图：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a7b9075f3a7bf2b46a6ac274d4359abb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;375&quot; data-rawheight=&quot;132&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a7b9075f3a7bf2b46a6ac274d4359abb&quot; data-watermark-src=&quot;v2-9873116689768432207a7a0f42598668&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 上边的图示都强调了 &lt;b&gt;HMM &lt;/b&gt;的状态变迁。而下图则明确的表示出模型的演化，其中绿色的圆圈表示隐藏状态，紫色圆圈表示可观察到状态，箭头表示状态之间的依存概率，一个 &lt;b&gt;HMM &lt;/b&gt;可用一个5元组 { N, M, π，&lt;i&gt;A，B &lt;/i&gt;} 表示，其中 N 表示隐藏状态的数量，我们要么知道确切的值，要么猜测该值，M 表示可观测状态的数量，可以通过训练集获得， π={πi} 为初始状态概率，A={aij} 为隐藏状态的&lt;b&gt;转移矩阵 &lt;/b&gt;Pr(xt(i) | xt-1(j))，B={bik} 表示某个时刻因隐藏状态而可观察的状态的概率，即&lt;b&gt;混淆矩阵&lt;/b&gt;，Pr(ot(i) | xt(j))。在状态转移矩阵和混淆矩阵中的每个概率都是时间无关的，即当系统演化时，这些矩阵并不随时间改变。对于一个 N 和 M 固定的 &lt;b&gt;HMM &lt;/b&gt;来说，用 λ={ π, A, B } 表示&lt;b&gt; HMM&lt;/b&gt; 参数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d113f9aeaf102bc4eef22d93abbba00f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;508&quot; data-rawheight=&quot;144&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d113f9aeaf102bc4eef22d93abbba00f&quot; data-watermark-src=&quot;v2-7e5d54d114daa1521246229a62b3fadd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 在正常的&lt;b&gt;马尔可夫模型&lt;/b&gt;中，状态对于观察者来说是直接可见的。这样状态的转换概率便是全部的参数。而在&lt;b&gt;隐马尔可夫模型&lt;/b&gt;中，状态并不是直接可见的，但受状态影响的某些变量则是可见的。每一个状态在可能输出的符号上都有一概率分布。因此输出符号的序列能够透露出状态序列的一些信息。&lt;/p&gt;&lt;p&gt; 在 &lt;b&gt;HMM&lt;/b&gt; 中有三个典型问题：&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　（一） 已知模型参数，计算某一给定可观察状态序列的概率&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;假设我们已经有一个特定的&lt;b&gt;隐马尔科夫模型 λ&lt;/b&gt; 和一个可观察状态序列集。我们也许想知道在所有可能的隐藏状态序列下，给定的可观察状态序列的概率。当给定如下一个隐藏状态序列：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0e35c4e17f751080692bb205cd63a8fe_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;129&quot; data-rawheight=&quot;32&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　那么在 &lt;b&gt;HMM&lt;/b&gt; 和这个隐藏状态序列的条件下，可观察状态序列的概率为：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-62732bfcaa428eac4ade8a2540ee07d2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;389&quot; data-rawheight=&quot;39&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　而隐藏状态序列在 &lt;b&gt;HMM &lt;/b&gt;条件下的概率为：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3999e0a2372e0d2eae57394fcddc08d2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;346&quot; data-rawheight=&quot;42&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　因此，隐藏状态序列和可观察状态序列的联合概率为：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4c506877bce5a66ed86e53fa79c4f6dd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;350&quot; data-rawheight=&quot;34&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　那么所有可能的隐藏状态序列上，可观察状态序列的概率为：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-82ba78d52f3f0ce5f9a0879ef4d81828_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;339&quot; data-rawheight=&quot;53&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　例如，我们也许有一个海藻的“Summer”模型和一个“Winter”模型，因为海藻在夏天和冬天的状态应该是不同的，我们希望根据一个可观察状态（海藻的潮湿与否）序列来判断现在是夏天还是冬天。&lt;/p&gt;&lt;p&gt; 我们可以使用&lt;b&gt;前向算法&lt;/b&gt;来计算在某个特定的 &lt;b&gt;HMM&lt;/b&gt; 下一个可观察状态序列的概率，然后据此找到最可能的模型。&lt;/p&gt;&lt;p&gt; 这种类型的应用通常出现在语音设别中，通常我们会使用很多&lt;b&gt; HMM&lt;/b&gt;，每一个针对一个特别的单词。一个可观察状态的序列是从一个可以听到的单词向前得到的，然后这个单词就可以通过找到满足这个可观察状态序列的最大概率的 &lt;b&gt;HMM&lt;/b&gt; 来识别。&lt;/p&gt;&lt;p&gt; 下面介绍一下&lt;b&gt;前向算法 &lt;/b&gt;(Forward Algorithm)&lt;/p&gt;&lt;p&gt; 　如何计算一个可观察序列的概率？&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　1. 穷举搜索&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 给定一个 &lt;b&gt;HMM&lt;/b&gt;，我们想计算出某个可观察序列的概率。考虑天气的例子，我们知道一个描述天气和海藻状态的 &lt;b&gt;HMM&lt;/b&gt;，而且我们还有一个海藻状态的序列。假设这个状态中的某三天是（dry，damp，soggy），在这三天中的每一天，天气都可能是晴朗，多云或者下雨，我们可以用下图来描述观察序列和隐藏序列：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-09ebc1e4a51d86716e2b0bc64ccf0ced_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;192&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-09ebc1e4a51d86716e2b0bc64ccf0ced&quot; data-watermark-src=&quot;v2-89f714056ed1a90c16254f1a708e03b4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 在这个图中的每一列表示天气的状态可能，并且每个状态都指向相邻的列的每个状态，每个状态转换在状态转移矩阵中都有一个概率。每一列的下面是当天的可观察的海藻的状态，在每种状态下出现这种可观察状态的概率是由&lt;b&gt;混淆矩阵&lt;/b&gt;给出的。&lt;/p&gt;&lt;p&gt; 一个可能的计算可观察概率的方法是找到每一个可能的隐藏状态的序列，这里有32 = 27种，这个时候的可观察序列的概率就是 Pr(dry, damp, soggy | HMM)=Pr(dry, damp, soggy | sunny, sunny, sunny) + . . . . + Pr(dry, damp, soggy | rainy, rainy, rainy)。&lt;/p&gt;&lt;p&gt; 很显然，这种计算的效率非常低，尤其是当模型中的状态非常多或者序列很长的时候。事实上，我们可以利用概率不随时间变化这个假设来降低时间的开销。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　2. 使用递归来降低复杂度&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 我们可以考虑给定 &lt;b&gt;HMM&lt;/b&gt; 的情况下，递归的计算一个可观察序列的概率。我们可以首先定义一个部分概率，表示达到某个中间状态的概率。接下来我们将看到这些部分概率是如何 在time=1 和 time = n (n &amp;gt; 1) 的时候计算的。&lt;/p&gt;&lt;p&gt; 假设一个T时间段的可观察序列是：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8d8093e9f2329a240cfaf0bac247a7e2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;130&quot; data-rawheight=&quot;41&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　1) 部分概率&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 下面这张图表示了一个观察序列（dry，damp，soggy）的一阶转移&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-aa3817cf245765cfc97d1e1dd295f691_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;329&quot; data-rawheight=&quot;208&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-aa3817cf245765cfc97d1e1dd295f691&quot; data-watermark-src=&quot;v2-9dd89bfec9ca825e742d5a626ebf39e4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 我们可以通过计算到达某个状态的所有路径的概率和来计算到达某个中间状态的概率。比如说，t=2时刻，cloudy的概率用三条路径的概率之和来表示：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-463baee0af7790baee0e98d65573bdad_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;332&quot; data-rawheight=&quot;183&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-463baee0af7790baee0e98d65573bdad&quot; data-watermark-src=&quot;v2-362bc117709d401c1d4e3dbd8538d03a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 我们用 αt(j) 来表示在 t 时刻是状态 j 的概率，αt(j)=Pr(观察状态 | 隐藏状态 j ) x Pr(t 时刻到达状态 j 的所有路径)。&lt;/p&gt;&lt;p&gt; 最后一个观察状态的部分概率就表示了整个序列最后达到某个状态的所有可能的路径的概率和，比如说在这个例子中，最后一列的部分状态是通过下列路径计算得到的：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d83c5ba765a9a93596a9a987b8bea8cc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;395&quot; data-rawheight=&quot;111&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d83c5ba765a9a93596a9a987b8bea8cc&quot; data-watermark-src=&quot;v2-3c5ca73cb5e72afff2fdea2ad86e26a7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 因为最后一列的部分概率是所有可能的路径的概率和，所以就是这个观察序列在给定 &lt;b&gt;HMM&lt;/b&gt; 下的概率了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　2) 计算 t=1时候的部分概率&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 当 t=1 的时候，没有路径到某个状态，所以这里是初始概率，Pr(状态 j | t=0) = π(状态 j )，这样我们就可以计算 t=1 时候的部分概率为：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11475808c1181147b59bcba2d6ed2351_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;154&quot; data-rawheight=&quot;42&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 因为在初始的时候，状态 j 的概率不仅和这个状态本身相关，还和观察状态有关，所以这里用到了&lt;b&gt;混淆矩阵&lt;/b&gt;的值，k1 表示第一个观察状态，bjk1 表示隐藏状态是 j，但是观察成 k1 的概率。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　3) 计算 t&amp;gt;1 时候的部分概率&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 还是看计算部分概率的公式是：αt(j) = Pr(观察状态 | 隐藏状态 j) x Pr(t 时刻到达状态 j 的所有路径)。 这个公式的左边是从混淆矩阵中已知的，我只需要计算右边部分，很显然右边是所有路径的和：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c1b6c50a1a279a93931764571d0da4fe_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;253&quot; data-rawheight=&quot;179&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c1b6c50a1a279a93931764571d0da4fe&quot; data-watermark-src=&quot;v2-af9e30f3bbe10dfef637a41df608c794&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 需要计算的路径数是和观察序列的长度的平方相关的，但是 t 时刻的部分概率已经计算过了之前的所有路径，所以在 t+1 时刻只需要根据 t 时刻的概率来计算就可以了：&lt;/p&gt;&lt;p&gt; 这里简单解释下，bjk(t+1) 就是在 t+1 时刻的第 j 个隐藏状态被认为是当前的观察状态的概率，后面一部分是所有t时刻的隐藏状态到 t+1 时候的隐藏状态j的转移的概率的和。这样我们每一步的计算都可以利用上一步的结果，节省了很多时间。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　4) 公式推导&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;b&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6974525598a03b5e10940731a4f269c5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;178&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6974525598a03b5e10940731a4f269c5&quot; data-watermark-src=&quot;v2-92dfc882ecdac9c9a873bed89fb5bdbb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;/b&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-28f0659cd3329306cee7c76e8758cd58_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;604&quot; data-rawheight=&quot;413&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-28f0659cd3329306cee7c76e8758cd58&quot; data-watermark-src=&quot;v2-591e1666867c0ce69003c249033a33c7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　5) 降低计算复杂度&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 我们可以比较穷举和递归算法的复杂度。假设有一个 &lt;b&gt;HMM&lt;/b&gt;，其中有 n 个隐藏状态，我们有一个长度为 T 的观察序列。&lt;/p&gt;&lt;p&gt; 穷举算法的需要计算所有可能的隐藏序列：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5d760ffe38b30aebc6f027c6bf54f8b5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;179&quot; data-rawheight=&quot;38&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 需要计算：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5362391cdedaeb7f75255f664ce689e0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;228&quot; data-rawheight=&quot;75&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5362391cdedaeb7f75255f664ce689e0&quot; data-watermark-src=&quot;v2-f71930454c38bb1b0d8718ff565fd5bc&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 很显然穷举算法的时间开销是和 T 指数相关的，即 NT，而如果采用递归算法，由于我们每一步都可以利用上一步的结果，所以是和 T 线性相关的，即复杂度是 N2T。&lt;/p&gt;&lt;p&gt; 这里我们的目的是在某个给定的 &lt;b&gt;HMM&lt;/b&gt; 下，计算出某个可观察序列的概率。我们通过先计算部分概率的方式递归的计算整个序列的所有路径的概率，大大节省了时间。在 t=1 的时候，使用了初始概率和&lt;b&gt;混淆矩阵&lt;/b&gt;的概率，而在t时刻的概率则可以利用 t-1 时刻的结果。&lt;/p&gt;&lt;p&gt; 这样我们就可以用递归的方式来计算所有可能的路径的概率和，最后，所有的部分概率的计算公式为&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4970b69d0fbffbb9b82043dc85d98b6b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;189&quot; data-rawheight=&quot;66&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 使用天气的例子，计算 t=2 时刻的 cloudy 状态的概率方法如图：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-18cdcc4a7de63ebe8817fe70ddc5ea1c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;364&quot; data-rawheight=&quot;342&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-18cdcc4a7de63ebe8817fe70ddc5ea1c&quot; data-watermark-src=&quot;v2-3f0e70826c737bd9474bb9978fbe0ce5&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 我们使用&lt;b&gt;前向算法&lt;/b&gt;在给定的一个 &lt;b&gt;HMM&lt;/b&gt; 下计算某个可观察序列的概率。&lt;b&gt;前向算法&lt;/b&gt;主要采用的是递归的思想，利用之前的计算结果。有了这个算法，我们就可以在一堆 &lt;b&gt;HMM&lt;/b&gt; 中，找到一个最满足当前的可观察序列的模型（前向算法计算出来的概率最大）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　（二） 根据可观察状态的序列找到一个最可能的隐藏状态序列&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 和上面一个问题相似的并且更有趣的是根据可观察序列找到隐藏序列。在很多情况下，我们对隐藏状态更有兴趣，因为其包含了一些不能被直接观察到的有价值的信息。比如说在海藻和天气的例子中，一个隐居的人只能看到海藻的状态，但是他想知道天气的状态。这时候我们就可以使用 &lt;b&gt;Viterbi 算法&lt;/b&gt;来根据可观察序列得到最优可能的隐藏状态的序列，当然前提是已经有一个 &lt;b&gt;HMM&lt;/b&gt;。&lt;/p&gt;&lt;p&gt; 另一个广泛使用 &lt;b&gt;Viterbi 算法&lt;/b&gt;的领域是自然语言处理中的词性标注。句子中的单词是可以观察到的，词性是隐藏的状态。通过根据语句的上下文找到一句话中的单词序列的最有可能的隐藏状态序列，我们就可以得到一个单词的词性（可能性最大）。这样我们就可以用这种信息来完成其他一些工作。&lt;/p&gt;&lt;p&gt; 下面介绍一下&lt;b&gt;维特比算法 &lt;/b&gt;(Viterbi Algorithm)&lt;/p&gt;&lt;p&gt; 　一．如何找到可能性最大的隐藏状态序列？&lt;/p&gt;&lt;p&gt; 通常我们都有一个特定的 &lt;b&gt;HMM&lt;/b&gt;，然后根据一个可观察状态序列去找到最可能生成这个可观察状态序列的隐藏状态序列。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　1. 穷举搜索&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 我们可以在下图中看到每个隐藏状态和可观察状态的关系。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a4cb68f8e62bc8fb11b95ee3b27b3d04_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;408&quot; data-rawheight=&quot;187&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a4cb68f8e62bc8fb11b95ee3b27b3d04&quot; data-watermark-src=&quot;v2-c7539ac1f64c4d90df95a5f4a75a1a2a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 通过计算所有可能的隐藏序列的概率，我们可以找到一个可能性最大的隐藏序列，这个可能性最大的隐藏序列最大化了 Pr(观察序列 | 隐藏状态集)。比如说，对于上图中的可观察序列 (dry damp soggy)，最可能的隐藏序列就是下面这些概率中最大的：&lt;/p&gt;&lt;p&gt; Pr(dry, damp, soggy | sunny, sunny, sunny), ……，Pr(dry, damp, soggy | rainy, rainy, rainy)&lt;/p&gt;&lt;p&gt; 这个方法是可行的，但是计算代价很高。和&lt;b&gt;前向算法&lt;/b&gt;一样，我们可以利用转移概率在时间上的不变性来降低计算的复杂度。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　2. 使用递归降低复杂度&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 在给定了一个可观察序列和HMM的情况下，我们可以考虑递归的来寻找最可能的隐藏序列。我们可以先定义一个部分概率 δ，即到达某个中间状态的概率。接下来我们将讨论如何计算 t=1 和 t=n (n&amp;gt;1) 的部分概率。&lt;/p&gt;&lt;p&gt; 注意这里的部分概率和&lt;b&gt;前向算法&lt;/b&gt;中的部分概率是不一样的，这里的部分概率表示的是在t时刻最可能到达某个状态的一条路径的概率，而不是所有概率之和&lt;b&gt;。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　1) 部分概率和部分最优路径&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 考虑下面这个图以及可观察序列 (dry, damp, soggy) 的一阶转移&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0697dc39b207c07517f497d9b86fa2d2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;337&quot; data-rawheight=&quot;216&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0697dc39b207c07517f497d9b86fa2d2&quot; data-watermark-src=&quot;v2-4e6d77a4c09fef4d0fc2c1f704b2ad55&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 对于每一个中间状态和终止状态 (t=3) 都有一个最可能的路径。比如说，在 t=3 时刻的三个状态都有一个如下的最可能的路径：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d82d1ce15a62e186cd21b3beff42fc94_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;394&quot; data-rawheight=&quot;114&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d82d1ce15a62e186cd21b3beff42fc94&quot; data-watermark-src=&quot;v2-1ff6749702fa7ebb5a2dcf7043f1e584&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 我们可以称这些路径为&lt;b&gt;部分最优路径&lt;/b&gt;。这些部分最优路径都有一个概率，也就是部分概率 δ。和&lt;b&gt;前向算法&lt;/b&gt;中的部分概率不一样，这里的概率只是一个最可能路径的概率，而不是所有路径的概率和。&lt;/p&gt;&lt;p&gt; 我们可以用 δ(i, t) 来表示在t时刻，到状态i的所有可能的序列（路径）中概率最大的序列的概率，部分最优路径就是达到这个最大概率的路径，对于每一个时刻的每一个状态都有这样一个概率和部分最优路径。&lt;/p&gt;&lt;p&gt; 最后，我们通过计算 t=T 时刻的每一个状态的最大概率和部分最优路径，选择其中概率最大的状态和它的部分最优路径来得到全局的最优路径。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　2) 计算 t=1 时刻的部分概率&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 当 t=1 时刻的时候，到达某个状态最大可能的路径还不存在，但是我们可以直接使用在 t=1 时刻某个状态的概率和这个状态到可观察序列 k1 的转移概率：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-36bbf69d89c2703dc2e55727443f4eda_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;156&quot; data-rawheight=&quot;43&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　3) 计算 t&amp;gt;1 时刻的部分概率&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 接下来我们可以根据 t-1 时刻的部分概率来求 t 时刻的部分概率&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-dc5491ae97c35edc603a46a1d4fa2296_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;286&quot; data-rawheight=&quot;139&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-dc5491ae97c35edc603a46a1d4fa2296&quot; data-watermark-src=&quot;v2-4e3ea6f2216d5fce7e11e4518fce1d5a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 我们可以计算所有到状态 X 的路径的概率，找到其中最可能的路径，也就是局部最优路径。注意到这里，到达X的路径必然会经过 t-1 时刻的 A、B 和 C，所以我们可以利用之前的结果。达到X的最可能的路径就是下面三个之一：&lt;/p&gt;&lt;p&gt; (状态序列)，. . .，A，X (状态序列)，. . .，B，X (状态序列)，. . .，C，X&lt;/p&gt;&lt;p&gt; 我们需要做的就是找到以 AX、BX 和 CX 结尾的路径中概率最大的那个。&lt;/p&gt;&lt;p&gt; 根据&lt;b&gt;一阶马尔科夫的假设&lt;/b&gt;，一个状态的发生之和之前的一个状态有关系，所以X在某个序列的最后发生的概率只依赖于其之前的一个状态：&lt;/p&gt;&lt;p&gt;Pr (到达A的最优路径) . Pr (X | A) . Pr (观察状态 | X)&lt;/p&gt;&lt;p&gt; 有个了这个公式，我们就可以利用t-1时刻的结果和状态转移矩阵和混淆矩阵的数据：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4a13df57c36d23191ab307a3e854ec6b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;599&quot; data-rawheight=&quot;33&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 将上面这个表达式推广一下，就可以得到 t 时刻可观察状态为 kt 的第 i 个状态的最大部分概率的计算公式：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98dd6db2b61c0334755cd504ca464ac8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;242&quot; data-rawheight=&quot;51&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-98dd6db2b61c0334755cd504ca464ac8&quot; data-watermark-src=&quot;v2-b60ff8d83332448d31361ad082fe0300&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 其中 aji 表示从状态 j 转移到状态 i 的概率，bikt 表示状态i被观察成 kt 的概率。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　4) 后向指针&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 考虑下图&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0ba0a23c0dba967a6ff39e60ff9d5da9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;333&quot; data-rawheight=&quot;213&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0ba0a23c0dba967a6ff39e60ff9d5da9&quot; data-watermark-src=&quot;v2-a4c5e96eb0d3b34a43df0e14c3551c26&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 在每一个中间状态和结束状态都有一个部分最优概率 δ(i, t)。但是我们的目的是找到最可能的隐藏状态序列，所以我们需要一个方法去记住部分最优路径的每一个节点。&lt;/p&gt;&lt;p&gt; 考虑到要计算 t 时刻的部分概率，我们只需要知道 t-1 时刻的部分概率，所以我们只需要记录那个导致了 t 时刻最大部分概率的的状态，也就是说，在任意时刻，系统都必须处在一个能在下一时刻产生最大部分概率的状态。如下图所示：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-93efd1be81ff5ee48910a73a7c70ac2b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;282&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-93efd1be81ff5ee48910a73a7c70ac2b&quot; data-watermark-src=&quot;v2-a9a7aa12671540397e06925f09c2a723&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 我们可以利用一个后向指针 φ 来记录导致某个状态最大局部概率的前一个状态，即&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3aa1b5b691882bb8b7e499fd2db20a68_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;296&quot; data-rawheight=&quot;37&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 这里 argmax 表示能最大化后面公式的j值，同样可以发现这个公式和 t-1 时刻的部分概率和转移概率有关，因为后向指针只是为了找到“我从哪里来”，这个问题和可观察状态没有关系，所以这里不需要再乘上混淆矩阵因子。全局的行为如下图所示：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-03b7629d556f5ea86bcd3b6b68104f70_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;202&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-03b7629d556f5ea86bcd3b6b68104f70&quot; data-watermark-src=&quot;v2-a23650ba97cfe3217eac5014458dcf83&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　5) 优点&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 使用 &lt;b&gt;viterbi &lt;/b&gt;算法对一个可观察状态进行解码有两个重要的优点：&lt;/p&gt;&lt;p&gt; a) 通过使用递归来减少复杂度，这点和之前的&lt;b&gt;前向算法&lt;/b&gt;是一样的&lt;/p&gt;&lt;p&gt; b) 可以根据可观察序列找到最优的隐藏序列，这个的计算公式是：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5d760ffe38b30aebc6f027c6bf54f8b5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;179&quot; data-rawheight=&quot;38&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中 &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-402beb019c7789ffaa9c675f4a28177a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;223&quot; data-rawheight=&quot;74&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-402beb019c7789ffaa9c675f4a28177a&quot; data-watermark-src=&quot;v2-75140cbd792d8e69bcd30a54ce93876f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 这里就是一个从左往右翻译的过程，通过前面的翻译结果得到后面的结果，起始点是初始向量 π。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　3. 补充&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 但在序列某个地方有噪声干扰的时候，某些方法可能会和正确答案相差的较远。但是 &lt;b&gt;Viterbi &lt;/b&gt;算法会查看整个序列来决定最可能的终止状态，然后通过后向指针来找到之前的状态，这对忽略孤立的噪声非常有用。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　Viterbi&lt;/b&gt; 算法提供了一个根据可观察序列计算隐藏序列的很高效的方法，它利用递归来降低计算复杂度，并且使用之前全部的序列来做判断，可以很好的容忍噪声。&lt;/p&gt;&lt;p&gt; 在计算的过程中，这个算法计算每一个时刻每一个状态的部分概率，并且使用一个后向指针来记录达到当前状态的最大可能的上一个状态。最后，最可能的终止状态就是隐藏序列的最后一个状态，然后通过后向指针来查找整个序列的全部状态。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　（三） 根据观察到的序列集来找到一个最有可能的 HMM。 &lt;/b&gt;&lt;/p&gt;&lt;p&gt; 在很多实际的情况下，&lt;b&gt;HMM&lt;/b&gt; 不能被直接的判断，这就变成了一个学习问题，因为对于给定的可观察状态序列 O 来说，没有任何一种方法可以精确地找到一组最优的 &lt;b&gt;HMM&lt;/b&gt; 参数 &lt;b&gt;λ&lt;/b&gt; 使 P(O | λ) 最大，于是人们寻求使其局部最优的解决办法，而&lt;b&gt;前向后向算法&lt;/b&gt;（也称为&lt;b&gt;Baum-Welch&lt;/b&gt;算法）就成了 &lt;b&gt;HMM&lt;/b&gt;学习问题的一个近似的解决方法。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　前向后向算法&lt;/b&gt;首先对于 &lt;b&gt;HMM&lt;/b&gt; 的参数进行一个初始的估计，但这个很可能是一个错误的猜测，然后通过对于给定的数据评估这些参数的的有效性并减少它们所引起的错误来更新 &lt;b&gt;HMM&lt;/b&gt; 参数，使得和给定的训练数据的误差变小，这其实是&lt;b&gt;机器学习&lt;/b&gt;中的&lt;b&gt;梯度下降&lt;/b&gt;的思想。&lt;/p&gt;&lt;p&gt; 对于网格中的每一个状态，&lt;b&gt;前向后向算法&lt;/b&gt;既计算到达此状态的“前向”概率，又计算生成此模型最终状态的“后向”概率，这些概率都可以通过前面的介绍利用递归进行高效计算。可以通过利用近似的&lt;b&gt; HMM&lt;/b&gt; 模型参数来提高这些中间概率从而进行调整，而这些调整又形成了&lt;b&gt;前向后向算法&lt;/b&gt;迭代的基础。&lt;/p&gt;&lt;p&gt; 另外，&lt;b&gt;前向后向算法&lt;/b&gt;是 &lt;b&gt;EM 算法&lt;/b&gt;的一个特例，它避免了 &lt;b&gt;EM 算法&lt;/b&gt;的暴力计算，而采用动态规划思想来解决问题，Jelinek 在其书《Statistical Methods for Speech Recognition》中对&lt;b&gt;前向后向算法&lt;/b&gt;与 &lt;b&gt;EM 算法&lt;/b&gt;的关系进行了详细描述，有兴趣的读者可以参考这本书。&lt;/p&gt;&lt;p&gt; 类似于上面讲到的&lt;b&gt;前向算法&lt;/b&gt;，我们也可以定义后向变量 βt(i) 来计算给定当前隐藏状态 i 时，部分观察序列 ot+1，ot+2，…，oT的概率，即：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-713ea636c4faf15066a4d9fbe17be240_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;343&quot; data-rawheight=&quot;41&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 与前向算法类似，我们也可以通过迭代算法有效计算 βt(i)，计算公式如下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2dd6fbd76fab5ed92babfb09c1f9d4cc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;387&quot; data-rawheight=&quot;65&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2dd6fbd76fab5ed92babfb09c1f9d4cc&quot; data-watermark-src=&quot;v2-4e82e61f4f3f405bc009a86833f1baa4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 其中&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-416ae3b7ee3ea4f8bcb92369e3213fd4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;178&quot; data-rawheight=&quot;39&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 进一步我们可以发现&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2e1a2805e118f107d02710c5af0190a7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;447&quot; data-rawheight=&quot;42&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 因此&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6cf8804c0a99796ce4f8c891854eb44d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;526&quot; data-rawheight=&quot;62&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 下面开始介绍&lt;b&gt;前向后向算法&lt;/b&gt;。&lt;/p&gt;&lt;p&gt; 首先我们需要定义两个辅助变量，这两个变量可以用前文介绍过的前向变量和后向变量进行定义。&lt;/p&gt;&lt;p&gt; 第一个变量定义为 t 时状态 i 和 t+1 时状态 j 的概率，即&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-58fd120cf04fd003255b26a3f6a8a98e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;327&quot; data-rawheight=&quot;44&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 该变量在网格中所代表的关系如下图所示：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e2c986678c089b8969b4052ec6ca6fae_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;444&quot; data-rawheight=&quot;220&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e2c986678c089b8969b4052ec6ca6fae&quot; data-watermark-src=&quot;v2-252158fe4afc9d6e28c4aec4555201fa&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt; 该等式等价于&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fe8da010b89cbac5bc83e00350395057_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;294&quot; data-rawheight=&quot;58&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-fe8da010b89cbac5bc83e00350395057&quot; data-watermark-src=&quot;v2-6012282059f5646d8a256b8e3a068464&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 利用前向变量和后向变量，上式可以表示为&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ffb6530856c9d3302b929f360d053f96_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;323&quot; data-rawheight=&quot;98&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ffb6530856c9d3302b929f360d053f96&quot; data-watermark-src=&quot;v2-014168153cb78f19610763bcff437d51&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 第二个变量定义为后验概率，也就是在给定观察状态序列和 &lt;b&gt;HMM &lt;/b&gt;的情况下，t 时状态 i 的概率，即&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-75e2fbde6f188361aebcb8060a8ad572_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;232&quot; data-rawheight=&quot;37&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 利用前向变量和后向变量，上式可以表示为&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-90cda2de9a4b12e87a0861349241b136_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;222&quot; data-rawheight=&quot;131&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-90cda2de9a4b12e87a0861349241b136&quot; data-watermark-src=&quot;v2-788b4ddc48e034714b5e4dd1a672ad64&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　因此，下式为在任意时刻状态 i 的期望，也就是从状态 i 转移到观察状态 o 的期望&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　同样，下式也就是从状态 i 转移到状态 j 的期望&lt;/p&gt;&lt;p&gt; 我们可以发现定义的这两个变量之间的关系为&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1d180a461208a9195960c238cb55258d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;310&quot; data-rawheight=&quot;60&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1d180a461208a9195960c238cb55258d&quot; data-watermark-src=&quot;v2-18b0ae9cef6ee555628f546cef842e4f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 下面介绍&lt;b&gt;前向后向算法&lt;/b&gt;的参数学习过程，在学习的过程中，不断更新 &lt;b&gt;HMM&lt;/b&gt; 的参数，从而使得 P(O | λ) 最大。我们假设初始的 &lt;b&gt;HMM&lt;/b&gt; 参数为  λ={ π, &lt;i&gt;A, B &lt;/i&gt;}，首先计算前向变量 α 和后向变量 β，再根据刚刚介绍的公式计算期望 ξ 和 ζ，最后，根据下面的3个重估计公式更新&lt;b&gt; HMM&lt;/b&gt; 参数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2900dea8b567efa998aded7fbdf3b425_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;348&quot; data-rawheight=&quot;287&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2900dea8b567efa998aded7fbdf3b425&quot; data-watermark-src=&quot;v2-490b97ffecef24280a06b1779e1bea7d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 如果我们定义当前的 &lt;b&gt;HMM&lt;/b&gt; 模型为 λ={ π，&lt;i&gt;A，B &lt;/i&gt;}，那么可以利用该模型计算上面三个式子的右端；我们再定义重新估计的 &lt;b&gt;HMM&lt;/b&gt; 模型为&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-536b33d3c3ef06f4638657f0bab4b7d4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;86&quot; data-rawheight=&quot;26&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;，那么上面三个式子的左端就是重估的 &lt;b&gt;HMM&lt;/b&gt; 模型参数。Baum 及他的同事在70年代证明了&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a7cf43798821be9bafbec6f6f148d43d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;136&quot; data-rawheight=&quot;28&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;，因此如果我们迭代地计算上面三个式子，由此不断地重新估计 &lt;b&gt;HMM&lt;/b&gt; 的参数，那么在多次迭代后可以得到 &lt;b&gt;HMM&lt;/b&gt; 模型的一个最大似然估计。不过需要注意的是，前向后向算法所得的这个最大似然估计是一个局部最优解。&lt;/p&gt;</description>
<author>量化家</author>
<guid isPermaLink="false">2018-07-31-40962600</guid>
<pubDate>Tue, 31 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>策略||数据处理</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-07-30-40876243.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40876243&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;异常数据的影响&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;以2016年5月底全市场股票的ROE数据为例，这里总共有2824个数据：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;between = roe[(roe.ROE &amp;lt;= 0.5) &amp;amp; (roe.ROE &amp;gt;= -0.5)]
float(len(between))/len(roe)&lt;/code&gt;&lt;p&gt;0.9851274787535411&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以看到有98%的数据都在[-0.5, 0.5]之间&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;去掉上下各1%的数据&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;remove = roe[(roe.ROE &amp;lt;= roe.quantile(0.99).iloc[0]) &amp;amp;
 (roe.ROE &amp;gt;=roe.quantile(0.01).iloc[0])]&lt;/code&gt;&lt;h2&gt;&lt;b&gt;异常值的识别&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;固定比例法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上下2%的值进行拉回，这些数据不可信。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;均值标准差法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这种想法的思路来自于正态分布，假设&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a9d4e5ce53a24c718b892a69ba007d42_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;97&quot; data-rawheight=&quot;23&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;那么&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-547d86e0e8df086419092f49b371cfb2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;311&quot; data-rawheight=&quot;67&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-547d86e0e8df086419092f49b371cfb2&quot; data-watermark-src=&quot;v2-929ff202a3d3666e155c3235e6f73b91&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;通常把三倍标准差之外的值都视为异常值，不过要注意的是样本均值和样本标准差都不是稳健统计量，其计算本身受极值的影响就非常大，所以可能会出现一种情况，那就是我们从数据分布图上能非常明显的看到异常点，但按照上面的计算方法，这个异常点可能仍在均值三倍标准差的范围内。因此按照这种方法剔除掉异常值后，需要重新观察数据的分布情况，看是否仍然存在显著异常点，若存在则继续重复上述步骤寻找异常点。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;理解：因为剔除掉极值后，样本的方差可能发生变化了（正如文中所说，它不是一个稳健的估计量），每次剔除通常都会变化——就是因为这个，所以需要重复的去做。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果数据不服从正态分布，可以通过切比雪夫不等式依然可以对均值的若干倍标准差之外的样本数据量的占比进行估计：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c65c7beed9d6de49f73eeff4f72985ca_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;212&quot; data-rawheight=&quot;35&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;坏处对于这样的方法，上面不等式右边的上界数值会偏大，在数据分布的偏度和峰度影响下，这种方法可能会把过量的数据认定为异常点。 &lt;/p&gt;&lt;p&gt;如果通过Box-Cox变换将不服从正态分布的数据转化为服从正态分布的数据，那么是否可行呢？熟悉Box-Cox变换方法的都知道，经过这样的一个变换，例如就取对数，它会缩小数据之间的距离，这样可能会使得原来是异常值的点变为不是异常值。&lt;br&gt;&lt;b&gt;MAD法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;MAD 法是针对均值标准差方法的改进，把均值和标准差替换成稳健统计量，样本均值用样本中位数代替，样本标准差用样本MAD（Median Absolute Deviation）代替：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0313342a387d2e4947bc295003a7d67b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;240&quot; data-rawheight=&quot;31&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c276044210dd85c5c00f0592fd11cfb7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;314&quot; data-rawheight=&quot;28&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f07c81a5dffb04dca08b8400ac85e077_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;184&quot; data-rawheight=&quot;32&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;通常把偏离中位数三倍以上的数据作为异常值。和均值标准差方法比，中位数和MAD的计算不受极端异常值的影响，结果更加稳健。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;boxplot法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们知道箱线图上其实也会注明异常值，假设Q1和Q3分别为数据从小到大排列的25%和75%分位数，记IQR=Q1-Q3，把&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ab260048641a01e98e4ea125020dce84_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;309&quot; data-rawheight=&quot;22&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;区间里的数据标识为异常点。分位数也是稳健统计量，因此Boxplot 方法对极值不敏感，但如果样本数据正偏严重，且右尾分布明显偏厚时，Boxplot 方法会把过多的数据划分为异常数据，因此Hubert&amp;amp; Vandervieren （2007）对原有Boxplot 方法进行了偏度调整。首先样本偏度定义采用了Brys(2004)提出的MedCouple方法：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c5206623c31cb6fcf03ab15cb6533930_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;231&quot; data-rawheight=&quot;30&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1428c4297a783136cad3114640a404e7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;457&quot; data-rawheight=&quot;52&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;然后给出了经偏度调整boxplot方法上下限：&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3e82d5d101f6be87936b73cbcdf3b18a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;390&quot; data-rawheight=&quot;103&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-3e82d5d101f6be87936b73cbcdf3b18a&quot; data-watermark-src=&quot;v2-f620a2377be043ea6a573877c6df335a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;区间上的点视为异常点。和原始Boxplot 方法相比，当样本数据分布右偏时，此法会提升正常数据区间上限的数值；样本数据左偏时，则会降低正常数据区间下限的数值。&lt;/p&gt;&lt;p&gt;这个mc可以使用statsmodels包中的函数直接进行计算&lt;br&gt;&lt;/p&gt;&lt;p&gt;def _medcouple_1d(y):    &quot;&quot;&quot;&lt;br&gt;    Calculates the medcouple robust measure of skew.&lt;br&gt;    Parameters&lt;br&gt;    ----------&lt;br&gt;    y : array-like, 1-d&lt;br&gt;    Returns&lt;br&gt;    -------&lt;br&gt;    mc : float&lt;br&gt;        The medcouple statistic&lt;br&gt;    Notes&lt;br&gt;    -----&lt;br&gt;    The current algorithm requires a O(N**2) memory allocations, and so may&lt;br&gt;    not work for very large arrays (N&amp;gt;10000).&lt;br&gt;    .. [1] M. Huberta and E. Vandervierenb, &quot;An adjusted boxplot for skewed&lt;br&gt;    distributions&quot; Computational Statistics &amp;amp; Data Analysis, vol. 52,&lt;br&gt;    pp. 5186-5201, August 2008.&lt;br&gt;    &quot;&quot;&quot;&lt;br&gt;    y = np.squeeze(np.asarray(y))    &lt;br&gt;    if y.ndim != 1:        &lt;br&gt;        raise ValueError(&quot;y must be squeezable to a 1-d array&quot;)&lt;br&gt;    y = np.sort(y)&lt;br&gt;    n = y.shape[0]    if n % 2 == 0:&lt;br&gt;        mf = (y[n // 2 - 1] + y[n // 2]) / 2    else:&lt;br&gt;        mf = y[(n - 1) // 2]&lt;br&gt;    z = y - mf&lt;br&gt;    lower = z[z &amp;lt;= 0.0]&lt;br&gt;    upper = z[z &amp;gt;= 0.0]&lt;br&gt;    upper = upper[:, None]&lt;br&gt;    standardization = upper - lower&lt;br&gt;    is_zero = np.logical_and(lower == 0.0, upper == 0.0)&lt;br&gt;    standardization[is_zero] = np.inf&lt;br&gt;    spread = upper + lower    return np.median(spread / standardization)&lt;br&gt;sm.stats.stattools.medcouple(roe.ROE)&lt;/p&gt;&lt;p&gt;array(0.04458953766624774)&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;偏度调整Boxplot和MAD方法对比&lt;/b&gt;&lt;/p&gt;&lt;p&gt;首先使用计算机模拟来进行比较这两种方法。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-421667d5d0e372b7e0d0b74cb6f52c10_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;760&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-421667d5d0e372b7e0d0b74cb6f52c10&quot; data-watermark-src=&quot;v2-cd59c1299824ffdb035e8571a91adf23&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;# 计算异常值占比

def mad(x):    if len(x) == 0:        
        return np.NaN    
    else:
        md = np.median(x)
        mad_ = np.median([np.abs(i-md) for i in x])
        mad_e = 1.483*mad_
        left_percent = len(x[(x&amp;lt;=(md-3*mad_e))])/float(len(x))
        right_percent = len(x[(x&amp;gt;=(md+3*mad_e))])/float(len(x))
        total = len(x[(x&amp;lt;=(md-3*mad_e))|(x&amp;gt;=(md+3*mad_e))])/float(len(x))        
    return [left_percent, right_percent, total]

def adj_boxplot(x):    if len(x) == 0:        
        return np.NaN    
    else:
        mc = sm.stats.stattools.medcouple(x)
        x.sort()
        q1 = x[int(0.25*len(x))]
        q3 = x[int(0.75*len(x))]
        iqr = q3-q1        
    if mc &amp;gt;= 0:
            l = q1-1.5*np.exp(-3.5*mc)*iqr
            u = q3+1.5*np.exp(4*mc)*iqr        
    else:
            l = q1-1.5*np.exp(-4*mc)*iqr
            u = q3+1.5*np.exp(3.5*mc)*iqr
        left_percent = len(x[x&amp;lt;=l])/float(len(x))
        right_percent = len(x[x&amp;gt;=u])/float(len(x))
        total = len(x[(x&amp;lt;=l)|(x&amp;gt;=u)])/float(len(x))        
    return [left_percent, right_percent, total]
fig = plt.figure(figsize=(7, 4))
ax = fig.add_subplot(111)
ax.plot(adj_boxplot_left, &#39;-o&#39;, label=&#39;adj_boxplot&#39;)
ax.plot(mad_method_left, &#39;-^&#39;, label=&#39;mad&#39;)
l = ax.legend(loc=1)
l = ax.set_ylabel(u&quot;left percentage&quot;)
l = ax.set_xticklabels([&#39;SN&#39;, &#39;LN(0, 0.2)&#39;, &#39;LN(0, 0.4)&#39;, &#39;LN(0, 0.6)&#39;, &#39;LN(0, 0.8)&#39;, &#39;LN(0, 1)&#39;])
l = ax.set_xlabel(u&quot;different distribution&quot;)&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8aa5c89791c4155a11747b0480a1a44d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;475&quot; data-rawheight=&quot;274&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-8aa5c89791c4155a11747b0480a1a44d&quot; data-watermark-src=&quot;v2-4477d6a70d85708ceaa909b882039df0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5f938cbfd5f1febb5018d803b89fe035_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;469&quot; data-rawheight=&quot;274&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5f938cbfd5f1febb5018d803b89fe035&quot; data-watermark-src=&quot;v2-fc606ac804f028f0d4f0408e08c2c03b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a781ad80c6b5bc6e86bb697188626d16_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;469&quot; data-rawheight=&quot;274&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a781ad80c6b5bc6e86bb697188626d16&quot; data-watermark-src=&quot;v2-2702af2ec8ae9c2a598685950cb5b0b9&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;还可以对单个分布，不同样本量进行测试，不写了。&lt;/p&gt;&lt;p&gt;再拿个几因子实际来比较这两种方法。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;def compare_factor(factor_name, month_list):    factor_data = pd.DataFrame(index=month_list, columns=universe)    
for date in factor_data.index:
        current_data = DataAPI.MktStockFactorsOneDayProGet(tradeDate=date, secID=universe, 
                                                           field=[u&quot;secID&quot;, u&quot;tradeDate&quot;,factor_name], pandas=&quot;1&quot;)
        current_data = current_data.pivot(index=&#39;tradeDate&#39;, columns=&#39;secID&#39;, values=factor_name)
        factor_data = factor_data.append(current_data)
    percent_mad = []
    precent_boxplot = []    
    for date in factor_data.index:
        sample = np.array(factor_data.ix[date, :].dropna())        if isinstance(mad(sample), list):
            percent_mad.append(mad(sample)[2])
            precent_boxplot.append(adj_boxplot(sample)[2])

    a = np.array(percent_mad).mean()
    b = np.array(precent_boxplot).mean()    
return [a, b, factor_data]
PEG3Y = compare_factor(&#39;PEG3Y&#39;, month_list)
print u&#39;市盈率/归属于母公司所有者净利润3年复合增长率:&#39;, u&#39;MAD&#39;, PEG3Y[0], &#39;;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;市盈率/归属于母公司所有者净利润3年复合增长率:&lt;/p&gt;&lt;p&gt;MAD 0.140822936272 &lt;/p&gt;&lt;p&gt; Adj boxplot 0.158164542833&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;对数市值:&lt;/p&gt;&lt;p&gt;MAD 0.0291881850994 ;&lt;/p&gt;&lt;p&gt;Adj boxplot 0.00655765983319&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;对数流通市值:&lt;/p&gt;&lt;p&gt;MAD 0.0221524346318 ;&lt;/p&gt;&lt;p&gt;Adj boxplot 0.0229505798271&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;和Seo(2002)做的仿真测试结果一致，对于市值这样样本偏度较大的数据，MAD方法识别出的异常数值比例明显高于偏度调整后的Boxplot方法。从研报的结果来看，MAD方法认定的异常数据数量明显高于Boxplot方法，剔除或修改太多数据不利于后续的统计分析。可以尝试人为提高MAD方法中的一些阈值设置来降低异常数据占比，但这样有可能使得一些本该剔除的数据未被侦测出来，如果每个因子都设置一个阈值的话，调试的工作量会比较大。相对来说，偏度调整过的Boxplot方法对不同因子的适应性更强，建议在实证研究中采用。&lt;/p&gt;&lt;p&gt;&lt;b&gt;数据正太转换&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;非正态数据的影响&lt;/b&gt;&lt;/p&gt;&lt;p&gt;因子选股过程中至少有两个地方涉及因子数据的正态分布假设：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Alpha因子的zscore计算。只有当两个因子的分布都为近似正态分布时，基于均值-标准差标准化得到的zscore 才有可比性，否则样本偏度和峰度的影响会使得个股在某一个因子上的得分明显偏大或偏小，其在多因子中的效用被显著放大或缩小，也就是Scinto(2009)提到的Percential Ranking Problem。&lt;/li&gt;&lt;li&gt;风险因子的因子收益率显著性检验。因子收益率由横截面回归得到，其显著性检验有赖于残差项的正态分布假设，虽然线性回归对解释变量与被解释变量的分布没有要求，但当解释变量和被解释变量满足正态分布时，更容易得到符合正态分布的残差。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;每个因子数据都去看下偏度，峰度有点多。主要是电脑还在跑其他的耗内存的代码，所以就不做了。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;def my_winsorize(data):    if isinstance(data, pd.Series):
        mc = sm.stats.stattools.medcouple(data)
        data.sort()
        q1 = data[int(0.25*len(data))]
        q3 = data[int(0.75*len(data))]
        iqr = q3-q1        if mc &amp;gt;= 0:
            l = q1-1.5*np.exp(-3.5*mc)*iqr
            u = q3+1.5*np.exp(4*mc)*iqr        else:
            l = q1-1.5*np.exp(-4*mc)*iqr
            u = q3+1.5*np.exp(3.5*mc)*iqr
        data[data&amp;lt;l]=l
        data[data&amp;gt;u]=u    
return data
peg_3y = PEG3Y[2]
factor_skew = []
factor_kurt = []
for date in peg_3y.index:
    data = peg_3y.ix[date,:].dropna()    
    if len(data) &amp;gt; 0:
        data = my_winsorize(data)
        data = np.array(data)
        factor_skew.append(st.skew(data))
        factor_kurt.append(st.kurtosis(data))
print u&#39;极值调整后PEG3Y因子的平均偏度与峰度：&#39;
print u&#39;偏度：&#39;, np.mean(factor_skew)
print u&#39;峰度：&#39;, np.mean(factor_kurt)&lt;/code&gt;&lt;p&gt;极值调整后PEG3Y因子的平均偏度与峰度：&lt;/p&gt;&lt;p&gt;偏度： -3.00481152198 峰度： 10.2882451426&lt;/p&gt;&lt;p&gt;极值调整后LCAP因子的平均偏度与峰度：&lt;/p&gt;&lt;p&gt;偏度： 1.22322935534 峰度： 2.08015032857&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 Box-Cox变换&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在多元回归分析，时间序列分析中经常都见到Box-Cox变换变换。把非正态数据转换为正态数据通常有取对数、开根号、求倒数等方法，这些都可以归为Box-Cox变换，形式上可以写作：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cf2c73cedb3649c80b6f31ceeee71861_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;215&quot; data-rawheight=&quot;54&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-cf2c73cedb3649c80b6f31ceeee71861&quot; data-watermark-src=&quot;v2-4f93d5a3efc91d493f399d98e66aa436&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;参数λ可以通过极大似然法做估计（Box&amp;amp;Cox，1964）。不过Box-Cox 变换并非万能，变换后的数据仍然可能不满足正态分布，被统计检验拒绝，但是这种变换得到的数据分布往往都有明显的对称性，与正态分布的相似性更高。 只有取正值的数据才能使用Box-Cox变换，对于一些数据是负数或者为零，在Box-Cox变换之前，需要在所有值上加一个正数，使得所有数据为正。但这种移动是主观确定的。另一种方法是适用于任何数据的变换，无论正负，这种方法的一个缺点是，对他的解释不如对Box-Cox变换的解释来得直观，参见Yeo和Johnson(2000)。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3 正态变换的选择&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们知道一个因子通常包括两个维度，由于通常的alpha因子zscore 打分和风险因子中性化处理都在横截面方向进行，因此我们主要对同一个时间点横截面上的因子数据做正态转换处理。但是如果把数据正态转换当成一个纯粹的数学问题，每个横截面上都用极大似然方法估算一个最优的λ，会发现有的选股因子的λ数值变化非常之大。以EP因子的月度数据为例。&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;PE = compare_factor(&#39;PE&#39;, month_list)
EP= 1/PE[2]
lambda_ = pd.Series(index=EP.index)
for date in EP.index:
    data = np.array(EP.ix[date,:].dropna()+3, dtype=float)    
    if len(data) &amp;gt; 0:
        lambda_.ix[date]=st.boxcox(data)[1]    
    else:
        lambda_.ix[date]=np.NaN
lambda_.dropna(inplace=True)
ax = lambda_.plot()
t = ax.set_title(u&#39;EP因子Box-Cox变换的最优lambda&#39;, fontpropert=font, fontsize=16)&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-770dc5e5015ab7f146d2c586f089b2e1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;355&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-770dc5e5015ab7f146d2c586f089b2e1&quot; data-watermark-src=&quot;v2-f1df02d0fec9a4480ea8f28ef7ba3a9b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以看到Lambda中间有一段的变化是非常剧烈的，也就是说每个月我们需要对原始的数据都做不同的数据变化。Box-Cox是一个单调变换，保持了原有数据的相对秩序，因此变换后的因子和原始因子的IC（秩相关系数）相等；但这种变换会改变alpha因子的zscore，频繁剧烈变换的参数可能会对结果产生负面影响，变换后因子的经济含义也更加难以解释，所以把因子数据正态变换当成一个单纯数学问题的方法不可取。&lt;/p&gt;</description>
<author>量化家</author>
<guid isPermaLink="false">2018-07-30-40876243</guid>
<pubDate>Mon, 30 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>策略||数据可视化</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-07-27-40701499.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40701499&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  Python中，matplotlib可以视为数据可视化的基准和主力。尽管有许多其他的可视化库，但是matplotlib已经确立了一个标杆，在许多情况下，它都是健壮、可靠的可视化工具。在标准的绘图工作中很容易理解，对更复杂的绘图和自定义又很灵活。此外，它与NumPy及其提供的数据结构紧密集成。下面就列举几个用二维数据集说明对金融应用程序中的可视化方法。&lt;/p&gt;&lt;p&gt;首先要先导入NumPy和matplotlib这两个库，主要的绘图函数在子库matplotlib.pyplot中：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0aa49f05c9b4e526101aa51fe804cf16_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;218&quot; data-rawheight=&quot;43&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0aa49f05c9b4e526101aa51fe804cf16&quot; data-watermark-src=&quot;v2-029880039662c6e85c49389c9b155f2e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;散点图&lt;/b&gt;&lt;/p&gt;&lt;p&gt;  要介绍的第一种图表是散点图，这种图表中一个数据集的值作为其他数据集的x值。例如，这种图标类型可用于绘制一个金融时间序列的收益和另一个时间序列收益的对比。下面例子中，将使用二维数据集和其他一些数据。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-27368169b1878a32582d8d6f5b5dc31b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;281&quot; data-rawheight=&quot;119&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-27368169b1878a32582d8d6f5b5dc31b&quot; data-watermark-src=&quot;v2-df73c2eb32f7b316b04802c601677e4d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5e589663446d4b841d56cd26f836e9e2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;468&quot; data-rawheight=&quot;400&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5e589663446d4b841d56cd26f836e9e2&quot; data-watermark-src=&quot;v2-ff42ebd91ec0abb6943a5b151bccfb7c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;直方图&lt;/b&gt;&lt;/p&gt;&lt;p&gt;  另一种图表类型直方图也常常用于金融收益中。它是金融应用中的重要图表类型。主要应用plt.hist这个函数。下面显示的是两个数据集的数据在直方图中堆叠。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6b858265870bc1002f05c2bd5de954fb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;331&quot; data-rawheight=&quot;146&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6b858265870bc1002f05c2bd5de954fb&quot; data-watermark-src=&quot;v2-f1d06f509c77a73d7094007fdc27fd11&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-20e916ee8b7951c8e867fc45a24e0fb0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;530&quot; data-rawheight=&quot;248&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-20e916ee8b7951c8e867fc45a24e0fb0&quot; data-watermark-src=&quot;v2-fbb911445319e3198638e336d65c8651&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;箱形图&lt;/b&gt;&lt;/p&gt;&lt;p&gt;  另一种实用图表类型是箱形图。和直方图类似，它可以简洁概述数据集的特性，很容易比较多个数据集。通过下面的例子我们绘制出了这类图表。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-aff06ad2f5e9073fde2478965c25281a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;278&quot; data-rawheight=&quot;132&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-aff06ad2f5e9073fde2478965c25281a&quot; data-watermark-src=&quot;v2-2b209f644b4ec1b61ab8faca9ddb3777&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-830df5e5f7220632b81122eee8f4b7f1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;499&quot; data-rawheight=&quot;385&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-830df5e5f7220632b81122eee8f4b7f1&quot; data-watermark-src=&quot;v2-63bd51496470e7ea4285be435f81c3c8&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;特殊金融图表&lt;/b&gt;&lt;/p&gt;&lt;p&gt;  matplotlib还提供了少数精选的特殊金融图表。这些图表（如柱状图）主要用于可视化历史股价数据或者类似的金融时间序列数据，可以在matplotlib.finance子库中找到：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0383e514938d639c9fcca5f9de40fc18_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;225&quot; data-rawheight=&quot;18&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;作为一个方便的函数，且该子库可以简单地从雅虎财经网站（http://finance.yahoo.com）读取历史股价数据。只需要起始和结束日期，以及对应的股票代码。下面以读取德国DAX指数数据为例，其股票代码为^GDAXI:&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-695da7fc839c0417591bcd93d7d66a1d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;391&quot; data-rawheight=&quot;43&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt; 这里quotes包含了DAX指数的时间序列数据，包括日期、开盘价、最高价、最低价、收盘价和成交量：&lt;/p&gt;&lt;p&gt;matplotlib.finance的绘制函数能准确理解可能传递的格式和数据集，这里每日的正收益由蓝色的矩形表示，负收益由红色矩形表示。而且matplotlib会根据数据集中的日期信息，为x轴正确设置标签：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-13b047387a0f6b21a01bf47ca7762b07_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;436&quot; data-rawheight=&quot;122&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-13b047387a0f6b21a01bf47ca7762b07&quot; data-watermark-src=&quot;v2-6114d807cf085523c901ed33255a5c61&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-77a9070313c5894581c631a41a992a2b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;497&quot; data-rawheight=&quot;291&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-77a9070313c5894581c631a41a992a2b&quot; data-watermark-src=&quot;v2-412a7ee29bd6da9c1981a8ea5ba362d7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;3D图形应用&lt;/b&gt;&lt;/p&gt;&lt;p&gt;  最后一个是在金融中的3D图形应用。金融中从3维可视化中获益的领域不是太大。但是，波动率平面是一个应用领域，它可以同时展示许多到期日和行权价的隐含波动率。下面例子中，我们人为生产一个类似波动率平面的图表。&lt;/p&gt;&lt;p&gt;为此，考虑如下因素：1.行权价格在50-150元之间。2.到期日在0.5-2.5年之间。&lt;/p&gt;&lt;p&gt;这提供了一个2维坐标系。我们可以使用NumPy的meshgrid函数，根据两个1维ndarray对象生成这样的坐标系：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-82061047546933d44a61b4c8d6690643_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;259&quot; data-rawheight=&quot;41&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;上述代码将两个1维数组转换为2维数组，在必要时重复原始坐标轴值：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d801a3ed1404e37bbbd4a238991a0f07_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;72&quot; data-rawheight=&quot;15&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;根据新的ndarray对象，我们通过简单的比例调整二次函数生成模拟的隐含波动率：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-eadacf7dfec781502baedd8a61045c7d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;264&quot; data-rawheight=&quot;16&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;通过下面代码即可得出图表：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9cd2fe9bb36da06639d5d138a01c5358_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;408&quot; data-rawheight=&quot;159&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9cd2fe9bb36da06639d5d138a01c5358&quot; data-watermark-src=&quot;v2-4aaf6c178f9acde092831f86e97e7e21&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-43c8ac31f7f5947685239df7c4216001_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;543&quot; data-rawheight=&quot;308&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-43c8ac31f7f5947685239df7c4216001&quot; data-watermark-src=&quot;v2-6b4279141e50e1e56bca5a5d165150dd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>量化家</author>
<guid isPermaLink="false">2018-07-27-40701499</guid>
<pubDate>Fri, 27 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>量化||趋势</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-07-26-40614397.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40614397&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;一、量化投资是更专业的投资&lt;/b&gt;&lt;/p&gt;&lt;p&gt;投资本身，现在已经变成了一个专业的事情。因为不管什么事情，只要做的人多了，就会向专业的方向发展，而投资无疑就是这么一件事。当一件事情变得更专业，它必然变得更为深入和复杂，这时它就越来越远离大众人群。&lt;/p&gt;&lt;p&gt;这不是说这件事变得和大众越来越没有关系，而是指没有专业训练的人会越来越难以亲自做这件事。&lt;/p&gt;&lt;p&gt;做事的专业性，主要体现在深度和广度上边。而在深度和广度二者中，深度是第一位的，没有深度，就谈不上广度。只有先精于一事，方可涉及其他。投资也是一样。投资的品种有很多，股票、债券、期货、期权、货币、外汇、基金等等，还有更多的组合和衍生品。如果不精于每一个，便无法广泛投资于所有。而精通其中任意一个，都是何等的难事！&lt;/p&gt;&lt;p&gt;量化是专业性最典型的特征，因为量化代表着准确和精确。爱迪生说“天才是1%的灵感加上99%的汗水”，为什么不说是“一点点灵感加上大量的汗水”呢？这就是为了显得更为专业。我们去菜市场买肉，现在不会再接受卖家“信手掂来”的重量，因为我们不相信掂量出来的价格是准确精确的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1、量化就是准确精确，模糊是交易的最大障碍&lt;/b&gt;&lt;/p&gt;&lt;p&gt;从古代埃及人开始，数学就已经开始发展并且占据了重要的位置。人们丈量土地，计算面积，发现了各种图形的面积计算公式。这是最早期的量化之一。没有这些明明白白的计算公式，一块三角形的土地和一块长方形的土地是没办法进行交换的。人们进行各种物物交易，无论重量、体积、价值，都必须对等，所以人们发明了各种量具。&lt;/p&gt;&lt;p&gt;我国秦朝时期统一了全国的度量衡，就是为了使全国有一个统一的量化标准。因为可量化是交易的基础，也是人们交流的基础。&lt;/p&gt;&lt;p&gt;模糊是交易和交流的最大障碍之一。放在资本市场也是一样，如果各种证券合约没有统一量化的交易价格和条款，那整个市场就不可能发展壮大。买卖双方想达成交易，不仅需要在价量上必须要有统一的认识，在标的品质和服务等更多权利责任上必须都要澄清模糊，达到准确清晰。没有任何一个市场是基于模糊信息的交易。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2、精确带来信任，信任推动市场发展&lt;/b&gt;&lt;/p&gt;&lt;p&gt;无论是自然界还是社会学，量化的研究是最核心最根本的研究，是可验证可实践的基础。在物理学，牛顿定律定量地告诉我们外力和质量和加速度的关系。如果这一关系只是模糊的定性研究，我们怎么能用它来制造实用的机械，用它来推动工业革命呢？爱因斯坦如果没有给出质量和能量的准确关系，那我们怎么精确的使用核能呢？&lt;/p&gt;&lt;p&gt;在资本市场也是一样。期权定价从定性交易，到二叉树定价，再到连续模型定价，一步步走向专业，一步步走向量化。而最终期权定价公式的发现，则极大的推动了整个市场的扩张。这正是量化的力量，它给原本不确定的市场注入了确定性的因素，就给市场注入了信心。而基于大家对这一公式的信心，参与者就会变多，成交就会放大，而这一量化公式也会进一步得到印证和加强。现在这一公式已经成为期权交易的基础，而不可能是其他定性的研究。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3、投资需要精确，经验需要量化&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在资本市场中投资，我们投资的各种品种，无论股票、债券、期货，我们买卖的无一不是其数字化的价格，而我们的投资业绩，我们的收益率和风险波动，也都是数字化的结果。即使对于上市公司而言，其销量业绩都是数字，其最终股价也是数字。我们不可能忽略这些量化的数字结果，定性摸黑地去经营公司或者进行投资。&lt;/p&gt;&lt;p&gt;虽然资本市场价格具有很大的不确定性，很难完全加以量化，但是我们不能因此而放弃对量化准确性的追求。&lt;/p&gt;&lt;p&gt;例如，我们定性的感觉到如果行业间涨跌过于无序混乱则股市可能见顶，这时我们就可能发现了一个规律。如果我们追求准确，就需要把这一规律进行量化。我们的第一步就是要准确的定义涨跌无序和股市见顶，第二步择时观察和验证二者之间有没有相关关系，只要保证有较高的胜率，我们就以后就可以定量的使用这一规律，而无需仅仅依靠直觉进行模糊的判断。&lt;/p&gt;&lt;p&gt;&lt;b&gt;4、投资需要理性，量化坚定信念&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们知道作为一个合格的专业投资者，保持理性是非常核心的品质。这是因为股市的波动很大，趋势可能延续，也可能随时反转。股市的规律一般都不稳定，即使我们发现的规律每一次都会准确，但是每一次发生的时候其情况都会有所不同，可能时间点不同，可能维持的时间段长度不同，可能力度大小不同。虽然每一次过后我们发现规律仍然成立，但是对当下和未来的不确定性我们仍然充满了担心和恐惧。&lt;/p&gt;&lt;p&gt;人们的感性情绪引起的不理性投资行为非常普遍，比如人们对沉没成本的考虑，着眼于已有盈亏而不是为了走势等等。没有人可以像电脑程序一样固定的运行，我们的投资行为总会随着市场的变化而受影响。所以如果没有一条准绳，那么我们的投资行为将会飘忽不定，充满感性，这无疑会对我们的投资造成不利影响。&lt;/p&gt;&lt;p&gt;我们定量的对人们的情绪进行测量，构建了“舆情指标”。我们发现，人们的情绪波动和股市的波动息息相关，同步性非常强。当股市向好时，人们的情绪就逐渐高涨，同时当股市到高点是，人们的情绪也达到了最高涨；同样在股市低点时，投资者也是最为悲观的时候。如此可见情绪本身并不是理性的，如果我们按照自身的情绪去投资，我们就会在最高点买入，而在最低点卖出，造成重大失误。所以很多理性的投资者会“逆市”操作，在其他人贪婪的时候恐惧，在其他人恐惧的时候贪婪。&lt;/p&gt;&lt;p&gt;量化我们的发现的投资规律就给了我们一条看得见的准绳，他让我们在暴风骤雨的茫茫大海中有一个抓手。能做到时刻保持理性，不是单靠信念的，需要一定的方法了措施，这其中量化我们的规律就可以加强我们的信念，让我们更能保持理性。经过量化的规律，会给我们更多的信心。这不仅仅是因为单纯的数字让我们踏实，而是因为我们的到这些数字的背后，是经过了大量的统计和研究，得出来的大概率事件。它是一个“锚”，可以帮助我们稳定情绪，不让它偏离太远。让投资者做到“众人皆醉我独醒”，时刻保持理性。&lt;/p&gt;&lt;p&gt;&lt;b&gt;二、量化产品将占有主要份额&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1、量化产品没有严格定义&lt;/b&gt;&lt;/p&gt;&lt;p&gt;量化产品和其他产品的区别，是使用了较多的量化方法，而使用了较少的定性方法。但是这一说法显然没有严格的定义。在目前而言，绝对多数的量化产品基本上是使用“纯量化”方法的，而不使用“定性”的信息。这里的“定性”信息，主要包含以下几种：①新闻资讯，政策信息等非数据类公众信息；②各券商、基金、保险、私募等研究员调研获得的公司、行业、宏观经济等信息（此类信息只在特定人群传播）；③基于以上信息得出的定性结果和判断。&lt;/p&gt;&lt;p&gt;目前量化产品所使用的信息，绝大多数属于完全量化的资料，它们大多自于类似万得资讯、彭博社等数据提供商提供的整理得很整齐的数据库，其数据主要包含以下几种：①各品种的交易行情等数据；②宏观经济、各行业、各上市公司的基本面信息数据（例如行业产销量、公司财务数据、研究员定量预测信息等）；③数据提供商整理的其他数据。&lt;/p&gt;&lt;p&gt;这些量化的数据已经涵盖了金融资讯的很大一部分，尤其是历史信息。实际上，不仅仅是量化人员，不被称为量化人员的各宏观策略研究员和行业研究员，也在大量的使用这些纯数据姓信息来辅助形成自己的判断，他们也会用到量化的方法。所以从这一点来讲，量化和非量化也没有本质的区别。&lt;/p&gt;&lt;p&gt;另外，量化产品基本不使用定性的研究结果，但是这并不代表它们完全不采用定性研究的逻辑。各种投资方法的逻辑和规律很多时候是殊途同归的，量化的产品尽可能的将这些规律予以量化，那些不能或不易被量化的规律，量化产品就无法采用。也就是说，量化产品放弃了那些难以量化的规律，但加强了对可量化的投资规律的应用，这一点肯定有利有弊。一般而言，那些难以量化的定性投资方法，他们是部分投资者的想法，或者拥有较高的收益，或者拥有很大的风险。使用这些投资方法，有可能造成投资结果差别很大。而可量化的投资规律，大多数表现较为稳定，但不一定有很高的收益。&lt;/p&gt;&lt;p&gt;由于国内传统的定性研究仍占主流位置，所以目前的量化产品和非量化产品还有比较大的区别。但是我们相信随着时间的推移，二者将会互相渗透。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2、目前的量化产品分类&lt;/b&gt;&lt;/p&gt;&lt;p&gt;目前的量化产品一般分为三大类，一类是被动型指数产品，另一类是主动量化产品，第三类是介于二者之间的增强型指数产品。对于被动型指数产品，它主要是以被动完全复制指数为主，一般不需要太多的定性研究，需要的主要是一些投资技术来减小跟踪误差，而这些技术都属于量化方法的范畴。主动量化型产品是使用量化方法进行投资的基金，其竞争产品是占主导的各主动型基金。指数增强型基金则以战胜指数为其目标，使用的方法大多是纯量化的方法，也有一些增强型产品使用的是传统定性投资的方法。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）被动型指数产品&lt;/b&gt;&lt;/p&gt;&lt;p&gt;从海外的情况来看，被动型产品逐渐替代了主动基金，成为了市场的主流。而国内市场也正在进行这一趋势。&lt;/p&gt;&lt;p&gt;国内指数型产品在股票型基金和混合型基金中的占比，从2006 年的4.2%，迅速上升到目前的24.7%。&lt;/p&gt;&lt;p&gt;指数型产品之所以会越来越盛行，原因主要有以下几点。&lt;/p&gt;&lt;p&gt;（1）主动型基金未必可以跑赢指数，选基成本高。不管国外的研究还是国内的研究，都发现有很大比例的（很多年份超过一半，尤其是大盘上涨的年份）主动基金是跑不赢指数的。&lt;/p&gt;&lt;p&gt;从2005 年以来的9 年中，沪深300 指数有4 年上涨，在这4 年中，多数的基金都跑输了沪深300；而在另外5 年大盘下跌的年份中，多数基金跑赢了沪深300。另外，最近3 年连续跑赢沪深300 的基金只占20%，而最近5年连续跑赢沪深300 的只有1.2%（4 只）。鉴于很大比例的基金很难跑赢指数，而且单只基金的表现年年不同，这大大增加了基民的选基成本，所以很多基民选择直接购买指数基金。&lt;/p&gt;&lt;p&gt;（2）标的指数的多样化。根据万得资讯截至11 月25 日的数据，目前市场上纯被动股票指数基金有207 只（不含海外指数，含ETF 联接基金），占股票型基金加混合型基金总数的23.3%（份额占24.7%如图3），它们跟踪了93 个指数。这当中有36 个宽基指数、29 个主题指数、15 个风格指数和13 个行业指数，它们已经涵盖了从大盘到热门行业主题。而且，图5 显示指数的只数在迅速的增加，而且覆盖范围越来越多。所以无论是何种行情之下，都会有表现很好的指数，投资者时时刻刻总可以找到好的指数基金去投资。而未来指数的覆盖范围必将迅速扩大，海外成熟市场的指数数量都远多于股票的数量，而我国目前还有很大空间。另外，指数本身的创新也将会带领指数&lt;/p&gt;&lt;p&gt;基金进入新的时代，将来股票多空指数、130/30 类指数（部分多空）等将会扩充新的股票指数类型。而未来海外市场、债券、货币、商品、外汇和混合类指数的编制都会逐渐完善。希望投资于这些非股票资产但对这些方面不是很了解的投资者就可以直接购买相关的指数产品。&lt;/p&gt;&lt;p&gt;（3）指数基金的产品形式多样。指数基金由于成份股公开透明，所以非常容易做产品方面的设计。①普通封基、②普通开基、③ETF、④LOF、⑤分级基金都可以是指数基金。在207 只股票型被动指数基金中，有72 只ETF，40 只分级基金母基金。而且像ETF 和分级基金，基本上是被动型产品的天下。指数基金类型的多样，方便投资者进行各种套利操作。这样不仅使得基金的净值稳定不偏离，而且还会增大基金的交易量和份额（在份额排名前10的股票型基金中，指数基金占了一半）。除了上述品种，目前申报火热的⑥多空分级基金和⑦多空杠杆ETF 也都是被动指数产品，未来被动产品的类型会越来越丰富。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）增强型指数产品&lt;/b&gt;&lt;/p&gt;&lt;p&gt;目前的增强型指数基金并不是很多，全市场有35 只股票型指数增强基金，其中有13 只以沪深300 为增强标的。指数增强基金的业绩总体而言和其基准指数相差不是很大，整体跑赢基准的概率也保持在50%左右。但是相比图4 就可以看出来，指数增强基金的业绩非常稳健，业绩情况不存在随行情大幅的波动。而且，就最近3 年的情况来看，增强基金平均每年跑赢基准6.1‰，年度跑赢最多的为14.6%，跑输最多的为9.4%，幅度都不是很大。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（3）更多的创新指数产品类型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;指数产品除了单一的指数基金（含ETF、LOF）外，还演化出多种多样的产品形式。目前最主要的形式是分级基金，其中A 级为约定的固定收益产品，B 级为有杠杆的股票性基金，分别满足不同投资者的需求。目前，正在火热申请的还有多空分级指数基金、多空分级货币基金和多空杠杆ETF 等3 种多空产品。这必将又带动新一波的指数基金热潮。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（4）主动量化产品&lt;/b&gt;&lt;/p&gt;&lt;p&gt;目前市场上的主动量化基金有20 只，其中多数为股票型基金。而今年新发行的几只较为创新的量化基金，都是混合型基金，股票的仓位上下限很高，可以更灵活的配置，而且都以追求绝对收益为目标。&lt;/p&gt;&lt;p&gt;除此之外，嘉实基金今年还发行了一只名为“嘉实绝对收益策略”的对冲基金（未包含图9 在统计范围内），该基金采用完全对冲策略，使用股指期货对冲现货股票的系统性风险，将股票相对于大盘的绝对收益转化为绝对收益，该基金对冲部分的使用了量化策略。我们相信以后会有更多的类似基金出来。&lt;/p&gt;&lt;p&gt;主动量化产品在风险控制方面有较大的优势，但是其收益未必显著高于定性投资基金。在相对收益制度下，量化基金并没有什么优势，但是随着绝对收益和对冲基金时代的来临，风险控制会变得越来越重要，更多的使用了量化操作的基金在收益的平稳性上会表现更好，更容易抓住绝对收益投资者。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（5）量化产品的发展方向&lt;/b&gt;&lt;/p&gt;&lt;p&gt;量化产品将在广度和深度方向迅速衍生发展，它会向覆盖全面、杠杆化、多空双向、T+0，非线性（期权）等多方面发展，而且这些特点都是我们短期能看到的发展。指数产品会逐渐覆盖全面，在工具性上，会逐渐杠杆化，而且马上会出现多空双向，以及允许T+0 交易。&lt;/p&gt;&lt;p&gt;而主动量化产品，将会在绝对收益上发力，凭借更强的风控能力获得投资者的青睐，而且通过杠杆化可以提高收益。而期权等更复杂的非线性产品将会越来越多被量化产品所使用，对于风险控制和提高收益都会有促进作用。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3、量化产品和方法会越来越占主导&lt;/b&gt;&lt;/p&gt;&lt;p&gt;量化产品从无到有，发展非常迅速。我们相信未来量化产品的占比会越来越高。指数产品的发展我们已经无须赘述，指数数量、覆盖广度必将迅速发展。这将推动投资者细分领域资产配置的需要。主动量化技术和产品，也必将获得越来越广泛的发展和使用。这其中至少有以下原因。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）可量化的资讯和规律会越来越多&lt;/b&gt;&lt;/p&gt;&lt;p&gt;人们最初做投资所仰赖的是①各种市场资讯以及②对资讯的正确理解处理能力。这两点，无疑都是可以通过量化方法进行处理的。&lt;/p&gt;&lt;p&gt;目前市场上的金融数据提供商越来越多，向万得资讯这样的主流公司，通过现代科技和统计手段，可以将越来越多的资讯纳入到数据库中来，每年增加7%左右的资讯新品种，这样每10 年可统计的资讯品种数量就可以翻倍。&lt;/p&gt;&lt;p&gt;现在大量的资讯来自于网络，而一个非常现实的事情是，网站背后的核心都是一个庞大的数据库。无论是新闻、聊天、博客、微博、商品、音乐、视频，其背后都是一个数据库。在数据库中，每一条数据的存储结构都是一样的。&lt;/p&gt;&lt;p&gt;以后随着物联网和大数据云计算的发展，我们相信会有很多我们想象不到的东西可以纳入量化的统计之中。这一切不仅包含我们日常生活的信息，还会有国家宏观的统计信息，这一切，都可以为投资提供参考。&lt;/p&gt;&lt;p&gt;而对资讯的处理能力，毫无疑问，量化的方法也会越来越有利。随着各种有效的投资规律逐渐被大家认识和掌握，这些规律必将很快被量化，并包含到量化产品中去，而且还会不断的完善修正。我们目前正在经历的一个现实就是，各家基金公司、券商、保险、私募量化部门的人手都越来越多，从几个到几十个不等。这在10 年前是不可想象的，即使和5 年前相比都有很大的差距。像现在券商，研究部、衍生品部、资管部、自营部、甚至营业部等都有人手在做量化方面的研究和投资。很多券商的自营部门已经把量化和传统投资并列为同等的两块，在逐渐削弱原来的定性投资力量，我觉得这是一个非常明显的信号。人力和物力投下去，未来量化的研究必然会有很大的发展。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）衍生品市场的兴起和产品数量的扩大&lt;/b&gt;&lt;/p&gt;&lt;p&gt;仰赖人脑的定性计算，其机械能力是有限的，所以很难在计算的深度和广度上战胜电脑。而①衍生品市场的兴起和②交易产品数量的扩大，这两者必然在计算的复杂性（深度）和重复计算量（广度）上对人脑产生巨大的挑战。&lt;/p&gt;&lt;p&gt;如果不借助量化的手法，就很难理清它们的规律。&lt;/p&gt;&lt;p&gt;实际上，目前股指期货和国债期货，都是比较简单的衍生品种，其价格和现货价格走势非常相近。但是随着不久之后期权的推出，单靠人脑已经不可能给出期权的参考价格了。而且，就沪深300 股指期货来说，目前仿真推出的合约就有62 种，以后还可能会进一步增加，如果再加上将来的个股期权，数量将会极其庞大。由于每只期权有不同的参数条款，而且会滚动发行，我估计大部分的传统基金经理一看就头大了。这时候要想保持理性，必须得使用量化的方法。还有一点，衍生品市场的繁荣是不可避免的事情。国外的期权市场和期货市场都是比股票市场大的市场，未来几年在中国肯定也是如此。而且，未来的新产品如果不参与期权期货，必然没有竞争优势，而要参与，必然要大量的使用量化的方法。&lt;/p&gt;&lt;p&gt;不光衍生品市场，未来股票、债券、商品，甚至外汇的品种都会越来越多。一个基金经理不可能兼顾所有品种，而对于不太熟悉的投资品种，或者采用被动配置的策略，或者采用量化抓主要规律的办法。另外，多品种之间的投资仓位和操作平衡互动，都需要从整体角度出发进行量化。&lt;/p&gt;&lt;p&gt;&lt;b&gt;三、大众理财将带动量化投资大发展&lt;/b&gt;&lt;/p&gt;&lt;p&gt;随着这几年银行理财产品和今年余额宝的爆发，大众理财市场逐渐成为各资管机构争夺的主要战场。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1、大众理财带动资产管理走向以客户为中心&lt;/b&gt;&lt;/p&gt;&lt;p&gt;大众理财市场的兴起，会给整个资管行业带来本质的变化。那就是，资产管理将从原来按技术划分转变为按客户群划分。按技术分类是从自我出发，而按客户群划分，是从客户出发。这一理念的转换，是从卖方市场到买方市场的转变，表明行业的成熟。&lt;/p&gt;&lt;p&gt;我们现在的基金产品，主流的划分方式是按照投资品种划分，股票型、债券型、货币型、混合型。这个是从资产管理者角度出发的，是按照投资技术划分的。对于投资者（老百姓）而言，不论是那一类，只要能赚钱就行。市场成熟之后，技术的区别将不在成为核心的竞争力，业绩、产品设计和营销将成为胜出的关键。&lt;/p&gt;&lt;p&gt;未来客户的划分，将不在拘泥于投资标的是股票还是债券，而是按照客户的风险收益偏好进行分类。这其中，又会主要分为绝对收益大类和资产配置大类。货币、债券、信托、保本基金等都属于绝对收益大类的投资范畴，股票对冲、期货CTA 等也属于绝对收益；目前基本上所有的股票型、混合型基金都属于股票市场资产配置型产品，以后会有更对的期货类、外汇类的配置型基金上市。对于资产配置型基金，虽然基金经理努力的提高投资业绩，但是其走势肯定摆脱不了市场系统风险的影响。人们如果某段时间不想投资于股票市场，股票类基金的配置作用就会降低，大众会转向绝对收益或者其他大类的资产。而在资产配置中，指数基金会是最主要的选择。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2、大众理财以绝对收益为主导&lt;/b&gt;&lt;/p&gt;&lt;p&gt;老百姓喜欢绝对收益，所以最近几年银行理财产品和债券货币类产品非常畅销，而股票型产品很难卖。很明显，最大的原因就是股票型产品很可能赚不了钱，即使一时赚了钱，老百姓也担心会亏回去。所以，现在不保收益的产品比较难卖。&lt;/p&gt;&lt;p&gt;投资股票也做绝对收益，但是必须剥离掉大盘风险。为了控制下跌风险，必须做到在大盘下跌时不能下跌。可以用对冲，也可以用风控较好的单边投机策略。无论哪种策略，投资理念都要转换，不能像纯做多一样扛，而且要加入定量化的精确控制。&lt;/p&gt;&lt;p&gt;绝对收益，不等于固定收益，其范围比固定收益大。保本基金也属于绝对收益类产品，对冲套利基金也属于绝对收益类产品。绝对收益产品追求的是年化正收益，而不像目前普通股票型基金一样，希望可以战胜沪深300。因为希望取得正收益，所以这类产品希望在期限内的时时刻刻可以保持有正的收益，这样是投资者最希望看到的。这就对该类产品的下跌风险控制（回撤）提出了很高的要求。这就要求投资的精准性，可以根据行情做出细微调整。&lt;/p&gt;&lt;p&gt;同时，由于单一投资策略很容易会因为行情的变化导致不稳定，为避免回撤较大，一般都需要多策略配合使用。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3、不同的投资者细分市场，风险管理重要性提升&lt;/b&gt;&lt;/p&gt;&lt;p&gt;投资者总体是按照风险偏好程度划分的，可见风险控制重要性不低于收益的高低。而风险本身的衡量，是比收益更复杂的事。常见的风险度量是收益的二次项，如果按照VaR 来计算，风险的计算就更加复杂。&lt;/p&gt;&lt;p&gt;同样的投资策略，经过产品的设计改造之后，其风险收益可能适用于不同的投资者。而在产品管理的过程中，风控可能会成为产品运行的底线，所以必须加强对于风险的控制，以满足投资者的要求。风控的管理一般是一个量化的过程。&lt;/p&gt;&lt;p&gt;&lt;b&gt;4、大资管时代要求投资范围、投资策略扩大&lt;/b&gt;&lt;/p&gt;&lt;p&gt;既然市场转向以大众为中心的买方市场，各种投资品种和技术就不再成为操作的限制。为了达到绝对收益的目标，多种品种——股票、债券、期货、期权、甚至外汇——都有可能成为投资的标的。“专、精”很重要，“博、广”也必不可少。同时因为当单品种单策略失效时，我们需要有其他的投资策略予以弥补。&lt;/p&gt;&lt;p&gt;当然，由于投资经理很难将多策略和多品种完全掌握和照顾到，一般会偏重某一（某些）策略或产品，其他策略可以通过量化的方式予以监控。我们目前很多有效的相对投资策略，比如定向增发策略，通过一定的策略延伸和配合，可以转化为绝对收益策略，这属于产品设计的范畴，也需要量化的方法。&lt;/p&gt;</description>
<author>量化家</author>
<guid isPermaLink="false">2018-07-26-40614397</guid>
<pubDate>Thu, 26 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>1.5 量化技术篇—使用zipline回测</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-07-25-40565731.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40565731&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;------从零开始学量化------&lt;/b&gt;&lt;br&gt;&lt;b&gt;简书&lt;/b&gt;：&lt;a href=&quot;https://www.jianshu.com/p/2c34aee64649&quot;&gt;量化目录传送门&lt;/a&gt;&lt;br&gt;&lt;b&gt;知乎&lt;/b&gt;：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38656100&quot;&gt;量化目录传送门&lt;/a&gt; &lt;/p&gt;&lt;hr&gt;&lt;h2&gt;0. 前言&lt;/h2&gt;&lt;p&gt;在1.4中，我们实现了一个简单的量化择时策略，那么该策略到底效果如何呢？我们该使用什么开源框架，使用历史数据回测策略呢？我们又该用那些指标评价一个策略？&lt;/p&gt;&lt;p&gt;本篇的内容就是回答以上的问题的，下面给一个简要的答案：  &lt;/p&gt;&lt;p&gt;&lt;b&gt;回测的开源框架&lt;/b&gt;：&lt;b&gt;zipline&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;策略的评价指标&lt;/b&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;累计收益&lt;/li&gt;&lt;li&gt;年化收益&lt;/li&gt;&lt;li&gt;最大回撤&lt;/li&gt;&lt;li&gt;夏普比率&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为什么选择zipline？主要由以下几点原因：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在quant的框架中star数最多，版本更新和维护比较快。&lt;/li&gt;&lt;li&gt;社区生态比较好，出现问题，google容易找到解决方案。&lt;/li&gt;&lt;li&gt;该框架在国外已经比较成熟，坑少。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;1. 策略的回测结果&lt;/h2&gt;&lt;h2&gt;1.1 策略的回测指标&lt;/h2&gt;&lt;p&gt;年化收益率 = 8.34%&lt;br&gt;&lt;br&gt;累计收益率 = 17.37%&lt;br&gt;&lt;br&gt;最大回撤 = -16.14%&lt;br&gt;&lt;br&gt;夏普比率 = 0.62  &lt;/p&gt;&lt;h2&gt;1.2 策略的收益图&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9fc26cb0d26a6f7a4e2ff158d7e19ea9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;480&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9fc26cb0d26a6f7a4e2ff158d7e19ea9&quot; data-watermark-src=&quot;v2-84d37accd772d5c13a4cbd590c0f3ac1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;1.3 回测的环境&lt;/h2&gt;&lt;p&gt;量化框架：zipline（version = 1.3.0）&lt;/p&gt;&lt;h2&gt;1.4 策略追踪的股票和benchmark&lt;/h2&gt;&lt;p&gt;追踪的股票：个股选择了苹果（AAPL）&lt;br&gt;&lt;br&gt;benchmark：美国标普500（SPX）的指数&lt;br&gt;&lt;br&gt;策略时间： 2015-01-01 ~ 2017-01-01  &lt;/p&gt;&lt;h2&gt;1.5 择时策略描述&lt;/h2&gt;&lt;p&gt;买入： 当cci &amp;gt;= 50&lt;br&gt;&lt;br&gt;卖出：当cci &amp;lt; 50&lt;/p&gt;&lt;h2&gt;2. zipline回测前的准备&lt;/h2&gt;&lt;p&gt;在开始回测之前，zipline首先需要下载数据包（data bundle）。由于在1.2篇——环境安装中已经说明了zipline的安装方式,如果还有问题可以查看&lt;a href=&quot;https://github.com/quantopian/zipline#installation&quot;&gt;zipline github installation&lt;/a&gt;。下面假设大家已经使用anaconda安装好了zipline（我的zipline的版本是1.3.0）。&lt;/p&gt;&lt;p&gt;zipline安装完毕后，可以打开命令行，输入命令查询zipline目前支持的数据包，具体可以参考&lt;a href=&quot;https://blog.csdn.net/qq_39377696/article/details/80414711&quot;&gt;Zipline Data Bundles&lt;/a&gt;，输入的命令如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;# 命令行中输入查询数据包的命令
zipline bundles

# 返回的结果
csvdir &amp;lt;no ingestions&amp;gt;
quandl &amp;lt;no ingestions&amp;gt;
quantopian-quandl &amp;lt;no ingestions&amp;gt;&lt;/code&gt;&lt;p&gt;从命令行中可以看到，zipline中没有载入任何数据包。然后我们开始下载数据包，具体可以参考&lt;a href=&quot;https://blog.ihanai.com/2018/04/08/install-and-config-zipline/&quot;&gt;Zipline 的安装配置&lt;/a&gt;。下载数据包主要分为两步：&lt;/p&gt;&lt;p&gt;&lt;b&gt;第一步&lt;/b&gt;：登录&lt;a href=&quot;https://www.quandl.com/account/api&quot;&gt;quandl&lt;/a&gt;官网，进行注册，获得api key。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第二部&lt;/b&gt;：设置api key，并下载数据包，具体命令如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;# 设置quandl的api key
set QUANDL_API_KEY=your_key

# 下载数据包
zipline ingest -b quandl

# 查询数据包
 zipline bundles
# 返回
csvdir &amp;lt;no ingestions&amp;gt;
quandl 2018-07-23 09:34:37.144466
quandl 2018-07-23 09:28:37.817531
quantopian-quandl &amp;lt;no ingestions&amp;gt;&lt;/code&gt;&lt;p&gt;当zipline bundles 返回的quandl中出现上面的返回，说明数据下载成功。&lt;/p&gt;&lt;h2&gt;3. 策略代码&lt;/h2&gt;&lt;code lang=&quot;text&quot;&gt;from datetime import datetime

import matplotlib.pyplot as plt
import pytz
import seaborn as sns
import talib as ta
from empyrical import cum_returns, annual_return, sharpe_ratio, max_drawdown
from matplotlib.dates import DateFormatter
from zipline import run_algorithm
from zipline.api import symbol, order, record
from zipline.finance import commission, slippage


def initialize(context):
    # 记录股票代码，通过股票代码获取股票对象
    context.asset = symbol(&#39;AAPL&#39;)

    # 定义是否买入股票的标记
    context.invested = False

    # 设置交易的手续费，股票成交时，手续费按成交金额一定比例收取
    # 设置手续费率和最低费用
    context.set_commission(commission.PerShare(cost=.0075, min_trade_cost=1.0))

    # 设置模拟真实交易的滑价，当实际下单交易时，下单订单将影响市场。买单驱使价格上涨，卖单驱使价格下滑;
    # 这通常被称为交易的“价格影响”。价格影响的大小取决于订单与当前交易量相比有多大。
    context.set_slippage(slippage.VolumeShareSlippage(volume_limit=0.025, price_impact=0.1))


def handle_data(context, data):
    # 获取历史股票数据
    # context.asset表示股票列表
    # fields – 历史数据项或集合，项可以为’close’, ‘open’, ‘high’, ‘low’, ‘price’
    # bar_count – 获取多少单位时间
    # frequency – 可以取值‘1m’ 或 ‘1d’。 ‘1m’表示分钟单位, ‘1d’表示日单位, 现在只支持日单位
    trailing_window = data.history(context.asset, [&#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;open&#39;], 40, &#39;1d&#39;)

    # 数据为空则返回
    if trailing_window.isnull().values.any():
    return

    # 计算cci指标
    cci = ta.CCI(trailing_window[&#39;high&#39;].values, trailing_window[&#39;low&#39;].values, trailing_window[&#39;close&#39;].values,
    timeperiod=14)

    # 定义买入和卖出的标志位
    buy = False
    sell = False

    if (cci[-1] &amp;gt;= 50) and not context.invested:
    # 买卖股票，按股票数量生成订单，amount为负，表示做空。
    # 参数:
    # asset – 股票
    # amount – 交易数量, 正数表示买入, 负数表示卖出
    # style –（可选参数）指定下单类型，默认为市价单，可用的下单类型如下：
    #   style=MarketOrder()，下市价单
    #   style=StopOrder(stop_price)，下止损单，通常用来止损或者锁定利润
    #   style=LimitOrder(limit_price)，下限价单，限定一个价格买入或卖出
    #   style=StopLimitOrder(limit_price=price1, stop_price=price2)，指定限价和止损价格
    order(context.asset, 100)
    # 设置买入
    context.invested = True
    buy = True
    elif (cci[-1] &amp;lt; 50) and context.invested:
    order(context.asset, -100)
    context.invested = False
    sell = True

    # 记录函数，在交易执行时记录用户自定义数据，该数据存放在回测输出结果中
    record(open=data.current(context.asset, &quot;open&quot;),
        high=data.current(context.asset, &quot;high&quot;),
        low=data.current(context.asset, &quot;low&quot;),
        close=data.current(context.asset, &quot;close&quot;),
        cci=cci[-1],
        buy=buy,
        sell=sell)


# 定义分析回测效果的函数
def analyze(context=None, results=None):
    pass


def draw_return_rate_line(result):
    sns.set_style(&#39;darkgrid&#39;)
    sns.set_context(&#39;notebook&#39;)
    ax = plt.axes()
    # 设置时间显示格式
    years_fmt = DateFormatter(&#39;%Y-%m-%d&#39;)
    ax.xaxis.set_major_formatter(years_fmt)
    # 让x轴坐标旋转45度
    labels = ax.get_xticklabels()
    plt.setp(labels, rotation=35, horizontalalignment=&#39;right&#39;)
    # 画出收益率曲线
    sns.lineplot(x=&#39;period_close&#39;,
    y=&#39;algorithm_period_return&#39;,
    data=result,
    label=&quot;AAPL&quot;)
    sns.lineplot(x=&#39;period_close&#39;,
        y=&#39;benchmark_period_return&#39;,
        data=result, label=&quot;SPX&quot;)

    plt.legend(loc=&#39;upper left&#39;)
    plt.title(&quot;return rate of AAPL and SPX&quot;)
    plt.xlabel(&#39;time&#39;)
    plt.ylabel(&#39;return rate&#39;)
    plt.show()


if __name__ == &#39;__main__&#39;:
    capital_base = 10000
    start = datetime(2015, 1, 1, 0, 0, 0, 0, pytz.utc)
    end = datetime(2017, 1, 1, 0, 0, 0, 0, pytz.utc)

    # 运行算法
    result = run_algorithm(start=start, end=end, initialize=initialize,
        capital_base=capital_base, handle_data=handle_data,
        bundle=&#39;quandl&#39;, analyze=analyze)

    # 画出收益曲线图
    draw_return_rate_line(result)

    return_list = result[&#39;returns&#39;]

    # 计算年化收益率
    ann_return = annual_return(return_list)

    # 计算累计收益率
    cum_return_list = cum_returns(return_list)

    # 计算sharp ratio
    sharp = sharpe_ratio(return_list)

    # 最大回撤
    max_drawdown_ratio = max_drawdown(return_list)

    print(&quot;年化收益率 = {:.2%}, 累计收益率 = {:.2%}, 最大回撤 = {:.2%}, 夏普比率 = {:.2f} &quot;.format
        (ann_return, cum_return_list[-1], max_drawdown_ratio, sharp))&lt;/code&gt;&lt;hr&gt;&lt;p&gt;如果你对我的文章有兴趣，可以关注一下我的简书和知乎，后期会在简书和知乎上定期更新，传送门在下方：&lt;br&gt;&lt;b&gt;简书&lt;/b&gt;：&lt;a href=&quot;https://www.jianshu.com/u/d436b7e60253&quot;&gt;潇潇夜雨归何处&lt;/a&gt;&lt;br&gt;&lt;b&gt;知乎&lt;/b&gt;：&lt;a href=&quot;https://www.zhihu.com/people/edwardzhang0630/activities&quot;&gt;潇潇夜雨&lt;/a&gt;&lt;br&gt;&lt;br&gt;我相信，有趣的灵魂总会相遇！！！&lt;br&gt;&lt;br&gt;你的关注，是我前进的动力！！！&lt;/p&gt;</description>
<author>潇潇夜雨</author>
<guid isPermaLink="false">2018-07-25-40565731</guid>
<pubDate>Wed, 25 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>策略||模型校正</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-07-25-40528417.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40528417&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;斯蒂文管理着一个交易组合包含着各种资产类 (asset class) 的金融产品。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;老板：有一百万欧元，欧元对美元 (EURUSD) 可能会涨，3 个月后 锁定一个汇率换成美元&lt;/p&gt;&lt;p&gt;斯蒂文：买 EURUSD 看涨期权 (call option)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;老板：美元三个月同业拆放利率 (USD Libor3M) 可能会降，1 年后 锁定一个利率赚利差&lt;/p&gt;&lt;p&gt;斯蒂文：买 USD 利率下限 (IR floor)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;老板：咖啡价格 3 个月可能会涨，抓住它的平均涨幅&lt;/p&gt;&lt;p&gt;斯蒂文：买咖啡亚式固定行权看涨期权(Asian fixed strike calloption)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;老板：通用汽车 (GM) 在 1 年内可能会涨，但是一旦超过 38 就不 会跌破 30&lt;/p&gt;&lt;p&gt;斯蒂文；买 GM 向上敲出障碍看跌期权 (up-and-out put option)， 障碍价位 38，行权价为 30。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;要买这么多金融衍生品，以什么价格买?这可不是简单的折现现金流(discounted cash flow) 就可以算出来，都需要对其原生资产 (underlying asset) 价格进行建模。原因很简单，衍生品的价值是原生资产价格的函数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;• 外汇看涨期权的价值是汇率价格的函数 &lt;/p&gt;&lt;p&gt;• 利率下限的价值是利率价格的函数&lt;/p&gt;&lt;p&gt;• 商品亚式期权的价值是商品价格的函数 &lt;/p&gt;&lt;p&gt;• 股权障碍期权的价值是股票价格的函数&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;但是产品定价 (instrument pricing) 易，模型校正 (model calibration) 难， 因为&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;• 定价是个正问题，给定模型参数算出产品价格&lt;/p&gt;&lt;p&gt;• 校正是个反问题，给定产品价格反推模型参数 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;为了让大家保持兴趣，现在来看看两个最简单的定价和校正：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;定价问题是1 + 2 = 3，把加法看成是个“模型”，那么与之对应的校正问题就是 1 加上多少等于 3，校正 (用减法3 - 1) 出来的结果是2。&lt;/li&gt;&lt;li&gt;定价问题是sin(π/6) = 0.5，把正弦函数看成是个“模型”，那么与之对应的校正问题就是sin多少等于0.5，校正 (用反正弦argsin(0.5)) 出来的结果是π/6 。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;虽然上面两例“校正”不难，但也比“定价”难吧。在量化金融中，用复杂模型的定价问题已经不易，那么相对应的校正问题更加困难，如：&lt;/p&gt;&lt;p&gt;定价问题是BS(σ) = 1美元，把BS看成是个模型，那么与之对应的校正问题就是多少波动率σ带入BS公式里得到期权价值1美元。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;本推文就为大家展示各种资产类的常见模型的模型校正！里面画的图全是基于真实的市场数据，而作者也有一套系统的程序来实现各种模型校正。&lt;b&gt;出于里面有些技巧是公司或客户的私有财产和作者多年以来的心血，作者还是不发整套代码怕担当法律责任，但是有问必答！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;前戏王&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;0.1 模型参数形式&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在金融模型中，时间 t 是个很重要的变量，而模型参数 c 通常认为和 t 有 关，写作 c(t)。在建模时，将 c(t) 的整个函数形式完全描述出来不容易也 不实际，通常把 c(t) 看成是常数形式和分段常数形式，如下图: &lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ecb5b856aebdd09cb131ab0735166c03_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;438&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ecb5b856aebdd09cb131ab0735166c03&quot; data-watermark-src=&quot;v2-b0e9518b7ca1f872c5e0669db743e37b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;给定时间结构 t0 &amp;lt; t1 &amp;lt; ... &amp;lt; ti-1 &amp;lt; ... &amp;lt; tn，常数和分段常数的表达形式如下表所示 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3662d2ac0bc65897eff7d5970c8ade8d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;582&quot; data-rawheight=&quot;186&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-3662d2ac0bc65897eff7d5970c8ade8d&quot; data-watermark-src=&quot;v2-81e4fdbd5463723dd87c7168de5010a8&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;0.2 随机微分方程&lt;/b&gt;&lt;/p&gt;&lt;p&gt;随机微分方程 (SDE) 就是常微分方程 (ODE) 加个随机过程。在各种金融 衍生品模型中，其对应的原生资产都能用 SDE 来描述。比如股票类Black-Scholes 模型，利率类 Hull-White 模型，商品类 Schwartz 模型和外 汇类 Heston 模型相对应的 SDE 如下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f76f848fb70a024f1bf043cb42c55d23_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;336&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f76f848fb70a024f1bf043cb42c55d23&quot; data-watermark-src=&quot;v2-c965afb51a3f170f92887f801bda0511&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们可以不严谨把 SDE 当成模型，而里面红色项就是模型参数，这些参数都不是随意给定，而是从金融市场中“校正”出来的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;股权类&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.1 Black-Scholes 模型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;模型介绍&lt;/b&gt;&lt;/p&gt;&lt;p&gt;股权类的 Black-Scholes (BS) 模型下的 SDE 是描述股票价格 (stock price) 的走势：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-222a895052e30100308fed7cea8fe089_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;77&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中&lt;/p&gt;&lt;p&gt;S(t) = 股票价格&lt;/p&gt;&lt;p&gt;r(t) = 瞬时无风险利率&lt;/p&gt;&lt;p&gt;q(t) = 瞬时红利率&lt;/p&gt;&lt;p&gt;ς(t) = S(t)的瞬时波动率 &lt;/p&gt;&lt;p&gt;B(t) = 布朗运动&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;该模型是 Fischer Black 和 Myron Scholes 在 1973 年提出，其论文题目是 &lt;i&gt;The Pricing of Options and Corporate Liabilities&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;模型参数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一般情况下&lt;/p&gt;&lt;p&gt; r(t) 和 q(t) 当成常数&lt;/p&gt;&lt;p&gt; ς( ) 可以是常数，但通常是分段常数 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;它们的获取方式为&lt;/p&gt;&lt;ul&gt;&lt;li&gt;r：根据股票结算的货币，找到其掉期曲线，如美元对应 USD Libor 3M 曲线，欧元对应 EUR Euribor 6M 曲线等，在曲线上插出 T 点 的r值&lt;/li&gt;&lt;li&gt;q：根据该股票在估值日和到期日 T 之间的所有离散红利，折现到 0 点得到红利现值 div，再利用公式 div = e-qT 计算出 T 点的 q 值， q = -ln(div/T)&lt;/li&gt;&lt;li&gt; ς 或 ς( ) :从一系列股权欧式期权中校正出来&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.2 市场标准产品和数据&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;产品定义&lt;/b&gt;&lt;/p&gt;&lt;p&gt;股权类市场标准产品是“一系列不同行权价格 K 和不同年限 T 股权欧式 期权 (EQ option)”，定义如下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在股权欧式期权 (equity vanilla option) 合约下，买方和卖方将同意以下内容：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 买方付出期权金 (premium) 便有权利 (right)去行使，而卖方收取 期权金后则有义务 (obligation) 履行买方行使权利的义务。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 看涨期权:买方有权在到期日以 K 买入 S，而卖方一旦被行使期权 时，则有责任以 K 卖出 S&lt;/li&gt;&lt;li&gt; 看跌期权:买方有权在到期日以 K 卖出 S，而卖方一旦被行使期权 时，则有责任以 K 买入 S&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其中 S 是到期日股权的价格，K 是执行价格 (strike price)。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;市场数据&lt;/b&gt;&lt;/p&gt;&lt;p&gt;它们的成交价就是用于模型校正的市场数据，但市场惯例是用波动率当市 场数据，原因是价格在价内和价外是差别会很大，而波动率是一个没有单 位的量。某天的日经平均指数 (N225) 的真实数据如下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-472a564b35e7a7e46b4ab38780f925fb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;148&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-472a564b35e7a7e46b4ab38780f925fb&quot; data-watermark-src=&quot;v2-d5527f5c1d9beb2e48b920ea8c1173e0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图数据又称 EQ option 波动率平面，它是二维数据结构&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 行对应的年限 (expiry)，期权年限从 1 个月到 5 年&lt;/li&gt;&lt;li&gt; 列对应的行权价格 (strike)，注意第三列白色粗体 17450.77 是&lt;/li&gt;&lt;li&gt;ATM 行权价格，其对应的绿色粗体是 ATM 波动率&lt;/li&gt;&lt;li&gt; 波动率与行权价格和年限有关，可写成 ς(K, T)&lt;/li&gt;&lt;li&gt; 波动率单位是%，28.63 实际上指的是 28.63%&lt;/li&gt;&lt;li&gt; 市场波动率带进 BS 公式得到期权的市场价格&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.3 市场价格和模型价格&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;市场价格&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a5929135e8070fa00c92e8d1cca8eed9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;195&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a5929135e8070fa00c92e8d1cca8eed9&quot; data-watermark-src=&quot;v2-be5b161afd4186e076f0faeae0769219&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;EQ option 市场价格是之后模型校正的基准 (benchmark)。关于 BS 模型的 EQ option 公式推导细节，可参考 &lt;i&gt;Options, Futures And Other Derivatives, 9th edition, Chapter15, Appendix.&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;模型价格&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-75f3f99ee795e63a39472631593d6acc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;176&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-75f3f99ee795e63a39472631593d6acc&quot; data-watermark-src=&quot;v2-c2f0287ad1f09c384412e7c43e515784&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-58433216e55a62af703dda68d8f3a78a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;240&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-58433216e55a62af703dda68d8f3a78a&quot; data-watermark-src=&quot;v2-f9d352ee22ac8067414f37a09ec0b6ca&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当模型参数为 t 的函数时，关于 BS 模型的 EQ option 公式推导细节，可参考 &lt;i&gt;Volatility and Correlation, 2th edition, Chapter3.&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.4 模型校正&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在 EQ option 市场上，对每一个标准 K 有 n 个到期的 EQ option，到期日分别为&lt;/p&gt;&lt;p&gt;0 = T0 &amp;lt; T1 &amp;lt; ... &amp;lt; i &amp;lt; ... &amp;lt; n&lt;/p&gt;&lt;p&gt;而对于每一个 Ti，EQ option 的行权价格为 K1 ... j ... m。 接下来我们分别讨论当模型参数为常数和分段常数是的校正过程。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;常数型参数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当参数为常数时，BS 模型校正本质上是找到“最优”ς，从而最小化一系列 EQ option 的市场价格和模型价格之间的差异，其目标函数为:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f034c6378e67077e5e37e8d51c1cd0d1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;210&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f034c6378e67077e5e37e8d51c1cd0d1&quot; data-watermark-src=&quot;v2-c6ae9067a11f318c2d6475a8e68e0c8a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Vmkt是 EQ option 市场价格，惯例是用 BS 公式计算的&lt;/li&gt;&lt;li&gt;ςmkt(K, T) 是 EQ option 市场波动率，有 n 个 T 和 m 个 K&lt;/li&gt;&lt;li&gt;VBS 是 EQ option 模型价格&lt;/li&gt;&lt;li&gt;ς 是 BS 模型的模型参数&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;分段常数型参数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当参数为分段常数时，对每一个标准 K，市场上都有一系列 Ti 到期的 EQ option，由上面公式发现期权价格 V 是 ς2(t) 积分的函数，如下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-fbbfa5ea8fbc52e67ba2c8f64a9eb324_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;279&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-fbbfa5ea8fbc52e67ba2c8f64a9eb324&quot; data-watermark-src=&quot;v2-7c6ac09f29e7ab5a205aebd3e197616d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;注意 ς0-i 是从 0 到 Ti 的波动率 ς(t )的均方根 (root-mean-square)，而它们可以直接反解 BS公式得到。之后我们可以得到从 Ti 到 Ti+1&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c67569762f36bd35e8aaa663dc8f91f5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;216&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c67569762f36bd35e8aaa663dc8f91f5&quot; data-watermark-src=&quot;v2-9d26d00ae0dcc5fdbbe5aa8625d33740&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上面公式建立了即期波动率到远期波动率的关系，而这个关系通常称为方 差平衡条件 (balance-of-variance condition)。具体步骤如下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;步骤 1&lt;/b&gt; - 在每个 Kj 下的所有年限 T 上计算:即期方差 = ς2mkt*T&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a68e6b484fb11a6323672977721d2fbd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;199&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a68e6b484fb11a6323672977721d2fbd&quot; data-watermark-src=&quot;v2-bf61a7e8bd4488fe2de9cfb9dbcd7cf5&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;步骤 2&lt;/b&gt;- 用方差平衡条件从即期方差推出远期波动率，如下表所示&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3938fa5280ec8a5c4ee991a3eabc7416_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;311&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-3938fa5280ec8a5c4ee991a3eabc7416&quot; data-watermark-src=&quot;v2-d226aaac03b006958943d217ca7908fb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#BS模型校正代码
spot_var = spot_vol.*2.*Te
for i = 1 : size(spot_vol,2)
    fwd_Vol(:,i) = sqrt( diff([0; spot_var(:,i)]) ./ diff([0;Te]) )
end&lt;/code&gt;&lt;p&gt;在做模型校正的同时，一旦我们发现下面的关系，那么就有套利机会。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a75b1aa33ce12bc15dd138855f752de3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;148&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a75b1aa33ce12bc15dd138855f752de3&quot; data-watermark-src=&quot;v2-3527cfb65ae78386bbf1d7ea73fdbf0c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上式意思就是股票价格到 Ti+1 的不确定性比到 Ti 的不确定性还小，这显然违背常理。如果有这种机会出现，买 Ti+1 到期的便宜期权，卖 Ti 到期 的昂贵期权。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.5 校正结果&lt;/b&gt;&lt;/p&gt;&lt;p&gt;下图展示着 N225 option 的市场价格 (红圈) 和模型价格 (蓝线)，发现它们在不同 K 和 T 时都高度吻合。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9cca54dc8e91829579520f6cfeceeb37_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;560&quot; data-rawheight=&quot;420&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9cca54dc8e91829579520f6cfeceeb37&quot; data-watermark-src=&quot;v2-10875c5776b5346c65c600ac244b4e68&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下图展示着在不同 K 下的分段常数 ς( )，基本上 ς( ) 是 t 的增函数，走 势正常。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-41fdd5321499a2c42e80e2616ae2e90c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;560&quot; data-rawheight=&quot;420&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-41fdd5321499a2c42e80e2616ae2e90c&quot; data-watermark-src=&quot;v2-0c8f2a77c50bc2c23da7c14d17fa4373&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;利率类&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.1 Hull-White 模型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;模型介绍&lt;/b&gt;&lt;/p&gt;&lt;p&gt;利率类的 Hull-White (HW) 模型下的 SDE 是描述短期利率 (short rate) 的走势:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-36f684652e2299f6a88a482a4e1f3f6b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;41&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中&lt;/p&gt;&lt;ul&gt;&lt;li&gt;r(t) = 短期利率&lt;/li&gt;&lt;li&gt;k( )=r(t)的均值回归速率&lt;/li&gt;&lt;li&gt;ς( )=r(t)的均值&lt;/li&gt;&lt;li&gt;6(t)= r(t)的波动率&lt;/li&gt;&lt;li&gt;B(t) = 布朗运动&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;该模型是 John Hull 和 Alan White 在 1990 年提出，其论文题目是&lt;/p&gt;&lt;p&gt;&lt;i&gt;Pricing Interest-Rate Derivative Securities&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;模型参数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一般情况下&lt;/p&gt;&lt;ul&gt;&lt;li&gt;k (t) 当成常数&lt;/li&gt;&lt;li&gt; 6(t) 可以是常数，但通常是分段常数 &lt;/li&gt;&lt;li&gt;ς(t )是 t 的函数&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;它们的获取方式为&lt;/p&gt;&lt;ul&gt;&lt;li&gt;k：根据历史数据人为设定，也可以从一系列利率期权中校正出来 &lt;/li&gt;&lt;li&gt;6或 6(t)：从一系列利率期权中校正出来&lt;/li&gt;&lt;li&gt;ς( )：从收益率曲线中校正出来&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-70dbeacc7c93b617dfcd8ec29d978adc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;62&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中 f(0, t)是 0 点观察到的 t 点瞬时远期利率&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;为了消除 ( ) 这个复杂项，令 x(t) = r(t) – f(0, t)，那么 x(0) = r(0) –f(0,0) = 0。原来 r(t) 的 SDE 转换成 x(t) 的 SDE:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-34a77508898cd3624831e3311f303a42_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;31&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1c988fcfeb822979c554eb47a89ab387_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;55&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这样在 HW 模型下的零息债券的公式如下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7e863eb8b51ec0e50c0c67a00a8b43fd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;63&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5780aeaca84cae5cacdadbc5509bd15e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;64&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;关于上面 ( ) 和 P(t, T) 推导细节，可以参考 &lt;i&gt;Interest Rate Modeling Volumn II, Term Structure Model, Chapter 10, 10.1.2.2.&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 市场标准产品和数据&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;产品定义&lt;/b&gt;&lt;/p&gt;&lt;p&gt;利率类市场标准产品包括:&lt;/p&gt;&lt;p&gt;1. 一系列不同行权价格 K 和不同年限 T 利率上限 (cap)&lt;/p&gt;&lt;p&gt;2. 一系列不同行权价格 K，不同期权年限 TO 和不同掉期年限 TU 利率&lt;/p&gt;&lt;p&gt;掉期期权 (swaption) Cap 和 swaption 定义如下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Cap 和 swaption 定义如下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在利率上限或下限 (interest rate cap/floor) 合约下，买方和卖方将同意以 下内容:&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 买方付出期权金 (premium) 便有权利 (right) 去行使，而卖方收取期权金后则有义务 (obligation) 履行买方行使权利的义务。&lt;/li&gt;&lt;li&gt; 双方就未来某一时期商定一个固定利率 K 作为利率上限/下限&lt;/li&gt;&lt;li&gt; 上限：买方有权利在每期获得市场利率 L 与上限利率 K 的差额 (L – K)，而卖方一旦被行使期权时，则有义务将市场利率 L 与上限利率 K 的差额支付给买方&lt;/li&gt;&lt;li&gt; 下限：买方有权利在每期获得下限利率 K 和市场利率 L 的差额 (K – L)，而卖方一旦被行使期权时，则有义务将下限利率 K 和市场利率 L 的差额支付给买方&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中 L 通常是 LIBOR，但是不是当期定盘，而是上一期定盘的 LIBOR。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;市场上流动性强的 cap 以美元、欧元和日元计价，每个 cap 都一连串 caplet 组成&lt;/p&gt;&lt;ul&gt;&lt;li&gt; USD cap 每年由 4 个 caplet 组成，每个 caplet 期限是 3 个月，以 USD LIBOR 3M 作标的利率&lt;/li&gt;&lt;li&gt; EUR cap 每年由 2 个 caplet 组成，每个 caplet 期限是 6 个月，以 EUR EURIBOR 6M 作标的利率&lt;/li&gt;&lt;li&gt; JPY cap 每年由 2 个 caplet 组成，每个 caplet 期限是 6 个月，以 JPY LIBOR 6M 作标的利率&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在利率掉期期权 (interest rate swaption) 合约下，买方和卖方将同意以下 内容:&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 买方付出期权金 (premium) 便有权利 (right) 去行使，而卖方收取 期权金后则有义务 (obligation) 履行买方行使权利的义务。&lt;/li&gt;&lt;li&gt; 支付类掉期期权 (payer swaption):买方有权利在期权到期日获得 一个“支付固定利率接受浮动利率 (pay fixed receive floating) 的利率 掉期”，而卖方一旦被行使期权时，则有义务将上述利率掉期给买 方&lt;/li&gt;&lt;li&gt; 接受类掉期期权 (payer swaption):买方有权利在期权到期日获得一个“接受固定利率支付浮动利率 (receive fixed pay floating) 的利率 掉期”，而卖方一旦被行使期权时，则有义务将上述利率掉期给买 方&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中利率掉期 (interest rate swap, IRS) 是指交易双方以一定的名义本金为 基础，将该本金产生的一种利率计算的利息收入 (支出) 与另一种利率计 算的利息收入 (支出)。交换的只是不同特征的利息，没有实质本金的互 换。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;市场上流动性强的以美元、欧元和日元计价的 swaption。其实 swaption 波动率是一个立方 (cube)，有行权利率、期权到期日、掉期到期日这三 个维度。通常我们用的最多的是 ATM swaption 波动率，当行权利率等于 远期掉期率，那么波动率立方降维成一个波动率平面，维度为二维。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;市场数据&lt;/b&gt;&lt;/p&gt;&lt;p&gt;某天的 JPY cap 的真实数据如下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-148e1017173dc2e4a6e142db8b0fc9a0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;199&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-148e1017173dc2e4a6e142db8b0fc9a0&quot; data-watermark-src=&quot;v2-e2ab3ccce5b93352d63af90584d4497e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图数据又称 cap 波动率平面，它是二维数据结构&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 行对应的年限 (expiry)，期权年限从 1 年到 20 年&lt;/li&gt;&lt;li&gt; 列对应的行权利率 (strike rate)，注意第一列绿色粗体是 ATM 波动率，而每个年限对应的 ATM 行权利率都不同&lt;/li&gt;&lt;li&gt; 波动率与行权价格和年限有关，可写成 ς(K, T)&lt;/li&gt;&lt;li&gt; 波动率单位是 %，43.01 实际上指的是 43.01%&lt;/li&gt;&lt;li&gt;市场波动率带进 Black 公式得到利率上限的市场价格&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;某天的 USD ATM swaption 的真实数据如下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-df05513cb349e28c6fc24e0dabacec42_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;187&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-df05513cb349e28c6fc24e0dabacec42&quot; data-watermark-src=&quot;v2-842e1849552671470db6fc5eda785ca7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图数据又称 ATM swaption 波动率平面，它是二维数据结构&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 行对应的利率掉期的年限 (maturity)，年限从 1 年到 30 年&lt;/li&gt;&lt;li&gt; 列对应的掉期期权的年限 (expiry)，年限从 1 个月到 30 年&lt;/li&gt;&lt;li&gt; ATM 波动率与期权年限和掉期年限有关，可写成 ς(TO, TU)&lt;/li&gt;&lt;li&gt; 波动率单位是%，59.80 实际上指的是 59.80%&lt;/li&gt;&lt;li&gt;市场波动率带进 Black 公式得到掉期期权的市场价格&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3 市场价格和模型价格&lt;/b&gt;&lt;/p&gt;&lt;p&gt;定义T0 &amp;lt;T1 &amp;lt;...&amp;lt; k &amp;lt;...&amp;lt; N 是cap 的年限结构，那么定义&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;{T0, T1, ..., TN-1} = LIBOR 定盘日 &lt;/p&gt;&lt;p&gt;{T1, T2, ..., TN} = 支付日&lt;/p&gt;&lt;p&gt;N = caplet 的个数&lt;/p&gt;&lt;p&gt;τk =Tk–Tk-1&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Cap 市场价格&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Cap 市场价格是之后模型校正的基准 (benchmark)。关于 Black 模型的 cap 推导细节，可以参考 &lt;i&gt;Interest Rate Model – Theory and Practice, Chapter 1 and Appendix D.&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-44366d83f6a1984c89d1dc084cd145df_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;288&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-44366d83f6a1984c89d1dc084cd145df&quot; data-watermark-src=&quot;v2-ce8cdcd1b01290164f9b21e43341cc75&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Cap 模型价格&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98bad03dfee7c7d17ba177441d8c635e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;269&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-98bad03dfee7c7d17ba177441d8c635e&quot; data-watermark-src=&quot;v2-5a60ed797fc1ce330ed6df5bb7a18e42&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当模型参数为常数时，关于 HW 模型的 cap 推导细节，可以参考 &lt;i&gt;Interest Rate Model – Theory and Practice, Chapter 3.&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;function price = HW_IRO( omega, Ds, De, Ts, Te, tau, K, kappa, sigma )

X = 1 + K*tau;
price = X .* HW_ZBO( -omega, Ts, Te, Ds, De, 1./X, kappa, sigma );
end
--------------------------------------
function price = HW_ZBO( omega, T1, T2, PT1, PT2, X, kappa, sigma )

tau = T2 - T1;

if kappa &amp;lt; 1e-12    
    sigmaP = sigma * tau .* sqrt(T1);
else
    sigmaP = sigma * sqrt((1-exp(-2*kappa*T1))/2/kappa) /kappa .* (1- exp(-kappa*tau));
end

h1 = (1./sigmaP) .* log(PT2./(PT1.*X)) + sigmaP/2;
h2 = h1 - sigmaPprice = omega * ( PT2.*normcdf(omega*h1) - X.*PT1.*normcdf(omega*h2) )

end&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5ed17be97c36fbd1630c8dcdeb10d965_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;272&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5ed17be97c36fbd1630c8dcdeb10d965&quot; data-watermark-src=&quot;v2-98582bf8cf339adc80ff8d561654c041&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Swaption 市场价格&lt;/b&gt;&lt;/p&gt;&lt;p&gt;定义T0 &amp;lt;T1 &amp;lt;...&amp;lt; k &amp;lt;...&amp;lt; N 是swaption 的年限结构，那么定义&lt;/p&gt;&lt;ul&gt;&lt;li&gt;T0 = swaption 到期日 &lt;/li&gt;&lt;li&gt;TN = swap 到期日&lt;/li&gt;&lt;li&gt;τk =Tk–Tk-1&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-76653f11f91e59ee2fc79239e3f387de_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;312&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-76653f11f91e59ee2fc79239e3f387de&quot; data-watermark-src=&quot;v2-525eea7a0479c969be46ab0a5201fa4a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Swaption 市场价格是之后模型校正的基准 (benchmark)。关于 Black 模 型的 Swaption 推导细节，可以参考 &lt;i&gt;Interest Rate Model – Theory and Practice, Chapter 1 and Appendix D.&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Swaption 模型价格&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Swaption 可看成在期权到期日 T1 时交换 IRS 的固定端和浮动端，因此它在 T1 的支付函数为&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-baa029ae64217e4dec8dbc6e82d45701_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;67&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;由小节 2.1 可知 P(t, T;x)是 x 的减函数，因此定义一个临界值 x* 使得&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b89dcea4870f45c9fec9314a4dd90c20_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;232&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b89dcea4870f45c9fec9314a4dd90c20&quot; data-watermark-src=&quot;v2-7c3d5a13a982671d5c3c82774483d987&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4d25f76e4522fd5dce064baced457707_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;39&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;根据 Jamshidian Trick，swaption 只有在 w x(T1) &amp;gt; * 时才有 payout， 为了简化符号引进 P1,k(x) = P(T1,Tk, x)，我们有&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1c45813d0e81e415a9b27d5b701f1b08_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;136&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1c45813d0e81e415a9b27d5b701f1b08&quot; data-watermark-src=&quot;v2-60ecfb7178958f44f28f5a71e1921777&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;最后 swaption 在 T1 的 payout 可表示为一系列的零息债券期权 (zero- coupon bond option, ZBO) 在的 payout，因此其价值为这些 ZBO 的价值 的组合。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-59764b769adc4bef96bee49a8926b885_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;329&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-59764b769adc4bef96bee49a8926b885&quot; data-watermark-src=&quot;v2-16d62d1d7d03a5ff358f91b3fc8b150b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#计算 HW Swaption 代码
function price = HW_Swaption( D, Tvec, tau, c, kappa, sigma )
Pt = D(1); PT = D(2:end); t = Tvec(1); T = Tvec(2:end);
x_star = fzero( @(x) Jamshidian( Pt, PT, kappa, sigma, t, T, c, tau, x ), 0 );
K = HW_zcb( Pt, PT, kappa, sigma, t, T, x_star )&#39;;

price = HW_ZBO( -1, t, T(end), Pt, PT(end), K(end), kappa, sigma ) ... + c*sum( tau.*HW_ZBO( -1, t, T, Pt, PT, K, kappa, sigma ) );
end
function y = Jamshidian( Pt, PT, kappa, sigma, t, T, c, tau, x )
y = HW_zcb(Pt, PT(end), kappa, sigma, t, T(end), x) ...
+ c*sum( tau.*HW_zcb(Pt, PT, kappa, sigma, t, T, x)&#39; ) - 1;
end
--------------------------------------
function PtT = HW_zcb( Pt, PT, kappa, sigma, t, T, Xt ) 
G = 1-exp(-kappa*(T-t))) / kappa;
y = sigma^2 * (1-exp(-2*kappa*t)) / (2*kappa)
PtT = (PT/Pt) * exp( -Xt*G -0.5*y*G^2 );
end&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e38e56d9d1f631a954c64861a6cc5b87_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;322&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e38e56d9d1f631a954c64861a6cc5b87&quot; data-watermark-src=&quot;v2-28b1e39cca7dc59f4dbc7f1453158cfd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;关于 HW 模型的 swaption 推导细节，可以参考 &lt;i&gt;Interest Rate Modeling – Volumn II, Term Structure Model, Chapter 10, 10.1.3.&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.4 模型校正 (cap)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在 cap 市场上，对每一个标准 K 有 n 个到期的 cap，到期日分别为&lt;/p&gt;&lt;p&gt;0 = T0 &amp;lt; T1 &amp;lt; ... &amp;lt; i &amp;lt; ... &amp;lt; n&lt;/p&gt;&lt;p&gt;而对于每一个 Ti，cap 的行权价格为 K1 ... j ... m。 接下来我们分别讨论当模型参数为常数和分段常数是的校正过程。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;常数型参数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当参数为常数时，HW 模型校正本质上是找到“最优” 和 ς，从而最小 化一系列 cap 的市场价格和模型价格之间的差异，其目标函数为:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b2123d4062fd99a43fc886d29174ad6f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;213&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b2123d4062fd99a43fc886d29174ad6f&quot; data-watermark-src=&quot;v2-ca880c56fbef6cbe914d3d885d4e0788&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Cap 是市场价格，惯例是用 Black 公式计算的&lt;/li&gt;&lt;li&gt;ςmkt(K, T) 是市场波动率，有 n 个 T 和 m 个 K&lt;/li&gt;&lt;li&gt;CapHW 是模型价格&lt;/li&gt;&lt;li&gt;k和 ς 是 HW 模型的模型参数&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;分段常数型参数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;从小节 2.3 的公式出发，&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 用上标i表示每一个K下的第i个cap&lt;/li&gt;&lt;li&gt; 用 Ni 表示该 cap 里面 caplet 的个数&lt;/li&gt;&lt;li&gt; 用tNi 代表第i 个cap 到期日，tNi =Ti&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cea78b49fcddc88102fb8a336f59e2eb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;380&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-cea78b49fcddc88102fb8a336f59e2eb&quot; data-watermark-src=&quot;v2-64dec05ec8f477209a6f643d7fb0cda1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当参数为分段常数时，假设选取 ATM cap 做校正，那么 HW 模型校正的 步骤为:&lt;/p&gt;&lt;p&gt;步骤 1 - 参数 根据历史数据手动输入，或者用常数形式的 HW 模型校 正得出&lt;/p&gt;&lt;p&gt;步骤 2 - 对第 1 个 cap，反解 ς1 使得 Capmkt(T1) = Cap1HW(ς1)&lt;/p&gt;&lt;p&gt;步骤 3 - 对第 2 个 cap，已知 ς1，反解 ς2 使得 Capmkt(T2) = Cap2HW(ς1,ς2)&lt;/p&gt;&lt;p&gt;步骤 4 - 重复上面过程到第 n 个 cap，已知 ς1, ς2 ... ςn-1，反解 ςn 使得 Capmkt(Tn) = CapnHW(ς1,ς2 ... ςn-1,ςn)&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;%HW 模型校正代码
sigma = zeros(num_of_T,1);
for i = 1 : num_of_T,
    [ itau, iTs, iTe, iDs, iDe ] = reference( (1:nFlt(i)-1), tau, Ts, Te, Ds, De );
    sigma(i) = fzero(@(x) Cap_diff( iDs, iDe, iTs, iTe, itau, K(i), kappa, x, mkt_price(i) ), 0.005 );
end&lt;/code&gt;&lt;p&gt;以上过程把 1 个 n 维的优化问题转成 n 个 1 维的优化问题，增加了模型 校正的效率。需要注意的是，上述步骤并不是每次都行得通，这种情况称 为“波动率紧缩 (volatility squeeze)”，出现在当 Ti+1 到期的 cap 比 Ti 到期的 cap 价格小很多的时候。这种情况很少见，一旦出现可以当成是套 利的信号。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.5 模型校正 (swaption)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在 ATM swaption 市场上，在以下的年限结构上考虑一串特殊的 swaption&lt;/p&gt;&lt;p&gt;0 = T0 &amp;lt; T1 &amp;lt; ... &amp;lt; i &amp;lt; ... &amp;lt; n&lt;/p&gt;&lt;p&gt;此类 swaption 的 option 到期日为 Ti, ... -1，而它们的 swap 到 期日都是 Tn，这样的 swaption 成为 coterminal swaption，记作 aYbY， 指的是 a 年 option 到期可以换一个 b 年 swap 的 swaption。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;由于此类结构和市场交易的百慕大期权 (Bermudan swaption) 很类似，因 此 coterminal swaption 经常被当作校正工具来使用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接下来我们分别讨论当模型参数为常数和分段常数是的校正过程。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;常数型参数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当参数为常数时，HW 模型校正本质上是找到“最优” 和 ς，从而最小 化一系列 coterminal swaption 的市场价格和模型价格之间的差异，其目 标函数为:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e1274b9d884c293eba89a45975f70345_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;68&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Swaption是市场价格，惯例是用 Black 公式计算的 &lt;/li&gt;&lt;li&gt;ςmkt(K, T) 是市场波动率，有 n 个 T 和 m 个 K &lt;/li&gt;&lt;li&gt;Swaption HW是模型价格&lt;/li&gt;&lt;li&gt;k和 ς 是 HW 模型的模型参数 &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;分段常数型参数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a4583276097585f735175eec5d025183_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;348&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a4583276097585f735175eec5d025183&quot; data-watermark-src=&quot;v2-b66a0945174f3628224b40e37d60653f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当参数为分段常数时，选取 ATM coterminal swaption 做校正，那么 HW 模型校正的步骤为:&lt;/p&gt;&lt;p&gt;步骤 1 - 参数 根据历史数据手动输入，或者用常数形式的 HW 模型校 正而得&lt;/p&gt;&lt;p&gt;步骤 2 - 对第 1 个 swaption，反解 ς1 使得 swaptionmkt(T1) = swaption1HW(ς1)&lt;/p&gt;&lt;p&gt;步骤 3 - 对第 2 个 swaption，已知 ς1，反解 ς2 使得 swaptionmkt(T2) = swaption2HW(ς1,ς2)&lt;/p&gt;&lt;p&gt;步骤 4 - 重复上面过程到第 n-1 个 swaption，已知 ς1, ς2 ... ςn-2，反解 ςn- 1 使得 swaptionmkt(Tn-1) = swaptionn-1HW(ς1,ς2 ... ςn-2,ςn-1)&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#HW 模型校正代码
sigma = zeros(num_of_T,1);
for i = 1 : num_of_T,
    T = getTenor( settle, fixedLegDate{i}, &#39;act/365&#39; );
    D = getDiscount( settle, spotDate, fixedLegDate{i}, LiborCurve ); 
    [ iT, iD ] = reference( 1:nFix(i), T, D );
    sigma(i) = fzero(@(x) Swaption_diff( iD, iT, fixtau{i,i}, K(i),
kappa, x, mkt_price(i) ), 0.005 );     
end&lt;/code&gt;&lt;p&gt;和 cap 校正是遇到的问题一样，波动率紧缩也是 swaption 的校正可能出 现的问题。该情况出现在当 Ti+1 到期的 swaption 比 Ti 到期的 swaption 价格小很多的时候。这种情况很少见，一旦出现可以当成是套利的信号。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.6 校正结果&lt;/b&gt;&lt;/p&gt;&lt;p&gt;下图展示着当 和 ς 为常数时，USD ATM cap 的市场价格 (红圈) 和模型 价格 (蓝线)，发现它们在不同 T 时结果相近但不完全吻合，原因是 2 个 未知量来拟合 13 个 cap，只能平均接近不能各个匹配。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-28c2c82df0287e2bcbc7110dfcc48f91_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;560&quot; data-rawheight=&quot;420&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-28c2c82df0287e2bcbc7110dfcc48f91&quot; data-watermark-src=&quot;v2-3f037e1d7057305de977bb234a420262&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下图展示着当 为已设好的 0.01 和 ς(t) 为分段常数时，USD ATM cap 的 市场价格 (红圈) 和模型价格 (蓝线)，发现它们在不同 T 时完全吻合，原 因是当 已知，每个 cap 和 ς 是一一对应关系。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-46765c49338460f58fc9c194cb7b3cea_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;560&quot; data-rawheight=&quot;420&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-46765c49338460f58fc9c194cb7b3cea&quot; data-watermark-src=&quot;v2-67e0ce5becb27caa627b9b983a661961&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下图展示着当 和 ς 为常数时，USD ATM coterminal swaption 的市场价 格 (红圈) 和模型价格 (蓝线)，发现它们在短期 T 时结果相近但长期 T 相 差很远。原因是 2 个未知量来拟合 11 个 cap，只能平均接近不能各个匹 配，而且后面几个 swaption 的到期日从 15 年到 30 年，常数参数很难能 把这么长的掉期期权拟合好。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3bcd78b60f8d82021ff2b164e8637ec2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;560&quot; data-rawheight=&quot;420&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-3bcd78b60f8d82021ff2b164e8637ec2&quot; data-watermark-src=&quot;v2-02630b7756dae9a5f6075e90a3581814&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下图展示着当 为常数和 ς( ) 为分段常数时，USD ATM coterminal swaption 的市场价格 (红圈) 和模型价格 (蓝线)，发现它们在不同 T 时完 全吻合，原因是当 先校正好，每个 swaption 和 ς 是一一对应关系。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-386339a35bc5ffc2d9c85e2a3f84bb81_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;560&quot; data-rawheight=&quot;420&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-386339a35bc5ffc2d9c85e2a3f84bb81&quot; data-watermark-src=&quot;v2-1cb72648327911c1d9cddcfeded8e342&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;商品类&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.1 Schwartz 模型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;模型介绍&lt;/b&gt;&lt;/p&gt;&lt;p&gt;股权类的 Black-Scholes 模型也适用于商品类，但是它无法处理具有均值 回归 (mean-reverting) 特征的商品。为解决上述缺点，一个方法就是将均 值回归特征融合到商品价格过程中，而 Schwartz 模型涵盖这些特点。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;商品类的 Schwartz (SW) 模型下的 SDE 是描述商品即期价格 (commodity spot price) 的走势:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-49a0c5231f70799e27d02e52be688e75_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;53&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中&lt;/p&gt;&lt;ul&gt;&lt;li&gt;r(t) = 短期利率&lt;/li&gt;&lt;li&gt;k(t)=C(t) 的均值回归速率 &lt;/li&gt;&lt;li&gt;ς(t)=C(t) 的均值&lt;/li&gt;&lt;li&gt;6(t)=C(t) 的波动率&lt;/li&gt;&lt;li&gt;B(t) = 布朗运动&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;该模型是 Eduardo S. Schwartz 在 1997 年提出，其论文题目是&lt;/p&gt;&lt;p&gt;&lt;i&gt;The Stochastic Behavior of Commodity Prices Implications for Valuation and Hedging&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;模型参数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一般情况下&lt;/p&gt;&lt;ul&gt;&lt;li&gt; r(t) 当成常数&lt;/li&gt;&lt;li&gt;6 (t)和k(t)当成常数 &lt;/li&gt;&lt;li&gt;ς(t)当成分段常数&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;它们的获取方式为&lt;/p&gt;&lt;ul&gt;&lt;li&gt;r：根据商品结算的货币，绝大部分情况是 USD，用其掉期曲线 USD Libor 3M 曲线，在曲线上插出 T 点的 r 值&lt;/li&gt;&lt;li&gt;k和6：从一系列商品期货欧式期权中校正出来 &lt;/li&gt;&lt;li&gt;ς(t) :从商品期货曲线中校正出来&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.2 市场标准产品和数据&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;产品定义&lt;/b&gt;&lt;/p&gt;&lt;p&gt;商品类市场标准产品是一系列“不同行权价格 K 和不同年限 T 商品欧式期货期权 (CM futures option)”，定义如下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;定义:期权买方和卖方进入商品欧式期货期权 (commodity futures option) 合约的将同意以下内容:&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 期权买方付出期权金 (premium) 便有权利 (right)去行使，而卖方 收取期权金后则有义务 (obligation) 履行买方行使权利的义务。&lt;/li&gt;&lt;li&gt; 看涨期权:买方有权在到期日以 K 买入期货，而卖方一旦被行使期 权时，则有责任以 K 卖出期货&lt;/li&gt;&lt;li&gt; 看跌期权:买方有权在到期日以 K 卖出期货，而卖方一旦被行使期 权时，则有责任以 K 买入期货&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其中 K 是执行价格 (strike price)。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;市场数据&lt;/b&gt;&lt;/p&gt;&lt;p&gt;某天的咖啡期货期权和期货价格的真实数据如下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-71ff88d7da586e27f399d5fa2cd443fb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;207&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-71ff88d7da586e27f399d5fa2cd443fb&quot; data-watermark-src=&quot;v2-90d274c5dc1c6348266fb3b910381012&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图数据又称 CM futures option 波动率平面，它是二维数据结构&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 行对应的年限 (expiry)，期权年限从 1 个月到 2 年&lt;/li&gt;&lt;li&gt; 行对应的行权价格 (strike)，注意第四行白色粗体 302.85 是 ATM&lt;/li&gt;&lt;li&gt; 行权价格，其对应的绿色粗体是 ATM 波动率&lt;/li&gt;&lt;li&gt; 波动率单位是%，32.33 实际上指的是 32.33%&lt;/li&gt;&lt;li&gt; 市场波动率带进 Black 公式得到期货期权的市场价格&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b1dd0655221abecf909cd64938a76466_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;269&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b1dd0655221abecf909cd64938a76466&quot; data-watermark-src=&quot;v2-1af8b3eef51969b7b7e225d6afd79854&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图数据又称 CM futures 价格曲线，它是一维数据结构，每一个年限对 应一个期货价格。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.3 市场价格和模型价格&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;市场价格&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d642cd51b43f28e4dd5ab41f58afc2e1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;198&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d642cd51b43f28e4dd5ab41f58afc2e1&quot; data-watermark-src=&quot;v2-aa56197ae63a2da515172503df699ee9&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;CM futures option 的市场价格是之后模型校正的基准 (benchmark)。关于 Black 模型的 CM futures option 推导细节，可以参考 &lt;i&gt;Commodities and&lt;/i&gt; &lt;i&gt;Commodity Derivatives Modeling and Pricing for Agriculturals, Metals and Energy, Chapter 4.&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;模型价格&lt;/b&gt;&lt;/p&gt;&lt;p&gt;给定k和6，通过 Ito&#39;s&#39;lemma 可以推出F(0,T)在 SW 模型下的表达式以及它的 SDE:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-915ea72e3c12b907cec2b1fdd0a99564_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;115&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-915ea72e3c12b907cec2b1fdd0a99564&quot; data-watermark-src=&quot;v2-9134c5f3fa3bc7dd8b1e090b11ad3ee0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;从上面的 SDE 发现参数 ( ) 不见了，而且在 SW 模型下 FSW(0,T) 的分布 和 Black 模型下的分布非常相似，不同的只是离散项。因此，套用 Black 模型的公式，类比出 CM futures option 的定价公式:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a8825149731e5852cd7865699b7bd531_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;265&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a8825149731e5852cd7865699b7bd531&quot; data-watermark-src=&quot;v2-97fe2d96f2374e22140a9e47244d0617&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.4 模型校正&lt;/b&gt;&lt;/p&gt;&lt;p&gt;SW 模型校正步骤总结如下:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;先假设FSW(0,Ti)=F(0,Ti),从一系列欧式期货期权校正出和&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;    2. 再使得FSW(0,Ti)=F(0,Ti),从期货曲线进行校正出(t)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;步骤 1&lt;/p&gt;&lt;p&gt;SW 模型校正本质上是找到“最优” 和 ς，从而最小化一系列 ATM CM futures option 的市场价格和模型价格之间的差异，其目标函数为:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a14a59b836fed4deecfb184d4c8160dd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;80&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#SF 模型校正步骤 1 代码
MP = fminsearch(@(x) option_diff( F_mkt, K, r, 0, x, T1, OptFlavor, vol_mkt), [0.1;0.1] ); 
function diff = option_diff( F, K, r, b, x, T, Flavor, vol_mkt )

kappa = x(1); sigma = x(2);

vol_mdl = sigma .* sqrt( (1-exp(-2*kappa.*T))./(2*kappa.*T) );
opt_mdl = OPTION_BLACK( Flavor, F, K, T, r, b, vol_mdl ); 
opt_mkt = OPTION_BLACK( Flavor, F, K, T, r, b, vol_mkt );

diff = sum( (opt_mdl - opt_mkt).^2 );
end&lt;/code&gt;&lt;p&gt;步骤 2&lt;/p&gt;&lt;p&gt;在 SW 模型下定价 CM futures option 时不需要 ，因为 F 是从期货曲线中 提取的。在确定了6和k 之后，再校正 (t) 从而完全匹配期货的市场价格 和模型价格，其目标函数为:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-aab1006ff98b2f5ddf4f9abe44bd0391_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;86&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中&lt;/p&gt;&lt;p&gt;Fmkt(0, Ti) = 从期货曲线插出 Ti 时点的期货价格 &lt;/p&gt;&lt;p&gt;FSW(0, Ti; ) = SW 模型计算的 Ti 时点的期货价格&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a13b30aee7f51f5ad38c40e19b1d9127_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;372&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a13b30aee7f51f5ad38c40e19b1d9127&quot; data-watermark-src=&quot;v2-edf0edd18d403287d2f409ecf3504d47&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#SF 模型校正步骤 2 代码
theta = Calibration_F( MP, SRspline, C, F_mkt, T );

function theta = Calibration_F( x, SRspline, C, F, T )
kappa = x(1); sigma = x(2);
temp = integration( SRspline, kappa, T );
RHS = exp(-kappa*T).*log(C)-log(F)+temp-0.5*sigma^2/kappa.*(1-exp(-kappa*T)) + 0.25*sigma^2/kappa*(1-exp(-2*kappa*T)); LHS = (1-exp(-kappa*T)) / kappa;

theta = RHS ./ LHS;
end&lt;/code&gt;&lt;p&gt;&lt;b&gt;3.5 季节性调整&lt;/b&gt;&lt;/p&gt;&lt;p&gt;与典型的投资性资产相比，农产品的价格通常显示出季节性特征。在旺季 时，农产品的产量会剧增而导致价格下降。之后，农产品价格通常会逐渐 上涨，当然这也取决农产品不可预见的存储量。因此，在对农产品价格进 行建模时会考虑季节性因素。对那些长期期权进行定价时，季节性因素显 得更为重要。&lt;/p&gt;&lt;p&gt;为了在商品价格过程中体现季节性因素的影响，通常会用一个函数来对 “季节性的贡献”进行建模。说明如下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4b5270404652a27577fa7fe3d0d64a50_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;168&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-4b5270404652a27577fa7fe3d0d64a50&quot; data-watermark-src=&quot;v2-1d7bebc610484db78aa27cdc3f5f3bb7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;带季节性调整的 SW 模型校正步骤总结如下:&lt;/p&gt;&lt;p&gt;1. 用KalmanFilter和m个期货校正季节性函数的β和ψ&lt;/p&gt;&lt;p&gt;2. 最小化一系列欧式期货期权的市场价格和模型价格得出和&lt;/p&gt;&lt;p&gt;3. 最小化一系列期货曲线的市场价格和模型价格得出(t)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上述步骤 2 和 3 和不带季节性调整的 SW 模型步骤 1 和 2 一样 (见小节 3.4)，不同的是期权公式里面的 FSW(0,T)要做季节性调整。&lt;/p&gt;&lt;p&gt;因此在上面校正过程之前，我们必须知道季节函数 f 里面的参数 β 和 ψ， 而校正它们用的是 Kalman Filter (KF)方法。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.6 Kalman Filter 方法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;为了节省空间，将时间 t 写成下标，比如 S(t)写成 St，F(t, T) 写成 Ft,T，定义&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;xt = lnSt = 现货价格的对数&lt;/p&gt;&lt;p&gt;yt = lnFt,T + fT = 经过季节因素调整后的期货价格的对数 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;根据以上符号和 SW 模型可推出以下两个线性方程:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-210e2874902599c57d47a2a7464328c4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;349&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-210e2874902599c57d47a2a7464328c4&quot; data-watermark-src=&quot;v2-13b5400461b9b8ddfadd455f77df9e16&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上面两个方程:&lt;/p&gt;&lt;ul&gt;&lt;li&gt; E2 是一个观察方程，它将列向量 yt 和标量 xt，解释列向量 ct 和误差列向量 et 联系起来。&lt;/li&gt;&lt;li&gt;E1 是一个动态方程，它描述一个一阶马可夫链 (Markov chain) 过 程。变量 Tt, Rt, Qt, Zt 和 Ht 称为系统变量，它们是关于 SW 模型参数的函数。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在 KF 校正过程中需要不同期限期货的历史价格，如下图所示&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0d4465287370b9487f0f9fc4a0ffc6ae_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;281&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0d4465287370b9487f0f9fc4a0ffc6ae&quot; data-watermark-src=&quot;v2-9e42c09c88680300ead7a1edc9cfb7c1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;每行代表不同天数上的期货价格 (每隔 7 天)&lt;/li&gt;&lt;li&gt; 每列代表不同期限的期货价格 (1 个月、3 个月到 15 个月)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;KF 方法是在已知数据 Yt = {y1, y2 ... yt} 和相关模型的情况下，更新 xt+1 条 件分布。因为条件分布是一个正态分布过程，用条件均值和协方差矩阵就 足以说明此过程。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;将 xj|i 和 Σ j|i 定义在已知 Yi 的情况下 xj 的条件均值和协方差矩阵，我们有 xj|Yi~N(xj|i Σj|i)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;做好准备工作&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 算出起始值 x1|0 和 Σ1|0&lt;/li&gt;&lt;/ul&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-262b6f0ead53507b61b1dfd8bd3ba163_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;28&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 初始化对数密度概率函数 p = 0&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;KF 算法描述如下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-13980ba58165f4a49a12d4b7c1c29d9e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;544&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-13980ba58165f4a49a12d4b7c1c29d9e&quot; data-watermark-src=&quot;v2-6c197de760b1527f12c9602e0b71375a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;最后最大化 p 来得到 β* ψ* ς* * μ* H*。关于以上 Kalman Filter 校正步 骤，可以参考&lt;i&gt;Analysis of Financial Time Series, Chapter 11.&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2e1cf2e9f3606e5de1c0c2c59be6e475_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;652&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2e1cf2e9f3606e5de1c0c2c59be6e475&quot; data-watermark-src=&quot;v2-6e0a5753fc595de453d0d4a13d149891&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;外汇类&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;4.1 Heston 模型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;模型介绍&lt;/b&gt;&lt;/p&gt;&lt;p&gt;虽然 Black-Scholes 模型在市场上被广泛应用于定价欧式期权，该模型假 设波动性是常数或是时间 t 的函数。从实证证据可以看出，这一假设是错 的，资产的波动率也表现出随机性，就像资产价格一样。而 Heston 模型 在 Black-Scholes 模型基础上把波动率看成是个随机变量。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;股权类的 Heston 模型下的 2 个 SDE 分别描述即期汇率 (spot FX rate) 和 其波动率 (volatility) 的走势:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d14944d03889d5dfc39dd2f7a9029e42_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;284&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d14944d03889d5dfc39dd2f7a9029e42&quot; data-watermark-src=&quot;v2-5584bb6d1e13c4944a1de6baf8af412f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;该模型是 Steven L. Heston 在 1993 年提出，其论文题目是&lt;/p&gt;&lt;p&gt;&lt;i&gt;A Closed-Form Solution for Options with Stochastic Volatility with Applications to Bond and Currency Options&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;模型参数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一般情况下&lt;/p&gt;&lt;ul&gt;&lt;li&gt; rd(t) 和 rf(t) 当成常数  &lt;/li&gt;&lt;li&gt;v0 当成常数&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;它们的获取方式为&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7a517c73bacf86bdc90f3e9622cbd68b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;94&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;4.2 市场标准产品和数据&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;产品定义&lt;/b&gt;&lt;/p&gt;&lt;p&gt;外汇类市场标准产品是一系列“不同 Delta 和不同年限 T 外汇欧式期权 (FX option)”，定义如下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;用 FOR 代表外币，DOM 代表本币，FOR/DOM 为货币对。 期权买方和卖 方进入外汇欧式期权 (FX vanilla option) 合约的将同意以下内容:&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 买方付出期权金 (premium) 便有权利 (right)去行使，而卖方收取 期权金后则有义务 (obligation) 履行买方行使权利的义务。&lt;/li&gt;&lt;li&gt; 看涨 FOR/DOM 期权 (看涨外币看跌本币): 买方有权在到期日进入 当前即期市场买入外币 N，并卖出本币 N×K;而卖方一旦被行使期 权时，则有责任卖出外币 N，并买入本币 N×K&lt;/li&gt;&lt;li&gt; 看跌 FOR/DOM 期权 (看跌外币看涨本币): 买方有权在到期日进入 当前即期市场卖出外币 N，并买入本币 N×K ;而卖方一旦被行使 期权时，则有责任买入外币 N，并卖出本币 N×K&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其中 N 是名义金额 (notional)，K 是执行汇率 (strike rate)。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;市场数据&lt;/b&gt;&lt;/p&gt;&lt;p&gt;某天的 EURUSD 期权的真实数据如下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e65862fab60181dc3edda4d73f859d4f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;230&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e65862fab60181dc3edda4d73f859d4f&quot; data-watermark-src=&quot;v2-73cc59acbb049b4c40f273fc3ac7f312&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图数据又称 FX option 波动率平面，它是二维数据结构&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 行对应的年限 (expiry)，期权年限从 1 天到 2 年&lt;/li&gt;&lt;li&gt; 行对应的报价惯例 (convention)，外汇市场最常见的报价类型是价中(ATM)，25 和 10 风险反转 (risk reversal, RR) 组合，25 和 10 蝶式 (butterfly, BF) 组合&lt;/li&gt;&lt;li&gt; 波动率单位是%，6.44 实际上指的是 6.44%&lt;/li&gt;&lt;li&gt;市场波动率带进 BS 公式得到期权的市场价格&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下表根据 ATM, RR 和 BF 之间波动率的联系推出 10 和 25 delta 对应的波动率:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-589fb1724376d6c2014300ff6b485084_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;199&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-589fb1724376d6c2014300ff6b485084&quot; data-watermark-src=&quot;v2-8d3cee0aa6ea1b9a5a4bda9caaedc128&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;利用上表右边的公式算出各个 delta 和 T 下的波动率。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-fae05b3dfddf066d2a614d46405dda97_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;372&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-fae05b3dfddf066d2a614d46405dda97&quot; data-watermark-src=&quot;v2-d67d90767407be6829585932b389644f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;4.3 市场价格和模型价格&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;市场价格&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4dc75ee35df3d6c1bcc931fe6abd5eab_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;211&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-4dc75ee35df3d6c1bcc931fe6abd5eab&quot; data-watermark-src=&quot;v2-d361658b1dbe9eb24840993fb03b3468&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;FX option 的市场价格是之后模型校正的基准 (benchmark)。关于 BS 模型 的 FX option 公式推导细节，可参考 &lt;i&gt;Foreign Exchange Option Pricing - A Practitioner&#39;s Guide, Chapter 2.&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;模型价格&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e602ffc7f26812d3f85da357cb116b1c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;516&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e602ffc7f26812d3f85da357cb116b1c&quot; data-watermark-src=&quot;v2-bc0ef11883e2bd8ad63d0602366b0cca&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当模型参数为常数时，关于 Heston 模型的 option 推导细节，可以参考 &lt;i&gt;The Heston Model and Its Extensions in Matlab and C#, Chapter 1.&lt;/i&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当参数为分段常数时，表达如下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8e0f08f2bca0614cbcbda63e4d158941_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;110&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-8e0f08f2bca0614cbcbda63e4d158941&quot; data-watermark-src=&quot;v2-69272942863ff3d2c318a696ad75325a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;为了简化公式，用 Wk 代表 Heston 模型参数集，即&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-654125d6eb2bb96a5958d68a1e89bef9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;36&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d9b85912332f6fa634e220b11f07f0fe_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;690&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d9b85912332f6fa634e220b11f07f0fe&quot; data-watermark-src=&quot;v2-7069bdf57d94e571622378c101394649&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;当模型参数为分段常数时，关于 Heston 模型的 option 推导细节，可以参考 &lt;i&gt;The Heston Model and Its Extensions in Matlab and C#, Chapter 9.&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上面公式难点就是如何用迭代的方法求得 C 和 D，最后计算出 P，代码如 下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b3c33c68744c5ea37dbf6784e7ab38b3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;521&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b3c33c68744c5ea37dbf6784e7ab38b3&quot; data-watermark-src=&quot;v2-d9eb616a678ae44c79e69bd90aa63979&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;4.4 模型校正&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在外汇期权市场上，对每一个标准 delta 有 n 个到期的 option，到期日分别为&lt;/p&gt;&lt;p&gt;0 = T0 &amp;lt; T1 &amp;lt; ... &amp;lt; k &amp;lt; ... &amp;lt; n&lt;/p&gt;&lt;p&gt;而对于每一个 Tk，option 的行权汇率为 K1,k ... j,k ... m,k。 &lt;/p&gt;&lt;p&gt;接下来我们分别讨论当模型参数为常数和分段常数是的校正过程。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;常数型参数&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c276df44faf0d052f083b28f9fa96074_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;614&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c276df44faf0d052f083b28f9fa96074&quot; data-watermark-src=&quot;v2-1fc257913f0f12f0276daf2354a0a025&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;分段常数型参数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e3ae88afe441d44a5b19008595df2e0a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;533&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e3ae88afe441d44a5b19008595df2e0a&quot; data-watermark-src=&quot;v2-9bc7349231f9233561723539f01e7f93&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-095b155165259f43fc2a75fe27f740c1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;483&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-095b155165259f43fc2a75fe27f740c1&quot; data-watermark-src=&quot;v2-e0e072c2bcbd999d1ff2476e5a09929f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;4.5 校正结果&lt;/b&gt;&lt;/p&gt;&lt;p&gt;下图展示着 USDJPY option 的市场价格 (红圈) 和模型价格 (蓝线)，发现它们在不同 delta 和 T 时差别不大。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b5241ae4155851826d510c3db8b9069d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;560&quot; data-rawheight=&quot;420&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b5241ae4155851826d510c3db8b9069d&quot; data-watermark-src=&quot;v2-0365125e202c8853127634ff3e1e2140&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下图展示着模型参数的分段常数形式，发现它们都不是和时间 t 呈单调关 系，但除了 上下摇摆而变化很大之外，其他三个参数总体来讲还比较 稳定。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a90a5a70831dcabf83c0066ca49f2962_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;560&quot; data-rawheight=&quot;420&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a90a5a70831dcabf83c0066ca49f2962&quot; data-watermark-src=&quot;v2-252db598cf6908c897963438efe1e29c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;模型校正是选择模型中的参数使得市场流动性强的交易价格 (市场价格) 和模型输出 (模型价格) 完全匹配或尽可能接近。完全匹配价格意味着消 除套利机会。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;几乎所有的金融模型都有一些不能准确测量的参数。在最简单 Black- Scholes 模型，该参数是波动率。如果我们无法测量该参数，我们如何决 定波动率的值?如果决定不了，那么该模型是无用的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;两种方式可以得到波动率的值。一个是使用历史数据，另一个是使用当天 的期权价格数据。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;历史波动率：它的主要问题是使用过去的数据向后看而未来无关。 另一个问题是，它可能给出一个和市场价格不一致的价格。例如你 有兴趣购买一个期权。 你根据历史波动率算出的价格是 10 美元， 然而该期权的市场价格是 19 美元。你还有兴趣购买吗? 这时候， 要不期权市价错了，要不你对波动率的估计的不正确。&lt;/li&gt;&lt;li&gt; 隐含波动率：它是隐含在市场交易产品的价格里面。在上面的例子 中，我们要问什么波动率放入 Black-Scholes 以获得 19 美元的“正 确”价格。然后使用该波动率来定价其他复杂产品。 这时我们是向 前看的，而不是用来自过去的信息。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在量化金融上，第二种叫做模型校正，第一种不是。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;模型校正使得市场流动性强的交易价格接近模型价格，但是这些产品的市 场价格已经有了，为何还需要模型价格呢?请注意，模型校正从来不是为 了定价那些有市价的简单产品，而且为了定价那些没有市价的复杂产品。 但是，一个模型连一个简单产品的价格都算不准，谁还会对它算准一个复 杂产品有信心呢?理清这个就知道模型校正的意义了。本文只是讲了模型 校正的基本知识，此外:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 模型校正在实际应用上还会有许多变种，目标函数除了最小化绝对 价格，还有最小化相对价格或绝对波动率，它们各有优缺点限于篇 幅就不延伸了。&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 模型校正和机器学习也有同异，相同之处是它们最终都是用“最小化代价函数技巧”来解决问题;不同之处是前者用数量少的当前数 据，而后者用数量多的历史数据。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 模型校正也可以用于量化交易上，比如校正一个均值回归例如 Hull-White 模型加上 Kalman Filter 方法可以用于配对交易 (pairs trading)。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt; 模型校正还有更有挑战的内容，比如 Libor Market+SABR 模型、 Local Stochastic Volatility 模型，这些内容是量化金融的巅峰。&lt;/li&gt;&lt;/ul&gt;</description>
<author>量化家</author>
<guid isPermaLink="false">2018-07-25-40528417</guid>
<pubDate>Wed, 25 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>算法||LSTM</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-07-24-40449368.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40449368&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LSTM Networks是递归神经网络（RNNs）的一种，该算法由Sepp Hochreiter和Jurgen Schmidhuber在Neural Computation上首次公布。后经过人们的不断改进，LSTM的内部结构逐渐变得完善起来（图1）。在处理和预测时间序列相关的数据时会比一般的RNNs表现的更好。目前，LSTM Networks已经被广泛应用在机器人控制、文本识别及预测、语音识别、蛋白质同源检测等领域。基于LSTM Networks在这些方面的优异表现，本推文旨在探究LSTM是否可以应用于股票时间序列的预测。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-40e8a6c2517c2d9f2324d0a2fdc9814b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;622&quot; data-rawheight=&quot;412&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-40e8a6c2517c2d9f2324d0a2fdc9814b&quot; data-watermark-src=&quot;v2-b5f7fdb6f2245c6b7e91de03d93903a6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;LSTM Networks 建模流程&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;处理股票时间序列的流程&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本推文使用的LSTM处理股票序列的流程如图2。构建LSTM模型使用库主要为Keras。&lt;/p&gt;&lt;p&gt;&lt;b&gt;数据获取与处理：&lt;/b&gt;对于时间序列，我们通常会以[X(t-n),X(t-n+1),…,X(t-1),X(t)]这n个时刻的数据作为输入来预测(t+1)时刻的输出。对于股票来说，在t时刻会有若干个features，因此，为了丰富features以使模型更加精确，本推文将n(time series)×s(features per time series)的二维向量作为输入。LSTM对于数据标准化的要求很高，因此本推文所有input数据均经过z-score标准化处理。&lt;/p&gt;&lt;p&gt;&lt;b&gt;LSTM模型构建：&lt;/b&gt;作为循环层的一种神经网络结构，只使用LSTM并不能构建出一个完整的模型，LSTM还需要与其他神经网络层（如Dense层、卷积层等）配合使用。此外，还可以构建多层LSTM层来增加模型的复杂性。&lt;/p&gt;&lt;p&gt;&lt;b&gt;回测：&lt;/b&gt;本推文进行的回测分为两种，一是直接将LSTM输出结果作为做单信号在个股上进行回测，二是将LSTM的预测结果作为一种择时信号，再配合其他选股模型（如BigQuant平台的StockRanker）进行回测。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-49b808f7911ab3dee7dae7491b18bcf3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;196&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-49b808f7911ab3dee7dae7491b18bcf3&quot; data-watermark-src=&quot;v2-6bbf089b1ab53b41c8625bcc4af35b7c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;LSTM对沪深300未来五日收益率预测&lt;/b&gt;&lt;/p&gt;&lt;p&gt;综合以上两点，本推文所使用的输入和输出为利用过去30天的数据预测将来五天的收益。&lt;/p&gt;&lt;p&gt;测试对象：沪深300&lt;/p&gt;&lt;p&gt;数据选择和处理：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;input的时间跨度为30天，每天的features为[&#39;close&#39;,&#39;open&#39;,&#39;high&#39;,&#39;low&#39;,&#39;amount&#39;,&#39;volume&#39;]共6个，因此每个input为30×6的二维向量。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;output为未来5日收益future_return_5（future_return_5&amp;gt;0.2,取0.2;future_return_5&amp;lt;-0.2,取-0.2)，为使训练效果更加明显，output=future_return_5×10； features均经过标准化处理(在每个样本内每个feature标准化处理一次)。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;训练数据：沪深300 2005-01-01至2014-12-31时间段的数据；测试数据：沪深300 2015-01-01至2017-05-01时间段数据。&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;模型构建：鉴于数据较少（训练数据约2500个，预测数据约500个），因此模型构建的相对简单。模型共四层，为一层LSTM层+三层Dense层（图3）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;回测：得到LSTM预测结果后，若LSTM预测值小于0，则记为-1，若大于0，记为1。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;部分代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;# 数据处理：设定每个input（30time series×6features）以及数据标准化
train_input = []
train_output = []
test_input = []
test_output = []
for i in range(conf.seq_len-1, len(traindata)):
    a = scale(scaledata[i+1-conf.seq_len:i+1])
    train_input.append(a)
    c = data[&#39;return&#39;][i]
    train_output.append(c)
for j in range(len(traindata), len(data)):
    b = scale(scaledata[j+1-conf.seq_len:j+1])
    test_input.append(b)
    c = data[&#39;return&#39;][j]
    test_output.append(c)

# LSTM接受数组类型的输入
train_x = np.array(train_input)
train_y = np.array(train_output)
test_x = np.array(test_input) 
test_y = np.array(test_output)
# 自定义激活函数
import tensorflow as tf
def atan(x): 
    return tf.atan(x)

# 构建神经网络层 1层LSTM层+3层Dense层
# 用于1个输入情况
lstm_input = Input(shape=(30,6), name=&#39;lstm_input&#39;)
lstm_output = LSTM(128, activation=atan, dropout_W=0.2, dropout_U=0.1)(lstm_input)
Dense_output_1 = Dense(64, activation=&#39;linear&#39;)(lstm_output)
Dense_output_2 = Dense(16, activation=&#39;linear&#39;)(Dense_output_1)
predictions = Dense(1, activation=atan)(Dense_output_2)

model = Model(input=lstm_input, output=predictions)

model.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;, metrics=[&#39;mse&#39;])

model.fit(train_x, train_y, batch_size=conf.batch, nb_epoch=10, verbose=2)

# 预测
predictions = model.predict(test_x)

# 预测值和真实值的关系
data1 = test_y
data2 = predictions
fig, ax = plt.subplots(figsize=(8, 6))
ax.plot(data2,data1, &#39;o&#39;, label=&quot;data&quot;)
ax.legend(loc=&#39;best&#39;)&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-fba00d7cf1300546eff924d31bbe5dc7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;495&quot; data-rawheight=&quot;361&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-fba00d7cf1300546eff924d31bbe5dc7&quot; data-watermark-src=&quot;v2-546896e11fffb7b6590b73b8d2668a6d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;# 如果预测值&amp;gt;0,取为1；如果预测值&amp;lt;=0,取为-1.为回测做准备
for i in range(len(predictions)):    
    if predictions[i]&amp;gt;0:
        predictions[i]=1    elif predictions[i]&amp;lt;=0:
        predictions[i]=-1

# 将预测值与时间整合作为回测数据
cc = np.reshape(predictions,len(predictions), 1)
databacktest = pd.DataFrame()
databacktest[&#39;date&#39;] = datatime
databacktest[&#39;direction&#39;]=np.round(cc)&lt;/code&gt;&lt;p&gt;每个模型做两次回测，第一次回测（后文简称回测1）为直接以LSTM预测值在沪深300上做单：若LSTM预测值为1，买入并持有5day（若之前已持仓，则更新持有天数），若LSTM预测值为-1，若为空仓期，则继续空仓，若已持有股票，则不更新持有天数；&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;第二次回测（后文简称回测2）为以LSTM为择时指标，与StockRanker结合在3000只股票做单：若LSTM预测值为1，则允许StockRanker根据其排序分数买入股票，若LSTM预测值为-1，若为空仓期，则继续空仓，若已持有股票，则禁止StockRanker买入股票，根据现有股票的买入时间，5天内清仓；&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b1e30f42a79e874c0bc3b2d1a395035f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;136&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b1e30f42a79e874c0bc3b2d1a395035f&quot; data-watermark-src=&quot;v2-78e81f4dd1c057e0a56c0d4d160d6ee1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;1)future_return_5是否二极化处理比较&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对于future_return_5的处理分为两种情况，一种为直接将future_return_5作为output进行模型训练，二是将future_return_5二极化（future_return_5&amp;gt;0,取1；future_return_5&amp;lt;=0,取-1），然后将二极化后的数据作为output进行模型训练。&lt;/p&gt;&lt;p&gt;两种处理方法的回测情况如图4，图5。由于模型每次初始化权重不一样，每次预测和回测结果会有一些差别，但经过多次回测统计，直接将future_return_5作为output进行模型训练是一个更好的选择。在本推文接下来的讨论中，将会直接将future_return_5作为output进行模型训练。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-03bdabfee8f59a75e6eda470baeb893d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;468&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-03bdabfee8f59a75e6eda470baeb893d&quot; data-watermark-src=&quot;v2-2fadda2fb35a9479a343c43dda2bb81c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2ee3e51fe1ab0a31f5564506a9cbb7ec_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;474&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2ee3e51fe1ab0a31f5564506a9cbb7ec&quot; data-watermark-src=&quot;v2-dbe6b9707d8cfe131f5adb6cb63350d7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2)在权重上施加正则项探究&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;神经网络的过拟合：在训练神经网络过程中，“过拟合”是一项尽量要避免的事。神经网络“死记”训练数据。过拟合意味着模型在训练数据的表现会很好，但对于训练以外的预测则效果很差。原因通常为模型“死记”训练数据及其噪声，从而导致模型过于复杂。本推文使用的沪深300的数据量不是太多，因此防止模型过拟合就尤为重要。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;训练LSTM模型时，在参数层面上有两个十分重要的参数可以控制模型的过拟合：Dropout参数和在权重上施加正则项。Dropout是指在每次输入时随机丢弃一些features，从而提高模型的鲁棒性。它的出发点是通过不停去改变网络的结构，使神经网络记住的不是训练数据本身，而是能学出一些规律性的东西。正则项则是通过在计算损失函数时增加一项L2范数，使一些权重的值趋近于0，避免模型对每个feature强行适应与拟合，从而提高鲁棒性，也有因子选择的效果；在1)的模型训练中，我们加入了Dropout参数来避免过拟合。接下来我们尝试额外在权重上施加正则项来测试模型的表现。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;回测结果如图6，加入正则项之后回测1和回测2的最大回撤均有下降，说明加入正则项后确实减轻了模型的过拟合。比较加入正则项前后回测1的持仓情况，可以看到加入正则化后空仓期更长,做单次数减少(19/17)，可以理解为：加入正则项之后，模型会变得更加保守。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;正则项的问题：经过试验,对于一个LSTM模型来说，正则项的参数十分重要，调参也需要长时间尝试，不合适的参数选择会造成模型的预测值偏正分布(大部分预测值大于0)或偏负分布，从而导致预测结果不准确，而较好的正则参数会使模型泛化性非常好(图6所用参数训练出来的模型的预测值属于轻度偏正分布)。本文之后的讨论仍会基于未加权重正则项的LSTM模型。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-33156ad39591613a03c2f4001326ae99_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;473&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-33156ad39591613a03c2f4001326ae99&quot; data-watermark-src=&quot;v2-5310c6835ceeb0f0c32e6804f2fc2c41&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3)双输入模型探究&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;除了传统的Sequential Model(一输入，一输出)外，本推文还尝试构建了Functional Model(支持多输入，多输出)。前面提到的features处理方法丢失了一项重要的信息：价格的高低。相同的input处在3000点和6000点时的future_return_5可能有很大不同。因此，本文尝试构建了&quot;二输入一输出&quot;的Functional Model：标准化后的features作为input输入LSTM，LSTM层的输出结果和一个指标-label(label=np.round(close/500))作为input输入后面的Dense层，最终输出仍为future_return_5(图7)。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1960872c7a2a2199ea4a906552f861f8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;177&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1960872c7a2a2199ea4a906552f861f8&quot; data-watermark-src=&quot;v2-d3ec043369162e1ff233548b5d6a6720&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;部分代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;# LSTM与stockranker配合回测
class conf:    start_date = &#39;2010-01-01&#39;    end_date=&#39;2017-05-01&#39;    # split_date 之前的数据用于训练，之后的数据用作效果评估    split_date = &#39;2015-01-01&#39;    instruments = D.instruments(start_date, end_date)    
    label_expr = [&#39;return * 100&#39;, &#39;where(label &amp;gt; {0}, {0}, where(label &amp;lt; -{0}, -{0}, label)) + {0}&#39;.format(20)]    # 持有天数，用于计算label_expr中的return值(收益)    hold_days = 5
    # 特征    features = [&#39;close_5/close_0&#39;,  # 5日收益    &#39;close_10/close_0&#39;,  # 10日收益    &#39;close_20/close_0&#39;,  # 20日收益    &#39;avg_amount_0/avg_amount_5&#39;,  # 当日/5日平均交易额    &#39;avg_amount_5/avg_amount_20&#39;,  # 5日/20日平均交易额    &#39;rank_avg_amount_0/rank_avg_amount_5&#39;,  # 当日/5日平均交易额排名    &#39;rank_avg_amount_5/rank_avg_amount_10&#39;,  # 5日/10日平均交易额排名    &#39;rank_return_0&#39;,  # 当日收益    &#39;rank_return_5&#39;,  # 5日收益    &#39;rank_return_10&#39;,  # 10日收益    &#39;rank_return_0/rank_return_5&#39;,  # 当日/5日收益排名    &#39;rank_return_5/rank_return_10&#39;,  # 5日/10日收益排名    &#39;pe_ttm_0&#39;,  # 市盈率TTM    ]
# 给数据做标注：给每一行数据（样本）打分，一般分数越高表示越好
m1 = M.fast_auto_labeler.v5(
    instruments=conf.instruments, start_date=conf.start_date, end_date=conf.end_date,
    label_expr=conf.label_expr, hold_days=conf.hold_days,
    benchmark=&#39;000300.SHA&#39;, sell_at=&#39;open&#39;, buy_at=&#39;open&#39;
)

# 计算特征数据
m2 = M.general_feature_extractor.v5(
    instruments=conf.instruments, start_date=conf.start_date, end_date=conf.end_date,
    features=conf.features)

# 数据预处理：缺失数据处理，数据规范化，T.get_stock_ranker_default_transforms为StockRanker模型做数据预处理
m3 = M.transform.v2(
    data=m2.data, transforms=T.get_stock_ranker_default_transforms(),
    drop_null=True, astype=&#39;int32&#39;, except_columns=[&#39;date&#39;, &#39;instrument&#39;],
    clip_lower=0, clip_upper=200000000)

# 合并标注和特征数据
m4 = M.join.v2(data1=m1.data, data2=m3.data, on=[&#39;date&#39;, &#39;instrument&#39;], sort=True)

# 训练数据集
m5_training = M.filter.v2(data=m4.data, expr=&#39;date &amp;lt; &quot;%s&quot;&#39; % conf.split_date)

# 评估数据集
m5_evaluation = M.filter.v2(data=m4.data, expr=&#39;&quot;%s&quot; &amp;lt;= date&#39; % conf.split_date)

# StockRanker机器学习训练
m6 = M.stock_ranker_train.v2(training_ds=m5_training.data, features=conf.features)

# 对评估集做预测
m7 = M.stock_ranker_predict.v2(model_id=m6.model_id, data=m5_evaluation.data)

# 生成卖出订单：hold_days天之后才开始卖出；对持仓的股票，按StockRanker预测的排序末位淘汰
if databacktest[&#39;direction&#39;].values[databacktest.date==current_dt]==-1: # LSTM择时卖    instruments = list(reversed(list(ranker_prediction.instrument[ranker_prediction.instrument.apply(lambda x: x in equities and not context.has_unfinished_sell_order(equities[x]))])))        
     for instrument in instruments:            
         if context.trading_calendar.session_distance(pd.Timestamp(context.date[instrument]), pd.Timestamp(current_dt))&amp;gt;=5:
                context.order_target(context.symbol(instrument), 0)if not is_staging and cash_for_sell &amp;gt; 0:
    instruments = list(reversed(list(ranker_prediction.instrument[ranker_prediction.instrument.apply(lambda x: x in equities and not context.has_unfinished_sell_order(equities[x]))])))        
    # print(&#39;rank order for sell %s&#39; % instruments)    for instrument in instruments:
        context.order_target(context.symbol(instrument), 0)
        cash_for_sell -= positions[instrument]            
        if cash_for_sell &amp;lt;= 0:                
            break
            
# 生成买入订单：按StockRanker预测的排序，买入前面的stock_count只股票
if databacktest[&#39;direction&#39;].values[databacktest.date==current_dt]==1: # LSTM择时买    buy_dt = data.current_dt.strftime(&#39;%Y-%m-%d&#39;)
    context.date=buy_dt
    buy_cash_weights = context.stock_weights
    buy_instruments = list(ranker_prediction.instrument[:len(buy_cash_weights)])
    max_cash_per_instrument = context.portfolio.portfolio_value * context.max_cash_per_instrument        
    for i, instrument in enumerate(buy_instruments):
        cash = cash_for_buy * buy_cash_weights[i]            
        if cash &amp;gt; max_cash_per_instrument - positions.get(instrument, 0): # 确保股票持仓量不会超过每次股票最大的占用资金量            cash = max_cash_per_instrument - positions.get(instrument, 0)            
        if cash &amp;gt; 0:
            context.order_value(context.symbol(instrument), cash)
            buy_dates[instrument] = current_dt

context.date = buy_dates&lt;/code&gt;&lt;p&gt;回测结果如图8。由回测结果可以看出，加入指示标后的LSTM模型收益率相对下降，但是回撤更小。LSTM预测值小于0的时间段覆盖了沪深300上大多数大幅下跌的时间段,虽然也错误地将一些震荡或上涨趋势划归为下跌趋势。或许这是不可避免的，俗话说高风险高回报，风险低那么回报也不会非常高，高回报和低风险往往不可兼得。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3b68f728634de83ee3dd394e8de8e1a1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;472&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-3b68f728634de83ee3dd394e8de8e1a1&quot; data-watermark-src=&quot;v2-49198b1d13b4b81b1149699dc27afb39&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;结论与展望&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;结论：&lt;/b&gt;本推文通过探究性地应用LSTM对沪深300未来五日收益率进行预测，初步说明了LSTM Networks是可以用在股票市场上的。由于LSTM更适用于处理个股/指数，因此，将LSTM作为择时模型与其他选股模型配合使用效果较好。利用LSTM模型对沪深300数据进行预测并将结果作为择时信号，可以显著改善stockranker选股模型在回测阶段的回撤。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;展望：&lt;/b&gt;由于个股数据量较少，LSTM模型的可扩展程度和复杂度受到很大制约，features的选择也受到限制（若input的features太多，而data较少的话，会使一部分features不能发挥出应有的作用，也极易造成过拟合）。将来我们希望能在个股/指数的小时或分钟数据上测试LSTM的性能。另外，将探究LSTM模型能否将属于一个行业的所有股票data一起处理也是一个可选的方向。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;说明：&lt;/b&gt;由于每次训练LSTM模型权重更新情况不同以及Dropout的随机性，LSTM模型的每次训练训练结果都会有差异。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;提示：&lt;/b&gt;由于LSTM涉及参数众多，目前还不能保证LSTM模型的稳定性，本推文所附回测结果均为多次训练模型后选取的较为理想的情况，目的是说明LSTM是可以应用于股票市场的以及将其作为择时模型是可能的。本推文所述以及提供的代码仅供探究及讨论，若要形成一个在股票市场比较实用的LSTM模型，还需要在features选择、模型构建、模型参数选择以及调优等方面花费大量精力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>量化家</author>
<guid isPermaLink="false">2018-07-24-40449368</guid>
<pubDate>Tue, 24 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>【中信证券】量化实习生招聘（2019应届生）</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-07-24-40441698.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40441698&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中信证券招聘量化实习生，优异者可留用（2019年校园招聘）。&lt;/p&gt;&lt;p&gt;实习招聘部门：中信证券股权衍生品业务线&lt;/p&gt;&lt;p&gt;股权衍生品业务线是中信证券开展权益类产品交易的业务部门，其业务模式是依托中信证券的信用和资产负债表，作为产品设计者和交易对手方，面向机构和零售客户提供种类丰富的与权益资产相关的投融资产品，满足客户各项需求。 &lt;/p&gt;&lt;p&gt;工作地：北京 亮马桥 中信证券总部。 &lt;/p&gt;&lt;p&gt;有意者请将简历寄送至EQ_HR@citics.com，2018年8月15日之前有效。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;职责： &lt;/p&gt;&lt;p&gt;1、负责数据整理、挖掘、统计分析、展示； &lt;/p&gt;&lt;p&gt;2、从数据中发现规律，为量化分析提供支持； &lt;/p&gt;&lt;p&gt;3、开发量化模型策略； &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;要求：&lt;/p&gt;&lt;p&gt;1、2019年毕业的硕士、博士。&lt;/p&gt;&lt;p&gt;2、知名院校的数学/统计、物理、计算机、电子或其他相关理工科专业； &lt;/p&gt;&lt;p&gt;3、一流的概率统计能力，严谨的研究习惯； &lt;/p&gt;&lt;p&gt;4、有一定的编程能力，至少熟悉Python和C++其中一门编程语言； &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;加分项： &lt;/p&gt;&lt;p&gt;1、顶级的研究能力，有领先的学术成果； &lt;/p&gt;&lt;p&gt;2、学科竞赛、ACM-ICPC获奖； &lt;/p&gt;&lt;p&gt;3、熟悉深度学习原理和基本模型，熟练使用 Tensorflow，并能够灵活的解决实际问题。有过大型机器学习、数据挖掘实践项目者优先； &lt;/p&gt;&lt;p&gt;4、爬虫以及文本处理项目经历； &lt;/p&gt;&lt;p&gt;5、熟悉linux系统的非桌面环境, 良好的编码风格； &lt;/p&gt;</description>
<author>zhiqiang</author>
<guid isPermaLink="false">2018-07-24-40441698</guid>
<pubDate>Tue, 24 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>策略||缠论</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-07-23-40365211.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40365211&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;一． 缠论理论体系梳理及精髓解读&lt;/b&gt;&lt;br&gt;&lt;b&gt;1.1 K线包含处理目的：清洗K线数据，识别顶底分型&lt;/b&gt;&lt;br&gt;相邻两K线可能出现包含关系（ 注： K线包含影线，且不分阴阳线）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-77a4e20aa1f3f37b5445dfdd3c659b22_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;252&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-77a4e20aa1f3f37b5445dfdd3c659b22&quot; data-watermark-src=&quot;v2-3c9ce02a9f838d4c5d0d2944527f3b58&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-acecc35dcab111429f574b6939731977_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;448&quot; data-rawheight=&quot;255&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-acecc35dcab111429f574b6939731977&quot; data-watermark-src=&quot;v2-373053262ff437d6b247fadafb0b48d1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;1.2 分型：对局部高低点的识别（ K线已经过包含处理）&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2ec90effb7ea2a6cccfe42e202e86f8a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;255&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2ec90effb7ea2a6cccfe42e202e86f8a&quot; data-watermark-src=&quot;v2-f6d6f773ebdf6195cb77a64b82e208e3&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;1.3 笔：对阶段性高低点的识别（ K线已经过包含处理）&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-531677a7cc6175114502dc9e0d2db4d6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;148&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-531677a7cc6175114502dc9e0d2db4d6&quot; data-watermark-src=&quot;v2-9899fe874d70723ca4f7a35f404dfe26&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;两个相邻的顶和底，并且顶分型和底分型之间至少有一根独立的K线，这就构成一笔，笔从其构成的K线走向看分为向上笔和向下笔。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b179f3df18fbdac3b584476e6297a69e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;212&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b179f3df18fbdac3b584476e6297a69e&quot; data-watermark-src=&quot;v2-e76f65c6d34e3f83fc13f9e531502fdc&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;将K线图的分型按照一顶一低交替出现的方式进行笔的连接，遇到连续两&lt;br&gt;个分型是同类分型时，笔将延伸， 忽略前面出现的，连接后面出现的分型。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.4 线段：&lt;/b&gt;&lt;/p&gt;&lt;b&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-963e091df9696d9481533bda8f806d72_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;566&quot; data-rawheight=&quot;172&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-963e091df9696d9481533bda8f806d72&quot; data-watermark-src=&quot;v2-6362ee719e5532f3289c09f9ab2f4dc8&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;/b&gt;&lt;p&gt;连续的三笔之间若存在重叠部分，其起点和终点之间的连线为线段。&lt;br&gt;同样，线段依据走势分为向上线段和向下线段。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fc3977988f50bc0279019c85f0400487_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;176&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-fc3977988f50bc0279019c85f0400487&quot; data-watermark-src=&quot;v2-6eb17792d75aeba2a098d811f58a2d9a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;线段产生以后，若不在相反方向产生新线段，那么这个线段在同方向上继续延伸，否则称为线段被线段破环。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d49d9647e71aa215004198f51a8a436c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;147&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d49d9647e71aa215004198f51a8a436c&quot; data-watermark-src=&quot;v2-5fdadae63f7a5a7290656036bac14539&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;•  向上线段用笔的序列表示成： S1X1S2X2…Sn。反向往下运动的笔序列X1X2…Xn称&lt;br&gt;  之为向上线段的特征序列， 同理 S1S2…Sn序列称为向下线段的特征序列。&lt;/p&gt;&lt;p&gt;•  特征序列两相邻元素之间没有重叠的区间，称为序列的缺口。&lt;br&gt;•  对于特征序列，将每一元素看成一K线，也存在所谓的包含关系，也可以对此进行K线&lt;br&gt;  合并处理。经过处理的特征序列，称为标准特征序列。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-befe74e7113d2c83bf82c6e8432e4d77_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;172&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-befe74e7113d2c83bf82c6e8432e4d77&quot; data-watermark-src=&quot;v2-94f865afaab650085cc877ca5ea6c010&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;准特征序列分型中，第一二元素无缺口&lt;br&gt;• 向上线段出现顶分型，线段结束于该顶分型的顶&lt;br&gt;• 向下线段出现底分型，线段结束于该底分型的底&lt;br&gt;&lt;/p&gt;&lt;p&gt;标准特征序列分型中，第一二元素存在缺口&lt;br&gt;• 向上线段出现顶分型，如果从该分型最高点开始的向下一笔开始的序列的特征序列出现底      分型，并且在完成底分型前不破顶分型最高点，那么该线段在该顶分型的高点处结束&lt;br&gt;• 向下线段同理&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.5 中枢&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8dc78093dfda14be87ec0cc124d6ce5c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;553&quot; data-rawheight=&quot;134&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-8dc78093dfda14be87ec0cc124d6ce5c&quot; data-watermark-src=&quot;v2-e00783fac3aed0f327361bea2038034a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;•  某级别走势类型中，被至少三个连续次级别走势类型所重叠的部分称为&lt;b&gt;中枢&lt;/b&gt;。向上走势 考察下上下…的次级别，向下走势考察下上下…的次级别。&lt;br&gt;•  对上升的线段，取其回撤构成中枢，对下降的线段，取其回升构成中枢。&lt;br&gt;•  中枢三种生长方式： 新生（前后两个中枢波动区间无重合）， 延伸（前后两个中枢中枢 区间重合），扩展（前后两个中枢中枢区间无重合，波动区间有重合）。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7ad414ff98321bbf3d6fd6934a61a341_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;558&quot; data-rawheight=&quot;151&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7ad414ff98321bbf3d6fd6934a61a341&quot; data-watermark-src=&quot;v2-9e27310c196afde637c39d661ff2aba1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;根据中枢的相对位置关系和数量，可将走势类型分为两类：&lt;br&gt;•  一个已完成的走势类型若只包含一个中枢，称其为盘整。&lt;br&gt;•  一个已完成的走势类型若包含两个以上的同向中枢，称其为趋势。中枢依次向上且波&lt;br&gt;动区间无重合，为上涨趋势；中枢依次向下且波动区间无重合，为下降趋势。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2c0c3c2a526aeb33898f9818ea5eb183_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;160&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2c0c3c2a526aeb33898f9818ea5eb183&quot; data-watermark-src=&quot;v2-95c3d59ba1030d8bef2fcaa4b835f174&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;背驰：是指围绕同一中枢的前后两个次级别波动，后面的力度弱于前面。力度有多种衡量方式，缠论中用MACD， MACD又有三种标准（红绿柱子面积/红绿柱子高度/黄白线高度）。&lt;br&gt;&lt;/p&gt;&lt;p&gt;趋势背驰：趋势的最后一个中枢前后两个次级别波动，必须创新高/新低。例如， b段对应&lt;br&gt;的MACD柱子面积（向上看红柱子，向下看绿柱子）比a段对应的面积小,且b段创新高，这&lt;br&gt;就构成标准的趋势背驰。&lt;br&gt;&lt;/p&gt;&lt;p&gt;盘整背驰：与趋势背驰类似，但定义相对宽松。 通常比较的是同向的相邻两个次级别波动，并且不需要考虑是否创新高/低。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.7 三类买卖点&lt;/b&gt;&lt;/p&gt;&lt;b&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f9f98a85b0c2234ced68d6c5ffe438af_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;197&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f9f98a85b0c2234ced68d6c5ffe438af&quot; data-watermark-src=&quot;v2-972c09a34d91eac3266a7bfa56606722&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;/b&gt;&lt;p&gt;•  第一类买卖点由趋势背驰产生，第一类买卖点出现意味着原走势终结。&lt;br&gt;•  第二类买卖点出现在第一类买卖点之后，如果走势不创新低新高或者新低新高之后盘整背驰，都构成第二类买卖点。&lt;br&gt;•  第三类买卖点出现在最近的一个同级别中枢之上/之下，如果次级别离开后次级别回抽，回不到最近的一个同级别中枢中，则构成第三类买卖点，意味着中枢的新生或者中枢级别的扩展。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>量化家</author>
<guid isPermaLink="false">2018-07-23-40365211</guid>
<pubDate>Mon, 23 Jul 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
