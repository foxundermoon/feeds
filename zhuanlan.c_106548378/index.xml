<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>babyquant谈量化金融</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Tue, 14 Aug 2018 11:09:51 +0800</lastBuildDate>
<item>
<title>周山鑫：止盈不难，你得了解适合你的投资方式</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-08-13-41958882.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41958882&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ff0e1cffd93dd428370b3655ea0cdb20_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;　　现代人进投资市场，大都是为了赚钱。只有极少数的人是因为对投资市场的操作方法有兴趣而进入市场。换言之：对财富的兴趣如果大于对“追求投资市场的正确知识”，就会变成很危险的事情。因为：在投资市场中，很容易赚钱，但也很容易赔钱（赔钱的机会也不少）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　1，扛亏损。这种情况一般由不带止损操作造成。比如1102做多，计划好下破1102就出，结果破位之后发现指标有点低，想等回调之后再出，结果一下打到1098，又奢望1098能受支撑反弹，结果一下到1095之后舍不得割肉，结果是亏损越扛亏多。有人会说，我有时候不止损能扛回来。俗话说的好，常在河边走，哪有不湿鞋，可能你一次两次侥幸逃过，但只要遇到单边反方向，就会损失惨重，而且结果是一单把前面赚的都赔进去了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　2，锁单。锁单等于自杀！不要讲理论上解单如何如何简单，锁过单的投资者都知道，锁单容易解单难。锁单的结果一般是余额在增加，净值在不断减少，而且锁单距离越来越大。如遇到特殊情况，锁单一定注意两个原则：锁单距离不要超过5个点、少亏即是赢（讲亏损减少之后两个单都出）。举例：1102的多单，扛到1095之后，判断行情还要下（扛亏损之后分析行情一般带有很强的主观性），锁着，一锁金价就上，上破1108之后以为要上行了，割了空单，结果行情马上又下，来回折腾，心态越做越坏。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　3，激进。这包括分析、下单点把握和追单三方面。a，分析，在还没有明确的信号出现的时候就主观选择一个方向，然后开始下单。b，下单点，感觉自己计划的下单点不会到了，或者是在错过了理想的建仓点之后，随便在中间点建仓。这些都容易造成点位不好，不便于守利润，其次就是止损不好设置。比如我们计划在1102做多，下破1102追空，结果金价在1105一直下不去，感觉不会到1102了，就在1105建了多单，止损也放2-美金，结果一下打到1102扫损，然后金价一直维持在1102-1104之间盘整，并显示很强劲的下跌动能，这时很多投资者就按捺不住，在1102还未破位之前即提前空单进场，结果可能又是扫损，周山鑫认为这样来回诱导，对于投资者的心态影响特别大。而稳健的做法为：挂1102上一些的多单，止损设1100下方，这样3美金的止损即包括了两重强支撑，而且扫损之后可以顺势追单，何乐而不为。而如果价格到不了1102，挂单挂不上，我们并没有损失。c，盲目追单。举例1105做多，跌到1102看见行情还要下，出多单进空单，扫损之后以为要上，又多单进场……来回追，来回亏损。zsx加上壹叁玖壹陆捌玖而杜绝这种现象的方法是等破位之后追单，成功率会很高。而追单有技巧，单边行情中直接挂破位单，震荡行情中破位等回调再追。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　4，建仓时机不好。a，一般博回调，仅限于第一次试探时。比如昨日1102强支撑，第一次在此博回调很稳健，即便跌破1102，第一次一般也会受支撑于1100，之后反弹到1103-1105之间，这时也有机会出来。而如果第一次没有把握到，也不要因为看见别人赚钱了，而第二次也急着进场。b选好建仓周期，尽量不要在交接盘、大周期收线前和大消息面出来前下单，比如美盘开盘前几分钟，四小时收线前几分钟和非农数据出来前等等，宁可等几分钟，这样可以参考的标志会更多，成功几率也会增加。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　5，拿不住利润，看见正数就想出单。这样下单的结果是：一单亏损会将九单盈利全输掉。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　基本上投资现货亏损就是由上述原因造成的。那究竟如何在现货市场赚钱呢？只有一种方法，而且只有一种方法！那就是：每天列好做单计划，计划包括今日操作区间和关键点位，然后严格在计划的点位下单，可多使用挂单，下单带好止损止盈（止盈远大于止损才符合我们以小博大的做单原则），然后不管，除非有特殊情况和很明显的信号，否则不中途出单，切忌修改止损止盈。其中，破位追单的成功率最高！这点对于平台稳定性有要求，平台就像是剑客手中的佩剑，一定要好使，稳定性稍差会造成无故扫损和点位突破的假象。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　文/周山鑫&lt;/p&gt;</description>
<author>周山鑫</author>
<guid isPermaLink="false">2018-08-13-41958882</guid>
<pubDate>Mon, 13 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>周山鑫：套单亏损不停歇，几分钟看完解决你的亏损问题</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-08-13-41894604.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41894604&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-820f22d0098d01d0bdce5e96bdd06eb1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;　　金价每一次的下探之后都会反弹，每一次的上升之后都有回落，几乎所有的走势也会如此，早间震荡，随后放量下行试探下方的低点，最后触底反弹，还是不改区间的运行！投资犹如下棋，棋艺高者能看出五步，七步甚至十几步，而棋艺低者只能看出两三步，高者顾大局，谋大势，不以一子一地为重，以最终赢棋为目标，低者则寸土必争，只为争一时之需，结果频频受困。趋势，一定要有长远眼光，投资，一定要有长远规划，而布局技巧是成功的关键。做投资，如果你的能力不足以支撑你现在的状况，那么你需要一位军师助你操控大局，一次选择，就是一次转折！一次尝试，就是一次机会！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　在金融市场中，盈亏永远是市场中不变的话题。作为人性而言，获利，是进入市场的目标，而亏损，是不愿意面对的结果，我想大部分都是想获利的，或者是想买房买车，或者是存私房钱，再或者是潇洒的生活。现在市面上的分析师太多，能让获利的有多少？大家的钱都是辛苦钱，哪能惊得起消磨。我明白很多朋友拿来做投资的钱是怎么来的，有的是在烈日炎炎下辛勤劳作获取的工资，有的是家里正常一个月的开销，更有甚者可能是孩子的奶粉钱。我知道我说的这些并不夸张，我懂你拿出这些钱出来做投资其实是想让家人和自己的生活过的更好，这些都是人之常情，我懂！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　但是这个市场谁能保证百分之百的获利呢，刚开始拿20万的资金去做，第一平台做，亏了5万，换个平台做做吧，又亏了，再换，终于找到一个好的平台了，你却因为资金量小了抵抗不了风险黯然离场。对于普通的你来说，损失的又是什么？也许是你努力奋斗一个月的时间、一家人一个月的生活费亦或者是孩子的奶粉钱。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　当你在这个市场上亏损了之后，我可以想象你那种慌张无措的样子，你会去找到知道你的老师诉苦，希望可以从他们哪里得到一丝的安慰和鼓励，甚至是可以看到一点点可以回本的希望。这时候你开始迷茫不知道怎么面对现在的处境，你害怕又一次的重蹈覆辙，你这个时候的心情，我懂！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　这个时候的你是无奈的，因为你所经历的这些你不知道怎么把它宣泄出来。你不敢告诉自己的家人和朋友，一方面是怕他们会担心你，更有一方面是愧对自己的家人，对于这种事情怎么开口告诉家人，怕看到家人对你失望的眼神。所以你只能把它放在心里，或者是更加疯狂的在各种部落，论坛翻找更多的贴子，找更多的老师，希望可以找到一个静静地听你讲过去的事，把你从崩溃的边缘拉回来。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　如果你在这个时候发现了我，只能说明是缘分，佛说，修百世方可同舟渡，修千世方能同枕眠，前生五百次的凝眸，换今生的擦肩，是命运的安排，因为懂你的心境，所以我会尽我所能给你最有利的。如果我的努力和付出可以使你走出困境，那么我愿意，能让你的资金不再跳水，能挽回之前的损失，这就是我的责任，是对我能力的认可，是体现我价值的最好回报，每次我会给一个最稳健的单子，这样你不用有心里上的压力，不用承受太多，而我不辜负自己的努力，没有辜负客户的信任，这就是我要做的事，看到客户开心的笑脸才是我最骄傲的事情，只要你需要，我就在你身边，从未走远，只要你伸出了需要援助的手，我就会牢牢的握住。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　文/周山鑫/zsx1398629&lt;/p&gt;</description>
<author>周山鑫</author>
<guid isPermaLink="false">2018-08-13-41894604</guid>
<pubDate>Mon, 13 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>策略||框架</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-08-07-41446711.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41446711&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;我们的回测可能会告诉我们策略能赚钱，其实有的时候策略在说谎。也许我们使用的回测数据很干净，但它给出的结果往往出乎我们的意料。我们需要深入挖掘，了解金融市场幕后发生的事情。&lt;/h2&gt;&lt;h2&gt;让我们将这些有问题的回测原因分为两个：1、一般偏差和2、特定偏差（具体而言，我们指的是资产类别或衍生物特有的）。在本文中，我们关注一般偏差&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;一般偏差&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;以下是一些影响我们的回测的因素。&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;持有成本&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;持有成本是我们进行交易时支付的费用。开仓持有的时间越长，成本越高。这些可能不适用于所有产品。但外汇，黄金，差价合约等某些商品会有。&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;幸存者偏差&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;i&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Survivorship_bias&quot;&gt;幸存者偏差的&lt;/a&gt;官方定义&lt;a href=&quot;https://en.wikipedia.org/wiki/Survivorship_bias&quot;&gt;：&lt;/a&gt;&lt;/i&gt;&lt;/h2&gt;&lt;h2&gt;幸存者偏差（Survivorship bias），另译为“生存者偏差”或“存活者偏差”，驳斥的是一种常见的逻辑谬误（“&lt;a href=&quot;https://baike.baidu.com/item/%E8%B0%AC%E8%AF%AF&quot;&gt;谬误&lt;/a&gt;”而不是“偏差”），这个被驳斥的逻辑谬误指的是只能看到经过某种筛选而产生的结果，而没有意识到筛选的过程，因此忽略了被筛选掉的关键信息。&lt;/h2&gt;&lt;h2&gt;&lt;i&gt;用简单的话说：&lt;/i&gt;&lt;/h2&gt;&lt;h2&gt;生存偏见指的是人们忽略了失败的流程，因为他们只看到成功的流程。&lt;/h2&gt;&lt;h2&gt;让我们来看看幸存者偏差如何影响我们的回测&lt;/h2&gt;&lt;h2&gt;&lt;i&gt;&lt;b&gt;选择问题&lt;/b&gt;&lt;/i&gt;&lt;/h2&gt;&lt;h2&gt;我们创建了一个策略，并根据策略选出了股票，进行了回测，并且回测数据很漂亮。&lt;/h2&gt;&lt;h2&gt;就出来了幸存者偏差，我们用到的回测数据都是目前还在市场交易。退市的股票我们并没有包含在内，我们还需要考虑这些股票，让策略的回测会不过滤出这些退市的股票。&lt;/h2&gt;&lt;h2&gt;黑天鹅&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-811d5b5d705d75c07c807400c5189db6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;371&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-811d5b5d705d75c07c807400c5189db6&quot; data-watermark-src=&quot;v2-0e19233a43197e91e1244cf9da7d9a11&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;图2：一只天真无邪的黑天鹅&lt;/p&gt;&lt;h2&gt;&lt;b&gt;这里举个‘栗子’&lt;/b&gt;：&lt;/h2&gt;&lt;h2&gt;算了，不举了，有兴趣的去搜索下2016年11月11日光棍节晚上国内期货市场的情况。&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;交易成本/佣金&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;交易成本有3种类型：1、固定 2、变量 3、1和2的混合。&lt;/h2&gt;&lt;h2&gt;这块儿目前国内的股票手续费都是比较低的，但是为了严谨，或者方便跨品种使用，最好加入该模块，从结果中减去或添加损益。&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;滑点和重新报价&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;在回测过程中，您几乎总是按预期价格进行成交（即使市场没有以该价格进行交易）。但是，在实时交易中，您可能无法获得所需的价格。可能会面临滑点和重新报价。&lt;/h2&gt;&lt;h2&gt;&lt;i&gt;&lt;b&gt;滑点&lt;/b&gt;：订单的预定价格和实际价格之间的差异。&lt;/i&gt;&lt;/h2&gt;&lt;h2&gt;&lt;i&gt;&lt;b&gt;重新报价&lt;/b&gt;：详情了解下国内两家交易所的报价方式，上交所，深交所都有文档&lt;/i&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;&lt;a href=&quot;http://www.futuresmag.com/2011/01/31/contract-specs-know-what-you-are-trading&quot;&gt;合同规格的&lt;/a&gt;变更&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;券商或者交易所可以更改其产品的合同规格。例如，他们可能会增加保证金要求，更改结算规格或产品的合约规模。&lt;/h2&gt;&lt;h2&gt;这块内容主要针对的是国内目前的融资融券，以及期权。这两个部分的回测框架和股票的框架并不相同，特别是期权，而期权这样的衍生品，目前也越来越活跃，并将会成为主流交易产品。&lt;/h2&gt;&lt;h2&gt;要想做好一个好的回测框架，通常就是这样。要了解交易市场微观结构（也就是幕后发生的事情）。&lt;/h2&gt;&lt;h2&gt;“量化家”完整灵活的策略回测框架，让您的策略在回测中展现更为精准的数据。&lt;/h2&gt;</description>
<author>量化家</author>
<guid isPermaLink="false">2018-08-07-41446711</guid>
<pubDate>Tue, 07 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>策略||白马股</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-08-03-41207512.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41207512&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;绩优白马股&lt;/b&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;绩优白马股相关研究简介&lt;br&gt;&lt;/p&gt;&lt;p&gt;按字面理解，绩优白马股是指业绩优秀、稳定成长的公司。围绕公司业绩：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;PB-ROE 模型对 A 股市场的行业层面约束效果不明显；所以用 ROE 指标截面比较，行业内选股。&lt;/li&gt;&lt;li&gt;将 ROE 分解为杜邦三因子，通过因子收益归因发现，销售利润率和资产周转率是显著的收益来源，而财务杠杆在 A 股市场范围内，对收益无明显的解释作用。因此，分别通过销售利润率，资产周转率和 ROE 三部分来 对公司经营质量进行评价打分。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;绩优白马股的反思与启示&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对绩优白马股的定义并无统一标准，本报告将用两类特征作为切入点，研究绩优白马股：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;ROE长期水平，以及波动特征。&lt;/li&gt;&lt;li&gt;利润长期水平。 &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;从ROE到净利润，再到股票收益率&lt;/p&gt;&lt;p&gt;&lt;b&gt;绩优白马股:从基本面到二级市场的传导&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;长期高 ROE的公司研究&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们采用 2007 年至 2016 年年报数据，对过去十年的上市公司年报，按照长期ROE 的高低进行了梳理。首先我们将全市场上市 10 年以上的股票，按照 ROE的长期波动率分为两类，即 ROE 稳定组和 ROE 高波动组。其中，ROE 稳定组的列表如下: &lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-414740c7e86aa1f0b670da205c4d724f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;266&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-414740c7e86aa1f0b670da205c4d724f&quot; data-watermark-src=&quot;v2-0e8cf00499c0f7371406df42c0cc360f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f860f88055d4103aa134e110eed32bd5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;461&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f860f88055d4103aa134e110eed32bd5&quot; data-watermark-src=&quot;v2-e9d6a9d9b3e07922fd6210ae0387e8a7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上表共有 237 家公司，这些公司过去 10 年的 ROE 波动率均未超过 ROE 均值水平。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;ROE 与净利润增长的关系&lt;/b&gt;&lt;br&gt;ROE 波动组中，长期 ROE 和净利润复合年增长率的关系，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e2346be96604c2e27096cc005b651517_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;408&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e2346be96604c2e27096cc005b651517&quot; data-watermark-src=&quot;v2-942a1eea87c58c55372b9d325756279e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE高波动组中，长期 ROE和净利润复合年增长率 &lt;/p&gt;&lt;p&gt;图中显示，在 ROE 高波动组中，净利润在 ROE 每个固定位臵上的分布较为分散，长期 ROE 对净利润复合年增长率的解释度不强。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE 稳定组中，长期 ROE 和净利润复合年增长率的关系，如下表所示：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-73c0a402238d88394b261605bc585abe_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;448&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-73c0a402238d88394b261605bc585abe&quot; data-watermark-src=&quot;v2-81b5e67ef2801b2f0e3fbf1ca2e59fe3&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE 稳定组中，长期 ROE 和净利润复合年增长率 &lt;/p&gt;&lt;p&gt;如上图所示，在 ROE 稳定组中，长期 ROE 较好的解释了净利润复合年增长率。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;净利润增长与股票收益率的关系&lt;/b&gt;&lt;/p&gt;&lt;p&gt;ROE 波动组中，净利润复合年增长率与股票收益率的关系，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e28564cb3d10938bd73e7119be256831_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;398&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e28564cb3d10938bd73e7119be256831&quot; data-watermark-src=&quot;v2-6468e029818749d23da369066cabddaa&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE高波动组中，净利润复合年增长率和股票年化收益率 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图显示，随着净利润复合年增长率上升，股票十年年化收益率也上升。即便在 ROE 高波动组当中，长期净利润增长也能较好地解释不同股票长期收益率的差异。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE 稳定组中，净利润复合年增长率与股票收益率的关系，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c1a21170ba835c9fe5f92d1e5f206ab8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;401&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c1a21170ba835c9fe5f92d1e5f206ab8&quot; data-watermark-src=&quot;v2-97e763c6935e5dee3427f3aa0ff69f65&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE稳定组中，净利润复合年增长率和股票年化收益率 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图显示，净利润复合年增长率和股票年化收益率正相关。在 ROE 稳定组当中，股票之间长期净利润增长的差异解释了股票长期收益率的差异。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;至此，我们总结出在 ROE 不同组当中的传导逻辑:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在 ROE 稳定组中，长期 ROE 较好地解释了长期净利润增长，而长期净利润又显著影响了股票长期收益率。从而，此类股票的长期收益主要取决于长期 ROE 水平的差异。&lt;/li&gt;&lt;li&gt;在 ROE 高波动组中，ROE 本身对长期净利润增长无显著解释。此类股票的长期收益主要受到长期净利润增长率的影响。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;ROE 稳定组中寻找绩优白马股&lt;/b&gt;&lt;br&gt;在 ROE 稳定组中，我们选择长期 ROE 综合水平最高的前 20 名，分析这类公司 ROE，净利润和二级市场十年收益率的情况，如下表所示:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE稳定组中，ROE均值最高top20的年报 ROE(单位:%) &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0295b0e22ef98f7ef44e72f9b1c57ce2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;257&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0295b0e22ef98f7ef44e72f9b1c57ce2&quot; data-watermark-src=&quot;v2-4f2afeb19cc164e05acc4ce6e22cd71d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e9e63d94181e7995b507ad8252acb46a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;63&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上表中这 20 家公司，从 2007 年至 2016 年的 ROE 来看，呈现出“ROE 波动小，整体水平高”的特征。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE 稳定组中，ROE 最高 top 20 的业绩指标和股票收益率统计(单位: %) &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-26349f8ef3a3847245e96f9b0a687f01_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;175&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-26349f8ef3a3847245e96f9b0a687f01&quot; data-watermark-src=&quot;v2-eed143f738e1afa339f8ab26dfe0945d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;表中显示这类公司的长期 ROE 能够保持较高水平，长期净利润复合增长率较高， 二级市场长期收益率也显著高于市场平均水平。值得一提的是，这类公司的长期 ROE 水平，与其长期净利润复合增长率基本相当(长期净利润增长既没有过高，保证了可持续性;也显著比多数公司高，反映了公司良好的成长能力)。此外，此类公司的长期负债结构也呈现出稳定的态势: &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;ROE 稳定组中，ROE 均值最高 top 20 的资产负债率(单位: %)&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f5efc759be986a21e3629d5fe6e74663_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;315&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f5efc759be986a21e3629d5fe6e74663&quot; data-watermark-src=&quot;v2-ebe4ded6eeedda9678d489f1e9077c3d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上表显示，无论宏观或行业景气或不景气时，公司的负债率都比较稳定。负债率稳定是公司经营稳定的体现，比一般公司更能抵御经济周期风险。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;绩优白马股在 ROE，利润等方面所展现出的特征，有助于我们去理清选股的目 标。更有针对性地制定选股模型。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;茅台魔咒：注定还是巧合？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;多年以来，A 股市场的股票存在“茅台魔咒”。那么这是巧合?还是其中另有原因?本章我们从绩优白马股的角度，来就此进行一番探讨。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;茅台魔咒:股价超越茅台，就意味着要调整?&lt;/b&gt;&lt;/p&gt;&lt;p&gt;每当一只股票价格超越贵州茅台之后，随之而来都会经历一波显著的调整。我们选取了 2007 年至 2017 年的 A 股市场具有代表性的 25 个例子: &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;2007-2017 年股价超越茅台的典型案例 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-338f9a8ab848e77663d72fd08502358b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;302&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-338f9a8ab848e77663d72fd08502358b&quot; data-watermark-src=&quot;v2-3384b0e9ae552aa5b65bbf4cfe6a2f2c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上表显示，多数股票都是在牛市当中，股价超越茅台的。07 年底附近，牛市有两只股票股价超过茅台，分别是中国船舶和山东黄金;10 年和 15 年两轮牛市中，上表共有 20 家公司股价超过茅台；之后 16 年有两家，17 年有一家。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;股价超越茅台是否合理?&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们将上述在过去十年股价曾超越茅台的公司，剔除 2016 年以后上市的股票，与 茅台从基本面和二级市场两方面的客观数据进行对比: &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;超越茅台的公司基本面和股价近期表现 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5e91b44baff9993ee5f9cde77efbab2a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;460&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5e91b44baff9993ee5f9cde77efbab2a&quot; data-watermark-src=&quot;v2-4700b4a017618878025ad7ebbcc8948a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6638423c8046fa351fc19d948b52e80c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;65&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上表显示，过去股价超越茅台的公司按照基本面大致分为两类：其中多数属于 “基本面看，无法称作白马股”这一类。无论从长期 ROE 水平，还是长期净利润复合增长，这些公司 2007 至 2016 年所体现出成长的可持续性、经济周期抗风险能力，尚未具有白马股的特征；另有少部分诸如碧水源、东方园林、洋河股份属于拥有较好的基本面，但长期 ROE 整体水平低于茅台，从而公司的长期盈利质量难以超越茅台。成长性欠佳则长期净利润增速不高，进而长期股票收益率不可能太高。另一方面，考虑到茅台过去十年股本并无大幅度的扩张，所以综合公司基本面和股本扩张两方面因素考虑，股价想超越茅台的机会就微乎其微。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;白马股量化选股模型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;绩优白马股的特征鲜明:长期 ROE 保持较高水平;公司业绩长期具有较高的成长性。并且绩优白马股的长期收益率也比较显著。因为，我们制作了以下绩优白马股量化选股模型，仅供参考。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;模型目标&lt;/b&gt;&lt;/p&gt;&lt;p&gt;寻找下一年 ROE 仍能保持高水平;且下个季度业绩增速显著高于市场平均水平的公司。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;选股逻辑&lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;按照 ROE 波动率，将全市场分为 ROE 稳定组和高波动组。&lt;/li&gt;&lt;li&gt;在 ROE 稳定组中，过去三年 ROE 每年均在 10%以上的公司。&lt;/li&gt;&lt;li&gt;营业收入同比 /环比 改善。&lt;/li&gt;&lt;li&gt;净利润同比/环比改善。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;回测结果&lt;/b&gt;&lt;br&gt;对 2007 年至 2017 年进行了回测，每年 5/1，9/1，11/1 日换仓。结果如下: &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-02735ee1517889edc47eb2e3dd4c4ccf_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;351&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-02735ee1517889edc47eb2e3dd4c4ccf&quot; data-watermark-src=&quot;v2-c67432aa73f6ea91672cdbdff1360014&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;模型月度超额收益时间序列分布 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图显示，模型收益分布均匀。最大回撤出现在 2014 年 12 月，市场行情出现金融和非金融板块极端分化的时候。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;国信白马股量化选股模型主要绩效评价指标 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d700873649fd7f5fa4c2347cec6bc378_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;101&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;无论从月度还是年度，绩优白马股模型胜率还是不错的。过去 12 年，年化绝对收益超过 30%。换手率也不算特别高。 &lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-aaa00e980ab3907cbb43118eca40cafd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;343&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-aaa00e980ab3907cbb43118eca40cafd&quot; data-watermark-src=&quot;v2-7e083035f93c44a93b50f3c45a4867d0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;模型绝对收益净值图 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图显示，绩优白马股模型长期持续跑赢沪深 300 等权指数，在每轮牛市(或者结构性牛市)中净值都创出了新高。第一波高点出现在 07 年底;第二波高点在 2011 年初，第三波高点出现在 15 年中期。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-038e2842e570694b4221fcd8f6658b14_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;354&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-038e2842e570694b4221fcd8f6658b14&quot; data-watermark-src=&quot;v2-624c90522f32447a912b9882d173158f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;模型累计超额收益净值图 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图显示，绩优白马股模型超额收益净值不断创新高，且整体回撤较小。三次较大的回撤分别出现在 2009 年 8 月，2014 年 12 月和 2016 年 1 月。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;基本面实证( ROE 和净利润兑现) &lt;/b&gt;&lt;/p&gt;&lt;p&gt;逻辑上讲，本模型的收益主要来自于公司业绩的增长。为了检验这一目标的兑现情况，我们对每期组合下期的业绩状况进行了验证。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;首先我们验证，下期年报模型组合 ROE 的情况: &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-90e87c3d8980da54a2fe1d7002a882b3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;335&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-90e87c3d8980da54a2fe1d7002a882b3&quot; data-watermark-src=&quot;v2-fed58ab186a1f6ed266fdd479894206c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;模型与全市场整体在下期年报 ROE 水平的比较 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以看到，每年模型组合下期年报整体的 ROE 水平介于 15%以上，25%以下；大幅高于市场整体水平。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;然后我们验证，下期季报模型组合净利润增长的情况: &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d19ed9f11bed6886121dde6ef92736b4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;349&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d19ed9f11bed6886121dde6ef92736b4&quot; data-watermark-src=&quot;v2-79f2805cb042923fd6f17aeb8a0b48a2&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;模型与全市场整体在下期净利润同比增速的比较 &lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上图显示，每年模型组合下期净利润增长介于 25%至 70%之间，大幅跑赢市场。 综合上述 ROE 和净利润增速的兑现情况，则不难理解本模型长期收益显著跑赢市场的原因。所以，本模型基本达成了所需目标，选择绩优白马股，坚持基本面驱动的价值投资风格。 &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;总结&lt;/p&gt;&lt;p&gt;本篇报告核心探讨了一个问题:虽然全市场股票的长期收益率是由长期业绩增长驱动;但绩优白马股的长期收益率可能更加直接地由长期稳定的高 ROE 驱动。 绩优白马股通过长期兑现未来的 ROE，兑现未来的利润增长，以实现长期高于市场平均 水平的股票收益率。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;本模型的预测指标仅包含 ROE，营业收入和净利润增长三项。在报告中我们也有提到过，我们猜测绩优白马股的负债结构可能相对比较稳定，这可能是一个区分绩优白马股的潜在指标。如果有其它对区分绩优白马股有辨识力的指标，也会对模型产生增量贡献。&lt;/p&gt;</description>
<author>量化家</author>
<guid isPermaLink="false">2018-08-03-41207512</guid>
<pubDate>Fri, 03 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>1.6 量化技术篇—优化择时策略的思路</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-08-02-41155677.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41155677&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;------从零开始学量化------&lt;/b&gt;&lt;br&gt;&lt;b&gt;简书&lt;/b&gt;：&lt;a href=&quot;https://www.jianshu.com/p/2c34aee64649&quot;&gt;量化目录传送门&lt;/a&gt;&lt;br&gt;&lt;b&gt;知乎&lt;/b&gt;：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38656100&quot;&gt;量化目录传送门&lt;/a&gt; &lt;/p&gt;&lt;hr&gt;&lt;h2&gt;0. 前言&lt;/h2&gt;&lt;p&gt;上篇使用zipline回测了一个简单策略，收益图如下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9fc26cb0d26a6f7a4e2ff158d7e19ea9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;480&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9fc26cb0d26a6f7a4e2ff158d7e19ea9&quot; data-watermark-src=&quot;v2-84d37accd772d5c13a4cbd590c0f3ac1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;评价指标如下&lt;/b&gt;：&lt;br&gt;&lt;br&gt;年化收益率 = 8.34%&lt;br&gt;&lt;br&gt;累计收益率 = 17.37%&lt;br&gt;&lt;br&gt;最大回撤 = -16.14%&lt;br&gt;&lt;br&gt;夏普比率 = 0.62  &lt;/p&gt;&lt;p&gt;综合以上指标，我们发现这个策略存在以下几个问题：&lt;br&gt;1. 夏普比率比较低，也就是承受单位风险带来的收益并不是很高。&lt;br&gt;2. 最大回撤较大，风险较大。&lt;/p&gt;&lt;p&gt;很明显，这个策略过于简单，效果并不理想，所以本篇主要介绍优化这个择时策略的思路。&lt;/p&gt;&lt;h2&gt;1. 改进的思路&lt;/h2&gt;&lt;p&gt;改进的第一个思路就是添加更多的技术指标，但千万不要立即去这样做，如果你直接尝试不同的技术指标，最终的结果可能是吃力不讨好，花了很大精力，却收效甚微。&lt;/p&gt;&lt;p&gt;为什么？？？&lt;/p&gt;&lt;p&gt;因为你没有抓住问题的本质，你的优化更像是一种遍历式的组合，明显是低效的。&lt;/p&gt;&lt;p&gt;那么，我们该怎么办？&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;了解问题的本质。&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;站在巨人的肩膀上。&lt;/b&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;2. 了解问题的本质&lt;/h2&gt;&lt;blockquote&gt;First principle, Simplicity. Read Macrus Aurelius. Of each particular thing, ask:What is it initself?What is its nature?&lt;br&gt;&lt;br&gt;来源于电影《沉默的羔羊》&lt;/blockquote&gt;&lt;p&gt;上面一段话来源于《沉默的羔羊》，他说出了如何去寻找问题的本质。 &lt;/p&gt;&lt;h2&gt;2.1 策略的核心&lt;/h2&gt;&lt;p&gt;我个人认为，量化获利的本质，不是预测未来。因为未来根本是不可预测的，所以拟合曲线的想法是不可行的。&lt;/p&gt;&lt;p&gt;未来不可预测，但是规律却是可以找到的。&lt;/p&gt;&lt;p&gt;在历史的长河中，没有任何力量可以抵挡历史的车轮，因为历史轮回的规律是无可抗拒的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;量化策略的核心————不是拟合曲线，而是服规律。&lt;/b&gt; &lt;/p&gt;&lt;h2&gt;2.2 择时优化点&lt;/h2&gt;&lt;p&gt;上一篇策略使用的是CCI指标（顺势指标，Commodity Channel Index）&lt;/p&gt;&lt;p&gt;CCI指标的核心思想是：根据统计学原理，使用价格与固定期间的股价平均区间的偏离程度，来度量股价是否超出常态分布范围。CCI是一种超买超卖类指标。&lt;/p&gt;&lt;p&gt;根据定义，我们知道上篇文章实现的是一种趋势跟踪的择时策略，股票超买的时候买入，超买结束就卖出。&lt;/p&gt;&lt;p&gt;趋势跟踪策略的盈利逻辑是，市场是非有效的，当市场中某些因素变化，导致某些资产的价值短期内迅速变化，但是这些资产的价格变化滞后于价值变化，那么该资产就具有趋势性，策略顺应这样的趋势实现盈利。&lt;/p&gt;&lt;p&gt;所以趋势跟踪的择时策略，非常依赖于市场的波动性。当市场出现大方向的波动性，策略的收益会比较高；当市场没有明显波动的时候，策略的收益往往就不如人意。这种策略典型的特征是“亏小赚大”。&lt;/p&gt;&lt;p&gt;因此改进有两个方向：&lt;br&gt;&lt;br&gt;1. &lt;b&gt;添加有效的趋势指标，增强信号的可信度。&lt;/b&gt;&lt;br&gt;&lt;br&gt;2. &lt;b&gt;选择具有趋势特性的股票。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;所以接下来的核心问题就是：  &lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;寻找有效的趋势指标？&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;如何判断股票具有趋势性？&lt;/b&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;为了解决以上两个问题，我们就需要站在巨人的肩膀上了。&lt;/p&gt;&lt;h2&gt;3. 站在巨人的肩膀上&lt;/h2&gt;&lt;p&gt;做策略的时候，尽量不要闭门造车，因为自己极有可能在做前人做过的工作，凭一己之力，很难有所作为。&lt;/p&gt;&lt;p&gt;所以我们需要站在巨人的肩膀上，再出发，这样才可能有所突破。&lt;/p&gt;&lt;p&gt;巨人的肩膀指的就是机构的研报、相关的学术研究、优秀的基金经理的理论框架。&lt;/p&gt;&lt;p&gt;当我们站在这些优秀的研究成果上，再进行尝试，事半功倍。&lt;/p&gt;&lt;p&gt;那么前人在择时指标和选股的问题中，有什么好的成果呢？&lt;/p&gt;&lt;h2&gt;3.1 择时指标的成果&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;众泰证券——《传统技术指标有效性的量化分析》，该文章分析了移动平均线（MA）、乖离率（BIAS）和成交量（VOL）的有效性分析。&lt;/li&gt;&lt;li&gt;《Foundations of Technical Analysis:Computational Algorithms, Statistical Inference, and Empirical Implementation》 ，该文章使用了美国的股票数据，研究了10个技术指标的有效性，最终得出5个指标是显著有效的。&lt;/li&gt;&lt;li&gt;《Technical analysis of stock trends》&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;3.2 选股的成果&lt;/h2&gt;&lt;p&gt;&lt;b&gt;目前还未找到好的文章，后续更新&lt;/b&gt;&lt;/p&gt;&lt;p&gt;最后列举一些我看过的，比较有收获的文章：&lt;/p&gt;&lt;h2&gt;3.3 量化策略的科普文章&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;天风证券——《商品期货CTA专题报告》&lt;/li&gt;&lt;li&gt;渤海证券——《商品期货跨品种择时套利策略》&lt;/li&gt;&lt;li&gt;中信证券——《关于多因子模型构建方法实用性的理论探讨》&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;3.4 启发量化策略的文章&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;缠中说禅的缠论&lt;/b&gt;，&lt;a href=&quot;http://blog.sina.com.cn/u/1215172700&quot;&gt;缠师博客&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;&lt;b&gt;周金涛的周期嵌套理论&lt;/b&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;本人还是比较推崇以上两位大牛的大局观和理论分析能力的，从他们的字里行间中，就可以看出他们对问题认识的深度和分析问题独特的思路，从中可以获益不少。&lt;/p&gt;&lt;p&gt;&lt;b&gt;后期会继续更新，也希望大家推荐好的文章&lt;/b&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;如果你对我的文章有兴趣，可以关注一下我的简书和知乎，后期会在简书和知乎上定期更新，传送门在下方：&lt;br&gt;&lt;b&gt;简书&lt;/b&gt;：&lt;a href=&quot;https://www.jianshu.com/u/d436b7e60253&quot;&gt;潇潇夜雨归何处&lt;/a&gt;&lt;br&gt;&lt;b&gt;知乎&lt;/b&gt;：&lt;a href=&quot;https://www.zhihu.com/people/edwardzhang0630/activities&quot;&gt;潇潇夜雨&lt;/a&gt;&lt;br&gt;&lt;br&gt;我相信，有趣的灵魂总会相遇！！！&lt;br&gt;&lt;br&gt;你的关注，是我前进的动力！！！&lt;/p&gt;</description>
<author>潇潇夜雨</author>
<guid isPermaLink="false">2018-08-02-41155677</guid>
<pubDate>Thu, 02 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>策略||止损思路</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-08-01-41024096.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41024096&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;一、时间止损&lt;/b&gt;&lt;/p&gt;&lt;p&gt;认为时间是有价值的，若在一定的时间内某股票的回报收益低于一个预设值就认为该交易低于预期，选择卖出。 这是一个非常简单的止损策略， 由于止损线是固定的， 所以不能很好的减少回撤。若不是专门研究时间止损， 不建议使用。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b0e42f37aa24af1f9a421287701d9481_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;352&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b0e42f37aa24af1f9a421287701d9481&quot; data-watermark-src=&quot;v2-f9452b856d60541dd3e8afff98e947f3&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;if 持仓时间&amp;gt; X 天 and 区间涨幅 小于Y% ： 
卖出止损else：
继续持有
import pandas as pd import numpy as np import time import datetime import mathimport itertools

def init(context):    context.to_buy = (&#39;300033.XSHE&#39;,&#39;000025.XSHE&#39;)
    context.period=10 # 持股天数X     context.total_return=0.05 # 持股天数内的回报率     # 实时打印日志    #scheduler.run_daily(stoploss)    logger.info(&quot;Interested at stock: &quot; + str(context.to_buy))
    context.time=pd.DataFrame()
    scheduler.run_monthly(rebalance,1)
    scheduler.run_daily(stoploss)

def handle_bar(context, bar_dict):    pass 

def stoploss( context,bar_dict):    # 根据时间 清仓    print(context.time)    
    for stock in  context.portfolio.positions: 
        if stock in context.time.columns:
            buytime=context.time[stock][0] # 获取买入时间            currenttime=context.now.replace(tzinfo=None) # 获取当前时间            print (&#39;buytime=&#39;+str(buytime))
            print(&#39;currenttime=&#39;+str(currenttime))

            total_return=context.portfolio.positions[stock].market_value/context.portfolio.positions[stock].bought_value # 计算回报            escape=(currenttime-buytime).days # 计算持有天数            if escape&amp;gt;context.period and total_return&amp;lt;1+context.total_return:
                print(str(stock)+ &#39;大于&#39; + str (context.period)+&#39;天 且回报过小， 卖出&#39;)
                order_target_percent(stock, 0)                
                del context.time[stock]            
            elif total_return&amp;gt;1+context.total_return: 
                print(str(stock)+&#39;回报为: &#39; +str(total_return)+&#39;大于预设值&#39;+str(1+context.total_return))            
            else:
                print(str(stock)+ &#39;持仓未到&#39; +str(context.period)+&#39;天,继续持有&#39;)

def record(context,bar_dict,stock):    if stock not in context.time.columns:
        temp=pd.DataFrame({str(stock):[context.now.replace(tzinfo=None)]})
        logger.info (temp)
        context.time = pd.concat([context.time, temp], axis=1, join=&#39;inner&#39;)

def rebalance(context,bar_dict):    if len(context.to_buy)!=0:        
        for stock in context.to_buy:
            record(context,bar_dict,stock)
            order_target_percent(stock,1/len(context.to_buy))            
    else: 
        order_target_percent(stock,0)&lt;/code&gt;&lt;p&gt;&lt;b&gt;二、时间+ 阶梯 止损&lt;/b&gt;&lt;/p&gt;&lt;p&gt;时间+阶梯 止损是将“时间有价值” 和 “动态止损” 这两个思路结合在一起的策略。 止损价会随着 持股周期的变化而变化， 一旦跌破止损价，则卖出。 良好的止损策略。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-75f416fcc44d4800b194c230c182c153_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;350&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-75f416fcc44d4800b194c230c182c153&quot; data-watermark-src=&quot;v2-215d36dd8c25c2763559ea1340ed2ca9&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;止损价 =fx ( 持股周期， 期望回报率)if 现价&amp;lt; 止损价：
卖出止损
阶梯次数= floor(log(1+最大涨幅%)/log(1+阶梯长度%))
止损价位=初始止损价*(1+Y%)^周期次数if 现价&amp;lt;止损价位:
卖出止损
阶梯次数= floor (持股时间(天)/周期X(天))
止损价= 买入价*(1+阶梯次数* Y%)if 持股时间&amp;gt;周期 X  and 现价&amp;lt; 止损价：
卖出止损else if  持股时间&amp;lt;周期X and 现价&amp;lt;买入价*预设止损比例：
在第一个周期内亏损过多， 卖出止损else：
继续持有  
import numpy as np import time import datetime import mathimport itertools

def init(context):    context.to_buy = (&#39;300033.XSHE&#39;,&#39;000025.XSHE&#39;)
    context.period=10 # 持股天数X     context.increment=0.15    # 实时打印日志    context.time=pd.DataFrame()
    scheduler.run_monthly(rebalance,1)
    scheduler.run_daily(stoploss)

def handle_bar(context, bar_dict):    pass 

def stoploss( context,bar_dict):    # 根据时间 清仓    print(context.time)    f
    or stock in  context.portfolio.positions: 
        if stock in context.time.columns:
            buytime=context.time[stock][0] # 获取买入时间            currenttime=context.now.replace(tzinfo=None) # 获取当前时间            print (&#39;buytime=&#39;+str(buytime))
            print(&#39;currenttime=&#39;+str(currenttime))

            total_return=context.portfolio.positions[stock].market_value/context.portfolio.positions[stock].bought_value # 计算回报
            escape=(currenttime-buytime).days # 计算持有天数            threshold=math.floor(escape/context.period)*context.increment+1 # 计算期望。            if escape&amp;gt;context.period and total_return&amp;lt;threshold:
                print(str(stock)+ &#39;大于&#39; + str (context.period)+&#39;天 且回报小于&#39;+ str(threshold)+&#39; 卖出&#39;)
                order_target_percent(stock, 0)                
                del context.time[stock]            
            elif total_return&amp;gt;threshold: 
                print(str(stock)+&#39;回报为: &#39; +str(total_return)+&#39;大于预设值&#39;+str(threshold)+&#39;, 继续持有&#39;)            
            elif total_return&amp;lt;0.95:
                print(str(stock)+&#39;周期内跌幅超过5% 直接止损&#39;)           
             else:
                print(str(stock)+ &#39;持仓未到&#39; +str(context.period)+&#39;天,继续持有&#39;)

def record(context,bar_dict,stock):    if stock not in context.time.columns:
        temp=pd.DataFrame({str(stock):[context.now.replace(tzinfo=None)]})
        logger.info (temp)
        context.time = pd.concat([context.time, temp], axis=1, join=&#39;inner&#39;)

def rebalance(context,bar_dict):    if len(context.to_buy)!=0:        
        for stock in context.to_buy:
            record(context,bar_dict,stock)
            order_target_percent(stock,1/len(context.to_buy))    else: 
    order_target_percent(stock,0)&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;三、限价止损&lt;/b&gt;&lt;/p&gt;&lt;p&gt;限价止损 将买入价设置为基准价， 一旦股价上涨大于X% 或下跌大于 Y% 就卖出该股。这是也是一个固定止损/止盈价位的止损方案， 和时间止损存在相同问题：不能有效减少回撤。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a9ce1c29dd1f28e8dedea412140b0d80_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;352&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a9ce1c29dd1f28e8dedea412140b0d80&quot; data-watermark-src=&quot;v2-b4a9561d8773b5067ae63584997244b2&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;if 现价&amp;gt;(1+X%)*买入价：&lt;br&gt;卖出 止盈else if 现价&amp;lt;(1-Y%)*买入价：&lt;br&gt;卖出止损else：&lt;br&gt;继续持有&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;import numpy as np import time import datetime 
def init(context):    context.to_buy = (&#39;300033.XSHE&#39;,&#39;000025.XSHE&#39;,&#39;601766.XSHG&#39;)
    context.stoplossmultipler= 0.95 #止损 乘数     context.stoppofitmultipler= 1.5 #止盈 乘数    # 实时打印日志    #scheduler.run_daily(stoploss)    logger.info(&quot;Interested at stock: &quot; + str(context.to_buy))
    scheduler.run_monthly(position,1)
    scheduler.run_daily(stoploss)def stoploss(context,bar_dict):    for stock in context.portfolio.positions:        
        if bar_dict[stock].last&amp;lt;context.portfolio.positions[stock].average_cost*context.stoplossmultipler:# 现价低于 原价一定比例            order_target_percent(stock,0)
            print(str(stock)+&#39;跌幅超过&#39;+str((1-context.stoplossmultipler)*100) +&#39;%  触发止损&#39;)        
        elif bar_dict[stock].last&amp;gt;context.portfolio.positions[stock].average_cost*context.stoppofitmultipler:# 现价高于原价一定比例            order_target_percent(stock,0)
            print(str(stock)+&#39;涨幅幅超过&#39;+str((context.stoppofitmultipler-1)*100) +&#39;%  触发止盈&#39;)    
    pass 

def handle_bar(context, bar_dict):    pass

def position(context,bar_dict):    if len(context.to_buy)!=0:        
        for stock in context.to_buy:
            order_target_percent(stock,1/len(context.to_buy))    
    else: 
        order_target_percent(stock,0)&lt;/code&gt;&lt;p&gt;&lt;b&gt;四、跟踪止损&lt;/b&gt;&lt;/p&gt;&lt;p&gt;跟踪止损 考虑的是该股的回撤， 若回撤大于某预设值X% 就将其卖出。 此方案的止损价会随着最高价的变化而变化， 在股灾和熔断中有很好的表现。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b590d65735a0a8045f6ab88d5a85af0f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;361&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b590d65735a0a8045f6ab88d5a85af0f&quot; data-watermark-src=&quot;v2-85f542cdbca8de0d56e457e41e873adc&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;X=允许最大回撤if 现价&amp;lt;持股周期内最高价*(1-X %):&lt;br&gt;卖出止损else：&lt;br&gt;继续持有&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;import pandas as pd import numpy as np import time import mathimport datetime def init(context):    context.to_buy = (&#39;300033.XSHE&#39;,&#39;000025.XSHE&#39;,&#39;601390.XSHG&#39;)
    context.drawdown= 0.1 # 回撤限度 10%     context.maxvalue=pd.DataFrame()
    logger.info(&quot;Interested at stock: &quot; + str(context.to_buy))
    scheduler.run_monthly(position,1)
    scheduler.run_daily(stoploss)

def stoploss(context,bar_dict):    for stock in context.portfolio.positions:
        market_value=context.portfolio.positions[stock].market_value# 该股市场价值 单位（RMB）        bought_value=context.portfolio.positions[stock].bought_value#该股初始价值 单位（RMB）        stockdic=context.maxvalue[stock]
        maxvalue=stockdic[0]        

del context.maxvalue[stock]
        temp=pd.DataFrame({str(stock):[max(maxvalue,market_value)]})
        context.maxvalue=pd.concat([context.maxvalue,temp], axis=1, join=&#39;inner&#39;) # 更新其盘中最高价值和先阶段比例。         drawdown=1-market_value/max(maxvalue,market_value)

        print(str(stock)+&#39;的成本为：&#39; +str( bought_value) +&#39;, 最高价值为：&#39;+str(maxvalue)+&#39;现价值为：&#39;+ str(market_value))
        print(str(stock) +&#39;的现 回撤为: &#39; +str(drawdown*100)+ &#39;%&#39;)        
    if drawdown&amp;gt;context.drawdown:# 现价低于 原价一定比例            order_target_percent(stock,0)
            print(str(stock)+&#39;回撤大于&#39;+ str(context.drawdown*100)+ &#39;%&#39;+&#39;  触发止损&#39;)            
            del context.maxvalue[stock]    
pass 

def handle_bar(context, bar_dict):    pass

def createdic(context,bar_dict,stock):    if stock not in context.maxvalue.columns:
        temp=pd.DataFrame({str(stock):[context.portfolio.positions[stock].bought_value]})    
        context.maxvalue = pd.concat([context.maxvalue, temp], axis=1, join=&#39;inner&#39;)
    print(context.maxvalue)

def position(context,bar_dict):    if len(context.to_buy)!=0:        
        for stock in context.to_buy:
            order_target_percent(stock,1/len(context.to_buy))
            createdic(context,bar_dict,stock)    
    else: 
        order_target_percent(stock,0)&lt;/code&gt;&lt;p&gt;&lt;b&gt;五、阶梯止损&lt;/b&gt;&lt;/p&gt;&lt;p&gt;阶梯止损是一种 动态止损策略。 止损价会根据持股周期内最高价的变化而变化。 和跟踪止损的思路类似， 但是止损价的计算方式略有不同， 股灾期间表现良好。 但不及阶梯止损。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-31f6fa0e09cbbc85cb97e5a2bf328c31_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;344&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-31f6fa0e09cbbc85cb97e5a2bf328c31&quot; data-watermark-src=&quot;v2-68550f44fb9fe01bb1feb606188703d6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;M= 初始止损比例
X= 阶梯长度  
Y= 阶梯变化率 （阶梯每改变一次， 止损线上涨的幅度）

止损线改变次数=floor[log(周期内最高股价/买入价)/log(1+ X%)]
止损价= M * [1+Y%] ^ 止损线改变次数if 现价&amp;lt; 止损价： 
直接跌破止损价， 卖出止损。else：
继续持有
import pandas as pd import numpy as np import time import mathimport datetime 
def init(context):    context.to_buy = (&#39;300033.XSHE&#39;,&#39;000025.XSHE&#39;)
    context.initSLM=0.9 # 初始止损比例 M     context.step=0.10    # 间隔 X    context.increment=0.09 # 止损增量  Y    context.maxvalue=pd.DataFrame()
    logger.info(&quot;Interested at stock: &quot; + str(context.to_buy))
    scheduler.run_monthly(position,1)
    scheduler.run_daily(stoploss)

def stoploss(context,bar_dict):    for stock in context.portfolio.positions:
        market_value=context.portfolio.positions[stock].market_value# 该股市场价值 单位（RMB）        bought_value=context.portfolio.positions[stock].bought_value#该股初始价值 单位（RMB）        stockdic=context.maxvalue[stock]
        maxvalue=stockdic[0]        

del context.maxvalue[stock]
        currSL=context.initSLM*(1+context.increment)**math.floor((math.log(maxvalue/bought_value)/math.log(1+context.step)))#阶梯止损算法 

        temp=pd.DataFrame({str(stock):[max(maxvalue,market_value),currSL]})
        context.maxvalue=pd.concat([context.maxvalue,temp], axis=1, join=&#39;inner&#39;) # 更新dataframe。 
        print(str(stock)+&#39;的成本为：&#39; +str( bought_value) +&#39;, 最高价值为：&#39;+str(maxvalue)+&#39;现价值为：&#39;+ str(market_value))
        print(str(stock) +&#39;的现 止损价位为: &#39; +str(currSL))        if market_value&amp;lt;bought_value*currSL:# 现价初始止损价            order_target_percent(stock,0)
            print(str(stock)+ (&#39;触发止损&#39;))    
    pass 

def handle_bar(context, bar_dict):    pass            

def createdic(context,bar_dict,stock):    if stock not in context.maxvalue.columns:
        temp=pd.DataFrame({str(stock):[context.portfolio.positions[stock].bought_value,context.initSLM]})    
        context.maxvalue = pd.concat([context.maxvalue, temp], axis=1, join=&#39;inner&#39;)
    print(context.maxvalue)

def position(context,bar_dict):    if len(context.to_buy)!=0:        
        for stock in context.to_buy:
            order_target_percent(stock,1/len(context.to_buy))
            createdic(context,bar_dict,stock)    
        else: 
        order_target_percent(stock,0)&lt;/code&gt;&lt;p&gt;&lt;b&gt;6、ATR 止损&lt;/b&gt;&lt;/p&gt;&lt;p&gt;ATR止损 会先计算 一个叫做平均真实波幅 (Average True Range )的指标，ATR止损是根据这一指标发散出来编写的策略。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-28a13ba20e5e8f07218ffb0c0cdbd7d4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;344&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-28a13ba20e5e8f07218ffb0c0cdbd7d4&quot; data-watermark-src=&quot;v2-87a149c04566deb8fcdf504ee93fde9d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;code lang=&quot;text&quot;&gt;Raw_ATR=max(|今日振幅|， |昨天收盘-今日最高价|，|昨天收盘-今日最低价|)# 未处理ATR = 这三个指标的最大值
ATR=moving_average (ATR ,N)  #真实ATR 为 Raw_ATR 的N 日简单移动平均,默认N=22
import pandas as pd import numpy as np import time import mathimport talibimport datetime 
def init(context):    context.to_buy = (&#39;300033.XSHE&#39;,&#39;000025.XSHE&#39;)
    context.ATRperiod=22# ATR 中moving average 的N 值,可自己调, 默认为22    update_universe(context.to_buy)
    context.trigger=0    context.initSL=0.9    context.profit=0.2 # 当盈利大于20% 就将阶梯设为此价位。    context.maxvalue=pd.DataFrame()
    logger.info(&quot;Interested at stock: &quot; + str(context.to_buy))
    scheduler.run_monthly(position,1)
    scheduler.run_daily(stoploss)def findATR(context,bar_dict,stock): # 玄学指标        close=history(context.ATRperiod+2,&#39;1d&#39;,&#39;close&#39;)[stock][0:context.ATRperiod]
        high=history(context.ATRperiod+2,&#39;1d&#39;,&#39;high&#39;)[stock][1:context.ATRperiod+1]
        low=history(context.ATRperiod+2,&#39;1d&#39;,&#39;low&#39;)[stock][1:context.ATRperiod+1]
        art1=high.values-low.values
        art2=abs(close.values-high.values)
        art3=abs(close.values-low.values)
        art123=np.matrix([art1, art2,art3])
        rawatr=np.array(art123.max(0)).flatten()
        ATR=rawatr.sum()/len(rawatr)
        print(str(rawatr)+&#39;ATR=&#39;+str(rawatr))
        print(str(stock)+&#39;ATR=&#39;+str(ATR))        
    return ATR

def stoploss(context,bar_dict):    for stock in context.portfolio.positions:
        high=bar_dict[stock].high
        current=bar_dict[stock].last
        bought_value=context.portfolio.positions[stock].bought_value#该股初始价值 单位（RMB）
        stockdic=context.maxvalue[stock]
        highest=stockdic[0]        

del context.maxvalue[stock]
        ATR=findATR(context,bar_dict,stock)
        temp=pd.DataFrame({str(stock):[max(highest,high)]})
        context.maxvalue=pd.concat([context.maxvalue,temp], axis=1, join=&#39;inner&#39;) # 更新其盘中最高价值和先阶段比例。         print(str(stock)+&#39;的成本为：&#39; +str( context.portfolio.positions[stock].average_cost) +&#39;, 最高价为：&#39;+str(highest)+&#39;ATR为：&#39;+ str(ATR))        
    if bar_dict[stock].last&amp;lt;highest-3*ATR:
            print(&#39;吊灯止损&#39;)
            order_target_percent(stock,0)            
del context.maxvalue[stock]    
    pass 

def handle_bar(context, bar_dict):    pass       

def createdic(context,bar_dict,stock):    if stock not in context.maxvalue.columns:
        temp=pd.DataFrame({str(stock):[0]})    
        context.maxvalue = pd.concat([context.maxvalue, temp], axis=1, join=&#39;inner&#39;)
    print(context.maxvalue)def position(context,bar_dict):    if len(context.to_buy)!=0:        
        for stock in context.to_buy:
            createdic(context,bar_dict,stock)
            order_target_percent(stock,1/len(context.to_buy))    else: 
        order_target_percent(stock,0)&lt;/code&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>量化家</author>
<guid isPermaLink="false">2018-08-01-41024096</guid>
<pubDate>Wed, 01 Aug 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>策略||隐马尔可夫模型</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-07-31-40962600.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40962600&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;隐马尔可夫模型 &lt;/b&gt;(Hidden Markov Model，HMM) 最初由 L. E. Baum 和其它一些学者发表在一系列的统计学论文中，随后在语言识别，自然语言处理以及生物信息等领域体现了很大的价值。平时，经常能接触到涉及 &lt;b&gt;HMM &lt;/b&gt;的相关文章，一直没有仔细研究过，都是蜻蜓点水，因此，想花一点时间梳理下，加深理解，在此特别感谢 52nlp 对 &lt;b&gt;HMM&lt;/b&gt; 的详细介绍。&lt;/p&gt;&lt;p&gt; 考虑下面交通灯的例子，一个序列可能是红-红/橙-绿-橙-红。这个序列可以画成一个状态机，不同的状态按照这个状态机互相交替，每一个状态都只依赖于前一个状态，如果当前的是绿灯，那么接下来就是橙灯，这是一个确定性系统，因此更容易理解和分析，只要这些状态转移都是已知的。但是在实际当中还存在许多不确定性系统。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1ecd8683bb77c40341371fd17c391227_r.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;297&quot; data-rawheight=&quot;113&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-1ecd8683bb77c40341371fd17c391227_b.jpg&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 在日常生活当中，我们总是希望根据当前天气的情况来预测未来天气情况，和上面的交通灯的例子不同，我们不能依靠现有知识确定天气情况的转移，但是我们还是希望能得到一个天气的模式。一种办法就是假设这个模型的每个状态都只依赖于前一个的状态，这个假设被称为&lt;b&gt;马尔科夫假设&lt;/b&gt;，这个假设可以极大简化这个问题。显然，这个假设也是一个非常糟糕的假设，导致很多重要的信息都丢失了。&lt;br&gt;&lt;/p&gt;&lt;p&gt; 当涉及到天气的时候，&lt;b&gt;马尔科夫假设&lt;/b&gt;描述为，假设如果我们知道之前一些天的天气信息，那么我们就能预测今天的天气。当然，这个例子也是有些不合实际的。但是，这样一个简化的系统可以有利于我们的分析，所以我们通常接受这样的假设，因为我们知道这样的系统能让我们获得一些有用的信息，尽管不是十分准确的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f96e315dce171b1c29831c733878cc9d_r.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;41&quot; data-rawheight=&quot;41&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-f96e315dce171b1c29831c733878cc9d_b.jpg&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d551404091b8f1df73e1150d121f4b5d_r.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;41&quot; data-rawheight=&quot;41&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot; data-thumbnail=&quot;https://pic4.zhimg.com/v2-d551404091b8f1df73e1150d121f4b5d_b.jpg&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6dc602bda819c6d591c87b84ea4331c2_r.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;41&quot; data-rawheight=&quot;41&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-6dc602bda819c6d591c87b84ea4331c2_b.jpg&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;       谈到 &lt;b&gt;HMM&lt;/b&gt;，首先简单介绍一下&lt;b&gt;马尔可夫过程 &lt;/b&gt;(Markov Process)，它因俄罗斯数学家安德烈·马尔可夫而得名，代表数学中具有&lt;b&gt;马尔可夫性质&lt;/b&gt;的离散随机过程。该过程中，每个状态的转移只依赖于之前的 n 个状态，这个过程被称为1个 n 阶的模型，其中 n 是影响转移状态的数目。最简单的马尔科夫过程就是一阶过程，每一个状态的转移只依赖于其之前的那一个状态。注意这和确定性系统不一样，因为这种转移是有概率的，而不是确定性的。&lt;br&gt;&lt;/p&gt;&lt;p&gt; 马尔可夫链是随机变量 &lt;i&gt;X&lt;/i&gt;1, … , &lt;i&gt;Xn&lt;/i&gt; 的一个数列。这些变量的范围，即他们所有可能取值的集合，被称为“状态空间”，而 &lt;i&gt;Xn  &lt;/i&gt;的值则是在时间 &lt;i&gt;n &lt;/i&gt;的状态。如果 &lt;i&gt;Xn&lt;/i&gt;+1 对于过去状态的条件概率分布仅是 &lt;i&gt;Xn &lt;/i&gt;的一个函数，则&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-41f3af3fbaf50d11913f537577899a1e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;434&quot; data-rawheight=&quot;48&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 这里 &lt;i&gt;x &lt;/i&gt;为过程中的某个状态。上面这个恒等式可以被看作是&lt;b&gt;马尔可夫性质&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　马尔可夫链&lt;/b&gt;的在很多应用中发挥了重要作用，例如，谷歌所使用的网页排序算法（PageRank）就是由&lt;b&gt;马尔可夫链&lt;/b&gt;定义的。&lt;/p&gt;&lt;p&gt; 下图展示了天气这个例子中所有可能的一阶转移：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6e613f9799e1e770b4a9a5c4b888e75d_r.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;320&quot; data-rawheight=&quot;137&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-6e613f9799e1e770b4a9a5c4b888e75d_b.jpg&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 注意一个含有 N 个状态的一阶过程有 N2 个状态转移。每一个转移的概率叫做&lt;b&gt;状态转移概率 &lt;/b&gt;(state transition probability)，就是从一个状态转移到另一个状态的概率。这所有的 N2 个概率可以用一个&lt;b&gt;状态转移矩阵&lt;/b&gt;来表示，其表示形式如下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;b&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-cea8745b8712d6ea9d95c61662c1a97f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;585&quot; data-rawheight=&quot;248&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-cea8745b8712d6ea9d95c61662c1a97f&quot; data-watermark-src=&quot;v2-260a8429660f81d28668e59d5926f5a1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;/b&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 对该矩阵有如下约束条件：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a737652b07e8bbef859a1db284bb7f0b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;153&quot; data-rawheight=&quot;122&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 下面就是海藻例子的&lt;b&gt;状态转移矩阵&lt;/b&gt;：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ba908784eeab9bd78055a9d675d5c78b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;351&quot; data-rawheight=&quot;166&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ba908784eeab9bd78055a9d675d5c78b&quot; data-watermark-src=&quot;v2-fbd21207deef2cdd176cd62307087d73&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt; 这个矩阵表示，如果昨天是晴天，那么今天有50%的可能是晴天，37.5%的概率是阴天，12.5%的概率会下雨，很明显，矩阵中每一行的和都是1。&lt;/p&gt;&lt;p&gt; 为了初始化这样一个系统，我们需要一个初始的概率向量：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fe47981cc1537b7a9bbc8139a88df9e7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;193&quot; data-rawheight=&quot;64&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 这个向量表示第一天是晴天。&lt;/p&gt;&lt;p&gt; 到这里，我们就为上面的一阶&lt;b&gt;马尔科夫过程&lt;/b&gt;定义了以下三个部分：&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　状态&lt;/b&gt;：晴天、阴天和下雨&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　初始向量&lt;/b&gt;：定义系统在时间为0的时候的状态的概率&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　状态转移矩阵&lt;/b&gt;：每种天气转换的概率&lt;/p&gt;&lt;p&gt; 所有的能被这样描述的系统都是一个&lt;b&gt;马尔科夫过程&lt;/b&gt;。&lt;/p&gt;&lt;p&gt; 然而，当&lt;b&gt;马尔科夫过程&lt;/b&gt;不够强大的时候，我们又该怎么办呢？在某些情况下，&lt;b&gt;马尔科夫过程&lt;/b&gt;不足以描述我们希望发现的模式。&lt;/p&gt;&lt;p&gt; 例如，一个隐居的人可能不能直观的观察到天气的情况，但是民间传说告诉我们海藻的状态在某种概率上是和天气的情况相关的。在这种情况下我们有两个状态集合，一个可以观察到的状态集合（海藻的状态）和一个隐藏的状态（天气状况）。我们希望能找到一个算法可以根据海藻的状况和&lt;b&gt;马尔科夫假设&lt;/b&gt;来预测天气的状况。&lt;/p&gt;&lt;p&gt; 一个更现实的例子是语音识别，我们听到的声音是声带、喉咙和一起其他的发音器官共同作用的结果。这些因素相互作用，共同决定了每一个单词的声音，而一个语音识别系统检测的声音（可以观察的状态）是人体内部各种物理变化（隐藏的状态、引申一个人真正想表达的意思）产生的。&lt;/p&gt;&lt;p&gt; 某些语音识别设备把内部的发音机制作为一个隐藏的状态序列，把最后的声音看成是一个和隐藏的状态序列十分相似的可以观察到的状态的序列。在这两个例子中，一个非常重要的地方是&lt;b&gt;隐藏状态的数目和可以观察到的状态的数目可能是不一样的&lt;/b&gt;。在一个有3种状态的天气系统（sunny、cloudy、rainy）中，也许可以观察到4种潮湿程度的海藻（dry、dryish、damp、soggy）。在语音识别中，一个简单的发言也许只需要80个语素来描述，但是一个内部的发音机制可以产生不到80或者超过80种不同的声音。&lt;/p&gt;&lt;p&gt; 在上面的这些情况下，&lt;b&gt;可以观察到的状态序列和隐藏的状态序列是概率相关的&lt;/b&gt;。于是我们可以将这种类型的过程建模为有一个隐藏的&lt;b&gt;马尔科夫过程&lt;/b&gt;和一个与这个&lt;b&gt;隐藏马尔科夫过程&lt;/b&gt;概率相关的并且可以观察到的状态集合。这就是本文重点介绍的&lt;b&gt;隐马尔可夫模型。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　隐马尔可夫模型 &lt;/b&gt;(Hidden Markov Model) 是一种统计模型，用来描述一个含有隐含未知参数的&lt;b&gt;马尔可夫过程&lt;/b&gt;。其难点是从可观察的参数中确定该过程的隐含参数，然后利用这些参数来作进一步的分析。下图是一个三个状态的&lt;b&gt;隐马尔可夫模型&lt;/b&gt;状态转移图，其中x 表示隐含状态，y 表示可观察的输出，a 表示状态转换概率，b 表示输出概率。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-15ee8d97a4f0181db094bac01e15b5b0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;439&quot; data-rawheight=&quot;312&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-15ee8d97a4f0181db094bac01e15b5b0&quot; data-watermark-src=&quot;v2-47f86b462317e0ea4a2242a45df5ece0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 下图显示了天气的例子中隐藏的状态和可以观察到的状态之间的关系。我们假设隐藏的状态是一个简单的一阶&lt;b&gt;马尔科夫过程&lt;/b&gt;，并且他们两两之间都可以相互转换。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-168521291b6ce88e84aa37550b777995_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;426&quot; data-rawheight=&quot;265&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-168521291b6ce88e84aa37550b777995&quot; data-watermark-src=&quot;v2-935ebb9bdbdd808e2a00fc8945ad3059&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　对 HMM 来说，有如下三个重要假设，尽管这些假设是不现实的。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　假设1：马尔可夫假设（状态构成一阶马尔可夫链）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;b&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ad3227eb78db54bf477ad297b5f30adf_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;350&quot; data-rawheight=&quot;35&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;/b&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　假设2：不动性假设（状态与具体时间无关）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;b&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-63b57b495f9f2199cd870d409b16cf08_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;407&quot; data-rawheight=&quot;40&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;/b&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　假设3：输出独立性假设（输出仅与当前状态有关）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;b&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-96f96a84dc36ee97cd3337564bb611e8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;438&quot; data-rawheight=&quot;36&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;/b&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　隐藏的状态和可观察到的状态之间有一种概率上的关系，也就是说某种隐藏状态 H 被认为是某个可以观察的状态 O1 是有概率的，假设为 P(O1 | H)。如果可以观察的状态有3种，那么很显然 &lt;b&gt;P(O1 | H)+P(O2 | H)+ P(O3 | H) = 1&lt;/b&gt;。&lt;/p&gt;&lt;p&gt; 这样，我们也可以得到一个另一个矩阵，称为&lt;b&gt;混淆矩阵 &lt;/b&gt;(confusion matrix&lt;b&gt;)&lt;/b&gt;。这个矩阵的内容是某个隐藏的状态被分别观察成几种不同的可以观察的状态的概率，在天气的例子中，这个矩阵如下图：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a7b9075f3a7bf2b46a6ac274d4359abb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;375&quot; data-rawheight=&quot;132&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a7b9075f3a7bf2b46a6ac274d4359abb&quot; data-watermark-src=&quot;v2-9873116689768432207a7a0f42598668&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 上边的图示都强调了 &lt;b&gt;HMM &lt;/b&gt;的状态变迁。而下图则明确的表示出模型的演化，其中绿色的圆圈表示隐藏状态，紫色圆圈表示可观察到状态，箭头表示状态之间的依存概率，一个 &lt;b&gt;HMM &lt;/b&gt;可用一个5元组 { N, M, π，&lt;i&gt;A，B &lt;/i&gt;} 表示，其中 N 表示隐藏状态的数量，我们要么知道确切的值，要么猜测该值，M 表示可观测状态的数量，可以通过训练集获得， π={πi} 为初始状态概率，A={aij} 为隐藏状态的&lt;b&gt;转移矩阵 &lt;/b&gt;Pr(xt(i) | xt-1(j))，B={bik} 表示某个时刻因隐藏状态而可观察的状态的概率，即&lt;b&gt;混淆矩阵&lt;/b&gt;，Pr(ot(i) | xt(j))。在状态转移矩阵和混淆矩阵中的每个概率都是时间无关的，即当系统演化时，这些矩阵并不随时间改变。对于一个 N 和 M 固定的 &lt;b&gt;HMM &lt;/b&gt;来说，用 λ={ π, A, B } 表示&lt;b&gt; HMM&lt;/b&gt; 参数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d113f9aeaf102bc4eef22d93abbba00f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;508&quot; data-rawheight=&quot;144&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d113f9aeaf102bc4eef22d93abbba00f&quot; data-watermark-src=&quot;v2-7e5d54d114daa1521246229a62b3fadd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 在正常的&lt;b&gt;马尔可夫模型&lt;/b&gt;中，状态对于观察者来说是直接可见的。这样状态的转换概率便是全部的参数。而在&lt;b&gt;隐马尔可夫模型&lt;/b&gt;中，状态并不是直接可见的，但受状态影响的某些变量则是可见的。每一个状态在可能输出的符号上都有一概率分布。因此输出符号的序列能够透露出状态序列的一些信息。&lt;/p&gt;&lt;p&gt; 在 &lt;b&gt;HMM&lt;/b&gt; 中有三个典型问题：&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　（一） 已知模型参数，计算某一给定可观察状态序列的概率&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;假设我们已经有一个特定的&lt;b&gt;隐马尔科夫模型 λ&lt;/b&gt; 和一个可观察状态序列集。我们也许想知道在所有可能的隐藏状态序列下，给定的可观察状态序列的概率。当给定如下一个隐藏状态序列：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0e35c4e17f751080692bb205cd63a8fe_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;129&quot; data-rawheight=&quot;32&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　那么在 &lt;b&gt;HMM&lt;/b&gt; 和这个隐藏状态序列的条件下，可观察状态序列的概率为：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-62732bfcaa428eac4ade8a2540ee07d2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;389&quot; data-rawheight=&quot;39&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　而隐藏状态序列在 &lt;b&gt;HMM &lt;/b&gt;条件下的概率为：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3999e0a2372e0d2eae57394fcddc08d2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;346&quot; data-rawheight=&quot;42&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　因此，隐藏状态序列和可观察状态序列的联合概率为：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4c506877bce5a66ed86e53fa79c4f6dd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;350&quot; data-rawheight=&quot;34&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　那么所有可能的隐藏状态序列上，可观察状态序列的概率为：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-82ba78d52f3f0ce5f9a0879ef4d81828_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;339&quot; data-rawheight=&quot;53&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　例如，我们也许有一个海藻的“Summer”模型和一个“Winter”模型，因为海藻在夏天和冬天的状态应该是不同的，我们希望根据一个可观察状态（海藻的潮湿与否）序列来判断现在是夏天还是冬天。&lt;/p&gt;&lt;p&gt; 我们可以使用&lt;b&gt;前向算法&lt;/b&gt;来计算在某个特定的 &lt;b&gt;HMM&lt;/b&gt; 下一个可观察状态序列的概率，然后据此找到最可能的模型。&lt;/p&gt;&lt;p&gt; 这种类型的应用通常出现在语音设别中，通常我们会使用很多&lt;b&gt; HMM&lt;/b&gt;，每一个针对一个特别的单词。一个可观察状态的序列是从一个可以听到的单词向前得到的，然后这个单词就可以通过找到满足这个可观察状态序列的最大概率的 &lt;b&gt;HMM&lt;/b&gt; 来识别。&lt;/p&gt;&lt;p&gt; 下面介绍一下&lt;b&gt;前向算法 &lt;/b&gt;(Forward Algorithm)&lt;/p&gt;&lt;p&gt; 　如何计算一个可观察序列的概率？&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　1. 穷举搜索&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 给定一个 &lt;b&gt;HMM&lt;/b&gt;，我们想计算出某个可观察序列的概率。考虑天气的例子，我们知道一个描述天气和海藻状态的 &lt;b&gt;HMM&lt;/b&gt;，而且我们还有一个海藻状态的序列。假设这个状态中的某三天是（dry，damp，soggy），在这三天中的每一天，天气都可能是晴朗，多云或者下雨，我们可以用下图来描述观察序列和隐藏序列：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-09ebc1e4a51d86716e2b0bc64ccf0ced_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;192&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-09ebc1e4a51d86716e2b0bc64ccf0ced&quot; data-watermark-src=&quot;v2-89f714056ed1a90c16254f1a708e03b4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 在这个图中的每一列表示天气的状态可能，并且每个状态都指向相邻的列的每个状态，每个状态转换在状态转移矩阵中都有一个概率。每一列的下面是当天的可观察的海藻的状态，在每种状态下出现这种可观察状态的概率是由&lt;b&gt;混淆矩阵&lt;/b&gt;给出的。&lt;/p&gt;&lt;p&gt; 一个可能的计算可观察概率的方法是找到每一个可能的隐藏状态的序列，这里有32 = 27种，这个时候的可观察序列的概率就是 Pr(dry, damp, soggy | HMM)=Pr(dry, damp, soggy | sunny, sunny, sunny) + . . . . + Pr(dry, damp, soggy | rainy, rainy, rainy)。&lt;/p&gt;&lt;p&gt; 很显然，这种计算的效率非常低，尤其是当模型中的状态非常多或者序列很长的时候。事实上，我们可以利用概率不随时间变化这个假设来降低时间的开销。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　2. 使用递归来降低复杂度&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 我们可以考虑给定 &lt;b&gt;HMM&lt;/b&gt; 的情况下，递归的计算一个可观察序列的概率。我们可以首先定义一个部分概率，表示达到某个中间状态的概率。接下来我们将看到这些部分概率是如何 在time=1 和 time = n (n &amp;gt; 1) 的时候计算的。&lt;/p&gt;&lt;p&gt; 假设一个T时间段的可观察序列是：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8d8093e9f2329a240cfaf0bac247a7e2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;130&quot; data-rawheight=&quot;41&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　1) 部分概率&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 下面这张图表示了一个观察序列（dry，damp，soggy）的一阶转移&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-aa3817cf245765cfc97d1e1dd295f691_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;329&quot; data-rawheight=&quot;208&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-aa3817cf245765cfc97d1e1dd295f691&quot; data-watermark-src=&quot;v2-9dd89bfec9ca825e742d5a626ebf39e4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 我们可以通过计算到达某个状态的所有路径的概率和来计算到达某个中间状态的概率。比如说，t=2时刻，cloudy的概率用三条路径的概率之和来表示：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-463baee0af7790baee0e98d65573bdad_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;332&quot; data-rawheight=&quot;183&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-463baee0af7790baee0e98d65573bdad&quot; data-watermark-src=&quot;v2-362bc117709d401c1d4e3dbd8538d03a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 我们用 αt(j) 来表示在 t 时刻是状态 j 的概率，αt(j)=Pr(观察状态 | 隐藏状态 j ) x Pr(t 时刻到达状态 j 的所有路径)。&lt;/p&gt;&lt;p&gt; 最后一个观察状态的部分概率就表示了整个序列最后达到某个状态的所有可能的路径的概率和，比如说在这个例子中，最后一列的部分状态是通过下列路径计算得到的：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d83c5ba765a9a93596a9a987b8bea8cc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;395&quot; data-rawheight=&quot;111&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d83c5ba765a9a93596a9a987b8bea8cc&quot; data-watermark-src=&quot;v2-3c5ca73cb5e72afff2fdea2ad86e26a7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 因为最后一列的部分概率是所有可能的路径的概率和，所以就是这个观察序列在给定 &lt;b&gt;HMM&lt;/b&gt; 下的概率了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　2) 计算 t=1时候的部分概率&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 当 t=1 的时候，没有路径到某个状态，所以这里是初始概率，Pr(状态 j | t=0) = π(状态 j )，这样我们就可以计算 t=1 时候的部分概率为：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-11475808c1181147b59bcba2d6ed2351_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;154&quot; data-rawheight=&quot;42&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 因为在初始的时候，状态 j 的概率不仅和这个状态本身相关，还和观察状态有关，所以这里用到了&lt;b&gt;混淆矩阵&lt;/b&gt;的值，k1 表示第一个观察状态，bjk1 表示隐藏状态是 j，但是观察成 k1 的概率。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　3) 计算 t&amp;gt;1 时候的部分概率&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 还是看计算部分概率的公式是：αt(j) = Pr(观察状态 | 隐藏状态 j) x Pr(t 时刻到达状态 j 的所有路径)。 这个公式的左边是从混淆矩阵中已知的，我只需要计算右边部分，很显然右边是所有路径的和：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c1b6c50a1a279a93931764571d0da4fe_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;253&quot; data-rawheight=&quot;179&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c1b6c50a1a279a93931764571d0da4fe&quot; data-watermark-src=&quot;v2-af9e30f3bbe10dfef637a41df608c794&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 需要计算的路径数是和观察序列的长度的平方相关的，但是 t 时刻的部分概率已经计算过了之前的所有路径，所以在 t+1 时刻只需要根据 t 时刻的概率来计算就可以了：&lt;/p&gt;&lt;p&gt; 这里简单解释下，bjk(t+1) 就是在 t+1 时刻的第 j 个隐藏状态被认为是当前的观察状态的概率，后面一部分是所有t时刻的隐藏状态到 t+1 时候的隐藏状态j的转移的概率的和。这样我们每一步的计算都可以利用上一步的结果，节省了很多时间。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　4) 公式推导&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;b&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6974525598a03b5e10940731a4f269c5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;178&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6974525598a03b5e10940731a4f269c5&quot; data-watermark-src=&quot;v2-92dfc882ecdac9c9a873bed89fb5bdbb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;/b&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-28f0659cd3329306cee7c76e8758cd58_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;604&quot; data-rawheight=&quot;413&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-28f0659cd3329306cee7c76e8758cd58&quot; data-watermark-src=&quot;v2-591e1666867c0ce69003c249033a33c7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　5) 降低计算复杂度&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 我们可以比较穷举和递归算法的复杂度。假设有一个 &lt;b&gt;HMM&lt;/b&gt;，其中有 n 个隐藏状态，我们有一个长度为 T 的观察序列。&lt;/p&gt;&lt;p&gt; 穷举算法的需要计算所有可能的隐藏序列：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5d760ffe38b30aebc6f027c6bf54f8b5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;179&quot; data-rawheight=&quot;38&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 需要计算：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5362391cdedaeb7f75255f664ce689e0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;228&quot; data-rawheight=&quot;75&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5362391cdedaeb7f75255f664ce689e0&quot; data-watermark-src=&quot;v2-f71930454c38bb1b0d8718ff565fd5bc&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 很显然穷举算法的时间开销是和 T 指数相关的，即 NT，而如果采用递归算法，由于我们每一步都可以利用上一步的结果，所以是和 T 线性相关的，即复杂度是 N2T。&lt;/p&gt;&lt;p&gt; 这里我们的目的是在某个给定的 &lt;b&gt;HMM&lt;/b&gt; 下，计算出某个可观察序列的概率。我们通过先计算部分概率的方式递归的计算整个序列的所有路径的概率，大大节省了时间。在 t=1 的时候，使用了初始概率和&lt;b&gt;混淆矩阵&lt;/b&gt;的概率，而在t时刻的概率则可以利用 t-1 时刻的结果。&lt;/p&gt;&lt;p&gt; 这样我们就可以用递归的方式来计算所有可能的路径的概率和，最后，所有的部分概率的计算公式为&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4970b69d0fbffbb9b82043dc85d98b6b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;189&quot; data-rawheight=&quot;66&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 使用天气的例子，计算 t=2 时刻的 cloudy 状态的概率方法如图：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-18cdcc4a7de63ebe8817fe70ddc5ea1c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;364&quot; data-rawheight=&quot;342&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-18cdcc4a7de63ebe8817fe70ddc5ea1c&quot; data-watermark-src=&quot;v2-3f0e70826c737bd9474bb9978fbe0ce5&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 我们使用&lt;b&gt;前向算法&lt;/b&gt;在给定的一个 &lt;b&gt;HMM&lt;/b&gt; 下计算某个可观察序列的概率。&lt;b&gt;前向算法&lt;/b&gt;主要采用的是递归的思想，利用之前的计算结果。有了这个算法，我们就可以在一堆 &lt;b&gt;HMM&lt;/b&gt; 中，找到一个最满足当前的可观察序列的模型（前向算法计算出来的概率最大）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　（二） 根据可观察状态的序列找到一个最可能的隐藏状态序列&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 和上面一个问题相似的并且更有趣的是根据可观察序列找到隐藏序列。在很多情况下，我们对隐藏状态更有兴趣，因为其包含了一些不能被直接观察到的有价值的信息。比如说在海藻和天气的例子中，一个隐居的人只能看到海藻的状态，但是他想知道天气的状态。这时候我们就可以使用 &lt;b&gt;Viterbi 算法&lt;/b&gt;来根据可观察序列得到最优可能的隐藏状态的序列，当然前提是已经有一个 &lt;b&gt;HMM&lt;/b&gt;。&lt;/p&gt;&lt;p&gt; 另一个广泛使用 &lt;b&gt;Viterbi 算法&lt;/b&gt;的领域是自然语言处理中的词性标注。句子中的单词是可以观察到的，词性是隐藏的状态。通过根据语句的上下文找到一句话中的单词序列的最有可能的隐藏状态序列，我们就可以得到一个单词的词性（可能性最大）。这样我们就可以用这种信息来完成其他一些工作。&lt;/p&gt;&lt;p&gt; 下面介绍一下&lt;b&gt;维特比算法 &lt;/b&gt;(Viterbi Algorithm)&lt;/p&gt;&lt;p&gt; 　一．如何找到可能性最大的隐藏状态序列？&lt;/p&gt;&lt;p&gt; 通常我们都有一个特定的 &lt;b&gt;HMM&lt;/b&gt;，然后根据一个可观察状态序列去找到最可能生成这个可观察状态序列的隐藏状态序列。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　1. 穷举搜索&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 我们可以在下图中看到每个隐藏状态和可观察状态的关系。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a4cb68f8e62bc8fb11b95ee3b27b3d04_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;408&quot; data-rawheight=&quot;187&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a4cb68f8e62bc8fb11b95ee3b27b3d04&quot; data-watermark-src=&quot;v2-c7539ac1f64c4d90df95a5f4a75a1a2a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 通过计算所有可能的隐藏序列的概率，我们可以找到一个可能性最大的隐藏序列，这个可能性最大的隐藏序列最大化了 Pr(观察序列 | 隐藏状态集)。比如说，对于上图中的可观察序列 (dry damp soggy)，最可能的隐藏序列就是下面这些概率中最大的：&lt;/p&gt;&lt;p&gt; Pr(dry, damp, soggy | sunny, sunny, sunny), ……，Pr(dry, damp, soggy | rainy, rainy, rainy)&lt;/p&gt;&lt;p&gt; 这个方法是可行的，但是计算代价很高。和&lt;b&gt;前向算法&lt;/b&gt;一样，我们可以利用转移概率在时间上的不变性来降低计算的复杂度。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　2. 使用递归降低复杂度&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 在给定了一个可观察序列和HMM的情况下，我们可以考虑递归的来寻找最可能的隐藏序列。我们可以先定义一个部分概率 δ，即到达某个中间状态的概率。接下来我们将讨论如何计算 t=1 和 t=n (n&amp;gt;1) 的部分概率。&lt;/p&gt;&lt;p&gt; 注意这里的部分概率和&lt;b&gt;前向算法&lt;/b&gt;中的部分概率是不一样的，这里的部分概率表示的是在t时刻最可能到达某个状态的一条路径的概率，而不是所有概率之和&lt;b&gt;。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　1) 部分概率和部分最优路径&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 考虑下面这个图以及可观察序列 (dry, damp, soggy) 的一阶转移&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0697dc39b207c07517f497d9b86fa2d2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;337&quot; data-rawheight=&quot;216&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0697dc39b207c07517f497d9b86fa2d2&quot; data-watermark-src=&quot;v2-4e6d77a4c09fef4d0fc2c1f704b2ad55&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 对于每一个中间状态和终止状态 (t=3) 都有一个最可能的路径。比如说，在 t=3 时刻的三个状态都有一个如下的最可能的路径：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d82d1ce15a62e186cd21b3beff42fc94_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;394&quot; data-rawheight=&quot;114&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d82d1ce15a62e186cd21b3beff42fc94&quot; data-watermark-src=&quot;v2-1ff6749702fa7ebb5a2dcf7043f1e584&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 我们可以称这些路径为&lt;b&gt;部分最优路径&lt;/b&gt;。这些部分最优路径都有一个概率，也就是部分概率 δ。和&lt;b&gt;前向算法&lt;/b&gt;中的部分概率不一样，这里的概率只是一个最可能路径的概率，而不是所有路径的概率和。&lt;/p&gt;&lt;p&gt; 我们可以用 δ(i, t) 来表示在t时刻，到状态i的所有可能的序列（路径）中概率最大的序列的概率，部分最优路径就是达到这个最大概率的路径，对于每一个时刻的每一个状态都有这样一个概率和部分最优路径。&lt;/p&gt;&lt;p&gt; 最后，我们通过计算 t=T 时刻的每一个状态的最大概率和部分最优路径，选择其中概率最大的状态和它的部分最优路径来得到全局的最优路径。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　2) 计算 t=1 时刻的部分概率&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 当 t=1 时刻的时候，到达某个状态最大可能的路径还不存在，但是我们可以直接使用在 t=1 时刻某个状态的概率和这个状态到可观察序列 k1 的转移概率：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-36bbf69d89c2703dc2e55727443f4eda_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;156&quot; data-rawheight=&quot;43&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　3) 计算 t&amp;gt;1 时刻的部分概率&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 接下来我们可以根据 t-1 时刻的部分概率来求 t 时刻的部分概率&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-dc5491ae97c35edc603a46a1d4fa2296_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;286&quot; data-rawheight=&quot;139&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-dc5491ae97c35edc603a46a1d4fa2296&quot; data-watermark-src=&quot;v2-4e3ea6f2216d5fce7e11e4518fce1d5a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 我们可以计算所有到状态 X 的路径的概率，找到其中最可能的路径，也就是局部最优路径。注意到这里，到达X的路径必然会经过 t-1 时刻的 A、B 和 C，所以我们可以利用之前的结果。达到X的最可能的路径就是下面三个之一：&lt;/p&gt;&lt;p&gt; (状态序列)，. . .，A，X (状态序列)，. . .，B，X (状态序列)，. . .，C，X&lt;/p&gt;&lt;p&gt; 我们需要做的就是找到以 AX、BX 和 CX 结尾的路径中概率最大的那个。&lt;/p&gt;&lt;p&gt; 根据&lt;b&gt;一阶马尔科夫的假设&lt;/b&gt;，一个状态的发生之和之前的一个状态有关系，所以X在某个序列的最后发生的概率只依赖于其之前的一个状态：&lt;/p&gt;&lt;p&gt;Pr (到达A的最优路径) . Pr (X | A) . Pr (观察状态 | X)&lt;/p&gt;&lt;p&gt; 有个了这个公式，我们就可以利用t-1时刻的结果和状态转移矩阵和混淆矩阵的数据：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4a13df57c36d23191ab307a3e854ec6b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;599&quot; data-rawheight=&quot;33&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 将上面这个表达式推广一下，就可以得到 t 时刻可观察状态为 kt 的第 i 个状态的最大部分概率的计算公式：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98dd6db2b61c0334755cd504ca464ac8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;242&quot; data-rawheight=&quot;51&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-98dd6db2b61c0334755cd504ca464ac8&quot; data-watermark-src=&quot;v2-b60ff8d83332448d31361ad082fe0300&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 其中 aji 表示从状态 j 转移到状态 i 的概率，bikt 表示状态i被观察成 kt 的概率。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　4) 后向指针&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 考虑下图&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0ba0a23c0dba967a6ff39e60ff9d5da9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;333&quot; data-rawheight=&quot;213&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0ba0a23c0dba967a6ff39e60ff9d5da9&quot; data-watermark-src=&quot;v2-a4c5e96eb0d3b34a43df0e14c3551c26&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 在每一个中间状态和结束状态都有一个部分最优概率 δ(i, t)。但是我们的目的是找到最可能的隐藏状态序列，所以我们需要一个方法去记住部分最优路径的每一个节点。&lt;/p&gt;&lt;p&gt; 考虑到要计算 t 时刻的部分概率，我们只需要知道 t-1 时刻的部分概率，所以我们只需要记录那个导致了 t 时刻最大部分概率的的状态，也就是说，在任意时刻，系统都必须处在一个能在下一时刻产生最大部分概率的状态。如下图所示：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-93efd1be81ff5ee48910a73a7c70ac2b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;282&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-93efd1be81ff5ee48910a73a7c70ac2b&quot; data-watermark-src=&quot;v2-a9a7aa12671540397e06925f09c2a723&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 我们可以利用一个后向指针 φ 来记录导致某个状态最大局部概率的前一个状态，即&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3aa1b5b691882bb8b7e499fd2db20a68_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;296&quot; data-rawheight=&quot;37&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 这里 argmax 表示能最大化后面公式的j值，同样可以发现这个公式和 t-1 时刻的部分概率和转移概率有关，因为后向指针只是为了找到“我从哪里来”，这个问题和可观察状态没有关系，所以这里不需要再乘上混淆矩阵因子。全局的行为如下图所示：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-03b7629d556f5ea86bcd3b6b68104f70_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;202&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-03b7629d556f5ea86bcd3b6b68104f70&quot; data-watermark-src=&quot;v2-a23650ba97cfe3217eac5014458dcf83&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　5) 优点&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 使用 &lt;b&gt;viterbi &lt;/b&gt;算法对一个可观察状态进行解码有两个重要的优点：&lt;/p&gt;&lt;p&gt; a) 通过使用递归来减少复杂度，这点和之前的&lt;b&gt;前向算法&lt;/b&gt;是一样的&lt;/p&gt;&lt;p&gt; b) 可以根据可观察序列找到最优的隐藏序列，这个的计算公式是：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5d760ffe38b30aebc6f027c6bf54f8b5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;179&quot; data-rawheight=&quot;38&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;其中 &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-402beb019c7789ffaa9c675f4a28177a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;223&quot; data-rawheight=&quot;74&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-402beb019c7789ffaa9c675f4a28177a&quot; data-watermark-src=&quot;v2-75140cbd792d8e69bcd30a54ce93876f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 这里就是一个从左往右翻译的过程，通过前面的翻译结果得到后面的结果，起始点是初始向量 π。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　3. 补充&lt;/b&gt;&lt;/p&gt;&lt;p&gt; 但在序列某个地方有噪声干扰的时候，某些方法可能会和正确答案相差的较远。但是 &lt;b&gt;Viterbi &lt;/b&gt;算法会查看整个序列来决定最可能的终止状态，然后通过后向指针来找到之前的状态，这对忽略孤立的噪声非常有用。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　Viterbi&lt;/b&gt; 算法提供了一个根据可观察序列计算隐藏序列的很高效的方法，它利用递归来降低计算复杂度，并且使用之前全部的序列来做判断，可以很好的容忍噪声。&lt;/p&gt;&lt;p&gt; 在计算的过程中，这个算法计算每一个时刻每一个状态的部分概率，并且使用一个后向指针来记录达到当前状态的最大可能的上一个状态。最后，最可能的终止状态就是隐藏序列的最后一个状态，然后通过后向指针来查找整个序列的全部状态。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　（三） 根据观察到的序列集来找到一个最有可能的 HMM。 &lt;/b&gt;&lt;/p&gt;&lt;p&gt; 在很多实际的情况下，&lt;b&gt;HMM&lt;/b&gt; 不能被直接的判断，这就变成了一个学习问题，因为对于给定的可观察状态序列 O 来说，没有任何一种方法可以精确地找到一组最优的 &lt;b&gt;HMM&lt;/b&gt; 参数 &lt;b&gt;λ&lt;/b&gt; 使 P(O | λ) 最大，于是人们寻求使其局部最优的解决办法，而&lt;b&gt;前向后向算法&lt;/b&gt;（也称为&lt;b&gt;Baum-Welch&lt;/b&gt;算法）就成了 &lt;b&gt;HMM&lt;/b&gt;学习问题的一个近似的解决方法。&lt;/p&gt;&lt;p&gt;&lt;b&gt;　　前向后向算法&lt;/b&gt;首先对于 &lt;b&gt;HMM&lt;/b&gt; 的参数进行一个初始的估计，但这个很可能是一个错误的猜测，然后通过对于给定的数据评估这些参数的的有效性并减少它们所引起的错误来更新 &lt;b&gt;HMM&lt;/b&gt; 参数，使得和给定的训练数据的误差变小，这其实是&lt;b&gt;机器学习&lt;/b&gt;中的&lt;b&gt;梯度下降&lt;/b&gt;的思想。&lt;/p&gt;&lt;p&gt; 对于网格中的每一个状态，&lt;b&gt;前向后向算法&lt;/b&gt;既计算到达此状态的“前向”概率，又计算生成此模型最终状态的“后向”概率，这些概率都可以通过前面的介绍利用递归进行高效计算。可以通过利用近似的&lt;b&gt; HMM&lt;/b&gt; 模型参数来提高这些中间概率从而进行调整，而这些调整又形成了&lt;b&gt;前向后向算法&lt;/b&gt;迭代的基础。&lt;/p&gt;&lt;p&gt; 另外，&lt;b&gt;前向后向算法&lt;/b&gt;是 &lt;b&gt;EM 算法&lt;/b&gt;的一个特例，它避免了 &lt;b&gt;EM 算法&lt;/b&gt;的暴力计算，而采用动态规划思想来解决问题，Jelinek 在其书《Statistical Methods for Speech Recognition》中对&lt;b&gt;前向后向算法&lt;/b&gt;与 &lt;b&gt;EM 算法&lt;/b&gt;的关系进行了详细描述，有兴趣的读者可以参考这本书。&lt;/p&gt;&lt;p&gt; 类似于上面讲到的&lt;b&gt;前向算法&lt;/b&gt;，我们也可以定义后向变量 βt(i) 来计算给定当前隐藏状态 i 时，部分观察序列 ot+1，ot+2，…，oT的概率，即：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-713ea636c4faf15066a4d9fbe17be240_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;343&quot; data-rawheight=&quot;41&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 与前向算法类似，我们也可以通过迭代算法有效计算 βt(i)，计算公式如下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2dd6fbd76fab5ed92babfb09c1f9d4cc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;387&quot; data-rawheight=&quot;65&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2dd6fbd76fab5ed92babfb09c1f9d4cc&quot; data-watermark-src=&quot;v2-4e82e61f4f3f405bc009a86833f1baa4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 其中&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-416ae3b7ee3ea4f8bcb92369e3213fd4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;178&quot; data-rawheight=&quot;39&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 进一步我们可以发现&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2e1a2805e118f107d02710c5af0190a7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;447&quot; data-rawheight=&quot;42&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 因此&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6cf8804c0a99796ce4f8c891854eb44d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;526&quot; data-rawheight=&quot;62&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 下面开始介绍&lt;b&gt;前向后向算法&lt;/b&gt;。&lt;/p&gt;&lt;p&gt; 首先我们需要定义两个辅助变量，这两个变量可以用前文介绍过的前向变量和后向变量进行定义。&lt;/p&gt;&lt;p&gt; 第一个变量定义为 t 时状态 i 和 t+1 时状态 j 的概率，即&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-58fd120cf04fd003255b26a3f6a8a98e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;327&quot; data-rawheight=&quot;44&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 该变量在网格中所代表的关系如下图所示：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e2c986678c089b8969b4052ec6ca6fae_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;444&quot; data-rawheight=&quot;220&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e2c986678c089b8969b4052ec6ca6fae&quot; data-watermark-src=&quot;v2-252158fe4afc9d6e28c4aec4555201fa&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt; 该等式等价于&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fe8da010b89cbac5bc83e00350395057_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;294&quot; data-rawheight=&quot;58&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-fe8da010b89cbac5bc83e00350395057&quot; data-watermark-src=&quot;v2-6012282059f5646d8a256b8e3a068464&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 利用前向变量和后向变量，上式可以表示为&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ffb6530856c9d3302b929f360d053f96_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;323&quot; data-rawheight=&quot;98&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ffb6530856c9d3302b929f360d053f96&quot; data-watermark-src=&quot;v2-014168153cb78f19610763bcff437d51&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 第二个变量定义为后验概率，也就是在给定观察状态序列和 &lt;b&gt;HMM &lt;/b&gt;的情况下，t 时状态 i 的概率，即&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-75e2fbde6f188361aebcb8060a8ad572_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;232&quot; data-rawheight=&quot;37&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 利用前向变量和后向变量，上式可以表示为&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-90cda2de9a4b12e87a0861349241b136_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;222&quot; data-rawheight=&quot;131&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-90cda2de9a4b12e87a0861349241b136&quot; data-watermark-src=&quot;v2-788b4ddc48e034714b5e4dd1a672ad64&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　因此，下式为在任意时刻状态 i 的期望，也就是从状态 i 转移到观察状态 o 的期望&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;　　同样，下式也就是从状态 i 转移到状态 j 的期望&lt;/p&gt;&lt;p&gt; 我们可以发现定义的这两个变量之间的关系为&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1d180a461208a9195960c238cb55258d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;310&quot; data-rawheight=&quot;60&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1d180a461208a9195960c238cb55258d&quot; data-watermark-src=&quot;v2-18b0ae9cef6ee555628f546cef842e4f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 下面介绍&lt;b&gt;前向后向算法&lt;/b&gt;的参数学习过程，在学习的过程中，不断更新 &lt;b&gt;HMM&lt;/b&gt; 的参数，从而使得 P(O | λ) 最大。我们假设初始的 &lt;b&gt;HMM&lt;/b&gt; 参数为  λ={ π, &lt;i&gt;A, B &lt;/i&gt;}，首先计算前向变量 α 和后向变量 β，再根据刚刚介绍的公式计算期望 ξ 和 ζ，最后，根据下面的3个重估计公式更新&lt;b&gt; HMM&lt;/b&gt; 参数。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2900dea8b567efa998aded7fbdf3b425_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;348&quot; data-rawheight=&quot;287&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2900dea8b567efa998aded7fbdf3b425&quot; data-watermark-src=&quot;v2-490b97ffecef24280a06b1779e1bea7d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt; 如果我们定义当前的 &lt;b&gt;HMM&lt;/b&gt; 模型为 λ={ π，&lt;i&gt;A，B &lt;/i&gt;}，那么可以利用该模型计算上面三个式子的右端；我们再定义重新估计的 &lt;b&gt;HMM&lt;/b&gt; 模型为&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-536b33d3c3ef06f4638657f0bab4b7d4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;86&quot; data-rawheight=&quot;26&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;，那么上面三个式子的左端就是重估的 &lt;b&gt;HMM&lt;/b&gt; 模型参数。Baum 及他的同事在70年代证明了&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a7cf43798821be9bafbec6f6f148d43d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;136&quot; data-rawheight=&quot;28&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;，因此如果我们迭代地计算上面三个式子，由此不断地重新估计 &lt;b&gt;HMM&lt;/b&gt; 的参数，那么在多次迭代后可以得到 &lt;b&gt;HMM&lt;/b&gt; 模型的一个最大似然估计。不过需要注意的是，前向后向算法所得的这个最大似然估计是一个局部最优解。&lt;/p&gt;</description>
<author>量化家</author>
<guid isPermaLink="false">2018-07-31-40962600</guid>
<pubDate>Tue, 31 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>策略||数据处理</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-07-30-40876243.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40876243&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;异常数据的影响&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;以2016年5月底全市场股票的ROE数据为例，这里总共有2824个数据：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;between = roe[(roe.ROE &amp;lt;= 0.5) &amp;amp; (roe.ROE &amp;gt;= -0.5)]
float(len(between))/len(roe)&lt;/code&gt;&lt;p&gt;0.9851274787535411&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以看到有98%的数据都在[-0.5, 0.5]之间&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;去掉上下各1%的数据&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;remove = roe[(roe.ROE &amp;lt;= roe.quantile(0.99).iloc[0]) &amp;amp;
 (roe.ROE &amp;gt;=roe.quantile(0.01).iloc[0])]&lt;/code&gt;&lt;h2&gt;&lt;b&gt;异常值的识别&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;固定比例法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上下2%的值进行拉回，这些数据不可信。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;均值标准差法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这种想法的思路来自于正态分布，假设&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a9d4e5ce53a24c718b892a69ba007d42_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;97&quot; data-rawheight=&quot;23&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;那么&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-547d86e0e8df086419092f49b371cfb2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;311&quot; data-rawheight=&quot;67&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-547d86e0e8df086419092f49b371cfb2&quot; data-watermark-src=&quot;v2-929ff202a3d3666e155c3235e6f73b91&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;通常把三倍标准差之外的值都视为异常值，不过要注意的是样本均值和样本标准差都不是稳健统计量，其计算本身受极值的影响就非常大，所以可能会出现一种情况，那就是我们从数据分布图上能非常明显的看到异常点，但按照上面的计算方法，这个异常点可能仍在均值三倍标准差的范围内。因此按照这种方法剔除掉异常值后，需要重新观察数据的分布情况，看是否仍然存在显著异常点，若存在则继续重复上述步骤寻找异常点。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;理解：因为剔除掉极值后，样本的方差可能发生变化了（正如文中所说，它不是一个稳健的估计量），每次剔除通常都会变化——就是因为这个，所以需要重复的去做。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果数据不服从正态分布，可以通过切比雪夫不等式依然可以对均值的若干倍标准差之外的样本数据量的占比进行估计：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c65c7beed9d6de49f73eeff4f72985ca_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;212&quot; data-rawheight=&quot;35&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;坏处对于这样的方法，上面不等式右边的上界数值会偏大，在数据分布的偏度和峰度影响下，这种方法可能会把过量的数据认定为异常点。 &lt;/p&gt;&lt;p&gt;如果通过Box-Cox变换将不服从正态分布的数据转化为服从正态分布的数据，那么是否可行呢？熟悉Box-Cox变换方法的都知道，经过这样的一个变换，例如就取对数，它会缩小数据之间的距离，这样可能会使得原来是异常值的点变为不是异常值。&lt;br&gt;&lt;b&gt;MAD法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;MAD 法是针对均值标准差方法的改进，把均值和标准差替换成稳健统计量，样本均值用样本中位数代替，样本标准差用样本MAD（Median Absolute Deviation）代替：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0313342a387d2e4947bc295003a7d67b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;240&quot; data-rawheight=&quot;31&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c276044210dd85c5c00f0592fd11cfb7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;314&quot; data-rawheight=&quot;28&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f07c81a5dffb04dca08b8400ac85e077_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;184&quot; data-rawheight=&quot;32&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;通常把偏离中位数三倍以上的数据作为异常值。和均值标准差方法比，中位数和MAD的计算不受极端异常值的影响，结果更加稳健。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;boxplot法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们知道箱线图上其实也会注明异常值，假设Q1和Q3分别为数据从小到大排列的25%和75%分位数，记IQR=Q1-Q3，把&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ab260048641a01e98e4ea125020dce84_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;309&quot; data-rawheight=&quot;22&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;区间里的数据标识为异常点。分位数也是稳健统计量，因此Boxplot 方法对极值不敏感，但如果样本数据正偏严重，且右尾分布明显偏厚时，Boxplot 方法会把过多的数据划分为异常数据，因此Hubert&amp;amp; Vandervieren （2007）对原有Boxplot 方法进行了偏度调整。首先样本偏度定义采用了Brys(2004)提出的MedCouple方法：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c5206623c31cb6fcf03ab15cb6533930_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;231&quot; data-rawheight=&quot;30&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1428c4297a783136cad3114640a404e7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;457&quot; data-rawheight=&quot;52&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;然后给出了经偏度调整boxplot方法上下限：&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3e82d5d101f6be87936b73cbcdf3b18a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;390&quot; data-rawheight=&quot;103&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-3e82d5d101f6be87936b73cbcdf3b18a&quot; data-watermark-src=&quot;v2-f620a2377be043ea6a573877c6df335a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;区间上的点视为异常点。和原始Boxplot 方法相比，当样本数据分布右偏时，此法会提升正常数据区间上限的数值；样本数据左偏时，则会降低正常数据区间下限的数值。&lt;/p&gt;&lt;p&gt;这个mc可以使用statsmodels包中的函数直接进行计算&lt;br&gt;&lt;/p&gt;&lt;p&gt;def _medcouple_1d(y):    &quot;&quot;&quot;&lt;br&gt;    Calculates the medcouple robust measure of skew.&lt;br&gt;    Parameters&lt;br&gt;    ----------&lt;br&gt;    y : array-like, 1-d&lt;br&gt;    Returns&lt;br&gt;    -------&lt;br&gt;    mc : float&lt;br&gt;        The medcouple statistic&lt;br&gt;    Notes&lt;br&gt;    -----&lt;br&gt;    The current algorithm requires a O(N**2) memory allocations, and so may&lt;br&gt;    not work for very large arrays (N&amp;gt;10000).&lt;br&gt;    .. [1] M. Huberta and E. Vandervierenb, &quot;An adjusted boxplot for skewed&lt;br&gt;    distributions&quot; Computational Statistics &amp;amp; Data Analysis, vol. 52,&lt;br&gt;    pp. 5186-5201, August 2008.&lt;br&gt;    &quot;&quot;&quot;&lt;br&gt;    y = np.squeeze(np.asarray(y))    &lt;br&gt;    if y.ndim != 1:        &lt;br&gt;        raise ValueError(&quot;y must be squeezable to a 1-d array&quot;)&lt;br&gt;    y = np.sort(y)&lt;br&gt;    n = y.shape[0]    if n % 2 == 0:&lt;br&gt;        mf = (y[n // 2 - 1] + y[n // 2]) / 2    else:&lt;br&gt;        mf = y[(n - 1) // 2]&lt;br&gt;    z = y - mf&lt;br&gt;    lower = z[z &amp;lt;= 0.0]&lt;br&gt;    upper = z[z &amp;gt;= 0.0]&lt;br&gt;    upper = upper[:, None]&lt;br&gt;    standardization = upper - lower&lt;br&gt;    is_zero = np.logical_and(lower == 0.0, upper == 0.0)&lt;br&gt;    standardization[is_zero] = np.inf&lt;br&gt;    spread = upper + lower    return np.median(spread / standardization)&lt;br&gt;sm.stats.stattools.medcouple(roe.ROE)&lt;/p&gt;&lt;p&gt;array(0.04458953766624774)&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;偏度调整Boxplot和MAD方法对比&lt;/b&gt;&lt;/p&gt;&lt;p&gt;首先使用计算机模拟来进行比较这两种方法。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-421667d5d0e372b7e0d0b74cb6f52c10_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;760&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-421667d5d0e372b7e0d0b74cb6f52c10&quot; data-watermark-src=&quot;v2-cd59c1299824ffdb035e8571a91adf23&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;# 计算异常值占比

def mad(x):    if len(x) == 0:        
        return np.NaN    
    else:
        md = np.median(x)
        mad_ = np.median([np.abs(i-md) for i in x])
        mad_e = 1.483*mad_
        left_percent = len(x[(x&amp;lt;=(md-3*mad_e))])/float(len(x))
        right_percent = len(x[(x&amp;gt;=(md+3*mad_e))])/float(len(x))
        total = len(x[(x&amp;lt;=(md-3*mad_e))|(x&amp;gt;=(md+3*mad_e))])/float(len(x))        
    return [left_percent, right_percent, total]

def adj_boxplot(x):    if len(x) == 0:        
        return np.NaN    
    else:
        mc = sm.stats.stattools.medcouple(x)
        x.sort()
        q1 = x[int(0.25*len(x))]
        q3 = x[int(0.75*len(x))]
        iqr = q3-q1        
    if mc &amp;gt;= 0:
            l = q1-1.5*np.exp(-3.5*mc)*iqr
            u = q3+1.5*np.exp(4*mc)*iqr        
    else:
            l = q1-1.5*np.exp(-4*mc)*iqr
            u = q3+1.5*np.exp(3.5*mc)*iqr
        left_percent = len(x[x&amp;lt;=l])/float(len(x))
        right_percent = len(x[x&amp;gt;=u])/float(len(x))
        total = len(x[(x&amp;lt;=l)|(x&amp;gt;=u)])/float(len(x))        
    return [left_percent, right_percent, total]
fig = plt.figure(figsize=(7, 4))
ax = fig.add_subplot(111)
ax.plot(adj_boxplot_left, &#39;-o&#39;, label=&#39;adj_boxplot&#39;)
ax.plot(mad_method_left, &#39;-^&#39;, label=&#39;mad&#39;)
l = ax.legend(loc=1)
l = ax.set_ylabel(u&quot;left percentage&quot;)
l = ax.set_xticklabels([&#39;SN&#39;, &#39;LN(0, 0.2)&#39;, &#39;LN(0, 0.4)&#39;, &#39;LN(0, 0.6)&#39;, &#39;LN(0, 0.8)&#39;, &#39;LN(0, 1)&#39;])
l = ax.set_xlabel(u&quot;different distribution&quot;)&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8aa5c89791c4155a11747b0480a1a44d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;475&quot; data-rawheight=&quot;274&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-8aa5c89791c4155a11747b0480a1a44d&quot; data-watermark-src=&quot;v2-4477d6a70d85708ceaa909b882039df0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5f938cbfd5f1febb5018d803b89fe035_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;469&quot; data-rawheight=&quot;274&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5f938cbfd5f1febb5018d803b89fe035&quot; data-watermark-src=&quot;v2-fc606ac804f028f0d4f0408e08c2c03b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a781ad80c6b5bc6e86bb697188626d16_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;469&quot; data-rawheight=&quot;274&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a781ad80c6b5bc6e86bb697188626d16&quot; data-watermark-src=&quot;v2-2702af2ec8ae9c2a598685950cb5b0b9&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;还可以对单个分布，不同样本量进行测试，不写了。&lt;/p&gt;&lt;p&gt;再拿个几因子实际来比较这两种方法。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;def compare_factor(factor_name, month_list):    factor_data = pd.DataFrame(index=month_list, columns=universe)    
for date in factor_data.index:
        current_data = DataAPI.MktStockFactorsOneDayProGet(tradeDate=date, secID=universe, 
                                                           field=[u&quot;secID&quot;, u&quot;tradeDate&quot;,factor_name], pandas=&quot;1&quot;)
        current_data = current_data.pivot(index=&#39;tradeDate&#39;, columns=&#39;secID&#39;, values=factor_name)
        factor_data = factor_data.append(current_data)
    percent_mad = []
    precent_boxplot = []    
    for date in factor_data.index:
        sample = np.array(factor_data.ix[date, :].dropna())        if isinstance(mad(sample), list):
            percent_mad.append(mad(sample)[2])
            precent_boxplot.append(adj_boxplot(sample)[2])

    a = np.array(percent_mad).mean()
    b = np.array(precent_boxplot).mean()    
return [a, b, factor_data]
PEG3Y = compare_factor(&#39;PEG3Y&#39;, month_list)
print u&#39;市盈率/归属于母公司所有者净利润3年复合增长率:&#39;, u&#39;MAD&#39;, PEG3Y[0], &#39;;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;市盈率/归属于母公司所有者净利润3年复合增长率:&lt;/p&gt;&lt;p&gt;MAD 0.140822936272 &lt;/p&gt;&lt;p&gt; Adj boxplot 0.158164542833&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;对数市值:&lt;/p&gt;&lt;p&gt;MAD 0.0291881850994 ;&lt;/p&gt;&lt;p&gt;Adj boxplot 0.00655765983319&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;对数流通市值:&lt;/p&gt;&lt;p&gt;MAD 0.0221524346318 ;&lt;/p&gt;&lt;p&gt;Adj boxplot 0.0229505798271&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;和Seo(2002)做的仿真测试结果一致，对于市值这样样本偏度较大的数据，MAD方法识别出的异常数值比例明显高于偏度调整后的Boxplot方法。从研报的结果来看，MAD方法认定的异常数据数量明显高于Boxplot方法，剔除或修改太多数据不利于后续的统计分析。可以尝试人为提高MAD方法中的一些阈值设置来降低异常数据占比，但这样有可能使得一些本该剔除的数据未被侦测出来，如果每个因子都设置一个阈值的话，调试的工作量会比较大。相对来说，偏度调整过的Boxplot方法对不同因子的适应性更强，建议在实证研究中采用。&lt;/p&gt;&lt;p&gt;&lt;b&gt;数据正太转换&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;非正态数据的影响&lt;/b&gt;&lt;/p&gt;&lt;p&gt;因子选股过程中至少有两个地方涉及因子数据的正态分布假设：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Alpha因子的zscore计算。只有当两个因子的分布都为近似正态分布时，基于均值-标准差标准化得到的zscore 才有可比性，否则样本偏度和峰度的影响会使得个股在某一个因子上的得分明显偏大或偏小，其在多因子中的效用被显著放大或缩小，也就是Scinto(2009)提到的Percential Ranking Problem。&lt;/li&gt;&lt;li&gt;风险因子的因子收益率显著性检验。因子收益率由横截面回归得到，其显著性检验有赖于残差项的正态分布假设，虽然线性回归对解释变量与被解释变量的分布没有要求，但当解释变量和被解释变量满足正态分布时，更容易得到符合正态分布的残差。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;每个因子数据都去看下偏度，峰度有点多。主要是电脑还在跑其他的耗内存的代码，所以就不做了。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;def my_winsorize(data):    if isinstance(data, pd.Series):
        mc = sm.stats.stattools.medcouple(data)
        data.sort()
        q1 = data[int(0.25*len(data))]
        q3 = data[int(0.75*len(data))]
        iqr = q3-q1        if mc &amp;gt;= 0:
            l = q1-1.5*np.exp(-3.5*mc)*iqr
            u = q3+1.5*np.exp(4*mc)*iqr        else:
            l = q1-1.5*np.exp(-4*mc)*iqr
            u = q3+1.5*np.exp(3.5*mc)*iqr
        data[data&amp;lt;l]=l
        data[data&amp;gt;u]=u    
return data
peg_3y = PEG3Y[2]
factor_skew = []
factor_kurt = []
for date in peg_3y.index:
    data = peg_3y.ix[date,:].dropna()    
    if len(data) &amp;gt; 0:
        data = my_winsorize(data)
        data = np.array(data)
        factor_skew.append(st.skew(data))
        factor_kurt.append(st.kurtosis(data))
print u&#39;极值调整后PEG3Y因子的平均偏度与峰度：&#39;
print u&#39;偏度：&#39;, np.mean(factor_skew)
print u&#39;峰度：&#39;, np.mean(factor_kurt)&lt;/code&gt;&lt;p&gt;极值调整后PEG3Y因子的平均偏度与峰度：&lt;/p&gt;&lt;p&gt;偏度： -3.00481152198 峰度： 10.2882451426&lt;/p&gt;&lt;p&gt;极值调整后LCAP因子的平均偏度与峰度：&lt;/p&gt;&lt;p&gt;偏度： 1.22322935534 峰度： 2.08015032857&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 Box-Cox变换&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在多元回归分析，时间序列分析中经常都见到Box-Cox变换变换。把非正态数据转换为正态数据通常有取对数、开根号、求倒数等方法，这些都可以归为Box-Cox变换，形式上可以写作：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cf2c73cedb3649c80b6f31ceeee71861_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;215&quot; data-rawheight=&quot;54&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-cf2c73cedb3649c80b6f31ceeee71861&quot; data-watermark-src=&quot;v2-4f93d5a3efc91d493f399d98e66aa436&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;参数λ可以通过极大似然法做估计（Box&amp;amp;Cox，1964）。不过Box-Cox 变换并非万能，变换后的数据仍然可能不满足正态分布，被统计检验拒绝，但是这种变换得到的数据分布往往都有明显的对称性，与正态分布的相似性更高。 只有取正值的数据才能使用Box-Cox变换，对于一些数据是负数或者为零，在Box-Cox变换之前，需要在所有值上加一个正数，使得所有数据为正。但这种移动是主观确定的。另一种方法是适用于任何数据的变换，无论正负，这种方法的一个缺点是，对他的解释不如对Box-Cox变换的解释来得直观，参见Yeo和Johnson(2000)。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3 正态变换的选择&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们知道一个因子通常包括两个维度，由于通常的alpha因子zscore 打分和风险因子中性化处理都在横截面方向进行，因此我们主要对同一个时间点横截面上的因子数据做正态转换处理。但是如果把数据正态转换当成一个纯粹的数学问题，每个横截面上都用极大似然方法估算一个最优的λ，会发现有的选股因子的λ数值变化非常之大。以EP因子的月度数据为例。&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;PE = compare_factor(&#39;PE&#39;, month_list)
EP= 1/PE[2]
lambda_ = pd.Series(index=EP.index)
for date in EP.index:
    data = np.array(EP.ix[date,:].dropna()+3, dtype=float)    
    if len(data) &amp;gt; 0:
        lambda_.ix[date]=st.boxcox(data)[1]    
    else:
        lambda_.ix[date]=np.NaN
lambda_.dropna(inplace=True)
ax = lambda_.plot()
t = ax.set_title(u&#39;EP因子Box-Cox变换的最优lambda&#39;, fontpropert=font, fontsize=16)&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-770dc5e5015ab7f146d2c586f089b2e1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;355&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-770dc5e5015ab7f146d2c586f089b2e1&quot; data-watermark-src=&quot;v2-f1df02d0fec9a4480ea8f28ef7ba3a9b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以看到Lambda中间有一段的变化是非常剧烈的，也就是说每个月我们需要对原始的数据都做不同的数据变化。Box-Cox是一个单调变换，保持了原有数据的相对秩序，因此变换后的因子和原始因子的IC（秩相关系数）相等；但这种变换会改变alpha因子的zscore，频繁剧烈变换的参数可能会对结果产生负面影响，变换后因子的经济含义也更加难以解释，所以把因子数据正态变换当成一个单纯数学问题的方法不可取。&lt;/p&gt;</description>
<author>量化家</author>
<guid isPermaLink="false">2018-07-30-40876243</guid>
<pubDate>Mon, 30 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>人工智能会给外汇行业带来什么样的改变？EA可以帮你赚钱吗？</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-07-27-40728317.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40728317&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-15469ac443d0584e6416cc25cea83381_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;人工智能，这几年是人们津津乐道的话题，各国政府、商界大佬都纷纷把注意力集中在人工智能技术上面，谷歌、百度等公司更是将AI作为下一步发展的战略核心。，可以说，抓住了人工智能，也就抓住了未来，科技这个东西，向来都是先到者先得。&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果说我们现在是互联网的时代，未来一定是人工智能的天下，人工智能将会给整个世界带来的变革，不会弱于互联网。随着无人驾驶，AI医疗等技术的发展，各行各业都被人工智能这个新技术撼动，外汇行业也不例外。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;人工智能为外汇行业带来的改变&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;2017年底，美国时代周刊发文称2018年将是金融机构全面智能化转型的一年，人工智能将成为金融机构的一种核心能力。高盛、花旗以及汇丰等大型金融机构每年都投入数十亿美金研究金融领域的人工智能技术应用，人工智能领域俨然已经成为国际金融公司重金搏杀的新战场。&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;人工智能的崛起，正在逐步改变着外汇市场的格局。&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;相比较其它行业的工作岗位，金&lt;b&gt;融行业因为数据量丰富，可以流程标准化的岗位较多，所以用 AI 算法代替人工，在提升效率的同时更降低了人工成本。&lt;/b&gt;同时，人工智能还有助于降低银行的合规成本，满足监管当局有关外汇定价和收费更加透明化的监管要求。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;各大银行都没有无视这种转变，&lt;/b&gt;花旗银行计划5年内裁员50%，采用人工智能算法代替他们的工作；巴克莱银行95%的即期交易从交易到结算都由自动化程序完成；瑞士联合银行约三分之二的交易通过其Neo平台处理......&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在外汇行业到处裁员的同时，自动化交易模式也开始盛行，&lt;b&gt;量化交易、程序化交易越来越受到各大机构的青睐，&lt;/b&gt;这也进一步减少了外汇行业从业人员的需求。与此同时，零售外汇行业也有越来越多的人倾向于自动化交易，各种策略、软件层出不穷，产品宣传更让人眼花缭乱，吸引了很多行业内外的人，人工智能正在从交易技术、成本、行业参与者等各个方面，重构整个外汇行业。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;人工智能可以帮交易者持续盈利吗&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;人工智能不管在银行间外汇市场还是在零售外汇市场都大受追捧，这是因为&lt;b&gt;人工智能在外汇交易方面有着其先天的优势。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;人工智能交易系统是个集合体，里面包含着无数人的智慧结晶，相当于站在巨人的肩膀上。&lt;b&gt;无论是在行情判断、仓位控制、交易纪律、风险控制和盈利能力方面，都会优于人工操作，优于普通的交易者&lt;/b&gt;；同时，它可以摆脱人生理上的局限，克服人性的弱点。人工智能交易系统不需要休息，&lt;b&gt;可以24小时无休的工作，&lt;/b&gt;对行情持续不断地监视，并且严格执行交易策略，不会有犹豫、恐惧和贪婪等情绪，也就是说，&lt;b&gt;你有一个保证盈利的交易策略，你就一定会赚钱。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;那么，问题就在这里，&lt;b&gt;“一个保证盈利的交易策略”这本身就不是那么容易做到的。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;普通的交易者，现在所接触的人工智能交易系统，大多是各种EA，它是将外汇交易策略编程后应用于交易平台，让电脑按照事先设定好的条件自动地执行持仓和买卖。所以盈利与否，取决于两点，&lt;b&gt;交易策略本身的优劣，以及交易策略的执行效果。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;一个良好的交易策略可以实现稳定的盈利，即使发生亏损也会在极小的范围内得到控制，而差的交易策略则可能会导致交易账户在极短的时间内就发生巨量亏损甚至爆仓。&lt;b&gt;所以一个优秀的EA其实要求非常高，需要有顶级的操盘手的经验和杰出的程序员进行设计编程。&lt;/b&gt;同时，没有一个固定的策略可以应对不断变化着的市场，EA策略还要随着时间不断进行人为优化。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;此外，由于EA运行过程中，需要大量的判断和计算，网络环境就显得至关重要，&lt;b&gt;配置强大的电脑和畅通的网络环境是EA顺利运行的保障，&lt;/b&gt;这些也是为什么大机构的自动化交易可以赚钱，很多投资者却在EA上赔了钱的原因。&lt;b&gt;EA总的来说是个工具，&lt;/b&gt;可以代替人工进行大量重复的劳动，处理海量人工无法处理的数据，&lt;b&gt;它是一个完美的执行者，但是它取胜的核心仍旧是人。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;事实上，人工智能最重要的还有一点就是它的学习能力，这也是AI与EA之间的差距。严格来说，EA是人工智能在外汇领域发展过程当中的一个孩子，还需要人的扶持和引导，而在未来，人工智能真的发展成熟了，可以自己对行情进行记录分析，并不断修正自己的策略，电脑对面将会剩下一个没有感情的，只有超强的判断力和运算能力的机器，那将会对是对现有模式的一种颠覆。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;内容转自网络，欢迎关注私信，有问必答！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;我是投资界C.Roiee，一个搞金融的男人。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;欢迎私信交流，有问必答！互相学习，共同进步！&lt;/b&gt;&lt;/p&gt;</description>
<author>投资界C.Roiee</author>
<guid isPermaLink="false">2018-07-27-40728317</guid>
<pubDate>Fri, 27 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>策略||数据可视化</title>
<link>https://henix.github.io/feeds/zhuanlan.c_106548378/2018-07-27-40701499.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40701499&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  Python中，matplotlib可以视为数据可视化的基准和主力。尽管有许多其他的可视化库，但是matplotlib已经确立了一个标杆，在许多情况下，它都是健壮、可靠的可视化工具。在标准的绘图工作中很容易理解，对更复杂的绘图和自定义又很灵活。此外，它与NumPy及其提供的数据结构紧密集成。下面就列举几个用二维数据集说明对金融应用程序中的可视化方法。&lt;/p&gt;&lt;p&gt;首先要先导入NumPy和matplotlib这两个库，主要的绘图函数在子库matplotlib.pyplot中：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0aa49f05c9b4e526101aa51fe804cf16_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;218&quot; data-rawheight=&quot;43&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0aa49f05c9b4e526101aa51fe804cf16&quot; data-watermark-src=&quot;v2-029880039662c6e85c49389c9b155f2e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;散点图&lt;/b&gt;&lt;/p&gt;&lt;p&gt;  要介绍的第一种图表是散点图，这种图表中一个数据集的值作为其他数据集的x值。例如，这种图标类型可用于绘制一个金融时间序列的收益和另一个时间序列收益的对比。下面例子中，将使用二维数据集和其他一些数据。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-27368169b1878a32582d8d6f5b5dc31b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;281&quot; data-rawheight=&quot;119&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-27368169b1878a32582d8d6f5b5dc31b&quot; data-watermark-src=&quot;v2-df73c2eb32f7b316b04802c601677e4d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5e589663446d4b841d56cd26f836e9e2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;468&quot; data-rawheight=&quot;400&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5e589663446d4b841d56cd26f836e9e2&quot; data-watermark-src=&quot;v2-ff42ebd91ec0abb6943a5b151bccfb7c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;b&gt;直方图&lt;/b&gt;&lt;/p&gt;&lt;p&gt;  另一种图表类型直方图也常常用于金融收益中。它是金融应用中的重要图表类型。主要应用plt.hist这个函数。下面显示的是两个数据集的数据在直方图中堆叠。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6b858265870bc1002f05c2bd5de954fb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;331&quot; data-rawheight=&quot;146&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6b858265870bc1002f05c2bd5de954fb&quot; data-watermark-src=&quot;v2-f1d06f509c77a73d7094007fdc27fd11&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-20e916ee8b7951c8e867fc45a24e0fb0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;530&quot; data-rawheight=&quot;248&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-20e916ee8b7951c8e867fc45a24e0fb0&quot; data-watermark-src=&quot;v2-fbb911445319e3198638e336d65c8651&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;箱形图&lt;/b&gt;&lt;/p&gt;&lt;p&gt;  另一种实用图表类型是箱形图。和直方图类似，它可以简洁概述数据集的特性，很容易比较多个数据集。通过下面的例子我们绘制出了这类图表。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-aff06ad2f5e9073fde2478965c25281a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;278&quot; data-rawheight=&quot;132&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-aff06ad2f5e9073fde2478965c25281a&quot; data-watermark-src=&quot;v2-2b209f644b4ec1b61ab8faca9ddb3777&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-830df5e5f7220632b81122eee8f4b7f1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;499&quot; data-rawheight=&quot;385&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-830df5e5f7220632b81122eee8f4b7f1&quot; data-watermark-src=&quot;v2-63bd51496470e7ea4285be435f81c3c8&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;特殊金融图表&lt;/b&gt;&lt;/p&gt;&lt;p&gt;  matplotlib还提供了少数精选的特殊金融图表。这些图表（如柱状图）主要用于可视化历史股价数据或者类似的金融时间序列数据，可以在matplotlib.finance子库中找到：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0383e514938d639c9fcca5f9de40fc18_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;225&quot; data-rawheight=&quot;18&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;作为一个方便的函数，且该子库可以简单地从雅虎财经网站（http://finance.yahoo.com）读取历史股价数据。只需要起始和结束日期，以及对应的股票代码。下面以读取德国DAX指数数据为例，其股票代码为^GDAXI:&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-695da7fc839c0417591bcd93d7d66a1d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;391&quot; data-rawheight=&quot;43&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt; 这里quotes包含了DAX指数的时间序列数据，包括日期、开盘价、最高价、最低价、收盘价和成交量：&lt;/p&gt;&lt;p&gt;matplotlib.finance的绘制函数能准确理解可能传递的格式和数据集，这里每日的正收益由蓝色的矩形表示，负收益由红色矩形表示。而且matplotlib会根据数据集中的日期信息，为x轴正确设置标签：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-13b047387a0f6b21a01bf47ca7762b07_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;436&quot; data-rawheight=&quot;122&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-13b047387a0f6b21a01bf47ca7762b07&quot; data-watermark-src=&quot;v2-6114d807cf085523c901ed33255a5c61&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-77a9070313c5894581c631a41a992a2b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;497&quot; data-rawheight=&quot;291&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-77a9070313c5894581c631a41a992a2b&quot; data-watermark-src=&quot;v2-412a7ee29bd6da9c1981a8ea5ba362d7&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;3D图形应用&lt;/b&gt;&lt;/p&gt;&lt;p&gt;  最后一个是在金融中的3D图形应用。金融中从3维可视化中获益的领域不是太大。但是，波动率平面是一个应用领域，它可以同时展示许多到期日和行权价的隐含波动率。下面例子中，我们人为生产一个类似波动率平面的图表。&lt;/p&gt;&lt;p&gt;为此，考虑如下因素：1.行权价格在50-150元之间。2.到期日在0.5-2.5年之间。&lt;/p&gt;&lt;p&gt;这提供了一个2维坐标系。我们可以使用NumPy的meshgrid函数，根据两个1维ndarray对象生成这样的坐标系：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-82061047546933d44a61b4c8d6690643_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;259&quot; data-rawheight=&quot;41&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;上述代码将两个1维数组转换为2维数组，在必要时重复原始坐标轴值：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d801a3ed1404e37bbbd4a238991a0f07_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;72&quot; data-rawheight=&quot;15&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;根据新的ndarray对象，我们通过简单的比例调整二次函数生成模拟的隐含波动率：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-eadacf7dfec781502baedd8a61045c7d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;264&quot; data-rawheight=&quot;16&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;通过下面代码即可得出图表：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9cd2fe9bb36da06639d5d138a01c5358_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;408&quot; data-rawheight=&quot;159&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9cd2fe9bb36da06639d5d138a01c5358&quot; data-watermark-src=&quot;v2-4aaf6c178f9acde092831f86e97e7e21&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-43c8ac31f7f5947685239df7c4216001_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;543&quot; data-rawheight=&quot;308&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-43c8ac31f7f5947685239df7c4216001&quot; data-watermark-src=&quot;v2-6b4279141e50e1e56bca5a5d165150dd&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>量化家</author>
<guid isPermaLink="false">2018-07-27-40701499</guid>
<pubDate>Fri, 27 Jul 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
