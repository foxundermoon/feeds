<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>王垠的知乎文章</title>
<link>https://henix.github.io/feeds/zhihu.posts.yinwang0/</link>
<description>当然我在扯淡</description>
<language>zh-cn</language>
<lastBuildDate>Sun, 11 Feb 2018 18:32:49 +0800</lastBuildDate>
<item>
<title>什么是语义学</title>
<link>https://henix.github.io/feeds/zhihu.posts.yinwang0/2018-01-29-33399227.htm</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33399227&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b5d38986b8a8f187dfbe127c1f1829b2_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;来源：王垠的博客&lt;/p&gt;&lt;blockquote&gt;很多人问我如何在掌握基本的程序语言技能之后进入“语义学”的学习。现在我就简单介绍一下什么是“语义”，然后推荐一本入门的书。这里我说的“语义”主要是针对程序语言，不过自然语言里的语义，其实本质上也是一样的。&lt;br&gt;&lt;br&gt;一个程序的“语义”通常是由另一个程序决定的，这另一个程序叫做“解释器”(interpreter)。程序只是一个数据结构，通常表示为语法树(abstractsyntaxtree)或者指令序列。这个数据结构本身其实没有意义，是解释器让它产生了意义。对同一个程序可以有不同的解释，就像上面这幅图，对画面元素的不同解释，可以看到不同的内容（少女或者老妇）。&lt;br&gt;&lt;br&gt;解释器接受一个“程序”(program)，输出一个“值”(value)。用图形的方法表示，解释器看起来就像一个箭头：程序===&gt;值。这个所谓的“值”可以具有非常广泛的含义。它可能是一个整数，一个字符串，也有可能是更加奇妙的东西。&lt;br&gt;&lt;br&gt;其实解释器不止存在于计算机中，它是一个很广泛的概念。其中好些你可能还没有意识到。写Python程序，需要Python解释器，它的输入是Python代码，输出是一个Python里面的数据，比如42或者“foo”。CPU其实也是一个解释器，它的输入是以二进制表示的机器指令，输出是一些电信号。人脑也是一个解释器，它的输入是图像或者声音，输出是神经元之间产生的“概念”。如果你了解类型推导系统(typeinference)，就会发现类型推导的过程也是一个解释器，它的输入是一个程序，输出是一个“类型”。类型也是一种值，不过它是一种抽象的值。比如，42对应的类型是int，我们说42被抽象为int。&lt;br&gt;&lt;br&gt;所以“语义学”，基本上就是研究各种解释器。解释器的原理其实很简单，但是结构非常精巧微妙，如果你从复杂的语言入手，恐怕永远也学不会。最好的起步方式是写一个基本的lambdacalculus的解释器。lambdacalculus只有三种元素，却可以表达所有程序语言的复杂结构。&lt;br&gt;&lt;br&gt;专门讲语义的书很少，现在推荐一本我觉得深入浅出的：《ProgrammingLanguagesandLambdaCalculi》。只需要看完前半部分（PartI和II，100来页）就可以了。这书好在什么地方呢？它是从非常简单的布尔表达式（而不是lambdacalculus）开始讲解什么是递归定义，什么是解释，什么是Church-Rosser，什么是上下文(evaluationcontext)。在让你理解了这种简单语言的语义，有了足够的信心之后，才告诉你更多的东西。比如lambdacalculus和CEK，SECD等抽象机(abstractmachine)。理解了这些概念之后，你就会发现所有的程序语言都可以比较容易的理解了。&lt;/blockquote&gt;</description>
<author>王垠</author>
<guid isPermaLink="false">2018-01-29-33399227</guid>
<pubDate>Mon, 29 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>什么是“对用户友好”</title>
<link>https://henix.github.io/feeds/zhihu.posts.yinwang0/2018-01-29-33398839.htm</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33398839&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b5d38986b8a8f187dfbe127c1f1829b2_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;来源：王垠的博客&lt;/p&gt;&lt;blockquote&gt;当我提到一个工具“对用户不友好”(user-unfriendly)的时候，我总是被人“鄙视”。难道这就叫“以其人之道还治其人之身”？想当年有人对我抱怨Linux或者TeX对用户不友好的时候，我貌似也差不多的态度吧。现在当我指出TeX的各种缺点，提出新的解决方案的时候，往往会有美国同学眼角一抬，说：“菜鸟们抱怨工具不好用，那是因为他们不会用。LaTeX是‘所想即所得’，所以不像Word之类的上手。”&lt;br&gt;&lt;br&gt;殊不知他面前这个“菜鸟”，其实早已把TeX的配置搞得滚瓜烂熟，把TeXbook翻来覆去看了两遍，”doublebend”的习题都全部完成，可以用TeX的语言来写宏包。而他被叫做“菜鸟”，这是一个非常有趣的问题。所以现在抛开个人感情不谈，我们来探讨一下这种“鄙视”现象产生的原因，以及什么叫做“对用户友好”。&lt;br&gt;&lt;br&gt;首先我们从心理的角度来分析一下为什么有人对这种“对用户不友好”的事实视而不见，而称抱怨的用户为“菜鸟”。这个似乎很明显，答案是“优越感”。如果每个人都会做一件事情，如何能体现出我的超群智力？所以我就是要专门选择那种最难用，最晦涩，最显得高深的东西，把它折腾会。这样我就可以被称为“高手”，就可以傲视群雄。我不得不承认，我以前也有类似的思想。从上本科以来我就一直在想，同样都会写程序，是什么让计算机系的学生与非计算机系的学生有所不同？经过多年之后的今天，我终于得到了答案（以后再告诉你）。可是在多年以前，我犯了跟很多人一样的错误：把“难度”与“智力”或者“专业程度”相等同。但是其实，一个人会用难用的工具，并不等于他智力超群或者更加专业。&lt;br&gt;&lt;br&gt;可惜的是，我发现世界上有非常少的人明白这个道理。在大学里，公司里，彰显自己对难用的工具的掌握程度的人比比皆是。这不只是对于计算机系统，这也针对数学以及逻辑等抽象的学科。经常听人很自豪的说：“我准备用XX逻辑设计一个公理化的系统……”可是这些人其实只知道这个逻辑的皮毛，他们会用这个逻辑，却不知道它里面所有含混晦涩的规则都可以用更简单更直观的方法推导出来。&lt;br&gt;&lt;br&gt;爱因斯坦说：“Any intelligent fool can make things bigger and more complex… It takes a touch of genius - and a lot of courage to move in the opposite direction.”我现在深深的体会到这句话的道理。想要简化一个东西，让它更“好用”，你确实需要很大的勇气。而且你必须故意的忽略这个东西的一些细节。但是由于你的身边都是不理解这个道理的人，他们会把你当成菜鸟或者白痴。即使你成功了，可能也很难说服他们去尝试这个简化后的东西。&lt;br&gt;&lt;br&gt;那么现在我们来谈一下什么是“对用户友好”。如何定义“对用户友好”？如何精确的判断一个东西是否对用户友好？我觉得这是一个现在仍然非常模糊的概念，但是程序语言的设计思想，特别是其中的类型理论(typetheory)可以比较好的解释它。我们可以把机器和人看作同一个系统：&lt;br&gt;&lt;br&gt;1、这个系统有多个模块，包括机器模块和人类模块。&lt;br&gt;2、机器模块之间的界面使用通常的程序接口。&lt;br&gt;3、人机交互的界面就是机器模块和人类模块之间的接口。&lt;br&gt;4、每个界面必须提供一定的抽象，用于防止使用者得到它不该知道的细节。这个使用者可能是机器模块，也可能是人类模块。&lt;br&gt;5、抽象使得系统具有可扩展性。因为只要界面不变，模块改动之后，它的使用者完全不用修改。&lt;br&gt;&lt;br&gt;在机器的各个模块间，抽象表现为函数或者方法的类型(type)，程序的模块(module)定义，操作系统的系统调用(systemcall)，等等。但是它们的本质都是一样的：他们告诉使用者“你能用我来干什么”。很多程序员都会注意到这些机器界面的抽象，让使用者尽量少的接触到实现细节。可是他们却往往忽视了人和机器之间的界面。也许他们没有忽视它，但是他们却用非常不一样的设计思想来考虑这个问题。他们没有真正把人当成这个系统的一部分，没有像对待其它机器模块一样，提供具有良好抽象的界面给人。他们貌似觉得人应该可以多做一些事情，所以把纷繁复杂的程序内部结构暴露给人（包括他们自己）。所以人对“我能用这个程序干什么”这个问题总是很糊涂。当程序被修改之后，还经常需要让人的操作发生改变，所以这个系统对于人的可扩展性就差。通常程序员都考虑到机器各界面之间的扩展性，却没有考虑到机器与人之间界面的可扩展性。&lt;br&gt;&lt;br&gt;举个例子。很多Unix程序都有配置文件，它们也设置环境变量，它们还有命令行参数。这样每个用户都得知道配置文件的名字，位置和格式，环境变量的名字以及意义，命令行参数的意义。一个程序还好，如果有很多程序，每个程序都在不同的位置放置不同名字的配置文件，每个配置文件的格式都不一样，这些配置会把人给搞糊涂。经常出现程序说找不到配置文件，看手册吧，手册说配置文件的位置是某某环境变量FOO决定的。改了环境变量却发现没有解决问题。没办法，只好上论坛问，终于发现配置文件起作用当且仅当在同一个目录里没有一个叫“.bar”的文件。好不容易记住了这条规则，这个程序升级之后，又把规则给改了，所以这个用户又继续琢磨，继续上论坛，如此反复。也许这就叫做“折腾”？他何时才能干自己的事情？&lt;br&gt;&lt;br&gt;TeX系统的配置就更为麻烦。成千上万个小文件，很少有人理解kpathsea的结构和用法，折腾好久才会明白。但是其实它只是解决一个非常微不足道的问题。TeX的语言也有很大问题，使得扩展起来非常困难。这个以后再讲。&lt;br&gt;&lt;br&gt;一个良好的界面不应该是这样的。它给予用户的界面，应该只有一些简单的设定。用户应该用同样的方法来设置所有程序的所有参数，因为它们只不过是一个从变量到值的映射（map）。至于系统要在什么地方存储这些设定，如何找到它们，具体的格式，用户根本不应该知道。这跟高级语言的运行时系统(runtimesystem)的内存管理是一个道理。程序请求建立一个对象，系统收到指令后分配一块内存，进行初始化，然后把对象的引用(reference)返回给程序。程序并不知道对象存在于内存的哪个位置，而且不应该知道。程序不应该使用对象的地址来进行运算。&lt;br&gt;&lt;br&gt;所以我们看到，“对用户不友好”的背后，其实是程序设计的不合理使得它们缺少抽象，而不是用户的问题。这种对用户不友好的现象在Windows，Mac，iPhone,Android里也普遍存在。比如几乎所有iPhone用户都被洗脑的一个错误是“iPhone只需要一个按钮”。一个按钮其实是不够的。还有就是像Photoshop,Illustrator,Flash之类的软件的菜单界面，其实把用户需要的功能和设置给掩藏了起来，分类也经常出现不合理现象，让他们很难找到这些功能。&lt;br&gt;&lt;br&gt;如何对用户更加友好，是一两句话说不清楚的事情。所以这里只粗略说一下我想到过的要点：&lt;br&gt;&lt;br&gt;1、统一：随时注意，人是一个统一的系统的一部分，而不是什么古怪的神物。基本上可以把人想象成一个程序模块。&lt;br&gt;&lt;br&gt;2、抽象：最大限度的掩盖程序内部的实现，尽量不让人知道他不必要知道的东西。不愿意暴露给其它程序模块的细节，也不要暴露给人。“机所不欲，勿施于人”。&lt;br&gt;&lt;br&gt;3、充要：提供给人充分而必要（不多于）的机制来完成人想完成的任务。&lt;br&gt;&lt;br&gt;4、正交：机制之间应该尽量减少冗余和重叠，保持正交(orthogonal)。&lt;br&gt;&lt;br&gt;5、组合：机制之间应该可以组合(compose)，尽量使得干同一件事情只有一种组合。&lt;br&gt;&lt;br&gt;6、理性：并不是所有人想要的功能都是应该有的，他们经常欺骗自己，要搞清楚那些是他们真正需要的功能。&lt;br&gt;&lt;br&gt;7、信道：人的输入输出包括5种感官，虽然通常电脑只与人通过视觉和听觉交互。&lt;br&gt;&lt;br&gt;8、直觉：人是靠直觉和模型(model)思考的，给人的信息不管是符号还是图形，应该容易在人脑中建立起直观的模型，这样人才能高效的操作它们。&lt;br&gt;&lt;br&gt;9、上下文：人脑的“高速缓存”的容量是很小的。试试你能同时想起7个人的名字吗？所以在任一特定时刻，应该只提供与当前被关注对象相关的操作，而不是提供所有情况下的所有操作供人选择。上下文菜单和依据上下文的键盘操作提示，貌似不错的主意。&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>王垠</author>
<guid isPermaLink="false">2018-01-29-33398839</guid>
<pubDate>Mon, 29 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Google的眼光</title>
<link>https://henix.github.io/feeds/zhihu.posts.yinwang0/2018-01-29-33392188.htm</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33392188&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b5d38986b8a8f187dfbe127c1f1829b2_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;来源：王垠的博客&lt;/p&gt;&lt;blockquote&gt;你知道吗，Google（Alphabet）要卖掉BostonDynamics，一个它收购才没多久的机器人公司。这也意味着，Google准备完全退出机器人的领域。新闻传言说，是因为Google觉得这些机器人太吓人了，把它踢倒在地，居然能像终结者一样爬起来！还有舆论说Google研究机器人，是想抢走人类的饭碗，所以现在Google为了人类的幸福，放弃了这个计划。呵呵，这借口多么美妙呀！你们真以为Google有这么好心，会为你们的生存着想吗？&lt;br&gt;&lt;br&gt;Boston Dynamics&lt;br&gt;—————————&lt;br&gt;卖掉BostonDynamics（以下简称BD）真正的原因，其实是因为BD的机器人，只是一些研究性质的原型。它们离能够投入实用，其实差的老远。研究经费的需求，却是一个无底洞。你们只要仔细看看这些BD机器人的视频（视频1，视频2），就会发现虽然貌似很先进的样子，跟科幻片里的很像，然而由于人工智能和机器视觉的局限性，它们其实仍然处于玩具阶段。&lt;br&gt;&lt;br&gt;特别是从第一个视频中你可以看到，这机器人头部旋转着一个很大的光学雷达（Lidar），虽然能拿起箱子，然而它只能在很简单，理想化的环境下才能做到，而且动作相当的缓慢和笨拙。箱子必须是方形的，而且必须有特殊的记号或者二维码在上面，这样机器人才能知道从哪里下手。拿起箱子的时候，它并不像人那样，可以感受到箱子的重心在哪里，所以它只是随意的把“手”（其实是两个橡胶垫）夹上去。箱子重心不稳，所以摇摇晃晃的，很容易滑落下来。至于机器人推门出去雪地上走的镜头，其实是有人遥控的，它并不能完全独立的探索外面的世界。被人踢倒在地，它真的是像“终结者”一样爬起来的吗？不是的。它爬起来的动作，很像一只蚂蚱，而且很慢。我很难想象，这样的机器人在战场上被人踹倒之后，能够及时爬起并且活下来。&lt;br&gt;&lt;br&gt;所以BD的机器人，其实是拿来做搬运工都不合格的，更不要说做士兵了。它们的“智能”，其实跟家用的机器人吸尘器，没有很大的差别。在如此理想化的条件下，普通的工业机器人其实就能搬运箱子，而且效率高很多。看看这些Amazon配送中心的机器人就知道，制造人形的机器人来做一些事情，完全是多此一举。只要你简化环境，就可以让普通没有智能的机器人，做很多有用的事情。&lt;br&gt;&lt;br&gt;BD之前是由美国国防部和和海军陆战队投资，进行机器人的研究。我们都知道，军方的钱是非常容易骗，可以放心大胆的烧。到时候东西做出来能不能用，就是另外一回事。拿军方的钱多舒服，没压力，所以这样的公司不拿军方的钱，把自己卖给Google，说明军方已经不想资助这样的项目了。Google的眼光有问题，买下来才发现这些个玩具，离能够投入实际使用，恐怕还需要几十年上百年。于是暗自惊呼上当，赶快转手。&lt;br&gt;&lt;br&gt;另外一种谣言是说，Google早就知道BD的机器人是不能用的。买下这公司，其实是拿来给Android的创始人AndyRubin做玩具（圣诞礼物）的。因为Rubin很喜欢机器人，从小就梦想做自己的机器人，却壮志未酬。哪知道Rubin后来离开了Google，所以这玩具公司也就没必要留着了。Google创始人对高层领导的宠幸和溺爱，由此可见一斑。&lt;br&gt;&lt;br&gt;D-Wave量子计算机&lt;br&gt;——————————&lt;br&gt;Google似乎总是喜欢做这种吸引眼球的项目，显得自己高大上，却不能真正的成功。Google投资的另外一个泡沫项目，叫做D-Wave量子计算机。D-Wave是一个加拿大公司，号称利用低温超导技术，制造出了具有上千个qubit的量子计算机，能解决NP-Complete的问题。Google图着量子计算的虚名，花了很大的价钱买了一台D-Wave的机器，于是时不时的要冒出一些新闻。比如这个新闻说，Google声称经过自己测试，D-Wave的计算速度，是普通计算机的一亿倍！&lt;br&gt;&lt;br&gt;然而，真正的量子计算专家，比如ScottAaronson，早就揭露过，由于环境对量子的干扰，要实现一千个qubit的量子计算机，难度是非常大，甚至是不可能的。D-Wave所谓的“量子计算机”，其实并不具有正确的“量子态”，不具有真正的量子计算能力，它其实最多算是一台“模拟计算机”。对于模拟计算机，其实研究已经很多了。模拟计算机确实可以在某些非常特殊的问题上，比数字计算机快几个数量级。然而，由于模拟计算机与生俱来的“误差问题”，它不能用于通用的计算，更不能用来解决NP-Complete的问题。实际上没有任何研究表明，量子计算机是可以解决NP-Complete问题的。&lt;br&gt;&lt;br&gt;Google声称D-Wave的机器比普通计算机快一亿倍，用的是什么样的测试呢？他们的测试并不是一个全面的benchmark，它其实只包括一个问题：模拟退火。望文生义你就可以知道，退火这问题，本来就是非常适合用模拟计算机来解决的。D-Wave是个模拟计算机，它做退火的速度，当然比数字计算机快很多了。解决一个问题快了一亿倍，可是它却不能以同样的速度解决其它的问题，甚至无法解决普通计算机能解决的那些问题。一个机器要被叫做“计算机”，它应该具有比较全面的解题能力。如果只能解决一个问题，那它根本就不算是一个计算机，最多算是个物理实验:P&lt;br&gt;&lt;br&gt;再来看看，D-Wave解决了量子计算机本来应该可以解决的问题吗？没有。否则的话，一千个qubit的机器，应该能实现著名的“Shor算法”，从而可以很快的分解很大的整数，从而就能破解相当长度的RSA秘钥！Google为何不用D-Wave来破解RSA，引起全球轰动和震惊呢？因为它做不到。D-Wave压根就不是量子计算机，所以不能实现快速的大数分解。&lt;br&gt;&lt;br&gt;其实很多人早就知道，D-Wave不是真正的量子计算机，而Google却堂而皇之的以讹传讹，打着“量子计算”的招牌，发布自己的测试结果。我不知道他们是真的不知道，还是故弄玄虚，吸引外行的眼球，长自己的威风。&lt;br&gt;&lt;br&gt;Google Glass&lt;br&gt;————————&lt;br&gt;世界忘不了你，GoogleGlass。当它刚出现的时候，Google可秀了不少神奇的视频。要查地图导航，滴滴滴，Glass直接把导航路线投射到地面上，指引你前进！在书店里说想找的书名，刷刷，Glass在空气中划出一条明亮的路线，在书架之间蜿蜒穿行，指引你到摆放它的位置，……多么神奇，多么美好！&lt;br&gt;&lt;br&gt;可是到最后，GoogleGlass做到了这些炫酷的功能吗？门都没有摸到！一开头Google就应该意识到，这样的视网膜光学投影，把虚拟的线条和人眼看到的实际物体合并在一起，是非常难办的问题。电影特效倒好做，实现起来就发现按照GoogleGlass的硬件能力，完全不可能。而且Google怎么可能有时间和精力，去输入书店里摆放书的位置。这年头还有多少人逛书店，这功能不是吃饱了撑着是什么:P&lt;br&gt;&lt;br&gt;这教训就是，一开头牛皮不要吹得太大，不然会摔得很惨。最后的GoogleGlass，感觉就是一个戴在头上的手机屏而已，并没有发挥头戴设备的任何特点。电池寿命不到半小时，而且它的镜腿还不能折叠，取下来就不知道该放哪里了。所以买了的人都发现没什么用处，可是价格不菲啊，只想把它转手倒卖出去。&lt;br&gt;&lt;br&gt;GoogleGlass吹够了牛皮，忽然人间蒸发了。可惜的是，粉丝们仍然没有看透Google的一贯作风，他们仍然相信Google夸出的各种海口，盼望这位“巨人”制造出伟大的新产品。&lt;br&gt;&lt;br&gt;自动车&lt;br&gt;——————&lt;br&gt;关于Google的自动车，我已经有专文介绍了。自动车是一个美好的幻想，可是物体识别等AI问题，却很难解决。&lt;br&gt;&lt;br&gt;有人可能以为这种自动车“够好用”就可以，因为世界上有那么多糟糕的司机，酒后驾车的，意外情况判断失误的，……所以Google的自动车也不需要完美，能大幅度减少车祸概率，就是人类的福气了。然而从道德和法律意义上来讲，自动车却必须要接近完美才可以。可能有人会犯的错误，它却不可以犯。这是为什么呢？原因在于，坐这辆犯了错误的自动车，导致身体残疾的人，如果是他自己开车，他可能根本不会烦这样的错误。诚然，其它人可能在这种情况也会犯错误，但其他人会犯错误，跟这个受害的人毫无关系。他会告上法庭，说：“如果是我开车，肯定不会导致车祸，以至于我自己变成残疾。所以Google的自动车对此负有严重的责任。”明白了吗？只是能从“宏观”意义上减少车祸是不够的。自动车的驾驶技术，必须超过世界上最安全的驾驶员，它完全不可以犯错误。&lt;br&gt;&lt;br&gt;所以Google的自动车，离能够实用差的天远，却喜欢到处游说，甚至要求政府监管部门大开绿灯。Google为何如此执着？我的猜测是，Google并不是真的想让自动车能够投入实用。显然，研究这些东西，可以显得自己很高大上，技术实力强。这样一来，recruiter们就可以对刚毕业的学生们说：“看那，我们Google有各种刺激的，开创未来的项目。快加入我们吧！”等你进去，才发现那些炫酷的项目，其实根本没机会进去。虽然拿着机器视觉的PhD，却无法进入自动车的项目。只有老老实实写些JavaScript，改进一下Adwords，给Gmail加个小不点的功能进去，……然后你走出Google的时候，就不小心变成了这个样子：&lt;br&gt;&lt;br&gt;其实完全无人控制的自动车，且不说能不能实现，它真的有必要吗？现在很多汽车公司（Subaru，本田，奔驰，……）都可以实现自动防撞刹车功能，这才是人们最需要的，而且难度不是特别高。一旦人们发现满足了基本的安全需求，就不会想要完全自动的车了。所以我预测，Google自动车很可能再过一阵子就会跟GoogleGlass一样，人间蒸发掉。我们走着瞧吧:)&lt;br&gt;&lt;br&gt;Chromecast&lt;br&gt;————————&lt;br&gt;再来看看Chromecast吧。Chromecast刚出现的时候，有些人也是热情高涨，甚至有国内朋友托我帮他买一个寄回国。我说这玩意比起AppleTV有什么特色吗？回答说：这是Google造的，肯定很牛，比AppleTV牛很多，一定要帮我买！于是等我要帮他买的时候，发现已经供不应求断货了。&lt;br&gt;&lt;br&gt;直到我自己用过Chromecast，才发现这东西就像一个未完工的intern项目，根本不能用！我当然不会去买个Chromecast。我用它是因为有天买了个投影机，免费附送了一个Chromecast。心想免费送的就试试呗，结果用了几次之后，发现简直bug百出。虽然我的是免费附送，但是这东西单独卖也要$35。这样质量的东西，Google你也好意思拿出来卖钱吗？！&lt;br&gt;&lt;br&gt;放YouTube视频的时候，它可以把视频加入播放队列，或者可以立即播放。可是队列播放和立即播放的逻辑，却是混乱的。有时候你本来想让它立即播放，它却把你之前放进去的视频给放了出来，仿佛你是在队列播放。所以我后来发现，这东西总是不放我现在想看的视屏，烦死人了。&lt;br&gt;&lt;br&gt;更搞笑的是它的Chrome插件，有时候播放列表里面，忽然出现“[objectObject]”这样的东西。显然是某些初级JavaScript码工，把某个对象给直接“+”到了一个字符串上面。试试吧，在浏览器里打开开发界面，输入&quot;&quot;+{x:1}，你就得到&quot;[objectObject]&quot;。连这么低级的bug都放进去了，我就怀疑他们到底自己有没有用过自己的产品。&lt;br&gt;&lt;br&gt;我永远无法理解人们对这类Google产品的热情。最后，由于我对那个投影机也不是很满意，所以把投影机和Chromecast一起退给了Amazon。后来买了AppleTV，发现跟Chromecast比起来，简直天壤之别，好用顺畅很多，一点问题没有。&lt;br&gt;&lt;br&gt;可能因为退货比例太高，Chromecast现在已经从Amazon下架了。&lt;br&gt;&lt;br&gt;Go语言&lt;br&gt;——————&lt;br&gt;Go语言，也是Google最爱炫耀的技术之一。我之前的文章已经分析的很清楚了，Go语言就是一坨屎。每个研究过PL的人，都在嘲笑Go语言的设计，笑掉了大牙。&lt;br&gt;&lt;br&gt;Google对于真正的计算机科学，程序语言的研究，远远不如微软，Intel，Oracle（Sun），IBM，Cisco。基本就是业余水平。很可惜的是，Google仍然可以靠着自己在网络界的影响力，面对专家们的嘲笑，明目张胆在业界推广Go这个大垃圾，祸害其他人。你说我们这些PL人士，怎么可能不鄙视Google？&lt;br&gt;&lt;br&gt;对了，Google还有另外一个垃圾语言，叫做Dart。Google内部还有一个自用的垃圾语言，叫做Sawzall。Sawzall的创造者，后来创造了Go。此人之前设计了Plan9操作系统，自以为超越了Unix，而其实呢继承了Unix的所有糟粕，只含有一些肤浅的界面改动，而且还不怎么好用，所以后来根本没人用。不是我有偏见哈，可我发现的规律就是，制造垃圾的自大狂，永远都只会制造垃圾。&lt;br&gt;&lt;br&gt;因为内行人都知道Google对于语言的造诣和态度之肤浅，所以几乎没有科班出生的程序语言专家愿意去Google工作。大部分最好的PL人员进入了微软，少数去了其它地方。&lt;br&gt;&lt;br&gt;Google的水平&lt;br&gt;————————&lt;br&gt;另外，Google的无线路由器OnHub，出来的时候大家也是热情高涨。最后一看Amazon的review，恶评如潮。自称“speakhuman”，可怎么就那么不人性化，那么难用呢！&lt;br&gt;&lt;br&gt;别忘了Blogger，别忘了Orkut，ChromeOS,Chromebook，……哎，Google还有其它一系列失败的的产品和项目，公司里很多人做着一些穷途末路的项目，我就不多说了……&lt;br&gt;&lt;br&gt;所以总的来说，Google有它的特长。它是一个不错的互联网公司，Google的搜索引擎做得很好，Gmail，收购来的YouTube，地图，Android什么的，也比较好用。但是Google的特长，也就停留在那里了。做其他事情，几乎全都是业余水准，却自以为了不起，喜欢宣传自己，制造高大形象。最近AlphaGo搞得沸沸扬扬，也是一样的用意，煽风造势，以此吸引懵懂没经验的年轻人，进去为它做一些琐碎的杂活，帮助它赚更多的广告钱。&lt;br&gt;&lt;br&gt;这就是我眼里的Google。&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>王垠</author>
<guid isPermaLink="false">2018-01-29-33392188</guid>
<pubDate>Mon, 29 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>正面思维的误区</title>
<link>https://henix.github.io/feeds/zhihu.posts.yinwang0/2018-01-29-33391867.htm</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33391867&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b5d38986b8a8f187dfbe127c1f1829b2_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;来源：王垠的博客&lt;/p&gt;&lt;blockquote&gt;有些人喜欢宣扬所谓“正面思维”（positivethinking），而不顾事实真相。每当你批评一些事情，他们就会拿出正面思维这个万能法宝来压制你，说：“你这人怎么这么negative？要positive，要看到事物好的方面才对！”&lt;br&gt;比如这次有人说：“你把之前每个东家都喷了一遍。这里面难道就没有你自己的问题吗？”我只能说，如果它们真的就是那么恶劣，那我有什么办法呢？由于没来得及选择，连续进入好几家问题公司，其实很正常。我不是一个完美的人，然而在公司的人际关系上，我可以说是仁至义尽了。我没架子，容易相处，这点很多同事都知道，甚至厨师和扫地大妈都知道。然而我绝对不是好欺负的。&lt;br&gt;像Coverity，Sourcegraph这类极品，欺压员工，无耻利用，行为极其恶劣，难道我还能说它们好话不成？我的心理不知道要扭曲到什么程度，才能发掘出他们好的地方来。这些公司的恶劣行径，严重损害了员工的身心健康，伤害了他们的事业发展，在某种程度上可以说是犯罪行为，没有把这些人告上法庭就已经不错了。关于这些公司，有很多骇人听闻的细节我还没有说出来，我保留对这些进行进一步揭露的权利。&lt;br&gt;然而这不是今天的主题，我今天想谈的是所谓“正面思维”。很多人没有意识到，盲目的正面思维，其实是一个很严重的问题。正面并没有什么问题，快乐是好事，然而它们应该是结果，而不应该是目的。如果一个社会需要刻意去提倡“正面”和“快乐”，去宣扬它们，通过舆论压力或者暴力，迫使每个人都“正面思维”，那就有严重问题了。文化大革命的时候，人们的思维可真是很正面啊，各种歌颂……你要是敢说任何不好听的话，立即被打成反革命右派。可是今天，我发现这种文革似的“正面思潮”，又有抬头之势。其实，它在美国已经泛滥成灾，以至于有人专门写了一本书来批判这种“正面思维”：&lt;br&gt;当你遇到困难的时候，美国人喜欢说：“别担心，一切都会好起来的……”，“要专注于事物好的方面……”，“只要你努力，就会有好结果……”，“困难是临时的，面包会有的，Go语言会改进的……”，“危机会过去的，经济会持续增长的⋯⋯”，“美国是世界上最伟大的国家，上帝保佑美利坚……”看看这本书，你就知道这些说法有多大的欺骗性。整个美国，其实都沉浸在人们不切实际的“正面幻想”之中。&lt;br&gt;“正面思维”跟美国的剥削制度和资本主义，是密不可分的。美国总是宣称自己是民主自由的国家。听到这个，比美国民主和自由很多的国家，都笑了。一个真正民主自由的国家，有什么必要反复的宣称自己是民主和自由的呢？事实上，美国是一个剥削和压迫非常严重的国家，美国人民并不幸福。实际上，正面思维就是剥削者想出来，用于安抚人民，让人安心做廉价劳动力的工具。一些所谓“成功人士”，总是鼓励大家要上进，要看到事物好的方面，说失业是一种福分，要安于现状，一步一步奋斗，往上爬！然后呢，自己却在背后玩弄权术，利用人们的正面不设防的心理，招摇撞骗，投机取巧，贬低人的价值，压低雇员工资，让别人加班加点，动作慢了随时开掉。自己却不劳而获，靠着一口官腔（所谓“领导才能”）飞黄腾达。&lt;br&gt;在美国，正面思维是一个产业。号称“快乐民族”的美国人，每年消耗掉世界上三分之二的抗抑郁症药物。美国出产层出不穷的正面思维和“成功学”书籍，DVD，以及其他产品：『人性的弱点』，『心灵的鸡汤』，『谁动了我的奶酪』，『秘密』……出产成千上万的所谓人生导师，职场教练，宗教领袖，知心大妈，心理医生，鸡汤和蛇油贩子……他们的谋生方式，就是训练你如何正面思维，抑制负面情绪。这些人不能给你任何切实可行改善生活的办法，而只是告诉你，如何才能把生活的挫折，社会的不合理，不公平，都想成自己的思想有问题，或者自己不够努力，不够好。不论遇到什么样的不幸或者不公正待遇，你都不能抱怨抗议，反而还得“心存感激”，因为你活着就是上帝最好的恩赐。这也就是为什么美国有个节日叫“感恩节”，除了美国及其附庸加拿大，世界上没有其它国家庆祝感恩节。&lt;br&gt;美国的正面思维产业是如此的发达，甚至产生了一门学科，叫做“正面心理学”。哈佛大学还开设了红极一时的『正面心理学』课程（所谓“幸福课”）。我当年看了一阵子这课的视频，发现它真的很不寻常。课程进行到将近一半，教授仍然在做一般课程第一堂课的那种“动员工作”。没有传授任何切实可行的方法，只是反反复复地试图说服你，为什么你应该学正面心理学……老师啊，我坐在你课堂上半学期了，你还在告诉我为什么应该上你的课？！后来我发现，这个学科很像传销。它并不能让人快乐起来，然而它确实能教会你如何说服别人来上这门课，能把你训练成跟老师一样的“幸福课推销员”，然后你又可以去训练下一代的推销员……最后大家都成了推销员，然而推销员自己并不快乐，因为他们没有真正的产品和客户。&lt;br&gt;你知道为什么自从小布什做总统以来，美国的正面思维产业越来越红火了吗？因为小布什本来就是拉拉队长（cheerleader）出生，他以前的工作就是给大家加油鼓气的。小布什要求美国人民，一定要正面，一定要认为美国是世界上最伟大的国家，一定要认为美国人民是上帝的宠儿！;-)&lt;br&gt;在Cornell和Google的时候，我饱尝了盲目的正面思维所带来的危害。Cornell这学校有个奇怪的现象，跟同学聊天时，如果你想打听某个教授的学术或者为人，得到的回应必然是：“他好牛！”“好厉害！”“非常聪明！”之类的语言。你听不到任何人说不好的方面，比如：“他讲课像是背书”，“他的研究没有实质意义”，“他的学生都很累”之类的负面信息。所以在Cornell，你无法从同学那里得到任何信息，每个人都饱尝了与某些教授打交道的辛酸，可是每个人都把那些秘密藏在心底。他们对你说：“嗯，他很厉害，他的研究很伟大……”&lt;br&gt;这种铺天盖地的正面信息，是无益甚至有害的。如果你只听到正面的声音，那你就无法做出正确的决定。这就像你在网上买东西，如果只看正面的评价，那你很可能买到有问题的商品。正确的作法，应该是正面负面的信息都看。特别是负面的信息，必须仔细看。它们可以告诉你，这个产品有哪些烦扰其他人的缺陷，会不会影响到你的使用。一般我在网上如果被一个产品吸引，我首先看的是一颗星的评价，因为给一颗星的人，一般是恨透了这个产品。当然里面有些无知或者不知好歹的人，你可以忽略，但是大部分人会告诉你，他们不喜欢这个产品的具体原因。我很会分析这些评价，这就是为什么我家里的很多产品，都是非常好用的。&lt;br&gt;Cornell这个学校，就是缺乏这种有益的负面评价。你总是听说每个教授都很牛，人都很好，……然而当你真正跟他们接触，就发现事实并非如此。你一次次的跳入火坑，然后才开始希望，要是开头的时候听到一些负面的信息，该多好。可是每个人表面上都是那么的positive，每个人都认为negative是错误的心理，每个人都在强装笑容。这是一个多么可怕的地方！&lt;br&gt;Google的气氛非常类似于Cornell。Google员工吃饭时，谈论每个项目或者团队，都带着玫瑰色的光环，仿佛Google做的一切都是美好的，先进的，有前途的。在每个星期的TGIF（TellGooglersIt’sFriday）大会上，founder们都在大讲台上宣布各种好消息，而对坏消息闭口不提或者一笔带过。下面的Google员工们群情激昂，对一些小不点的事情各种欢呼鼓掌尖叫，跟传销大会似的。事实上，Google内部有许多穷途末路的项目。表面看上去很厉害的样子，等你进去才发现是死路一条，垂死挣扎。项目领导平时紧紧张张，生怕上面来人调查，把自己的项目杀掉。在公司内部搞各种政治，东拉西扯建立各种依赖关系，这样自己的项目才得以生存。&lt;br&gt;这种虚伪的正面氛围，存在于很多的美国公司，员工每个星期都被领导打各种鸡血针，保持激昂向上的状态。我曾经跟英国，法国，德国，意大利，瑞典，波兰等国家的同事聊天，他们都暗自嘲笑美国人，说过度正面，传销式的群情激昂，吃错药了一样，确实是美国文化的一大特色。欧洲人比较务实，不搞这套，好的就说好，坏的就批评或者嘲笑，直率坦荡。当然，我不能说所有美国公司都有这种问题，所以我仍然存在希望，找到稍微实在点的公司。&lt;br&gt;盲目的正面思维，忽略问题，并不能解决问题。你必须看到负面的事实，才有可能避免困难，得到好的结果。正面思维和浮夸的气氛，正在侵蚀Google和很多其它美国公司。为了看清楚正面思维的危害性，我推荐你看看这本书，名叫『负面思维的威力』：&lt;/blockquote&gt;</description>
<author>王垠</author>
<guid isPermaLink="false">2018-01-29-33391867</guid>
<pubDate>Mon, 29 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>测试的道理</title>
<link>https://henix.github.io/feeds/zhihu.posts.yinwang0/2018-01-29-33391692.htm</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33391692&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b5d38986b8a8f187dfbe127c1f1829b2_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;来源：王垠的博客&lt;/p&gt;&lt;blockquote&gt;在长期的程序语言研究和实际工作中，我摸索出了一些关于测试的道理。然而在我工作过的每一个公司，我发现绝大多数人都不明白这些道理，很多团队集体性的采用错误的做法而不自知。很多人把测试当成一种主义和教条，进行过度的测试，不必要的测试，不可靠的测试，并且把这些错误的做法传授给新手，造成恶性循环。本来目的是提高代码质量，结果不但没能达到目的，反而降低了代码质量，增大了工作量，大幅度延缓工程进度。&lt;br&gt;我也写测试，但我的测试方式比“测试教条主义者”们的方式聪明很多。在我心目中，代码本身的地位大大的高于测试。我不忽视测试，但我不会本末倒置，过分强调测试，我并不推崇测试驱动开发（TDD）。我知道该测试什么，不该测试什么，什么时候该写测试，什么时候不该写，什么时候应该推迟测试，什么时候完全不需要测试。因为这个原因，再加上高强的编程能力，我多次完成别人认为在短时间不可能完成的任务，并且制造出质量非常高的代码。&lt;br&gt;测试的道理&lt;br&gt;现在我就把这些自己领悟到的关于测试的道理总结一下，其中有一些是鲜为人知或者被误解的。&lt;br&gt;不要以为你处处显示出“重视代码质量”的态度，就能提高代码质量。总有些人，以为自己知道“单元测试”（unittest），“集成测试”（integrationtest）这样的名词，就很懂编程，就可以教育其他人。可惜，光有态度和口号是不解决问题的，你还必须有实战的技巧，深入的见解和智慧，必须切实地知道应该怎么做。代码的质量不会因为你重视它就得到提升，也不会因为你采取了措施（比如测试，静态分析）就一定会得到改善。你必须知道什么时候该写测试，什么时候不该写测试，需要写测试的时候，要写什么样的测试。其实，提高代码质量唯一可行的手段不是写测试，而是反复的提炼自己的思维，写简单清晰的代码。如果你想真的提高代码质量，我的文章『编程的智慧』是一个不错的出发点。&lt;br&gt;真正的编程高手不会被测试捆住手脚。是的，你身边那个你认为“不很在乎测试”的家伙，也许是个比你更好的程序员。我喜欢把编程比喻成开赛车，而测试就是放在路边用来防撞的轮胎护栏……&lt;br&gt;护栏有时候是很有用，可以救命的，然而一个合格的车手，绝对不会一心想着有护栏保护，测试在编程活动中的地位也应该就是这样。优秀的车手会很快看见优雅而简单的路径，恰到好处地掌握速度和时机，直奔终点而去。护栏只是放在最危险的地段，让你出了意外不要死得太惨。护栏并不能让你成为好的车手，不能让你取得冠军。绝大多数时候，你的安全只有靠自己的技术，而不是护栏，你永远有办法可以撞死自己。测试的作用也是一样，即使有了很多的测试，代码的安全仍然只掌握在你的手里。你永远可以制造出新的bug，而没有测试可以检测到它……&lt;br&gt;通常情况下，一个合格的车手是根本碰不到这些护栏的，他们心里想的是更高的目标：快点到达终点。相比之下，一个不合格的车手，他经常撞到赛道外面去，所以在他的心里，护栏有着至高无上的地位，所以他总是跟别人宣扬护栏的重要性。他开车的时候为了防止犯错，要在他经过的路径两边密密麻麻摆上护栏，甚至把护栏摆到赛道中间，以确保自己的转弯幅度正确。他在护栏之间跌跌撞撞，最后只能算是勉强到达终点。鼓吹测试驱动开发的人，就是这种三流车手，这种人写再多的测试也不可能倒腾出可靠的代码来。&lt;br&gt;在程序和算法定型之前，不要写测试。TDD的教条者喜欢跟你说，在写程序之前就应该先写测试。为什么写代码之前要写测试呢？这只是一种教条。这些人其实没有用自己的脑子思考过这个问题，而只是人云亦云，觉得这样“很酷”，符合潮流，或者以为这样做了别人就会认为自己是高手。实际上在程序框架完成，算法定型之前，你都不需要写测试。如果你想知道代码是否正确，用人工方式运行代码，看看结果足以。&lt;br&gt;如果你发现编程初期需要保证的性质纷繁复杂，如此之多，不写测试你就没信心的话，那你还是想办法先提高下基本的编程技术吧：多做练习，简化代码，让代码更加模块化，看看我的『编程的智慧』或者『SICP』一类的东西。写测试并不能提高你的水平，正好相反，过早的写测试会捆住你的手脚，让你无法自由的修改代码和算法。如果你不能很快的修改代码，不能用直觉感觉到它的变化和结构，而是因为测试而处处卡顿，你的头脑里就不能产生所谓“flow”，就不能写出优雅的代码来，结果到最后你什么也没学会。只有在程序不再需要大幅度的改动之后，才是逐渐加入测试的时候。&lt;br&gt;不要为了写测试而改变本来清晰的编程方式。很多人为了满足“覆盖”（coverage）的要求，为了可以测试到某些模块，或者为了使用mock，而把本来简单清晰地代码改成更加复杂而混淆的形式，甚至采用大量reflection。这样一来其实降低了代码的质量。本来很简单的代码，一眼看去就知道是否正确，可是现在你一眼看过去，到处都是为了方便测试而加进去的各种转接插头，再也无法感觉到代码。这些用来辅助测试的代码，阻碍了你对代码进行直觉思维，而如果你不能把代码的逻辑完全映射在头脑里（进而产生直觉），你是很难写出真正可靠的代码的。&lt;br&gt;有些C#程序员，为了测试而加入大量的interface和reflection，因为这样可以在测试的时候很方便的把一片代码替换成mock。结果你就发现这程序里每个类都有一个配套的interface，还需要写另外一个mock类，去实现这个interface。这样一来，不但代码变得复杂难以理解，而且还损失了VisualStudio的协助功能：你不再能按一个键（F12）就直接跳转到方法的定义，而需要先跳到对应的interface方法，然后再找到正确的实现。所以你不再能够在代码里面快速的跳转浏览。这种方便性的损失，会大幅度降低头脑产生整体理解的机会。而且为了mock，每一个构造函数调用都得换成一个含有reflection的构造，使得编译器的静态类型检查无法确保类型正确，增加运行时出错的可能性，出错信息还难以理解，得不偿失的后果。&lt;br&gt;不要测试“实现细节”，因为那等同于把代码写两遍。测试应该只描述程序需要满足的“基本性质”（比如sqrt(4)应该等于2），而不是去描述“实现细节”（比如具体的开平方算法的步骤）。有些人的测试过于详细，甚至把代码的每个实现步骤都兢兢业业的进行测试：第一步必须做A，第二步必须做B，第三步必须做C……还有些人喜欢给UI写测试，他们的测试里经常这样写：如果你浏览到这个页面，那么你应该在标题栏看见这行字……&lt;br&gt;仔细想一下就会发现，这种作法本质上不过是把代码（或者UI）写了两遍而已。本来代码里面明白写着：先做A，再做B，再做C。UI描述文件里面明白写着：标题栏里面是这些内容。你有什么必要在测试里把它们全都再检查一遍呢？这根本没有增加任何可靠性：你在代码里会犯错，你把同样的逻辑换种形式再写一遍，难道就不会错了吗？&lt;br&gt;这就像某些脑子秀逗的人，他出门时总是担心门没锁好，关门之后要推推拉拉好几次，确认门是锁上了的。还没走几步，他仍然在怀疑门没锁好，又走回去推推拉拉好几次，却始终不能放心:P这种做法非但不能保证代码的正确，反而给修改代码制造了障碍。理所当然，你把同一段代码写了两遍，每当要修改代码，你就得修改两次！这样的测试就像紧箍咒一样，把代码压得密不透风。每一次修改代码，都会导致很多测试失败，以至于这些测试都不得不重写。本质上就是把代码修改了两遍，只不过更加痛苦一些。&lt;br&gt;并不是每修复一个bug都需要写测试。很多公司都流传一个常见的教条，就是认为每修复一个bug，都需要为它写测试，用于确保这个bug不再发生。甚至有人要求你这样修复一个bug：先写一个测试，重现这个bug，然后修复它，确保测试通过。这种思维其实是一种生搬硬套的教条主义，它会严重的减慢工程的进度，而代码的质量却不会得到提高。写测试之前，你应该仔细的思考一个问题：这个bug有多大可能会在同一个地方再次发生？很多低级错误一旦被看出来之后，它就不大可能在同一个地方再次出现。在这种情况下，你只需手工验证一下bug消失了就可以。&lt;br&gt;为不可能再出现的bug大费周折，写reproducer，构造各种数据结构去验证它，保证它下次不会再出现，其实是多此一举。同样的低级错误就算再出现，也很可能不在同一个地方。写测试不但不能保证它不再发生，而且浪费你很多时间。这测试在每次build的时候都会消耗时间，每次编译都因为这些测试多花几分钟，累积起来之后，你就发现工程进度明显减慢。只有当发现已有的测试没有抓住程序必须满足的重要性质时，你才应该写新的测试。你不应该是为这个bug而写测试，而是为代码的性质而写测试。这个测试的内容不应该只是防止这个bug再次发生，而是要确保bug所反映出来的，之前缺失的“性质”得到保证。&lt;br&gt;避免使用mock，特别是多层的mock。很多人写测试都喜欢用很多mock，堆积很多层，以为只有这样才能测试到路径比较深的模块。其实这样不但非常繁琐费事，而且多层的mock往往不能产生足够多样化的输入，不能覆盖各种边界情况。如果你发现测试需要进行多层的mock，那你应该考虑一下，也许你需要的不是mock，而是改写代码，让它更加模块化。如果你的代码足够模块化，你不应该需要多层的mock来测试它。你只需要为每一个模块准备一些输入（包括边界情况），确保它们的输出符合要求。然后你把这些模块像管道一样连接起来，形成一个更大的模块，测试它也符合输入输出要求，以此类推。&lt;br&gt;不要过分重视“测试自动化”，人工测试也是测试。写测试，这个词往往隐含了“自动运行”的含义，也就是假设了要不经人工操作，完全自动的测试。打一个命令，它过一会就会告诉你哪些地方有问题。然而，人们往往忽略了“人工测试”。他们没有意识到，人工去试验，去观察，也是一种测试。所以你就发现这样的情况，由于自动测试在很多时候非常难以构造（比如，如果你要测试一段复杂的交互式GUI代码的响应），很多人花了很多时间，利用各种测试框架和工具，甚至遥控WEB浏览器去做一些自动操作，花太多时间却发现各种不可靠，没法测到很多东西。&lt;br&gt;其实换一个思路，他们只需要花几分钟的时间，就可以用人工的方式观察到很多深入的问题。过分的重视测试自动化的原因，往往在于一个不切实际的假设，他们假设错误会频繁的再次发生，所以自动化了可以省下人的力气。但是其实，一旦一个bug被修好，它反复出现的机会不会很大的。过分的要求测试自动化，不但延缓了工程进度，让程序员恼火，效率低下，而且失去了人工测试的精确性。&lt;br&gt;避免写太长，太耗时的测试。很多人写测试，叽里呱啦很长一串，到后来再看的时候，他已经不记得自己当时想测什么了。有些人本来用很小的输入就可以测试到需要的性质，他却总喜欢给一个很大的输入，下意识的以为这样更加靠谱，结果这测试每次都会消耗大量的build时间，而其实达到的效果跟很小的输入没有任何区别。&lt;br&gt;一个测试只测试一个方面，避免重复测试。有些人一个测试测很多内容，结果每次那个测试失败，都搞不清楚到底是哪个部件出了问题。有些人为了“放心”，喜欢在多个测试里面“附带”测某些他认为相关的部件，结果每次那个部件出问题，就发现好多个测试失败。如果一个测试只测一个方面，不重复测同一个部件，那么你就可以很快的根据失败的测试，发现出问题的部件和位置。&lt;br&gt;避免通过比较字符串来进行测试。很多人写测试的时候，喜欢通过打印出一些东西，然后使用字符串比较的方式来决定输出是否符合要求。一个常见的做法是把输出打印成格式化的JSON，然后对比两个文本。甚至有人JSON都不用，直接就比较printf输出的结果。这种测试是非常脆弱的。因为字符串输出的格式往往会发生微小的变化，比如有人在里面加了一个空格之类的。把这种字符串作为标准输出，进行字符串比较，很容易因为微小的改动而使大量测试失败，导致很多的测试需要做不必要的修改。正确的做法，应该是进行结构化的比较，如果你要把标准结果存成JSON，那么你应该先parse出JSON所表示的对象，然后再进行结构化的对比。PySonar2的测试就是这样的做法，所以相当的稳定。&lt;br&gt;“测试能帮助后来人”的误区。每当指出测试教条主义的错误，就会有人出来说：“测试不是为了你自己，而是为了你走了以后，以后进来的人不犯错误。”首先，这种人根本没有看清楚我在说什么，因为我从来没有反对过合理的测试。其次，这种“测试能帮助后来人”，其实是没有经过实践检验，站不住脚的说法。如果你的代码写得很乱，就算你测试再多，后来人也无法理解，反倒被莫名其妙的测试失败给弄得更糊涂，不知道是自己错了还是测试错了。我已经说过了，测试不能完全保证代码不被改错，实际上它们防止代码被改错的作用是非常弱的。无论如何，后来人都必须理解原来的代码的逻辑，知道它在做什么，否则他们不可能做出正确的修改，就算你有再严密的测试也一样。&lt;br&gt;举一个亲身的例子。我在Google做出PySonar之后，最后一个测试都没写。第二次我回到Google，我的上司SteveYegge对我说：“你走了之后，我改了一些你的代码，真是太清晰，太好把握了，修改你的代码是一种快乐！”这说明什么问题呢？我并不是说你可以不写测试，但这个例子说明，测试对于后来人的作用，并不是你有些人想象的那么大。创造清晰的代码才是解决这个问题的关键。&lt;br&gt;这种怕人突然走了，代码无法维护的想法，导致了一些人对测试过分的重视，但测试却不能解决这种问题。相反，如果测试太繁琐，做不必要的测试，反而容易让员工不满，容易走人，去加入在这方面更加有见地的公司。有些公司以为有了测试，就可以随便打发人走，这种想法是大错特错的。你需要明白的一个事情是，代码永远是属于写出它的那个人的，就算有测试也一样。如果核心人物真的走了，就算你有再多的测试也没用的，所以解决的方法就是把他们留住！一个有远见的公司总是通过其他的手段解决这个问题，比如优待和尊重员工，创造良好的氛围，使得他们没那么快想走。另外，公司必须注意知识的传承，防止某些代码只有一个人理解。&lt;br&gt;案例分析&lt;br&gt;有人会疑问，我凭什么可以给别人讲这些经验，我自己为此有什么成功的案例呢？所以现在来讲讲我做过的几个东西，以及我亲眼目睹的测试教条主义者们的失败案例。&lt;br&gt;Google&lt;br&gt;很多人可能听说过我在Google做的PySonar。当时Google的队友们战战兢兢，说这么高难复杂的东西要从头做起，几乎是不可能的。特别是某位队友，一开头就吵着要我写测试，一直吵到最后，烦死我了。他们为什么这么担心呢？因为对Python做类型推导是非常高难度的代码，需要相当复杂的数据结构和算法，需要精通Python的语义实现。&lt;br&gt;作为一个训练有素的专家，我没有在乎他们的咋呼，没有信他们的教条。我按照自己的方式组织代码，进行精密的思考，设计和推理，最终在三个月之内做出了非常优雅，正确，高性能，而又容易维护的代码。PySonar到现在仍然是世界上最先进的Python类型推导和索引系统，被多家公司采用，用于处理数以百万计的Python代码。，&lt;br&gt;如果我当时按照Google队友的要求，采用已有的开源代码，或者过早的写了测试，别说无法在三个月的实习时间之内完成这个东西，就算折腾好几年也没有可能。&lt;br&gt;ShapeSecurity&lt;br&gt;这种思维方式最近的成功实例，是给ShapeSecurity做的一个先进的JavaScript混淆器（obfuscator）和对集群（cluster）管理系统的改进。不要小看了这个JS混淆器，它的混淆能力要比uglify之类的开源工具强很多，也快很多。它不但包含了uglify的变量换名等基本功能，而且含有专门针对人类和编译器的复杂化，使得没人能看出一点线索这个程序到底要干什么，让最先进的JS编译器也无法把它简化。&lt;br&gt;其实这个混淆器也是一种编译器，只不过它把JavaScript翻译成不可读的形式。在这个项目中，由于失之毫厘就可以差之千里，我采用了从ChezScheme编译器学过来的，非常严密的测试方法。对每一个编译器的步骤（pass），我都给它设计一些正好可以测到这个步骤的输入代码（比如，具有函数定义的，for循环，try-catch的，等等）。Pass输出的代码，经过JavaScript解释器执行，把结果跟原来程序的执行结果对比。每一个测试程序，经过每一个pass，输出的中间结果都跟标准结果进行对比，如果错了就表明那个pass有问题，出错的小程序会指出大概是哪一个部分出了问题。遵循小巧，不冗余，不重复的原则，我总共只写了40多个非常小的JavaScript程序。由于这些测试涵盖了JavaScript的所有构造而且几乎不重复，它们能够准确的定位到错误的改动。最后，这个JS混淆器能够正确的转换像AngularJS那么大的项目，确保语义的正确，让人完全无法读懂，而且能有效地防止被优化器（比如ClosureCompiler）简化掉。&lt;br&gt;相比之下，过度鼓吹测试和可靠性的人，并没能制造出这么高质量的混淆器。其实在我进入团队之前，里面的两三位高手已经做了一个混淆器，项目延续了好多个月。这片代码一直没能发布给客户用，因为它的换名部件总是会在某些情况下输出错误的代码，修改了好多次仍然会出错。不是100%的正确，这对于程序语言的转换器来说，是不可接受的。换名只是我的混淆器里的一个步骤，它还包含大概十个类似的步骤，可以把代码进行各种转换。&lt;br&gt;在实现换名器的时候，队友们让我直接拿他们以前写的换名代码过来，把bug修好就可以。然而看了代码之后，我发现这代码没法修，因为它采用了错误的思路，缝缝补补也不可能达到100%的正确，而且明显效率低下，所以我决定自己重写一个。由于轻车熟路，我只花了一下午的时间，就完成了一个正确的换名器，它完全符合JavaScript的语义，各种奇葩的作用域规则，而且结构非常简单。说白了，这个换名器也是一种解释器。对解释器的深刻理解，让我可以很容易的写出任何语言的换名器。&lt;br&gt;不幸的是，历史再次重演了;)队友们听说我花一下午重写了一个换名器，非常紧张，咋呼地跟我说：“你知道我们的换名器是花了多少个月的时间做出来的吗？你知道我们写了多少测试来保证它的正确性吗？你现在一下午做出来一个新的，你如何能保证它的正确！”我不知道他们怎么好意思说出这样的话来，因为事实是，他们花了这么多个月，耗费这么多人力，写了这么多的测试，做出来的换名器却仍然有bug，没法用。当我把我写的测试和几个大点的opensource项目（AngularJS,Backbone等）放进他们的换名器之后，就发现有些地方出问题了，而所有的测试和opensource项目通过我的换名器，却得到完全正确的代码。另外经过性能测试，我的换名器速度要快四倍的样子。所以就像Dijkstra所说：“最优雅的程序往往也是最高效的。”&lt;br&gt;结束这个项目之后，我换了一个团队（cluster团队），这个团队的人要好很多，低调而且幽默。ShapeSecurity的产品（ShapeShifter）里面包含一个高可靠（HA）集群管理系统，它可以通过网络，选举leader，构建一个高容错的并行处理集群。这个集群管理系统一直以来都是公司里很复杂，却是可靠性要求最高的一个部件，一旦出问题就可能有灾难性的后果。确实，它当时可靠性非常高，从来没出过问题。但由于历史原因，它的代码过度复杂而缺乏模块化，以至于很难扩展来应付新的客户需求。我进入这个新团队的任务，就是对它进行大规模的简化，模块化和扩展，让它满足新的需求。&lt;br&gt;在这个项目中，由于代码的改动幅度很大，在同事和部门领导的理解，信任和支持下，我们决定直接抛弃已有的测试，完全靠严格而及时的codereview，逻辑推理，推敲讨论，手工试验来保证代码的正确。在我修改代码的同时，一位更熟悉已有代码的队友一直通过git默默监视着我的每一次改动，根据他自己的经验来判断我的改动是否偏离了原来的语义，及时与我交流和讨论。由于这种灵活而严格的方式，工程不到两个月就完成了。改进后的代码不但更加模块化，更可扩展，适应了新的需求，而且仍然非常可靠。假设部门领导是“测试教条主义者”，不允许抛弃已有的测试，这样的项目是绝对不可能如期完成的。然而在当今世界遇到这样领导的机会，恐怕十个人里面不到一个吧。&lt;br&gt;Coverity&lt;br&gt;最后，我举一个由于测试方式不当而非常失败的案例，那就是Coverity的Java静态分析产品。我承认Coverity的C和C++分析器也许是非常好的，然而Java的分析器，很难说。当我进入Coverity的时候，同事们已经忍受了整整一年的管理层的威逼和高压，超时过劳工作，写出了基本的新产品和很多的测试。可是由于技术债太多，再多的测试也没能保证产品的可靠性。&lt;br&gt;我的任务就是利用我深入的PL知识，不停的修补前人留下来的各种蹊跷bug。有些bug需要运行20多分钟之后才出现，一次还看不出是怎么回事，所以修起来非常耗时。有时候我只好趴在电脑前面养神，时不时的睁眼看看结果。Coverity是如此的在乎测试，他们要求每修复一个bug你就必须写出新的测试。测试必须能够如实的重现bug的现象，修复之后测试必须能够通过。这看似一个很在乎代码质量的做法，然而它不但没能保证产品的稳定可靠，而且大幅度的减慢了工程进度，并且造成员工的疲惫和不满。&lt;br&gt;有一次他们分配给我一个bug：在分析一个中型项目的时候，分析器似乎进入了死循环，好几个小时都不能完成。因为Coverity的全局静态分析，其实就是某种图遍历算法。当这个图里面有回路的时候，你就必须小心，如果不问青红皂白就递归进去，就可能进入死循环。避免死循环的办法很简单，你构造一个图节点的集合（Set），然后把它传递到函数里面作为参数。每当访问一个节点，你先检查这个节点是否已经在这个集合里，如果在你就直接返回，否则你就把这个节点加入到集合里，然后递归处理这个节点的子节点。它的C++代码大概就像这个样子：&lt;br&gt;voidtraverse(Nodenode,Set&lt;Node&gt;&amp;visited)&lt;br&gt;{&lt;br&gt;if(visited.contains(node)){&lt;br&gt;return;&lt;br&gt;}else{&lt;br&gt;visited.add(node);&lt;br&gt;process_node(node,visited);//里面会递归调用traverse&lt;br&gt;}&lt;br&gt;}&lt;br&gt;查看代码之后我发现，代码其实没有进入“死循环”，而是进入了指数复杂度的计算，所以很久都不能完成。这是因为写这函数的人不小心，或者没有理解C++的函数参数缺省是传值（做拷贝）而不是传引用，所以他忘了打那个“&amp;”，所以函数被递归调用的时候不是传递原来的集合，而是做了一个拷贝。每一次递归调用traverse，visited都得到一个新的拷贝，所以返回之后，visited的值就恢复到之前的状态，就像node被自动remove了一样。所以这个函数仍然会在某种情况下再次访问这个节点。这样的代码不会进入死循环，然而在某种特殊的图结构下，这会造成指数级的时间复杂度（请想一下这是什么样的一种图）。&lt;br&gt;本来很明显的一个图论算法问题，加一个“&amp;”就修好了，手工试验也发现问题消失了。然而Coverity的测试教条主义者们（包括写出这bug的那人自己），吵着闹着，严肃命令我必须写出测试，构造出可以造成这种后果的数据结构，确保这个bug不会再重新出现。&lt;br&gt;为一个我根本不会犯的错误写测试，而且它不可能再次发生，这不是很搞笑吗？就算你写了测试，也不能保证同样的事情不再发生。如果你不小心漏掉“&amp;”，下次同样的问题还会发生，并且发生在另外的地方，而你却没有给那块代码写测试，所以给这个bug写测试，并不能防止同样的问题再次发生。这就像一个技术不过关的赛车手，他在别人不大可能撞车的地方撞了车，然后就要求赛场在那个地方装上轮胎护栏。可是下一次，这个车手又会在另一个其他人都不会撞车地方撞车……&lt;br&gt;稍微有点图论常识，熟悉C++基本概念的人，都不会犯这种错误。防止这种问题，只有靠个人的技术和经验，而不能靠测试。防止它再次发生的最好办法，恐怕是开个会把这个问题讲清楚，让大家理解，下次不要再犯。所以给这个bug写测试，完全是多此一举。跟队友们讲解了这个原理，他们听了之后，仿佛什么都没有听到一样，仍然强硬的要求：“可是你还是得写这个测试，因为这是我们的规定！你知道要是出了bug，送一个销售工程师去客户那里，要花多少钱吗……”无语了。&lt;br&gt;Coverity的Java分析，就是经常因为这种测试教条主义，使得项目进展及其痛苦和缓慢，却仍然bug百出。Coverity的其他的问题，还包括我上面指出的，写重复的测试，一个测试测太多东西，使用字符串比较来做测试，等等。你恐怕很难想象，一个制造旨在提高代码质量的产品的公司，自己代码的质量是这样维护的:P&lt;br&gt;完&lt;br&gt;由于绝大多数人对测试的误解如此之深，测试教条主义的流毒如此之广，导致许许多多优秀的程序员沉沦在繁琐的测试驱动开发中，无法舒展自己的长处。为了大家有一个轻松，顺利又可靠的工作环境，我希望大家多多转发这篇文章，改变这个行业的陋习。我希望大家在工程中理性的对待测试，而不是盲目的写测试，只有这样才能更好更快的完成项目。&lt;/blockquote&gt;</description>
<author>王垠</author>
<guid isPermaLink="false">2018-01-29-33391692</guid>
<pubDate>Mon, 29 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>设计的重要性</title>
<link>https://henix.github.io/feeds/zhihu.posts.yinwang0/2018-01-29-33390846.htm</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33390846&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b5d38986b8a8f187dfbe127c1f1829b2_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;来源：王垠的博客&lt;/p&gt;&lt;blockquote&gt;我曾经在一篇文章里谈过关于设计的问题，然而那篇文章由于标题不够醒目，可能很多人没有注意看。我觉得现在有必要把里面的内容专门提出来讲一下，因为设计在我的心目中具有至关重要的地位，却被很多计算机科学家和程序员所轻视。&lt;br&gt;我觉得自己不但是一个计算机科学家和程序员，在很大程度上我还是一个设计师。我不但是一个程序语言的设计师，而且是其它很多东西的设计师。我设计的东西不但常常比别人的简洁好用，而且我经常直接看出其他人的设计里面的问题。我写的代码不仅自己容易看懂，而且别人也容易理解。我有时候受命修补前人的BUG，结果没法看懂他们的代码。在这种情况下，我的解决方案是推翻重写。经我重写之后的代码，不仅没有BUG，而且简洁很多。&lt;br&gt;很多人自己的设计有问题，太复杂不易用，到头来却把责任推在用户身上，使用类似“皇帝的新装”的技巧，让用户有口难言。之前一篇文章提到的严重交通事故，就是一个设计问题，却被很多人归结为“人为错误”。这种出人命的事情都这么难引起人们对设计的关注，就更不要说软件行业那些无关性命的恼人之处了。有些人写的代码过度复杂，BUG众多，却仿佛觉得自己可以评估其他人的智商，打心眼里觉得自己是专家，看不懂他代码的人都是笨蛋。&lt;br&gt;很多程序员有意把“用户”和自己区别开来，好像程序员应该高人一等，不能以用户的标准。所以他们觉得程序员就是应该会用各种难用的工具，难用的操作系统，程序语言，编辑器，……他们觉得只要你追求这些东西的“易用性”或者“直观性”，就说明你智商有问题。只要你说某个东西太复杂，另一个东西好用些，他们就会跟你说：“专家才用这个，你那个是菜鸟用的。”这些人不明白，程序员其实也是用户，而且他们是自己的代码的用户，每一次调用自己写的函数，自己都是自己的用户。可是这种鄙视用户的风气之胜行，带来了整个行业不但设计过度复杂，而且以复杂为豪的局面。&lt;br&gt;经常有人自豪的声称自己的项目有多少万行代码，仿佛代码的行数是衡量一个软件质量的标准，行数越多质量越好，然而事实却恰恰相反。就像《小王子》作者说的：“一个设计师知道他达到了完美，并不是当他不能再加进任何东西，而是当没有任何东西可以被去掉。”&lt;br&gt;如果你跟我一样关心设计，却发现身边的人喜欢显示自己能搞懂复杂的东西，跟你说容易的东西都是菜鸟用的，那么你需要一个朋友。书籍是人类最好的朋友，因为它的作者可以跨越时间和空间的限制，给你最需要的支持和鼓励。这就是当我阅读这本1988年出版的《TheDesignofEverydayThings》（简称DOET）时的感觉。我觉得，终于有人懂我了！有趣的是，它的作者DonNorman曾经是AppleFellow，也是《TheUnix-HatersHandbook》一书序言的作者。&lt;br&gt;DOET不但包含并且支持了我的博文《黑客文化的精髓》以及《程序语言与……》里的基本观点，而且提出了比《什么是“对用户友好”》更精辟可行的解决方案。&lt;br&gt;我觉得这应该是每个程序员必读的书籍。为什么每个程序员必读呢？因为虽然这本书是设计类专业的必读书籍，而计算机及其编程语言和工具，其实才是作者指出的缺乏设计思想的“重灾区”。看了它，你会发现很多所谓的“人为错误”，其实是工具的设计不合理造成的。一个设计良好的工具，应该只需要很少量的文档甚至不需要文档。这本书将提供给你改进一切事物的原则和灵感。你会恢复你的人性。&lt;br&gt;值得一提的是，虽然DonNorman曾经是AppleFellow，但我觉得Apple产品设计的人性化程度与Norman大叔的思维高度还是有一定的差距的。因为我看了这书之后，立马发现了iPhone的一些设计问题。&lt;br&gt;如果你跟我一样不想用眼睛看书，可以到Audible买本有声书来听。&lt;/blockquote&gt;</description>
<author>王垠</author>
<guid isPermaLink="false">2018-01-29-33390846</guid>
<pubDate>Mon, 29 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Kotlin 和 Checked Exception</title>
<link>https://henix.github.io/feeds/zhihu.posts.yinwang0/2018-01-29-33390708.htm</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33390708&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b5d38986b8a8f187dfbe127c1f1829b2_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;来源：王垠的博客&lt;/p&gt;&lt;blockquote&gt;最近JetBrains的Kotlin语言忽然成了热门话题。国内小编们传言说，Kotlin取代了Java，成为了Android的“钦定语言”，很多人听了之后热血沸腾。初学者们也开始注意到Kotlin，问出各种“傻问题”，很“功利”的问题，比如“现在学Kotlin是不是太早了一点？”结果引起一些Kotlin老鸟们的鄙视。当然也有人来信，请求我评价Kotlin。&lt;br&gt;对于这种评价语言的请求，我一般都不予理睬的。作为一个专业的语言研究者，我的职责不应该是去评价别人设计的语言。然而浏览了Kotlin的文档之后，我发现Kotlin的设计者误解了一个重要的问题——关于是否需要checkedexception。对于这个话题我已经思考了很久，觉得有必要分享一下我对此的看法，避免误解的传播，所以我还是决定写一篇文章。&lt;br&gt;可以说我这篇文章针对的是checkedexception，而不是Kotlin，因为同样的问题也存在于C#和其它一些语言。&lt;br&gt;冷静一下&lt;br&gt;在进入主题之前，我想先纠正一些人的误解，让他们冷静下来。我们首先应该搞清楚的是，Kotlin并不是像有些国内媒体传言的那样，要“取代Java成为Android的官方语言”。准确的说，Kotlin只是得到了Android的“官方支持”，所以你可以用Kotlin开发Android程序，而不需要绕过很多限制。可以说Kotlin跟Java一样，都是Android的官方语言，但Kotlin不会取代Java，它们是一种并存关系。&lt;br&gt;这里我不得不批评一下有些国内技术媒体，他们似乎很喜欢片面报道和歪曲夸大事实，把一个平常的事情吹得天翻地覆。如果你看看国外媒体对Kotlin的报道，就会发现他们用词的迥然不同：&lt;br&gt;Google’sJava-centricAndroidmobiledevelopmentplatformisaddingtheKotlinlanguageasanofficiallysupporteddevelopmentlanguage,andwillincludeitintheAndroidStudio3.0IDE.&lt;br&gt;译文：Google的以Java为核心的Android移动开发平台，加入了Kotlin作为官方支持的开发语言。它会被包含到AndroidStudio3.0IDE里面。&lt;br&gt;看明白了吗？不是“取代了Java”，而只是给了大家另一个“选择”。我发现国内的技术小编们似乎很喜欢把“选择”歪曲成“取代”。前段时间这些小编们也有类似的谣传，说斯坦福大学把入门编程课的语言“换成了JavaScript”，而其实别人只是另外“增加”了一门课，使用JavaScript作为主要编程语言，原来以Java为主的入门课并没有被去掉。我希望大家在看到此类报道的时候多长个心眼，要分清楚“选择”和“取代”，不要盲目的相信一个事物会立即取代另一个。&lt;br&gt;Android显然不可能抛弃Java而拥抱Kotlin。毕竟现有的Android代码绝大部分都是Java写的，绝大部分程序员都在用Java。很多人都知道Java的好处，所以他们不会愿意换用一个新的，未经时间考验的语言。所以虽然Kotlin在Android上得到了和Java平起平坐的地位，想要程序员们从Java转到Kotlin，却不是一件容易的事情。&lt;br&gt;我不明白为什么每当出现一个JVM的语言，就有人欢呼雀跃的，希望它会取代Java，似乎这些人跟Java有什么深仇大恨。他们已经为很多新语言热血沸腾过了，不是吗？Scala，Clojure……一个个都像中国古代的农民起义一样，煽动一批人起来造反，而其实自己都不知道自己在干什么。Kotlin的主页也把“drasticallyreducetheamountofboilerplatecode”作为了自己的一大特色，仿佛是在暗示大家Java有很多“boilerplatecode”。&lt;br&gt;如果你经过理性的分析，就会发现Java并不是那么的讨厌。正好相反，Java的有些设计看起来“繁复多余”，实际上却是经过深思熟虑的决定。Java的设计者知道有些地方可以省略，却故意把它做成多余的。不理解语言“可用性”的人，往往盲目地以为简短就是好，多写几个字就是丑陋不优雅，其实不是那样的。关于Java的良好设计，你可以参考我之前的文章《为Java说句公道话》。另外在《对Rust语言的分析》里面，我也提到一些容易被误解的语言可用性问题。我希望这些文章对人们有所帮助，避免他们因为偏执而扔掉好的东西。&lt;br&gt;实际上我很早以前就发现了Kotlin，看过它的文档，当时并没有引起我很大的兴趣。现在它忽然火了起来，我再次浏览它的新版文档，却发现自己还是会继续使用Java或者C++。虽然我觉得Kotlin比起Java在某些小地方设计相对优雅，一致性稍好一些，然而我并没有发现它可以让我兴奋到愿意丢掉Java的地步。实际上Kotlin的好些小改进，我在设计自己语言的时候都已经想到了，然而我并不觉得它们可以成为人们换用一个新语言的理由。&lt;br&gt;CheckedException（CE）的重要性&lt;br&gt;有几个我觉得很重要的，具有突破性的语言特性，Kotlin并没有实现。另外我还发现一个很重要的Java特性，被Kotlin的设计者给盲目抛弃了。这就是我今天要讲的主题：checkedexception。我不知道这个术语有什么标准的中文翻译，为了避免引起定义混乱，下文我就把它简称为“CE”好了。&lt;br&gt;先来科普一下CE到底是什么吧。Java要求你必须在函数的类型里面声明它可能抛出的异常。比如，你的函数如果是这样：&lt;br&gt;voidfoo(stringfilename)throwsFileNotFoundException&lt;br&gt;{&lt;br&gt;if(...)&lt;br&gt;{&lt;br&gt;thrownewFileNotFoundException();&lt;br&gt;}&lt;br&gt;...&lt;br&gt;}&lt;br&gt;Java要求你必须在函数头部写上“throwsFileNotFoundException”，否则它就不能编译。这个声明表示函数在某些情况下，会抛出FileNotFoundException这个异常。由于编译器看到了这个声明，它会严格检查你对foo函数的用法。在调用foo的时候，你必须使用try-catch处理这个异常，或者在调用的函数头部也声明“throwsFileNotFoundException”，把这个异常传递给上一层调用者。&lt;br&gt;try&lt;br&gt;{&lt;br&gt;foo(&quot;blah&quot;);&lt;br&gt;}&lt;br&gt;catch(FileNotFoundExceptione)&lt;br&gt;{&lt;br&gt;...&lt;br&gt;}&lt;br&gt;这种对异常的声明和检查，叫做“checkedexception”。很多语言（包括C++，C#，JavaScript，Python……）都有异常机制，但它们不要求你在函数的类型里面声明可能出现的异常类型，也不使用静态类型系统对异常的处理进行检查和验证。我们说这些语言里面有“exception”，却没有“checkedexception”。&lt;br&gt;理解了CE这个概念，下面我们来谈正事：Kotlin和C#对CE的误解。&lt;br&gt;Kotlin的文档明确的说明，它不支持类似Java的checkedexception（CE），指出CE的缺点是“繁琐”，并且列举了几个普通程序员心目中“大牛”的文章，想以此来证明为什么Java的CE是一个错误，为什么它不解决问题，却带来了麻烦。这些人包括了BruceEckel和C#的设计者AndersHejlsberg。&lt;br&gt;很早的时候我就看过Hejlsberg的这些言论。他的话看似有道理，然而通过自己编程和设计语言的实际经验，我发现他并没有抓住问题的关键。他的论述里有好几处逻辑错误，一些自相矛盾，还有一些盲目的臆断，所以这些言论并没能说服我。正好相反，实在的项目经验告诉我，CE是C#缺少的一项重要特性，没有了CE会带来相当麻烦的后果。在微软写C#的时候，我已经深刻体会到了缺少CE所带来的困扰。现在我就来讲一下，CE为什么是很重要的语言特性，然后讲一下为什么Hejlsberg对它的批评是站不住脚的。&lt;br&gt;首先，写C#代码时最让我头痛的事情之一，就是C#没有CE。每调用一个函数（不管是标准库函数，第三方库函数，还是队友写的函数，甚至我自己写的函数），我都会疑惑这个函数是否会抛出异常。由于C#的函数类型上不需要标记它可能抛出的异常，为了确保一个函数不会抛出异常，你就需要检查这个函数的源代码，以及它调用的那些函数的源代码……&lt;br&gt;也就是说，你必须检查这个函数的整个“调用树”的代码，才能确信这个函数不会抛出异常。这样的调用树可以是非常大的。说白了，这就是在用人工对代码进行“全局静态分析”，遍历整个调用树。这不但费时费力，看得你眼花缭乱，还容易漏掉出错。显然让人做这种事情是不现实的，所以绝大部分时候，程序员都不能确信这个函数调用不会出现异常。&lt;br&gt;在这种疑虑的情况下，你就不得不做最坏的打算，你就得把代码写成：&lt;br&gt;try&lt;br&gt;{&lt;br&gt;foo();&lt;br&gt;}&lt;br&gt;catch(Exception)&lt;br&gt;{&lt;br&gt;...&lt;br&gt;}&lt;br&gt;注意到了吗，这也就是你写Java代码时，能写出的最糟糕的异常处理代码！因为不知道foo函数里面会有什么异常出现，所以你的catch语句里面也不知道该做什么。大部分人只能在里面放一条log，记录异常的发生。这是一种非常糟糕的写法，不但繁复，而且可能掩盖运行时错误。有时候你发现有些语句莫名其妙没有执行，折腾好久才发现是因为某个地方抛出了异常，所以跳到了这种catch的地方，然后被忽略了。如果你忘了写catch(Exception)，那么你的代码可能运行了一段时间之后当掉，因为忽然出现一个测试时没出现过的异常……&lt;br&gt;所以对于C#这样没有CE的语言，很多时候你必须莫名其妙这样写，这种做法也就是我在微软的C#代码里经常看到的。问原作者为什么那里要包一层try-catch，答曰：“因为之前这地方出现了某种异常，所以加了个try-catch，然后就忘了当时出现的是什么异常，具体是哪一条语句会出现异常，总之那一块代码会出现异常……”如此写代码，自己心虚，看的人也糊涂，软件质量又如何保证？&lt;br&gt;那么Java呢？因为Java有CE，所以当你看到一个函数没有声明异常，就可以放心的省掉try-catch。所以这个C#的问题，自然而然就被避免了，你不需要在很多地方疑惑是否需要写try-catch。Java编译器的静态类型检查会告诉你，在什么地方必须写try-catch，或者加上throws声明。如果你用IntelliJ，把光标放到catch语句上面，可能抛出那种异常的语句就会被加亮。C#代码就不可能得到这样的帮助。&lt;br&gt;CE看起来有点费事，似乎只是为了“让编译器开心”，然而这其实是每个程序员必须理解的事情。出错处理并不是Java所特有的东西，就算你用C语言，也会遇到本质一样的问题。使用任何语言都无法逃脱这个问题，所以必须把它想清楚。在《编程的智慧》一文中，我已经讲述了如何正确的进行出错处理。如果你滥用CE，当然会有不好的后果，然而如果你使用得当，就会起到事半功倍，提高代码可靠性的效果。&lt;br&gt;Java的CE其实对应着一种强大的逻辑概念，一种根本性的语言特性，它叫做“uniontype”。这个特性只存在于TypedRacket等一两个不怎么流行的语言里。Uniontype也存在于PySonar类型推导和Yin语言里面。你可以把Java的CE看成是对uniontype的一种不完美的，丑陋的实现。虽然实现丑陋，写法麻烦，CE却仍然有着uniontype的基本功能。如果使用得当，uniontype不但会让代码的出错处理无懈可击，还可以完美的解决null指针等头痛的问题。通过实际使用Java的CE和TypedRacket的uniontype来构建复杂项目，我很确信CE的可行性和它带来的好处。&lt;br&gt;现在我来讲一下为什么Hejlsberg对于CE的批评是站不住脚的。他的第一个错误，俗话说就是“人笨怪刀钝”。他把程序员对于出错处理的无知，不谨慎和误用，怪罪在CE这个无辜的语言特性身上。他的话翻译过来就是：“因为大部分程序员都很傻，没有经过严格的训练，不小心又懒惰，所以没法正确使用CE。所以这个特性不好，是没用的！”&lt;br&gt;他的论据里面充满了这样的语言：&lt;br&gt;“大部分程序员不会处理这些throws声明的异常，所以他们就给自己的每个函数都加上throwsException。这使得Java的CE完全失效。”&lt;br&gt;“大部分程序员根本不在乎这异常是什么，所以他们在程序的最上层加上catch(Exception)，捕获所有的异常。”&lt;br&gt;“有些人的函数最后抛出80多种不同的异常，以至于使用者不知道该怎么办。”……&lt;br&gt;注意到了吗，这种给每个函数加上throwsException或者catch(Exception)的做法，也就是我在《编程的智慧》里面指出的经典错误做法。要让CE可以起到良好的作用，你必须避免这样的用法，你必须知道自己在干什么，必须知道被调用的函数抛出的exception是什么含义，必须思考如何正确的处理它们。&lt;br&gt;另外CE就像uniontype一样，如果你不小心分析，不假思索就抛出异常，就会遇到他提到的“抛出80多种异常”的情况。出现这种情况往往是因为程序员没有仔细思考，没有处理本来该自己处理的异常，而只是简单的把下层的异常加到自己函数类型里面。在多层调用之后，你就会发现最上面的函数累积起很多种异常，让调用者不知所措，只好传递这些异常，造成恶性循环。终于有人烦得不行，把它改成了“throwsException”。&lt;br&gt;我在使用TypedRacket的uniontype时也遇到了类似的问题，但只要你严格检查被调用函数的异常，尽量不让它们传播，严格限制自己抛出的异常数目，缩小可能出现的异常范围，这种情况是可以避免的。CE和uniontype强迫你仔细的思考，理顺这些东西之后，你就会发现代码变得非常缜密而优雅。其实就算你写C代码或者JavaScript，这些问题是同样存在的，只不过这些语言没有强迫你去思考，所以很多时候问题被稀里糊涂掩盖了起来，直到很长时间之后才暴露出来，不可救药。&lt;br&gt;所以可以说，这些问题来自于程序员自己，而不是CE本身。CE只提供了一种机制，至于程序员怎么使用它，是他们自己的职责。再好的特性被滥用，也会产生糟糕的结果。Hejlsberg对这些问题使用了站不住脚的理论。如果你假设程序员都是糊里糊涂写代码，那么你可以得出无比惊人的结论：所有用于防止错误的语言特性都是没用的！因为总有人可以懒到不理解这些特性的用法，所以他总是可以滥用它们，绕过它们，写出错误百出的代码，所以静态类型没用，CE没用，……有这些特性的语言都是垃圾，大家都写PHP就行了;)&lt;br&gt;Hejlsberg把这些不理解CE用法，懒惰，滥用它的人作为依据，以至于得出CE是没用的特性，以至于不把它放到C#里面。由于某些人会误用CE，结果就让真正理解它的人也不能用它。最后所有人都退化到最笨的情况，大家都只好写catch(Exception)。在Java里，至少有少数人知道应该怎么做，在C#里，所有人都被迫退化成最差的Java程序员;)&lt;br&gt;另外，Hejlsberg还指出C#代码里没有被catch的异常，应该可以用“静态分析”检查出来。可以看出来，他并不理解这种静态检查是什么规模的问题。要能用静态分析发现C#代码里被忽略的异常，你必须进行“全局分析”，也就是说为了知道一个函数是否会抛出异常，你不能只看这个函数。你必须分析这个函数的代码，它调用的代码，它调用的代码调用的代码……所以你需要分析超乎想象的代码量，而且很多时候你没有源代码。所以对于大型的项目，这显然是不现实的。&lt;br&gt;相比之下，Java要求你对异常进行throws显式声明，实质上把这个全局分析问题分解成了一个个模块化（modular）的小问题。每个函数作者完成其中的一部分，调用它的人完成另外一部分。大家合力帮助编译器，高效的完成静态检查，防止漏掉异常处理，避免不必要的try-catch。实际上，像Exceptional一类的C#静态检查工具，会要求你在注释里写出可能抛出的异常，这样它才能发现被忽略的异常。所以Exceptional其实重新发明了Java的CE，只不过throws声明被写成了一个注释而已。&lt;br&gt;说到C#，其实它还有另外一个特别讨厌的设计错误，引起了很多不必要的麻烦。感兴趣的人可以看看我这篇文章：《可恶的C#IDisposable接口》。这个问题浪费了整个团队两个月之久的时间。所以我觉得作为C#的设计者，Hejlsberg的思维局限性相当大。我们应该小心的分析和论证这些人的言论，不应该把他们作为权威而盲目接受，以至于让一个优秀的语言特性被误解，不能进入到新的语言里。&lt;br&gt;结论？&lt;br&gt;所以我对Kotlin是什么“结论”呢？我没有结论，这篇文章就像我所有的看法一样，仅供参考。显然Kotlin有的地方做得比Java好，所以它不会因为没有CE而完全失去意义。我不想打击人们对新事物的兴趣，我甚至鼓励有时间的人去试试看。&lt;br&gt;我知道很多人希望我给他们一个结论，到底是用一个语言，还是不用它，这样他们就不用纠结了，然而我并不想给出一个结论。一来是因为我不想让人感觉我在“控制”他们，如何看待一个东西是他们的自由，是否采用一个东西是他们自己的决定。二来是因为我还没有时间和机会，去用Kotlin来做实际的项目。另外，我早就厌倦了试用新的语言，如果一个大众化的语言没有特别讨厌，不可原谅的设计失误，我是不会轻易换用新语言的。我宁愿让其他人做我的小白鼠，去试用这些新语言。到后来我有空了，再去看看他们的成功或者失败经历:P&lt;br&gt;所以对我个人而言，我至少现在不会去用Kotlin，但我并不想让其他人也跟我一样。因为Java，C++和C已经能满足我的需求，它们相当稳定，而且我对它们已经很熟悉，所以我为什么要花精力去学一个新的语言，去折腾不成熟的工具，放下我真正感兴趣的算法和数据结构等问题呢？实际上不管我用什么语言写代码，我的头脑里都在用同一个语言构造程序。我写代码的过程，只不过是在为我脑子里的“万能语言”找到对应的表达方式而已。&lt;/blockquote&gt;</description>
<author>王垠</author>
<guid isPermaLink="false">2018-01-29-33390708</guid>
<pubDate>Mon, 29 Jan 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
