<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>迷思</title>
<link>https://henix.github.io/feeds/zhuanlan.prattle/</link>
<description>我的博客及微信公众号里的精华内容都会放在这里。 我的博客及微信公众号里的精华内容都会放在这里。</description>
<language>zh-cn</language>
<lastBuildDate>Tue, 01 Jan 2019 04:14:36 +0800</lastBuildDate>
<item>
<title>数据：逍遥游</title>
<link>https://henix.github.io/feeds/zhuanlan.prattle/2018-11-15-49915113.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49915113&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7ad6ea6f456b42e2c4e41de3d30b9812_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;天之苍苍，其正色邪？其远而无所至极邪？其视下也，亦若是则已矣。 - 《逍遥游》&lt;/blockquote&gt;&lt;p&gt;对程序员来说，数据是我们时刻都在打交道的东西。我们的代码如同一台机器，把进入的数据转换或者映射成出来的数据。数学上，不过是：&lt;code class=&quot;inline&quot;&gt;y = f(x)&lt;/code&gt; 而已。数据就像庄子口中的鱼，在代码的作用下，一会化身为文件，在文件系统里「沉潜」，一会化身为变量，在内存中「浮动」，一会又扶摇直上，化身为字节流，在网络中「翱翔」。&lt;/p&gt;&lt;p&gt;周易里说：简易，变易，不易。数据再变化多端，复杂深奥，我们只要厘清了它的概念，摸清了它的脾性，就能掌控它，驾驭它；再从它的千变万化之中，找到一些固定的规律，就能成为它的主人。倒时差睡不着觉，突然想到了这个话题，便欲与诸君聊聊。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;概念&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;概念是事物的本元。含混不清的概念会导致含混不清的关系，进而把思维拖入含混不清的泥潭。工欲善其事，必先正其名。我们看看，围绕着数据，都有哪些概念。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;标识&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;标识是唯一能够代表数据本身的「名字」。这里有两重含义：1）唯一 2）代表。很多时候我们把标识和名字混淆。我的公众号的名字叫「程序人生」，但这个名字并不代表这个公号，任何公号都可以取名「程序人生」。所以标识必须唯一。在实际的工作中，我们往往只是关注到了标识的唯一性，却忽视了它的代表性。想想看，ID 是否是一个标识？99.999% 的情况下我们都会说 ID 等同于标识。我们通过王小二的身份证号可以精准找到王小二这个人，但是身份证号和王小二之间的联系是脆弱的单向连接关系。我找到了王小二，但单独从王小二身上我们并不能推演出他的身份证。80后大概还记得，大概十几年前，我们的身份证号码经历了 15 位到 18 位的更迭，旧的号码依旧唯一，但它失去了和它联系在一起的数据。标识既然能够代表数据，那么，数据理应也能够使用某种算法确定地推导出其标识；同样的，数据的标识不可能改变，也不应该改变。&lt;/p&gt;&lt;p&gt;符合这个条件的标识，对于人来说，是虹膜，指纹，DNA，哪怕王小二改名叫王小三，身份证从中国的换成泰国的，她还是那个他。对数据而言，符合这个条件的标识，是数据的 md5，sha1，sha2，sha3 等。&lt;/p&gt;&lt;p&gt;注意，标识唯一代表数据，但数据的标识可以并不唯一，这个不矛盾。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;地址&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们剥茧抽丝，把标识从与其纠缠的诸多概念中分离，有利于我们对后续内容的阐述。搞清楚标识后，地址就容易理解多了。地址是用来定位和寻找数据的，它是单向连接的，也是唯一的。从这个角度来说，地址是标识的超集，标识是地址的子集。上文提到的身份证号，就是一个地址。其它常见的地址还有数据库中一条记录的 ID，当然，更准确地说，数据库主机名 + 数据库名 + 表名 + ID，是这条记录的地址。包含完整路径的文件名是文件内容的地址。一个包含 IP 地址和端口的五元组（src ip, src port, dest ip, dest port, protocol）是一个 socket 连接的地址。&lt;/p&gt;&lt;p&gt;地址和地址对应的内容其实构成了一个逻辑上的 kv store。所以一个文件系统，本质上是一个 kv store，给我一个文件名（key），我就可以找到并且给你它的内容（value）。&lt;/p&gt;&lt;p&gt;我们说标识是地址的子集，那么如果我们就用数据的标识来寻址数据呢？这打开了一个奇妙的世界 —— 我们标识指向了数据，而数据本身又能推倒出来标识，从而证明 &lt;b&gt;我要寻址的内容，的确是我要寻址的内容&lt;/b&gt;。仔细咂摸这句话的威力。举个例子，夜深人静，你猥琐地带上耳机，颤巍巍的右手点开了 苍井空.avi，打开却是「般若波罗蜜多心经」。。。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;引用&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;搞懂了地址，那么引用是什么？我们为什么需要引用？引用是一个中间人（middleware），它把数据的地址和处理数据的上下文联系起来。人的名字就是一个最重要的引用。有了名字，人们便不必费力地记忆 9527，而是使用「华安」来指代 9527。在华府的上下文里，9527 是华安，出了华府，就是伯虎。所以我们说引用把数据的地址和上下文联系起来。从这个意义上讲，引用是一种隔离（indirection），它让被它隔离的上下两层可以互相不知道对方的存在。计算机世界里有句名言：Any problem in computer science can be solved with another layer of indirection。由此可见引用的巨大威力。Clojure 之父 Rich Hickey 在他的演讲 Simple made easy 中说：引用让我们避免糟糕的 PLOP - PLace Oriented Programming。&lt;/p&gt;&lt;p&gt;有了引用，你可以使用变量名来指代变量的内存地址，从而对数据进行读写，避免了代码被锁死在某种 CPU 的寻址能力上；你可以使用 &lt;code class=&quot;inline&quot;&gt;git reset HEAD~1&lt;/code&gt; 而不用关心当前的 &lt;code class=&quot;inline&quot;&gt;HEAD&lt;/code&gt; 究竟指向阿猫还是阿狗；你也可以 symbol link 让 current.log 指向系统中当前的日志文件，从而程序不用关心当前日志文件的具体位置。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;特性&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;区分清楚数据的标识，地址和引用后，我们接着讲数据应该具备的特性。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;不变&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;数据最重要的一个特性是：数据本质上是不可变的。这个论点很反大家的直觉，但如果我们加上时空的维度，就好理解一些。假设我们有数据 D0，在 t1 时刻，发生了事件 E1，导致这个数据迁移到 D1。这是数据发生变化的基本模式。我们目前的处理方式是：in-place update —— 直接把 D0 指向的内存地址或者文件位置写入 D1 的内容。数据 D0 变成了 D1，所以，我们认为它是可变的。然而，在 t0 时刻，数据依旧是 D0，这个事实是无法改变的。如果我们认清了这一点，不要做 in-place update，就能大大简化我们处理问题的方法。&lt;/p&gt;&lt;p&gt;比如在多线程的上下文，线程 alice，bob 和 tyr 都拿到了 t0 时刻的数据 D0 的引用。alice 使用她的引用，把 D0 迁移到 D1，并不会影响到 bob 和 tyr 对 D0 的使用，在他们各自的世界里，他们依旧看到的是 D0。这样，bob 和 tyr 不必担心 alice 的写入行为导致他们的代码崩溃，因而无所谓关键区的保护和上锁了，也就意味着 alice，bob 和 tyr 尽管作用于同一个数据之上，它们并不需要知道彼此的存在。从这个意义上讲，数据的不可变可以大大降低代码的上下文依赖。&lt;/p&gt;&lt;p&gt;多线程的这个例子放在 git 上，alice，bob 和 tyr 就是从同一个 master 分离出来的几个分支。它们可以独立完成它们的工作，互不干扰。只有当 alice 要把自身的工作合并到 master 时，她才需要看看 master 在最新的时刻和自己从 master 分离出来的时刻发生了哪些变化，自己能否适应这些变化：是 rebase，merge 还是 resolve conflict。&lt;/p&gt;&lt;p&gt;「数据不可变」这种看待数据的方式有着弥足珍贵的价值。&lt;/p&gt;&lt;p&gt;数据在内存中不可变，可以高效解决并发问题。大部分函数式编程语言使用了这一特性，让简洁可并发的代码易如反掌。不可变并不意味着数据不可修改，而是修改之后的状态并不影响修改之前的状态。要达到这样的效果，最直白的方法是只要有修改，就进行内存复制，但这种方式低效。persistent data structure 的发明和使用，让数据的不可变在性能上和效率上具备可操作性。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-549bac965615d1604b3a2affb69cb926_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;762&quot; data-rawheight=&quot;452&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-549bac965615d1604b3a2affb69cb926&quot; data-watermark-src=&quot;v2-9f9d2d576b22038225e955ec2698ab18&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;数据在持久化存储（比如硬盘）上不可变，可以用于追踪版本的变化。git 通过这种方式打造了一个极为特别的文件系统，在 VCS（Version Control System）领域舍我其谁。&lt;/p&gt;&lt;p&gt;不变意味着数据可以用其标识进行寻址，这样数据便和位置无关，可以放在任何地方：可以在远端的自己并不拥有主权的服务器上，也可能在本地的某个角落。它可以被缓存，可以被验真，可以被高效地保存（无损压缩），可以衍生出新的数据并且追踪和验证这些衍生数据。&lt;/p&gt;&lt;p&gt;解释一下数据的衍生。比如说一张 3200x1800 的照片 —— 我们将其衍生出 800x450 的缩略图。照片的寻址使用 sha2，在衍生出来的缩略图中我们携带原图的 sha2 以及衍生过程所使用的算法。假设原图的 sha2 地址是 abcd，缩略图是 efgh，那么，我们可以从衍生出来的缩略图中找到原图的地址 abcd，并且进而拿到原图的内容。之后我们可以用相同的算法算出缩略图，然后计算其地址，如果是 efgh，那么可以证明这个缩略图衍生自原图。&lt;/p&gt;&lt;p&gt;稍稍多说两句 git。&lt;/p&gt;&lt;p&gt;git 对自己的定位是 content-addressable file system。VCS 只是 git 能力的一种体现而已（而代码管理仅仅是 VCS 的一种应用而已，看看，我们就这么暴殄天物）。所谓 content-addressable，就是上文中我们说可以用数据本身的标识来寻址数据。用数据的标识来寻址数据，其先决条件一定是是数据不可变，二者相辅相成。因为唯有数据不可变，数据的标识才不变，才能够用作寻址的手段。git 使用这种方式把一个个文件组织成一棵树，再生成一个指向这棵树的 commit。之后，数据内容的变化导致新的树的产生，最终形成一个庞杂的 DAG（有向无环图）：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9604f6401f74f057e2481aac8be0ae8b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;358&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9604f6401f74f057e2481aac8be0ae8b&quot; data-watermark-src=&quot;v2-10bbef7e1139c4a7a4e17f86744e0de5&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;然而，我们知道，光有地址还无法无法方便使用数据，我们需要引用，于是有了 head / tag / branch，让我们可以给一个个枯燥难懂的 sha1 地址起名，比如默认的 master branch，某个 release 的 tag，它们都是对一个个 commit 地址的引用：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f6b0ac738f521b6ce451405aed0a83bc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;533&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f6b0ac738f521b6ce451405aed0a83bc&quot; data-watermark-src=&quot;v2-9ca0fbc80ed4dead97227c114fded33f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;IPFS（Inter-Planetary File System）进一步把 git 用来描述文件和目录树的 DAG 和 p2p 网络结合起来，打造了一个去中心化的文件系统。我们先抛开 p2p 这部分不谈，看看把整个文件系统用 content-addressable 的方式来描述有什么好处？首先，寻址到的文件能够自证其白，你想要找的 QmarHSr9（苍井空.avi 的 content-address），就是你想要的 avi，一帧不多，一帧不少。其次，你可以在文件的不同版本中漫游。由于每次改动都会导致产生新的标识，从而生成了一个新的树，所以任意时刻的改动都可以很方便地被找到。&lt;/p&gt;&lt;p&gt;和现有的文件系统相比，你也许会担心这种文件系统对资源的额外消耗。的确多了不少，但这是值得的。就跟函数式编程语言的 persistent data structure，浪费了一些内存，但收获到的好处远比这种浪费要多得多。文件现在有了版本，可以恢复到任意状态； 可以自证 —— 地址的的确确代表了内容；由于这种寻址方式和具体的位置无关，我们还可以把文件的不同部分分散到不同的机器上 —— 因为文件的每个部分都可以自证，所以我们不担心恶意的机器上篡改文件内容。让文件的访问和文件在互联网或者局域网上的位置无关，同样的内容全网只会逻辑（物理上还是会有冗余）上存在一份（因为地址相同），可以大大减少存储（想想 江南 style 全网有多少份拷贝），同时提高访问效率 —— 想象一下，5G 时代，网络的速度高于磁盘访问的速度，文件的不同部分存在不同的地方能够更快地获取文件。&lt;/p&gt;&lt;p&gt;5G 时代会大大改变我们获取数据的方式：1) 网络的速度高于磁盘访问的速度，因而数据从本地读取和从网络读取几乎没有差异 2) 本地的存储容量在很短时间内被网络数据塞满（假设 5G 速度达到 10Gbps，你的 1T 硬盘也就能装 20 分钟的流量承载的数据），在这样的环境下，数据的分布式存储是是唯一选择。所以，IPFS 背后的技术，在 5G 到来后会有非常广阔的前景。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;连接&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;所谓聚沙成堆，集腋成裘，数据与数据产生连接会有量变到质变的效果。1个字节的数据仅能容纳 256 个状态，而 1GB 数据可以承载王者荣耀。一个文件描述了伏尔加河畔的一个生活场景，而一组文件可以构成恢弘的「战争与和平」。World Wide Web 对人类世界的巨大贡献是数据通过 URI 有了唯一的地址，这些地址进而通过超文本链接的形式被连接起来。于是，原本零零散散于 FTP 之上的文件以一种网状的结构被重新组织 —— 信息不再是孤零零宅着，而是以某种顺序构成一个个鲜活的有机体。&lt;/p&gt;&lt;p&gt;数据的连接大大拓展了数据的边界和数据本身的意义，然而，web 最大的问题也源自于它的组织方式：URI。URI 是 Rich 口中典型的 PLOP，它混淆了地址和标识。URI 背后的网站可能会消失，URI 映射到的内容可能会损坏，因此，你消费一个 URI 是一件不确定的事情：它可能 404，可能 500，可能两小时前和两小时后拿到的内容完全不同。这种不确定性使得我们在处理连接时需要耗费很多额外的精力去处理各种异常。&lt;/p&gt;&lt;p&gt;我们上面讲到，git 通过一棵不可变的树来管理内容。如果内容变化，会产生新的树。如果把一个网站看成是一个 git repo 组成的小树林，那么 web 就是千千万万个小树林交织成的亚马逊。网站 A 连接网站 B 的数据，并不会因为网站 B 修改该数据而失效，因为在 git 的世界里，一个对 commit hash 的引用永远有效（假设 git push -f 被禁用）。&lt;/p&gt;&lt;p&gt;在不远的将来，我们的 web 会以 git 的方式去连接。当这种连接形成后，web 不再仅仅是一种「空间」上的连接，还是一种「时间」上的连接。到那时，就没有 internet archive 什么事了，因为，一切过去，现在，以及未来都会以一种不可变的方式被记录和连接起来。&lt;/p&gt;&lt;p&gt;以上。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;继续预告一下我们这次区块链漫游指南北京站的活动，机不可失，欢迎大家翘班来听：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bae6dbb56567a6a3f898631b50c69afe_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1000&quot; data-rawheight=&quot;2000&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-bae6dbb56567a6a3f898631b50c69afe&quot; data-watermark-src=&quot;v2-b7bbf896f9d34823476b1f2780814fed&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;12:30-13:00: 签到
13:00-13:50: 公开可验证：去中心化的必经之路
13:55-14:15: 场景一：去中心化账本 - 比特币
14:15-14:35: 场景二：去中心化计算 - 以太坊
14:35-14:55: 场景三：去中心化文件系统 - IPFS
15:00-15:45: 入门指南：如何在以太坊上构建 dApps
15:50-16:30: 入门指南：如何使用 ArcBlock Forge 锻造你自己的区块链&lt;/code&gt;&lt;p&gt;这次活动我们和承办方微软创新车库一起，献上一场长达四个小时的饕餮盛宴。时间上对上班族可能不那么友好，但内容绝对精彩，不容错过！&lt;/p&gt;&lt;hr&gt;&lt;p&gt;好看的皮囊千篇一律，有趣的灵魂万里挑一。欢迎大家多多关注「程序人生」，在这里你能接触到不一样的思考，不一样的人生。&lt;/p&gt;</description>
<author>陈天</author>
<guid isPermaLink="false">2018-11-15-49915113</guid>
<pubDate>Thu, 15 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>在程序中时间旅行</title>
<link>https://henix.github.io/feeds/zhuanlan.prattle/2018-11-07-48822123.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/48822123&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7cb4eda0a2d2711fad3a337d335e0d71_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;Nor Time, nor Place, nor Chance, nor Death can bow. My least desires unto the least remove. - “The Time Traveler’s Wife”&lt;/blockquote&gt;&lt;p&gt;三年前，当我写下那篇青涩的『&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;amp;mid=206436214&amp;amp;idx=1&amp;amp;sn=2140cf7b2894c4fdeb49ad4458d0fb3e&amp;amp;scene=21#wechat_redirect&quot;&gt;永恒不变的魅力&lt;/a&gt;』的文章时，我刚刚是 elixir 和 clojure 的入门者。我如饥似渴地从 Bret Victor，Rich Hickey 等人身上吸取思想和力量，来浇筑我对函数式编程的信仰。函数式编程语言中有诸多让人赞不绝口的设计思想，但 immutability（不可变）显然是皇冠上的明珠。它让我们可以肆无忌惮地使用并发，不必考虑 lock，因为没有 critical section 可言；它让我们不必再终日在野指针造成的 segment fault，坏引用导致的 exception 中彷徨哀怨甚至自戕。当我们用一个产品的时候，确定性让我们感到安全和愉悦 —— 你使用微信，发给朋友的信息如果代表发送的小菊花停了没有惊叹号，那就一定成功了，这就是确定性；immutable 给程序员带来的确定性是：我给你一个引用，只要你拿着，就算到了天荒地老，海枯石烂它也能够访问，且还守候着原来的值。&lt;/p&gt;&lt;p&gt;有没有想过，这么好的东西，为什么前辈们不使用呢？&lt;/p&gt;&lt;p&gt;非不为也，实不能也。immutable 是好，但是「浪费」内存啊。&lt;/p&gt;&lt;p&gt;当机器的内存以 KB 为单位时，描述复杂状态的程序都力不从心，自然只能尽可能地重复利用每一个 bit，以期它能发挥最大的作用。什么 “copy on write”，一边去。&lt;/p&gt;&lt;p&gt;八九十年代，内存虽然到了 MB 级别，但 DOS 受限于实模式的寻址能力，还是把内存分成了五环内（低 1M）和五环外（超过 1M 的 expanded memory），所以那时的程序员依旧以扣内存闻名。&lt;/p&gt;&lt;p&gt;千禧年后，内存在亚 GB 级别往 GB 级别过渡，操作系统早已完全采用 32 位保护模式，正往 64 位过渡。大部分应用程序开发者渐渐无需考虑内存的天花板，就算一不小心把物理内存用超了，还有 swap 兜底，管够。但是，牛顿告诉我们，程序员是懒惰的，没有外力作用的时候，会产生惯性，也就是路径依赖。&lt;/p&gt;&lt;p&gt;路径依赖导致 immutable 的思想人人叫好，但依旧只是用在少量的场合，比如 git，docker，react，当然，还有区块链。&lt;/p&gt;&lt;p&gt;还有一个原因。看待世界的方式。我们所运行的世界究竟是一个可变系统（mutable system）还是一个不可变系统（immutable system）？我们先来研究自己的大脑。大多数人第一反应可能会觉得大脑是个可变系统，然而仔细想想，它是不可变的。我们的记忆就像洋葱圈一样，不断叠加，而不会修改。拿我家的电话号码来说，我脑袋里能立刻蹦出来好几个号码，有四位数的，那是小时候家里安装的第一部电话，有广东的，北京的，圣何塞的，西雅图的，等等。所以大脑是个不可变系统，数据一旦产生，大脑只会将其连接起来，并不会修改。我们再看日常发生的各种事件 —— 今天的气温，世界各地的新闻，楼下弹钢琴的孩子，所有这一切都是不可变的。气温看上去在变化，但这取决于建模的方式，如果气温不是一个值而是一个以时间为刻度的 vector 呢？&lt;/p&gt;&lt;p&gt;所以当我们把世界看成一个个只有最终状态的点的时候，它是不断变化的；然而加上时间的维度，它是不可变的 —— 在一个初值 (genesis state) 下，发生了一系列不可变的事件（event），最终导致了当下这个状态（state）。这是我们这个世界运作的方式，可惜，在大部分时间，不是我们撰写程序的方式 —— 即使我们的程序要么和现实世界打交道，要么在模拟现实世界。&lt;/p&gt;&lt;p&gt;Bret Victor 在他著名的讲座 Inventing on principle，展示了改变认识如何让我们拥有一个又一个 voila moment，比如这个截图，游戏中的时间旅行：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1dcb90b1ec67b04f06f1a0d0c6d666c8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;986&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1dcb90b1ec67b04f06f1a0d0c6d666c8&quot; data-watermark-src=&quot;v2-036c8aeffa6bf5cb32d5ca4bb80548cf&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在程序中做时间旅行并不是件新鲜事，我们每天使用的 git 就可以让我们自如地在历史上发生的任何一个 commit / tag / branch 上切换：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f6b0ac738f521b6ce451405aed0a83bc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;533&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f6b0ac738f521b6ce451405aed0a83bc&quot; data-watermark-src=&quot;v2-9ca0fbc80ed4dead97227c114fded33f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;而 clojure 的一个 pixel editor，Goya，也用时间旅行的方式来做 undo / redo，非常简单：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d016e32cbeb0e4971d0d9e9ae5dd2223_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;266&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d016e32cbeb0e4971d0d9e9ae5dd2223&quot; data-watermark-src=&quot;v2-c9fd1990d659cf413ac6196cace9b225&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;而要做到这一切，首先我们要使用 genesis state + events 的方式来描述应用程序里的世界。在 git 里，一个个 commit 就是一个个 event；在 goya 中，画笔的每一次动作，就是一个 event。&lt;/p&gt;&lt;p&gt;然后，我们需要用一个合适的数据结构来保存 state - Chris Okasaki 的 Purely Functional Data Structures 向我们揭示了 persistent data structure 的神奇魔力 —— erlang 的发明者，Robert Verding 据说就是照着 PFDS 这本书的例子写出了 erlang 的数据结构的支持：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-549bac965615d1604b3a2affb69cb926_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;762&quot; data-rawheight=&quot;452&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-549bac965615d1604b3a2affb69cb926&quot; data-watermark-src=&quot;v2-9f9d2d576b22038225e955ec2698ab18&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在这里，数据保存在叶子节点上，然后以数据的索引为基础构建出来一棵树。当整个结构的某些数据变更时，我们只需要产生新的数据，然后产生索引该数据和未改变数据的一棵新的树，从而在空间上避免 immutable 产生的拷贝。在函数式编程语言中，旧的树如果没有人用了，GC 就回将其回收，但如果我们把每个 event 产生出来的新的树和旧的树链接起来，或者记录下来，就具备了时间旅行的能力。&lt;/p&gt;&lt;p&gt;git 使用了 Merkle tree（更准确地说 Merkle DAG）来存储所有 commit 的所有 object。和 persistent data structure 思路类似，数据（commit 里的 objects）在叶子节点上，只不过连接叶子节点的索引是其 hash，而非普通的 key。Merkle DAG 的使用非常广泛，从 Plan 9 OS 到 BitTorrent，从 git 到 bitcoin / ethereum，等：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-227537aaed9cfeff6bcc73fe4e64571e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;616&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-227537aaed9cfeff6bcc73fe4e64571e&quot; data-watermark-src=&quot;v2-d10eba245c83aec0725e1de9335bebde&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们知道，通过初始的 genesis state，不断顺序叠加 event，可以构成任意时刻的 state，这样的设计思路是 event sourcing。而使用 event sourcing，把当前的 state 用 Merkle DAG 管理并保存下来，再使用公钥加密算法使所有的 event 和 state 都 public verifiable，就构成了我们所熟知的以太坊。&lt;/p&gt;&lt;p&gt;在以太坊里，其 event 是 transaction，state 使用 Merkle Patricia Tree 保存。如果把以太坊看成是一个自给自足的世界，那么其 fork 就是这个世界在平行宇宙中的另一个世界，而我们人类就像『星际穿越』中的五维人，可以在以太坊世界中进行时间旅行 —— 比如，我要回到 2017 年 1 月 13 日，去探索那个时间点这个世界里所有账户的状态，只需要找到 4904084 这个块里的 state root，找到这个 hash 下面对应的数，然后从这棵树一路往下挖掘信息。&lt;/p&gt;&lt;p&gt;那么，如果我们需要以太坊任意一个时刻的状态呢？回答这个问题之前，我们先来回答，在以太坊的世界内，时间究竟是什么？时间是区块的高度。所以，在以太坊内进行时间旅行，就是在获取不同块高下的&lt;b&gt;状态&lt;/b&gt;。然而，以太坊自己的时间对人类来说是晦涩的（1 eth second ~= 12s），所以我们需要先将人类社会的时间映射到以太坊上的块高，然后找到给定的人类时间下最接近的块高，就得到了以太坊下的任意时间内的时间旅行。&lt;/p&gt;&lt;p&gt;以上。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;我下周一回国，会在上海参加 kubeconf；在深圳出席 techrunch 的黑客马拉松，代表 arcblock 负责区块链方向；以及在微软做一次区块链的深度技术讲座，欢迎参加活动的读者们勾搭。&lt;/p&gt;</description>
<author>陈天</author>
<guid isPermaLink="false">2018-11-07-48822123</guid>
<pubDate>Wed, 07 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>区块链和数据库：致虚极，守静笃</title>
<link>https://henix.github.io/feeds/zhuanlan.prattle/2018-11-07-48821686.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/48821686&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4aac8e0cb7e3c9e25167fc7abef19e0a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;如果说牛顿的经典物理是爱因斯坦相对论在低速环境下的一种体现的话，我们所熟知的数据库技术，可以认为是区块链技术在弱分布式环境下的一个特例。&lt;/p&gt;&lt;p&gt;「弱分布式」环境是我胡扯的一个词，你可以将其理解为节点数量极其有限，运行环境高度可控的一种分布式环境。一个数据库集群运行在同一数据中心，或者不同数据中心，只要是同一个管理者，那么这就是可控的运行环境。在可控的运行环境下，默认不存在「作恶」的节点，也就无所谓 BFT（Byzantine Fault Tolerance），因此我们不需要复杂的共识算法（consensus algorithm），一般两阶段提交（two phase commit）或者 paxos / raft 就能收敛共识，满足需要。所以，数据库的共识算法是区块链共识算法的特例。&lt;/p&gt;&lt;p&gt;在区块链的世界里，交易（transaction）和交易产生的状态（state）是严格分离的。若干交易由被共识算法选择出来的矿工验证并打包成为区块（block）并广播出去，然后网络里其他参与者验证区块中每个交易的合法性，并写入自己的 state db。在 bitcoin 里，state db 是 UTXO，在 ethereum 里，则是其 world state。&lt;/p&gt;&lt;p&gt;数据库的世界里仿佛没有类似于区块链的交易记录（数据库中的 transaction 是另一个概念），但仔细想想，它的交易历史其实就是 WAL（Write-Ahead Logging）。从外界接收到的请求，数据库会先将其写入 WAL，确保其进入持久化存储，才会往它自己的 “states” 里面写入。从这个角度，我们可以认为 WAL 里的每一个记录，就对应区块链里的一个交易，它是区块链交易的特例（当然你也可以 argue 两个 checkpoint 之间可以算作一个区块）。&lt;/p&gt;&lt;p&gt;如果你再认真思考一下，WAL，blockchain，以及 Martin Fowler 很早就提倡的 CQRS（Command Query Responsibility Segregation）在这个层面上其实都是「一中各表」：大家都强调「事件」和「状态」的分离，通过前一个状态 + 当前事件，可以推演出当前状态。这样，我们只要有一个初始的「状态」，然后记录系统发生过的所有的「事件」，就可以复原任意一个时刻的「状态」。&lt;/p&gt;&lt;p&gt;我们回到交易和容纳交易的「区块」。你会发现，「区块」是一个怪怪的存在，为什么数据库不需要「区块」这样的概念作为容器装载「交易」，而区块链却需要呢？我们知道，在区块链的世界里，不确定性和确定性仿佛一对孪生兄弟，确定的是规则，不确定的是规则的执行者。所谓矿工轮流做，下回到我家，那怎么定义一个「回合」呢？为了回答这个问题，我们需要某种机制明确一个回合矿工地位的起止 —— 这个起止就是一个「区块」。不仅如此，在一个物理时钟并不一致的分布式环境下，「区块」还承载着全局时钟的功能，滴答滴答将整个网络往前推进。「区块」的概念是如此重要，以至于它当仁不让地成为共识算法的基础 —— 大家先得对下一个要出的区块序号达成共识，否则这个游戏无法进行。反观数据库系统，在一个数据库集群中，master（等价于矿工）是固定的，master 令旗一挥，slave 就迅速跟进，指哪打哪，不存在轮流坐庄，也就无所谓回合，所以其实每个「交易」就是一个「区块」。所以在数据库的世界里，逻辑上每个交易，或者说 WAL 的每个记录，自成一个隐性的「区块」。&lt;/p&gt;&lt;p&gt;我们从另一个角度来探讨这个结论。「区块」的另一个重要的作用是 crash recovery。在一个区块链网路中，某个节点无论是断网还是崩溃，其状态和网络中达成共识的状态必不一致，那么，如何从这种不一致的状态恢复同步的状态呢？答案是「区块」，因为它是唯一明确的共识的产物。节点总是能够找到最近的 commit 的和网络中一致的区块高度，然后从这个高度往后一个区块一个区块同步，依次运行区块中包含的所有交易并更新本地的状态，最终可以保证和网络中的状态达成一致。在这里，「区块」就是检测和达成状态一致的最小单元。而在数据库系统中，在崩溃发生后，系统会从其他节点同步最新的 WAL，并从上次 commit 的 WAL 的位置往后一个记录一个记录执行命令，直到所有记录运行完毕，这时数据库状态恢复到集群的当前状态。在这里，WAL 的记录是检测和达成一致的最小单元，所以我们称其为隐性的「区块」，没毛病。&lt;/p&gt;&lt;p&gt;在区块链的世界里，一笔交易需要被验证。这里的验证有两重含义：1) 身份验证 —— 交易是由其发起人正确签名的；2) 完整性验证 —— 交易对状态的变更是合法的。身份验证好理解，你用自己钱包的私钥签名给我转 1 个 ABT 的交易，系统会验证你的确是你；完整性验证则是指在 states db 里，你的账号下的确有超过 1 个 ABT 的 token，才能发起这个交易。在数据库的世界里，身份验证直接赤果果用诸如 RBAC（Role Based Access Control）的访问控制系统解决了，而完整性验证和区块链类似。&lt;/p&gt;&lt;p&gt;接下来我们看看确定性（deterministic）。所谓确定性，就是在同一个状态 Sn-1 下，大家拿着同样一笔交易，不依赖任何第三方信息独立执行，执行的结果完全一致。这一点仅就纯粹的从交易到 states db 的处理来说，区块链和数据库是完全一致的，大家都能保证确定性。然而，如果某个区块链要支持交易中携带额外信息，这些信息触发某些链上部署好的代码的执行（比如说，smart contract），那么，我们就得注意代码本身需要具备确定性。所谓确定性，无非是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;代码中不要使用不确定的随机数生成器 —— 比如使用计算机的时钟作为种子生成随机数，这就是不确定的。因为交易在被执行的那一刻，我们无法保证所有参与者的时钟是精确同步的。&lt;/li&gt;&lt;li&gt;代码避免使用多线程。多线程引发的 race condition 具有不确定性。&lt;/li&gt;&lt;li&gt;不要使用系统时钟。不解释。&lt;/li&gt;&lt;li&gt;不要使用未初始化的内存。鬼知道上面是陈冠希还是诸子百家。&lt;/li&gt;&lt;li&gt;不要使用浮点数 —— 这个很奇葩，因为不同的 CPU arch，编译器，甚至不同 CPU 型号间，由于支持的浮点数指令集不同，会导致结果不同。&lt;/li&gt;&lt;li&gt;不要使用编程语言的可能有随机行为的数据结构。比如遍历一个 map&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;基本上避免了这些，代码就具备了确定性，可以在区块链上执行。那么，为什么数据库中的存储过程可以允许没有确定性的代码的执行？比如，一个存储过程里可以使用当前时间插入一条记录？我们如果再回归本源，从「交易」的角度看待问题，可以发现，存储过程类似于 “off-chain” 执行的代码，它虽然植根于数据库之中，但其实是「交易」的源头，存储过程的执行产生真正的交易，也就是 WAL 记录，然后同步给其它节点。所以存储过程可以 non-deterministic，因为其产生的 WAL 记录已经是 deterministic 的 —— 添加一条带当前时间的记录这件事情，在 master 执行时，已经将取「当前时间」这个动作完成并得到一个确定的值，携带于 WAL 之中。这跟区块链的 smart contract 的概念有本质的区别，这也是为什么存储过程可以不必具备确定性，而 “on-chain” 执行的 smart contract 需要确定性。从这个角度来讲，数据库系统也是一个弱化的区块链系统。&lt;/p&gt;&lt;p&gt;既然区块链和数据库存储的对象都是数据，那么，提过了数据的完整性和确定性，接下来就是数据的一致性。区块链显然是最终一致性的典范 —— 网络越大，参与的节点越多，区块的扩散就越慢，任何时刻在不同的节点上读取状态就很大几率出现不一致的情况。然而，只要节点能同步到最新的区块，整个网络的状态是收敛的，最终大家能够得到一个一致的状态数据。其实，按照这个道理，所有使用 WAL，CQRS 思想的分布式系统，其数据的状态都是最终一致的 —— 这似乎和我们对经典数据库强一致性的印象不匹配。然而，如果我们把视角拉到数据库内部，可以发现，强一致性只不过是最终一致性之上添加了一些条件，是个特例。如果我们假定一个区块链满足下面的条件：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;任何节点收到新的区块，必须在交易执行完成，写入 states db 中之后，给矿工节点（其实就是当前的 master）发送确认&lt;/li&gt;&lt;li&gt;矿工节点在收到所有确认之后广播给网络中所有节点这个区块大家已经 commit 成功&lt;/li&gt;&lt;li&gt;在一个区块没有收到矿工节点的上述广播之前（写入完成之前），客户端发送来的查询进入队列排队（其实就是 read-write lock）&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;那么在外界看来，它也是强一致性。当然，第三点有些过于苛刻，一般的数据库实现都会采用 MVCC（Multiversion concurrency control），让每个 client 看到当前状态的一个 snapshot，因而存在一个很小的窗口，大家看到的数据是不一致的。如果较真，MVCC 不算强一致性，当然没人会这么认为。&lt;/p&gt;&lt;p&gt;通过上面的规则，数据库可以通过牺牲一些性能来打造对外而言的强一致性。但有时候，为了一些崇(wo)高(chuo)的理想，数据库系统也可以打破这些规则来号称更高的性能。mongdb 可以在 cluster 的环境下，写操作不需要节点确认即可返回，于是有了美其名曰的，如薛定谔的猫一般的「弱一致性」。&lt;/p&gt;&lt;p&gt;一个区块链网络理论上可以通过上述规则把自己营造成对外强一致性的感觉，但这实际上没有可操作性。能力越大，责任越大网络越大，延迟越大，所以，实际可操作的强一致性只能发生在节点数量很少，且节点都在同一个 data center 的环境下。从数据一致性的角度来说，数据库也是区块链在特殊场景下的一个特例。&lt;/p&gt;&lt;p&gt;最后说说性能。性能这事，和网络规模成反比。两个主要原因：1) 节点越多，达成共识的难度就越大。2) 节点越多，「交易」在网络中传播所需的时间就越长。那想要达到宇宙无敌的 TPS（Transactions Per Second） 怎么办？其实不难 —— 既然数据库是一个弱分布式环境下的特例，那么，咱就把区块链往数据库的方向退化就好。PoW 说「王侯将相，宁有种乎」，让全网参与铁王座的竞争，PoS 就让「一小部分人先富起来」，DPoS 再进一步，「让领导先走」，也许不久的将来，有人会则憋出终极大招，全网就一个九五之尊，把数据库里能用的招数，replicaSet（总还得 HA 一下嘛），Sharding 等等统统用上，再使用兵法中不战而屈人之兵之术：「今治水军八十万众，方与将军会猎于吴」…于是，可以名正言顺地抢下性能的桂冠。&lt;/p&gt;&lt;p&gt;只不过…就像非诚勿扰里车晓问葛优：那事儿，就那么有意思吗？&lt;/p&gt;</description>
<author>陈天</author>
<guid isPermaLink="false">2018-11-07-48821686</guid>
<pubDate>Wed, 07 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>使用 Tendermint 开发自己的链</title>
<link>https://henix.github.io/feeds/zhuanlan.prattle/2018-11-07-48821038.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/48821038&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f49d42ebdfbf142db1b350bd7fd1ba7e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;（这是 1024 节写的文章，时间线以 1024 前后为准）&lt;/p&gt;&lt;p&gt;前两周上线了我们为 Cybermiles 提供的 supernode，因为 Cybermiles 主网使用了 Tendermint，于是上周便研究了一下 Tendermint，边学边写了个 slides 介绍 Tendermint。&lt;/p&gt;&lt;p&gt;Tendermint 是一个脱胎于 PBFT 的 consensus engine，并在此之上构建了一个 Appliation BlockChain Interface (ABCI)，让 blockchain 的开发者可以关注于如何提供服务，以及维系服务的状态，而把如何达成共识，如何管理 mempool，如何进行安全的 p2p 通讯这样的琐事交给 Tendermint 来处理。Tendermint 自身是 golang 撰写的，其 ABCI 接口用 protobuf 实现，并使用 raw TCP 或者 http2 (gRPC) 和 application layer 通讯。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7a34bf6c6882df480118044dd4f282ba_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;910&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7a34bf6c6882df480118044dd4f282ba&quot; data-watermark-src=&quot;v2-2d5156ad3d668a756accafabefba34d6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;周日，闲来无事，想用 tendermint 做点东西。无奈 tendermint 没有提供 elixir 的 ABCI 实现，社区的 erlang 实现又缺失一些东西，且我很不喜欢 erlang 下用 Record 来描述 protobuf 的方式，于是用 Tony 的 protobuf 库，写了个 elixir 的 ABCI 实现，放在 github.com/arcblock/ex_abci 上，并随后实现了 Tendermint 自身提供的 counter example app - 用区块链的不可篡改性来维护一个全网唯一的计数器。&lt;/p&gt;&lt;p&gt;使用 ex_abci，counter app 的核心代码也就几十行，就是实现 info，check_tx，deliver_tx 几个接口即可：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ac8401876804a94f7ca99c97f9c3f8dc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1033&quot; data-rawheight=&quot;1015&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ac8401876804a94f7ca99c97f9c3f8dc&quot; data-watermark-src=&quot;v2-0b09e0d77e071c5a128b59966766fff0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这样的 app 当 hello world 还可以，用来验证 Tendermint 是否靠谱，本身并不靠谱。Tendermint 还提供了一个 kv store 的 example，也没有 get 到区块链的核心要素，于是我便萌生了搞一个足够简单，最好能在几百行内演示区块链技术的 Simple Chain。那什么算是区块链的核心要素呢，我觉得是这幅图 - Merkle Patricia Tree (MPT)：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8bd68bc480907702264be223b7be41d7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;763&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-8bd68bc480907702264be223b7be41d7&quot; data-watermark-src=&quot;v2-70b4756d4121554ffdb40baf1a9557eb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这是以太坊保存其 World State 的核心 - 我相信我的读者们了解 patricia tree (prefix tree, radix tree, 或者叫 trie)，有一些区块链知识的读者应该知道 merkle tree，MPT 结合二者，组织出一个自带验证的 persistent data structure（函数式编程语言保存 list / map 的方式），关于 MPT 和以及上图，我们的工程师丁沛灵同学在上次北京 Hackathon 有一个精彩的讲座，感兴趣的同学可以去 youtube arcblock channel 上找：ArcBlock’s Introduction to Blockchain，在 37 分钟附近开始讲 MPT，大约 10 分钟，非常之深入浅出。篇幅有限，我这里就不详细展开。&lt;/p&gt;&lt;p&gt;关于 Simple Chain，产品上我是这么考虑的：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;账号系统兼容以太坊&lt;/li&gt;&lt;li&gt;完整使用 Tendermint 的全部接口，并探索它们的意义&lt;/li&gt;&lt;li&gt;chain 的状态使用 MPT 保存，并将每个 block commit 后的 state root 提交给 Tendermint&lt;/li&gt;&lt;li&gt;chain 能够具有基本的容错 - 比如 tx 执行到一半，crash 了，可以恢复到上一个 block 的 state 继续往下执行&lt;/li&gt;&lt;li&gt;Transaction 使用简化版本的 Ethereum tx，一个 TX 只包含 from, to, nonce, total 和 pub key&lt;/li&gt;&lt;li&gt;MPT 里保存类似 Ethereum 的 account，每个 account 有自己的 balance，nonce 和 num_txs&lt;/li&gt;&lt;li&gt;client RPC 直接整合在 Wallet 模块里，方便演示&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;花了两天的功夫，一个粗糙的，未经过多节点测试的版本终于实现了，源码见：ex_abci/examples/simple_chain。我们谈谈其主要对外接口：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Wallet.new: 生成离线账号&lt;/li&gt;&lt;li&gt;Wallet.declare: 每个 Wallet 第一次可以让系统给自己打 10000 个 token，这个主要方便测试&lt;/li&gt;&lt;li&gt;Wallet.transfer：一个账户给另一个账户打钱。两方的 address 对应的 account 会在 chain 的 MPT 里更新，每个 block commit 之后，MPT root，也就是 app state 会写入 block header。&lt;/li&gt;&lt;li&gt;Wallet.info / Wallet.chain_info：访问 account 的信息 / chain 的信息&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;下面是运行时的整个过程。&lt;/p&gt;&lt;p&gt;初始化：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6b7bef4eaaab05d89ceee14925245b44_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;399&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6b7bef4eaaab05d89ceee14925245b44&quot; data-watermark-src=&quot;v2-958e75aa1074a94bafdb8c9b291f435a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Wallet 状态：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b3e684a14ebef8c4500a7f840c121872_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;425&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b3e684a14ebef8c4500a7f840c121872&quot; data-watermark-src=&quot;v2-eff42e9aba2e7b0cf43b5346c7eb5cdc&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;转账：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-452de83ffae5efe7552e8ccbe66730b5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;638&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-452de83ffae5efe7552e8ccbe66730b5&quot; data-watermark-src=&quot;v2-c5131ce9e0538611afdda9f9a3af4c77&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ef5828e115f07797008b3f08f4b635a7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1070&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ef5828e115f07797008b3f08f4b635a7&quot; data-watermark-src=&quot;v2-5190c6a0db69ba1e7a205943d3345456&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b70278b546420f6935120f614efd829a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;623&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b70278b546420f6935120f614efd829a&quot; data-watermark-src=&quot;v2-56354152c62f15c9b02cf24e82fc8359&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Tendermint block:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-93b2be74e5c2cab7d74ae49ab15e02b1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1022&quot; data-rawheight=&quot;642&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-93b2be74e5c2cab7d74ae49ab15e02b1&quot; data-watermark-src=&quot;v2-563feca3eb32540d3d1df202f20ac9bc&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;转账结束后的状态：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-52ea92306e747934f53b6bff70c43ee4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;715&quot; data-rawheight=&quot;112&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这个 Simple Chain 主要使用到的技术：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Tendermint 和 ex_abci，这是自然&lt;/li&gt;&lt;li&gt;Elixir 下的 MPT 实现：merkle_patricia_tree&lt;/li&gt;&lt;li&gt;Tony 的 protobuf 实现。我们在 MPT 里存储 account，其 value 也是用 protobuf 定义的&lt;/li&gt;&lt;li&gt;keccakf1600：ethereum 的 sha3 的实现，用来产生 account address 和各种需要 hash 的场合（注意，我们这里并没有使用 double hash）&lt;/li&gt;&lt;li&gt;libsecp256k1：ECDSA 的实现，主要用来生成 wallet，以及 transaction 的 sign 和 verify&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;目前代码量在 400 行内，基本上一目了然，用来理解 Tendermint 和区块链技术的基本逻辑再好不过。感兴趣的读者可以安装 tendermint，下载 &lt;a href=&quot;http://github.com/arcblock/ex_abci&quot;&gt;github.com/arcblock/ex_abci&lt;/a&gt; 尝试。&lt;/p&gt;</description>
<author>陈天</author>
<guid isPermaLink="false">2018-11-07-48821038</guid>
<pubDate>Wed, 07 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>是的，我们将开放大部分技术讲座</title>
<link>https://henix.github.io/feeds/zhuanlan.prattle/2018-09-26-45379581.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45379581&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f9dca8150a051a6f571b7e20cc45dac9_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;上周五我小规模尝试了一下把我们 ArcBlock 内部的技术讲座（BBL）和培训（bootcamp）分享给更广大的听众，反响很不错。为了满足更多读者参与类似的在线讲座，我们决定把这件事情做成一个系列：&lt;b&gt;ArcBlock Technical Learning Series&lt;/b&gt;，通过学习和分享，我们大家一起共同成长。本周，我们的工程师将会分享两个话题：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1. 美西周三晚 5:00 / 北京周四早 8:00：&lt;b&gt;Intro to Ethereum Smart Contract&lt;/b&gt;，由&lt;a href=&quot;https://www.zhihu.com/people/wangshijun/activities&quot;&gt;仕军&lt;/a&gt;同学出品。该讲座会对以太坊智能合约如何撰写以及其最佳实践进行介绍，目标是帮助你更好地进行智能合约的开发。受众需要有一定的区块链和以太坊的基础知识。仕军对以太坊和智能合约深有研究，之前还在掘金出版了一本介绍以太坊智能合约小册，大受欢迎。报名地址：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-889d55e2af0f6b9c654b959c6b33e2e9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;371&quot; data-rawheight=&quot;371&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-889d55e2af0f6b9c654b959c6b33e2e9&quot; data-watermark-src=&quot;v2-f214100a235978568553f61d73db70aa&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;2. 美西周四晚 4:40 / 北京周五早 7:40：&lt;b&gt;Data pipeline overview in AWS&lt;/b&gt;，由我们的美女数据工程师舒适出品。在这个讲座中，舒适将会系统性介绍 AWS 里进行数据处理和分析的各个服务，它们的应用场景，以及 ArcBlock 使用过程中的一些心得。受众需要对 AWS 有初步的了解，最好正在或者将要进行数据方面的工作。报名地址：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ff0bbee310ef7678d2c3b20bb6eb9c92_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;371&quot; data-rawheight=&quot;371&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ff0bbee310ef7678d2c3b20bb6eb9c92&quot; data-watermark-src=&quot;v2-de2e94046da9fd26a55b5a6bbd349eea&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;以上讲座名额有限（限 100 人），请考虑清楚后尽快报名。由于我们不收取任何费用，报名之后请务必参加，不要浪费别人的资源。多谢！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;国庆后我们会有更多精彩分享与您见面，包括（但不限于）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Intro to AWS Athena&lt;/li&gt;&lt;li&gt;Intro to AWS Kinesis&lt;/li&gt;&lt;li&gt;Intro to Growth Hack&lt;/li&gt;&lt;li&gt;CQRS and commanded&lt;/li&gt;&lt;li&gt;Design thinking&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;敬请期待！&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Q: 为什么讲座时间这么奇葩？&lt;/p&gt;&lt;p&gt;A: 因为我们在西雅图和北京都有工程团队，需要在两边的时间上找一个平衡点。&lt;/p&gt;&lt;p&gt;Q: 我需要用什么软件参加讲座？&lt;/p&gt;&lt;p&gt;A: 报名后会有链接，你可以按照提示下载 zoom。Zoom 是一款很赞的第三方视频会议软件（创始人是个华人），我们很喜欢。&lt;/p&gt;&lt;p&gt;Q: 讲座过程中我可以问问题么？&lt;/p&gt;&lt;p&gt;A: 我们目前只允许 ArcBlock 的工程师语音提问，毕竟我们先要为自己团队负责；外部参与者可以文字提问，讲座结束前的 QA 环节，主讲人会根据时间选择回答。&lt;/p&gt;&lt;p&gt;Q: 讲座用什么语言？&lt;/p&gt;&lt;p&gt;A: 如无特殊情况，讲座均用中文。讲座所用的 slides 一般为英文。&lt;/p&gt;&lt;p&gt;Q: 如果一个讲座我很想听，但时间上不合适，错过了怎么办？&lt;/p&gt;&lt;p&gt;A: 讲座结束后，视频将会同步到 ArcBlock 的 youtube channel 和 腾讯视频（ArcBlock 公众号会发布）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;预祝大家国庆快乐！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>陈天</author>
<guid isPermaLink="false">2018-09-26-45379581</guid>
<pubDate>Wed, 26 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>ArcBlock 北京黑客松，你来不来？</title>
<link>https://henix.github.io/feeds/zhuanlan.prattle/2018-09-10-44203357.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/44203357&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-adfcf9a4e3215203c43ba0147fd10eba_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;Hackathon，黑客马拉松，或者黑客松，是程序员们喜闻乐见的一种愉悦心情，开阔眼界，碰撞灵感的活动 —— 一群人，在一段特定的时间内，相聚在一起，通力合作，针对某个主题，编写点有意思的程序，应用，或者产品。根据 wikipedia 的记载，hackathon 起源于 OpenBSD 的一次密码学活动：「OpenBSD 于 1999 年 6 月 4 日在卡尔加里举办的一次密码学开发活动上第一次使用了该术语。在那次活动中，10 名程序员相聚到一起商讨如何避免由美国密码学软件出口规定引起的合法性问题」。在那之后，hackathon 遍地开花，有程序员的地方，便少不了由 pizza，软饮，噼里啪啦的键盘敲击声，角落里间或传来的欢呼声交织成的 hackathon。&lt;/p&gt;&lt;p&gt;就像小孩子们在游乐场放飞自我一样，程序员在 hackathon 的世界里尽情挥洒汗水，探寻个人能耐的边界。工作上的苦楚，生活中的琐事，朋友圈里的焦虑，在这一刻都不复存在。沉浸于其中的每个人，眼睛盯着屏幕，双手飞快地，铿锵有力地在键盘上敲击，仿佛在演奏悠扬轻快的卡农，又仿佛《通缉令》里织布机上辛勤劳作的梭子，永不停歇地谱写下一个「上帝密码」。&lt;/p&gt;&lt;p&gt;对 ArcBlock 来说，让区块链技术的开发和应用变得越来越友好是我们的使命。我们正在打造一系列的工具来达成这个使命。Open Chain Access Protocol，或者说 OCAP，是我们打造的第一个核心服务。我们读取公链上的数据，将 blocks / transactions / accounts 等信息索引出来，构建了一个基于 Aurora 的 Postgres Cluster，方便对数据进行 OLAP；以及基于 Parquet 格式的文件集，存储于 S3 之上，方便离线分析。在这些数据的基础上，我们搭建了一套基于 GraphQL 的 API 服务，对外提供数据的访问。整个 API 系统的结构如下：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c570f71be2a148527a85a388fec44aa0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;632&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c570f71be2a148527a85a388fec44aa0&quot; data-watermark-src=&quot;v2-f42842dca9c9ce680adc90c57825905a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;API 服务的最大问题是不够直观，因而我们围绕着 OCAP API 提供了前端的 playground，方便大家实验和探索；当你在探索的过程中有了些许灵感，迫不及待想要做点什么的时候，我们提供了 javascript / nodejs / iOS / android 的 SDK，方便大家将灵感快速 MVP 化 —— 甚至，我们还贴心地为前端的同学提供了 react / vue 的 starter projects，一键带你飞上云端。下面是我们两周前在 Bellevue 举办的 hackathon 的一个作品，直接基于我们的 react starter project 和我们提供的 GraphQL subscription 功能：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9dafec0e10ce9f71c37a83bad38de221_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;1200&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9dafec0e10ce9f71c37a83bad38de221&quot; data-watermark-src=&quot;v2-1d438deed195ffe19f15cbc2f1d73809&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;讲到这里，我相信有些同学会问，为什么我们要采用 GraphQL 作为 API layer？&lt;/p&gt;&lt;p&gt;GraphQL 自 facebook 在 2016 年推出以来，并未大红大紫，究其原因，还是后端实现起来有些复杂，和工程师已有的知识体系（以及运维体系）有所冲突。我在两年前的文章：&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;amp;mid=2649827506&amp;amp;idx=1&amp;amp;sn=7eb23c6b15806382d6fdca5729bd7916&amp;amp;chksm=8704aaaeb07323b86b5bbd2f855cf1b3ccaef0e3d4fde8f6c7aebd5e4da9f9ceb3edb8ff542c&amp;amp;scene=21#wechat_redirect&quot;&gt;GraphQL，你准备好了么&lt;/a&gt; 有过一些分析。ArcBlock 之所以采用 GraphQL，是因为我们觉得它的思想 —— 减轻客户端的学习成本和使用成本，很契合 ArcBlock 的让 blockchain app 开发变得简单便利的使命。我们不但在 OCAP API 上采用 GraphQL，我们几乎 all in GraphQL —— 所有对外（或者未来可能对外）的 API，我们都采用 GraphQL。为此，我们打造了一套叫 Goldorin 的工具（尚未开源），来减轻 GraphQL 的开发难度。工程师只需要撰写 yaml 格式的 API 描述文档，Goldorin 会生成 Absinthe，Ecto 等相关的代码，最后工程师只需要在生成的 resolver 里面做完形填空，填写如何 resolve 各个 field 的函数即可。通过 Goldorin，GraphQL notation / schema 等一系列繁琐的事情都被工具完成，开发的难度被大大降低。不仅如此，最近我们还在思考：如何构建一个内部的服务，让前端的同学只需要提交 yaml，描述好她希望使用的 API，后端自动生成并部署 stub API，提供&lt;b&gt;理性&lt;/b&gt;的 stub data，供前端调用。这样，前端就不需要巴巴等着后端提供支持，才能完成下一步的工作。&lt;/p&gt;&lt;p&gt;还有同学会问：为什么你们的后端架构在 elixir 之上？&lt;/p&gt;&lt;p&gt;上周在 Bellevue 举办 Elixir US 2018 conference，ArcBlock 是赞助商之一。我在站台的时候，也有很多人问我这个问题。技术是为产品服务的。如果你看上图 OCAP API 的架构，不难发现，里面有很多 micro service 的点。而 elixir 的基石 —— erlang/OTP，天然就是 micro service 的完美诠释 —— 每个 gen_server，都可以被视作一个 micro service。不仅如此，它还完整支持了使用 micro service 不得不做的很多固有仪式：比如说服务注册和发现（Registry），监控（link / monitor），自我治愈（supervision tree），集群管理（distributed erlang）等等。所以其他软件架构做起来复杂，憋半天才憋出一个 NB 的解决方案的事情，在 elixir 下，自然得仿佛在做新手上路的练习。比如 OCAP API 里面提供的实时币价 price_in_usd，它的 resolver 就是一个 gen_server 而已。&lt;/p&gt;&lt;p&gt;此外，elixir 可能有 nodejs（apollo）外最成熟（最漂亮）的 GraphQL 实现。借助 Absinthe + Phoenix，我们可以轻松实现复杂的 subscription API，并且，运行在一个若干台机器组成的 cluster 里面。跨机器的不依赖第三方（比如 redis / kafka）的分布式 subscription 方案，可能仅有 elixir 的方案可以放心部署在 production，并 scale out 到数十台机器。需要支持规模更大的用户时，现有的 elixir 的 Phoenix pub/sub 方案又很容易集成第三方的工具 —— 所谓可箩可御，不过如此。&lt;/p&gt;&lt;p&gt;扯远了。回到 hackathon。&lt;/p&gt;&lt;p&gt;我们充分理解参加一次 hackathon，你所付出的宝贵的时间成本 —— 毕竟，匀出一整天宝贵的周六，不陪孩子玩耍，不陪老婆（老公）逛街（打游戏），花上据说又在「杀死」一千万北京青年的，不知道有多久的通勤时间，来参加一场 blockchain 这样一个相对陌生的领域的 hackathon，如果得不到些什么，似乎说不过去。所以我们提供了一些小礼物和小奖品（当然我相信你不太会冲着这个而来），以及精心准备了两场 talk。第一场会深入浅出介绍 bitcoin / ethereum，以及他们技术实现上的特点和亮点；第二场会介绍 ArcBlock 的技术栈，技术选型，OCAP API 的架构，以及如何使用 OCAP SDK 构建应用。我们希望通过这两场讲座，把我们 ArcBlock 对 blockchain tech 的认知，毫无保留地分享给大家。当然，讲座以外的时间，我们也会为大家解答币价以外的，任何有关 ArcBlock / bitcoin / ethereum 的问题；同时，当你在 hack 的过程中，出现的任何技术问题，我和我们的技术团队，也会第一时间和你探讨和处理。&lt;/p&gt;&lt;p&gt;为了保证参与质量，此次 hackathon，在注册时我们会收取 50 元的门票，然后现场签到者我们即时微信转账返还全额门票。这是吸取了我们第二次在 Bellevue 举办 hackathon 的教训 —— eventbrite 上注册了太多人，使得我们担心活动场地无法容纳全部参与者，于是提前结束了注册，结果活动当天 80% 的参与者都没有出现，白白浪费场地资源和别人的机会。&lt;/p&gt;&lt;p&gt;下面是活动详情：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;时间：9/15 周六 9:30am - 7:00pm&lt;/li&gt;&lt;li&gt;地址：优客工场（酒仙桥），北京市酒仙桥路兆维工业园C3号楼2层（地铁 14 号线&lt;b&gt;将台站&lt;/b&gt;附近）&lt;/li&gt;&lt;li&gt;报名链接：扫下面的小程序码直达（也可点击「阅读原文」，或者&lt;b&gt;在 huodongxing.com 里搜索 arcblock&lt;/b&gt;，然后在相应活动下点击「我要报名」）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9029f43d942b2a7733e692aa50c0682d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;280&quot; data-rawheight=&quot;280&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9029f43d942b2a7733e692aa50c0682d&quot; data-watermark-src=&quot;v2-35ea538d335f49ca500198c84d4d0266&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;也许，这样一场 hackathon，能够小小抚慰你那颗被 996 磨去锋芒的，但依旧不安分的心？&lt;/p&gt;&lt;p&gt;也许，这样一场以码会友的活动，能够帮你找到自己事业上的「虚竹」和「段誉」？&lt;/p&gt;&lt;p&gt;也许，太多的也许。也许冥冥中，这就是亚马逊河边煽动翅膀的蝴蝶？&lt;/p&gt;&lt;p&gt;我们诚挚地欢迎你的到来！目前尚余十多个名额，报完即止！&lt;/p&gt;</description>
<author>陈天</author>
<guid isPermaLink="false">2018-09-10-44203357</guid>
<pubDate>Mon, 10 Sep 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>银河系跳槽指南</title>
<link>https://henix.github.io/feeds/zhuanlan.prattle/2018-07-19-40093644.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40093644&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1eca2fafc57316cda3d51bd868d7f2b9_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;这颗行星上存在着 —— 或者说曾经存在 —— 一个问题，那就是：大部分的居民在大部分的时间里都感到不开心。针对这一问题曾提出过各种各样的解决方案，但其中大部分都是紧紧围绕那些绿色小纸片的运动来着手的 —— 这很奇怪，因为实际上并不是这些绿色小纸片不开心。- 《银河系漫游指南》&lt;br&gt;&lt;br&gt;我见过五年换过八份工作的人，也见过对自己没有稳定定位，在几个方向上来回飘的人。我还见过履历倒着来的人 —— 在硅谷，见得多的是 Google - FB - Airbnb 的职业切换，我却见过 FB - Google - MS 的切换（没有贬低 MS 的意思）。这种没有想清楚，仅仅因为 package 一时之高低就随意跳槽，是程序员们的《伤仲永》。 - &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;amp;mid=2649827812&amp;amp;idx=1&amp;amp;sn=8b2389d4c7221cb439ab0e705dd6e8e9&amp;amp;chksm=8704abf8b07322eee8aecb3bd6ad6f71f2673072feb0ed5b6f2f2fee97f0b0d11411526cc8ef&amp;amp;scene=21#wechat_redirect&quot;&gt;《程序员的好日子什么时候才到头》&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;这几天跟朋友聊的很多的一个话题是跳槽。马老师说员工离职的原因林林总总，只有两点最真实：1. 钱，没给到位；2. 心，委屈了。两个理由合二为一，就是干得不爽。如果把员工跳槽的动机归根于这个，有些过于简单粗暴。干得挺爽还主动拍屁股走人的，也大有人在，毕竟还有更大的世界可以追求。&lt;/p&gt;&lt;p&gt;那么问题来了，打算拍屁股走人的时候，走去哪里？敢问路在何方？&lt;/p&gt;&lt;p&gt;在 Fidelity 里上过 401k 的同学们会有这样的经验：系统会让你选择一个风险承受的系数，然后根据这个承受能力，来调整整个仓位中股票，基金和债券的比例。对我来说，如果把股票看做是 Arcblock，那么基金就是 Tubi，而债券是 Juniper；当然，在你的眼里，股票可能是 nextdoor，基金是 Airbnb，而债券是 Facebook。每个人可以有自己不同的坐标系，这不是重点。重点是你需要知道你自己的风险系数 —— 这是跳槽时向左走向右走的决定因素，否则，就像错配的婚姻，强扭的瓜。&lt;/p&gt;&lt;p&gt;风险系数的计算有时候没有那么精确，但大体上，跟两件事相关。&lt;/p&gt;&lt;p&gt;一是是否年轻。年轻时一片丹心，无所畏惧，可承受的风险大些，年迈时历经磨难，满心苦涩，可承受的风险自然小些。我说年轻而不是年龄，是因为年轻这东西，主要看心态，未必和年龄相关。有些人二十岁活出了四十岁的沉稳，有些人，奔四了比二哈还要傻白甜。&lt;/p&gt;&lt;p&gt;二是有多少东西需要交代。悬而未决的身份，让人叹息的房贷（房租），嗷嗷待哺的婴孩，年事已高的父母等等，这些都是交代 —— 对自己，对家人，对长辈的交代。要交代的东西多了，转角遇见的，都是掣肘，都是生命不能承受之轻，自己就像「被放在草篮里顺水漂着的江流儿」（管氏翅吧撸串时一个咬牙买了西城区学区房把下半身交给银行的朋友红着眼睛说的），承受不起太大的风浪。&lt;/p&gt;&lt;p&gt;精心算计好了自己的风险系数，或者说可以接受的槽位，下一步是认清市场和大的方向。雷军说要顺势而为，这个「势」很重要。那怎么看「势」在何方？每年互联网女皇 Mary Meeker 的 internet trends report 是个很重要的工具，要读，仔细读，然后混入自己的思考和判断。report 里面重点提到的行业要额外花些时间去了解。当然，女皇不是上帝，每年的 report 也不可能面面俱到，还是有不少遗漏（比如今年的 report 竟然没有提 blockchain 及其背后的 token economy，中国的篇幅较去年缩水，印度只字未提）所以用它看全局可以，具体某个方向还需要更多的资料去佐证。&lt;/p&gt;&lt;p&gt;当你算好自己的风险系数，又对市场方向有个自己的判断，可以往下对号入座了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;股票 —— 创业公司&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;风险承受能力强，可以入这个槽位的，看中的是潜力，或者说可兑付的未来。潜力这东西很是玄妙，就像抖音视频里的美女，不相处到天黑卸妆时，你很难窥得真容。然而通过这种方式试错，要命。我打这个比方，大家会乐，心想：SB，老子肯定先看身份证啦。然而到自己找工作时，却连最基本的求证都不做。我一个读者前一阵加入一家区块链初创公司，喜滋滋后台跟我报道，说以后是同行了。我问：&lt;/p&gt;&lt;blockquote&gt;创始人 / CEO / CTO 你认识么？&lt;b&gt;不认识。&lt;/b&gt;&lt;br&gt;他们之前做过啥？&lt;b&gt;bla bla bla（很粗浅的认识）&lt;/b&gt;&lt;br&gt;他们为啥要做这个项目？&lt;b&gt;呃。。。区块链很火，很多机会&lt;/b&gt;&lt;br&gt;现在产品和服务都做到哪个地步了？&lt;b&gt;刚起步，还在搭团队&lt;/b&gt;&lt;br&gt;那产品的 roadmap 是啥？&lt;b&gt;呃。。。我没问。反正是 blockchain 3.0&lt;/b&gt;&lt;br&gt;怎么获取用户？&lt;b&gt;那啥，做好了自然有人用吧。他们市场宣传力度挺大的&lt;/b&gt;&lt;br&gt;白皮书写的怎样？有具体跟创始人 / 团队聊白皮书里你的疑惑么？&lt;b&gt;呃。。。白皮书我还没看完，所以还没啥问题&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;问到这里，我已经无话可说了。选股还讲究看看财报，研究基本面啥的，这啥都不知道，啥都不去主动了解，就跟非诚勿扰上节目上看了几个视频就去牵手的女嘉宾，这心多大，胆儿多肥？人家非诚勿扰那是作秀给咱们看，赚的是 dollar；咱们自己何必要拿自己的光阴下注，赌渺茫的未来？&lt;/p&gt;&lt;p&gt;所以去创业公司要尽可能多的了解标的公司的文化，产品，团队，然后了解同行各个公司的文化，产品，团队，对比，多方求证，最好实地考察一下，收集尽可能多的一手资料，然后在 spreadsheet 里做个 SWOT analysis 组织和分析你收集到的信息：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1cfc1a9b610918cf2314ce7ba645dc0a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;575&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1cfc1a9b610918cf2314ce7ba645dc0a&quot; data-watermark-src=&quot;v2-51c816236074f4dfcf818b629e7e61c2&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;(图片来源：wordstream， Small Business)&lt;/p&gt;&lt;p&gt;Bad code smells。同样的，bad team smells。包装再好的项目，放大镜下总有败絮露出。当你把优(S)劣(W)危(T)机(O)分析清楚后，你也有了最终的目标 —— 也许一番分析之下，本来你情定 A，却牵上了 B。这结果并不重要，重要的是要有这个分析的过程 —— 你把自己的未来紧紧攥在自己手中，而不是交由轮盘赌。&lt;/p&gt;&lt;p&gt;选创业公司是三分看势，三分看人，三分看命。选对了赛道，挑对了人，做足了努力，并不意味着可以全身而退 —— 也许命运还要捉弄你一下，就像取经成功的师徒四人还要被踢下云端再渡一劫。如果是这样，也就认了，毕竟这是风险最大，（成功后）收益也最大的一种选择。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;基金 —— 增长型公司&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;落入这个槽位的，一般是想稳妥些，又厌恶成熟期公司的一成不变的人。增长型公司的范围很广，可以从有稳定收入不差钱的 startup，到 Pre-IPO 的公司，再到 IPO 后潜力还未完全兑付的公司。&lt;/p&gt;&lt;p&gt;选这个范畴下的公司，如果已经有标的，angelList，crunchbase 都是你的好助手。看看公司一轮轮融资的情况，创始人和管理层的 linkedIn，公司的官网 —— 如果是 2C 的产品，下载使用，亲身体验；如果是 2B 的产品，能体验最好，不能体验，看看都有哪些公司在用，找身边已经使用该产品的用户，听他们的意见。查询各种公开的（比如 app store 的排名），非公开的数据，把自己当成一个没啥资源又要勉力尽调的小 VC 里的苦逼投资经理，想办法获取更多的资讯。&lt;/p&gt;&lt;p&gt;如果没有标的，那么最简单的方法，女皇的 report 里面提过的公司，一般差不到哪去，挑一个或者几个出来慢慢甄选。比如 2017 年花了些篇幅介绍的 Stitch Fix，年底就敲钟去了。今年 report 里 C 位乱入的唯一一家 blockchain 公司 coinbase（嘀嗒嘀嗒安姐新东家），report 里提到两三次的 intercom，nextdoor，提到一次的安全公司 signifyd 等，也许都可以是深入研究的标的。不要动不动跳槽就冲着 airbnb，uber，netflix 这些大路货的名字，在增长型公司里，有的是潜力比他们高，空缺也许比他们更好的公司。对于国内的同学来说，可能麻烦一些 —— 虽然 report 里高瓴资本写了些中国的公司，但毕竟给老美看的，翻来覆去也就是 BAT 新美大，头条快手这些，要挖掘国内 B 轮往上，有稳定收入且运作良好，重视 R&amp;amp;D 的公司，还是要花一番心血的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;债券 —— 成熟期公司&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这个不说了，就几家值得去的，而且大家挤破脑袋。没混出来之前，去了也就做做螺丝钉，其实没啥意思，适合养生。有一点注意的：除非你热爱政治斗争，千万千万避开那些名扬四海的，内部充满山头，内斗不止的大公司。&lt;/p&gt;&lt;p&gt;另外，不管你是否欣赏，我建议你都好好研究一下 Amazon。它其实不该算在债券型的成熟期公司里，更应该放在增长型公司 —— 但加入 amazon 对小的个体而言（除了财务回报外）没有太大的成长。Amazon 之所以需要重点研究，是因为它的效率，它对 R&amp;amp;D 近乎疯狂的投入（45% YoY），以及它高市盈率和低得令人发指的融资成本，是横亘在你辛辛苦苦挑选出来的赛道上的一个可能无解的拦路虎。Google / FB 等几乎有自己明确的赛道，而 Amazon 的赛道是飘忽的，不断膨胀的 —— 丫的胃口跟吃了 elixir 的 pacman 一样，不吃光一切糖豆，不会干休；而华尔街却很买这个「不会赚钱」的公司的帐 —— 最近这货仅仅宣布了 &lt;b&gt;考虑&lt;/b&gt; 未来十八个月要对外销售自己的交换机，就让思科的市值蒸发了近百亿。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;禅定时刻&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;Don’t panic&lt;br&gt;&lt;br&gt;银河系每一个主要文明的历史都会经历三个可以清晰辨识的阶段，即生存、质疑和诡辩，或者也被称为如何、为何以及向何处去三阶段。比如，第一个阶段的特征是这样的问题：我们如何才能跳槽？第二个阶段则是：我们为何要跳槽？第三个阶段就变成了：我们该跳往何处呢？&lt;/blockquote&gt;&lt;p&gt;风险承受系数高的同学，我给你们一道送分题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;ArcBlock - 区块链方向，北京爱上西雅图，两头都在大力招人 - 戳这里 &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;amp;mid=2649827999&amp;amp;idx=1&amp;amp;sn=5374d71f1baa677ffe6805d36fac2af0&amp;amp;chksm=8704a883b07321953c6e713bb86a08ca546a18f661522bbbf89a8832fbdb897f82babdc7a11e&amp;amp;scene=21#wechat_redirect&quot;&gt;欢迎来到区块链的世界&lt;/a&gt;，想清楚了我们私聊，北京办公地点在优客工场酒仙桥 :)&lt;/li&gt;&lt;li&gt;Service Wall - 互联网安全领域，硅谷人在北京，戳这里 &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;amp;mid=2649827979&amp;amp;idx=1&amp;amp;sn=9b9aa25cb3d9e7a80f1fd98fe8dfc1b8&amp;amp;chksm=8704a897b0732181821bbaf5a5c4669c39c36cf62f2d1b3ac31cc3ca15a3401aca3236a254ee&amp;amp;scene=21#wechat_redirect&quot;&gt;Servicewall 在北京招人啦&lt;/a&gt;，我靠谱前老板 Shalang 在望京 SOHO 恭候您的邮件。&lt;/li&gt;&lt;li&gt;Tubi - Video Stream  新贵，我老东家。戳这里：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;amp;mid=2649827851&amp;amp;idx=1&amp;amp;sn=02640a0616743e2a65a04c63e3b6b1fb&amp;amp;chksm=8704a817b07321016accf1034bd7751985e5fa0c02074f0f12f130323bc44ac9f27f03bb7307#rd&quot;&gt;快来围观别人家的公司&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;</description>
<author>陈天</author>
<guid isPermaLink="false">2018-07-19-40093644</guid>
<pubDate>Thu, 19 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何提高代码质量？</title>
<link>https://henix.github.io/feeds/zhuanlan.prattle/2018-07-09-39305285.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/39305285&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d55296c96c0b0d33ad2dc3fb08d5a790_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;好的程序员从来不靠格子衫或者颜值吃饭，就像你家 C 罗明明可以靠脸，却非要用不断精进的身体和技术迷倒你。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9b637e61450e3f857b9c99aa945410df_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;544&quot; data-rawheight=&quot;390&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9b637e61450e3f857b9c99aa945410df&quot; data-watermark-src=&quot;v2-3dcd8bca88d091467194b8e74c9f76b2&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;对伟大前锋来说，进球，以及一个能够迸发出进球能力的身体非常重要。&lt;/p&gt;&lt;p&gt;对靠谱程序员来说，代码质量，以及一颗能够洞悉高质量软件编写之道的大脑弥足珍贵。&lt;/p&gt;&lt;p&gt;本文从 &lt;b&gt;产品&lt;/b&gt;，&lt;b&gt;接口&lt;/b&gt;，&lt;b&gt;指标&lt;/b&gt;，&lt;b&gt;日志&lt;/b&gt;，&lt;b&gt;代码清晰度&lt;/b&gt;，&lt;b&gt;代码复杂度&lt;/b&gt; 等方面，谈谈如何提高代码质量。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;产品和接口&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;好的产品经理未必是个好的程序员，但好的程序员一定是个好的产品经理。&lt;/p&gt;&lt;p&gt;产品经理的工作是什么？是把复杂的逻辑用清晰的，易用的方式（接口）展现给用户。&lt;/p&gt;&lt;p&gt;程序员的产品是代码，代码的用户是其它程序员 —— 所以高质量的代码是让别的程序员容易理解，容易使用的代码。注意，这个层次的容易理解，是指结构，原理和接口上容易理解，而并非代码的细节容易理解。&lt;/p&gt;&lt;p&gt;细节在产品这个层次，一定要隐藏起来。用户在打开浏览器，访问 arcblock.io 的时候，并不需要关心 DNS 是怎么工作的，PKI 体系是怎么运作的，HTTP / TLS / TCP / IP 协议是什么，报文是怎么从 user space 交付到 kernel space，再怎么 DMA 到网口发送出去 —— 这还没完，接下来出场的，还有负责 l2 protocol 的 switch，保护你安全的 firewall，邮递员 router，以及明明概念上是网络技术，却整个青春都错付给了安全的 NAT。。。&lt;/p&gt;&lt;p&gt;如果产品经理做的产品展示给用户是这样巴拉巴拉的细节，那么丫一定会被扯烂暂住证，大耳光从天黑抽到天亮，然后早班绿皮车送到清河去挖沙；如果程序员的 &lt;code class=&quot;inline&quot;&gt;main()&lt;/code&gt; 如此啰嗦，不管人家受得了受不了，那么他这辈子笃定找不到同性朋友，更别说异性了。&lt;/p&gt;&lt;p&gt;所以程序员在写代码之前，先要想想如果这是一篇演讲稿，我该如何说起？我能在三五分钟讲清楚这代码要干什么？有没有生活中或者同行会心一笑立刻 get 到的例子可以类比？&lt;/p&gt;&lt;p&gt;90% 以上的情况，程序员是在写 parser。换句话说，我们写的绝大部分代码就是把一系列的输入，经过若干转换（transformation），变成一系列输出。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2abd79f6808d645afa3609a65e81545d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;206&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2abd79f6808d645afa3609a65e81545d&quot; data-watermark-src=&quot;v2-04626f8ed74d81f8e040ad4182090210&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;举些具体的例子。&lt;/p&gt;&lt;p&gt;前端工程师是把用户的 url 请求，parse 成浏览器 DOM 上的一系列 component，把用户的行为，parse 成某种内部的事件 &lt;code class=&quot;inline&quot;&gt;{event_type, event_data}&lt;/code&gt;，并且进一步由 &lt;code class=&quot;inline&quot;&gt;event_type&lt;/code&gt; parse 成某个 &lt;code class=&quot;inline&quot;&gt;event_handler&lt;/code&gt; —— 然后这个 handler 继续 parse &lt;code class=&quot;inline&quot;&gt;event_data&lt;/code&gt;，直到其转化成新的 DOM，或者对后端的某个 API 的某个请求。&lt;/p&gt;&lt;p&gt;对于 API 来说，它 parse request，生成 response。request 可能被 parse 成一个 sql，交付给 database；也可能被 parse 成满足另一个服务接口的 request（比如 grpc），交给另一个服务。这样周而复始，直到 API 收集完七颗龙珠召唤神龙各个服务的所有数据，再 parse 成一个合规的 response，交还给 client。&lt;/p&gt;&lt;p&gt;所以程序员看待自己的代码产品，要像庖丁看待肥牛一样 ——「未见全牛」，「神遇而不以目视」，「以无厚入有间」—— 满眼望去，就是一个个 parser，大的 parser 挂小的 parser，再挂更小的 parser。每层，甚至每个 parser，都是个 pipeline —— 它们一般由 validator，serializer，transformer 等接口组织起来，辅以各种 builder，decorator，factory，commander，再加上为之而生的 tools，utility，helper 等搭建而成。&lt;/p&gt;&lt;p&gt;这样一层层组织下来，该粗的地方粗，该细的地方细，遇人说人话，遇猿说猿语，代码可伶可俐，可萝可御。&lt;/p&gt;&lt;p&gt;接下来，是很重要却最让人挠头的事情，给你的大大小小的模块 &lt;b&gt;取名&lt;/b&gt;。名字倾注着感情，就像寒夜里小女孩划下的火柴，酣战一宿的圣盔谷外甘道夫挥起的魔杖，给人以光明，温暖，希望，以及读到时触电般的「我懂你」。&lt;/p&gt;&lt;p&gt;肖申克的救赎里有段，午餐时 Andy 问大伙那个前夜里被打死的可怜的胖子叫什么？大伙一脸懵逼，说我 TM 为什么要关心一个死胖子的名字。这一幕看着很痛，就像华安在成为华安之前，只有一个如蝼蚁般微渺的代号。如果你想让你的代码不是一个让人漠视的死胖子，而是人们愿意谈论，那么，取个容易让人理解，甚至让人刻骨铭心的名字吧。&lt;/p&gt;&lt;p&gt;不好的名字除了让人不解，漠视，甚至宛如与人世间幽隔的恶鬼，望上一眼，大家便想逃离；好的名字，嗯，随便说一个，聂小倩，同样是与人世间幽隔的孤鬼，你我却念念不忘。&lt;/p&gt;&lt;p&gt;在 Juniper，我最忘不了的两台服务器是 gretel 和 hansel，取自格林童话；在途客圈，让我心心念之的项目是 atlantis 和以及其上 viking (code name) —— 这不难理解，要追寻 atlantis，你需要远征 (viking）；在 tubi，cms service 是个糟糕的取名，merlin 算是回归了正途，虽然作为一个 build service，它的魔力并不太强，还时不时失灵；而在 arcblock，我在上篇文章里谈到的 AADL，被正式取名 AODL —— 这不重要，估计你也记不住，不过，她有了一个对外的名字：goldorin —— 托尔金为中土大陆精灵族发明的精灵语。&lt;/p&gt;&lt;p&gt;在 &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;amp;mid=2649827483&amp;amp;idx=1&amp;amp;sn=228be8c6c3448a56f7ecd00e20e3ae1d&amp;amp;chksm=8704aa87b0732391ceca19893103f58f7aa360c815faec08a334daddbff74a62b4db724125b7&amp;amp;scene=21#wechat_redirect&quot;&gt;代码命名：僧敲月下门&lt;/a&gt; 那篇文章里，我提到晦涩的 IKE 代码里 pitcher / catcher 让协议的 negotiation 读来犹如欣赏棒球比赛。好的名字，和好的接口几乎成对出现，它让程序员的产品 —— 代码，变得鲜活，读来如沐春风，如饮醇酒，如赏佳人。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;指标和日志&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;好的产品是在改进中不断提升的，就像凤凰，经历烈火不断煎熬，得以涅槃。而要想改进，离不来测量 (measure)，它是构建 (build) 和学习改进 (learn) 中间最重要的一环。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-604bf4b4226f180ff45fa8bce5874793_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1350&quot; data-rawheight=&quot;848&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-604bf4b4226f180ff45fa8bce5874793&quot; data-watermark-src=&quot;v2-bc52c265bf285c8cf9f86e4e151adc2c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;热力学第二定律是最让人讨厌也最让人无奈的定律。它直接导致了「不运动肚子上的赘肉必然增加」，「不收拾房子房子会越来越乱」，「不持续改进代码，代码的质量会越来越低」这些让人烦心的事情。&lt;/p&gt;&lt;p&gt;而这个破定律的祖师爷 Lord Kelvin 说：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-444ceb2f17abc8ed81a7db60ea72fdbf_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;638&quot; data-rawheight=&quot;479&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-444ceb2f17abc8ed81a7db60ea72fdbf&quot; data-watermark-src=&quot;v2-07126afd094d0bcd96f751cc3f78fd32&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;嗯，测量很重要，非常重要。如果构建和改进是两根枝杈，测量就像蜘蛛在两者间挂下的网，这网越密，两根树枝间的路就越多，就越容易从一端走到另一端，循环往复。&lt;/p&gt;&lt;p&gt;对于测量的途径主要是指标 - metrics 和日志 - logs。metrics 像是心电图或者 CT，让身体的状况一览无余。所以 metrics 用来了解现状，指明方向；logs 则是细密的日记，什么都有，唯独没重点，所以常常在现状和问题的方向确定后，用来归因。比如说 CT 报告说，这周和上周相比，肝不那么好了，需要小心肝。那么肝为什么不好？把一周的日志调出来一看，哎呀，夜夜酒吧里纵情于世界杯，难怪。于是得出改进方案：世界杯结束后，别又喝酒又熬夜又赌球这病就好了，没事。&lt;/p&gt;&lt;p&gt;metrics 和 logs 大部分时候是给自己和别的程序员看的，所以从上文的角度看，它也是个产品，符合产品和接口定义的一切准则。&lt;/p&gt;&lt;p&gt;先说 metrics。&lt;/p&gt;&lt;p&gt;定义 metrics 的时候，你要先搞明白你要改进些什么，这是所谓的 begin with the end in mind。代码的运行效率？那么，究竟那里效率不高？怎么定义效率，怎么计算效率（latency? throughput? 还是什么）。代码的容错性？那么，什么样的 error 要收集，如何分门别类？哪里是潜在的错误大本营？&lt;/p&gt;&lt;p&gt;知道要改进什么后，接下来脑袋里要有幅图 —— 不是富春山居图 —— 是自己或者别人使用这些 metrics 的场景预现图，就像至尊宝给山贼展示他和白晶晶的旷古奇恋的画面一样。&lt;/p&gt;&lt;p&gt;比如说要提高效率，并且确定是降低 latency，所以打算收集服务的 response time，那么，response time 是看 line chart 还是 bar chart，知道了 latency 突然升高这件事之后，下一步呢？怎么知道再看什么？要和其它 metrics / event 关联么？关联哪些，怎么关联？想想意外事件发生之后，作为唯一可以背锅的程序员，身后一堆产品运营盯着你的屏幕，丧着个个脸，表情比出殡还悲壮，好像你一秒钟给公司损失几十万上下似的。在紧张的汗水打湿了你的格子衫时，你能看些什么，你该看些什么？&lt;/p&gt;&lt;p&gt;这样从解决什么问题，收集什么 metrics，怎么关联使用 metrics，一层层定义下来之后，我们可以确保两件事情：1. 当坏事发生的时候，我第一个知道。比如：对外的 API 的 95 percentile 的 response time 过去 5 分钟突然增加了 30%。2. 我能快速锁定问题的大致范围。比如：从其它 metrics 上看，是因为 diagon alley 服务的 latency 突然升高，进一步地，diagon alley 的 disk write IOPS 显著提高。那么这个问题，我就看为什么 diagon alley 的 disk write 不正常。&lt;/p&gt;&lt;p&gt;接下来是 logs。&lt;/p&gt;&lt;p&gt;logs 是不出问题不必太在意，但一旦出问题一定要能够方便定位具体的位置的奇葩重要 数据。所以 logs 求充足具体，要像辞海一样广而全 —— 比如当 metrics 告诉我们，问题出在我们并不清楚茴香豆的「茴」字时有几种写法，logs 能够帮助我们快速翻出来有用的那段，然后找出「茴」的四种写法。&lt;/p&gt;&lt;p&gt;logs 兼具给人看，和给机器分析两种效用，因而，最好要固定格式，以方便机器分析；但又不要用类似 JSON 的供机器阅读的方式，如果不配合一个好用的 parser，当人阅读时像是韩式整容过的足球宝贝，或者被抽干了形容词的句子，每个都长得一个模样，需要摘了眼镜用放大镜仔细找不同。&lt;/p&gt;&lt;p&gt;通过合理的 metrics 和 logs，测量变得唾手可得。这便释放出来我们不断迭代不断改进的能力。同样起点的代码，同样水准的程序员，一个一周迭代一次，一个一天迭代一次，其累进的质量在若干周期之后，会有质的变化。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;代码清晰度和代码复杂度&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果上面几个方面都做好了，代码的质量再差也是有下限的。这个下限可以通过严格使用 linter 和不断提升对所用语言的掌握来提高。就好比一个会独立思考并勤于思考的人，他的文章值得一读，也许从遣词造句，从修辞手法，从原起承提来说，他还稚嫩，但那是下限，并且是很容易提升的下限。&lt;/p&gt;&lt;p&gt;在 elixir 的 linter 里，我把 ABC complexity size 设置为 70，Cyclomatic complexity 设置为 15。所谓 ABC complexity，是代码里的 assignments(A)，branches(B)，conditionals(C) 的平方之和开方根的结果，它代表了一段代码有多冗长。Cyclomatic complexity，或者说循环复杂度，是指由程序的源代码中量测线性独立路径的个数，它代表了一段代码有多难懂（我们的小脑仁最不擅长同时记几件事情，比如情人节和结婚纪念日）。还有一些其他的设置，比如 nesting（嵌套层数）不超过 3， arity（函数的秩，或者说参数个数）不超过 6 个等等。这些 lint 的约束，会强迫你在函数的实现细节层面，考虑地更好。大部分情况下，同一个功能的代码可以有不同的表述方式，linter 的目的就是建立约束，强迫你用更合理的方式去表达一个功能点。&lt;/p&gt;&lt;p&gt;比如我常常不经意写出的代码：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-46eaa926c9224fc4d06848834ce6390e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;675&quot; data-rawheight=&quot;547&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-46eaa926c9224fc4d06848834ce6390e&quot; data-watermark-src=&quot;v2-3820afdcc07931af86b27152b6eda6b5&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这样降低了代码的 complexity，提高了代码的 clarity，同时，还使得代码的 extensibility 大大提升 —— 以后要加一个 “type 3” 的处理，仅仅是加一个简单的函数而已，非常符合 open/close 原则。&lt;/p&gt;&lt;p&gt;这样的小技巧有赖于对语言的精进，和对 linter 规则的恪守。虽然例外偶有发生 —— 比如一个复杂的 sql query 用 Ecto 表述很容易超过 ABC，但绝大多数情况，守着规则，会让你受益 —— 每次 commit，过 linter 就像灵魂在桑拿房里给蒸气熏碾，痛苦难耐。勉力熬过去后，推门出去一下子无比清爽，有种拨云见日，level up 的感觉。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;禅定时刻&lt;/b&gt;&lt;/h2&gt;&lt;blockquote&gt;为革命保护视力，预防近视，眼保健操，开始！&lt;/blockquote&gt;&lt;p&gt;眼睛是心灵的窗户，更是程序员除了左手和右手之外，攻城略地，气吞山河的利刃。最近重温了曾经折磨陪伴 自己十二年的眼保健操曲子，豁然发现，原来我们保护视力，是为了革命啊！你看，还好我小时候认真做眼保健操，否则要错过多少革命：通讯革命，互联网革命，移动互联网革命，云计算革命，大数据革命，庵の，区块链革命。&lt;/p&gt;&lt;p&gt;&amp;lt;此处我欠你们一个眼镜厂商，眼药水厂商，以及去眼角纹，拉双眼皮的广告&amp;gt;&lt;/p&gt;</description>
<author>陈天</author>
<guid isPermaLink="false">2018-07-09-39305285</guid>
<pubDate>Mon, 09 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>思考，问题和方法</title>
<link>https://henix.github.io/feeds/zhuanlan.prattle/2018-07-02-38813900.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38813900&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c2dc6929f1e633b30cc00c0de3d4864b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;转眼已是七月。距我上次更新公众号，已经一月有余。离我加入 Arcblock，也有两月。如果把人看做一个运行的软件，那么这两个月我已经迭代好几轮，就像龙珠里在飞往那美克星的太空船里不懈修炼的悟空。&lt;/p&gt;&lt;p&gt;人的成长是有诱因的，但不外乎得到他人指点，和自己开悟两种情况。吕蒙原本一介武夫，经孙权劝学后，发愤图强。有次鲁肃跟他议事，大惊失色，于是有了「士别三日，当刮目相待」的故事 —— 这是他人指点迷津。我是因为换了新的环境，破而后立，往日的积累和思考有了实施的空间和对象，又加上自己在西雅图孑然一身，事情又多，于是就把时间都扑在工作上，想得多，做得更多，能力也就上来了 —— 这是自己开悟。&lt;/p&gt;&lt;p&gt;孔子说三十而立，立的是什么？是立德、立功、立言这三不朽么？还是小家子些的，立身，立家，立业？每个在奔四路上的人都会有自己的体味和解读。但不容置疑的是，三十岁往上，要渐渐形成自己的思想和方法论。上篇文章 &lt;a href=&quot;http://localhost:8000/misc/thinking-in-arcblock.html&quot;&gt;Code is Law&lt;/a&gt;，我为 Arcblock 的 github repo 定义的一套规范，就是我自己的思想和方法论的产物 —— 你在任何已有的公开的文档中找不到类似的做法。它完美么？不，肯定不，我们在使用一段时间后已经有了一些新的感悟；它独特么？独一无二，且很有价值。&lt;/p&gt;&lt;p&gt;我在 &lt;a href=&quot;http://localhost:8000/misc/thinking-in-arcblock.html&quot;&gt;上帝说：要有一门面向未来的语言，于是有了 erlang&lt;/a&gt; 引用了 Joe 老爷子在其博士论文中提到的他对 erlang 的 worldview：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;everything is a process.&lt;/li&gt;&lt;li&gt;process are strongly isolated.&lt;/li&gt;&lt;li&gt;process creation and destruction is a lightweight operation.&lt;/li&gt;&lt;li&gt;message passing is the only way for processes to interact.&lt;/li&gt;&lt;li&gt;processes have unique names.&lt;/li&gt;&lt;li&gt;if you know the name of a process you can send it a message.&lt;/li&gt;&lt;li&gt;processes share no resources.&lt;/li&gt;&lt;li&gt;error handling is non-local.&lt;/li&gt;&lt;li&gt;processes do what they are supposed to do or fail.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;而在 Joe 的眼里，erlang 其实没有什么神秘的，仅仅六个函数就能涵盖它的全部：spawn，send，receive，register，whereis，self。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b77f3be9f5d480cc7991e32d9af04c91_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2448&quot; data-rawheight=&quot;3264&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b77f3be9f5d480cc7991e32d9af04c91&quot; data-watermark-src=&quot;v2-2a2882f794466d3784dad6a17b3848b3&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;（感谢小山同学贡献的老爷子亲笔阐述）&lt;/p&gt;&lt;p&gt;仔细想想，它简单地可怕，就像物理学的大一统理论一样，试图从纷繁复杂中跳脱出来，回归本源。更可怕的是，这六个函数不仅仅涵盖了 erlang，似乎也可以解释软件领域里的很多系统 —— 它们无所不在，在系统里面的意义就像原力之于星战。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;spawn：创建一个资源。对于 erlang，这资源是 process；对某个 service，是 service 本身。&lt;/li&gt;&lt;li&gt;send / receive：给资源发指令和接受指令。对于 erlang，这指令是 message，封装成 erlang term，走的是 IPC/RPC；而对某个 http service，指令是 request，封装成 json / msgpack / protobuf，走的是 http / http2。&lt;/li&gt;&lt;li&gt;register / whereis：资源怎么注册，怎么发现。对于 erlang，这是 process 在 name register 的注册和发现；对于某个 service，可以是 Consul / DNS。&lt;/li&gt;&lt;li&gt;self：返回自己的 identity。在 erlang 里，这是 process 找寻自我的方式；在 micro service 的场景下，每个 service 隐含着有自己的 identity。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我喜爱 Joe，和我喜欢 Rich Hickey 一样，他们在传播知识的同时，传播他们自己对事物独特的理解和思考。&lt;/p&gt;&lt;p&gt;回到我自己对做事的流程和方法的感悟。那些表层的方法之下，其实蕴含着一个重要的思考：如何让团队低成本的沟通和协作。我的方式是：convention by configuration。你弄懂了一个 repo 的结构，知道 make init，make build，make run，make create-pr 干些什么之后，就自然懂得我们在 arcblock 里所有 repo 的运行法则 —— 不管它是 elixir，还是 nodejs，还是 python。也不管 elixir 是否使用 asdf，nodejs 是否使用 nvm，python 是否使用 virtualenv，一个 make init 就把所有的环境帮里构建好，然后就可以安全地 make build 以及 make run 了。一个新来的工程师不需要跑来问我（或者其他人），这个 repo 怎么初始化，怎么运行起来，这大大节省了我们的时间；同时他也不需要为了能运行起来费力去读 READMME.md 里一个长长的「安装须知」的章节，因而也大大节省了他的时间。&lt;/p&gt;&lt;p&gt;这只是冰山的一角。我们还做了很多其它降低团队沟通协作成本的工作。而为大家节省下来的时间和精力，可以被用来做那些更重要的事情。这样点点滴滴的累积，最终有机会转化成一倍或者多倍的生产力，从而形成竞争优势。&lt;/p&gt;&lt;p&gt;我们的 Open Chain Access Protocal（OCAP）选用 GraphQL 而非 REST 接口来做 API 层，也有类似的考量。对于开发者而言，起初，他们有一些学习曲线，适应之后，我们无论是提供 1 个 API 还是 100 个 API，是支持一条链还是若干条链，对使用者的使用成本都是近似的。而 REST API，学习 100 个形态各异的 endpoints 对开发者来说将会是个梦魇；对于我们自己而言，初期搭设地基需要很多时间，随后，花样繁多的 query 背后，都是几种基本的 resolver 的组合。&lt;/p&gt;&lt;p&gt;「如何让团队低成本地沟通和协作」是我过去两个月的重要思考，也是我过去若干年知识和经验的储备的一次厚积薄发。&lt;/p&gt;&lt;p&gt;这两个月我的另一个尚处在摸索中的思考是：「如何用更先进更高效的方式来构建我们的服务及其生态？」&lt;/p&gt;&lt;p&gt;arcblock 目前是个小团队，即便研发团队发展到数十人的规模，依然很小。在我们想要做的事情的范畴上来看，如果找不到一个更行之有效的开发方式，我们会开发得很累，且开发进度会比较缓慢。就拿 OCAP 来说，打造一套供开发者使用的 API，不仅仅是 API 及其背后的服务那么简单。API 要有文档，要有 SDK，要有 API interface 的定义，以及支撑这个 interface 的服务。这里面会有很多重复的劳动：API doc 和 API interface，以及 SDK 都在不断地重复类似的内容和代码。当我们对 API 的定义进行改变的时候，往往牵一发而动全身，数个地方都需要修改，而这些都是非常机械的行为。所以，我们要寻找能够「降维打击」的方式。&lt;/p&gt;&lt;p&gt;在 Tubi，我做的 UAPI 系统，就整合了 API 和 API 的文档，使其可以一次定义，两处生效，节省大家的时间。而对于 OCAP，我们更进一步，试图把问题定义成这样：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;定义一门「语言」，来描述我们的 API&lt;/li&gt;&lt;li&gt;撰写不同方向上的 Parser（Code generator），将其转换成特定场景的代码&lt;/li&gt;&lt;li&gt;将 Parser 构建在 build pipeline 中，可以一次 build，生成各种结果&lt;/li&gt;&lt;li&gt;生成的结果要能很方便地扩展，以及和系统里的其他部分整合&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们定义的语言，姑且称之为：AADL（Arcblock API Description Language），为了方便每一个人撰写和理解（比如，产品经理也可以很方便地定义），我们使用了 yaml 格式，比如 &lt;code class=&quot;inline&quot;&gt;RichestAccounts&lt;/code&gt; 这个查询，其定义为：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;- name: RichestAccounts
 doc: Returns richest accounts, order by balance.
 return: PagedAccounts
 params:
 - name: paging
 type: PagingInput
 doc: Describes which page of data to return.&lt;/code&gt;&lt;p&gt;而这里面使用的 data structure，是这么定义的：&lt;/p&gt;&lt;code lang=&quot;yaml&quot;&gt;- name: PagedAccounts
 doc: Represents paginated Accounts.
 properties:
 - name: page
 type: PageInfo
 doc: The pagination information.
 - name: data
 type: [Account]
 doc: The paged Account data.&lt;/code&gt;&lt;p&gt;通过这种定义，我们生成：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;slate 风格的 API 文档（github.com/lord/slate）&lt;/li&gt;&lt;li&gt;Absinthe 的 GraphQL 的 query schema 定义（Absinthe 是 elixir 的 GraphQL lib）&lt;/li&gt;&lt;li&gt;Absinthe 的 GraphQL 的 type notation 定义&lt;/li&gt;&lt;li&gt;Ecto 的 DB repo 定义&lt;/li&gt;&lt;li&gt;Ecto 的 DB schema 定义&lt;/li&gt;&lt;li&gt;Ecto 的 DB migration 的定义&lt;/li&gt;&lt;li&gt;各种语言的 SDK（比如 nodejs，python，go，etc. 筹划中，还未开始）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;然后在一个 build pipeline 里，生成所有代码。比如生成的 Absinthe 的 query 长这个样子：&lt;/p&gt;&lt;code lang=&quot;elixir&quot;&gt;(
 @desc &quot;Returns richest accounts, order by balance.&quot;
  field(:richest_accounts, :paged_bitcoin_accounts) do
    [
      (
 @desc &quot;Describes which page of data to return.&quot;
        arg(:paging, :paging_input)
      )
    ]

    resolve(fn parent, args, resolution -&amp;gt;
      apply(Resolver, :paged_bitcoin_accounts, [parent, args, resolution])
 end)
 end
)&lt;/code&gt;&lt;p&gt;以上生成的代码符合前文中所述的「生成的结果要能很方便地扩展，以及和系统里的其他部分整合」这个限定条件。在这个例子里，程序员只需要进一步撰写 &lt;code class=&quot;inline&quot;&gt;Resolver.paged_bitcoin_accounts&lt;/code&gt; 这个函数就可以了。&lt;/p&gt;&lt;p&gt;目前这套流程还在实验当中，我们线上的服务，OCAP playground 就跑的是生成的代码。我们自己写了大约 3500 行 elixir，1000 行 yaml；生成出来 1500 行 elixir 代码（Elixir 支持 Macro，所以我们生成出来这些源码只是方便自己排查问题）。&lt;/p&gt;&lt;p&gt;虽然还有很多问题，但这套系统最大的好处是，在开发过程中，我们可以随意调整 API 的结构而不必每次调整都苦逼修改很多地方的代码。这在我们对很多 API 的行为还没有一个良好定义的时候，是个莫大的福音。而之后，当我们要大规模增加新的 API 时，我们将能够很快地支持。&lt;/p&gt;&lt;p&gt;这目前是我们对「如何用更先进更高效的方式来构建服务及其生态？」的一个答案。它离完美还有十万八千里，但立等可用。很多时候，问对问题比找对答案更有意义。好的问题就像在黑暗的隧道里寻觅出口，突然手边摸出一把手电筒，瞬间照亮整个征途。&lt;/p&gt;&lt;p&gt;先写这么多吧，希望能引发你的思考和问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>陈天</author>
<guid isPermaLink="false">2018-07-02-38813900</guid>
<pubDate>Mon, 02 Jul 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Code is Law</title>
<link>https://henix.github.io/feeds/zhuanlan.prattle/2018-05-16-36913380.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36913380&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-94e9c81b043fdbd3d0a1b6ecbc13dd97_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;如果你以为本文是在讲 Ethereum，或者 Smart Contract，那我非常抱歉。本文将要讲述的是 Engineering practices 以及我对一些流程的思考和应用。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;先举一个栗子&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在展开新工作的第一天，我就试图将 bootcamp 和 BBL 的文化引入 Arcblock。两周后，我们的 bootcamp site 长这个样子：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1b319c991fc6979311c24607fb86d9a6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1000&quot; data-rawheight=&quot;1600&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1b319c991fc6979311c24607fb86d9a6&quot; data-watermark-src=&quot;v2-33e68c40b3b920cfac3d3f0286270c08&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;请原谅这个简单的 UI 一副舅舅不疼姥姥不爱的样子 —— 我们只是还没有精力去将其做得更加美观。我的偶像陈道明先生说：简约而不简单。这简单的界面下面，其实蕴含着复杂的自动化流程。&lt;/p&gt;&lt;p&gt;如果要写新的 slides，团队里的工程师只需在我们的 bootcamp repo 里新建一个 markdown 文件，然后遵循一定的标准去撰写，就可以生成合适的 slides，比如：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f005af389867dad9b9a6975892464397_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;1573&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f005af389867dad9b9a6975892464397&quot; data-watermark-src=&quot;v2-c4205b5a6cd32700e56f8775367108c2&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;again，先暂且不要在意简单的 UI —— 面包会有的，一切都会好的。你要在意的是，confidential 的页面和非 confidential 的页面，差异仅仅在一个预定义好的 css class：&lt;code class=&quot;inline&quot;&gt;.confidential&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;当你完成了 slides 的编撰，&lt;code class=&quot;inline&quot;&gt;make create-pr&lt;/code&gt;（之后会介绍）会自动更新这个 repo 的版本，创建一个 pull request。&lt;/p&gt;&lt;p&gt;这时，勤劳的 travis 便会开始工作，把 slides build 一遍，确保无误后，给一个 green light。然后，reviewer review 后，merge PR。勤劳的 travis 会再度出现，先是把当前的版本打一个 tag，然后创建一个 github release，然后再把 slides 部署到一个 host static website 的 S3 bucket 上。这就是你开头看到的那幅图 —— 注意标题中的版本号。&lt;/p&gt;&lt;p&gt;整个流程的 UX 对 arcblock 的工程师来说，清晰，简单，并且是 day-to-day work，没有任何额外的入侵性的工作要做 —— 而且，系统帮你能简单就简单，连手工更新版本号，创建 pull request 这种工作，都只需要一条命令完成。&lt;/p&gt;&lt;p&gt;如果只是改一点点文字，觉得流程还是略繁琐，你还可以 inline edit（注意下图右上角的 label）：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2614ff57b075d7560412676e7d98b17c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;1161&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2614ff57b075d7560412676e7d98b17c&quot; data-watermark-src=&quot;v2-a96bfe1e149df2e0ceb554a91f5c9bf5&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;然后你可以不用命令行，直接编辑并创建 PR：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7ac8414f443a502bdb22b47045278a3d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1363&quot; data-rawheight=&quot;1600&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7ac8414f443a502bdb22b47045278a3d&quot; data-watermark-src=&quot;v2-0f741a8a1f5e8f7f92ef1002c8c83040&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;PR merge 之后，网站就得到自动更新了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;为什么说 Code is Law？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当我工作得越久，我越发感觉到流程的自动化和易用，非常非常重要。大家都知道 security best practice，都了解 key rotation 的重要性，但没有人真正去实施，为何？太繁琐，需要记住的条条框框太多，流程自己害死了流程。然而好的流程往往自身已经优化到不可精简的地步 —— 着粉则太白，施朱则太赤 —— 这个时候，我们唯一可依赖的就只有代码。通过代码，我们可以固化流程，通过代码，我们可以在保持流程完备的情况下，让流程的 UX 尽可能简单而没有入侵性。&lt;/p&gt;&lt;p&gt;在 Arcblock，上面的例子仅仅是沧海一粟。我们很多做事的方法，都在最大程度地践行和优化 Code is Law。我们的开发流程有如下要求：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;所有的改动必须有 pre commit hook —— 代码的风格和静态检查，代码编译，单元测试，文档的自动生成都必须通过，才能 commit&lt;/li&gt;&lt;li&gt;所有的改动必须发 pull request，要 up to date，CI 通过，有至少一个 review 才能 merge&lt;/li&gt;&lt;li&gt;每个 PR 的 merge 必须是 squash merge，不能是 rebase 或者 merge&lt;/li&gt;&lt;li&gt;每个 PR 必须 bump version，在 merge 到 master 之后，必须要有相关的 changelog，并且创建一个 github release&lt;/li&gt;&lt;li&gt;如果是编译型的语言，编译后的结果要放在对应的 github release 上&lt;/li&gt;&lt;li&gt;如果是 static web site，生成的结果要放在对应的 S3 bucket 上，可以直接访问&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这些事情如果都是手工去做的话，非常费事，会让工程师叫苦不堪 —— 自然，会有聪明的工程师想办法将其自动化。然而，更进一步的问题出现了 —— 不同的 repo 里自动化的机理可能不一样，在不同的 repo 工作有学习成本和上下文切换成本。&lt;/p&gt;&lt;p&gt;于是我们问自己一个的问题：可不可以构建一个体系，让所有的 repo 尽可能长得一样，拥有相同的能力？&lt;/p&gt;&lt;p&gt;从产品设计的角度来说，这个面向工程师的产品应该是个 CLI，它应该可以这么交互，来帮助工程师生成新的 repo：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ arcli create:repo
? Repo name: arc-awesome-repo
? Please write concise description: Awesome repo in arcblock
? Choose a template: (Use arrow keys or type to search)❯
  elixir
  general
  nodejs
  python
  web&lt;/code&gt;&lt;p&gt;为什么使用 interactive CLI，而不是带参数的 CLI？因为我们不想加重工程师记忆的负担 —— 第一次使用它的工程师也能无障碍的使用。当然，如果在其他程序中调用，我们也支持把所需的数据以 JSON 的形式直接 pipe 给 &lt;code class=&quot;inline&quot;&gt;arcli create:repo&lt;/code&gt;，以符合 UNIX 文化。&lt;/p&gt;&lt;p&gt;这个自动生成的 repo 会有以下 layout，并且自动生成这些文件和目录：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-80656f6f463a47c309685219acd96cee_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1034&quot; data-rawheight=&quot;893&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-80656f6f463a47c309685219acd96cee&quot; data-watermark-src=&quot;v2-6b3900d336962a7c2cf5ed95be7509c1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;如果你在生成的 repo 下看看 make 的能力：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ make &amp;lt;tab&amp;gt;watch
dep             precommitall    deploy          release
browse-pr       doc             runbuild        init
bump-version    install         travisclean     lint
create-pr       post-build      travis-init     travis-deploy 
delete-release  pre-build       test&lt;/code&gt;&lt;p&gt;你会惊异地发现，很多基础的工具，都已经立等可用。你可以用 &lt;code class=&quot;inline&quot;&gt;make create-pr&lt;/code&gt; 去做 pull request，可以 &lt;code class=&quot;inline&quot;&gt;make browse-pr&lt;/code&gt; 打开 browser 查看当前 repo 的 pull requests，可以 &lt;code class=&quot;inline&quot;&gt;bump-version&lt;/code&gt;。此时此刻，你的第一个 travis build 应该已经 build 完了并且 all green —— 这个时候，你还没有写真正的代码，然而，整个世界已经串起来，滚滚前行。&lt;/p&gt;&lt;p&gt;单拎出 &lt;code class=&quot;inline&quot;&gt;make create-pr&lt;/code&gt; 来说。当一个 PR 创建出来的时候，工程师需要干四件事：改软件的版本号，commit，写 changelog，去 github 上创建 PR。&lt;code class=&quot;inline&quot;&gt;make create-pr&lt;/code&gt; 在命令行里将所有这些事情都做了：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ git commit -a -m &quot;my awesome commit&quot;
$ make create-prBump version...
Current version: 0.2.0
Latest commit hash: cca0f8c
Enter a version number [0.3.0]:
[feature/test 53e617d] bump version
 4 files changed, 9 insertions(+), 3 deletions(-)
remote: Resolving deltas: 100% (4/4), completed with 3 local objects.
To github.com:ArcBlock/arc-test.git
 * [new branch]      feature/test -&amp;gt; feature/test
https://github.com/ArcBlock/arc-test/pull/1&lt;/code&gt;&lt;p&gt;如果你的项目有需要预先安装的软件，可以将其置于 &lt;code class=&quot;inline&quot;&gt;init&lt;/code&gt; 下，其他用户下载 repo 后可以直接 &lt;code class=&quot;inline&quot;&gt;make init&lt;/code&gt;，就生成一个完全可用的开发环境，而非阅读长篇累牍的 “how to install”。&lt;/p&gt;&lt;p&gt;如果项目需要让 travis deploy，可以放在 &lt;code class=&quot;inline&quot;&gt;travis-deploy&lt;/code&gt; 下，而 &lt;code class=&quot;inline&quot;&gt;.travis.yml&lt;/code&gt; 会引用这个 make target。&lt;/p&gt;&lt;p&gt;任何一个工程师，只要学会了一个 repo 的使用方法，其它 repo 都是一模一样，真正的 learn once, run everywhere。&lt;/p&gt;&lt;p&gt;对于工程师来说，整个开发的繁杂流程简化成几条命令：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ arcli init:repo # 第一次使用，以后不需要，会调用当前 repo 下的 make init
$ arcli start:story # 选择一个 story 开始工作 - 会自动 git check -b feature/&amp;lt;story-id&amp;gt;/&amp;lt;title&amp;gt;
$ git commit
$ arcli create:pr # 调用 make create-pr（见上文）

&lt;/code&gt;&lt;p&gt;这大大增强了流程的易用性。&lt;/p&gt;&lt;p&gt;使用代码来实施流程有如下好处：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;reuse：某个流程的实现可以被复用到其他地方&lt;/li&gt;&lt;li&gt;compose：流程和流程可以组合&lt;/li&gt;&lt;li&gt;compile：流程可以从一种结构被 transform 成另一种结构&lt;/li&gt;&lt;li&gt;configure：流程可配置，可松可紧，可萝可御&lt;/li&gt;&lt;li&gt;extend：流程可以被继承并拓展&lt;/li&gt;&lt;li&gt;debug：流程可以很方便地 debug&lt;/li&gt;&lt;li&gt;test：流程可以 test&lt;/li&gt;&lt;li&gt;version：流程有其自己的版本号&lt;/li&gt;&lt;li&gt;document：流程有和代码在一起的文档&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当然，还有代码的最大的好处：快速迭代。当我发现问题后，就可以立刻修改并且发送 pull request，让同事参与进来讨论。我们前几天完成了 interview process 的流程的制定，昨天讨论之后，就有一些 PR 发出来：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4f5202492b2efd7701be981f26b7ed1f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;841&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-4f5202492b2efd7701be981f26b7ed1f&quot; data-watermark-src=&quot;v2-8e048f498c98b5875a68fd76ed67e1f0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-dfd00d911e099088b1d5f37c700cac15_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1541&quot; data-rawheight=&quot;1600&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-dfd00d911e099088b1d5f37c700cac15&quot; data-watermark-src=&quot;v2-fb50b33629d66ee785aa77c5e8a33f55&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;现在请你停下来，仔细想想这样的迭代速度多么地可怕。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;再想一想。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们常常说不要让流程僵化，人人都可参与，人人都可修改，然而，当你的公司的流程是贴在墙上的一张张纸，躺在内网里的一个个 PDF，你怎么去参与？怎么去修改？跟 HR 反馈？跟哪个 HR 反馈？我认识的那个 HR 管这个么？如果修改怎么修改？修改流程的流程是什么？当这么多困惑摆在眼前时，你最终不得不放弃；而当一个 github repo 放在那里，你只要会用 markdown，几分钟就能修改好，merge 之后，该 build 成 pdf travis 就 build pdf，该放在内网上就 travis 就将其放在内网上，你不用关心，最重要的是你的工作几乎能够立刻得到反馈，或被接受，或被拒绝 —— 并且，当被接受之后，就跟区块链一样，你的名字被永远地刻进了这次修订之中。&lt;/p&gt;&lt;p&gt;人人都说 lean startup，谁都知道 build - measure - learn 的 feedback loop —— 天下武功，唯快不破，说的也是这个 loop 的迭代速度要快。然而这个 loop 光靠吹是吹不快的，要靠好的机制，要靠 code。&lt;/p&gt;&lt;p&gt;还拿 interview 为例，昨天面试一个 data engineer，她给我们的 code test 提了些建议，我回头仔细想了想，很有道理，于是就在 clubhouse 里提了这么一个方案（还没有实现）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ arcli create:code-test
Please choose a role: Data Engineer
Please choose a test: General
Please set expiration (1-7 days, default 7): 7
Please put the github id for the candidate: tyrchen

Code test is genearted for candidate tyrchen. Temporal link (expire in 7 days): https://....
Github repo is generated for candidate tyrchen. It will be merged into arcblock/arc-archived-code-tests upon expiration.&lt;/code&gt;&lt;p&gt;基本上，就是当我们要给一个 candidate 发 code test 时，我们可以选择相关的角色和试题，生成 github repo，生成关于试题的临时访问地址，然后通过邮件或者微信通知对方链接。这样，试题的说明我们可以随时更新，而不需要邮件或者微信上来来回回口头阐述 —— 而口头阐述是 conversation-based，很容易失真，很容易即兴发挥而引导对方到错误的方向。&lt;/p&gt;&lt;p&gt;这些都不重要，重要的是 —— &lt;b&gt;我们把流程和 user story 结合在了一起！发现流程的问题，谁都可以发 PR，当然，如果自己解决不了或者没空解决，可以提 user story，然后，会有工程师在这个 user story 上工作，写代码，测试，部署！然后我们自己 eat your own dog food！这才是流程能够不断演进之道！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;扯两句 arcli —— 她也许已经成功取得了你的关注。arcli 也是我们 Code is Law 思想的一种体现。我们说我们的一个原则是 &lt;b&gt;内部的各种工具最好统一易用&lt;/b&gt;。那么对应的需求是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;CLI 的界面要一致&lt;/li&gt;&lt;li&gt;CLI 能够很方便地被发现&lt;/li&gt;&lt;li&gt;CLI 是 interactive 和 self-document，能够轻松上手&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;所以我花了点时间用 commander 和 inquirer 写了个自注册的 CLI 的 framework（别被这个名头唬住 —— 整个 core 也就不到 100 行代码），同时做了一个 CLI 模板，可以自动生成新的 CLI 的整个 layout，最后填充执行的 action 即可。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ arcli create:arcli
? name of the cli (use &quot;:&quot; to differentiate action and object. e.g. create:repo): hello:world
? Please write concise description: hello world

Creating target index.js with file index.js.tpl.
Creating target cli.js with file cli.js.tpl.
Regenerateing /Users/tchen/projects/arcblock/arcli/src/cli/hello/index.js
Regenerateing /Users/tchen/projects/arcblock/arcli/src/cli/index.js
Code generated at: /Users/tchen/projects/arcblock/arcli/src/cli/hello/world

&lt;/code&gt;&lt;p&gt;这样，当一个工程师需要创建某个自动化工具时，她可以很方便快捷地创建，并专注于其逻辑而不是 CLI 如何注册，如何被发现，如何设置和选择参数等等。&lt;/p&gt;&lt;p&gt;而我们内部也在不断讨论，如何让这些工具和流程能够更加人性化，让体验是一种 peak experience：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c5016dbb2dc7dfc53e049be5df7be559_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;720&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c5016dbb2dc7dfc53e049be5df7be559&quot; data-watermark-src=&quot;v2-bbec173a70d159ceac29a71b4a97bb96&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们知道，如果一家公司口口声声说 user centric，give user love and care，内部的流程却处处反人性，并没有 user centric，那么如何让员工去 love and care user？如果一家公司拍着胸脯说每个员工都是公司的 leader，却根本不给予 leader 们合适的工具去行使 owner 的权利，那这和没有说有什么区别？在哈佛幸福课里，Tal 用生动的例子向大家证明，people don’t follow what you say, but follow what you do。&lt;/p&gt;&lt;p&gt;所以，在 Arcblock，我们说我们要构建一个 &lt;b&gt;人人可以参与制定 &lt;/b&gt;的公司文化，我们就要 &lt;b&gt;在工具上让这种参与唾手可得&lt;/b&gt; —— 所以，我们拥抱 Code is Law。虽然我们现在很多东西都还在起步阶段，但只要我们持续地用代码来表述流程，我们用 github 来记录流程，用 travis 来编译和部署流程，用开源代码合作的方式来进化流程，那么我们就能更快地演进，更快地自我迭代。而所有这一切，我们希望不仅仅工程师受益，整个公司都能受益；不仅仅工程师能发送 PR，其它职能部门的人，我们也会教会她们 markdown 和 github 的简单用法，从而无障碍地使用和更新；她们也可以在 clubhouse 里随时给工程师提需求，让流程源源不断地被工具简化。&lt;/p&gt;&lt;p&gt;Code is Law！&lt;/p&gt;&lt;p&gt;我们还在招人！可以看我前一篇文章了解详情：&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;amp;mid=2649827999&amp;amp;idx=1&amp;amp;sn=5374d71f1baa677ffe6805d36fac2af0&amp;amp;chksm=8704a883b07321953c6e713bb86a08ca546a18f661522bbbf89a8832fbdb897f82babdc7a11e&amp;amp;scene=21#wechat_redirect&quot;&gt;欢迎来到区块链的世界&lt;/a&gt;。对我们感兴趣请将简历发至：career at arcblock.io。谢谢！&lt;/p&gt;</description>
<author>陈天</author>
<guid isPermaLink="false">2018-05-16-36913380</guid>
<pubDate>Wed, 16 May 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
