<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>业余程序员的个人修养</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Sat, 23 Jun 2018 16:27:24 +0800</lastBuildDate>
<item>
<title>编程哲学（六）：从正确归因到个人影响力</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-06-22-37656537.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37656537&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;归因问题&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6fe64e4355dea168d4bafe593f0d5e18_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;542&quot; data-rawheight=&quot;324&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6fe64e4355dea168d4bafe593f0d5e18&quot; data-watermark-src=&quot;v2-d90a5a68977b9787a05a631937d18708&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;归因理论&lt;/b&gt;是社会心理学研究的理论之一，它描述了我们怎样解释人们的行为。&lt;/p&gt;&lt;p&gt;我们总是试图将某个人的行为或者某个结果，&lt;br&gt;归因于性格（内因）或情境（外因）。&lt;/p&gt;&lt;p&gt;我们无休止的分析和讨论&lt;b&gt;事情为什么发生&lt;/b&gt;，&lt;br&gt;特别是当我们经历一些消极事件或者预期之外的事件的时候。&lt;/p&gt;&lt;p&gt;归因理论的研究者发现，人们在归因时存在一个普遍性的问题，&lt;br&gt;当我们解释他人的行为时，会低估&lt;b&gt;环境&lt;/b&gt;造成的影响，而高估&lt;b&gt;个人的特质和态度&lt;/b&gt;所造成的影响。这种个体在归因时低估情境因素作用的倾向，被称为&lt;b&gt;基本归因错误&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;就像当我们看一个演员出演正面或反面角色时，&lt;br&gt;尽管我们知道这些都不是真实的，&lt;br&gt;但我们却很容易固执的认为这就是那个人本质的真实反映。&lt;/p&gt;&lt;p&gt;&lt;b&gt;人们习惯性的将自己的失误归因于环境，而将别人的失误归因于他们的内部秉性。&lt;/b&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;改变他人 vs 改变环境&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-376c76249fe7f30b58bb35ff1f571050_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;550&quot; data-rawheight=&quot;464&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-376c76249fe7f30b58bb35ff1f571050&quot; data-watermark-src=&quot;v2-ccb1dda6328405bdb18be57b1be9deed&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;想要改变他人，是人们表达对环境不适的正常反应。&lt;br&gt;然而，对每个人来说，本身也是自己所处环境的一部分。&lt;br&gt;因此，想要改变他人，也是人们缺乏行动力，没办法行动起来的正常反应。&lt;/p&gt;&lt;p&gt;不幸的是，&lt;b&gt;试图改变他人，其实就是互相伤害。&lt;/b&gt;&lt;br&gt;有意无意的想改变对方，是矛盾的根源。&lt;/p&gt;&lt;p&gt;改变别人是不可能的，况且&lt;b&gt;别人也不认为自己需要作出改变。&lt;/b&gt;&lt;br&gt;所以，如果对环境感到不适的时候，&lt;br&gt;应该着手从自己做起，做好想让别人去做的事情。&lt;/p&gt;&lt;p&gt;一旦行动起来，自身所处的局部环境就自然发生了改变。&lt;br&gt;局部环境改变了，才有可能通过环境&lt;b&gt;影响&lt;/b&gt;他人。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;从抱怨到合作&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-04ed55edb879971ba4ed21b11f2bdba2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;663&quot; data-rawheight=&quot;442&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-04ed55edb879971ba4ed21b11f2bdba2&quot; data-watermark-src=&quot;v2-d5c8c89251ec202ea7fd5acf4cdaa2d1&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;不是别人没有把事情做好，而是我们这些人&lt;b&gt;都没有把事情做好&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;在软件开发中，人们经常为了完成更多的功能，不得已而降低软件的可维护性和可用性，&lt;br&gt;其表现形式就是代码缺少注释和文档。&lt;/p&gt;&lt;p&gt;那么应该由谁来完成这些注释和文档的编写工作呢？&lt;br&gt;很显然代码的作者很难逃避这个责任，&lt;br&gt;但我想说这并不是一个人的责任，相反，整个团队应该&lt;b&gt;共同担负&lt;/b&gt;这个责任。&lt;/p&gt;&lt;p&gt;因为不是一个人而是一个团队，交付了软件产品。&lt;br&gt;我们经常对别人能做而未做，自己也能做却不想做的事情，进行抱怨。&lt;/p&gt;&lt;p&gt;避免抱怨的最好方法就是，行动起来，&lt;br&gt;从自己能做的事情做起，与团队成员紧密的合作。&lt;/p&gt;&lt;p&gt;只有在竞争中才纠结谁对谁错，合作的时候，只看&lt;b&gt;共同的表现结果&lt;/b&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/1476651/&quot;&gt;社会心理学（第八版）- 戴维·迈尔斯&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-06-22-37656537</guid>
<pubDate>Fri, 22 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>编程哲学（五）：未雨绸缪</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-06-19-37656145.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37656145&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;备选方案&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d243ceba53e0a64071a0f4c31de953d1_r.jpg&quot; data-rawwidth=&quot;269&quot; data-rawheight=&quot;188&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d243ceba53e0a64071a0f4c31de953d1&quot; data-watermark-src=&quot;v2-2b26fb0642ec7c3eb7ade5335f341b2b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;和优秀的人合作，很容易得到理解和体谅，&lt;br&gt;因为他们对问题本来就有很多种解决方案，也都明白&lt;b&gt;方案是灵活机变&lt;/b&gt;的。&lt;/p&gt;&lt;p&gt;因此，互相怀疑对方能力，不能理解对方的处境，绝不让步，&lt;br&gt;这些事永远都不会发生。&lt;/p&gt;&lt;p&gt;当我们面对困难的时候，如果我们除了仅有的一个选择之外别无它法，&lt;br&gt;这往往不是一个好的状态。&lt;br&gt;如果&lt;b&gt;没有权衡的余地&lt;/b&gt;，就只能被动的接受一切，也就没有办法处理任何突发状况。&lt;/p&gt;&lt;p&gt;编写代码也是如此，&lt;br&gt;如果我们一开始只有一种办法来实现功能，&lt;br&gt;那么这通常不是一个最优的选择。&lt;/p&gt;&lt;p&gt;实际上，我们应该不遗余力的寻找备选方案，未雨绸缪。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;有失才有得&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我听过很多人都呐喊着想做出改变，&lt;br&gt;但是真正主动承受痛苦改变成功的却没有多少人。&lt;/p&gt;&lt;p&gt;究其原因是，仅仅想要做出改变，还远远不够。&lt;br&gt;&lt;b&gt;任何改变不可能只是带来利益，而不需要付出沉重的代价。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;所以，关键不在于人们是否愿意改变自己，&lt;br&gt;也不在于人们是否能够战胜自己的习惯。&lt;br&gt;而是在于愿不愿意为不确定的事情付出显而易见的&lt;b&gt;代价&lt;/b&gt;，是否有能力承担&lt;b&gt;风险&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;事情就是这样，我们会得到一些自己想要的，&lt;br&gt;却同时又会失去一些我们不想失去的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;维持任何优雅的代码特征都是需要成本的，&lt;/b&gt;&lt;br&gt;我们都想追求可维护性，可读性，&lt;br&gt;又要保证性能和质量，还要按时完成，这几乎是不可能的。&lt;/p&gt;&lt;p&gt;我们需要考虑的是，&lt;br&gt;维持这些特性的成本是否值得投入，以及性价比有多大，&lt;br&gt;是否有更重要的事情要做。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;更上一层楼&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-069dc382e28a09cd69ca1de24d654715_r.jpg&quot; data-rawwidth=&quot;185&quot; data-rawheight=&quot;466&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;当我们视野不够的时候，总是容易表现得小肚鸡肠，对一些细枝末节斤斤计较。&lt;br&gt;所以，最好先看一下较远的地方，再低下头来审视当前工作的价值。&lt;/p&gt;&lt;p&gt;制定目标的时候也是如此，&lt;br&gt;先想一下未来的样子，&lt;br&gt;然后再&lt;b&gt;将长期计划截断为短期计划&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;在软件行业，新瓶装旧酒的技术方案受制于各种商业因素的影响，此起彼伏层出不穷。&lt;br&gt;如果看不清发展趋势，我们当前努力打造的代码堡垒，&lt;br&gt;会被潮流的更替瞬间击垮，凭添太多改造成本。&lt;/p&gt;&lt;p&gt;所以，保持忙碌很重要，&lt;br&gt;也要谨防忙碌的样子，&lt;br&gt;正确的做事很重要，也要胆识&lt;b&gt;做正确的事情&lt;/b&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;意料之外还是意料之中&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;没有明确的目的，会让我们很难进行取舍。&lt;/p&gt;&lt;p&gt;例如，保留一个已有的问题会节省时间，&lt;br&gt;但是可能会使这个问题以后更难被解决，该如何选择？&lt;br&gt;事实上，这取决于我们到底想节省时间，还是想避免以后的麻烦。&lt;/p&gt;&lt;p&gt;只有明确了目的，明确了某些做法是我们有意而为之，才会避免心理上的抵触。&lt;br&gt;&lt;b&gt;洁癖&lt;/b&gt;和&lt;b&gt;强迫症&lt;/b&gt;才不会干扰我们，世界才能清静下来。&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-06-19-37656145</guid>
<pubDate>Tue, 19 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>编程哲学（四）：把控间接性</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-06-15-37655447.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37655447&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;间接性&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;计算机领域有句名言：&lt;br&gt;“计算机科学领域的任何问题都可以通过增加一个&lt;b&gt;间接的中间层&lt;/b&gt;来解决”。&lt;/p&gt;&lt;p&gt;但是&lt;b&gt;过多的间接性&lt;/b&gt;反而会造成不好的影响，所以人们进行了这样补充，&lt;/p&gt;&lt;blockquote&gt;...except for the problem of too many layers of indirection.[1]&lt;/blockquote&gt;&lt;p&gt;间接性指的是，为了达成某个目的，我们可以&lt;b&gt;先做另外一件事情&lt;/b&gt;，&lt;br&gt;然后再绕过来解决原始的问题。&lt;/p&gt;&lt;p&gt;间接性在编程工作中很常见，实际在不知不觉中，我们已经使用了它。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cd50740c33993f7f63bf68ce68bf9cf6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;492&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-cd50740c33993f7f63bf68ce68bf9cf6&quot; data-watermark-src=&quot;v2-072323a53c264cca74449ef5c70157f4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;blockquote&gt;计算过程是存在于计算机里的一类抽象事物，在其演化进程中，这些过程会去操作一些被称为数据的抽象事物。人们创建出一些称为&lt;b&gt;程序&lt;/b&gt;的规则模式，以&lt;b&gt;指导&lt;/b&gt;这类过程的进行。从作用上看，就像是我们在通过自己的写作魔力去控制计算机里的精灵似的。[2]&lt;/blockquote&gt;&lt;p&gt;可见，&lt;b&gt;程序符号&lt;/b&gt;不同于它们所操纵的&lt;b&gt;计算过程&lt;/b&gt;，&lt;br&gt;编写程序是间接性的一种体现，&lt;br&gt;程序只是软件功能的一种&lt;b&gt;符号表示&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;我们应该选取合适的符号，用以描述目标系统的软件功能。&lt;/p&gt;&lt;p&gt;在数学史上，区分&lt;b&gt;符号&lt;/b&gt;以及对符号的&lt;b&gt;解释&lt;/b&gt;，却花费了很长时间。&lt;br&gt;人们总是&lt;b&gt;不由自主的&lt;/b&gt;把符号解释为日常生活中熟悉的概念。&lt;/p&gt;&lt;blockquote&gt;这是整个十九世纪数学的最深刻的教训之一。[3]&lt;/blockquote&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;表达能力&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们经常处于一种&lt;b&gt;表达能力受限而不自知&lt;/b&gt;的状态。&lt;/p&gt;&lt;p&gt;为了得到编程语言相关的种种商业好处，&lt;br&gt;经常把自己局限在&lt;b&gt;某个特定编程语言&lt;/b&gt;范围之内。&lt;/p&gt;&lt;p&gt;我们只用这种语言去“描述”心中想做的“事情”，&lt;br&gt;结果我们能“描述”的“事情”，&lt;br&gt;就慢慢局限在了该语言善于“描述”的“事情”范围之中了。&lt;/p&gt;&lt;p&gt;除此之外，写出易读的代码，显然和&lt;b&gt;写作水平&lt;/b&gt;有关，&lt;br&gt;好的表达方式，可以把长篇大论平白直叙的“流水账”，&lt;br&gt;改造成结构清晰发人深省的“文学作品”。&lt;/p&gt;&lt;p&gt;因此，我们应该多从文学作品中学习经验，&lt;br&gt;训练自己怎样把事情说清楚，&lt;br&gt;以及在每个层面上把问题展开成什么样的细节程度。&lt;/p&gt;&lt;p&gt;只有在这种情况下，&lt;b&gt;封装信息&lt;/b&gt;和&lt;b&gt;隐藏细节&lt;/b&gt;才突然有了意义。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;扁平化&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-dba26251fa18650ec432a84f71564982_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;477&quot; data-rawheight=&quot;317&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-dba26251fa18650ec432a84f71564982&quot; data-watermark-src=&quot;v2-1f4f9017a363697609f11db3f98f1009&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;重复未必是有问题的&lt;/b&gt;，重复的描述细节才有问题。&lt;/p&gt;&lt;p&gt;某些代码显得无比冗余啰嗦，&lt;br&gt;我们才想到要把它们放在更为细节的层次上。&lt;/p&gt;&lt;p&gt;通常我们会先去构建一些粒度较大的“砖块”，&lt;br&gt;再用这些“砖块”去搭建主流程，&lt;b&gt;简化主流程的描述方式&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;然而，过多的细节&lt;b&gt;层次&lt;/b&gt;也是不恰当的，它增加了我们的&lt;b&gt;描述复杂度&lt;/b&gt;。&lt;br&gt;在大型项目中，这些“砖块”本身也会包含很多的细节，由更小的“砖块”组成。&lt;br&gt;阅读代码的人，必须经常&lt;b&gt;在不同的层次中上下跳跃&lt;/b&gt;，才能理解我们到底想要表达什么。&lt;/p&gt;&lt;p&gt;这时候，识别出可复用的代码才是关键。&lt;/p&gt;&lt;p&gt;通过分析问题本身的&lt;b&gt;数学结构&lt;/b&gt;，或者理解项目相关的&lt;b&gt;业务背景&lt;/b&gt;，&lt;br&gt;我们可以看到具有逻辑完整性的模式和工具。&lt;/p&gt;&lt;p&gt;把它们提取出去独立放在其他的地方，&lt;br&gt;可以帮助我们减少当前项目的描述层次，使之扁平化。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Indirection&quot;&gt;Indirection&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/1148282/&quot;&gt;计算机程序的构造与解释 - P1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/1291204/&quot;&gt;哥德尔.艾舍尔.巴赫_集异璧之大成 - P117&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-06-15-37655447</guid>
<pubDate>Fri, 15 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>编程哲学（三）：是什么影响了我们的开发效率</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-06-13-37654697.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37654697&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;工作量是实际工作任务或可达工作任务，&lt;br&gt;而&lt;b&gt;工作效率&lt;/b&gt;，一般指工作投入与产出之比。&lt;/p&gt;&lt;p&gt;在进行某项任务时，工作效率是取得的成绩与所用时间、精力、金钱等的比值。&lt;br&gt;产出大于投入，就是正效率；产出小于投入，就是负效率。&lt;/p&gt;&lt;p&gt;软件是一个神奇的行业，&lt;br&gt;不同的工作方式，在工作效率上可能会产生&lt;a href=&quot;https://movie.douban.com/subject/6974319/&quot;&gt;15倍甚至100倍&lt;/a&gt;的差距。&lt;/p&gt;&lt;p&gt;因此延长工作时间，变成了一件不是特别重要的事情了，&lt;br&gt;人们更多考虑的是&lt;b&gt;如何在有限的时间内效率更高&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;在提高工作效率方面，每个人都有自己的办法。&lt;br&gt;“不要重复造轮子”就是其中一个，&lt;br&gt;它使我们看到了重复劳动，这在一定程度上确实提高了我们的工业水平。&lt;/p&gt;&lt;p&gt;然而，另外一些方面，就不是那么直观了。&lt;/p&gt;&lt;p&gt;我经常看到很多人在忙着写代码，却没有意识到，&lt;br&gt;我们确实有很多事情要做，但是却&lt;b&gt;未必有那么多代码要写&lt;/b&gt;。&lt;br&gt;更多的代码，意味着更高的开发成本，测试成本和维护成本。&lt;/p&gt;&lt;p&gt;因此，当我们需要动手实现很多功能的事情，&lt;br&gt;不妨问一下自己，&lt;b&gt;为什么我们不得不写这么多东西。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;难道我们真的走在了业界的前沿，做一些发明创造吗？&lt;br&gt;这个问题的答案通常是“否”。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;没有在专业性上保持谦逊&lt;/b&gt;&lt;/h2&gt;&lt;u&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-aa6b141028482f2bedf966ccc89b218b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;384&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-aa6b141028482f2bedf966ccc89b218b&quot; data-watermark-src=&quot;v2-19f77ed2f2371058a441fa13a01a9816&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;/u&gt;&lt;p&gt;某个领域的专家，会更倾向于喜爱自己所在的领域，&lt;br&gt;认可自身领域专业性的价值，否则当初就难以成为专家了。&lt;/p&gt;&lt;p&gt;这是一件利弊参半的事，&lt;br&gt;&lt;b&gt;专业性使得一些工作被巧妙的解决掉，也使得一些工作被解决的过于勉强&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;软件也是如此，&lt;br&gt;只有极少数情况下，用户是不得不需要软件的，&lt;br&gt;虽然我们听到和感受到的都是他们的确需要。&lt;/p&gt;&lt;p&gt;商业软件要解决的问题，通常在于缓解当前已有的工作压力，&lt;br&gt;或者说&lt;b&gt;对现有方案做出改善&lt;/b&gt;，&lt;br&gt;却很少创造出全新的解决方案，虽然我们不是这么宣传的。&lt;/p&gt;&lt;p&gt;因此，带着专业领域的自豪感，我们很容易绑架用户，&lt;br&gt;或者帮用户做太多只能由他们做的事情。&lt;br&gt;这会在不经意间给用户带来新的负担，还会极大的增加软件的功能范围和复杂度。&lt;/p&gt;&lt;p&gt;所以，我理解的专业性，并不是在专业领域给用户寻找方案，&lt;br&gt;而是&lt;b&gt;专业性的给用户寻找方案&lt;/b&gt;，结果可能是用户并不需要我们做那么多事情。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;没有把自己变成信息源&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a823234059256268be764f31ea104f30_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;484&quot; data-rawheight=&quot;300&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a823234059256268be764f31ea104f30&quot; data-watermark-src=&quot;v2-5f78ce4bd4c861b37fd791a42ebb680b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;人们对工程师的认识可能带有成见，&lt;br&gt;认为工程师一定是内向的，不善言辞的，&lt;br&gt;因为他们觉得只有这样才会显得更专注。&lt;/p&gt;&lt;p&gt;然而，别人这么认为，并不代表着这样做就是好的，&lt;br&gt;仅仅代表着如果这么做会给自己带来较小的阻力。&lt;/p&gt;&lt;p&gt;事实上我们应该反思一下，&lt;br&gt;&lt;b&gt;内向和不善言辞是不是真的有助于自己把工作做好。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;沟通问题在任何行业都会存在，并不是软件行业所独有的。&lt;br&gt;缺乏沟通，人们都被动的接受信息，会降低团队的工作效率。&lt;/p&gt;&lt;p&gt;这件事大家都是知道的，&lt;br&gt;然而却很少有人肯站出来，主动汇报自己的工作，变成&lt;b&gt;信息源&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;人们腼腆的不分享自己的成功案例，这可能算是一种谦虚，&lt;br&gt;但是因为没有机会得到反馈，而坚持自己的错误就很难被定义为谦虚了。&lt;/p&gt;&lt;p&gt;软件工程师需要主动得到工作反馈，确认待解决问题的动向，&lt;br&gt;向团队汇报自己的工作内容，向显然已经知道答案的同事学习经验。&lt;/p&gt;&lt;p&gt;&lt;b&gt;不要自己扛下所有的事情，不要自己研究。&lt;/b&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;没有吃自己的狗粮&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bcd32577e84af3fe424fece8b5086435_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;400&quot; data-rawheight=&quot;300&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-bcd32577e84af3fe424fece8b5086435&quot; data-watermark-src=&quot;v2-ff5362baec9a6eec639d3436cb5ff694&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Eating your own dog food，直译为“吃你自家的狗粮”，也称为dogfooding，&lt;br&gt;是一句英语俚语，常用于描述公司（尤指软件公司）使用自己生产的产品这一情况。&lt;/p&gt;&lt;p&gt;好的工匠常常拥有自己的&lt;b&gt;工具箱&lt;/b&gt;，&lt;br&gt;工程师也会思考如何利用团队的产出反哺团队自身。&lt;/p&gt;&lt;p&gt;我们有哪些工具是完成业务目标之外的副产品？&lt;br&gt;哪些副产品可以在后期当做产品来发布的？&lt;br&gt;我们做事情的方式是不是可以总结下来？&lt;/p&gt;&lt;p&gt;这是产生&lt;b&gt;技术产品&lt;/b&gt;的一个有效办法，&lt;br&gt;而那些立志于只产出技术产品的团队，却往往难以存活下来，&lt;br&gt;因为他们&lt;b&gt;并不用自己的产品&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;吃自己的狗粮，让我们把一部分注意力放到了&lt;b&gt;副产品&lt;/b&gt;和&lt;b&gt;历史积累&lt;/b&gt;上面。&lt;br&gt;这些积累才是一个团队赖以生存的根基，&lt;br&gt;也是工作效率不可能被新团队取代的根本保障。&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-06-13-37654697</guid>
<pubDate>Wed, 13 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>编程哲学（二）：让我们想个办法</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-06-09-37653890.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37653890&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2a9bce24f32e613a8f8748c0b7791ac2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;481&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2a9bce24f32e613a8f8748c0b7791ac2&quot; data-watermark-src=&quot;v2-2bada21402e3afe2ba18501830c6cc67&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们在编写代码的时候，如果发现某个处理过程已经在别处写好了，&lt;br&gt;想拿过来用，就会有所考量。&lt;/p&gt;&lt;p&gt;不能复制过来，因为修改起来费时费力；&lt;br&gt;也不能轻易建立依赖，因为修改可能会产生意外影响。&lt;/p&gt;&lt;p&gt;是的，&lt;b&gt;重复会增加冗余，但是复用会增加依赖。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;为此，聪明的人们想到很多办法，&lt;br&gt;指出了“软件设计原则”，还有人提到了“代码坏味”，&lt;br&gt;&lt;b&gt;代码质量&lt;/b&gt;被重视起来了。&lt;/p&gt;&lt;p&gt;扩展性，高性能，稳定性，可维护性，都是人们追求的目标。&lt;br&gt;丑陋的设计和肮脏的代码，是不可容忍的。&lt;/p&gt;&lt;p&gt;人们当然知道“适用”才是最好的，当然不想“过度设计”，&lt;br&gt;当然知道“模式”只是前人总结的一些可选经验。&lt;/p&gt;&lt;p&gt;然而，某些代码我们就是&lt;b&gt;不能容忍&lt;/b&gt;。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;后来，我们从这个层面跳出来了，&lt;br&gt;看到了代码要解决的&lt;b&gt;问题&lt;/b&gt;，看到了“方案”和“需求”，&lt;br&gt;看到了软件怎样被人使用，看到了代码在工程中的作用。&lt;/p&gt;&lt;p&gt;于是，我们学会了如何根据&lt;b&gt;问题的结构&lt;/b&gt;来组织代码，&lt;br&gt;根据业务的发展来促进代码的演进，&lt;br&gt;学会了推动别人来使用软件，为生态做出贡献。&lt;/p&gt;&lt;p&gt;然而，这并没有什么卵用。&lt;/p&gt;&lt;p&gt;我们仍然会遇到新状况，仍然有不能用已有经验去解决的问题，&lt;br&gt;我们可能会遇到&lt;b&gt;沟通问题&lt;/b&gt;，遇到&lt;b&gt;协作问题&lt;/b&gt;，遇到&lt;b&gt;工程问题&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;这不是一个人的事情，&lt;br&gt;我们不得不让大家都知道哪里出问题了，才有可能解决它。&lt;/p&gt;&lt;p&gt;我们发现了&lt;b&gt;人的重要性&lt;/b&gt;，&lt;br&gt;我们必须营造良好的“氛围”，优秀的人们才会被吸引过来。&lt;/p&gt;&lt;p&gt;我们不得不主动沟通，统一方向，&lt;br&gt;不得不扩大影响力，促成某件事情落地执行。&lt;/p&gt;&lt;hr&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6ac15818e9b42a62265467d27add35ef_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;903&quot; data-rawheight=&quot;400&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6ac15818e9b42a62265467d27add35ef&quot; data-watermark-src=&quot;v2-b3b32d055e8897e975d3392771c54060&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们总有事情要做，没有通用的解决方案，没有“&lt;b&gt;银弹&lt;/b&gt;”。&lt;/p&gt;&lt;p&gt;很多事情与代码无关，与编程也无关，&lt;br&gt;工程师们到底应该做什么呢？&lt;/p&gt;&lt;p&gt;有人会说，快速写出可用的代码去实现业务目标就够了。&lt;br&gt;我承认这是应该做的，但是还有&lt;b&gt;价值&lt;/b&gt;更大的事情。&lt;/p&gt;&lt;p&gt;这件事情就是，“&lt;b&gt;想办法&lt;/b&gt;”。&lt;br&gt;有的人总是没想法，而有的人总是会想办法。&lt;/p&gt;&lt;p&gt;这些，经验、原则、模式、方案、工程、文化，不都是别人想出来的吗？&lt;br&gt;&lt;b&gt;关键不在于做什么，而在于谁去做它，&lt;br&gt;&lt;/b&gt;不同的人会想出不同的办法。&lt;/p&gt;&lt;p&gt;所以，我认为软件工程师并不仅仅是写代码的人。&lt;br&gt;而是&lt;b&gt;发现问题，并思考如何解决&lt;/b&gt;的人。&lt;br&gt;能发现多大价值的问题并解决它，工程师就能创造多大的价值。&lt;/p&gt;&lt;p&gt;这里提到的问题，并不局限于业务功能，也不局限于代码本身，&lt;br&gt;不局限于软件工程，更不局限于团队文化。&lt;br&gt;它们都是问题，都需要想办法。&lt;/p&gt;&lt;p&gt;我们想到的办法如果可以用代码解决，就实现它，&lt;br&gt;如果不能，那就用别的办法解决它。&lt;/p&gt;&lt;p&gt;我觉得，到了这一步，才能从容的面对丑陋的代码，&lt;br&gt;面对混乱的项目工程，面对水土不服的文化。&lt;/p&gt;&lt;p&gt;为什么？因为这些问题，&lt;br&gt;本来就应该是工程师们，想办法去解决的呀。&lt;br&gt;&lt;b&gt;发现问题，让我们想个办法，然后解决它。&lt;/b&gt;&lt;/p&gt;&lt;hr&gt;&lt;blockquote&gt;陈皓：我给大约40多家公司做过相应的技术咨询和解决过很多技术问题，绝大多数公司都是因为性能和稳定性的问题来找我的，我给这些公司解决问题的时候，基本都是这样的Pattern：一开始，发现都是一些技术知识点的问题；然后，马上进入到系统架构方面方面的问题；当再解决架构问题的时候，我发现，已经是软件工程的问题；而软件工程问题的后面，又是公司管理上的问题；而公司管理的问题，结果又到了人的问题上；而人的问题，又到了公司文化的问题……&lt;br&gt;我能做的是，观察这个公司的业务形态、和相关的思维方式，以及现有的资源和相应的技术实力，帮助他们从技术到管理上缓解或改善现有的问题。&lt;br&gt;——&lt;a href=&quot;http://coolshell.cn/articles/17446.html&quot;&gt;这多年来我一直在钻研的技术&lt;/a&gt;&lt;/blockquote&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-06-09-37653890</guid>
<pubDate>Sat, 09 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>编程哲学（一）：愚者无疑，智者多虑</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-06-04-37653499.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37653499&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-306b63f723955845a825ec8d17ff5c48_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;620&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-306b63f723955845a825ec8d17ff5c48&quot; data-watermark-src=&quot;v2-b4018e8d7dd8d710944decbcea8181be&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;自从事软件行业以来，我接触到了很多有想法的人，他们的观点令人震撼，让人耳目一新。&lt;br&gt;然而，这样的好想法却从来没有在大雅之堂，或者在公开交流时被提及。&lt;br&gt;有想法的人们，总是在仔细考虑，暗自琢磨。&lt;/p&gt;&lt;p&gt;毕竟，&lt;b&gt;愚者无疑，智者多虑。&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;The whole problem with the world is that fools and fanatics are always so certain of themselves, and wiser people so full of doubts. ——Bertrand Rusell&lt;/blockquote&gt;&lt;p&gt;即便如此，我也想要讨论一些“编程哲学”，并不介意被认为愚蠢。&lt;br&gt;因为，&lt;a href=&quot;https://www.oschina.net/news/79166/apache-foundation-ceo-decades-views&quot;&gt;我太愚蠢了，我写不出好代码&lt;/a&gt;。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/25884108/&quot;&gt;软件需要哲学家&lt;/a&gt;，是的，我深以为然。&lt;/p&gt;&lt;blockquote&gt;我们需要伟大的思想家——菲奥多尔·陀思妥耶夫斯基、大卫·休谟、亚里士多德、让·保罗·萨特、本·富兰克林、伽利略·伽利莱、伯特兰·罗素和阿尔伯特·爱因斯坦这样的人来指引我们走出软件的黑暗世纪：这个每一寸都深陷黑暗和无知的时代一定会像中世纪一样被人铭记。&lt;/blockquote&gt;&lt;p&gt;即使我们用着不同的编程语言，&lt;b&gt;表达&lt;/b&gt;的也是同样的想法。&lt;br&gt;这些想法，是如何组织代码，如何促使软件发展，如何对概念进行抽象，&lt;br&gt;如何沟通，如何传递我们的知识，等等。&lt;/p&gt;&lt;p&gt;&lt;b&gt;语言本身的影响会随着深入程度而逐渐降低。&lt;/b&gt;&lt;/p&gt;&lt;blockquote&gt;社会是一个圆锥，每个人都在圆锥的高上面爬。你和同等水平不同领域的人的距离就是你所处平面圆的半径。只要你的水平更高，你接触别的领域的人的距离就会更短。——&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3OTU0NjAwNg==&amp;amp;idx=1&amp;amp;mid=2659462247&amp;amp;sn=321813de2e521a4df718f3678ff7a34b&quot;&gt;趣谈:实力把我们推向圆锥顶点&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;我们想要深入钻研任何领域，都不可避免的进行哲学上的思辨，&lt;br&gt;考虑很多与具体工作无关的指导思想，建立各种知识之间的联系。&lt;/p&gt;&lt;p&gt;任何事情要想做到极致，就不得不进行一系列的&lt;b&gt;理性思考&lt;/b&gt;，总结和反思。&lt;br&gt;而这些思考才是从业者的核心价值。&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-06-04-37653499</guid>
<pubDate>Mon, 04 Jun 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（十）：Curry-Howard-Lambek correspondance</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-04-06-35322455.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35322455&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-68f59b73edf64aba20eb0751897cf12a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;698&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们介绍了笛卡尔闭范畴，它给出了简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统 &lt;equation&gt;\lambda^{unit,\times,\to}&lt;/equation&gt; 的语义，&lt;br&gt;我们还看到了笛卡尔闭范畴与柯里化之间的关系。&lt;/p&gt;&lt;p&gt;结合《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34669807&quot;&gt;你好，类型&lt;/a&gt;》系列文章，&lt;br&gt;到目前为止我们已经有了，类型理论，逻辑学和范畴论的知识基础了。&lt;br&gt;现在我们介绍&lt;b&gt;Curry-Howard-Lambek correspondence&lt;/b&gt;，将三者联系起来。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 类型方面&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9f2137b50469a4455a8cf4a323e8f904_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;180&quot; data-rawheight=&quot;127&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;参考《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34679052&quot;&gt;你好，类型（二）：Lambda calculus&lt;/a&gt;》，我们来回顾一下简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.1 语法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;equation&gt;t::=x|tu|\lambda x.t&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;例子： &lt;equation&gt;\lambda x.x+1&lt;/equation&gt; ， &lt;equation&gt;\lambda f.\lambda x.fx&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;1.2 类型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;基本类型（basic types）， &lt;equation&gt;B::=\iota|\cdots&lt;/equation&gt; &lt;br&gt;一般类型（general types）， &lt;equation&gt;T::=B|T\to T|T\times T&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;例子： &lt;equation&gt;\iota\to\iota\to\iota&lt;/equation&gt; ， &lt;equation&gt;(\iota\to\iota)\to\iota&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;1.3 类型推导规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;（1） &lt;equation&gt;\frac{~}{\Gamma,x:t\vdash x:T}&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\frac{\Gamma\vdash t:T~~~~\Gamma\vdash u:U}{\Gamma\vdash\left\langle t,u\right\rangle:T\times U}&lt;/equation&gt; ， &lt;equation&gt;\frac{\Gamma\vdash v:T\times U}{\Gamma\vdash\pi_1v:T}&lt;/equation&gt; ， &lt;equation&gt;\frac{\Gamma\vdash v:T\times U}{\Gamma\vdash\pi_2v:U}&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;\frac{\Gamma,x:U\vdash t:T}{\Gamma\vdash\lambda x.t:U\to T}&lt;/equation&gt; ， &lt;equation&gt;\frac{\Gamma\vdash t:U\to T~~~~\Gamma\vdash u:U}{\Gamma\vdash tu:T}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中， &lt;equation&gt;\pi_1\left\langle v_1,v_2 \right\rangle=v_1&lt;/equation&gt; ， &lt;equation&gt;\pi_2\left\langle v_1,v_2 \right\rangle=v_2&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 逻辑方面&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-be588be0a43fee16751448824874cb51_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;318&quot; data-rawheight=&quot;254&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;参考《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34727603&quot;&gt;你好，类型（四）：Propositional logic&lt;/a&gt;》，&lt;br&gt;我们构建一个只包含逻辑联接词 &lt;equation&gt;\wedge&lt;/equation&gt; 和 &lt;equation&gt;\to&lt;/equation&gt; 的命题逻辑系统。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.1 逻辑推导规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;（1） &lt;equation&gt;\frac{~}{\Gamma,A\vdash A}&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\frac{\Gamma\vdash A~~~~\Gamma\vdash B}{\Gamma\vdash A\wedge B}&lt;/equation&gt; ， &lt;equation&gt;\frac{\Gamma\vdash A\wedge B}{\Gamma\vdash A}&lt;/equation&gt; ， &lt;equation&gt;\frac{\Gamma\vdash A\wedge B}{\Gamma\vdash B}&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;\frac{\Gamma,A\vdash B}{\Gamma\vdash A\to B}&lt;/equation&gt; ， &lt;equation&gt;\frac{\Gamma\vdash A\to B~~~~\Gamma\vdash A}{\Gamma\vdash B}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 Curry-Howard correspondence&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们看到，只要将逻辑系统中的 &lt;equation&gt;\wedge&lt;/equation&gt; 和 &lt;equation&gt;\to&lt;/equation&gt; ，&lt;b&gt;替换&lt;/b&gt;成简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算中的 &lt;equation&gt;\times&lt;/equation&gt; 和 &lt;equation&gt;\to&lt;/equation&gt; ，&lt;br&gt;那么这两个系统从&lt;b&gt;推导规则&lt;/b&gt;上来看是一致的。&lt;/p&gt;&lt;p&gt;逻辑中的&lt;b&gt;命题&lt;/b&gt;，对应了简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算中的&lt;b&gt;类型&lt;/b&gt;，&lt;br&gt;逻辑中命题的&lt;b&gt;证明&lt;/b&gt;，对应了简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算中的&lt;b&gt;项（的类型断言）&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;命题 &lt;equation&gt;A\to B&lt;/equation&gt; ，可以这样理解，&lt;br&gt;如果该命题可证，则存在将 &lt;equation&gt;A&lt;/equation&gt; 的证明转换为 &lt;equation&gt;B&lt;/equation&gt; 的证明的构建过程（construction）。&lt;br&gt;命题 &lt;equation&gt;A\wedge B&lt;/equation&gt; ，可以这样理解，它是 &lt;equation&gt;A&lt;/equation&gt; 和 &lt;equation&gt;B&lt;/equation&gt; 的证明序对（pair）。&lt;/p&gt;&lt;p&gt;考虑到以上命题逻辑与类型之间的对应关系，&lt;br&gt;我们可以说，&lt;b&gt;程序就是证明&lt;/b&gt;（proofs as programs）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 范畴论方面&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-134b8db97c09c1885daef4285fa9ee5b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;364&quot; data-rawheight=&quot;320&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;结合《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35281476&quot;&gt;语言背后的代数学（九）：笛卡尔闭范畴&lt;/a&gt;》，&lt;br&gt;我们给出了简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算的范畴论解释。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.1 对象&lt;/b&gt;&lt;/p&gt;&lt;p&gt;将简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统的类型，解释为笛卡尔闭范畴 &lt;equation&gt;C&lt;/equation&gt; 中的对象。&lt;br&gt; &lt;equation&gt;\mathscr{C}[\![\sigma\times\tau]\!]=\mathscr{C}[\![\sigma]\!]\times\mathscr{C}[\![\tau]\!]&lt;/equation&gt; &lt;br&gt; &lt;equation&gt;\mathscr{C}[\![\sigma\to\tau]\!]=\mathscr{C}[\![\sigma]\!]\to\mathscr{C}[\![\tau]\!]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;3.2 箭头&lt;/b&gt;&lt;/p&gt;&lt;p&gt;将带有自变量项，解释为从自变量类型到项类型的箭头。&lt;br&gt; &lt;equation&gt;\mathscr{C}[\![\Gamma\vdash M:\sigma]\!]=\mathscr{C}[\![\Gamma]\!]\to\mathscr{C}[\![\sigma]\!]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;3.3 Curry-Howard-Lambek correspondance&lt;/b&gt;&lt;/p&gt;&lt;p&gt;根据简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统中的推导规则，&lt;br&gt;我们可以为范畴 &lt;equation&gt;C&lt;/equation&gt; 添加对象和箭头之间的约束条件，&lt;/p&gt;&lt;p&gt;（1） &lt;equation&gt;\frac{~}{\pi_2:\Gamma\times A\to A}&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\frac{f:\Gamma\to A~~~~g:\Gamma\to B}{\left\langle f,g\right\rangle:\Gamma\to A\times B}&lt;/equation&gt; ， &lt;equation&gt;\frac{f:\Gamma\to A\times B}{\pi_1\circ f:\Gamma\to A}&lt;/equation&gt; ， &lt;equation&gt;\frac{f:\Gamma\to A\times B}{\pi_2\circ f:\Gamma\to B}&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;\frac{f:\Gamma\times A\to B}{g_f:\Gamma\to B^A}&lt;/equation&gt; ， &lt;equation&gt;\frac{f_1:\Gamma\to B^A~~~~f_2:\Gamma\to A}{e\circ\left\langle f_1,f_2\right\rangle:\Gamma\to B}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;g_f=\Gamma\to B^A&lt;/equation&gt; 是一个箭头，和 &lt;equation&gt;e:B^A\times A\to B&lt;/equation&gt; 的定义，&lt;br&gt;可以参考&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35281476&quot;&gt;前一篇&lt;/a&gt;文章中关于笛卡尔闭范畴的定义。&lt;/p&gt;&lt;p&gt;笛卡尔闭范畴作为简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统的语义模型，&lt;br&gt;范畴中箭头之间约束关系，与类型推导规则是一致的，&lt;br&gt;而根据Curry-Howard correspondence，类型推导规则与命题逻辑又是一致的。&lt;/p&gt;&lt;p&gt;因此，类型理论，逻辑学和范畴论产生了关联，&lt;br&gt;这种三者的对应关系，称为&lt;b&gt;Curry-Howard-Lambek correspondance&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-acf619f5ae01b95c6c7b99bd7d980de3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;292&quot; data-rawheight=&quot;233&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;本文介绍了Curry-Howard-Lambek correspondance，&lt;br&gt;它将本来毫无关系的三个学科联系在了一起，&lt;br&gt;类型理论与程序和计算相关，逻辑学与证明（论）相关，范畴论与模型（论）和代数学相关。&lt;/p&gt;&lt;p&gt;本系列文章到此结束了，与代数学和范畴论相关的内容其实还有很多，&lt;br&gt;例如，quotient algebra，comonad，adjoint functor，free monoid，等等概念，&lt;br&gt;&lt;b&gt;书山有路勤为径，学海无涯苦作舟&lt;/b&gt;，让我们一起努力吧。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34669807&quot;&gt;你好，类型（一）：开篇&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34727603&quot;&gt;你好，类型（四）：Propositional logic&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35281476&quot;&gt;语言背后的代数学（九）：笛卡尔闭范畴&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence&quot;&gt;Curry–Howard correspondence&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://wiki.haskell.org/Curry-Howard-Lambek_correspondence&quot;&gt;Curry-Howard-Lambek correspondence&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cs.ox.ac.uk/samson.abramsky/gsem/chll.pdf&quot;&gt;The Curry-Howard Correspondence, and beyond&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://disi.unitn.it/~bernardi/RSISE11/Papers/curry-howard.pdf&quot;&gt;Lectures on the curry-howard Isomorphism&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Intuitionistic_logic&quot;&gt;Intuitionistic logic&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-04-06-35322455</guid>
<pubDate>Fri, 06 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（九）：笛卡尔闭范畴</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-04-05-35281476.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35281476&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-249328aa0e740de961f0a8ce0c329c51_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;775&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们简单的介绍了一些范畴论相关的内容，&lt;br&gt;&lt;b&gt;范畴&lt;/b&gt;由一些&lt;b&gt;对象&lt;/b&gt;和&lt;b&gt;箭头&lt;/b&gt;组成，范畴之间的箭头称为&lt;b&gt;函子&lt;/b&gt;，&lt;br&gt;函子之间的一族箭头称为&lt;b&gt;自然变换&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;范畴的对象不一定是集合，所有的箭头也不一定构成一个集合。&lt;br&gt;如果一个范畴 &lt;equation&gt;C&lt;/equation&gt; ，它的对象都是集合，所有的箭头也构成了一个集合，&lt;br&gt;就称该范畴是一个&lt;b&gt;小范畴&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Category_(mathematics)#Small_and_large_categories&quot;&gt;small categories&lt;/a&gt;）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 定义域和值域&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-07a4c0b329a05ec427d5f5b9e9681ba6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;318&quot; data-rawheight=&quot;208&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在集合论中，函数自变量所有可取值的集合，称为函数的&lt;b&gt;定义域&lt;/b&gt;，&lt;br&gt;给定函数 &lt;equation&gt;f:A\to B&lt;/equation&gt; ，其中 &lt;equation&gt;A&lt;/equation&gt; 就是 &lt;equation&gt;f&lt;/equation&gt; 的定义域，记为 &lt;equation&gt;D_f&lt;/equation&gt; ，&lt;br&gt;集合 &lt;equation&gt;f(A)=\{f(x)|x\in A\}&lt;/equation&gt; ，称为 &lt;equation&gt;f&lt;/equation&gt; 的&lt;b&gt;值域&lt;/b&gt;，记为 &lt;equation&gt;R_f&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;在范畴论中，箭头也有定义域和值域的概念。&lt;br&gt;箭头 &lt;equation&gt;f:a\to b&lt;/equation&gt; ，表示了对象 &lt;equation&gt;a&lt;/equation&gt; 和 &lt;equation&gt;b&lt;/equation&gt; 之间的关系，&lt;br&gt;我们称 &lt;equation&gt;a&lt;/equation&gt; 为箭头 &lt;equation&gt;f&lt;/equation&gt; 的&lt;b&gt;定义域&lt;/b&gt;（domain），记为 &lt;equation&gt;dom~f&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;b&lt;/equation&gt; 为箭头 &lt;equation&gt;f&lt;/equation&gt; 的&lt;b&gt;值域&lt;/b&gt;（codomain），记为 &lt;equation&gt;cod~f&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;由此，我们还可以定义范畴 &lt;equation&gt;C&lt;/equation&gt; 中，从对象 &lt;equation&gt;a&lt;/equation&gt; 到对象 &lt;equation&gt;b&lt;/equation&gt; 所有箭头的集合，&lt;br&gt; &lt;equation&gt;hom(a,b)=\{f|f\in C,dom~f=a,cod~f=b\}&lt;/equation&gt; ，常被称为&lt;b&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Morphism#Definition&quot;&gt;hom-set&lt;/a&gt;&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 笛卡尔闭范畴&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7359d35caef3fc0840b8d5ea4b17cc0f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;343&quot; data-rawheight=&quot;147&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;笛卡尔闭范畴是一种带有附加结构的范畴，这个名字虽然不是那么熟悉，&lt;br&gt;而实际上，我们经常遇到它。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.1 笛卡尔积&lt;/b&gt;&lt;/p&gt;&lt;p&gt;两个集合 &lt;equation&gt;X&lt;/equation&gt; 和 &lt;equation&gt;Y&lt;/equation&gt; 的&lt;b&gt;笛卡尔积&lt;/b&gt;，是以下所有可能有序对构成的集合，&lt;br&gt; &lt;equation&gt;X\times Y=\{(x,y)|x\in X,y\in Y\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 笛卡尔积上的函数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;equation&gt;f:X\times Y\to Z&lt;/equation&gt; ，是从笛卡尔积 &lt;equation&gt;X\times Y&lt;/equation&gt; 到 &lt;equation&gt;Z&lt;/equation&gt; 的函数，&lt;br&gt;我们可以用两种不同的视角来看待它，&lt;/p&gt;&lt;p&gt;（1）它是一个一元函数，参数取遍 &lt;equation&gt;X\times Y&lt;/equation&gt; 中的所有元素。&lt;br&gt;（2）它是一个二元函数，一个参数来自于 &lt;equation&gt;X&lt;/equation&gt; ，另一个来自于 &lt;equation&gt;Y&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;原则上，这两种理解应该是不同的，然而它们却是等价的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3 柯里化&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6059ea733638bb9ffd73dcabe9510b88_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;496&quot; data-rawheight=&quot;232&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;笛卡尔闭范畴就是反映这一类性质的数学结构，&lt;br&gt;一个范畴中，定义在乘积对象 &lt;equation&gt;a\times b&lt;/equation&gt; 上的箭头 &lt;equation&gt;f&lt;/equation&gt; ，&lt;br&gt;总是可以“自然的”由定义在某一个对象 &lt;equation&gt;a&lt;/equation&gt; 或 &lt;equation&gt;b&lt;/equation&gt; 上的箭头来决定。&lt;/p&gt;&lt;p&gt;这就是&lt;b&gt;柯里化&lt;/b&gt;（curring）的概念，&lt;br&gt;将一个二元函数柯里化指的是，将它看成一个一元函数，这个函数返回另一个一元函数。&lt;/p&gt;&lt;p&gt;假设 &lt;equation&gt;f:X\times Y\to Z&lt;/equation&gt; 是一个函数，&lt;br&gt;令 &lt;equation&gt;Z^Y=\{f|f(y)\in Z,y\in Y\}&lt;/equation&gt; 是所有 &lt;equation&gt;Y&lt;/equation&gt; 到 &lt;equation&gt;Z&lt;/equation&gt; 的函数，&lt;br&gt;则存在唯一的 &lt;equation&gt;g=X\to Z^Y&lt;/equation&gt; ，使得 &lt;equation&gt;g(x)(y)=f(x,y)&lt;/equation&gt; ， &lt;equation&gt;\forall x\in X,y\in Y&lt;/equation&gt; 。&lt;br&gt;函数 &lt;equation&gt;g&lt;/equation&gt; 称为 &lt;equation&gt;f&lt;/equation&gt; 的&lt;b&gt;柯里化&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;用hom-set的术语来表述就是，存在一个一一映射，使得，&lt;br&gt; &lt;equation&gt;hom(X\times Y,Z)\cong hom(X,Z^Y)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;2.4 Cartesian Closed&lt;/b&gt;&lt;/p&gt;&lt;p&gt;将以上柯里化的概念推广到范畴论中，我们就有，&lt;br&gt;一个&lt;b&gt;笛卡尔闭范畴&lt;/b&gt;（cartesian closed category） &lt;equation&gt;C&lt;/equation&gt; ，是满足以下几个额外条件的范畴。&lt;/p&gt;&lt;p&gt;（1） &lt;equation&gt;C&lt;/equation&gt; 中存在一个对象 &lt;equation&gt;1&lt;/equation&gt; ，使得对于任意对象 &lt;equation&gt;A\in C&lt;/equation&gt; ，有唯一的箭头 &lt;equation&gt;A\to 1&lt;/equation&gt; ，&lt;br&gt;这样的对象 &lt;equation&gt;1&lt;/equation&gt; ，称为&lt;b&gt;终对象&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Initial_and_terminal_objects&quot;&gt;terminal object&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;（2）对于任意两个对象 &lt;equation&gt;X&lt;/equation&gt; 和 &lt;equation&gt;Y&lt;/equation&gt; ，范畴 &lt;equation&gt;C&lt;/equation&gt; 中存在一个对象 &lt;equation&gt;X\times Y&lt;/equation&gt; ，&lt;br&gt;以及两个箭头 &lt;equation&gt;p_1&lt;/equation&gt; 和 &lt;equation&gt;p_2&lt;/equation&gt; ，使得， &lt;equation&gt;p_1:X\times Y\to X&lt;/equation&gt; ， &lt;equation&gt;p_2:X\times Y\to Y&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;（3）对于任意两个对象 &lt;equation&gt;Y&lt;/equation&gt; 和 &lt;equation&gt;Z&lt;/equation&gt; ，&lt;br&gt;范畴 &lt;equation&gt;C&lt;/equation&gt; 中存在一个对象 &lt;equation&gt;Z^Y&lt;/equation&gt; ，以及一个箭头 &lt;equation&gt;e:Z^Y\times Y\to Z&lt;/equation&gt; ，使得，&lt;br&gt;对于任意的箭头 &lt;equation&gt;f:X\times Y\to Z&lt;/equation&gt; ，存在唯一的箭头 &lt;equation&gt;g:X\to Z^Y&lt;/equation&gt; ，&lt;br&gt;有 &lt;equation&gt;f=e\circ (g\times I)&lt;/equation&gt; 恒成立。&lt;/p&gt;&lt;p&gt;即， &lt;equation&gt;(e\circ (g\times I))(X\times Y)=e((g\times I)(X\times Y))=e(Z^Y\times Y)=Z&lt;/equation&gt; 。&lt;br&gt;其中 &lt;equation&gt;I:Y\to Y&lt;/equation&gt; ，为对象 &lt;equation&gt;Y&lt;/equation&gt; 的恒等箭头， &lt;equation&gt;Z^Y&lt;/equation&gt; 称为&lt;b&gt;指数对象&lt;/b&gt;（exponential object）。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ff51be8d96c9c10cb2fb0995941cd926_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;470&quot; data-rawheight=&quot;302&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;3. 项的解释&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35170799&quot;&gt;第六篇&lt;/a&gt;中，为了解释简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算，&lt;br&gt;我们为每一个 &lt;equation&gt;\lambda&lt;/equation&gt; 项，找到了一个 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数中数学对象与之对应，&lt;br&gt;简要的说，我们用 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数的载体 &lt;equation&gt;A^\sigma&lt;/equation&gt; 来解释基本类型 &lt;equation&gt;\sigma&lt;/equation&gt; ，&lt;br&gt;用载体上的函数集 &lt;equation&gt;A^{\sigma\to\tau}&lt;/equation&gt; 来解释类型为 &lt;equation&gt;\sigma\to\tau&lt;/equation&gt; 的所有函数。&lt;/p&gt;&lt;p&gt;现在有了笛卡尔闭范畴，我们准备为每一个&lt;b&gt;基本类型&lt;/b&gt;选择范畴中的一个对象，&lt;br&gt;而将&lt;b&gt;项常量&lt;/b&gt; &lt;equation&gt;b&lt;/equation&gt; 解释为范畴中的一个箭头 &lt;equation&gt;unit\to\mathscr{A}[\![b]\!]&lt;/equation&gt; （原因在下文解释），&lt;br&gt;其中 &lt;equation&gt;\mathscr{A}[\![\cdot]\!]&lt;/equation&gt; 为我们在Henkin模型中定义的&lt;b&gt;含义函数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.1 封闭项的解释&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们这样定义一个&lt;b&gt;含义函数&lt;/b&gt; &lt;equation&gt;\mathscr{C}[\![\cdot]\!]&lt;/equation&gt; ，&lt;br&gt;（1） &lt;equation&gt;\mathscr{C}[\![unit]\!]=unit&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\mathscr{C}[\![b]\!]=unit\to\mathscr{A}[\![b]\!]&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;\mathscr{C}[\![\sigma\times\tau]\!]=\mathscr{C}[\![\sigma]\!]\times\mathscr{C}[\![\tau]\!]&lt;/equation&gt; &lt;br&gt;（4） &lt;equation&gt;\mathscr{C}[\![\sigma\to\tau]\!]=\mathscr{C}[\![\sigma]\!]\to\mathscr{C}[\![\tau]\!]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;3.2 带有自由变量的项&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;\Gamma\vdash M:\sigma&lt;/equation&gt; 是一个含有自由变量的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，&lt;br&gt;则在笛卡尔闭范畴中，它应该解释为从自由变量的语义对象到 &lt;equation&gt;\sigma&lt;/equation&gt; 的语义对象的一个箭头，&lt;br&gt; &lt;equation&gt;\mathscr{C}[\![\Gamma\vdash M:\sigma]\!]=\mathscr{C}[\![\Gamma]\!]\to\mathscr{C}[\![\sigma]\!]&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;值得一提的是，这里说明了，项常量 &lt;equation&gt;b&lt;/equation&gt; 为什么不能被解释为范畴中的对象，&lt;br&gt;而是解释成了箭头 &lt;equation&gt;unit\to\mathscr{A}[\![b]\!]&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;其中，类型上下文 &lt;equation&gt;\Gamma&lt;/equation&gt; 的解释，定义如下，&lt;br&gt;（1） &lt;equation&gt;\mathscr{C}[\![\varnothing]\!]=unit&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\mathscr{C}[\![\Gamma,x:\sigma]\!]=\mathscr{C}[\![\Gamma]\!]\times\mathscr{C}[\![\sigma]\!]&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了笛卡尔闭范畴，是一种具有特殊结构的范畴，&lt;br&gt;它补充了柯里化这一概念所需满足的约束条件。&lt;/p&gt;&lt;p&gt;接着我们用笛卡尔闭范畴解释了，&lt;br&gt;带有&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34815896&quot;&gt;单位类型&lt;/a&gt;，乘积类型的简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算 &lt;equation&gt;\lambda^{unit,\times,\to}&lt;/equation&gt; 。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34815896&quot;&gt;你好，类型（六）：Simply typed lambda calculus&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35170799&quot;&gt;语言背后的代数学（六）：Henkin模型&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Category_(mathematics)#Small_and_large_categories&quot;&gt;Small and Large Categories&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Class_(set_theory)&quot;&gt;Class&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/26684696/&quot;&gt;Category Theory for Computing Science&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cartesian_closed_category&quot;&gt;Cartesian closed category&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-04-05-35281476</guid>
<pubDate>Thu, 05 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（八）：范畴</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-04-04-35237925.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35237925&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8fd16e3275832ced282b1a9c125bb8c2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;775&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文中，我们用群，拓扑空间，CPO作为例子，&lt;br&gt;来说明什么是&lt;b&gt;数学结构&lt;/b&gt;，以及数学结构是如何通过映射来保持的。&lt;br&gt;群同态保持了群结构，连续映射保持了拓扑结构，连续函数保持了完全偏序结构。&lt;/p&gt;&lt;p&gt;那么群结构与拓扑结构之间是否有联系呢？&lt;br&gt;我们能否建立拓扑空间与群之间的对应关系呢？&lt;/p&gt;&lt;p&gt;在代数拓扑中，就存在这样的例子，&lt;br&gt;人们找到了和拓扑空间相关的群论概念，例如基本群和同调群，&lt;br&gt;拓扑空间的连续映射可以导出这些群的群同态。&lt;/p&gt;&lt;p&gt;这就为了人们使用代数学方法研究其他数学分支，奠定了基础，&lt;br&gt;实际上，最原始的范畴论想法也是起源于此。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 图示法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在前一篇中我们学过了&lt;b&gt;幺半群&lt;/b&gt;，&lt;br&gt;它指的是一个集合 &lt;equation&gt;M&lt;/equation&gt; ，以及 &lt;equation&gt;M&lt;/equation&gt; 上的二元运算 &lt;equation&gt;\cdot&lt;/equation&gt; ，满足以下两个条件，&lt;br&gt;（1） &lt;equation&gt;\forall x,y,z\in M&lt;/equation&gt; ， &lt;equation&gt;(x\cdot y)\cdot z=x\cdot (y\cdot z)&lt;/equation&gt; ，&lt;br&gt;（2） &lt;equation&gt;\exists e\in M&lt;/equation&gt; ， &lt;equation&gt;\forall x\in M&lt;/equation&gt; ， &lt;equation&gt;x\cdot e=e\cdot x=x&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;这两个条件除了可以用等式来表示，还可以用&lt;b&gt;图&lt;/b&gt;（diagram）来表示，&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1bd56c30e34a673a998895029362c270_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1138&quot; data-rawheight=&quot;234&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们称以上两张图都是&lt;b&gt;可交换的&lt;/b&gt;（commutative），&lt;br&gt;即，沿着不同的路径进行运算，只要起点和终点相同，则运算的结果就相同。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;&amp;lt;x,y,z&amp;gt;\mapsto &amp;lt;x,yz&amp;gt;\mapsto x(yz)&lt;/equation&gt; ，总是等于 &lt;equation&gt;&amp;lt;x,y,z&amp;gt;\mapsto &amp;lt;xy,z&amp;gt;\mapsto (xy)z&lt;/equation&gt; ，&lt;br&gt;即， &lt;equation&gt;x(yz)=(xy)z&lt;/equation&gt; ，表明 &lt;equation&gt;M&lt;/equation&gt; 中元素的运算满足&lt;b&gt;结合律&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;又例， &lt;equation&gt;&amp;lt;0,x&amp;gt;\mapsto &amp;lt;e,x&amp;gt;\mapsto ex&lt;/equation&gt; ，总是等于 &lt;equation&gt;&amp;lt;0,x&amp;gt;\mapsto x&lt;/equation&gt; ，即 &lt;equation&gt;ex=x&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;&amp;lt;x,0&amp;gt;\mapsto &amp;lt;x,e&amp;gt;\mapsto xe&lt;/equation&gt; ，总是等于 &lt;equation&gt;&amp;lt;x,0&amp;gt;\mapsto x&lt;/equation&gt; ，即 &lt;equation&gt;xe=x&lt;/equation&gt; 。&lt;br&gt;因此， &lt;equation&gt;ex=x=xe&lt;/equation&gt; ，表明 &lt;equation&gt;M&lt;/equation&gt; 中存在&lt;b&gt;幺元&lt;/b&gt; &lt;equation&gt;e&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;所以，我们可以用以上两个图表，作为幺半群的定义，称为&lt;b&gt;图示法&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;另一方面，考虑在集合论中讨论映射的时候，一般都不写具体元素，还可以表示为，&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65f472da6c217b0f01bbc9704f4df946_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1070&quot; data-rawheight=&quot;218&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中， &lt;equation&gt;\mu:M\times M\to M&lt;/equation&gt; ， &lt;equation&gt;\eta:1\to M&lt;/equation&gt; ，是两个函数， &lt;equation&gt;1=\{0\}&lt;/equation&gt; 是只有一个元素的集合。&lt;/p&gt;&lt;p&gt;用图示法来表示幺半群，更具一般性。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 范畴&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;范畴是一个数学概念，也可以用图示法来表示。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-07f823a724618aaf5e160d394a7eab6e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;178&quot; data-rawheight=&quot;161&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;一个&lt;b&gt;范畴&lt;/b&gt; &lt;equation&gt;Cat&lt;/equation&gt; 由一系列&lt;b&gt;对象&lt;/b&gt;（object）和&lt;b&gt;箭头&lt;/b&gt;（arrow）组成。&lt;br&gt;对于每一个箭头 &lt;equation&gt;f&lt;/equation&gt; ，有两个对象与之关联，&lt;br&gt;称为箭头 &lt;equation&gt;f&lt;/equation&gt; 的&lt;b&gt;定义域&lt;/b&gt;（domain）和&lt;b&gt;值域&lt;/b&gt;（codomain）。&lt;/p&gt;&lt;p&gt;并且，还要满足以下几条规则，&lt;br&gt;（1）对于每一个对象 &lt;equation&gt;a&lt;/equation&gt; ，存在&lt;b&gt;恒等箭头&lt;/b&gt;（identity arrow）， &lt;equation&gt;i:a\to a&lt;/equation&gt; &lt;br&gt;（2）箭头满足&lt;b&gt;结合律&lt;/b&gt;，对于任意的箭头 &lt;equation&gt;f,g,h&lt;/equation&gt; ，有 &lt;equation&gt;(f\cdot g)\cdot h=f\cdot (g\cdot h)&lt;/equation&gt; &lt;br&gt;（3）箭头的集合在箭头组合运算下是&lt;b&gt;封闭的&lt;/b&gt;&lt;/p&gt;&lt;p&gt;其中， &lt;equation&gt;f\cdot g&lt;/equation&gt; 表示 &lt;equation&gt;g&lt;/equation&gt; 和 &lt;equation&gt;f&lt;/equation&gt; 的组合运算，它也是一个箭头，其中 &lt;equation&gt;g&lt;/equation&gt; 的值域是 &lt;equation&gt;f&lt;/equation&gt; 的定义域。&lt;/p&gt;&lt;p&gt;例子：&lt;br&gt;所有的集合，以集合为对象，集合之间的映射作为箭头，构成了一个范畴，&lt;br&gt;所有的群，以群作为对象，群同态作为箭头，构成了一个范畴，&lt;br&gt;所有的拓扑空间，以拓扑空间作为对象，拓扑空间之间的连续映射为箭头，构成了一个范畴。&lt;/p&gt;&lt;p&gt;以上三个例子中，&lt;br&gt;范畴中的对象都是集合，箭头都是映射，这就很容易造成误解。&lt;br&gt;因为，&lt;b&gt;范畴中的对象可以不是集合，箭头也可以不是映射，&lt;br&gt;&lt;/b&gt;理解这一点至关重要。&lt;/p&gt;&lt;p&gt;例如，完全偏序 &lt;equation&gt;(D,\leqslant)&lt;/equation&gt; ，&lt;br&gt;以 &lt;equation&gt;D&lt;/equation&gt; 中的元素作为对象，以 &lt;equation&gt;x\leqslant y&lt;/equation&gt; 作为 &lt;equation&gt;x,y&lt;/equation&gt; 之间的箭头，同样构成了一个范畴。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 函子&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;函子就是两个范畴之间的箭头。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9a2d8a5e543c0e1e27695a353869dda1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;436&quot; data-rawheight=&quot;243&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;一个&lt;b&gt;函子&lt;/b&gt; &lt;equation&gt;F&lt;/equation&gt; 是范畴 &lt;equation&gt;C&lt;/equation&gt; 到范畴 &lt;equation&gt;D&lt;/equation&gt; 的箭头， &lt;equation&gt;F:C\to D&lt;/equation&gt; ，它满足以下条件，&lt;br&gt; &lt;equation&gt;F&lt;/equation&gt; 把 &lt;equation&gt;C&lt;/equation&gt; 中的对象 &lt;equation&gt;c&lt;/equation&gt; 映射为 &lt;equation&gt;D&lt;/equation&gt; 中的对象 &lt;equation&gt;F~c&lt;/equation&gt; ，把 &lt;equation&gt;C&lt;/equation&gt; 中的箭头 &lt;equation&gt;f&lt;/equation&gt; 映射为 &lt;equation&gt;D&lt;/equation&gt; 中的箭头 &lt;equation&gt;F~f&lt;/equation&gt; 。&lt;br&gt;并且， &lt;equation&gt;F~(f\cdot g)=(F~f)\cdot (F~g)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;值得注意的是，等式左边的 &lt;equation&gt;\cdot&lt;/equation&gt; ，表示 &lt;equation&gt;C&lt;/equation&gt; 中的箭头组合运算，&lt;br&gt;等式右边的 &lt;equation&gt;\cdot&lt;/equation&gt; ，表示D&lt;i&gt;D&lt;/i&gt;中的箭头组合运算。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4. 自然变换&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;自然变换&lt;/b&gt;（natural transformation）是&lt;b&gt;一族箭头&lt;/b&gt;，&lt;br&gt;将范畴 &lt;equation&gt;A&lt;/equation&gt; 在一个函子中的像（picture），变换成了另一个函子的像。&lt;/p&gt;&lt;p&gt;给定两个函子 &lt;equation&gt;S,T:A\to B&lt;/equation&gt; ，其中 &lt;equation&gt;A&lt;/equation&gt; 和 &lt;equation&gt;B&lt;/equation&gt; 是范畴。&lt;br&gt;自然变换的每个&lt;b&gt;分量&lt;/b&gt;（components）使下图可交换。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-eed0e9ebd54183d14091dd04da29d37f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;696&quot; data-rawheight=&quot;225&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中， &lt;equation&gt;\tau_a&lt;/equation&gt; 是 &lt;equation&gt;B&lt;/equation&gt; 中的箭头， &lt;equation&gt;\tau_a:Sa\to Ta&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;5. Monad&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;范畴到自身的函子，称为&lt;b&gt;自函子&lt;/b&gt;（endofunctor）。&lt;br&gt;设 &lt;equation&gt;T:X\to X&lt;/equation&gt; 是任意范畴 &lt;equation&gt;X&lt;/equation&gt; 上的自函子，自函子复合之后仍为自函子，&lt;br&gt; &lt;equation&gt;T^2=T\circ T:X\to X&lt;/equation&gt; ， &lt;equation&gt;T^3=T^2\circ T:X\to X&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;\mu:T^2\to T&lt;/equation&gt; 是一个自然变换，其分量为 &lt;equation&gt;\mu_x:T^2x\to Tx&lt;/equation&gt; ， &lt;equation&gt;\forall x\in X&lt;/equation&gt; ，&lt;br&gt;则使用 &lt;equation&gt;\mu&lt;/equation&gt; 可以定义另外两个自然变换，&lt;br&gt; &lt;equation&gt;T\mu:T^3\to T^2&lt;/equation&gt; ，它的分量为 &lt;equation&gt;(T\mu)_x=T(\mu_x):T^3x\to T^2x&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\mu T:T^3\to T^2&lt;/equation&gt; ，它的分量为 &lt;equation&gt;(\mu T)_x=\mu_{Tx}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;范畴 &lt;equation&gt;X&lt;/equation&gt; 上的一个&lt;b&gt;Monad&lt;/b&gt;，指的是三元组 &lt;equation&gt;\left \langle T,\eta,\mu \right \rangle&lt;/equation&gt; ，它们使下图可交换，&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b877301e440b9c0f78a488e7e0022833_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;732&quot; data-rawheight=&quot;194&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中， &lt;equation&gt;T:X\to X&lt;/equation&gt; 是范畴 &lt;equation&gt;X&lt;/equation&gt; 上的自函子， &lt;equation&gt;\eta:I_X\to T&lt;/equation&gt; ， &lt;equation&gt;\mu:T^2\to T&lt;/equation&gt; 是两个自然变换。&lt;/p&gt;&lt;p&gt;值得注意的是，Monad与幺半群的图示法是相似的，&lt;br&gt;只需要将幺半群定义中的 &lt;equation&gt;\times&lt;/equation&gt; ，改写成自函子的复合运算，&lt;br&gt;把单位集合 &lt;equation&gt;1&lt;/equation&gt; ，改写成单位自函子即可。&lt;/p&gt;&lt;p&gt;因此，我们说&lt;b&gt;Monad是自函子范畴上的一个幺半群&lt;/b&gt;。&lt;/p&gt;&lt;blockquote&gt;All told, a monad in X is just a monoid in the category of endofunctors of X, with product x replaced by composition of endofunctors and unit set by the identity endofunctor.&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;6. Hask范畴上的Monad&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果把Haskell语言中的类型作为对象，把类型之间的函数看做箭头，&lt;br&gt;则在函数复合运算下，构成了一个范畴，称为&lt;b&gt;Hask范畴&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;函子&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Haskell中类型类（type class）&lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt;的每一个实例，定义了Hask范畴中的一个函子。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class Functor (f :: * -&amp;gt; *) where
    fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;表示了函子作用在箭头上的结果。&lt;br&gt;作用在对象上，可以使用&lt;code class=&quot;inline&quot;&gt;pure :: a -&amp;gt; f a&lt;/code&gt;来表示。&lt;/p&gt;&lt;p&gt;在Haskell中，一个类型要成为&lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt;的实例，还要满足相应的“&lt;a href=&quot;https://wiki.haskell.org/Functor#Functor_Laws&quot;&gt;Functor Law&lt;/a&gt;”，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fmap id = id
fmap (f . g) = fmap f . fmap g&lt;/code&gt;&lt;p&gt;可以&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Category_theory#Functors&quot;&gt;证明&lt;/a&gt;，这些“Functor Law”刚好使&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;pure&lt;/code&gt;构成了范畴论意义上的函子。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Monad&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Haskell中类型类&lt;code class=&quot;inline&quot;&gt;Monad&lt;/code&gt;的每一个实例，定义了Hask范畴中的一个Monad。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class Functor m =&amp;gt; Monad m where
    return :: a -&amp;gt; m a
    (&amp;gt;&amp;gt;=)  :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b&lt;/code&gt;&lt;p&gt;在Haskell中，一个类型要成为&lt;code class=&quot;inline&quot;&gt;Monad&lt;/code&gt;的实例，还要满足相应的“&lt;a href=&quot;https://wiki.haskell.org/Monad#Monad_class&quot;&gt;Monad Law&lt;/a&gt;”，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;return a &amp;gt;&amp;gt;= k                  =  k a
m        &amp;gt;&amp;gt;= return             =  m
m        &amp;gt;&amp;gt;= (\x -&amp;gt; k x &amp;gt;&amp;gt;= h)  =  (m &amp;gt;&amp;gt;= k) &amp;gt;&amp;gt;= h&lt;/code&gt;&lt;p&gt;可以&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Category_theory#Monads&quot;&gt;证明&lt;/a&gt;，这些“Monad Law”刚好使&lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;=&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;return&lt;/code&gt;构成了范畴论意义上的Monad。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了范畴论相关的一些内容，&lt;br&gt;介绍了什么是&lt;b&gt;范畴&lt;/b&gt;，什么是&lt;b&gt;函子&lt;/b&gt;，什么是&lt;b&gt;自然变换&lt;/b&gt;，&lt;br&gt;这些都是理解笛卡尔闭范畴所必须的。&lt;/p&gt;&lt;p&gt;为了理解什么是范畴，我们列举了前一篇提到的群，拓扑空间，CPO作为例子，&lt;br&gt;还借用了Haskell中的Functor和Monad学习了Hask范畴。&lt;/p&gt;&lt;p&gt;下文我们将继续学习范畴论，&lt;br&gt;理解什么是笛卡尔闭范畴，以及如何用它解释简单类型 &lt;equation&gt;\lambda&lt;/equation&gt; 演算的语义。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Category_(mathematics)&quot;&gt;Category (mathematics)&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Category_theory&quot;&gt;Haskell/Category theory&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1823110/&quot;&gt;Categories for the Working Mathematician&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-04-04-35237925</guid>
<pubDate>Wed, 04 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（七）：数学结构</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-04-03-35196235.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35196235&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27827c397b0021738c85f354a4ac1a29_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;960&quot; data-rawheight=&quot;600&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-27827c397b0021738c85f354a4ac1a29&quot; data-watermark-src=&quot;v2-4b04610094818b4d074320614025cc4b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们介绍了Henkin模型，以及它的环境模型条件和组合模型条件，&lt;br&gt;它们分别为合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项和 &lt;equation&gt;CL&lt;/equation&gt; 项，找到了对应的语义解释。&lt;br&gt;然而这只是简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 的其中一种解释。&lt;/p&gt;&lt;p&gt;另一种常用的解释方式，建立在范畴论基础之上，称为&lt;b&gt;笛卡尔闭范畴&lt;/b&gt;。&lt;br&gt;为了理解这个概念，我们需要补充一些简单的范畴论方面的内容。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 数学结构&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-15c0afbc750cd718cccc5c687d907251_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;386&quot; data-rawheight=&quot;252&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-15c0afbc750cd718cccc5c687d907251&quot; data-watermark-src=&quot;v2-548a7f1498a94ad8562175e088793b5b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;范畴论的研究数学结构的形式化方法，&lt;br&gt;它不考虑具体的数学对象，而是考虑数学对象以及它们之间的联系。&lt;/p&gt;&lt;p&gt;学习范畴论最好的办法，我认为不宜马上从抽象的概念开始，&lt;br&gt;而是先回到具体的例子上面，找到相似性，&lt;b&gt;理解概念被发明的动机&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;因此，我们要先理解什么是&lt;b&gt;数学结构&lt;/b&gt;。&lt;br&gt;后文中，我们会首先介绍最常被提及的群结构，然后再介绍拓扑空间和CPO（完全偏序）。&lt;br&gt;有了这些例子之后，对抽象概念的理解是事半功倍的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 群结构&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c2e40eb216c9642a8ae011d979ebf2f9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;268&quot; data-rawheight=&quot;272&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c2e40eb216c9642a8ae011d979ebf2f9&quot; data-watermark-src=&quot;v2-254492ee31ded3056ba06f187ea2ec1e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;群是一种满足结合律的乘法结构，&lt;br&gt;但是它的运算对象，却并不局限于整数，有理数甚至实数上。&lt;br&gt;因此，群论对概念采用了不同的定义方式，和初等代数有明显的不同。&lt;/p&gt;&lt;p&gt;在初等代数中，我们研究的是具体的运算系统，&lt;br&gt;例如，我们会先介绍什么是自然数，然后再介绍自然数上的四则运算。&lt;br&gt;群论则不然。&lt;/p&gt;&lt;p&gt;它会先抽象的定义满足哪些条件的运算系统是&lt;b&gt;群&lt;/b&gt;，&lt;br&gt;然后再去寻找（或证明）具体的运算系统满足这些条件。&lt;/p&gt;&lt;p&gt;为此，我们先从条件最弱的&lt;b&gt;半群&lt;/b&gt;开始，&lt;br&gt;逐渐增加约束条件，最终认识群结构是怎么建立起来的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;半群&lt;/b&gt;&lt;/p&gt;&lt;p&gt;集合 &lt;equation&gt;G&lt;/equation&gt; 和 &lt;equation&gt;G&lt;/equation&gt; 上满足结合律的二元运算 &lt;equation&gt;\cdot&lt;/equation&gt; ，所形成的代数结构，叫做&lt;b&gt;半群&lt;/b&gt;，记为 &lt;equation&gt;(G,\cdot)&lt;/equation&gt; ，&lt;br&gt;半群运算 &lt;equation&gt;x\cdot y&lt;/equation&gt; ，也常简记为 &lt;equation&gt;xy&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;好在我们&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35017879&quot;&gt;第二篇&lt;/a&gt;中，对“什么是代数”进行了严谨的定义，&lt;br&gt;因此，对这里提到的“代数结构”应该并不陌生，很显然半群是一个代数。&lt;/p&gt;&lt;p&gt;满足半群条件的例子是非常多的，&lt;br&gt;例如，自然数集以及自然数上的乘法运算，构成了一个半群。&lt;/p&gt;&lt;p&gt;值得注意的是，集合和运算要放在一起考虑才行，&lt;br&gt;集合包含了运算对象，运算表明了运算对象之间的关系。&lt;/p&gt;&lt;p&gt;&lt;b&gt;幺半群&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a9acc7bf821b71d3d4bcc269058b8016_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;174&quot; data-rawheight=&quot;164&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;设 &lt;equation&gt;G&lt;/equation&gt; 是半群，元素 &lt;equation&gt;e\in G&lt;/equation&gt; ，称为半群 &lt;equation&gt;G&lt;/equation&gt; 的&lt;b&gt;幺元&lt;/b&gt;，如果 &lt;equation&gt;\forall x\in G&lt;/equation&gt; ， &lt;equation&gt;ex=xe=x&lt;/equation&gt; 。&lt;br&gt;可以证明，如果半群存在幺元，则必定是唯一的。&lt;/p&gt;&lt;p&gt;幺元常被记为 &lt;equation&gt;1_S&lt;/equation&gt; ，或者直接写成 &lt;equation&gt;1&lt;/equation&gt; 。&lt;br&gt;具有幺元的半群，称为&lt;b&gt;幺半群&lt;/b&gt;，记为 &lt;equation&gt;(G,\cdot,e)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;幺半群的例子，我们可以考虑字符串及其连接运算，在连接运算下，空串是幺元。&lt;/p&gt;&lt;p&gt;&lt;b&gt;群&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;G&lt;/equation&gt; 是幺半群，如果它的每个元素都可逆，我们就称它为&lt;b&gt;群&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;所谓可逆指的是， &lt;equation&gt;\forall g\in G&lt;/equation&gt; ， &lt;equation&gt;\exists g^{-1}\in G&lt;/equation&gt; ，使得 &lt;equation&gt;gg^{-1}=g^{-1}g=e&lt;/equation&gt; ，&lt;br&gt;其中 &lt;equation&gt;e\in G&lt;/equation&gt; 为 &lt;equation&gt;G&lt;/equation&gt; 的幺元。&lt;/p&gt;&lt;p&gt;自然数集以及自然数上的乘法运算组成的代数结构，是半群，&lt;br&gt;如果把自然数 &lt;equation&gt;1&lt;/equation&gt; 看做幺元，则构成了一个幺半群，但是它不是群。&lt;br&gt;因为，除了 &lt;equation&gt;1&lt;/equation&gt; 之外，任何自然数都没有逆元。&lt;/p&gt;&lt;p&gt;字符串及其连接运算，构成了一个幺半群，但也不是群，&lt;br&gt;因为，没有任何两个非空字符串连接在一起会得到空串。&lt;/p&gt;&lt;p&gt;下面我们来看一个群的例子。&lt;/p&gt;&lt;p&gt;如果我们把整数集（包含正负整数）看做运算对象的集合，&lt;br&gt;把整数集上的加法运算看做群定义中的二元运算，&lt;br&gt;整数 &lt;equation&gt;0&lt;/equation&gt; 看做加法运算的幺元，则这样的运算系统构成了一个群。&lt;br&gt;因为，每一个整数的相反数，都是它的逆元。&lt;/p&gt;&lt;p&gt;&lt;b&gt;群同态&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1dad98d538dbb99ed7df169371a75acc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;335&quot; data-rawheight=&quot;150&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1dad98d538dbb99ed7df169371a75acc&quot; data-watermark-src=&quot;v2-74213495efd2725607eb2a55d66bdd8e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;有了群之后，很自然的一步我们会考虑两个群是否足够相似，&lt;br&gt;这就需要我们找到两个群之间的对应关系。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;(G,\cdot)&lt;/equation&gt; 和 &lt;equation&gt;(G&#39;,\circ)&lt;/equation&gt; 是两个群，我们把映射 &lt;equation&gt;f:G\to G&#39;&lt;/equation&gt; 称为&lt;b&gt;群同态&lt;/b&gt;，如果 &lt;equation&gt;\forall a,b\in G&lt;/equation&gt; ，&lt;br&gt;都有 &lt;equation&gt;f(a\cdot b)=f(a)\circ f(b)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;f&lt;/equation&gt; 是单射，则称 &lt;equation&gt;f&lt;/equation&gt; 为&lt;b&gt;单同态&lt;/b&gt;，如果 &lt;equation&gt;f&lt;/equation&gt; 是满射，则称 &lt;equation&gt;f&lt;/equation&gt; 为&lt;b&gt;满同态&lt;/b&gt;。&lt;br&gt;如果 &lt;equation&gt;f&lt;/equation&gt; 是双射，则称 &lt;equation&gt;f&lt;/equation&gt; 为&lt;b&gt;群同构&lt;/b&gt;，同构的两个群，记为 &lt;equation&gt;G\cong G&#39;&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;小结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;现在我们理解了半群，幺半群，群，群同态，这些概念放在一起，就是所谓的群结构。&lt;br&gt;结构一般所指的是一些运算规则，或者约束条件。&lt;/p&gt;&lt;p&gt;为了更好的理解数学结构，&lt;br&gt;下面我们来介绍另一个概念，它来自拓扑学，称为拓扑空间。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 拓扑结构&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b19804f92307f61dfa9c884943d0de29_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;227&quot; data-rawheight=&quot;222&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b19804f92307f61dfa9c884943d0de29&quot; data-watermark-src=&quot;v2-a7e83ab352c37df599387d19028ac7a2&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;拓扑学，被人们戏称橡皮膜上的几何学，它主要研究在连续变换下保持不变的几何性质，&lt;br&gt;例如，连通性和紧致性。&lt;/p&gt;&lt;p&gt;这里我们先不展开，主要看一下在拓扑学中是怎么建立数学结构的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;子集族&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;X&lt;/equation&gt; 是一个非空集合， &lt;equation&gt;2^X&lt;/equation&gt; 是 &lt;equation&gt;X&lt;/equation&gt; 的幂集（所有子集构成的集合），&lt;br&gt;把 &lt;equation&gt;2^X&lt;/equation&gt; 的子集（即以 &lt;equation&gt;X&lt;/equation&gt; 的一部分子集为成员的集合）称为 &lt;equation&gt;X&lt;/equation&gt; 的&lt;b&gt;子集族&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;拓扑空间&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;X&lt;/equation&gt; 是一个非空集合， &lt;equation&gt;X&lt;/equation&gt; 的一个子集族 &lt;equation&gt;\tau&lt;/equation&gt; 称为 &lt;equation&gt;X&lt;/equation&gt; 的一个&lt;b&gt;拓扑&lt;/b&gt;，如果它满足&lt;br&gt;（1） &lt;equation&gt;X&lt;/equation&gt; 和 &lt;equation&gt;\varnothing&lt;/equation&gt; 都包含在 &lt;equation&gt;\tau&lt;/equation&gt; 中&lt;br&gt;（2） &lt;equation&gt;\tau&lt;/equation&gt; 中任意多个成员的并集仍在 &lt;equation&gt;\tau&lt;/equation&gt; 中&lt;br&gt;（3） &lt;equation&gt;\tau&lt;/equation&gt; 中有限多个成员的交集仍在 &lt;equation&gt;\tau&lt;/equation&gt; 中&lt;/p&gt;&lt;p&gt;集合 &lt;equation&gt;X&lt;/equation&gt; 和它的一个拓扑 &lt;equation&gt;\tau&lt;/equation&gt; 一起称为一个&lt;b&gt;拓扑空间&lt;/b&gt;，记作 &lt;equation&gt;(X,\tau)&lt;/equation&gt; 。&lt;br&gt;称 &lt;equation&gt;\tau&lt;/equation&gt; 中的成员为这个拓扑空间的&lt;b&gt;开集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;从定义看出，给出集合的一个拓扑就是规定它的哪些子集是开集。&lt;/p&gt;&lt;p&gt;&lt;b&gt;连续映射&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-974ddbef8443d9229967e11c333ded9c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;380&quot; data-rawheight=&quot;129&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-974ddbef8443d9229967e11c333ded9c&quot; data-watermark-src=&quot;v2-36a76bf9d8a466872d8d8133d0cf9ec0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;设 &lt;equation&gt;X&lt;/equation&gt; 和 &lt;equation&gt;Y&lt;/equation&gt; 都是拓扑空间， &lt;equation&gt;f:X\rightarrow Y&lt;/equation&gt; 是一个映射，&lt;br&gt; &lt;equation&gt;x\in X&lt;/equation&gt; ，如果对于包含 &lt;equation&gt;f(x)\in Y&lt;/equation&gt; 的每一个开集 &lt;equation&gt;V&lt;/equation&gt; ，必存在包含 &lt;equation&gt;x&lt;/equation&gt; 的开集 &lt;equation&gt;U&lt;/equation&gt; ，&lt;br&gt;使得， &lt;equation&gt;f(U)\subseteq V&lt;/equation&gt; ，则我们就说， &lt;equation&gt;f&lt;/equation&gt; 在 &lt;equation&gt;x&lt;/equation&gt; 处&lt;b&gt;连续&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;如果映射 &lt;equation&gt;f:X\rightarrow Y&lt;/equation&gt; 在任一点 &lt;equation&gt;x\in X&lt;/equation&gt; 都连续，则说 &lt;equation&gt;f&lt;/equation&gt; 是&lt;b&gt;连续映射&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;同胚映射&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;f:X\rightarrow Y&lt;/equation&gt; 是双射，并且 &lt;equation&gt;f&lt;/equation&gt; 及其逆 &lt;equation&gt;f^{-1}:Y\rightarrow X&lt;/equation&gt; 都是连续的，&lt;br&gt;则称 &lt;equation&gt;f&lt;/equation&gt; 是一个&lt;b&gt;同胚映射&lt;/b&gt;，简称同胚。&lt;/p&gt;&lt;p&gt;当存在 &lt;equation&gt;X&lt;/equation&gt; 到 &lt;equation&gt;Y&lt;/equation&gt; 的同胚映射时，就称 &lt;equation&gt;X&lt;/equation&gt; 与 &lt;equation&gt;Y&lt;/equation&gt; 同胚，记作 &lt;equation&gt;X \cong Y&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;值得注意的是，同胚映射中条件 &lt;equation&gt;f^{-1}&lt;/equation&gt; 连续不可忽视，&lt;br&gt;它不能从双射和 &lt;equation&gt;f&lt;/equation&gt; 的连续性推出来。&lt;/p&gt;&lt;p&gt;&lt;b&gt;小结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;以上我们介绍了拓扑空间，以及两个拓扑空间之间的连续映射，&lt;br&gt;这和群以及两个群之间的群同态是很相似的。&lt;/p&gt;&lt;p&gt;它们表现出了一种结构上的相似性，&lt;br&gt;范畴论正是看到这种相似性，于是跳出具体的运算系统，&lt;br&gt;例如，它可以考虑群结构与拓扑结构之间的关系。&lt;/p&gt;&lt;p&gt;接下来我们来介绍CPO（完全偏序）。&lt;br&gt;它在范畴论中，对于摆脱集合论的观念束缚，帮助是很大的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4. 完全偏序&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-532615f76c50c7808ee4c139213ee560_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;457&quot; data-rawheight=&quot;347&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-532615f76c50c7808ee4c139213ee560&quot; data-watermark-src=&quot;v2-22529599b32d63a83febc0f08d8ad746&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34604220&quot;&gt;递归函数&lt;/a&gt;》系列文章中，我们已经介绍过CPO（&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E5%AE%8C%E5%85%A8%E5%81%8F%E5%BA%8F&quot;&gt;完全偏序&lt;/a&gt;）的概念了。&lt;br&gt;为了方便与本文中其他概念进行对比，我们再简单的梳理一下。&lt;/p&gt;&lt;p&gt;&lt;b&gt;二元关系&lt;/b&gt;&lt;/p&gt;&lt;p&gt;集合 &lt;equation&gt;S&lt;/equation&gt; 和 &lt;equation&gt;T&lt;/equation&gt; 上的&lt;b&gt;二元关系&lt;/b&gt; &lt;equation&gt;R&lt;/equation&gt; ，指的是它们笛卡尔积 &lt;equation&gt;S\times T&lt;/equation&gt; 的子集， &lt;equation&gt;R\subseteq S\times T&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;自反性，对称性，反对称性，传递性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一个二元关系 &lt;equation&gt;R\subseteq A\times A&lt;/equation&gt; 是&lt;b&gt;自反的&lt;/b&gt;，如果 &lt;equation&gt;R(a,a)&lt;/equation&gt; 对于所有的 &lt;equation&gt;a\in A&lt;/equation&gt; 成立；&lt;br&gt;是&lt;b&gt;对称的&lt;/b&gt;，如果 &lt;equation&gt;R(a,b)&lt;/equation&gt; 就有 &lt;equation&gt;R(b,a)&lt;/equation&gt; ，对于所有的 &lt;equation&gt;a,b\in A&lt;/equation&gt; 都成立；&lt;br&gt;是&lt;b&gt;反对称的&lt;/b&gt;，如果 &lt;equation&gt;R(a,b)&lt;/equation&gt; 且 &lt;equation&gt;R(b,a)&lt;/equation&gt; ，则 &lt;equation&gt;a,b&lt;/equation&gt; 是同一个元素，对于所有 &lt;equation&gt;a,b\in A&lt;/equation&gt; 都成立；&lt;br&gt;是&lt;b&gt;传递的&lt;/b&gt;，如果 &lt;equation&gt;R(a,b)&lt;/equation&gt; 和 &lt;equation&gt;R(b,c)&lt;/equation&gt; 能推出 &lt;equation&gt;R(a,c)&lt;/equation&gt; ，对于所有的 &lt;equation&gt;a,b,c\in A&lt;/equation&gt; 都成立。&lt;/p&gt;&lt;p&gt;&lt;b&gt;偏序关系&lt;/b&gt;&lt;/p&gt;&lt;p&gt;等价关系是同时具有自反性，对称性和传递性的关系。&lt;br&gt;&lt;b&gt;偏序关系&lt;/b&gt;是具有自反性，反对称性和传递性的关系。&lt;/p&gt;&lt;p&gt;等价关系的一个例子就是相等性，相等性关系 &lt;equation&gt;R(a,b)&lt;/equation&gt; 当且仅当 &lt;equation&gt;a,b&lt;/equation&gt; 是同一个元素。&lt;br&gt;偏序关系，例如通常的序关系 &lt;equation&gt;R\subseteq N\times N&lt;/equation&gt; ， &lt;equation&gt;R(a,b)&lt;/equation&gt; 当且仅当 &lt;equation&gt;a\leqslant b&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;最小元与上确界&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d13edf6ede5bb0d53616bec489bed30f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;450&quot; data-rawheight=&quot;362&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d13edf6ede5bb0d53616bec489bed30f&quot; data-watermark-src=&quot;v2-64344ef688ab03db3908fa429ea51c15&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;对于偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; ，以及它的一个子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; ，&lt;br&gt;如果存在 &lt;equation&gt;y\in S&lt;/equation&gt; ，且对于任意的 &lt;equation&gt;x\in S&lt;/equation&gt; ，有 &lt;equation&gt;y\leqslant x&lt;/equation&gt; ，则称 &lt;equation&gt;y&lt;/equation&gt; 为 &lt;equation&gt;S&lt;/equation&gt; 的&lt;b&gt;最小元&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;对于偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; ，以及它的一个子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; ，&lt;br&gt;如果存在 &lt;equation&gt;y\in D&lt;/equation&gt; ，（注意， &lt;equation&gt;y&lt;/equation&gt; 不一定在子集 &lt;equation&gt;S&lt;/equation&gt; 中）&lt;br&gt;使得对于任意的 &lt;equation&gt;x\in S&lt;/equation&gt; ， &lt;equation&gt;x\leqslant y&lt;/equation&gt; ，则称 &lt;equation&gt;y&lt;/equation&gt; 为 &lt;equation&gt;S&lt;/equation&gt; 的&lt;b&gt;上界&lt;/b&gt;，&lt;br&gt;如果 &lt;equation&gt;S&lt;/equation&gt; 的所有上界存在最小元，则称它为 &lt;equation&gt;S&lt;/equation&gt; 最小上界，或&lt;b&gt;上确界&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;完全偏序集&lt;/b&gt;&lt;/p&gt;&lt;p&gt;偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 的非空子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; 叫做&lt;b&gt;有向子集&lt;/b&gt;，&lt;br&gt;当且仅当，对于 &lt;equation&gt;S&lt;/equation&gt; 中的任意元素 &lt;equation&gt;a,b\in S&lt;/equation&gt; ，存在 &lt;equation&gt;S&lt;/equation&gt; 中的一个元素 &lt;equation&gt;c&lt;/equation&gt; ，有 &lt;equation&gt;a\leqslant c&lt;/equation&gt; 且 &lt;equation&gt;b\leqslant c&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果一个偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 的每个有向子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; 都有上确界（记为 &lt;equation&gt;\bigvee S&lt;/equation&gt; ）&lt;br&gt;就称它是一个有向完全偏序集，&lt;br&gt;此外，如果它还有最小元，就称它是一个&lt;b&gt;完全偏序集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;注意，完全偏序集并不是每一个子集都有上确界，而是它的每一个有向子集都有上确界。&lt;/p&gt;&lt;p&gt;&lt;b&gt;连续函数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;假设 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 与 &lt;equation&gt;(E,\leqslant )&lt;/equation&gt; 是完全偏序集， &lt;equation&gt;f:D\rightarrow E&lt;/equation&gt; 是集合上定义的一个函数，&lt;br&gt;对于任意的 &lt;equation&gt;d,d&#39;\in D&lt;/equation&gt; ，如果 &lt;equation&gt;d\leqslant d&#39;&lt;/equation&gt; 就有 &lt;equation&gt;f(d)\leqslant f(d&#39;)&lt;/equation&gt; ，我们就说 &lt;equation&gt;f&lt;/equation&gt; 是&lt;b&gt;单调的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;f&lt;/equation&gt; 是单调的，且对于任意有向子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; ，&lt;br&gt;有 &lt;equation&gt;f(\bigvee S)=\bigvee f(S)&lt;/equation&gt; ，就称 &lt;equation&gt;f&lt;/equation&gt; 是&lt;b&gt;连续的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;小结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们又重新回顾了完全偏序这一概念，&lt;br&gt;实际上，任意一个CPO（完全偏序），都构成了一个范畴，&lt;br&gt;而所有的群，也构成了一个范畴。&lt;/p&gt;&lt;p&gt;群范畴的对象是集合，而CPO（完全偏序）范畴的对象不一定是集合。&lt;br&gt;这对摆脱集合论来理解范畴是很关键的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了三种数学结构，群结构，拓扑结构，以及CPO（完全偏序）。&lt;br&gt;作为例子，可以为后面学习范畴论打下扎实的基础。&lt;/p&gt;&lt;p&gt;我们看到了这些数学结构之间的相似性，&lt;br&gt;从下一篇开始，我们要开始范畴论的学习之旅了。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Category_theory&quot;&gt;Category theory&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1230394/&quot;&gt;离散数学教程&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/4201293/&quot;&gt;近世代数引论&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1230382/&quot;&gt;基础拓扑学讲义&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-04-03-35196235</guid>
<pubDate>Tue, 03 Apr 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
