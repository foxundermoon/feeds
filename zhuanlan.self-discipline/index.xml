<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>业余程序员的个人修养</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Sat, 17 Mar 2018 15:11:29 +0800</lastBuildDate>
<item>
<title>递归函数（九）：最小不动点定理</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-17-34604220.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34604220&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们讨论了集合上的偏序结构，之所以谈论它们是因为，&lt;br&gt;完全偏序集上的连续函数具有最小不动点，这称之为最小不动点定理，&lt;br&gt;除了集合论的一些知识之外，我们还要讨论到底什么是连续函数，以及什么是完全偏序集。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;有向子集与完全偏序&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-798a5d7b110884184ff24d74e9a1378b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;246&quot; data-rawheight=&quot;197&quot;&gt;&lt;p&gt;偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 的非空子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; 叫做&lt;b&gt;有向子集&lt;/b&gt;（directed subset），&lt;br&gt;当且仅当，对于 &lt;equation&gt;S&lt;/equation&gt; 中的任意元素 &lt;equation&gt;a,b\in S&lt;/equation&gt; ，&lt;br&gt;存在 &lt;equation&gt;S&lt;/equation&gt; 中的一个元素 &lt;equation&gt;c&lt;/equation&gt; ，有 &lt;equation&gt;a\leqslant c&lt;/equation&gt; 且 &lt;equation&gt;b\leqslant c&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果一个偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 的每个有向子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; 都有上确界（记为 &lt;equation&gt;\bigvee S&lt;/equation&gt; ），&lt;br&gt;就称它是一个&lt;b&gt;有向完全偏序集&lt;/b&gt;，&lt;br&gt;此外，如果它还有最小元，就称它是一个&lt;b&gt;完全偏序集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;注意，完全偏序集并不是每一个子集都有上确界，&lt;br&gt;而是它的每一个有向子集都有上确界。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;连续函数&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1540a3cecd3b2e0877758d2ddfb0401f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;228&quot; data-rawheight=&quot;124&quot;&gt;&lt;p&gt;假设 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 与 &lt;equation&gt;(E,\leqslant )&lt;/equation&gt; 是完全偏序集， &lt;equation&gt;f:D\rightarrow E&lt;/equation&gt; 是集合上定义的一个函数，&lt;br&gt;如果 &lt;equation&gt;S\subseteq D&lt;/equation&gt; ，则 &lt;equation&gt;f(S)&lt;/equation&gt; 为 &lt;equation&gt;E&lt;/equation&gt; 的子集，其中 &lt;equation&gt;f(S)=\lbrace f(d)|\ d\in S \rbrace&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;对于任意的 &lt;equation&gt;d,d&#39;\in D&lt;/equation&gt; ，如果 &lt;equation&gt;d\leqslant d&#39;&lt;/equation&gt; 就有 &lt;equation&gt;f(d)\leqslant f(d&#39;)&lt;/equation&gt; ，我们就说 &lt;equation&gt;f&lt;/equation&gt; 是&lt;b&gt;单调的&lt;/b&gt;。&lt;br&gt;可以看出，如果 &lt;equation&gt;f&lt;/equation&gt; 是单调的，且 &lt;equation&gt;S&lt;/equation&gt; 是 &lt;equation&gt;D&lt;/equation&gt; 的有向子集，那么 &lt;equation&gt;f(S)&lt;/equation&gt; 也是 &lt;equation&gt;E&lt;/equation&gt; 的有向子集。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;f&lt;/equation&gt; 是单调的，且对于任意有向子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; ，有 &lt;equation&gt;f(\bigvee S)=\bigvee f(S)&lt;/equation&gt; ，&lt;br&gt;就称 &lt;equation&gt;f&lt;/equation&gt; 是&lt;b&gt;连续的&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;连续函数集上的偏序结构&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-222b5763dca58d03cdca2d16977a654d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;251&quot;&gt;&lt;p&gt;完全偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 到 &lt;equation&gt;(E,\leqslant )&lt;/equation&gt; 的连续函数，也可以定义出一个偏序结构，&lt;br&gt;我们称 &lt;equation&gt;f\leqslant g&lt;/equation&gt; ，当且仅当对于每一个 &lt;equation&gt;d\in D&lt;/equation&gt; ，我们有 &lt;equation&gt;f(d)\leqslant g(d)&lt;/equation&gt; 。&lt;br&gt;这样我们就得到了一个&lt;b&gt;元素为连续函数&lt;/b&gt;的偏序集， &lt;equation&gt;(D\rightarrow E,\leqslant )&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;可以证明， &lt;equation&gt;(D\rightarrow E,\leqslant )&lt;/equation&gt; 也是一个完全偏序集。（证略&lt;/p&gt;&lt;h2&gt;&lt;b&gt;最小不动点定理&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f19cc00b5a9f0b65494bc8bd66858f57_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;683&quot; data-rawheight=&quot;72&quot;&gt;&lt;p&gt;如果 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 是一个完全偏序集，且 &lt;equation&gt;f:D\rightarrow D&lt;/equation&gt; 是连续的，&lt;br&gt;则 &lt;equation&gt;f&lt;/equation&gt; 有&lt;b&gt;最小不动点&lt;/b&gt;， &lt;equation&gt;fix_D\ f=\bigvee \lbrace f^n(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;因为 &lt;equation&gt;\perp&lt;/equation&gt; 是 &lt;equation&gt;D&lt;/equation&gt; 中的最小元，且 &lt;equation&gt;f(\perp )\in D&lt;/equation&gt; ，所以， &lt;equation&gt;\perp \leqslant f(\perp )&lt;/equation&gt; ，&lt;br&gt;因为 &lt;equation&gt;f&lt;/equation&gt; 是连续的，所以 &lt;equation&gt;f&lt;/equation&gt; 也一定是单调的，所以， &lt;equation&gt;f(\perp )\leqslant f^2(\perp )&lt;/equation&gt; ，&lt;br&gt;继而， &lt;equation&gt;f^n(\perp )\leqslant f^{n+1}(\perp )&lt;/equation&gt; ，对于任意的 &lt;equation&gt;n\geqslant 0&lt;/equation&gt; 都成立。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\lbrace f^n(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; 构成了一个全序集，&lt;br&gt;所以，它是完全偏序集 &lt;equation&gt;(D\rightarrow E,\leqslant)&lt;/equation&gt; 的一个有向子集，必有上确界。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;a&lt;/equation&gt; 是上确界， &lt;equation&gt;a=\bigvee \lbrace f^n(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; ，则 &lt;b&gt;&lt;equation&gt;a&lt;/equation&gt; 是 &lt;equation&gt;f&lt;/equation&gt; 的不动点&lt;/b&gt;。&lt;br&gt;因为由 &lt;equation&gt;f&lt;/equation&gt; 的连续性， &lt;equation&gt;f(a)=f(\bigvee \lbrace f^n(\perp )|\ n\geqslant 0 \rbrace )=\bigvee \lbrace f^{(n+1)}(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; ，&lt;br&gt;而 &lt;equation&gt;\lbrace f^n(\perp ) \rbrace&lt;/equation&gt; 与 &lt;equation&gt;\lbrace f^{(n+1)}(\perp ) \rbrace&lt;/equation&gt; 有同样的上确界，所以 &lt;equation&gt;f(a)=a&lt;/equation&gt; ，即 &lt;equation&gt;a&lt;/equation&gt; 是 &lt;equation&gt;f&lt;/equation&gt; 的不动点。&lt;/p&gt;&lt;p&gt;其次， &lt;b&gt;&lt;equation&gt;a&lt;/equation&gt; 是 &lt;equation&gt;f&lt;/equation&gt; 的最小不动点&lt;/b&gt;，&lt;br&gt;假设 &lt;equation&gt;b=f(b)&lt;/equation&gt; 是 &lt;equation&gt;f&lt;/equation&gt; 的任意不动点，因为 &lt;equation&gt;\perp \leqslant b&lt;/equation&gt; ，所以 &lt;equation&gt;f(\perp )\leqslant f(b)&lt;/equation&gt; ，&lt;br&gt;类似的，对于任意的 &lt;equation&gt;n\geqslant 0&lt;/equation&gt; ， &lt;equation&gt;f^n(\perp )\leqslant f^n(b)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;而 &lt;equation&gt;b&lt;/equation&gt; 是 &lt;equation&gt;f&lt;/equation&gt; 的不动点，所以 &lt;equation&gt;f^n(b)=b&lt;/equation&gt; ，因此 &lt;equation&gt;b&lt;/equation&gt; 是集合 &lt;equation&gt;\lbrace f^n(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; 的上界。&lt;br&gt;由于集合的最小上界是 &lt;equation&gt;a&lt;/equation&gt; ，所以有 &lt;equation&gt;a\leqslant b&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;后继函数的不动点&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-85a40c8188217b5e65567daefb51447b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;342&quot; data-rawheight=&quot;147&quot;&gt;&lt;code lang=&quot;haskell&quot;&gt;succ :: Int -&amp;gt; Int
succ n = n+1&lt;/code&gt;&lt;p&gt;在第七篇中，我们说&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;可以得到任意函数的不动点，&lt;br&gt;那么这个&lt;code class=&quot;inline&quot;&gt;succ&lt;/code&gt;函数呢？它有没有不动点？&lt;code class=&quot;inline&quot;&gt;fix succ&lt;/code&gt;是什么？&lt;/p&gt;&lt;p&gt;现在我们有了&lt;b&gt;最小不动点定理&lt;/b&gt;，&lt;br&gt;就得验证&lt;code class=&quot;inline&quot;&gt;succ&lt;/code&gt;所指称的数学函数，是不是一个完全偏序集上的连续函数，&lt;br&gt;如果是的话，它就有不动点。&lt;/p&gt;&lt;p&gt;在第四篇为了表示计算的不可终止性，我们对自然数集进行了扩充， &lt;equation&gt;N\cup \lbrace \perp \rbrace&lt;/equation&gt; ，&lt;br&gt;然后用这个集合作为程序中&lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt;类型的值的解释。&lt;/p&gt;&lt;p&gt;然而， &lt;equation&gt;N\cup \lbrace \perp \rbrace&lt;/equation&gt; 不是一个完全偏序集，原因是它没有上界，&lt;br&gt;如果我们额外加入一个比其他的自然都大的元素 &lt;equation&gt;+\infty&lt;/equation&gt; ，&lt;br&gt;则我们就得到了一个&lt;b&gt;完全偏序集&lt;/b&gt;， &lt;equation&gt;N\cup \lbrace \perp \rbrace\cup \lbrace +\infty \rbrace&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;然后，我们看&lt;code class=&quot;inline&quot;&gt;succ&lt;/code&gt;连续吗？&lt;br&gt;首先，它是单调的，如果我们再定义 &lt;equation&gt;succ(+\infty )=+\infty&lt;/equation&gt; ，&lt;br&gt;就有 &lt;equation&gt;succ(\bigvee N)=\bigvee succ(N)&lt;/equation&gt; ，因此，&lt;code class=&quot;inline&quot;&gt;succ&lt;/code&gt;是一个连续函数。&lt;/p&gt;&lt;p&gt;根据最小不动点定理，&lt;code class=&quot;inline&quot;&gt;succ&lt;/code&gt;的&lt;b&gt;最小不动点&lt;/b&gt;是， &lt;equation&gt;fix\ succ=\bigvee \lbrace succ^n(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;由于 &lt;equation&gt;succ(\perp )=\perp&lt;/equation&gt; ，即对于非终止的输入&lt;code class=&quot;inline&quot;&gt;succ&lt;/code&gt;的计算也不会终止，所以 &lt;equation&gt;succ^n(\perp )=\perp&lt;/equation&gt; ，&lt;br&gt;因此， &lt;equation&gt;fix\ succ=\bigvee \lbrace succ^n(\perp )|\ n\geqslant 0 \rbrace =\perp&lt;/equation&gt; ，&lt;br&gt;即，&lt;code class=&quot;inline&quot;&gt;succ&lt;/code&gt;的最小不动点是 &lt;equation&gt;\perp&lt;/equation&gt; ，&lt;code class=&quot;inline&quot;&gt;fix succ&lt;/code&gt;的&lt;b&gt;计算不会终止&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;求解阶乘函数&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上一篇中，我们证明了阶乘函数&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;是以下函数的不动点，&lt;code class=&quot;inline&quot;&gt;fact = fix g&lt;/code&gt;，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;g :: (Int -&amp;gt; Int) -&amp;gt; Int -&amp;gt; Int
g f n = case n of
  1 -&amp;gt; 1
  _ -&amp;gt; n * f (n-1)&lt;/code&gt;&lt;p&gt;现在我们来看一下，如何运用最小不动点定理来得到这个答案。&lt;br&gt;为了避免篇幅过长，关于&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;函数的连续性证明暂略，&lt;br&gt;我们直接使用公式， &lt;equation&gt;fix\ g=\bigvee \lbrace g^n(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; ，&lt;br&gt;即，&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;函数的&lt;b&gt;最小不动点&lt;/b&gt;，就是集合 &lt;equation&gt;D=\lbrace g^n(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; 的&lt;b&gt;上确界&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;我们先来看一下这个集合 &lt;equation&gt;D&lt;/equation&gt; 中有哪些元素，&lt;br&gt;其中， &lt;equation&gt;g(\perp )\in D&lt;/equation&gt; ，我们将 &lt;equation&gt;\perp&lt;/equation&gt; 传入 &lt;equation&gt;g&lt;/equation&gt; 中，看看会得到什么，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;f1 = \n -&amp;gt; case n of 
  1 -&amp;gt; 1
  _ -&amp;gt; ...&lt;/code&gt;&lt;p&gt;这个函数能计算&lt;code class=&quot;inline&quot;&gt;f1 1&lt;/code&gt;，但是不能计算&lt;code class=&quot;inline&quot;&gt;f1 2&lt;/code&gt;，恰好是&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;函数有限展开的一阶项。&lt;/p&gt;&lt;p&gt;我们再来看 &lt;equation&gt;g^2(\perp )\in D&lt;/equation&gt; ，它等于 &lt;equation&gt;g(f1)&lt;/equation&gt; ，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;f2 = \n -&amp;gt; case n of 
  1 -&amp;gt; 1
  _ -&amp;gt; n * f1 (n-1)&lt;/code&gt;&lt;p&gt;这个函数能计算&lt;code class=&quot;inline&quot;&gt;f2 1&lt;/code&gt;以及&lt;code class=&quot;inline&quot;&gt;f2 2&lt;/code&gt;，但是不能计算&lt;code class=&quot;inline&quot;&gt;f2 3&lt;/code&gt;，&lt;br&gt;恰好是&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;函数展开的二阶项。&lt;/p&gt;&lt;p&gt;由此，我们看出了规律， &lt;equation&gt;g^n(\perp )\in D&lt;/equation&gt; 就是&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;函数有限展开的第 &lt;equation&gt;n&lt;/equation&gt; 阶项。&lt;br&gt;上一篇中，我们已经证明了，当 &lt;equation&gt;n\rightarrow \infty&lt;/equation&gt; 时，它就是&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;函数，&lt;br&gt;考虑到 &lt;equation&gt;f1,f2,\cdots&lt;/equation&gt; 这些函数的序关系，因此，我们有 &lt;equation&gt;fact=\bigvee \lbrace g^n(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;即，&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;函数就是&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;函数的最小不动点。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;到此为止，我想这个系列的文章已经讨论完了，&lt;br&gt;本系列文章一直围绕着递归函数和不动点进行分析，&lt;br&gt;在内容上可以分为两个部分，前半部分主要与可计算性理论有关，&lt;br&gt;后半部分与不动点定理有关，希望对大家有所帮助。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E9%9B%86%E5%90%88&quot;&gt;有向集合&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E5%81%8F%E5%BA%8F&quot;&gt;完全偏序&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Kleene_fixed-point_theorem&quot;&gt;Kleene fixed-point theorem&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1761918/&quot;&gt;Foundations for Programming Languages&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-17-34604220</guid>
<pubDate>Sat, 17 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（八）：偏序结构</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-16-34576092.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34576092&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上一篇我们介绍了不动点算子和Y组合子，以及Y组合子的具体表现形式，&lt;br&gt;这一篇我们根据不动点算子的性质来证明&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;函数就是&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;函数的不动点。&lt;br&gt;随后，我们回归到了数学中，讨论集合上的一种偏序结构，&lt;br&gt;这为下文完全偏序集，以及完全偏序集上连续函数的不动点定理做好准备。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;不动点算子的性质&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5aa0f01d21740986634a9e6bf34c3d48_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;259&quot; data-rawheight=&quot;246&quot;&gt;&lt;p&gt;上文我们介绍了不动点算子&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;，&lt;br&gt;它可以用来求取任意函数的不动点。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fix :: (a -&amp;gt; a) -&amp;gt; a
fix f = let x = f x in x&lt;/code&gt;&lt;p&gt;并且我们说以下函数的不动点为&lt;code class=&quot;inline&quot;&gt;fact = fix g&lt;/code&gt;，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;g :: (Int -&amp;gt; Int) -&amp;gt; Int -&amp;gt; Int
g f n = case n of
  1 -&amp;gt; 1
  _ -&amp;gt; n * f (n-1)&lt;/code&gt;&lt;p&gt;但是上文中，我们只是对它们的计算结果进行比对，&lt;br&gt;并没有对它进行&lt;b&gt;证明&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;考虑到&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;的性质，&lt;code class=&quot;inline&quot;&gt;fix g = g (fix g)&lt;/code&gt;，&lt;br&gt;（因为&lt;code class=&quot;inline&quot;&gt;fix g&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的不动点，令&lt;code class=&quot;inline&quot;&gt;h = fix g&lt;/code&gt;，上式为&lt;code class=&quot;inline&quot;&gt;h = g h&lt;/code&gt; &lt;br&gt;我们可以使用&lt;b&gt;数学归纳法&lt;/b&gt;，证明对于任意的自然数 &lt;equation&gt;n&lt;/equation&gt; ，&lt;code class=&quot;inline&quot;&gt;fact n = fix g n&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我们先证&lt;b&gt;初始条件&lt;/b&gt;，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fix g 1 
= g (fix g) 1 
= case 1 of 
    1 -&amp;gt; 1
    _ -&amp;gt; ...
= 1
= fact 1&lt;/code&gt;&lt;p&gt;然后再证&lt;b&gt;递推条件&lt;/b&gt;，假设&lt;code class=&quot;inline&quot;&gt;fact k = fix g k&lt;/code&gt;，&lt;br&gt;我们要推出&lt;code class=&quot;inline&quot;&gt;fact (k+1) = fix g (k+1)&lt;/code&gt;，其中， &lt;equation&gt;k &amp;gt; 0&lt;/equation&gt; 。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fix g (k+1)
= g (fix g) (k+1)
= case (k+1) of 
    1 -&amp;gt; 1
    _ -&amp;gt; (k+1) * (fix g) k
= (k+1) * (fix g) k
= (k+1) * fact k
= fact (k+1)&lt;/code&gt;&lt;p&gt;因此，对于任意的自然数 &lt;equation&gt;n&lt;/equation&gt; ，&lt;code class=&quot;inline&quot;&gt;fact n = fix g n&lt;/code&gt;。&lt;br&gt;即，&lt;code class=&quot;inline&quot;&gt;fact = fix g&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;不动点算子的有限展开&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2982ac05515d431e35d327be6238dfa6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;332&quot; data-rawheight=&quot;116&quot;&gt;&lt;p&gt;根据上一节&lt;code class=&quot;inline&quot;&gt;fact = fix g&lt;/code&gt;的证明，我们看到，&lt;br&gt;每一步递推，我们都使用了不动点算子&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;的性质&lt;code class=&quot;inline&quot;&gt;fix g = g (fix g)&lt;/code&gt;，&lt;br&gt;但是对于一个具有有限存储空间的机器来说，递推的步骤不可能是无限的。&lt;/p&gt;&lt;p&gt;为了界定最多使用多少次递推，我们定义， &lt;equation&gt;fix^{[n+1]}\ g = g\ (fix^{[n]} g)&lt;/equation&gt; ，&lt;br&gt;并且认为 &lt;equation&gt;fix^{[0]}\ g&lt;/equation&gt; 对于任意的 &lt;equation&gt;n&lt;/equation&gt; 无定义，&lt;br&gt; &lt;equation&gt;fix^{[1]}\ g\ 1 = 1&lt;/equation&gt; ，而 &lt;equation&gt;fix^{[1]}\ g\ n&lt;/equation&gt; 在 &lt;equation&gt;n &amp;gt; 1&lt;/equation&gt; 时没有定义，&lt;br&gt; &lt;equation&gt;fix^{[2]}\ g\ 1 = 1&lt;/equation&gt; ， &lt;equation&gt;fix^{[2]}\ g\ 2 = 2&lt;/equation&gt; ，而 &lt;equation&gt;fix^{[2]}\ g\ n&lt;/equation&gt; 在 &lt;equation&gt;n &amp;gt; 2&lt;/equation&gt; 时没有定义。&lt;/p&gt;&lt;p&gt;因此， &lt;equation&gt;fix^{[n]}\ g&lt;/equation&gt; 是一个&lt;b&gt;部分函数&lt;/b&gt;，且，&lt;br&gt; &lt;equation&gt;fix^{[n+1]}\ g&lt;/equation&gt; 所表示的函数，总是比 &lt;equation&gt;fix^{[n]}\ g&lt;/equation&gt; 的计算能力更强一些，离&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;更近一些。&lt;br&gt;当 &lt;equation&gt;n\rightarrow \infty&lt;/equation&gt; 时， &lt;equation&gt;fix^{[\infty ]}\ g&lt;/equation&gt; 就是阶乘函数&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;即， &lt;equation&gt;\lbrace fix^{[n]} g|\ n\geqslant 0 \rbrace&lt;/equation&gt; 的&lt;b&gt;最小上界&lt;/b&gt;，就是&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的不动点。&lt;br&gt;那么，什么样的&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;才能保证这个集合具有最小上界呢？&lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BA%8F%E7%90%86%E8%AE%BA&quot;&gt;序理论&lt;/a&gt;指出，&lt;b&gt;完全偏序集上的序保持自映射具有最小不动点&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;为此，我们需要先认识什么是偏序集，什么是连续函数。&lt;br&gt;使用完全偏序集上的连续函数解释程序中函数的方式，称为&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%9F%9F%E7%90%86%E8%AE%BA&quot;&gt;域论模型&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;偏序集与哈斯图&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ca7cf8adbf29c978933a475f247bebde_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;292&quot; data-rawheight=&quot;222&quot;&gt;&lt;p&gt;在第三篇中，我们讨论过&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB&quot;&gt;偏序关系&lt;/a&gt;，&lt;br&gt;一个&lt;b&gt;偏序集&lt;/b&gt; &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 是一个集合 &lt;equation&gt;D&lt;/equation&gt; ，并且在这个集合上定义了一个&lt;b&gt;偏序关系&lt;/b&gt; &lt;equation&gt;\leqslant&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;A&lt;/equation&gt; 为实数集的一个非空子集，我们定义 &lt;equation&gt;A&lt;/equation&gt; 上的偏序关系为 &lt;equation&gt;\leqslant&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;x\leqslant y&lt;/equation&gt; 当且仅当 &lt;equation&gt;x&lt;/equation&gt; 是小或等于 &lt;equation&gt;y&lt;/equation&gt; 的实数，则 &lt;equation&gt;(A,\leqslant )&lt;/equation&gt; 是一个偏序集。&lt;/p&gt;&lt;p&gt;偏序集反映了集合上的一种偏序结构，它比我们想象中的更为常见，&lt;br&gt;例如，一个集合 &lt;equation&gt;A&lt;/equation&gt; ，对于任意两个元素 &lt;equation&gt;x,y\in A&lt;/equation&gt; ，我们定义 &lt;equation&gt;x\leqslant y&lt;/equation&gt; 当且仅当 &lt;equation&gt;x=y&lt;/equation&gt; ，&lt;br&gt;那么 &lt;equation&gt;(A,\leqslant )&lt;/equation&gt; 是一个偏序集。&lt;/p&gt;&lt;p&gt;因此，如果某个集合构成了一个偏序集，这完全取决于我们怎样定义偏序关系。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 是一个偏序集，&lt;br&gt;对于任意的 &lt;equation&gt;x,y\in D&lt;/equation&gt; ，如果总是有 &lt;equation&gt;x\leqslant y&lt;/equation&gt; 或者 &lt;equation&gt;y\leqslant x&lt;/equation&gt; 成立，&lt;br&gt;则称 &lt;equation&gt;x&lt;/equation&gt; 和 &lt;equation&gt;y&lt;/equation&gt; 是&lt;b&gt;可比的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;x\leqslant y&lt;/equation&gt; ，且 &lt;equation&gt;x\neq y&lt;/equation&gt; ，则记为 &lt;equation&gt;x&amp;lt;y&lt;/equation&gt; 。&lt;br&gt;如果 &lt;equation&gt;x&lt;/equation&gt; 和 &lt;equation&gt;y&lt;/equation&gt; 是可比的，且 &lt;equation&gt;x&amp;lt;y&lt;/equation&gt; ，如果不存在 &lt;equation&gt;z\in D&lt;/equation&gt; ，使得 &lt;equation&gt;x&amp;lt;z&amp;lt;y&lt;/equation&gt; ，&lt;br&gt;则称 &lt;equation&gt;y&lt;/equation&gt;&lt;b&gt; 覆盖 &lt;/b&gt;&lt;equation&gt;x&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;根据可比性和覆盖性，我们就可以将偏序关系用&lt;b&gt;无向图&lt;/b&gt;表示出来了，&lt;br&gt;其中，顶点表示元素，边表示覆盖关系，并且省去图中每个顶点处的环，&lt;br&gt; &lt;equation&gt;y&lt;/equation&gt; 覆盖 &lt;equation&gt;x&lt;/equation&gt; 就将代表 &lt;equation&gt;y&lt;/equation&gt; 的顶点放在代表 &lt;equation&gt;x&lt;/equation&gt; 的顶点之上，并在 &lt;equation&gt;x&lt;/equation&gt; 和 &lt;equation&gt;y&lt;/equation&gt; 之间连线，&lt;br&gt;如果 &lt;equation&gt;x&amp;lt;y&lt;/equation&gt; ，但是 &lt;equation&gt;y&lt;/equation&gt; 不覆盖 &lt;equation&gt;x&lt;/equation&gt; ，就省掉 &lt;equation&gt;x&lt;/equation&gt; 与 &lt;equation&gt;y&lt;/equation&gt; 之间的连线。&lt;/p&gt;&lt;p&gt;这样用来表示有限偏序集的无向图，称为&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%88%E6%96%AF%E5%9C%96&quot;&gt;哈斯图&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;例如，易证&lt;b&gt;整除关系&lt;/b&gt;是整数集上的一种偏序关系，&lt;br&gt;我们可以画出偏序集 &lt;equation&gt;\lbrace 1,2,3,4,5,6,9,10,15 \rbrace&lt;/equation&gt; 对应的哈斯图，如下，&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-dafdb936b22c79c6840bae5bbbb84fc6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;220&quot; data-rawheight=&quot;173&quot;&gt;&lt;h2&gt;&lt;b&gt;全序集与拟序集&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a27366c2bff2c9c470d571693f760ed4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;530&quot; data-rawheight=&quot;200&quot;&gt;&lt;p&gt;设 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 是一个偏序集，如果对于任意 &lt;equation&gt;x,y\in D&lt;/equation&gt; ， &lt;equation&gt;x&lt;/equation&gt; 和 &lt;equation&gt;y&lt;/equation&gt; 都可比，&lt;br&gt;则称 &lt;equation&gt;\leqslant&lt;/equation&gt; 为 &lt;equation&gt;D&lt;/equation&gt; 上的&lt;b&gt;全序关系&lt;/b&gt;，此时称 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 为&lt;b&gt;全序集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;可见，实数集以及实数集上的小于等于关系 &lt;equation&gt;\leqslant&lt;/equation&gt; ，构成了一个全序集。&lt;br&gt;哈斯图为从下至上的“一条线”，是全序集的充要条件。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;R&lt;/equation&gt; 是非空集合 &lt;equation&gt;A&lt;/equation&gt; 上的，反自反的和传递的二元关系，&lt;br&gt;则称 &lt;equation&gt;R&lt;/equation&gt; 为 &lt;equation&gt;A&lt;/equation&gt; 上的&lt;b&gt;拟序关系&lt;/b&gt;，常将拟序关系记为 &lt;equation&gt;&amp;lt;&lt;/equation&gt; ，并称 &lt;equation&gt;(A,&amp;lt;)&lt;/equation&gt; 为&lt;b&gt;拟序集&lt;/b&gt;。&lt;br&gt;拟序关系自然具有反对称性。&lt;br&gt;（其中，反自反关系，指的是不存在 &lt;equation&gt;x\in A&lt;/equation&gt; ，使得 &lt;equation&gt;x&amp;lt;x&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;拟序关系与偏序关系的哈斯图在画法上完全相同，&lt;br&gt;只是拟序关系的哈斯图的各顶点都没有环。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;(A,&amp;lt;)&lt;/equation&gt; 是一个拟序集，如果对于任意的 &lt;equation&gt;x,y\in A&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;x&amp;lt;y&lt;/equation&gt; ， &lt;equation&gt;x=y&lt;/equation&gt; ， &lt;equation&gt;y&amp;lt;x&lt;/equation&gt; 三式有且仅有一式成立，则称 &lt;equation&gt;&amp;lt;&lt;/equation&gt; 具有&lt;b&gt;三歧性&lt;/b&gt;，&lt;br&gt;这样的拟序关系 &lt;equation&gt;&amp;lt;&lt;/equation&gt; ，称为&lt;b&gt;拟全序关系&lt;/b&gt;，这样的拟序集 &lt;equation&gt;(A,&amp;lt;)&lt;/equation&gt; ，称为&lt;b&gt;拟全序集&lt;/b&gt;。&lt;br&gt;拟全序集的哈斯图也是“一条线”。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;最小元与上确界&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3fa180632f5a71452ddd338e9867be18_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;187&quot;&gt;&lt;p&gt;对于偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; ，以及它的一个子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; ，&lt;br&gt;如果存在 &lt;equation&gt;y\in S&lt;/equation&gt; ，且对于任意的 &lt;equation&gt;x\in S&lt;/equation&gt; ，有 &lt;equation&gt;y\leqslant x&lt;/equation&gt; ，则称 &lt;equation&gt;y&lt;/equation&gt; 为 &lt;equation&gt;S&lt;/equation&gt; 的&lt;b&gt;最小元&lt;/b&gt;。&lt;br&gt;（相似的我们可以定义最大元&lt;/p&gt;&lt;p&gt;如果存在 &lt;equation&gt;y\in S&lt;/equation&gt; ，对于任意的 &lt;equation&gt;x\in S&lt;/equation&gt; ，&lt;br&gt;如果 &lt;equation&gt;x\leqslant y&lt;/equation&gt; 那么就有 &lt;equation&gt;x=y&lt;/equation&gt; ，则称 &lt;equation&gt;y&lt;/equation&gt; 为 &lt;equation&gt;S&lt;/equation&gt; 的&lt;b&gt;极小元&lt;/b&gt;。&lt;br&gt;（相似的我们可以定义极大元&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;S&lt;/equation&gt; 是有穷集，则 &lt;equation&gt;S&lt;/equation&gt; 的极小元一定存在，并且可能有多个，&lt;br&gt;但是最小元却不一定存在。&lt;/p&gt;&lt;p&gt;上文中，我们画出了偏序集 &lt;equation&gt;A=\lbrace 1,2,3,4,5,6,9,10,15 \rbrace&lt;/equation&gt; 对应的哈斯图，&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-086295e163bc5eaff1567167b64beca3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;220&quot; data-rawheight=&quot;173&quot;&gt;&lt;p&gt;我们取 &lt;equation&gt;B_1=\lbrace 1,2,3 \rbrace&lt;/equation&gt; ， &lt;equation&gt;B_2=\lbrace 3,5,15 \rbrace&lt;/equation&gt; ， &lt;equation&gt;B_3=A&lt;/equation&gt; ，&lt;br&gt;则 &lt;equation&gt;1&lt;/equation&gt; 是 &lt;equation&gt;B_1&lt;/equation&gt; 的最小元，也是极小元， &lt;equation&gt;2,3&lt;/equation&gt; 是 &lt;equation&gt;B_1&lt;/equation&gt; 的极大元，但 &lt;equation&gt;B_1&lt;/equation&gt; 没有最大元。&lt;br&gt; &lt;equation&gt;3,5&lt;/equation&gt; 是 &lt;equation&gt;B_2&lt;/equation&gt; 的极小元，但 &lt;equation&gt;B_2&lt;/equation&gt; 没有最小元， &lt;equation&gt;15&lt;/equation&gt; 是 &lt;equation&gt;B_2&lt;/equation&gt; 的最大元，也是极大元。&lt;br&gt; &lt;equation&gt;1&lt;/equation&gt; 是 &lt;equation&gt;B_3&lt;/equation&gt; 的最小元，也是极小元， &lt;equation&gt;4,6,9,10,15&lt;/equation&gt; 是 &lt;equation&gt;B_3&lt;/equation&gt; 的极大元，但是 &lt;equation&gt;B_3&lt;/equation&gt; 没有最大元。&lt;/p&gt;&lt;p&gt;对于偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; ，以及它的一个子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; ，&lt;br&gt;如果存在 &lt;equation&gt;y\in D&lt;/equation&gt; ，（注意，不一定是 &lt;equation&gt;y\in S&lt;/equation&gt; &lt;br&gt;使得对于任意的 &lt;equation&gt;x\in S&lt;/equation&gt; ， &lt;equation&gt;x\leqslant y&lt;/equation&gt; ，则称 &lt;equation&gt;y&lt;/equation&gt; 为 &lt;equation&gt;S&lt;/equation&gt; 的&lt;b&gt;上界&lt;/b&gt;，&lt;br&gt;如果 &lt;equation&gt;S&lt;/equation&gt; 的所有上界存在最小元，则称它为 &lt;equation&gt;S&lt;/equation&gt; &lt;b&gt;最小上界&lt;/b&gt;，或&lt;b&gt;上确界&lt;/b&gt;。&lt;br&gt;（相似的可以定义下确界&lt;/p&gt;&lt;p&gt;&lt;equation&gt;S&lt;/equation&gt; 的上界和下界不一定存在，即使存在，上确界和下确界也不一定存在。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;(A,&amp;lt;)&lt;/equation&gt; 是一个拟全序集，如果对于 &lt;equation&gt;A&lt;/equation&gt; 中的任何非空子集 &lt;equation&gt;S&lt;/equation&gt; 都有最小元，&lt;br&gt;则称 &lt;equation&gt;&amp;lt;&lt;/equation&gt; 是一个&lt;b&gt;良序关系&lt;/b&gt;， &lt;equation&gt;(A,&amp;lt;)&lt;/equation&gt; 是一个&lt;b&gt;良序集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如，自然数集以及自然数集上的小于关系，构成了一个良序集 &lt;equation&gt;(N,&amp;lt;)&lt;/equation&gt; ，&lt;br&gt;但是，整数集以及整数集上的小于关系，并不构成良序集，而仅仅是一个拟全序集。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文从一个证明出发，我们了解了不动点算子的工作原理，&lt;br&gt;然后引出了一些数学概念，序关系在不动点算子理论中占有很重要的地位，&lt;br&gt;所以，这里给出了详细的介绍，下文我们开始讨论最小不动点定理。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BA%8F%E7%90%86%E8%AE%BA&quot;&gt;序理论&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%9F%9F%E7%90%86%E8%AE%BA&quot;&gt;域论模型&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB&quot;&gt;偏序关系&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1230394/&quot;&gt;离散数学教程&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-16-34576092</guid>
<pubDate>Fri, 16 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（七）：不动点算子</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-15-34526779.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34526779&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;以上几篇文章中，我们讨论了可计算性理论相关的一些内容，&lt;br&gt;可计算性与递归函数论存在着千丝万缕的联系，&lt;br&gt;不动点理论也是这样的，我们定义的递归函数一定存在吗？&lt;br&gt;在什么情况下它是存在的？&lt;/p&gt;&lt;p&gt;要回答以上这些问题，还要从方程，不动点，不动点算子说起。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;约束方程&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-676edc86f9bf546b4765bf4586fc95cd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;215&quot;&gt;&lt;p&gt;在中学时代，我们学过“&lt;b&gt;方程&lt;/b&gt;”的概念，&lt;br&gt;方程可以简单表述为含有未知数的等式，例如， &lt;equation&gt;3x+3=2&lt;/equation&gt; 。&lt;br&gt;未知数可以同时出现在等式的两边，例如， &lt;equation&gt;2x+3=2-x&lt;/equation&gt; 。&lt;br&gt;通过合并同类项，我们可以求解 &lt;equation&gt;x&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;在大学时代，我们还学过&lt;b&gt;线性方程组&lt;/b&gt;和&lt;b&gt;微分方程&lt;/b&gt;，&lt;br&gt;例如，求解矩阵的特征值和特征向量， &lt;equation&gt;Av=\lambda v&lt;/equation&gt; ，&lt;br&gt;二阶常微分方程（&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%A1%9E%E5%B0%94%E5%87%BD%E6%95%B0&quot;&gt;贝塞尔方程&lt;/a&gt;）， &lt;equation&gt;x^2y&#39;&#39;+xy&#39;+(x^2-\alpha ^2)y=0&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;在计算机科学中，同样的未知“数”的思想，&lt;br&gt;还出现在了类型推导（例如：&lt;a href=&quot;https://en.wikipedia.org/wiki/Unification_(computer_science)&quot;&gt;unification&lt;/a&gt;）与递归函数的定义中。&lt;br&gt;以上这些例子，方程是“&lt;b&gt;约束&lt;/b&gt;”的一种表现形式。&lt;/p&gt;&lt;p&gt;我们回到最简单的阶乘函数&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的定义式，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact :: Int -&amp;gt; Int
fact 1 = 1
fact n = n * fact (n-1)&lt;/code&gt;&lt;p&gt;去掉语法糖，稍微修改一下，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact :: Int -&amp;gt; Int
fact n = case n of 
  1 -&amp;gt; 1
  n -&amp;gt; n * fact (n-1)&lt;/code&gt;&lt;p&gt;我们发现，&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的定义和“方程”十分相似，&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;同时出现在了等式的两边，&lt;br&gt;阶乘函数，就是这个“方程”的“解”。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;函数的不动点&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e4ccb41ef78c4fe19ec357fc532960ea_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;560&quot; data-rawheight=&quot;481&quot;&gt;&lt;p&gt;在中学数学中，我们已经学过不动点了，只是当时印象不是那么深刻，&lt;br&gt;&lt;b&gt;函数的不动点&lt;/b&gt;，是指被这个函数映射到其自身的那些点。&lt;br&gt;例如： &lt;equation&gt;f(x)=x^2-3x+4&lt;/equation&gt; ，&lt;br&gt;则 &lt;equation&gt;2&lt;/equation&gt; 是函数 &lt;equation&gt;f&lt;/equation&gt; 的一个不动点， &lt;equation&gt;f(2)=2&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;并不是每一个函数都有不动点，&lt;br&gt;例如，实数域上的函数 &lt;equation&gt;f(x)=x+1&lt;/equation&gt; ，就没有不动点，&lt;br&gt;对于任意实数 &lt;equation&gt;x&lt;/equation&gt; ，永远都不等于 &lt;equation&gt;x+1&lt;/equation&gt; 。&lt;br&gt;（不动点是和定义域有关的，以后我们还会重新讨论 &lt;equation&gt;f(x)=x+1&lt;/equation&gt; 的不动点。&lt;/p&gt;&lt;p&gt;一般的，函数 &lt;equation&gt;f(x)&lt;/equation&gt; 的&lt;b&gt;不动点&lt;/b&gt;，指的是这样的 &lt;equation&gt;x&lt;/equation&gt; ，使得 &lt;equation&gt;x=f(x)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;重新温习了不动点相关的知识之后，&lt;br&gt;我们就可以对上面的阶乘函数进行改造了，&lt;br&gt;我们要把阶乘函数看做另外一个函数的不动点。&lt;/p&gt;&lt;p&gt;定义函数 &lt;equation&gt;g&lt;/equation&gt; ，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;g :: (Int -&amp;gt; Int) -&amp;gt; Int -&amp;gt; Int
g f n = case n of 
  1 -&amp;gt; 1
  n -&amp;gt; n * f (n-1)&lt;/code&gt;&lt;p&gt;我们可以得到，&lt;code class=&quot;inline&quot;&gt;g fact = fact&lt;/code&gt;，&lt;br&gt;因此，&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;实际上就是函数&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的不动点。&lt;/p&gt;&lt;p&gt;于是，在“方程”中求解&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的过程，&lt;br&gt;就转换成了求解函数&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的不动点的过程了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;不动点算子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d17244c93688f8a33bbd53a896cbe762_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;492&quot; data-rawheight=&quot;179&quot;&gt;&lt;p&gt;我们怎样求解函数&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的不动点呢？&lt;br&gt;在Haskell中，可以很方便的定义一个高阶函数&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;，它可以用来求解任意函数的不动点，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fix :: (a -&amp;gt; a) -&amp;gt; a
fix g = let x = g x in x&lt;/code&gt;&lt;p&gt;我们试验一下&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;的强大威力，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact 10
&amp;gt; 3628800

fix g 10
&amp;gt; 3628800&lt;/code&gt;&lt;p&gt;注意，&lt;code class=&quot;inline&quot;&gt;fix g&lt;/code&gt;得到的是&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的不动点，而不是&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的不动点，&lt;br&gt;即&lt;code class=&quot;inline&quot;&gt;(fix g) = g (fix g)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;有了&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;，我们就可以构造&lt;b&gt;匿名递归函数&lt;/b&gt;了，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact&#39; :: Int -&amp;gt; Int
fact&#39; = fix $ \fact -&amp;gt; \n -&amp;gt; case n of 
  1 -&amp;gt; 1
  n -&amp;gt; n * fact (n-1)&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;后面跟的函数没有名字，它是匿名的，但是经过&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;作用后，可以产生一个递归函数。&lt;br&gt;也就是说，为了实现递归，函数是可以没有名字的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Y组合子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2434c4ee3ac9498d53d23a77e067d39f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;218&quot; data-rawheight=&quot;231&quot;&gt;&lt;p&gt;&lt;b&gt;Y组合子&lt;/b&gt;，是&lt;a href=&quot;https://zh.wikipedia.org/wiki/Haskell_Curry&quot;&gt;Haskell B. Curry&lt;/a&gt;在研究 &lt;equation&gt;\lambda&lt;/equation&gt; 演算时发现的，&lt;br&gt;它的表现形式如下， &lt;equation&gt;Y:=\lambda f.(\lambda x.(f\ (x\ x))\ \lambda x.(f\ (x\ x)))&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;在 &lt;equation&gt;\lambda&lt;/equation&gt; 演算中，（ &lt;equation&gt;\alpha&lt;/equation&gt; 转换和 &lt;equation&gt;\beta&lt;/equation&gt; 规约&lt;br&gt;我们可以证明，对于任何函数&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;， &lt;equation&gt;(Y g) = (g (Y g))&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;因此，Y组合子是一个&lt;b&gt;不动点算子&lt;/b&gt;，它可以得到任意函数的不动点。&lt;br&gt;其他的不动点算子还有图灵不动点组合子 &lt;equation&gt;\Theta&lt;/equation&gt; ， &lt;equation&gt;\Theta:=(\lambda x.\lambda y.(y\ (x\ x\ y)))\ (\lambda x.\lambda y.(y\ (x\ x\ y)))&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;讨论Y组合子在Haskell中的表示方式是有趣的，因为直接翻译过去会报类型错误，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;y :: (a -&amp;gt; a) -&amp;gt; a
y = \f -&amp;gt; (\x -&amp;gt; f (x x)) (\x -&amp;gt; f (x x))

-- Occurs check: cannot construct the infinite type: r0 ~ r0 -&amp;gt; a
-- Expected type: r0 -&amp;gt; a
--   Actual type: (r0 -&amp;gt; a) -&amp;gt; a
-- In the first argument of ‘x’, namely ‘x’
-- In the first argument of ‘f’, namely ‘(x x)’&lt;/code&gt;&lt;p&gt;类型系统无法确定&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型。&lt;/p&gt;&lt;p&gt;问题出在表达式&lt;code class=&quot;inline&quot;&gt;x x&lt;/code&gt;上面，&lt;br&gt;假设&lt;code class=&quot;inline&quot;&gt;x x&lt;/code&gt;的类型为&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，则第一个&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型就应该为&lt;code class=&quot;inline&quot;&gt;? -&amp;gt; a&lt;/code&gt;，&lt;br&gt;于是，第二个&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型肯定也应该是&lt;code class=&quot;inline&quot;&gt;? -&amp;gt; a&lt;/code&gt;。（因为都是&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt; &lt;/p&gt;&lt;p&gt;又因为&lt;code class=&quot;inline&quot;&gt;x x&lt;/code&gt;的类型为&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，&lt;br&gt;所以第一个&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型&lt;code class=&quot;inline&quot;&gt;? -&amp;gt; a&lt;/code&gt;中，&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;的类型就应该是&lt;code class=&quot;inline&quot;&gt;? -&amp;gt; a&lt;/code&gt;，&lt;br&gt;（因为&lt;code class=&quot;inline&quot;&gt;((? -&amp;gt; a) -&amp;gt; a)&lt;/code&gt;作用到&lt;code class=&quot;inline&quot;&gt;(? -&amp;gt; a)&lt;/code&gt;才能得到&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; &lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;的类型是&lt;code class=&quot;inline&quot;&gt;? -&amp;gt; a&lt;/code&gt;，因此&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;应该是一个&lt;a href=&quot;https://zh.m.wikipedia.org/wiki/%E9%80%92%E5%BD%92%E7%B1%BB%E5%9E%8B&quot;&gt;递归类型&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;下面我们来定义递归类型&lt;code class=&quot;inline&quot;&gt;Mu&lt;/code&gt;，来帮助编译器进行恰当的类型推导，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Mu a = Mu (Mu a -&amp;gt; a)

y :: (a -&amp;gt; a) -&amp;gt; a
y f = (\h -&amp;gt; h $ Mu h) (\x -&amp;gt; f . (\(Mu g) -&amp;gt; g) x $ x)&lt;/code&gt;&lt;p&gt;最后，&lt;code class=&quot;inline&quot;&gt;fact&#39;&lt;/code&gt;就可以使用Y组合子来定义了。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact&#39; :: Int -&amp;gt; Int
fact&#39; = y $ \fact -&amp;gt; \n -&amp;gt; case n of 
  1 -&amp;gt; 1
  n -&amp;gt; n * fact (n-1)&lt;/code&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文从简单的“方程”思想出发，引出了不动点的概念，&lt;br&gt;然后把递归函数看做了另外一个函数的不动点，&lt;br&gt;最后，我们讨论了Y组合子这样一个具体的不动点算子。&lt;/p&gt;&lt;p&gt;可是，这里隐藏着一个问题，我们看到&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;是可以求解任意函数的不动点的，&lt;br&gt;而对于以下递归函数&lt;code class=&quot;inline&quot;&gt;succ&lt;/code&gt;，即 &lt;equation&gt;f(x)=x+1&lt;/equation&gt; ，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;succ :: Int -&amp;gt; Int
succ n = n+1&lt;/code&gt;&lt;p&gt;在实数域上是显然没有不动点的。&lt;/p&gt;&lt;p&gt;那么&lt;code class=&quot;inline&quot;&gt;fix succ&lt;/code&gt;是什么呢？&lt;br&gt;这个问题，我们将在后文中继续讨论。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E6%96%B9%E7%A8%8B&quot;&gt;方程&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F&quot;&gt;特征值和特征向量&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B&quot;&gt;微分方程&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E4%B8%8D%E5%8A%A8%E7%82%B9&quot;&gt;不动点&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E4%B8%8D%E5%8A%A8%E7%82%B9%E7%BB%84%E5%90%88%E5%AD%90&quot;&gt;不动点组合子&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Fix_and_recursion&quot;&gt;Haskell/Fix and recursion&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;http://stackoverflow.com/questions/4273413/y-combinator-in-haskell/5885270#5885270&quot;&gt;Y Combinator in Haskell&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-15-34526779</guid>
<pubDate>Thu, 15 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（六）：最多有多少个程序</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-14-34484014.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34484014&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上一篇中，我们通过引入极小化算子定义了递归函数，&lt;br&gt;使用递归函数，我们又定义了递归集与递归可枚举集，&lt;br&gt;本文我们要讨论，为什么递归可枚举集是“可枚举”的，以及什么是可计算函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;可计算性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a4af83dc0f3607efe72758004eb1e9f5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;429&quot;&gt;&lt;p&gt;我们听说过，现代计算机在计算能力上是与图灵机等价的，&lt;br&gt;什么叫做计算能力呢？&lt;br&gt;它指的是图灵机可计算的函数集，与现代计算机可计算的函数集是相等的。&lt;/p&gt;&lt;p&gt;为了简单起见，我们不去讨论图灵机，而是从现代计算机直接说起，&lt;br&gt;设 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 是一段程序， &lt;equation&gt;n&lt;/equation&gt; 是一个正整数，&lt;br&gt;我们称数论函数 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 为&lt;b&gt;程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 所计算的&lt;/b&gt; &lt;equation&gt;n&lt;/equation&gt; 元部分函数，&lt;br&gt;如果对于相同的输入，&lt;br&gt;要么：（1）程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的计算可以终止，此时计算结果等于 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 的相应函数值；&lt;br&gt;要么：（2）程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的计算不能终止，此时 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 无定义。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;f(x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 是一个部分函数，&lt;br&gt;如果存在程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 可计算 &lt;equation&gt;f&lt;/equation&gt; ，则称 &lt;equation&gt;f&lt;/equation&gt; 是&lt;b&gt;部分可计算的&lt;/b&gt;。&lt;br&gt;如果一个函数，既是部分可计算的，又是全函数，则称这个函数是&lt;b&gt;可计算的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;可以证明，所有的原始递归函数和递归函数都是部分可计算的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;通用程序&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们使用现代计算机进行编程的时候，并不是直接把程序的输入传给程序，&lt;br&gt;而是将程序本身以及它的输入，传给计算机，最后由计算机得到计算结果，&lt;br&gt;像这种接受任何程序和它的输入作为自己的输入，返回程序执行结果的程序，称为&lt;b&gt;通用程序&lt;/b&gt;。&lt;br&gt;为此，通用程序需要把输入的程序进行&lt;b&gt;编码&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;常用的编码方法，涉及&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%85%8D%E5%AF%B9%E5%87%BD%E6%95%B0&quot;&gt;配对函数&lt;/a&gt;和&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E6%95%B0&quot;&gt;哥德尔编码&lt;/a&gt;。&lt;br&gt;为了不引入太多的复杂性，我们可以将程序的编码理解为存储程序的二进制数据，&lt;br&gt;不同的程序会有不同的二进制表示，每一个二进制表示可以对应一段程序&lt;br&gt;（虽然可能不合法）。&lt;/p&gt;&lt;p&gt;哥德尔编码做的事情就是将程序和自然数集一一对应起来。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9a7c9ce767daf3bef81c5e3e7d5c152e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;565&quot;&gt;&lt;p&gt;因此，所有程序的个数是&lt;b&gt;可数的&lt;/b&gt;，而这些程序可计算的函数个数也一定是可数的，&lt;br&gt;它们可能是全函数，也可能是部分函数。&lt;br&gt;（其中，“可数”指的是可数集，&lt;b&gt;可数集&lt;/b&gt;是与自然数集之间存在一一映射的集合。&lt;/p&gt;&lt;p&gt;然而，自然数集上的函数全体并不可数，（证略&lt;br&gt;所以肯定存在程序不可计算的函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;集合个数的可枚举性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-216f0ef423d8f37598db6eee7ed05452_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;389&quot; data-rawheight=&quot;182&quot;&gt;&lt;p&gt;程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 所计算的函数，我们可以记为 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; ，&lt;br&gt;由此，我们可以定义通用程序 &lt;equation&gt;\Phi&lt;/equation&gt; ，则有，&lt;br&gt; &lt;equation&gt;\Phi (x_1,x_2,\cdots ,x_n,y)=\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; &lt;br&gt;其中， &lt;equation&gt;y&lt;/equation&gt; 是程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的编码。&lt;/p&gt;&lt;p&gt;因为，所有的程序与自然数集一一对应，&lt;br&gt;所以， &lt;equation&gt;\Phi (x_1,x_2,\cdots ,x_n,0),\Phi (x_1,x_2,\cdots ,x_n,1),\cdots&lt;/equation&gt; &lt;b&gt;枚举了所有的 &lt;equation&gt;n&lt;/equation&gt; 元可计算函数。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们定义 &lt;equation&gt;W_y=\lbrace x\in N|\Phi(x,y)\downarrow \rbrace&lt;/equation&gt; ，&lt;br&gt;根据递归可枚举集的定义，每一个 &lt;equation&gt;W_y&lt;/equation&gt; 是一个递归可枚举集。&lt;/p&gt;&lt;p&gt;又因为 &lt;equation&gt;\Phi(x,0),\Phi(x,1),\cdots&lt;/equation&gt; 枚举了所有的可计算函数，&lt;br&gt;而上一篇中我们看到，递归可枚举集是由部分递归函数（即，可计算函数）定义的，&lt;br&gt;一个部分递归函数确定出一个递归可枚举集，&lt;br&gt;所以， &lt;equation&gt;W_0,W_1,\cdots&lt;/equation&gt; &lt;b&gt;枚举了所有的递归可枚举集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;因此，集合 &lt;equation&gt;B&lt;/equation&gt; 是递归可枚举的，当且仅当存在 &lt;equation&gt;y\in N&lt;/equation&gt; ，使得 &lt;equation&gt;B=W_y&lt;/equation&gt; ，&lt;br&gt;称为&lt;b&gt;枚举定理&lt;/b&gt;，这就是“枚举”的含义。&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;K=\lbrace n\in N|n\in W_n\rbrace&lt;/equation&gt; ，&lt;br&gt;则 &lt;equation&gt;K&lt;/equation&gt; 是递归可枚举的，但不是递归的，（证略&lt;br&gt;因此， &lt;equation&gt;\bar{K}&lt;/equation&gt; 不是递归可枚举的，否则 &lt;equation&gt;K&lt;/equation&gt; 就是递归集了。&lt;br&gt;（根据，集合 &lt;equation&gt;B&lt;/equation&gt; 是递归的当且仅当 &lt;equation&gt;B&lt;/equation&gt; 和 &lt;equation&gt;\bar{B}&lt;/equation&gt; 是递归可枚举的，见上一篇&lt;/p&gt;&lt;p&gt;因此，我们找到了一个非递归的递归可枚举集 &lt;equation&gt;K&lt;/equation&gt; ，&lt;br&gt;以及一个非递归可枚举集 &lt;equation&gt;\bar{K}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;停机问题&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2649469b93d96783266c38873773ab78_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;374&quot; data-rawheight=&quot;234&quot;&gt;&lt;p&gt;任给一个程序和一个自然数，问该程序对这个自然数输入的计算是否停止，&lt;br&gt;这个问题称为&lt;b&gt;停机问题&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;我们可以用谓词 &lt;equation&gt;H(x,y)&lt;/equation&gt; 描述这个问题，&lt;br&gt; &lt;equation&gt;H(x,y)&lt;/equation&gt; ，表示以 &lt;equation&gt;y&lt;/equation&gt; 为代码的程序对输入 &lt;equation&gt;x&lt;/equation&gt; 的计算最终停止。&lt;br&gt;那么， &lt;equation&gt;H(x,y)&lt;/equation&gt; 是不可计算的，即，不存在一个程序来计算 &lt;equation&gt;H(x,y)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们来证明一下，假设有一个程序可以计算 &lt;equation&gt;H(x,y)&lt;/equation&gt; ，&lt;br&gt;那么我们就能用它来构造一个新程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; ，它的输入是 &lt;equation&gt;x&lt;/equation&gt; ，&lt;br&gt;这段程序当 &lt;equation&gt;H(x,x)&lt;/equation&gt; 为真时，计算不停止，而当 &lt;equation&gt;H(x,x)&lt;/equation&gt; 为假时，计算停止。&lt;/p&gt;&lt;p&gt;程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 也可以进行编码，假设为 &lt;equation&gt;y_0&lt;/equation&gt; ，现在我们来判断 &lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 为真，意味着编码为 &lt;equation&gt;y_0&lt;/equation&gt; 的程序以 &lt;equation&gt;y_0&lt;/equation&gt; 作为输入最终停止，&lt;br&gt;即程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; ，输入为 &lt;equation&gt;y_0&lt;/equation&gt; 时，最终停止，&lt;br&gt;可是根据 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的定义，此时 &lt;equation&gt;H(x,x)=H(y_0,y_0)&lt;/equation&gt; 为假才会停止，矛盾。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 为假，意味着编码为 &lt;equation&gt;y_0&lt;/equation&gt; 的程序以 &lt;equation&gt;y_0&lt;/equation&gt; 作为参数最终不会停止，&lt;br&gt;即程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; ，输入为 &lt;equation&gt;y_0&lt;/equation&gt; 时，最终不停止，&lt;br&gt;可是根据 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的定义，此时 &lt;equation&gt;H(x,x)=H(y_0,y_0)&lt;/equation&gt; 为真才不会停止，矛盾。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 不能为真也不能为假，矛盾，&lt;br&gt;因此，计算 &lt;equation&gt;H(x,y)&lt;/equation&gt; 的程序&lt;b&gt;不存在&lt;/b&gt;，我们也无法用它来构造程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;可判定性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2b6940df2115ed418d982f28f5263301_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;380&quot;&gt;&lt;p&gt;&lt;b&gt;可判定性问题&lt;/b&gt;，指的是一个询问真或者假的问题是否可以被回答。&lt;br&gt;如果我们总能回答出这个问题是真或者是假，就称该问题是&lt;b&gt;可判定的&lt;/b&gt;，&lt;br&gt;如果我们只能当问题为真的时候确定为真，为假的时候所进行的计算可能不会终止，&lt;br&gt;那么就称该问题是&lt;b&gt;半可判定的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;某元素是否属于一个递归集，是可判定的，&lt;br&gt;某元素是否属于一个递归可枚举集，是半可判定的。&lt;/p&gt;&lt;p&gt;因为，递归集是使用一个递归的全函数定义的，&lt;br&gt;而递归可枚举集是使用第一个部分递归函数定义的，&lt;br&gt;我们无法判断某个部分递归函数，在接受某参数时，是没有定义，还是计算尚未停止。&lt;br&gt;即，判断元素是否属于某递归可枚举集的程序可能永不停机&lt;b&gt;。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了函数的可计算性，通用程序，以及最多有多少个程序，&lt;br&gt;还了解了停机问题和可判定性问题。&lt;/p&gt;&lt;p&gt;这些都是可计算性理论的基础，我们清晰的看到了人类的计算能力，&lt;br&gt;以及用递归所能计算的函数范围，后文中我们开始讨论不动点理论，&lt;br&gt;这同样是一个有趣的话题。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;附&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;配对函数和哥德尔数，是对数偶和有穷数列的一种编码方式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）配对函数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;\langle x,y\rangle=2^x(2y+1)-1&lt;/equation&gt; ，称 &lt;equation&gt;\langle x,y\rangle&lt;/equation&gt; 为&lt;b&gt;配对函数&lt;/b&gt;，它是一个原始递归函数。&lt;/p&gt;&lt;p&gt;任给一个数 &lt;equation&gt;z&lt;/equation&gt; ，存在唯一的一对数 &lt;equation&gt;x&lt;/equation&gt; 和 &lt;equation&gt;y&lt;/equation&gt; ，使得 &lt;equation&gt;\langle x,y\rangle =z&lt;/equation&gt; 。&lt;br&gt; &lt;equation&gt;x&lt;/equation&gt; 是 &lt;equation&gt;z+1&lt;/equation&gt; 含有因子 &lt;equation&gt;2&lt;/equation&gt; 的个数，即使得 &lt;equation&gt;2^t|(z+1)&lt;/equation&gt; 的 &lt;equation&gt;t&lt;/equation&gt; 的最大值。&lt;br&gt; &lt;equation&gt;(z+1)/2^x&lt;/equation&gt; 必为奇数， &lt;equation&gt;y&lt;/equation&gt; 是 &lt;equation&gt;2y+1=(z+1)/2^x&lt;/equation&gt; 的唯一解。&lt;/p&gt;&lt;p&gt;一般的，记 &lt;equation&gt;l(z)=x&lt;/equation&gt; ， &lt;equation&gt;r(z)=y&lt;/equation&gt; ，则 &lt;equation&gt;l(z)&lt;/equation&gt; 和 &lt;equation&gt;r(z)&lt;/equation&gt; 也是原始递归函数。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）哥德尔数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;记 &lt;equation&gt;[a_1,a_2,\cdots ,a_n]=\prod_{i=1}^{n}p_i^{a_i}&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;[a_1,a_2,\cdots ,a_n]&lt;/equation&gt; 称为有穷数列 &lt;equation&gt;(a_1,a_2,\cdots ,a_n)&lt;/equation&gt; 的哥德尔数，其中， &lt;equation&gt;p_i&lt;/equation&gt; 是第 &lt;equation&gt;i&lt;/equation&gt; 个素数。&lt;/p&gt;&lt;p&gt;例如，[ &lt;equation&gt;[2,0,1,3]=2^2\cdot 3^0\cdot 5^1\cdot 7^3=6860&lt;/equation&gt; 。&lt;br&gt;对于每一个固定的 &lt;equation&gt;n&lt;/equation&gt; ， &lt;equation&gt;[a_1,a_2,\cdots ,a_n]&lt;/equation&gt; 是原始递归函数，并且这种编码具有唯一性。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%85%8D%E5%AF%B9%E5%87%BD%E6%95%B0&quot;&gt;配对函数&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E6%95%B0&quot;&gt;哥德尔数&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%95%B8%E9%9B%86&quot;&gt;可数集&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%88%A4%E5%AE%9A%E6%80%A7&quot;&gt;可判定性&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E5%BA%B7%E6%89%98%E5%B0%94%E5%AE%9A%E7%90%86&quot;&gt;康托尔定理&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-14-34484014</guid>
<pubDate>Wed, 14 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（五）：递归集与递归可枚举集</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-13-34447250.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34447250&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文中我们讨论了全函数和部分函数，以及计算的可终止性。&lt;br&gt;本文我们从数论函数开始，给原始递归函数集增加一种新的运算，得到了一个更大的集合。&lt;br&gt;然后根据递归函数，我们可以定义递归集和递归可枚举集，&lt;br&gt;为以后讨论可计算性与可判定性打好基础。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;数论函数&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-00ebc8699bbcc75935897546101678be_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;214&quot;&gt;&lt;p&gt;自然数集一般记为 &lt;equation&gt;N=\lbrace 0,1,2,\cdots \rbrace&lt;/equation&gt; ，那么 &lt;equation&gt;n&lt;/equation&gt; 个自然数集的笛卡尔积记为 &lt;equation&gt;N^n&lt;/equation&gt; ，&lt;br&gt;于是，我们称集合 &lt;equation&gt;N^n&lt;/equation&gt; 到 &lt;equation&gt;N&lt;/equation&gt; 的部分函数为&lt;b&gt;&lt;equation&gt;n&lt;/equation&gt; 元部分数论函数&lt;/b&gt;。&lt;br&gt;作为数论函数， &lt;equation&gt;2x&lt;/equation&gt; 是一个全函数，而 &lt;equation&gt;x/2&lt;/equation&gt; ， &lt;equation&gt;x-y&lt;/equation&gt; ， &lt;equation&gt;\sqrt{x}&lt;/equation&gt; 只是部分函数，&lt;br&gt;它们的计算结果， &lt;equation&gt;3/2&lt;/equation&gt; ， &lt;equation&gt;4-6&lt;/equation&gt; ， &lt;equation&gt;\sqrt{5}&lt;/equation&gt; 都不在 &lt;equation&gt;N&lt;/equation&gt; 中，&lt;br&gt;于是相应定义域中的点可视为没有定义。&lt;/p&gt;&lt;p&gt;为什么讨论数论函数呢，其一是因为它是一个典型数学的问题，&lt;br&gt;另外一点，则是因为我们经常把其他数学问题转换成数论问题，例如，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E6%95%B0&quot;&gt;哥德尔编码&lt;/a&gt;。&lt;br&gt;本文中，使用数论函数，可以简化我们的描述方式。&lt;/p&gt;&lt;p&gt;一个&lt;b&gt;谓词&lt;/b&gt;，指的是返回布尔值的函数，&lt;br&gt;我们还可以将谓词看做值域为 &lt;equation&gt;\lbrace 0,1\rbrace&lt;/equation&gt; 的一个数论函数。&lt;br&gt; &lt;equation&gt;0&lt;/equation&gt; 代表&lt;code class=&quot;inline&quot;&gt;True&lt;/code&gt;， &lt;equation&gt;1&lt;/equation&gt; 代表&lt;code class=&quot;inline&quot;&gt;False&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;极小化算子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-cfab5b6b86d286530c4f9ea57cb8905f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;235&quot; data-rawheight=&quot;214&quot;&gt;&lt;p&gt;在前一篇中，我们从三个初始函数出发，&lt;br&gt;通过合成运算和原始递归运算，得到了原始递归函数集，&lt;br&gt;递归函数集是相对于这两种运算封闭的。&lt;/p&gt;&lt;p&gt;然而，这样定义的原始递归函数，并不能包括所有的数论函数，&lt;br&gt;一个典型的例子就是，&lt;a href=&quot;https://zh.wikipedia.org/zh/%E9%98%BF%E5%85%8B%E6%9B%BC%E5%87%BD%E6%95%B8&quot;&gt;阿克曼函数&lt;/a&gt;，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;ackermann :: Int -&amp;gt; Int -&amp;gt; Int 
ackermann 0 x = x+1
ackermann k 0 = ackermann (k-1) 1
ackermann k x = ackermann (k-1) $ ackermann k x-1&lt;/code&gt;&lt;p&gt;&lt;b&gt;它并不是一个原始递归函数&lt;/b&gt;，（证略&lt;br&gt;因此原始递归函数集并不足以表示计算机程序中的所有函数。&lt;/p&gt;&lt;p&gt;为此，我们需要对原始递归函数集进行扩充，我们定义一个新的运算，称为&lt;b&gt;极小化运算&lt;/b&gt;，&lt;br&gt;设 &lt;equation&gt;P(x_1,\cdots ,x_n,t)&lt;/equation&gt; 是一个谓词，令 &lt;equation&gt;f(x_1,\cdots ,x_n)=min\ P(x_1,\cdots ,x_n,t)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;f(x_1,\cdots ,x_n)&lt;/equation&gt; 的值，或者是使 &lt;equation&gt;P(x_1,\cdots ,x_n,t)&lt;/equation&gt; 为真的最小 &lt;equation&gt;t&lt;/equation&gt; 值，&lt;br&gt;或者无定义，此时不存在 &lt;equation&gt;t&lt;/equation&gt; 使得 &lt;equation&gt;P(x_1,\cdots ,x_n,t)&lt;/equation&gt; 为真。&lt;br&gt;这样通过 &lt;equation&gt;min&lt;/equation&gt; 得到 &lt;equation&gt;f(x_1,\cdots ,x_n)&lt;/equation&gt; 的过程称为&lt;b&gt;极小化运算&lt;/b&gt;，&lt;br&gt;也称部分函数 &lt;equation&gt;f(x_1,\cdots ,x_n)&lt;/equation&gt; 是由谓词经过极小化运算得到的。&lt;/p&gt;&lt;p&gt;以上我们给谓词定义了极小化运算，现在我们将极小化运算推广到一般的函数上面，&lt;br&gt;设 &lt;equation&gt;g(x_1,\cdots ,x_n,t)&lt;/equation&gt; 是一个 &lt;equation&gt;n+1&lt;/equation&gt; 元函数，令&lt;br&gt; &lt;equation&gt;f(x_1,\cdots ,x_n)=min\lbrace g(x_1,\cdots ,x_n,t)=0\rbrace&lt;/equation&gt; &lt;br&gt;则称部分函数 &lt;equation&gt;f(x_1,\cdots ,x_n)&lt;/equation&gt; 是由函数 &lt;equation&gt;g(x_1,\cdots ,x_n,t)&lt;/equation&gt; 经过极小化运算得到的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;递归函数集&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;和定义原始递归函数集一样，我们从以下三个初始函数出发，&lt;br&gt;（1）零函数 &lt;equation&gt;n(x)=0&lt;/equation&gt; &lt;br&gt;（2）后继函数 &lt;equation&gt;s(x)=x+1&lt;/equation&gt; &lt;br&gt;（3）投影函数 &lt;equation&gt;u^n_i(x_1,\cdots ,x_n)=x_i&lt;/equation&gt; ， &lt;equation&gt;1\leqslant i\leqslant n&lt;/equation&gt; &lt;br&gt;由初始函数，经过有限次合成运算，原始递归运算，以及极小化运算，&lt;br&gt;得到的函数称为&lt;b&gt;递归函数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;递归函数并不一定是全函数，因为极小化运算可能会导致结果函数在某些点无定义，&lt;br&gt;递归的部分函数称为&lt;b&gt;部分递归函数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;可以证明阿克曼函数是递归函数，但不是原始递归函数，&lt;br&gt;因此，原始递归函数集是递归函数集的真子集。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;递归可枚举集&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-707e7082ba20ea7f7b155d8bb50da75a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;518&quot; data-rawheight=&quot;353&quot;&gt;&lt;p&gt;在具体实践中，我们经常会遇到这样的问题，&lt;br&gt;给定一个元素，我们需要判断这个元素是否属于某个集合。&lt;br&gt;这种问题，称为集合的成员资格问题。&lt;/p&gt;&lt;p&gt;沿用这一思路，我们可以使用一个谓词 &lt;equation&gt;\chi _B&lt;/equation&gt; 来定义相应的集合 &lt;equation&gt;B\subseteq N&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;B=\lbrace x\in N|\chi _B(x)\rbrace&lt;/equation&gt; &lt;br&gt;谓词 &lt;equation&gt;\chi _B(x)&lt;/equation&gt; 为真，则 &lt;equation&gt;x\in B&lt;/equation&gt; 。&lt;br&gt;这个谓词 &lt;equation&gt;\chi _B(x)&lt;/equation&gt; ，通常称为集合 &lt;equation&gt;B&lt;/equation&gt; 的&lt;b&gt;特征函数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;如果特征函数 &lt;equation&gt;\chi _B&lt;/equation&gt; 是一个递归的全函数，&lt;br&gt;则我们总是可以判断 &lt;equation&gt;\chi _B(x)&lt;/equation&gt; 等于 &lt;equation&gt;0&lt;/equation&gt; 还是 &lt;equation&gt;1&lt;/equation&gt; ，&lt;br&gt;这样的集合 &lt;equation&gt;B&lt;/equation&gt; 称为&lt;b&gt;递归集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;如果存在部分递归函数 &lt;equation&gt;g&lt;/equation&gt; ，使得 &lt;equation&gt;B=\lbrace x\in N|g(x)\downarrow \rbrace&lt;/equation&gt; ，&lt;br&gt;即， &lt;equation&gt;x\in B&lt;/equation&gt; 当且仅当 &lt;equation&gt;g&lt;/equation&gt; 在 &lt;equation&gt;x&lt;/equation&gt; 处有定义，&lt;br&gt;则称集合 &lt;equation&gt;B&lt;/equation&gt; 是一个&lt;b&gt;递归可枚举集&lt;/b&gt;。&lt;br&gt;每一个部分递归函数，都确定出一个递归可枚举集。&lt;/p&gt;&lt;p&gt;因此，对于每一个自然数 &lt;equation&gt;x\in N&lt;/equation&gt; ，&lt;br&gt;我们总是可以通过递归集 &lt;equation&gt;B&lt;/equation&gt; 的特征函数 &lt;equation&gt;\chi _B&lt;/equation&gt; ，来判断 &lt;equation&gt;x&lt;/equation&gt; 是否 &lt;equation&gt;B&lt;/equation&gt; 的成员。&lt;br&gt;而对于递归可枚举集，就不容乐观了，&lt;br&gt;如果某个自然数 &lt;equation&gt;x\in N&lt;/equation&gt; 是 &lt;equation&gt;B&lt;/equation&gt; 的成员，那么我们可以断定这件事，因为 &lt;equation&gt;g(x)&lt;/equation&gt; 有定义，&lt;br&gt;但是如果某个自然数 &lt;equation&gt;y\in N&lt;/equation&gt; 不是 &lt;equation&gt;B&lt;/equation&gt; 的成员，我们就不能确定，因为这时候 &lt;equation&gt;g(x)&lt;/equation&gt; 无定义。&lt;br&gt;（ &lt;equation&gt;g(x)&lt;/equation&gt; 无定义，则它对应的图灵机不停机，后文我们详细讨论&lt;/p&gt;&lt;p&gt;因此，集合 &lt;equation&gt;B&lt;/equation&gt; 是递归的当且仅当 &lt;equation&gt;B&lt;/equation&gt; 和 &lt;equation&gt;\bar{B}&lt;/equation&gt; 是递归可枚举的，&lt;br&gt;其中 &lt;equation&gt;\bar{B}&lt;/equation&gt; 为 &lt;equation&gt;B&lt;/equation&gt; 的补集。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了数论函数，递归函数集，然后用递归函数分别定义了递归集和递归可枚举集，&lt;br&gt;可是为什么递归可枚举集是“可枚举”的呢？&lt;/p&gt;&lt;p&gt;是因为每一个递归可枚举集可以一一对应一个自然数，这是怎样做到的呢？&lt;br&gt;这需要我们理解总共有多少个可能的程序，以及什么是通用程序。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92%E9%9B%86%E5%90%88&quot;&gt;递归集&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92%E5%8F%AF%E6%9E%9A%E4%B8%BE%E9%9B%86%E5%90%88&quot;&gt;递归可枚举集&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-13-34447250</guid>
<pubDate>Tue, 13 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（四）：全函数与计算的可终止性</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-12-34425726.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34425726&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9488c88c2a5273ccfd75c83a424585ca_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;300&quot; data-rawheight=&quot;300&quot;&gt;&lt;p&gt;上文我们讨论了集合上的关系，还讨论了数学归纳法的一种普遍形式，称为良基归纳法，&lt;br&gt;它建立在集合上的良基关系之上。&lt;/p&gt;&lt;p&gt;本文开始讨论函数，我们将回顾函数的定义，&lt;br&gt;然后解释什么是全函数（total function），什么是部分函数（partial function）。&lt;/p&gt;&lt;p&gt;我们会看到，在证明一个递归函数是全函数时，&lt;br&gt;良基归纳法起到了重要作用。&lt;/p&gt;&lt;p&gt;在分析学中，人们似乎很少关心函数的完全性，&lt;br&gt;只关心它的连续性，可导性，可微性与可积性，等等。&lt;br&gt;而在计算机科学领域中，人们更在意计算的可终止性，&lt;br&gt;因此一个函数在某个点是否有定义将经常被提及。&lt;/p&gt;&lt;p&gt;程序中定义的函数，往往对应于某个集合上的数学函数，&lt;br&gt;为了描述程序的非终止性，就得扩充这个数学函数的定义域和值域。&lt;br&gt;为了理解这些事情，我们先要从函数的定义开始。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;函数&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;集合 &lt;equation&gt;A,B&lt;/equation&gt; 上的关系，是笛卡尔积 &lt;equation&gt;A\times B&lt;/equation&gt; 的一个子集。&lt;/p&gt;&lt;p&gt;而&lt;b&gt;函数&lt;/b&gt; &lt;equation&gt;f:A\rightarrow B&lt;/equation&gt; ，则是集合 &lt;equation&gt;A,B&lt;/equation&gt; 上的一种特殊关系，&lt;br&gt;它要求 &lt;equation&gt;A&lt;/equation&gt; 中的每一个元素，都有 &lt;equation&gt;B&lt;/equation&gt; 中&lt;b&gt;唯一确定的&lt;/b&gt;元素与之对应。&lt;br&gt;其中，集合 &lt;equation&gt;A&lt;/equation&gt; 称为函数 &lt;equation&gt;f&lt;/equation&gt; 的&lt;b&gt;定义域&lt;/b&gt;，集合 &lt;equation&gt;B&lt;/equation&gt; 称为函数的&lt;b&gt;值域&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;函数是我们熟悉的概念，这里只是提到了它本质上是集合上的一个关系。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）部分函数（partial function）&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-874ea6c6827de852cd55a96727978878_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;200&quot; data-rawheight=&quot;200&quot;&gt;&lt;p&gt;如果 &lt;equation&gt;f&lt;/equation&gt; 是从 &lt;equation&gt;A&lt;/equation&gt; 到 &lt;equation&gt;B&lt;/equation&gt; 的二元关系，且 &lt;equation&gt;\forall a\in A&lt;/equation&gt; ， &lt;equation&gt;f(a)=\varnothing&lt;/equation&gt; 或 &lt;equation&gt;\lbrace b\rbrace&lt;/equation&gt; ，&lt;br&gt;则称 &lt;equation&gt;f&lt;/equation&gt; 是从 &lt;equation&gt;A&lt;/equation&gt; 到 &lt;equation&gt;B&lt;/equation&gt; 的&lt;b&gt;部分函数&lt;/b&gt;，或 &lt;equation&gt;A&lt;/equation&gt; 上的部分函数。&lt;/p&gt;&lt;p&gt;其中，如果 &lt;equation&gt;f(a)=\lbrace b\rbrace&lt;/equation&gt; ，则称 &lt;equation&gt;f(a)&lt;/equation&gt; &lt;b&gt;有定义&lt;/b&gt;，记为 &lt;equation&gt;f(a)\downarrow&lt;/equation&gt; ，&lt;br&gt;也称 &lt;equation&gt;b&lt;/equation&gt; 为 &lt;equation&gt;f&lt;/equation&gt; 在 &lt;equation&gt;a&lt;/equation&gt; 点的函数值，记为 &lt;equation&gt;f(a)=b&lt;/equation&gt; 。&lt;br&gt;如果 &lt;equation&gt;f(a)=\varnothing&lt;/equation&gt; ，则称 &lt;equation&gt;f(a)&lt;/equation&gt;&lt;b&gt; 无定义&lt;/b&gt;，记为 &lt;equation&gt;f(a)\uparrow&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）全函数（total function）&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98cba4b9c4f902aab70190f355394426_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;200&quot; data-rawheight=&quot;200&quot;&gt;&lt;p&gt;如果 &lt;equation&gt;\forall a\in A&lt;/equation&gt; 都有 &lt;equation&gt;f(a)\downarrow&lt;/equation&gt; ，则称 &lt;equation&gt;f&lt;/equation&gt; 是 &lt;equation&gt;A&lt;/equation&gt; 上的全函数，&lt;br&gt;此时，可以记为 &lt;equation&gt;f:A\rightarrow B&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;可见，我们熟悉的函数，指的是全函数。&lt;br&gt;值得注意的是，部分函数的定义已经包含了我们学过的“函数”的定义，&lt;br&gt;后文中，我们提到的“函数”如果不强调它的完全性的话，都泛指部分函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;非终止性&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;部分函数在计算机科学中是非常重要的，&lt;br&gt;因为对于每一个 &lt;equation&gt;a\in A&lt;/equation&gt; ，一个算法可以表示为，计算出集合 &lt;equation&gt;B&lt;/equation&gt; 中与之对应元素的过程，&lt;br&gt;这个算法可能对于某些值 &lt;equation&gt;a\in A&lt;/equation&gt; 不会终止，而这种情况是很常见的。&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;f :: Int -&amp;gt; Int
f 1 = 1
f n = n + f(n-2)&lt;/code&gt;&lt;p&gt;这样定义的函数&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;，对应了数学上的一个部分函数 &lt;equation&gt;f&lt;/equation&gt; ，它只在某些情况下有意义，&lt;br&gt;只有当&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;是奇数时，我们才能得到终止性的结果。&lt;br&gt;而当&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;是偶数时，算法会无限的递归下去，直到堆栈溢出。&lt;/p&gt;&lt;p&gt;因此，将&lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt;解释为整数集 &lt;equation&gt;N&lt;/equation&gt; ，将&lt;code class=&quot;inline&quot;&gt;f :: Int -&amp;gt; Int&lt;/code&gt;解释为整数集上的函数，&lt;br&gt;似乎是有问题的，因为， &lt;equation&gt;f(2)&lt;/equation&gt; 并不是一个整数，它的计算不能终止。&lt;/p&gt;&lt;p&gt;为了描述非终止性，就需要对整数集进行扩充，&lt;br&gt;我们给整数集加上一个特殊元素“ &lt;equation&gt;\perp&lt;/equation&gt; ”，称为&lt;b&gt;bottom&lt;/b&gt;，来表示非终止性，&lt;br&gt;而将&lt;code class=&quot;inline&quot;&gt;f :: Int -&amp;gt; Int&lt;/code&gt;解释为集合 &lt;equation&gt;N\cup \lbrace \perp \rbrace&lt;/equation&gt; 上的一个数学函数。&lt;/p&gt;&lt;p&gt;像这种通过构造表达程序含义的数学对象，来对程序进行分析的方法，来自&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8C%87%E7%A7%B0%E8%AF%AD%E4%B9%89&quot;&gt;指称语义学&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;指称语义中，人们会区分函数的严格性，一个函数称为&lt;b&gt;严格的&lt;/b&gt;（strict），&lt;br&gt;如果接受一个非终止的输入表达式，函数的计算仍然不会终止，即， &lt;equation&gt;f(\perp )=\perp&lt;/equation&gt; 。&lt;br&gt;否则，称函数为&lt;b&gt;不严格的&lt;/b&gt;（non-strict）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;原始递归函数&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fcac4612d17b9df75820b2d778789687_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;271&quot; data-rawheight=&quot;186&quot;&gt;&lt;p&gt;我们看到在程序中使用递归，可能会导致非终止性的计算，而有些递归又不会。&lt;br&gt;这是为什么呢？&lt;/p&gt;&lt;p&gt;我们可以从递归函数论中找到一些线索。&lt;br&gt;递归函数论是和图灵机以及 &lt;equation&gt;\lambda&lt;/equation&gt; 演算相等价的计算模型，它从另一个角度刻画了可计算性。&lt;br&gt;可计算性是一个有趣的话题，后续文章中，我们会详细讨论。&lt;/p&gt;&lt;p&gt;在递归函数论中，人们把函数划分为了3个层次，&lt;br&gt;原始递归函数，递归函数，和其他的不能用递归函数表示的“函数”。&lt;br&gt;这些函数集合的范围越来越大。&lt;/p&gt;&lt;p&gt;本文我们先介绍原始递归函数，&lt;br&gt;为此，我们需要先定义两种运算。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）合成运算&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;f&lt;/equation&gt; 是 &lt;equation&gt;k&lt;/equation&gt; 元部分函数， &lt;equation&gt;g_1,g_2,\cdots ,g_k&lt;/equation&gt; 是 &lt;equation&gt;k&lt;/equation&gt; 个 &lt;equation&gt;n&lt;/equation&gt; 元部分函数，令，&lt;br&gt; &lt;equation&gt;h(x_1,\cdots ,x_n)=f(g_1(x_1,\cdots ,x_n),\cdots ,g_k(x_1,\cdots ,x_n))&lt;/equation&gt; &lt;br&gt;则称 &lt;equation&gt;h&lt;/equation&gt; 是由 &lt;equation&gt;f&lt;/equation&gt; 和 &lt;equation&gt;g_1,g_2,\cdots ,g_k&lt;/equation&gt; ，经过&lt;b&gt;合成运算&lt;/b&gt;得到的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）原始递归运算&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;f&lt;/equation&gt; 是一个 &lt;equation&gt;n&lt;/equation&gt; 元全函数， &lt;equation&gt;g&lt;/equation&gt; 是 &lt;equation&gt;n+2&lt;/equation&gt; 元全函数，令，&lt;br&gt; &lt;equation&gt;h(x_1,\cdots ,x_n,0)=f(x_1,\cdots ,x_n)&lt;/equation&gt; &lt;br&gt; &lt;equation&gt;h(x_1,\cdots ,x_n,t+1)=g(t,h(x_1,\cdots ,x_n,t),x_1,\cdots ,x_n)&lt;/equation&gt; &lt;br&gt;则称 &lt;equation&gt;h&lt;/equation&gt; 是由 &lt;equation&gt;f&lt;/equation&gt; 和 &lt;equation&gt;g&lt;/equation&gt; 经过&lt;b&gt;原始递归运算&lt;/b&gt;得到的。&lt;/p&gt;&lt;p&gt;于是，我们就可以定义原始递归函数了。&lt;/p&gt;&lt;p&gt;设&lt;b&gt;初始函数&lt;/b&gt;包括，&lt;br&gt;（1）零函数 &lt;equation&gt;n(x)=0&lt;/equation&gt; &lt;br&gt;（2）后继函数 &lt;equation&gt;s(x)=x+1&lt;/equation&gt; &lt;br&gt;（3）投影函数 &lt;equation&gt;u^n_i(x_1,\cdots ,x_n)=x_i&lt;/equation&gt; ， &lt;equation&gt;1\leqslant i\leqslant n&lt;/equation&gt; &lt;br&gt;则由初始函数经过有限次合成运算和原始递归运算得到的函数，称为&lt;b&gt;原始递归函数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;原始递归函数有以下这些性质：&lt;br&gt;由原始递归函数经过合成或原始递归得到的函数仍为原始递归函数，&lt;br&gt;因此，原始递归函数的集合在合成与原始递归运算下是封闭的。&lt;/p&gt;&lt;p&gt;此外，每一个原始递归函数都是全函数。&lt;br&gt;这是因为合成运算虽然是在部分函数上定义的，&lt;br&gt;但是如果 &lt;equation&gt;f&lt;/equation&gt; 和 &lt;equation&gt;g_1,g_2,\cdots ,g_k&lt;/equation&gt; 是全函数，那么 &lt;equation&gt;h&lt;/equation&gt; 也一定是全函数。&lt;/p&gt;&lt;p&gt;另一方面，在进行原始递归运算时，如果 &lt;equation&gt;f&lt;/equation&gt; 和 &lt;equation&gt;g&lt;/equation&gt; 是全函数，则 &lt;equation&gt;h&lt;/equation&gt; 也一定是全函数，&lt;br&gt;这是因为原始递归运算在 &lt;equation&gt;h&lt;/equation&gt; 的参数集上的定义了一个良基关系，&lt;br&gt;由良基归纳法可证， &lt;equation&gt;h&lt;/equation&gt; 是全函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a3866f274319c289a42997f7331f9611_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;259&quot; data-rawheight=&quot;246&quot;&gt;&lt;p&gt;本文介绍了全函数与部分函数，以及计算可终止性相关的概念，&lt;br&gt;我们对程序中函数的指称，进行了定义域和值域的扩充，&lt;br&gt;随后，我们进一步了解了原始递归函数，以及它的完全性，良基归纳法起到了关键作用。&lt;/p&gt;&lt;p&gt;下文，我们将深入到可计算性理论，&lt;br&gt;讨论部分可计算函数和可计算函数的区别，讨论递归函数与原始递归函数的关系，&lt;br&gt;引出递归可枚举集这个重要的概念。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Function_(mathematics)&quot;&gt;function (mathematics)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Strict_function&quot;&gt;strict function&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1310925/&quot;&gt;可计算性与计算复杂性导引&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-12-34425726</guid>
<pubDate>Mon, 12 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（三）：归纳原理</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-11-34287668.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34287668&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;自然数归纳法&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2dc9c1daf53982ff9dd9cd7829af8cef_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;534&quot; data-rawheight=&quot;318&quot;&gt;&lt;p&gt;自然数归纳法，是一种数学证明方法，&lt;br&gt;通常被用于证明某个给定命题在整个（或者局部）自然数范围内成立。&lt;br&gt;它可以用一个有限的方式写出一个无限的证明。&lt;/p&gt;&lt;p&gt;后续文章中我们会看到，&lt;br&gt;这种用有限表示无限的方法，其实是有局限性的，并不能用来解决所有的问题，&lt;br&gt;它能处理的只是无限中的一个子集罢了。&lt;/p&gt;&lt;p&gt;自然数归纳法，我们可以描述如下：&lt;br&gt;为证明对每一个自然数 &lt;equation&gt;n&lt;/equation&gt; ，命题 &lt;equation&gt;P(n)&lt;/equation&gt; 为真，只需要证明两件事，&lt;br&gt;（1）对于自然数 &lt;equation&gt;1&lt;/equation&gt; ，命题 &lt;equation&gt;P(1)&lt;/equation&gt; 为真&lt;br&gt;（2）如果对于自然数 &lt;equation&gt;m&lt;/equation&gt; ，命题 &lt;equation&gt;P(m)&lt;/equation&gt; 为真，那么对于自然数 &lt;equation&gt;m+1&lt;/equation&gt; ，命题 &lt;equation&gt;P(m+1)&lt;/equation&gt; 也为真&lt;/p&gt;&lt;p&gt;其中，第(1)条称为&lt;b&gt;起始条件&lt;/b&gt;，第(2)条称为&lt;b&gt;递推条件&lt;/b&gt;，或者称为&lt;b&gt;归纳步骤&lt;/b&gt;。&lt;br&gt;第(2)条中，为了证明 &lt;equation&gt;P(m+1)&lt;/equation&gt; 而假设的 &lt;equation&gt;P(m)&lt;/equation&gt; ，称为&lt;b&gt;归纳假设&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;这似乎是很显然的事情，我们可以在一张无限长的纸带开头写上初始条件 &lt;equation&gt;P(1)&lt;/equation&gt; ，&lt;br&gt;接着根据递推条件，由 &lt;equation&gt;P(1)&lt;/equation&gt; 我们可以证明 &lt;equation&gt;P(2)&lt;/equation&gt; 成立，&lt;br&gt;重复这种思想，我们可以由 &lt;equation&gt;P(2)&lt;/equation&gt; 证明 &lt;equation&gt;P(3)&lt;/equation&gt; 成立，如此不断的进行下去，&lt;br&gt;最终，对于每个自然数 &lt;equation&gt;n&lt;/equation&gt; ，我们都能证明 &lt;equation&gt;P(n)&lt;/equation&gt; 成立。&lt;/p&gt;&lt;p&gt;但是，这样并不算是一个有效的证明。&lt;br&gt;要证明自然数归纳法的正确性，我们还需要补充一些集合论方面的知识。&lt;br&gt;然而，在此之前，我们还是先来看自然数归纳法的一个例子吧。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;例子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4a82c1a5c4a25cf84243be45f3986796_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;272&quot;&gt;&lt;p&gt;在上一篇，我们在定义递归函数&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的时候，&lt;br&gt;先找到了“递推式”，再找到了“终止条件”，然后写出了&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的定义：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact :: Int -&amp;gt; Int
fact 1 = 1
fact n = n * fact (n-1)&lt;/code&gt;&lt;p&gt;我们还提到，有一个步骤是必不可少的，&lt;br&gt;那就是证明&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的正确性，即证明这样定义的&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;就是阶乘函数 &lt;equation&gt;f(n)=n!&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;现在，我们正好可以用自然数归纳法来证明它。&lt;br&gt;我们假设命题 &lt;equation&gt;P(n)&lt;/equation&gt; 为：&lt;code class=&quot;inline&quot;&gt;fact n&lt;/code&gt;的值为 &lt;equation&gt;n!&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;（1）对于自然数 &lt;equation&gt;1&lt;/equation&gt; ，命题 &lt;equation&gt;P(1)&lt;/equation&gt; ：&lt;code class=&quot;inline&quot;&gt;fact 1&lt;/code&gt;的值为 &lt;equation&gt;1!=1&lt;/equation&gt; ，成立&lt;br&gt;（2）假设对于自然数 &lt;equation&gt;m&lt;/equation&gt; ，命题 &lt;equation&gt;P(m)&lt;/equation&gt; ：&lt;code class=&quot;inline&quot;&gt;fact m&lt;/code&gt;的值为 &lt;equation&gt;m!&lt;/equation&gt; ，成立&lt;/p&gt;&lt;p&gt;那么，我们可以得到&lt;code class=&quot;inline&quot;&gt;fact (m+1) = (m+1) * fact m&lt;/code&gt;，值为 &lt;equation&gt;(m+1)*m!=(m+1)!&lt;/equation&gt; ，也成立。&lt;/p&gt;&lt;p&gt;所以，对于任意自然数（ &lt;equation&gt;n\geqslant 1&lt;/equation&gt; ），&lt;code class=&quot;inline&quot;&gt;fact n&lt;/code&gt;的值就是 &lt;equation&gt;n!&lt;/equation&gt; 。&lt;br&gt;于是，我们证明了&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;就是阶乘函数 &lt;equation&gt;f(n)=n!&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;自然数归纳法还有另外一种等价形式，&lt;br&gt;如果要证明 &lt;equation&gt;P(n)&lt;/equation&gt; 对每一个自然数 &lt;equation&gt;n&lt;/equation&gt; 为真，&lt;br&gt;只要证明对于任意自然数 &lt;equation&gt;m&lt;/equation&gt; ，如果 &lt;equation&gt;P(i)&lt;/equation&gt; 当 &lt;equation&gt;i&amp;lt;m&lt;/equation&gt; 为真，那么 &lt;equation&gt;P(m)&lt;/equation&gt; 也为真。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;集合上的关系&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a9ac2524ee3db1b8d2e19a941ffcfda5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;210&quot; data-rawheight=&quot;179&quot;&gt;&lt;p&gt;关系是一个日常生活用语，例如，“同学关系”，“我们的关系很好”之类的。&lt;br&gt;然而，它也是一个集合论中的概念，这给我们带来了很多困扰。&lt;br&gt;为了避免歧义，本文中从这里开始，我们开始谈论数学，我们要对集合上的“关系”进行定义。&lt;/p&gt;&lt;p&gt;直观的说，集合 &lt;equation&gt;A&lt;/equation&gt; 的元素和集合 &lt;equation&gt;B&lt;/equation&gt; 的元素之间的&lt;b&gt;关系&lt;/b&gt;是一个二元性质 &lt;equation&gt;R&lt;/equation&gt; ，&lt;br&gt;使得对于每个 &lt;equation&gt;a\in A&lt;/equation&gt; 和 &lt;equation&gt;b\in B&lt;/equation&gt; 而言， &lt;equation&gt;R(a,b)&lt;/equation&gt; 要么为真，要么为假。&lt;/p&gt;&lt;p&gt;关系通常表示为一个集合，它是笛卡尔积的子集，即，&lt;br&gt;集合 &lt;equation&gt;A&lt;/equation&gt; 和集合 &lt;equation&gt;B&lt;/equation&gt; 之间的关系 &lt;equation&gt;R&lt;/equation&gt; 是它们笛卡尔积的一个子集 &lt;equation&gt;R\subseteq A\times B&lt;/equation&gt; 。&lt;br&gt;如果序对 &lt;equation&gt;(a,b)&lt;/equation&gt; 属于子集 &lt;equation&gt;R&lt;/equation&gt; ，则认为 &lt;equation&gt;a&lt;/equation&gt; 与 &lt;equation&gt;b&lt;/equation&gt; 之间的关系为真，&lt;br&gt;否则认为 &lt;equation&gt;a&lt;/equation&gt; 与 &lt;equation&gt;b&lt;/equation&gt; 之间的关系为假。&lt;/p&gt;&lt;p&gt;通常关系直接描述为 &lt;equation&gt;R(a,b)&lt;/equation&gt; ，或者 &lt;equation&gt;aRb&lt;/equation&gt; ，而不用 &lt;equation&gt;(a,b)\in R&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;除了二元关系之外，对任何正整数 &lt;equation&gt;k&lt;/equation&gt; ，还可以定义&lt;b&gt;&lt;equation&gt;k&lt;/equation&gt; 元关系&lt;/b&gt;。&lt;br&gt;如果 &lt;equation&gt;A_1,\cdots,A_k&lt;/equation&gt; 为集合，则在 &lt;equation&gt;A_1,\cdots,A_k&lt;/equation&gt; 上的 &lt;equation&gt;k&lt;/equation&gt; 元关系，&lt;br&gt;是笛卡尔积 &lt;equation&gt;A_1\times \cdots \times A_k&lt;/equation&gt; 的一个子集。&lt;/p&gt;&lt;p&gt;某个集合上的二元关系有很多性质，例如自反性，对称性，反对称性，传递性。&lt;br&gt;一个关系 &lt;equation&gt;R\subseteq A\times A&lt;/equation&gt; 是&lt;b&gt;自反的&lt;/b&gt;，如果 &lt;equation&gt;R(a,a)&lt;/equation&gt; 对于所有的 &lt;equation&gt;a\in A&lt;/equation&gt; 成立；&lt;br&gt;是&lt;b&gt;对称的&lt;/b&gt;，如果 &lt;equation&gt;R(a,b)&lt;/equation&gt; 就有 &lt;equation&gt;R(b,a)&lt;/equation&gt; ，对于所有的 &lt;equation&gt;a,b\in A&lt;/equation&gt; 都成立；&lt;br&gt;是&lt;b&gt;反对称的&lt;/b&gt;，如果 &lt;equation&gt;R(a,b)&lt;/equation&gt; 且 &lt;equation&gt;R(b,a)&lt;/equation&gt; 则 &lt;equation&gt;a,b&lt;/equation&gt; 是同一个元素，对于所有的 &lt;equation&gt;a,b\in A&lt;/equation&gt; 都成立；&lt;br&gt;是&lt;b&gt;传递的&lt;/b&gt;，如果 &lt;equation&gt;R(a,b)&lt;/equation&gt; 和 &lt;equation&gt;R(b,c)&lt;/equation&gt; 能推出 &lt;equation&gt;R(a,c)&lt;/equation&gt; ，对于所有的 &lt;equation&gt;a,b,c\in A&lt;/equation&gt; 都成立。&lt;br&gt;（注意，反对称性不是对称性的否定。&lt;/p&gt;&lt;p&gt;&lt;b&gt;等价关系&lt;/b&gt;是同时具有自反性，对称性和传递性的关系。&lt;br&gt;&lt;b&gt;偏序关系&lt;/b&gt;是具有自反性，反对称性和传递性的关系。&lt;br&gt;等价关系的一个例子就是相等性，相等性关系 &lt;equation&gt;R(a,b)&lt;/equation&gt; 当且仅当 &lt;equation&gt;a,b&lt;/equation&gt; 是同一个元素。&lt;br&gt;偏序关系，例如通常的序关系 &lt;equation&gt;R\subseteq N\times N&lt;/equation&gt; ， &lt;equation&gt;R(a,b)&lt;/equation&gt; 当且仅当 &lt;equation&gt;a\leqslant b&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;良基关系&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-143831fefb5a8e05dbb75c4a045c419f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;408&quot; data-rawheight=&quot;292&quot;&gt;&lt;p&gt;归纳法有各种各样的形式，自然数归纳法只是其中的一种应用，&lt;br&gt;在数理逻辑和形式语言理论中，用的最多的是结构归纳法，在树形结构上进行归纳，后续文章中我们会提到。&lt;/p&gt;&lt;p&gt;人们总结了各种归纳法的共性，提出了&lt;b&gt;良基关系&lt;/b&gt;的概念，&lt;br&gt;于是，自然数归纳法和结构归纳法都变成了在良基关系上通用归纳法的具体应用了。&lt;/p&gt;&lt;p&gt;集合 &lt;equation&gt;A&lt;/equation&gt; 上的&lt;b&gt;良基关系&lt;/b&gt;（well-founded relation），是 &lt;equation&gt;A&lt;/equation&gt; 上的一个二元关系 &lt;equation&gt;\prec&lt;/equation&gt; ，&lt;br&gt;如果不存在无限下降序列（infinite descending sequence） &lt;equation&gt;a_0\succ a_1\succ a_2\cdots&lt;/equation&gt; 。&lt;br&gt;例如，自然数上的关系 &lt;equation&gt;&amp;lt;&lt;/equation&gt; ，就是一个良基关系。&lt;br&gt;但是 &lt;equation&gt;\leqslant&lt;/equation&gt; 却不是，因为存在一个无限下降序列 &lt;equation&gt;a_0\geqslant a_1\geqslant a_2\cdots&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;根据良基关系，我们可以定义集合中的&lt;b&gt;最小元&lt;/b&gt;，&lt;br&gt;&lt;equation&gt;a\in A&lt;/equation&gt; 为最小元，如果不存在 &lt;equation&gt;a&#39;\in A&lt;/equation&gt; ，使得 &lt;equation&gt;a&#39;\prec a&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;对于良基关系，有一个等价的定义，&lt;br&gt;&lt;b&gt;&lt;equation&gt;A&lt;/equation&gt; 上的二元关系 &lt;equation&gt;\prec&lt;/equation&gt; 是良基的，当且仅当 &lt;equation&gt;A&lt;/equation&gt; 的每一个非空子集 &lt;equation&gt;B&lt;/equation&gt; 有最小元。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们可以证明一下这两种说法等价性。&lt;br&gt;要证当且仅当，我们需要证明充分性和必要性，&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）充分性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;要证： &lt;equation&gt;A&lt;/equation&gt; 上的二元关系 &lt;equation&gt;\prec&lt;/equation&gt; 是良基的，则 &lt;equation&gt;A&lt;/equation&gt; 的每一个非空子集 &lt;equation&gt;B&lt;/equation&gt; 有最小元。&lt;br&gt;使用反证法，如果 &lt;equation&gt;B&lt;/equation&gt; 没有最小元，则对于每个 &lt;equation&gt;a\in B&lt;/equation&gt; ，&lt;br&gt;总可以找到 &lt;equation&gt;a&#39;\in B&lt;/equation&gt; ，使得 &lt;equation&gt;a&#39;\prec a&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;但是，如果这样的话，我们就可以对任何 &lt;equation&gt;a_0\in B&lt;/equation&gt; ，以 &lt;equation&gt;a_0&lt;/equation&gt; 开始构造一个无限下降序列 &lt;equation&gt;a_0\succ a_1\succ a_2\cdots&lt;/equation&gt; ，这与 &lt;equation&gt;\prec&lt;/equation&gt; 是一个良基关系矛盾。&lt;/p&gt;&lt;p&gt;充分性证毕。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2） 必要性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;要证：如果 &lt;equation&gt;A&lt;/equation&gt; 的每一个非空子集 &lt;equation&gt;B&lt;/equation&gt; 都有最小元，&lt;br&gt;则 &lt;equation&gt;A&lt;/equation&gt; 上用于比较的二元关系 &lt;equation&gt;\prec&lt;/equation&gt; 是良基的。&lt;/p&gt;&lt;p&gt;由于 &lt;equation&gt;A&lt;/equation&gt; 的每一个非空子集 &lt;equation&gt;B&lt;/equation&gt; 都有最小元，&lt;br&gt;则不可能存在无限下降序列 &lt;equation&gt;a_0\succ a_1\succ a_2\cdots&lt;/equation&gt; ，因此， &lt;equation&gt;\prec&lt;/equation&gt; 是良基的。&lt;/p&gt;&lt;p&gt;必要性证毕。&lt;/p&gt;&lt;p&gt;因此， &lt;equation&gt;A&lt;/equation&gt; 上的二元关系 &lt;equation&gt;\prec&lt;/equation&gt; 是良基的，当且仅当 &lt;equation&gt;A&lt;/equation&gt; 的每一个非空子集 &lt;equation&gt;B&lt;/equation&gt; 有最小元。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;良基归纳法&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2c813b575e2e614578b648087e3df9a4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;568&quot; data-rawheight=&quot;465&quot;&gt;&lt;p&gt;设 &lt;equation&gt;\prec&lt;/equation&gt; 为集合 &lt;equation&gt;A&lt;/equation&gt; 上的良基二元关系，并且设 &lt;equation&gt;P&lt;/equation&gt; 为关于 &lt;equation&gt;A&lt;/equation&gt; 中元素的某个命题，&lt;br&gt;如果 &lt;equation&gt;P(b)&lt;/equation&gt; 对于所有的 &lt;equation&gt;b\prec a&lt;/equation&gt; 成立，就必然有 &lt;equation&gt;P(a)&lt;/equation&gt; 成立，&lt;br&gt;那么 &lt;equation&gt;P(a)&lt;/equation&gt; 就对所有的 &lt;equation&gt;a\in A&lt;/equation&gt; 成立。&lt;/p&gt;&lt;p&gt;我们看到 &lt;equation&gt;&amp;lt;&lt;/equation&gt; 确实是自然数集上的良基关系，因此自然数归纳法只是良基归纳法的一种特例。&lt;/p&gt;&lt;p&gt;现在我们有了足够的能力来证明自然数归纳法的正确性了，&lt;br&gt;只要我们证明了良基归纳法是正确的。&lt;/p&gt;&lt;p&gt;还是用&lt;b&gt;反证法&lt;/b&gt;：&lt;/p&gt;&lt;p&gt;我们期望证明，&lt;br&gt;&lt;b&gt;前提：&lt;/b&gt;如果 &lt;equation&gt;P(b)&lt;/equation&gt; 对于所有的 &lt;equation&gt;b\prec a&lt;/equation&gt; 成立，必然有 &lt;equation&gt;P(a)&lt;/equation&gt; 成立，&lt;br&gt;&lt;b&gt;结论：&lt;/b&gt;那么对于所有的 &lt;equation&gt;a\in A&lt;/equation&gt; ， &lt;equation&gt;P(a)&lt;/equation&gt; 都成立。&lt;/p&gt;&lt;p&gt;如若不然，假设存在 &lt;equation&gt;x\in A&lt;/equation&gt; ，使得 &lt;equation&gt;P(x)&lt;/equation&gt; 不成立，&lt;br&gt;则集合 &lt;equation&gt;B=\{a\in A\ |\ \neg P(a)\}&lt;/equation&gt; 非空，&lt;br&gt;因此根据良基关系的等价定义，集合 &lt;equation&gt;B&lt;/equation&gt; 必有最小元 &lt;equation&gt;m\prec B\subseteq A&lt;/equation&gt; ，&lt;br&gt;而且， &lt;equation&gt;\neg P(m)&lt;/equation&gt; 成立。&lt;/p&gt;&lt;p&gt;则根据前提的逆否命题，一定存在 &lt;equation&gt;b\prec m&lt;/equation&gt; ，使得 &lt;equation&gt;\neg P(b)&lt;/equation&gt; 成立，&lt;br&gt;所以，我们有 &lt;equation&gt;b\in B&lt;/equation&gt; ，且 &lt;equation&gt;b \prec m&lt;/equation&gt; ，与 &lt;equation&gt;m&lt;/equation&gt; 是 &lt;equation&gt;B&lt;/equation&gt; 的最小元矛盾。&lt;/p&gt;&lt;p&gt;证毕。&lt;/p&gt;&lt;p&gt;由此，我们证明了良基归纳法的正确性。&lt;br&gt;理解良基关系和偏序关系，是理解递归和不动点算子的第一步。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a4cae22aff8b6d791971cfcc0d2a8de2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;220&quot; data-rawheight=&quot;361&quot;&gt;&lt;p&gt;本文从自然数归纳法出发，补充了一些集合论方面的知识，&lt;br&gt;让我们熟悉了集合上的几种常用关系，例如，等价关系，偏序关系和良基关系，&lt;br&gt;这些关系在以后的文章中还会被再次提到。&lt;/p&gt;&lt;p&gt;最后，我们证明了良基归纳法，从而证明了自然数归纳法的正确性。&lt;br&gt;不知道是否很明显了，递归的步骤和归纳的步骤，简直是太像了，&lt;br&gt;这一定不是偶然。&lt;/p&gt;&lt;p&gt;在&lt;a href=&quot;https://book.douban.com/subject/26429992/&quot;&gt;The Little Prover&lt;/a&gt;一书中，为了证明递归函数是否全函数（total function），&lt;br&gt;作者使用了测度（measure）的概念，这实际上定义了参数集上的一个良基关系。&lt;br&gt;全函数是可计算理论中一个很重要的概念，&lt;br&gt;到底什么是全函数，什么是测度？下文我们再详细讨论。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95&quot;&gt;维基百科 - 数学归纳法&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB&quot;&gt;维基百科 - 二元关系&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%89%AF%E5%9F%BA%E5%85%B3%E7%B3%BB&quot;&gt;维基百科 - 良基关系&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1144542/&quot;&gt;程序设计语言的形式语义&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-11-34287668</guid>
<pubDate>Sun, 11 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（二）：编写递归函数的思路和技巧</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-10-34287414.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34287414&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bc103055d4f8d209a9087df68eeddf49_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;680&quot; data-rawheight=&quot;310&quot;&gt;&lt;p&gt;递归，是一个熟悉而陌生的概念，说它熟悉，是因为人们经常提起它，&lt;br&gt;而说它陌生，指的是人们在实际编程中几乎不会主动使用它。&lt;/p&gt;&lt;p&gt;给定一个问题，如果本质上它能看做一个调用自身的规模较小的一个子问题来求解，&lt;br&gt;那么给出一个递归的算法解，就是很自然的。&lt;br&gt;然而，即使是这样，编制一个递归函数也是一件令人头疼的事情。&lt;/p&gt;&lt;p&gt;本系列文章的目的，可能并不局限于指出如何编写一个递归函数，&lt;br&gt;而是期望想从递归函数开始，了解它相关的科学知识，以达到对不同领域触类旁通的效果。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 从一个简单的例子开始&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先，我们来重温一下递归的概念，&lt;br&gt;维基百科上是这样描述的，&lt;/p&gt;&lt;blockquote&gt;递归（recursion），在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。&lt;/blockquote&gt;&lt;p&gt;我们来看一个简单的例子吧。（&lt;a href=&quot;https://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt;代码&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact :: Int -&amp;gt; Int
fact 1 = 1
fact n = n * fact (n-1)&lt;/code&gt;&lt;p&gt;在这个例子中，&lt;br&gt;第一行&lt;code class=&quot;inline&quot;&gt;fact :: Int -&amp;gt; Int&lt;/code&gt;表示了&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;函数的类型，&lt;br&gt;第二行和第三行定义了函数&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;，&lt;br&gt;我们看到第三行，在对&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;函数定义的时候，等式右边又出现了&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;，&lt;br&gt;这样定义的函数&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;是递归的。&lt;/p&gt;&lt;p&gt;我们调用一下&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;，来看看结果，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact 10
3628800&lt;/code&gt;&lt;p&gt;嗯嗯，&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;就是阶乘函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 写递归函数的步骤&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;那么，给定一个问题，我们编写一个递归函数，要如何开始呢？&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）递推式&lt;/b&gt;&lt;/p&gt;&lt;p&gt;首先，我们要找到“递推式”。&lt;/p&gt;&lt;p&gt;例如，在数学上阶乘的定义是， &lt;equation&gt;f(n)=n!&lt;/equation&gt; ，这样的表述形式，不具有递推性。&lt;br&gt;我们先要想办法把 &lt;equation&gt;f(n)&lt;/equation&gt; 用 &lt;equation&gt;f(n-1)&lt;/equation&gt; 表示出来。&lt;/p&gt;&lt;p&gt;经过思考之后，我们可以证明， &lt;equation&gt;f(n)=n*f(n-1)&lt;/equation&gt; ，&lt;br&gt;于是，我们就走出了关键的第一步，得到了“递推式”。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）找出终止条件&lt;/b&gt;&lt;/p&gt;&lt;p&gt;有了“递推式”还不行，我们还需要确定递推在什么时候终止。&lt;br&gt;我们知道 &lt;equation&gt;f(1)=1&lt;/equation&gt; ， &lt;equation&gt;f(2)=2*f(1)&lt;/equation&gt; ， &lt;equation&gt;f(3)=3*f(2)&lt;/equation&gt; ，等等，&lt;br&gt;因此，我们只需要指定 &lt;equation&gt;f(1)=1&lt;/equation&gt; ，那么递推就会在 &lt;equation&gt;f(n)&lt;/equation&gt; ，当 &lt;equation&gt;n=1&lt;/equation&gt; 的时候终止了。&lt;/p&gt;&lt;p&gt;终止，就是不再调用规模更小的问题了。&lt;br&gt;这时，终止条件是 &lt;equation&gt;f(1)=1&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（3）用数学归纳法证明解的正确性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这一步是很重要的，有很多人都缺少证明递推式正确性的环节，&lt;br&gt;但是，考虑到介绍&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95&quot;&gt;数学归纳法&lt;/a&gt;及其扩展会占用不少篇幅，&lt;br&gt;这里先略去，下一篇我们再回来讨论它。&lt;/p&gt;&lt;p&gt;这里，我们先假定，根据“递推式”和“终止条件”，使用数学归纳法，&lt;br&gt;我们已经证明了这样定义的 &lt;equation&gt;f(n)&lt;/equation&gt; 就是 &lt;equation&gt;n!&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（4）根据递推式和终止条件，编写程序&lt;/b&gt;&lt;/p&gt;&lt;p&gt;有了“递推式”和“终止条件”，再编写程序就水到渠成了。&lt;br&gt;很多人一上来就开始编码，就会感觉毫无头绪。&lt;/p&gt;&lt;p&gt;我们再来看下那段程序，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact :: Int -&amp;gt; Int
fact 1 = 1
fact n = n * fact (n-1)&lt;/code&gt;&lt;p&gt;这不就是“递推式”和“终止条件”的忠实表示吗？&lt;br&gt;我们用&lt;code class=&quot;inline&quot;&gt;fact 1 = 1&lt;/code&gt;表示了 &lt;equation&gt;f(1)=1&lt;/equation&gt; ，&lt;br&gt;用&lt;code class=&quot;inline&quot;&gt;fact n = n * fact (n-1)&lt;/code&gt;表示了 &lt;equation&gt;f(n)=n*f(n-1)&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 小技巧&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们再看个复杂一点的例子。&lt;/p&gt;&lt;p&gt;在实际项目中，我们可能会遇到循环 &lt;equation&gt;n&lt;/equation&gt; 次的场景，&lt;br&gt;在循环过程中，我们会根据索引进行运算，然后将某些符合条件的运算放到最终的结果中。&lt;/p&gt;&lt;p&gt;例如，我们选择10以内的所有偶数，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;[x|x &amp;lt;- [0..9], x `mod` 2 == 0]
[0,2,4,6,8]&lt;/code&gt;&lt;p&gt;使用以上列表解析（&lt;a href=&quot;http://www.haskell.org/haskellwiki/List_comprehension&quot;&gt;list comprehension&lt;/a&gt;）的方法，我们可以快速得到结果。&lt;br&gt;但是这里，我们想要拿它来举例，介绍一个编写递归函数常用的小技巧。&lt;/p&gt;&lt;p&gt;为了通用性，我们考虑循环&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;次，将索引传入函数&lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt;，&lt;br&gt;根据&lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt;的返回值，将结果放入一个列表中，完成这个功能的函数我们记为&lt;code class=&quot;inline&quot;&gt;myLoop&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）困境&lt;/b&gt;&lt;/p&gt;&lt;p&gt;根据前文介绍的编写步骤，我们需要先找到“递推式”和“终止条件”。&lt;/p&gt;&lt;p&gt;“终止条件”怎么写呢？&lt;br&gt;假如我们定义的递归函数称为&lt;code class=&quot;inline&quot;&gt;myLoop&lt;/code&gt;，那么 &lt;equation&gt;myLoop(0,fn)&lt;/equation&gt; 就是终止条件，它应该返回一个列表。但是这个列表在参数中没有，它随着递归调用的过程“积累”得到的。&lt;/p&gt;&lt;p&gt;好吧，那我们看“递推式”。&lt;br&gt;&lt;equation&gt;myLoop(n,fn)&lt;/equation&gt; 要用 &lt;equation&gt;myLoop(n-1,fn)&lt;/equation&gt; 的结果计算出来，&lt;br&gt;我们需要先用索引调用&lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt;，然后再根据&lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt;的返回值，放入结果列表，再继续调用 &lt;equation&gt;myLoop(n-1,fn)&lt;/equation&gt; 。可是，索引从哪来呢？&lt;br&gt;（&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;不是索引，因为索引从0开始，而&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;是逐渐变小的。&lt;/p&gt;&lt;p&gt;这是两个典型的困难，&lt;br&gt;其一，我们在递归的过程中“积累”了某些东西，&lt;br&gt;其二，我们需要传递和递归过程相关的“索引”。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）解法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这时候，我们的小技巧就有用武之地了。&lt;/p&gt;&lt;blockquote&gt;我们可以编写一个辅助的递归函数，通过增加参数的办法，提高灵活性。&lt;/blockquote&gt;&lt;p&gt;例如，我们可以编写一个辅助函数&lt;code class=&quot;inline&quot;&gt;myLoop&#39;&lt;/code&gt;，然后用&lt;code class=&quot;inline&quot;&gt;myLoop&#39;&lt;/code&gt;来实现&lt;code class=&quot;inline&quot;&gt;myLoop&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;myLoop :: Int -&amp;gt; (Int -&amp;gt; Maybe a) -&amp;gt; [a]
myLoop n fn = myLoop&#39; n 0 fn []

myLoop&#39; :: Int -&amp;gt; Int -&amp;gt; (Int -&amp;gt; Maybe a) -&amp;gt; [a] -&amp;gt; [a]
myLoop&#39; 0 i fn lst = lst
myLoop&#39; n i fn lst = case fn i of
  Just x -&amp;gt; myLoop&#39; (n-1) (i+1) fn (lst++[x])
  Nothing -&amp;gt; myLoop&#39; (n-1) (i+1) fn lst&lt;/code&gt;&lt;p&gt;以上，我们为&lt;code class=&quot;inline&quot;&gt;myLoop&#39;&lt;/code&gt;增加了参数&lt;code class=&quot;inline&quot;&gt;i&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;lst&lt;/code&gt;，分别表示“索引”和“积累”的列表。&lt;br&gt;然后，&lt;code class=&quot;inline&quot;&gt;myLoop&lt;/code&gt;就可以用&lt;code class=&quot;inline&quot;&gt;myLoop&#39;&lt;/code&gt;来实现了。&lt;/p&gt;&lt;p&gt;别忘了测试一下最终的结果，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;myLoop 10 (\x -&amp;gt; if x `mod` 2 == 0 then Just x else Nothing)
[0,2,4,6,8]&lt;/code&gt;&lt;p&gt;&lt;b&gt;（3）其他考虑&lt;/b&gt;&lt;/p&gt;&lt;p&gt;合理的利用递归函数的返回值，会减少附加参数的数量，例如，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;myLoop :: Int -&amp;gt; (Int -&amp;gt; Maybe a) -&amp;gt; [a]
myLoop n fn = myLoop&#39; n 0 fn

myLoop&#39; :: Int -&amp;gt; Int -&amp;gt; (Int -&amp;gt; Maybe a) -&amp;gt; [a]
myLoop&#39; 0 i fn = []
myLoop&#39; n i fn = case fn i of
  Just x -&amp;gt; x:(myLoop&#39; (n-1) (i+1) fn)
  Nothing -&amp;gt; myLoop&#39; (n-1) (i+1) fn&lt;/code&gt;&lt;p&gt;但最终得到的递归函数就不是&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8&quot;&gt;尾递归&lt;/a&gt;了，&lt;br&gt;关于尾递归，我们将在后续文章中讨论它。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92&quot;&gt;维基百科 - 递归&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%81%9E%E8%BF%B4%E9%97%9C%E4%BF%82%E5%BC%8F&quot;&gt;维基百科 - 递推关系式&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-10-34287414</guid>
<pubDate>Sat, 10 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（一）：开篇</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-10-34287397.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34287397&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;提到函数式编程，人们最多想到的可能是它的某些性质，&lt;br&gt;例如，不可变性，无副作用，惰性求值，类型推导，等等。&lt;/p&gt;&lt;p&gt;然而，这些性质可能并不是它能吸引粉丝的根本原因，&lt;br&gt;而是它从工业界触手可及的直接应用出发，带我们看到了人类能力的边界，&lt;br&gt;函数式编程仿佛一座桥梁，让我们普通程序员也能窥探计算机科学的奥秘。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\lambda&lt;/equation&gt; 演算是一个简洁的演算系统，但是它的计算能力却能比肩复杂的现代计算机，&lt;br&gt;因为它的简洁性质，以及与Lisp语言的紧密关系，对 &lt;equation&gt;\lambda&lt;/equation&gt; 演算有所了解的程序员也比较多。&lt;/p&gt;&lt;p&gt;提到编程语言，上下文无关文法，以及正则文法，熟悉的人可能会更多，&lt;br&gt;书写正则表达式，开发和应用DSL，甚至阅读编程语言的语法规范，都离不开它们。&lt;/p&gt;&lt;p&gt;然而，逻辑系统和递归函数论却鲜有人提及，&lt;br&gt;对如何书写递归函数人们可能仍旧心存畏惧，对类型的推导过程和原理也如坠迷雾。&lt;/p&gt;&lt;p&gt;其实，这是一块广袤的领域，其背景知识可能涉及了数学归纳法，良基或结构归纳法，&lt;br&gt;可计算性理论，不动点算子，哥德尔定理，以及证明论，模型论，等等。&lt;br&gt;数学背景，我们可能还需要补充，抽象代数，集合论，数理逻辑等离散数学的内容。&lt;/p&gt;&lt;p&gt;然而，我们的收获将是巨大的，&lt;br&gt;我们会看到用有限表示无限的递归思想，以及由这种思想导致的各种计算模型的能力限制。&lt;br&gt;递归与其他领域触类旁通之后，我们将走到数学，逻辑，计算机科学的交叉点上，&lt;br&gt;我认为这是一件值得高兴的事情。&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-10-34287397</guid>
<pubDate>Sat, 10 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Emacs之魂（九）：读取器宏</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-09-34106631.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34106631&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;1. 编译器宏&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2bb31943cb05a4b66f1109da6cfaef2f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;516&quot;&gt;&lt;p&gt;Lisp源代码文本，首先经过读取器，得到了一系列语法对象，&lt;br&gt;这些语法对象，在宏展开阶段进行变换，最终由编译器/解释器继续处理。&lt;/p&gt;&lt;p&gt;以下我们使用&lt;code class=&quot;inline&quot;&gt;defmacro&lt;/code&gt;定义了一个宏&lt;code class=&quot;inline&quot;&gt;inc&lt;/code&gt;，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(defmacro inc (var)
    `(setq ,var (1+ ,var)))&lt;/code&gt;&lt;p&gt;它可以将&lt;code class=&quot;inline&quot;&gt;(inc x)&lt;/code&gt;展开为&lt;code class=&quot;inline&quot;&gt;(setq x (1+ x))&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;inc&lt;/code&gt;宏可以看做对编译器/解释器进行“编程”，它影响了最终被编译/解释的程序。&lt;br&gt;因此，类似&lt;code class=&quot;inline&quot;&gt;inc&lt;/code&gt;这样的宏，称为&lt;b&gt;编译器宏&lt;/b&gt;（compiler macro）。&lt;/p&gt;&lt;p&gt;此外，还有一种宏，称为&lt;b&gt;读取器宏&lt;/b&gt;（reader macro），&lt;br&gt;它在源代码的读取阶段，以自定义的方式，将文本转换为语法对象。&lt;/p&gt;&lt;p&gt;引用（quote）“&lt;code class=&quot;inline&quot;&gt;&#39;&lt;/code&gt;”，就是一个读取器宏，&lt;br&gt;它将源代码文本&lt;code class=&quot;inline&quot;&gt;&#39;(1 2)&lt;/code&gt;转换成&lt;code class=&quot;inline&quot;&gt;(quote (1 2))&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 用户定义的读取器宏&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;虽然，引用“&lt;code class=&quot;inline&quot;&gt;&#39;&lt;/code&gt;”是一个读取器宏，但它却不是由用户定义的，&lt;br&gt;支持用户自定义的读取器宏，是一个很强大的语言特性，&lt;br&gt;它可以让我们摆脱语法的束缚，创建自己的语言。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.1 Common Lisp&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ac0034f27d908e076b8f1c5c6c59b47c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;160&quot; data-rawheight=&quot;160&quot;&gt;&lt;p&gt;（1）set-macro-character&lt;br&gt;在Common Lisp中，我们可以使用&lt;code class=&quot;inline&quot;&gt;set-macro-character&lt;/code&gt;，来模拟引用“&lt;code class=&quot;inline&quot;&gt;&#39;&lt;/code&gt;”的定义，&lt;/p&gt;&lt;code lang=&quot;common-lisp&quot;&gt;(set-macro-character #\&#39;
    #&#39;(lambda (stream char) 
        (list (quote quote) (read stream t nil t))))&lt;/code&gt;&lt;p&gt;当读取器遇到&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;的时候，会返回&lt;code class=&quot;inline&quot;&gt;(quote a)&lt;/code&gt;。&lt;br&gt;其中&lt;code class=&quot;inline&quot;&gt;read&lt;/code&gt;函数可以参考：&lt;a href=&quot;http://www.lispworks.com/documentation/HyperSpec/Body/f_rd_rd.htm&quot;&gt;read&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;（2）set-dispatch-macro-character&lt;br&gt;我们还可以自定义捕获字符（dispatch macro character），&lt;br&gt;例如，我们定义&lt;code class=&quot;inline&quot;&gt;#?&lt;/code&gt;来捕获后面的文本，&lt;/p&gt;&lt;code lang=&quot;common-lisp&quot;&gt;(set-dispatch-macro-character #\# #\?
    #&#39;(lambda (stream char1 char2)
        (list &#39;quote
            (let ((lst nil))
                (dotimes (i (+ (read stream t nil t) 1))
                    (push i lst))
                (nreverse lst)))))&lt;/code&gt;&lt;p&gt;读取器会将&lt;code class=&quot;inline&quot;&gt;#?7&lt;/code&gt;转换成&lt;code class=&quot;inline&quot;&gt;(0 1 2 3 4 5 6 7)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;（3）get-macro-character&lt;br&gt;我们还可以自定义分隔符，例如，以下我们定义了&lt;code class=&quot;inline&quot;&gt;#{ ... }&lt;/code&gt;分隔符，&lt;/p&gt;&lt;code lang=&quot;common-lisp&quot;&gt;(set-macro-character #\}
    (get-macro-character #\)))

(set-dispatch-macro-character #\# #\{
    #&#39;(lambda (stream char1 char2)
        (let ((accum nil)
              (pair (read-delimited-list #\} stream t)))
            (do ((i (car pair) (+ i 1)))
                ((&amp;gt; i (cadr pair))
                (list &#39;quote (nreverse accum)))
              (push i accum)))))&lt;/code&gt;&lt;p&gt;读取器会将&lt;code class=&quot;inline&quot;&gt;#{2 7}&lt;/code&gt;转换成&lt;code class=&quot;inline&quot;&gt;(2 3 4 5 6 7)&lt;/code&gt;。&lt;br&gt;其中，&lt;code class=&quot;inline&quot;&gt;get-macro-character&lt;/code&gt;可以参考：&lt;a href=&quot;http://www.lispworks.com/documentation/HyperSpec/Body/f_set_ma.htm&quot;&gt;GET-MACRO-CHARACTER&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 Racket&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-584cf7576c72a6d7d170c52876cec178_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;160&quot; data-rawheight=&quot;159&quot;&gt;&lt;p&gt;在Racket中，我们可以通过创建自定义的读取器，得到一门新语言，&lt;br&gt;例如，下面两个文件&lt;code class=&quot;inline&quot;&gt;language.rkt&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;main.rkt&lt;/code&gt;，&lt;/p&gt;&lt;p&gt;（1）&lt;code class=&quot;inline&quot;&gt;language.rkt&lt;/code&gt;模块创建了一个读取器，&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang racket
(require syntax/strip-context)

(provide (rename-out [literal-read read]
                     [literal-read-syntax read-syntax]))

(define (literal-read in)
  (syntax-&amp;gt;datum
   (literal-read-syntax #f in)))

(define (literal-read-syntax src in)
  (with-syntax ([str (port-&amp;gt;string in)])
    (strip-context
     #&#39;(module anything racket
         (provide data)
         (define data &#39;str)))))&lt;/code&gt;&lt;p&gt;（2）&lt;code class=&quot;inline&quot;&gt;main.rkt&lt;/code&gt;模块，就可以用新语法进行编写了，&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang reader &quot;language.rkt&quot;
Hello World!&lt;/code&gt;&lt;p&gt;然后，我们载入&lt;code class=&quot;inline&quot;&gt;main.rkt&lt;/code&gt;，查看该模块导出的&lt;code class=&quot;inline&quot;&gt;data&lt;/code&gt;变量，&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (require (file &quot;~/Test/main.rkt&quot;))
&amp;gt; data
&quot;\nHello World!&quot;&lt;/code&gt;&lt;p&gt;在&lt;code class=&quot;inline&quot;&gt;main.rkt&lt;/code&gt;中，&lt;br&gt;我们通过&lt;code class=&quot;inline&quot;&gt;#lang reader &quot;language.rkt&quot;&lt;/code&gt;，载入了一个自定义的读取器模块，&lt;br&gt;该模块必须导出&lt;code class=&quot;inline&quot;&gt;read&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;read-syntax&lt;/code&gt;两个函数。&lt;/p&gt;&lt;p&gt;这里，&lt;code class=&quot;inline&quot;&gt;read-syntax&lt;/code&gt;只是简单的获取源代码，导出到&lt;code class=&quot;inline&quot;&gt;data&lt;/code&gt;变量中，&lt;br&gt;最终返回了一个用于模块定义的语法对象&lt;code class=&quot;inline&quot;&gt;(module ...)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在本例中，它把&lt;code class=&quot;inline&quot;&gt;&quot;Hello World!&quot;&lt;/code&gt;转换成了一个模块定义表达式，&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(module anything racket
    (provide data)
    (define data &quot;Hello World!&quot;))&lt;/code&gt;&lt;p&gt;其中，&lt;code class=&quot;inline&quot;&gt;anything&lt;/code&gt;是模块名，&lt;code class=&quot;inline&quot;&gt;racket&lt;/code&gt;是该模块的依赖。&lt;br&gt;所以，当载入&lt;code class=&quot;inline&quot;&gt;main.rkt&lt;/code&gt;后，我们就可以获取&lt;code class=&quot;inline&quot;&gt;data&lt;/code&gt;的值了。&lt;/p&gt;&lt;p&gt;在实际应用中，我们还可以对源代码进行任意解析，创建自己的语言。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3 Emacs Lisp&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0bb085922b8effdfa6e998c8a4306626_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;160&quot; data-rawheight=&quot;159&quot;&gt;&lt;p&gt;Emacs Lisp内置的读取器，并不支持自定义的读取器宏，&lt;br&gt;为了实现读取器宏，我们需要重写Emacs内置的&lt;code class=&quot;inline&quot;&gt;read&lt;/code&gt;函数，&lt;br&gt;例如，&lt;a href=&quot;https://github.com/mishoo/elisp-reader.el&quot;&gt;elisp-reader&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;Emacs在启动时，会自动载入&lt;code class=&quot;inline&quot;&gt;~/.emacs.d/init.el&lt;/code&gt;文件，然后执行其中的配置脚本，&lt;br&gt;因此，我们可以在&lt;code class=&quot;inline&quot;&gt;init.el&lt;/code&gt;中调用&lt;a href=&quot;https://github.com/mishoo/elisp-reader.el&quot;&gt;elisp-reader&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;（1）创建&lt;code class=&quot;inline&quot;&gt;~/.emacs.d/init.el&lt;/code&gt;文件，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(add-to-list &#39;load-path &quot;~/.emacs.d/package/elisp-reader/&quot;)
(require &#39;elisp-reader)&lt;/code&gt;&lt;p&gt;（2）使用git克隆&lt;a href=&quot;https://github.com/mishoo/elisp-reader.el&quot;&gt;elisp-reader&lt;/a&gt;仓库到&lt;code class=&quot;inline&quot;&gt;~/.emacas.d/package&lt;/code&gt;文件夹，&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;git clone https://github.com/mishoo/elisp-reader.el.git ~/.emacs.d/package/elisp-reader&lt;/code&gt;&lt;p&gt;（3）打开Emacs，自动执行&lt;code class=&quot;inline&quot;&gt;init.el&lt;/code&gt;中的配置，&lt;/p&gt;&lt;p&gt;（4）在Emacs中定义一个读取器宏，然后求值整个Buffer，（&lt;code class=&quot;inline&quot;&gt;M-x ev-b&lt;/code&gt;）&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(require &#39;cl-macs)

(def-reader-syntax ?{
    (lambda (in ch)
      (let ((list (er-read-list in ?} t)))
        `(list ,@(cl-loop for (key val) on list by #&#39;cddr
                          collect `(cons ,key ,val))))))&lt;/code&gt;&lt;p&gt;（5）测试&lt;code class=&quot;inline&quot;&gt;read&lt;/code&gt;函数的执行结果，（&lt;code class=&quot;inline&quot;&gt;C-x C-e&lt;/code&gt;）&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(read &quot;{ :foo 1 :bar \&quot;string\&quot; :baz (+ 2 3) }&quot;)
&amp;gt; (list (cons :foo 1) (cons :bar &quot;string&quot;) (cons :baz (+ 2 3)))

(car { :foo 1 :bar &quot;string&quot; :baz (+ 2 3) })
&amp;gt; (:foo . 1)&lt;/code&gt;&lt;p&gt;源代码&lt;code class=&quot;inline&quot;&gt;{ :foo 1 :bar &quot;string&quot; :baz (+ 2 3) }&lt;/code&gt;被直接读取成了一个列表对象，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;((:foo . 1) (:bar &quot;string&quot;) (:baz (+ 2 3)))&lt;/code&gt;&lt;p&gt;对&lt;code class=&quot;inline&quot;&gt;car&lt;/code&gt;函数而言，它看到的是列表对象，并不知道具体的语法是什么。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了读取器宏的概念，Lisp各方言中会对读取器宏有不同程度的支持，&lt;br&gt;我们分析了Common Lisp，Racket以及Emacs Lisp的做法。&lt;/p&gt;&lt;p&gt;读取器宏直接作用到源代码文本上，用户定义的读取器宏可以对读取器进行“编程”，&lt;br&gt;借此可以支持自由灵活的语法，它是设计和使用DSL的神兵利器。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node101.html&quot;&gt;Common Lisp the Language, 2nd Edition: 8.4 Compiler Macros&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1456906/&quot;&gt;ANSI Common Lisp: 14.3 Read-Macros&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/3864436/&quot;&gt;Let Over Lambda: 4. Read Macros&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://docs.racket-lang.org/guide/hash-lang_reader.html?q=%23lang%20reader&quot;&gt;The Racket Reference: 17.3.2 Using #lang reader&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://github.com/mishoo/elisp-reader.el&quot;&gt;Github: elisp-reader&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-09-34106631</guid>
<pubDate>Fri, 09 Mar 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
