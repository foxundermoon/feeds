<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>业余程序员的个人修养</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Thu, 05 Apr 2018 12:35:48 +0800</lastBuildDate>
<item>
<title>语言背后的代数学（九）：笛卡尔闭范畴</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-04-05-35281476.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35281476&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-249328aa0e740de961f0a8ce0c329c51_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;775&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们简单的介绍了一些范畴论相关的内容，&lt;br&gt;&lt;b&gt;范畴&lt;/b&gt;由一些&lt;b&gt;对象&lt;/b&gt;和&lt;b&gt;箭头&lt;/b&gt;组成，范畴之间的箭头称为&lt;b&gt;函子&lt;/b&gt;，&lt;br&gt;函子之间的一族箭头称为&lt;b&gt;自然变换&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;范畴的对象不一定是集合，所有的箭头也不一定构成一个集合。&lt;br&gt;如果一个范畴 &lt;equation&gt;C&lt;/equation&gt; ，它的对象都是集合，所有的箭头也构成了一个集合，&lt;br&gt;就称该范畴是一个&lt;b&gt;小范畴&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Category_(mathematics)#Small_and_large_categories&quot;&gt;small categories&lt;/a&gt;）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 定义域和值域&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-07a4c0b329a05ec427d5f5b9e9681ba6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;318&quot; data-rawheight=&quot;208&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在集合论中，函数自变量所有可取值的集合，称为函数的&lt;b&gt;定义域&lt;/b&gt;，&lt;br&gt;给定函数 &lt;equation&gt;f:A\to B&lt;/equation&gt; ，其中 &lt;equation&gt;A&lt;/equation&gt; 就是 &lt;equation&gt;f&lt;/equation&gt; 的定义域，记为 &lt;equation&gt;D_f&lt;/equation&gt; ，&lt;br&gt;集合 &lt;equation&gt;f(A)=\{f(x)|x\in A\}&lt;/equation&gt; ，称为 &lt;equation&gt;f&lt;/equation&gt; 的&lt;b&gt;值域&lt;/b&gt;，记为 &lt;equation&gt;R_f&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;在范畴论中，箭头也有定义域和值域的概念。&lt;br&gt;箭头 &lt;equation&gt;f:a\to b&lt;/equation&gt; ，表示了对象 &lt;equation&gt;a&lt;/equation&gt; 和 &lt;equation&gt;b&lt;/equation&gt; 之间的关系，&lt;br&gt;我们称 &lt;equation&gt;a&lt;/equation&gt; 为箭头 &lt;equation&gt;f&lt;/equation&gt; 的&lt;b&gt;定义域&lt;/b&gt;（domain），记为 &lt;equation&gt;dom~f&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;b&lt;/equation&gt; 为箭头 &lt;equation&gt;f&lt;/equation&gt; 的&lt;b&gt;值域&lt;/b&gt;（codomain），记为 &lt;equation&gt;cod~f&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;由此，我们还可以定义范畴 &lt;equation&gt;C&lt;/equation&gt; 中，从对象 &lt;equation&gt;a&lt;/equation&gt; 到对象 &lt;equation&gt;b&lt;/equation&gt; 所有箭头的集合，&lt;br&gt; &lt;equation&gt;hom(a,b)=\{f|f\in C,dom~f=a,cod~f=b\}&lt;/equation&gt; ，常被称为&lt;b&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Morphism#Definition&quot;&gt;hom-set&lt;/a&gt;&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 笛卡尔闭范畴&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7359d35caef3fc0840b8d5ea4b17cc0f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;343&quot; data-rawheight=&quot;147&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;笛卡尔闭范畴是一种带有附加结构的范畴，这个名字虽然不是那么熟悉，&lt;br&gt;而实际上，我们经常遇到它。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.1 笛卡尔积&lt;/b&gt;&lt;/p&gt;&lt;p&gt;两个集合 &lt;equation&gt;X&lt;/equation&gt; 和 &lt;equation&gt;Y&lt;/equation&gt; 的&lt;b&gt;笛卡尔积&lt;/b&gt;，是以下所有可能有序对构成的集合，&lt;br&gt; &lt;equation&gt;X\times Y=\{(x,y)|x\in X,y\in Y\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 笛卡尔积上的函数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;equation&gt;f:X\times Y\to Z&lt;/equation&gt; ，是从笛卡尔积 &lt;equation&gt;X\times Y&lt;/equation&gt; 到 &lt;equation&gt;Z&lt;/equation&gt; 的函数，&lt;br&gt;我们可以用两种不同的视角来看待它，&lt;/p&gt;&lt;p&gt;（1）它是一个一元函数，参数取遍 &lt;equation&gt;X\times Y&lt;/equation&gt; 中的所有元素。&lt;br&gt;（2）它是一个二元函数，一个参数来自于 &lt;equation&gt;X&lt;/equation&gt; ，另一个来自于 &lt;equation&gt;Y&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;原则上，这两种理解应该是不同的，然而它们却是等价的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3 柯里化&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6059ea733638bb9ffd73dcabe9510b88_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;496&quot; data-rawheight=&quot;232&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;笛卡尔闭范畴就是反映这一类性质的数学结构，&lt;br&gt;一个范畴中，定义在乘积对象 &lt;equation&gt;a\times b&lt;/equation&gt; 上的箭头 &lt;equation&gt;f&lt;/equation&gt; ，&lt;br&gt;总是可以“自然的”由定义在某一个对象 &lt;equation&gt;a&lt;/equation&gt; 或 &lt;equation&gt;b&lt;/equation&gt; 上的箭头来决定。&lt;/p&gt;&lt;p&gt;这就是&lt;b&gt;柯里化&lt;/b&gt;（curring）的概念，&lt;br&gt;将一个二元函数柯里化指的是，将它看成一个一元函数，这个函数返回另一个一元函数。&lt;/p&gt;&lt;p&gt;假设 &lt;equation&gt;f:X\times Y\to Z&lt;/equation&gt; 是一个函数，&lt;br&gt;令 &lt;equation&gt;Z^Y=\{f|f(y)\in Z,y\in Y\}&lt;/equation&gt; 是所有 &lt;equation&gt;Y&lt;/equation&gt; 到 &lt;equation&gt;Z&lt;/equation&gt; 的函数，&lt;br&gt;则存在唯一的 &lt;equation&gt;g=X\to Z^Y&lt;/equation&gt; ，使得 &lt;equation&gt;g(x)(y)=f(x,y)&lt;/equation&gt; ， &lt;equation&gt;\forall x\in X,y\in Y&lt;/equation&gt; 。&lt;br&gt;函数 &lt;equation&gt;g&lt;/equation&gt; 称为 &lt;equation&gt;f&lt;/equation&gt; 的&lt;b&gt;柯里化&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;用hom-set的术语来表述就是，存在一个一一映射，使得，&lt;br&gt; &lt;equation&gt;hom(X\times Y,Z)\cong hom(X,Z^Y)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;2.4 Cartesian Closed&lt;/b&gt;&lt;/p&gt;&lt;p&gt;将以上柯里化的概念推广到范畴论中，我们就有，&lt;br&gt;一个&lt;b&gt;笛卡尔闭范畴&lt;/b&gt;（cartesian closed category） &lt;equation&gt;C&lt;/equation&gt; ，是满足以下几个额外条件的范畴。&lt;/p&gt;&lt;p&gt;（1） &lt;equation&gt;C&lt;/equation&gt; 中存在一个对象 &lt;equation&gt;1&lt;/equation&gt; ，使得对于任意对象 &lt;equation&gt;A\in C&lt;/equation&gt; ，有唯一的箭头 &lt;equation&gt;A\to 1&lt;/equation&gt; ，&lt;br&gt;这样的对象 &lt;equation&gt;1&lt;/equation&gt; ，称为&lt;b&gt;终对象&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Initial_and_terminal_objects&quot;&gt;terminal object&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;（2）对于任意两个对象 &lt;equation&gt;X&lt;/equation&gt; 和 &lt;equation&gt;Y&lt;/equation&gt; ，范畴 &lt;equation&gt;C&lt;/equation&gt; 中存在一个对象 &lt;equation&gt;X\times Y&lt;/equation&gt; ，&lt;br&gt;以及两个箭头 &lt;equation&gt;p_1&lt;/equation&gt; 和 &lt;equation&gt;p_2&lt;/equation&gt; ，使得， &lt;equation&gt;p_1:X\times Y\to X&lt;/equation&gt; ， &lt;equation&gt;p_2:X\times Y\to Y&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;（3）对于任意两个对象 &lt;equation&gt;Y&lt;/equation&gt; 和 &lt;equation&gt;Z&lt;/equation&gt; ，&lt;br&gt;范畴 &lt;equation&gt;C&lt;/equation&gt; 中存在一个对象 &lt;equation&gt;Z^Y&lt;/equation&gt; ，以及一个箭头 &lt;equation&gt;e:Z^Y\times Y\to Z&lt;/equation&gt; ，使得，&lt;br&gt;对于任意的箭头 &lt;equation&gt;f:X\times Y\to Z&lt;/equation&gt; ，存在唯一的箭头 &lt;equation&gt;g:X\to Z^Y&lt;/equation&gt; ，&lt;br&gt;有 &lt;equation&gt;f=e\circ (g\times I)&lt;/equation&gt; 恒成立。&lt;/p&gt;&lt;p&gt;即， &lt;equation&gt;(e\circ (g\times I))(X\times Y)=e((g\times I)(X\times Y))=e(Z^Y\times Y)=Z&lt;/equation&gt; 。&lt;br&gt;其中 &lt;equation&gt;I:Y\to Y&lt;/equation&gt; ，为对象 &lt;equation&gt;Y&lt;/equation&gt; 的恒等箭头， &lt;equation&gt;Z^Y&lt;/equation&gt; 称为&lt;b&gt;指数对象&lt;/b&gt;（exponential object）。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ff51be8d96c9c10cb2fb0995941cd926_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;470&quot; data-rawheight=&quot;302&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;3. 项的解释&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35170799&quot;&gt;第六篇&lt;/a&gt;中，为了解释简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算，&lt;br&gt;我们为每一个 &lt;equation&gt;\lambda&lt;/equation&gt; 项，找到了一个 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数中数学对象与之对应，&lt;br&gt;简要的说，我们用 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数的载体 &lt;equation&gt;A^\sigma&lt;/equation&gt; 来解释基本类型 &lt;equation&gt;\sigma&lt;/equation&gt; ，&lt;br&gt;用载体上的函数集 &lt;equation&gt;A^{\sigma\to\tau}&lt;/equation&gt; 来解释类型为 &lt;equation&gt;\sigma\to\tau&lt;/equation&gt; 的所有函数。&lt;/p&gt;&lt;p&gt;现在有了笛卡尔闭范畴，我们准备为每一个&lt;b&gt;基本类型&lt;/b&gt;选择范畴中的一个对象，&lt;br&gt;而将&lt;b&gt;项常量&lt;/b&gt; &lt;equation&gt;b&lt;/equation&gt; 解释为范畴中的一个箭头 &lt;equation&gt;unit\to\mathscr{A}[\![b]\!]&lt;/equation&gt; （原因在下文解释），&lt;br&gt;其中 &lt;equation&gt;\mathscr{A}[\![\cdot]\!]&lt;/equation&gt; 为我们在Henkin模型中定义的&lt;b&gt;含义函数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.1 封闭项的解释&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们这样定义一个&lt;b&gt;含义函数&lt;/b&gt; &lt;equation&gt;\mathscr{C}[\![\cdot]\!]&lt;/equation&gt; ，&lt;br&gt;（1） &lt;equation&gt;\mathscr{C}[\![unit]\!]=unit&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\mathscr{C}[\![b]\!]=unit\to\mathscr{A}[\![b]\!]&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;\mathscr{C}[\![\sigma\times\tau]\!]=\mathscr{C}[\![\sigma]\!]\times\mathscr{C}[\![\tau]\!]&lt;/equation&gt; &lt;br&gt;（4） &lt;equation&gt;\mathscr{C}[\![\sigma\to\tau]\!]=\mathscr{C}[\![\sigma]\!]\to\mathscr{C}[\![\tau]\!]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;3.2 带有自由变量的项&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;\Gamma\vdash M:\sigma&lt;/equation&gt; 是一个含有自由变量的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，&lt;br&gt;则在笛卡尔闭范畴中，它应该解释为从自由变量的语义对象到 &lt;equation&gt;\sigma&lt;/equation&gt; 的语义对象的一个箭头，&lt;br&gt; &lt;equation&gt;\mathscr{C}[\![\Gamma\vdash M:\sigma]\!]=\mathscr{C}[\![\Gamma]\!]\to\mathscr{C}[\![\sigma]\!]&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;值得一提的是，这里说明了，项常量 &lt;equation&gt;b&lt;/equation&gt; 为什么不能被解释为范畴中的对象，&lt;br&gt;而是解释成了箭头 &lt;equation&gt;unit\to\mathscr{A}[\![b]\!]&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;其中，类型上下文 &lt;equation&gt;\Gamma&lt;/equation&gt; 的解释，定义如下，&lt;br&gt;（1） &lt;equation&gt;\mathscr{C}[\![\varnothing]\!]=unit&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\mathscr{C}[\![\Gamma,x:\sigma]\!]=\mathscr{C}[\![\Gamma]\!]\times\mathscr{C}[\![\sigma]\!]&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了笛卡尔闭范畴，是一种具有特殊结构的范畴，&lt;br&gt;它补充了柯里化这一概念所需满足的约束条件。&lt;/p&gt;&lt;p&gt;接着我们用笛卡尔闭范畴解释了，&lt;br&gt;带有&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34815896&quot;&gt;单位类型&lt;/a&gt;，乘积类型的简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算 &lt;equation&gt;\lambda^{unit,\times,\to}&lt;/equation&gt; 。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34815896&quot;&gt;你好，类型（六）：Simply typed lambda calculus&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35170799&quot;&gt;语言背后的代数学（六）：Henkin模型&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Category_(mathematics)#Small_and_large_categories&quot;&gt;Small and Large Categories&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Class_(set_theory)&quot;&gt;Class&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/26684696/&quot;&gt;Category Theory for Computing Science&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cartesian_closed_category&quot;&gt;Cartesian closed category&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-04-05-35281476</guid>
<pubDate>Thu, 05 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（八）：范畴</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-04-04-35237925.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35237925&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8fd16e3275832ced282b1a9c125bb8c2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;775&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文中，我们用群，拓扑空间，CPO作为例子，&lt;br&gt;来说明什么是&lt;b&gt;数学结构&lt;/b&gt;，以及数学结构是如何通过映射来保持的。&lt;br&gt;群同态保持了群结构，连续映射保持了拓扑结构，连续函数保持了完全偏序结构。&lt;/p&gt;&lt;p&gt;那么群结构与拓扑结构之间是否有联系呢？&lt;br&gt;我们能否建立拓扑空间与群之间的对应关系呢？&lt;/p&gt;&lt;p&gt;在代数拓扑中，就存在这样的例子，&lt;br&gt;人们找到了和拓扑空间相关的群论概念，例如基本群和同调群，&lt;br&gt;拓扑空间的连续映射可以导出这些群的群同态。&lt;/p&gt;&lt;p&gt;这就为了人们使用代数学方法研究其他数学分支，奠定了基础，&lt;br&gt;实际上，最原始的范畴论想法也是起源于此。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 图示法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在前一篇中我们学过了&lt;b&gt;幺半群&lt;/b&gt;，&lt;br&gt;它指的是一个集合 &lt;equation&gt;M&lt;/equation&gt; ，以及 &lt;equation&gt;M&lt;/equation&gt; 上的二元运算 &lt;equation&gt;\cdot&lt;/equation&gt; ，满足以下两个条件，&lt;br&gt;（1） &lt;equation&gt;\forall x,y,z\in M&lt;/equation&gt; ， &lt;equation&gt;(x\cdot y)\cdot z=x\cdot (y\cdot z)&lt;/equation&gt; ，&lt;br&gt;（2） &lt;equation&gt;\exists e\in M&lt;/equation&gt; ， &lt;equation&gt;\forall x\in M&lt;/equation&gt; ， &lt;equation&gt;x\cdot e=e\cdot x=x&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;这两个条件除了可以用等式来表示，还可以用&lt;b&gt;图&lt;/b&gt;（diagram）来表示，&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1bd56c30e34a673a998895029362c270_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1138&quot; data-rawheight=&quot;234&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们称以上两张图都是&lt;b&gt;可交换的&lt;/b&gt;（commutative），&lt;br&gt;即，沿着不同的路径进行运算，只要起点和终点相同，则运算的结果就相同。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;&amp;lt;x,y,z&amp;gt;\mapsto &amp;lt;x,yz&amp;gt;\mapsto x(yz)&lt;/equation&gt; ，总是等于 &lt;equation&gt;&amp;lt;x,y,z&amp;gt;\mapsto &amp;lt;xy,z&amp;gt;\mapsto (xy)z&lt;/equation&gt; ，&lt;br&gt;即， &lt;equation&gt;x(yz)=(xy)z&lt;/equation&gt; ，表明 &lt;equation&gt;M&lt;/equation&gt; 中元素的运算满足&lt;b&gt;结合律&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;又例， &lt;equation&gt;&amp;lt;0,x&amp;gt;\mapsto &amp;lt;e,x&amp;gt;\mapsto ex&lt;/equation&gt; ，总是等于 &lt;equation&gt;&amp;lt;0,x&amp;gt;\mapsto x&lt;/equation&gt; ，即 &lt;equation&gt;ex=x&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;&amp;lt;x,0&amp;gt;\mapsto &amp;lt;x,e&amp;gt;\mapsto xe&lt;/equation&gt; ，总是等于 &lt;equation&gt;&amp;lt;x,0&amp;gt;\mapsto x&lt;/equation&gt; ，即 &lt;equation&gt;xe=x&lt;/equation&gt; 。&lt;br&gt;因此， &lt;equation&gt;ex=x=xe&lt;/equation&gt; ，表明 &lt;equation&gt;M&lt;/equation&gt; 中存在&lt;b&gt;幺元&lt;/b&gt; &lt;equation&gt;e&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;所以，我们可以用以上两个图表，作为幺半群的定义，称为&lt;b&gt;图示法&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;另一方面，考虑在集合论中讨论映射的时候，一般都不写具体元素，还可以表示为，&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-65f472da6c217b0f01bbc9704f4df946_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1070&quot; data-rawheight=&quot;218&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中， &lt;equation&gt;\mu:M\times M\to M&lt;/equation&gt; ， &lt;equation&gt;\eta:1\to M&lt;/equation&gt; ，是两个函数， &lt;equation&gt;1=\{0\}&lt;/equation&gt; 是只有一个元素的集合。&lt;/p&gt;&lt;p&gt;用图示法来表示幺半群，更具一般性。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 范畴&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;范畴是一个数学概念，也可以用图示法来表示。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-07f823a724618aaf5e160d394a7eab6e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;178&quot; data-rawheight=&quot;161&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;一个&lt;b&gt;范畴&lt;/b&gt; &lt;equation&gt;Cat&lt;/equation&gt; 由一系列&lt;b&gt;对象&lt;/b&gt;（object）和&lt;b&gt;箭头&lt;/b&gt;（arrow）组成。&lt;br&gt;对于每一个箭头 &lt;equation&gt;f&lt;/equation&gt; ，有两个对象与之关联，&lt;br&gt;称为箭头 &lt;equation&gt;f&lt;/equation&gt; 的&lt;b&gt;定义域&lt;/b&gt;（domain）和&lt;b&gt;值域&lt;/b&gt;（codomain）。&lt;/p&gt;&lt;p&gt;并且，还要满足以下几条规则，&lt;br&gt;（1）对于每一个对象 &lt;equation&gt;a&lt;/equation&gt; ，存在&lt;b&gt;恒等箭头&lt;/b&gt;（identity arrow）， &lt;equation&gt;i:a\to a&lt;/equation&gt; &lt;br&gt;（2）箭头满足&lt;b&gt;结合律&lt;/b&gt;，对于任意的箭头 &lt;equation&gt;f,g,h&lt;/equation&gt; ，有 &lt;equation&gt;(f\cdot g)\cdot h=f\cdot (g\cdot h)&lt;/equation&gt; &lt;br&gt;（3）箭头的集合在箭头组合运算下是&lt;b&gt;封闭的&lt;/b&gt;&lt;/p&gt;&lt;p&gt;其中， &lt;equation&gt;f\cdot g&lt;/equation&gt; 表示 &lt;equation&gt;g&lt;/equation&gt; 和 &lt;equation&gt;f&lt;/equation&gt; 的组合运算，它也是一个箭头，其中 &lt;equation&gt;g&lt;/equation&gt; 的值域是 &lt;equation&gt;f&lt;/equation&gt; 的定义域。&lt;/p&gt;&lt;p&gt;例子：&lt;br&gt;所有的集合，以集合为对象，集合之间的映射作为箭头，构成了一个范畴，&lt;br&gt;所有的群，以群作为对象，群同态作为箭头，构成了一个范畴，&lt;br&gt;所有的拓扑空间，以拓扑空间作为对象，拓扑空间之间的连续映射为箭头，构成了一个范畴。&lt;/p&gt;&lt;p&gt;以上三个例子中，&lt;br&gt;范畴中的对象都是集合，箭头都是映射，这就很容易造成误解。&lt;br&gt;因为，&lt;b&gt;范畴中的对象可以不是集合，箭头也可以不是映射，&lt;br&gt;&lt;/b&gt;理解这一点至关重要。&lt;/p&gt;&lt;p&gt;例如，完全偏序 &lt;equation&gt;(D,\leqslant)&lt;/equation&gt; ，&lt;br&gt;以 &lt;equation&gt;D&lt;/equation&gt; 中的元素作为对象，以 &lt;equation&gt;x\leqslant y&lt;/equation&gt; 作为 &lt;equation&gt;x,y&lt;/equation&gt; 之间的箭头，同样构成了一个范畴。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 函子&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;函子就是两个范畴之间的箭头。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9a2d8a5e543c0e1e27695a353869dda1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;436&quot; data-rawheight=&quot;243&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;一个&lt;b&gt;函子&lt;/b&gt; &lt;equation&gt;F&lt;/equation&gt; 是范畴 &lt;equation&gt;C&lt;/equation&gt; 到范畴 &lt;equation&gt;D&lt;/equation&gt; 的箭头， &lt;equation&gt;F:C\to D&lt;/equation&gt; ，它满足以下条件，&lt;br&gt; &lt;equation&gt;F&lt;/equation&gt; 把 &lt;equation&gt;C&lt;/equation&gt; 中的对象 &lt;equation&gt;c&lt;/equation&gt; 映射为 &lt;equation&gt;D&lt;/equation&gt; 中的对象 &lt;equation&gt;F~c&lt;/equation&gt; ，把 &lt;equation&gt;C&lt;/equation&gt; 中的箭头 &lt;equation&gt;f&lt;/equation&gt; 映射为 &lt;equation&gt;D&lt;/equation&gt; 中的箭头 &lt;equation&gt;F~f&lt;/equation&gt; 。&lt;br&gt;并且， &lt;equation&gt;F~(f\cdot g)=(F~f)\cdot (F~g)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;值得注意的是，等式左边的 &lt;equation&gt;\cdot&lt;/equation&gt; ，表示 &lt;equation&gt;C&lt;/equation&gt; 中的箭头组合运算，&lt;br&gt;等式右边的 &lt;equation&gt;\cdot&lt;/equation&gt; ，表示D&lt;i&gt;D&lt;/i&gt;中的箭头组合运算。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4. 自然变换&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;自然变换&lt;/b&gt;（natural transformation）是&lt;b&gt;一族箭头&lt;/b&gt;，&lt;br&gt;将范畴 &lt;equation&gt;A&lt;/equation&gt; 在一个函子中的像（picture），变换成了另一个函子的像。&lt;/p&gt;&lt;p&gt;给定两个函子 &lt;equation&gt;S,T:A\to B&lt;/equation&gt; ，其中 &lt;equation&gt;A&lt;/equation&gt; 和 &lt;equation&gt;B&lt;/equation&gt; 是范畴。&lt;br&gt;自然变换的每个&lt;b&gt;分量&lt;/b&gt;（components）使下图可交换。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-eed0e9ebd54183d14091dd04da29d37f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;696&quot; data-rawheight=&quot;225&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中， &lt;equation&gt;\tau_a&lt;/equation&gt; 是 &lt;equation&gt;B&lt;/equation&gt; 中的箭头， &lt;equation&gt;\tau_a:Sa\to Ta&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;5. Monad&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;范畴到自身的函子，称为&lt;b&gt;自函子&lt;/b&gt;（endofunctor）。&lt;br&gt;设 &lt;equation&gt;T:X\to X&lt;/equation&gt; 是任意范畴 &lt;equation&gt;X&lt;/equation&gt; 上的自函子，自函子复合之后仍为自函子，&lt;br&gt; &lt;equation&gt;T^2=T\circ T:X\to X&lt;/equation&gt; ， &lt;equation&gt;T^3=T^2\circ T:X\to X&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;\mu:T^2\to T&lt;/equation&gt; 是一个自然变换，其分量为 &lt;equation&gt;\mu_x:T^2x\to Tx&lt;/equation&gt; ， &lt;equation&gt;\forall x\in X&lt;/equation&gt; ，&lt;br&gt;则使用 &lt;equation&gt;\mu&lt;/equation&gt; 可以定义另外两个自然变换，&lt;br&gt; &lt;equation&gt;T\mu:T^3\to T^2&lt;/equation&gt; ，它的分量为 &lt;equation&gt;(T\mu)_x=T(\mu_x):T^3x\to T^2x&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\mu T:T^3\to T^2&lt;/equation&gt; ，它的分量为 &lt;equation&gt;(\mu T)_x=\mu_{Tx}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;范畴 &lt;equation&gt;X&lt;/equation&gt; 上的一个&lt;b&gt;Monad&lt;/b&gt;，指的是三元组 &lt;equation&gt;\left \langle T,\eta,\mu \right \rangle&lt;/equation&gt; ，它们使下图可交换，&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b877301e440b9c0f78a488e7e0022833_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;732&quot; data-rawheight=&quot;194&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;其中， &lt;equation&gt;T:X\to X&lt;/equation&gt; 是范畴 &lt;equation&gt;X&lt;/equation&gt; 上的自函子， &lt;equation&gt;\eta:I_X\to T&lt;/equation&gt; ， &lt;equation&gt;\mu:T^2\to T&lt;/equation&gt; 是两个自然变换。&lt;/p&gt;&lt;p&gt;值得注意的是，Monad与幺半群的图示法是相似的，&lt;br&gt;只需要将幺半群定义中的 &lt;equation&gt;\times&lt;/equation&gt; ，改写成自函子的复合运算，&lt;br&gt;把单位集合 &lt;equation&gt;1&lt;/equation&gt; ，改写成单位自函子即可。&lt;/p&gt;&lt;p&gt;因此，我们说&lt;b&gt;Monad是自函子范畴上的一个幺半群&lt;/b&gt;。&lt;/p&gt;&lt;blockquote&gt;All told, a monad in X is just a monoid in the category of endofunctors of X, with product x replaced by composition of endofunctors and unit set by the identity endofunctor.&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;6. Hask范畴上的Monad&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果把Haskell语言中的类型作为对象，把类型之间的函数看做箭头，&lt;br&gt;则在函数复合运算下，构成了一个范畴，称为&lt;b&gt;Hask范畴&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;函子&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Haskell中类型类（type class）&lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt;的每一个实例，定义了Hask范畴中的一个函子。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class Functor (f :: * -&amp;gt; *) where
    fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;表示了函子作用在箭头上的结果。&lt;br&gt;作用在对象上，可以使用&lt;code class=&quot;inline&quot;&gt;pure :: a -&amp;gt; f a&lt;/code&gt;来表示。&lt;/p&gt;&lt;p&gt;在Haskell中，一个类型要成为&lt;code class=&quot;inline&quot;&gt;Functor&lt;/code&gt;的实例，还要满足相应的“&lt;a href=&quot;https://wiki.haskell.org/Functor#Functor_Laws&quot;&gt;Functor Law&lt;/a&gt;”，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fmap id = id
fmap (f . g) = fmap f . fmap g&lt;/code&gt;&lt;p&gt;可以&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Category_theory#Functors&quot;&gt;证明&lt;/a&gt;，这些“Functor Law”刚好使&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;fmap&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;pure&lt;/code&gt;构成了范畴论意义上的函子。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Monad&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Haskell中类型类&lt;code class=&quot;inline&quot;&gt;Monad&lt;/code&gt;的每一个实例，定义了Hask范畴中的一个Monad。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;class Functor m =&amp;gt; Monad m where
    return :: a -&amp;gt; m a
    (&amp;gt;&amp;gt;=)  :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b&lt;/code&gt;&lt;p&gt;在Haskell中，一个类型要成为&lt;code class=&quot;inline&quot;&gt;Monad&lt;/code&gt;的实例，还要满足相应的“&lt;a href=&quot;https://wiki.haskell.org/Monad#Monad_class&quot;&gt;Monad Law&lt;/a&gt;”，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;return a &amp;gt;&amp;gt;= k                  =  k a
m        &amp;gt;&amp;gt;= return             =  m
m        &amp;gt;&amp;gt;= (\x -&amp;gt; k x &amp;gt;&amp;gt;= h)  =  (m &amp;gt;&amp;gt;= k) &amp;gt;&amp;gt;= h&lt;/code&gt;&lt;p&gt;可以&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Category_theory#Monads&quot;&gt;证明&lt;/a&gt;，这些“Monad Law”刚好使&lt;code class=&quot;inline&quot;&gt;m&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;&amp;gt;&amp;gt;=&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;return&lt;/code&gt;构成了范畴论意义上的Monad。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了范畴论相关的一些内容，&lt;br&gt;介绍了什么是&lt;b&gt;范畴&lt;/b&gt;，什么是&lt;b&gt;函子&lt;/b&gt;，什么是&lt;b&gt;自然变换&lt;/b&gt;，&lt;br&gt;这些都是理解笛卡尔闭范畴所必须的。&lt;/p&gt;&lt;p&gt;为了理解什么是范畴，我们列举了前一篇提到的群，拓扑空间，CPO作为例子，&lt;br&gt;还借用了Haskell中的Functor和Monad学习了Hask范畴。&lt;/p&gt;&lt;p&gt;下文我们将继续学习范畴论，&lt;br&gt;理解什么是笛卡尔闭范畴，以及如何用它解释简单类型 &lt;equation&gt;\lambda&lt;/equation&gt; 演算的语义。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Category_(mathematics)&quot;&gt;Category (mathematics)&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Category_theory&quot;&gt;Haskell/Category theory&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1823110/&quot;&gt;Categories for the Working Mathematician&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-04-04-35237925</guid>
<pubDate>Wed, 04 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（七）：数学结构</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-04-03-35196235.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35196235&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27827c397b0021738c85f354a4ac1a29_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;960&quot; data-rawheight=&quot;600&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-27827c397b0021738c85f354a4ac1a29&quot; data-watermark-src=&quot;v2-4b04610094818b4d074320614025cc4b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们介绍了Henkin模型，以及它的环境模型条件和组合模型条件，&lt;br&gt;它们分别为合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项和 &lt;equation&gt;CL&lt;/equation&gt; 项，找到了对应的语义解释。&lt;br&gt;然而这只是简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 的其中一种解释。&lt;/p&gt;&lt;p&gt;另一种常用的解释方式，建立在范畴论基础之上，称为&lt;b&gt;笛卡尔闭范畴&lt;/b&gt;。&lt;br&gt;为了理解这个概念，我们需要补充一些简单的范畴论方面的内容。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 数学结构&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-15c0afbc750cd718cccc5c687d907251_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;386&quot; data-rawheight=&quot;252&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-15c0afbc750cd718cccc5c687d907251&quot; data-watermark-src=&quot;v2-548a7f1498a94ad8562175e088793b5b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;范畴论的研究数学结构的形式化方法，&lt;br&gt;它不考虑具体的数学对象，而是考虑数学对象以及它们之间的联系。&lt;/p&gt;&lt;p&gt;学习范畴论最好的办法，我认为不宜马上从抽象的概念开始，&lt;br&gt;而是先回到具体的例子上面，找到相似性，&lt;b&gt;理解概念被发明的动机&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;因此，我们要先理解什么是&lt;b&gt;数学结构&lt;/b&gt;。&lt;br&gt;后文中，我们会首先介绍最常被提及的群结构，然后再介绍拓扑空间和CPO（完全偏序）。&lt;br&gt;有了这些例子之后，对抽象概念的理解是事半功倍的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 群结构&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c2e40eb216c9642a8ae011d979ebf2f9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;268&quot; data-rawheight=&quot;272&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c2e40eb216c9642a8ae011d979ebf2f9&quot; data-watermark-src=&quot;v2-254492ee31ded3056ba06f187ea2ec1e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;群是一种满足结合律的乘法结构，&lt;br&gt;但是它的运算对象，却并不局限于整数，有理数甚至实数上。&lt;br&gt;因此，群论对概念采用了不同的定义方式，和初等代数有明显的不同。&lt;/p&gt;&lt;p&gt;在初等代数中，我们研究的是具体的运算系统，&lt;br&gt;例如，我们会先介绍什么是自然数，然后再介绍自然数上的四则运算。&lt;br&gt;群论则不然。&lt;/p&gt;&lt;p&gt;它会先抽象的定义满足哪些条件的运算系统是&lt;b&gt;群&lt;/b&gt;，&lt;br&gt;然后再去寻找（或证明）具体的运算系统满足这些条件。&lt;/p&gt;&lt;p&gt;为此，我们先从条件最弱的&lt;b&gt;半群&lt;/b&gt;开始，&lt;br&gt;逐渐增加约束条件，最终认识群结构是怎么建立起来的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;半群&lt;/b&gt;&lt;/p&gt;&lt;p&gt;集合 &lt;equation&gt;G&lt;/equation&gt; 和 &lt;equation&gt;G&lt;/equation&gt; 上满足结合律的二元运算 &lt;equation&gt;\cdot&lt;/equation&gt; ，所形成的代数结构，叫做&lt;b&gt;半群&lt;/b&gt;，记为 &lt;equation&gt;(G,\cdot)&lt;/equation&gt; ，&lt;br&gt;半群运算 &lt;equation&gt;x\cdot y&lt;/equation&gt; ，也常简记为 &lt;equation&gt;xy&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;好在我们&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35017879&quot;&gt;第二篇&lt;/a&gt;中，对“什么是代数”进行了严谨的定义，&lt;br&gt;因此，对这里提到的“代数结构”应该并不陌生，很显然半群是一个代数。&lt;/p&gt;&lt;p&gt;满足半群条件的例子是非常多的，&lt;br&gt;例如，自然数集以及自然数上的乘法运算，构成了一个半群。&lt;/p&gt;&lt;p&gt;值得注意的是，集合和运算要放在一起考虑才行，&lt;br&gt;集合包含了运算对象，运算表明了运算对象之间的关系。&lt;/p&gt;&lt;p&gt;&lt;b&gt;幺半群&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a9acc7bf821b71d3d4bcc269058b8016_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;174&quot; data-rawheight=&quot;164&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;设 &lt;equation&gt;G&lt;/equation&gt; 是半群，元素 &lt;equation&gt;e\in G&lt;/equation&gt; ，称为半群 &lt;equation&gt;G&lt;/equation&gt; 的&lt;b&gt;幺元&lt;/b&gt;，如果 &lt;equation&gt;\forall x\in G&lt;/equation&gt; ， &lt;equation&gt;ex=xe=x&lt;/equation&gt; 。&lt;br&gt;可以证明，如果半群存在幺元，则必定是唯一的。&lt;/p&gt;&lt;p&gt;幺元常被记为 &lt;equation&gt;1_S&lt;/equation&gt; ，或者直接写成 &lt;equation&gt;1&lt;/equation&gt; 。&lt;br&gt;具有幺元的半群，称为&lt;b&gt;幺半群&lt;/b&gt;，记为 &lt;equation&gt;(G,\cdot,e)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;幺半群的例子，我们可以考虑字符串及其连接运算，在连接运算下，空串是幺元。&lt;/p&gt;&lt;p&gt;&lt;b&gt;群&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;G&lt;/equation&gt; 是幺半群，如果它的每个元素都可逆，我们就称它为&lt;b&gt;群&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;所谓可逆指的是， &lt;equation&gt;\forall g\in G&lt;/equation&gt; ， &lt;equation&gt;\exists g^{-1}\in G&lt;/equation&gt; ，使得 &lt;equation&gt;gg^{-1}=g^{-1}g=e&lt;/equation&gt; ，&lt;br&gt;其中 &lt;equation&gt;e\in G&lt;/equation&gt; 为 &lt;equation&gt;G&lt;/equation&gt; 的幺元。&lt;/p&gt;&lt;p&gt;自然数集以及自然数上的乘法运算组成的代数结构，是半群，&lt;br&gt;如果把自然数 &lt;equation&gt;1&lt;/equation&gt; 看做幺元，则构成了一个幺半群，但是它不是群。&lt;br&gt;因为，除了 &lt;equation&gt;1&lt;/equation&gt; 之外，任何自然数都没有逆元。&lt;/p&gt;&lt;p&gt;字符串及其连接运算，构成了一个幺半群，但也不是群，&lt;br&gt;因为，没有任何两个非空字符串连接在一起会得到空串。&lt;/p&gt;&lt;p&gt;下面我们来看一个群的例子。&lt;/p&gt;&lt;p&gt;如果我们把整数集（包含正负整数）看做运算对象的集合，&lt;br&gt;把整数集上的加法运算看做群定义中的二元运算，&lt;br&gt;整数 &lt;equation&gt;0&lt;/equation&gt; 看做加法运算的幺元，则这样的运算系统构成了一个群。&lt;br&gt;因为，每一个整数的相反数，都是它的逆元。&lt;/p&gt;&lt;p&gt;&lt;b&gt;群同态&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1dad98d538dbb99ed7df169371a75acc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;335&quot; data-rawheight=&quot;150&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1dad98d538dbb99ed7df169371a75acc&quot; data-watermark-src=&quot;v2-74213495efd2725607eb2a55d66bdd8e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;有了群之后，很自然的一步我们会考虑两个群是否足够相似，&lt;br&gt;这就需要我们找到两个群之间的对应关系。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;(G,\cdot)&lt;/equation&gt; 和 &lt;equation&gt;(G&#39;,\circ)&lt;/equation&gt; 是两个群，我们把映射 &lt;equation&gt;f:G\to G&#39;&lt;/equation&gt; 称为&lt;b&gt;群同态&lt;/b&gt;，如果 &lt;equation&gt;\forall a,b\in G&lt;/equation&gt; ，&lt;br&gt;都有 &lt;equation&gt;f(a\cdot b)=f(a)\circ f(b)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;f&lt;/equation&gt; 是单射，则称 &lt;equation&gt;f&lt;/equation&gt; 为&lt;b&gt;单同态&lt;/b&gt;，如果 &lt;equation&gt;f&lt;/equation&gt; 是满射，则称 &lt;equation&gt;f&lt;/equation&gt; 为&lt;b&gt;满同态&lt;/b&gt;。&lt;br&gt;如果 &lt;equation&gt;f&lt;/equation&gt; 是双射，则称 &lt;equation&gt;f&lt;/equation&gt; 为&lt;b&gt;群同构&lt;/b&gt;，同构的两个群，记为 &lt;equation&gt;G\cong G&#39;&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;小结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;现在我们理解了半群，幺半群，群，群同态，这些概念放在一起，就是所谓的群结构。&lt;br&gt;结构一般所指的是一些运算规则，或者约束条件。&lt;/p&gt;&lt;p&gt;为了更好的理解数学结构，&lt;br&gt;下面我们来介绍另一个概念，它来自拓扑学，称为拓扑空间。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 拓扑结构&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b19804f92307f61dfa9c884943d0de29_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;227&quot; data-rawheight=&quot;222&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b19804f92307f61dfa9c884943d0de29&quot; data-watermark-src=&quot;v2-a7e83ab352c37df599387d19028ac7a2&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;拓扑学，被人们戏称橡皮膜上的几何学，它主要研究在连续变换下保持不变的几何性质，&lt;br&gt;例如，连通性和紧致性。&lt;/p&gt;&lt;p&gt;这里我们先不展开，主要看一下在拓扑学中是怎么建立数学结构的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;子集族&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;X&lt;/equation&gt; 是一个非空集合， &lt;equation&gt;2^X&lt;/equation&gt; 是 &lt;equation&gt;X&lt;/equation&gt; 的幂集（所有子集构成的集合），&lt;br&gt;把 &lt;equation&gt;2^X&lt;/equation&gt; 的子集（即以 &lt;equation&gt;X&lt;/equation&gt; 的一部分子集为成员的集合）称为 &lt;equation&gt;X&lt;/equation&gt; 的&lt;b&gt;子集族&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;拓扑空间&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;X&lt;/equation&gt; 是一个非空集合， &lt;equation&gt;X&lt;/equation&gt; 的一个子集族 &lt;equation&gt;\tau&lt;/equation&gt; 称为 &lt;equation&gt;X&lt;/equation&gt; 的一个&lt;b&gt;拓扑&lt;/b&gt;，如果它满足&lt;br&gt;（1） &lt;equation&gt;X&lt;/equation&gt; 和 &lt;equation&gt;\varnothing&lt;/equation&gt; 都包含在 &lt;equation&gt;\tau&lt;/equation&gt; 中&lt;br&gt;（2） &lt;equation&gt;\tau&lt;/equation&gt; 中任意多个成员的并集仍在 &lt;equation&gt;\tau&lt;/equation&gt; 中&lt;br&gt;（3） &lt;equation&gt;\tau&lt;/equation&gt; 中有限多个成员的交集仍在 &lt;equation&gt;\tau&lt;/equation&gt; 中&lt;/p&gt;&lt;p&gt;集合 &lt;equation&gt;X&lt;/equation&gt; 和它的一个拓扑 &lt;equation&gt;\tau&lt;/equation&gt; 一起称为一个&lt;b&gt;拓扑空间&lt;/b&gt;，记作 &lt;equation&gt;(X,\tau)&lt;/equation&gt; 。&lt;br&gt;称 &lt;equation&gt;\tau&lt;/equation&gt; 中的成员为这个拓扑空间的&lt;b&gt;开集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;从定义看出，给出集合的一个拓扑就是规定它的哪些子集是开集。&lt;/p&gt;&lt;p&gt;&lt;b&gt;连续映射&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-974ddbef8443d9229967e11c333ded9c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;380&quot; data-rawheight=&quot;129&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-974ddbef8443d9229967e11c333ded9c&quot; data-watermark-src=&quot;v2-36a76bf9d8a466872d8d8133d0cf9ec0&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;设 &lt;equation&gt;X&lt;/equation&gt; 和 &lt;equation&gt;Y&lt;/equation&gt; 都是拓扑空间， &lt;equation&gt;f:X\rightarrow Y&lt;/equation&gt; 是一个映射，&lt;br&gt; &lt;equation&gt;x\in X&lt;/equation&gt; ，如果对于包含 &lt;equation&gt;f(x)\in Y&lt;/equation&gt; 的每一个开集 &lt;equation&gt;V&lt;/equation&gt; ，必存在包含 &lt;equation&gt;x&lt;/equation&gt; 的开集 &lt;equation&gt;U&lt;/equation&gt; ，&lt;br&gt;使得， &lt;equation&gt;f(U)\subseteq V&lt;/equation&gt; ，则我们就说， &lt;equation&gt;f&lt;/equation&gt; 在 &lt;equation&gt;x&lt;/equation&gt; 处&lt;b&gt;连续&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;如果映射 &lt;equation&gt;f:X\rightarrow Y&lt;/equation&gt; 在任一点 &lt;equation&gt;x\in X&lt;/equation&gt; 都连续，则说 &lt;equation&gt;f&lt;/equation&gt; 是&lt;b&gt;连续映射&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;同胚映射&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;f:X\rightarrow Y&lt;/equation&gt; 是双射，并且 &lt;equation&gt;f&lt;/equation&gt; 及其逆 &lt;equation&gt;f^{-1}:Y\rightarrow X&lt;/equation&gt; 都是连续的，&lt;br&gt;则称 &lt;equation&gt;f&lt;/equation&gt; 是一个&lt;b&gt;同胚映射&lt;/b&gt;，简称同胚。&lt;/p&gt;&lt;p&gt;当存在 &lt;equation&gt;X&lt;/equation&gt; 到 &lt;equation&gt;Y&lt;/equation&gt; 的同胚映射时，就称 &lt;equation&gt;X&lt;/equation&gt; 与 &lt;equation&gt;Y&lt;/equation&gt; 同胚，记作 &lt;equation&gt;X \cong Y&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;值得注意的是，同胚映射中条件 &lt;equation&gt;f^{-1}&lt;/equation&gt; 连续不可忽视，&lt;br&gt;它不能从双射和 &lt;equation&gt;f&lt;/equation&gt; 的连续性推出来。&lt;/p&gt;&lt;p&gt;&lt;b&gt;小结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;以上我们介绍了拓扑空间，以及两个拓扑空间之间的连续映射，&lt;br&gt;这和群以及两个群之间的群同态是很相似的。&lt;/p&gt;&lt;p&gt;它们表现出了一种结构上的相似性，&lt;br&gt;范畴论正是看到这种相似性，于是跳出具体的运算系统，&lt;br&gt;例如，它可以考虑群结构与拓扑结构之间的关系。&lt;/p&gt;&lt;p&gt;接下来我们来介绍CPO（完全偏序）。&lt;br&gt;它在范畴论中，对于摆脱集合论的观念束缚，帮助是很大的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4. 完全偏序&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-532615f76c50c7808ee4c139213ee560_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;457&quot; data-rawheight=&quot;347&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-532615f76c50c7808ee4c139213ee560&quot; data-watermark-src=&quot;v2-22529599b32d63a83febc0f08d8ad746&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34604220&quot;&gt;递归函数&lt;/a&gt;》系列文章中，我们已经介绍过CPO（&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E5%AE%8C%E5%85%A8%E5%81%8F%E5%BA%8F&quot;&gt;完全偏序&lt;/a&gt;）的概念了。&lt;br&gt;为了方便与本文中其他概念进行对比，我们再简单的梳理一下。&lt;/p&gt;&lt;p&gt;&lt;b&gt;二元关系&lt;/b&gt;&lt;/p&gt;&lt;p&gt;集合 &lt;equation&gt;S&lt;/equation&gt; 和 &lt;equation&gt;T&lt;/equation&gt; 上的&lt;b&gt;二元关系&lt;/b&gt; &lt;equation&gt;R&lt;/equation&gt; ，指的是它们笛卡尔积 &lt;equation&gt;S\times T&lt;/equation&gt; 的子集， &lt;equation&gt;R\subseteq S\times T&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;自反性，对称性，反对称性，传递性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一个二元关系 &lt;equation&gt;R\subseteq A\times A&lt;/equation&gt; 是&lt;b&gt;自反的&lt;/b&gt;，如果 &lt;equation&gt;R(a,a)&lt;/equation&gt; 对于所有的 &lt;equation&gt;a\in A&lt;/equation&gt; 成立；&lt;br&gt;是&lt;b&gt;对称的&lt;/b&gt;，如果 &lt;equation&gt;R(a,b)&lt;/equation&gt; 就有 &lt;equation&gt;R(b,a)&lt;/equation&gt; ，对于所有的 &lt;equation&gt;a,b\in A&lt;/equation&gt; 都成立；&lt;br&gt;是&lt;b&gt;反对称的&lt;/b&gt;，如果 &lt;equation&gt;R(a,b)&lt;/equation&gt; 且 &lt;equation&gt;R(b,a)&lt;/equation&gt; ，则 &lt;equation&gt;a,b&lt;/equation&gt; 是同一个元素，对于所有 &lt;equation&gt;a,b\in A&lt;/equation&gt; 都成立；&lt;br&gt;是&lt;b&gt;传递的&lt;/b&gt;，如果 &lt;equation&gt;R(a,b)&lt;/equation&gt; 和 &lt;equation&gt;R(b,c)&lt;/equation&gt; 能推出 &lt;equation&gt;R(a,c)&lt;/equation&gt; ，对于所有的 &lt;equation&gt;a,b,c\in A&lt;/equation&gt; 都成立。&lt;/p&gt;&lt;p&gt;&lt;b&gt;偏序关系&lt;/b&gt;&lt;/p&gt;&lt;p&gt;等价关系是同时具有自反性，对称性和传递性的关系。&lt;br&gt;&lt;b&gt;偏序关系&lt;/b&gt;是具有自反性，反对称性和传递性的关系。&lt;/p&gt;&lt;p&gt;等价关系的一个例子就是相等性，相等性关系 &lt;equation&gt;R(a,b)&lt;/equation&gt; 当且仅当 &lt;equation&gt;a,b&lt;/equation&gt; 是同一个元素。&lt;br&gt;偏序关系，例如通常的序关系 &lt;equation&gt;R\subseteq N\times N&lt;/equation&gt; ， &lt;equation&gt;R(a,b)&lt;/equation&gt; 当且仅当 &lt;equation&gt;a\leqslant b&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;最小元与上确界&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d13edf6ede5bb0d53616bec489bed30f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;450&quot; data-rawheight=&quot;362&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-d13edf6ede5bb0d53616bec489bed30f&quot; data-watermark-src=&quot;v2-64344ef688ab03db3908fa429ea51c15&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;对于偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; ，以及它的一个子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; ，&lt;br&gt;如果存在 &lt;equation&gt;y\in S&lt;/equation&gt; ，且对于任意的 &lt;equation&gt;x\in S&lt;/equation&gt; ，有 &lt;equation&gt;y\leqslant x&lt;/equation&gt; ，则称 &lt;equation&gt;y&lt;/equation&gt; 为 &lt;equation&gt;S&lt;/equation&gt; 的&lt;b&gt;最小元&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;对于偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; ，以及它的一个子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; ，&lt;br&gt;如果存在 &lt;equation&gt;y\in D&lt;/equation&gt; ，（注意， &lt;equation&gt;y&lt;/equation&gt; 不一定在子集 &lt;equation&gt;S&lt;/equation&gt; 中）&lt;br&gt;使得对于任意的 &lt;equation&gt;x\in S&lt;/equation&gt; ， &lt;equation&gt;x\leqslant y&lt;/equation&gt; ，则称 &lt;equation&gt;y&lt;/equation&gt; 为 &lt;equation&gt;S&lt;/equation&gt; 的&lt;b&gt;上界&lt;/b&gt;，&lt;br&gt;如果 &lt;equation&gt;S&lt;/equation&gt; 的所有上界存在最小元，则称它为 &lt;equation&gt;S&lt;/equation&gt; 最小上界，或&lt;b&gt;上确界&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;完全偏序集&lt;/b&gt;&lt;/p&gt;&lt;p&gt;偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 的非空子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; 叫做&lt;b&gt;有向子集&lt;/b&gt;，&lt;br&gt;当且仅当，对于 &lt;equation&gt;S&lt;/equation&gt; 中的任意元素 &lt;equation&gt;a,b\in S&lt;/equation&gt; ，存在 &lt;equation&gt;S&lt;/equation&gt; 中的一个元素 &lt;equation&gt;c&lt;/equation&gt; ，有 &lt;equation&gt;a\leqslant c&lt;/equation&gt; 且 &lt;equation&gt;b\leqslant c&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果一个偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 的每个有向子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; 都有上确界（记为 &lt;equation&gt;\bigvee S&lt;/equation&gt; ）&lt;br&gt;就称它是一个有向完全偏序集，&lt;br&gt;此外，如果它还有最小元，就称它是一个&lt;b&gt;完全偏序集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;注意，完全偏序集并不是每一个子集都有上确界，而是它的每一个有向子集都有上确界。&lt;/p&gt;&lt;p&gt;&lt;b&gt;连续函数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;假设 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 与 &lt;equation&gt;(E,\leqslant )&lt;/equation&gt; 是完全偏序集， &lt;equation&gt;f:D\rightarrow E&lt;/equation&gt; 是集合上定义的一个函数，&lt;br&gt;对于任意的 &lt;equation&gt;d,d&#39;\in D&lt;/equation&gt; ，如果 &lt;equation&gt;d\leqslant d&#39;&lt;/equation&gt; 就有 &lt;equation&gt;f(d)\leqslant f(d&#39;)&lt;/equation&gt; ，我们就说 &lt;equation&gt;f&lt;/equation&gt; 是&lt;b&gt;单调的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;f&lt;/equation&gt; 是单调的，且对于任意有向子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; ，&lt;br&gt;有 &lt;equation&gt;f(\bigvee S)=\bigvee f(S)&lt;/equation&gt; ，就称 &lt;equation&gt;f&lt;/equation&gt; 是&lt;b&gt;连续的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;小结&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们又重新回顾了完全偏序这一概念，&lt;br&gt;实际上，任意一个CPO（完全偏序），都构成了一个范畴，&lt;br&gt;而所有的群，也构成了一个范畴。&lt;/p&gt;&lt;p&gt;群范畴的对象是集合，而CPO（完全偏序）范畴的对象不一定是集合。&lt;br&gt;这对摆脱集合论来理解范畴是很关键的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了三种数学结构，群结构，拓扑结构，以及CPO（完全偏序）。&lt;br&gt;作为例子，可以为后面学习范畴论打下扎实的基础。&lt;/p&gt;&lt;p&gt;我们看到了这些数学结构之间的相似性，&lt;br&gt;从下一篇开始，我们要开始范畴论的学习之旅了。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Category_theory&quot;&gt;Category theory&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1230394/&quot;&gt;离散数学教程&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/4201293/&quot;&gt;近世代数引论&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1230382/&quot;&gt;基础拓扑学讲义&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-04-03-35196235</guid>
<pubDate>Tue, 03 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（六）：Henkin模型</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-04-02-35170799.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35170799&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0d34436db4471d65a5d0bd535cc42880_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;698&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;为了解释简单类型化演算 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 中项，我们介绍了&lt;b&gt;&lt;equation&gt;\Sigma&lt;/equation&gt; 代数&lt;/b&gt;，&lt;br&gt;用 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数中的载体 &lt;equation&gt;A^\sigma&lt;/equation&gt; 来解释基本类型 &lt;equation&gt;\sigma&lt;/equation&gt; ，&lt;br&gt;用载体上的函数集 &lt;equation&gt;A^{\sigma\to\tau}=\{f|f:A^\sigma\to A^\tau\}&lt;/equation&gt; 来解释类型为 &lt;equation&gt;\sigma\to\tau&lt;/equation&gt; 的所有函数。&lt;/p&gt;&lt;p&gt;但只是做这些对应关系，还是不够的，&lt;br&gt;我们还得证明，这样的解释是“足够多的”，&lt;br&gt;以保证每一个合法 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 项的解释，都在这个 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数中。&lt;/p&gt;&lt;p&gt;尤其是使用集合上的函数，来解释具有不动点的 &lt;equation&gt;\lambda&lt;/equation&gt; 项时，&lt;br&gt; &lt;equation&gt;A^{\sigma\to\tau}&lt;/equation&gt; 的条件应当适当放宽一些，它不一定恰好是函数集 &lt;equation&gt;\{f|f:A^\sigma\to A^\tau\}&lt;/equation&gt; 。&lt;br&gt;为此我们需要更抽象的，从语义角度定义函数是如何作用到它的参数上的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 作用结构&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-11930d7968530bedf2390866ed737269_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;454&quot; data-rawheight=&quot;388&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;从形式系统的角度来看， &lt;equation&gt;\lambda&lt;/equation&gt; 项的“应用”，是推导规则的一部分，&lt;br&gt;包括&lt;b&gt;类型推导规则&lt;/b&gt;， &lt;equation&gt;\frac{\Gamma\vdash t_1:T_1\to T_2~~~~\Gamma\vdash t_2:T_1}{\Gamma\vdash t_1~t_2:T_2}&lt;/equation&gt; ，&lt;br&gt;还包括&lt;b&gt;求值规则&lt;/b&gt;， &lt;equation&gt;(\lambda x:T.t)~v\to [x\mapsto v]t&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;项的“应用”，我们可以定义为 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数上的一个&lt;b&gt;作用结构&lt;/b&gt;（applicative structure）。&lt;/p&gt;&lt;p&gt;假设 &lt;equation&gt;\lambda x:\sigma.t&lt;/equation&gt; 是一个类型为 &lt;equation&gt;\sigma\to\tau&lt;/equation&gt; 的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，我们可以把它“应用于”类型为 &lt;equation&gt;\sigma&lt;/equation&gt; 的项 &lt;equation&gt;v:\sigma&lt;/equation&gt; ，&lt;br&gt;我们有， &lt;equation&gt;(\lambda x:\sigma.t)~v=([x\mapsto v]t):\tau&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;因此， &lt;equation&gt;\Sigma&lt;/equation&gt; 代数上的一个&lt;b&gt;作用结构&lt;/b&gt; &lt;equation&gt;App^{\sigma,\tau}&lt;/equation&gt; ，指的是这样的一个映射，&lt;br&gt; &lt;equation&gt;App^{\sigma,\tau}:A^{\sigma\to\tau}\to A^\sigma \to A^\tau&lt;/equation&gt; ，&lt;br&gt;它将集合 &lt;equation&gt;A^{\sigma\to\tau}&lt;/equation&gt; 中的一个函数，以及集合 &lt;equation&gt;A^\sigma&lt;/equation&gt; 中的一个元素，映射成集合 &lt;equation&gt;A^\tau&lt;/equation&gt; 中的一个元素。&lt;/p&gt;&lt;p&gt;一个有效的作用结构，必须具有&lt;b&gt;外延性条件&lt;/b&gt;（extensional），即， &lt;equation&gt;\forall f,g\in A^\sigma\to\tau&lt;/equation&gt; ，&lt;br&gt;如果对于任意的 &lt;equation&gt;d\in A^\sigma&lt;/equation&gt; ，都有 &lt;equation&gt;App~f~d=App~g~d&lt;/equation&gt; ，则必有 &lt;equation&gt;f=g&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;它指出集合 &lt;equation&gt;A^\sigma\to\tau&lt;/equation&gt; 的两个函数，如果在 &lt;equation&gt;App^{\sigma,\tau}&lt;/equation&gt; 下的作用效果相同，&lt;br&gt;那么它们必须是同一个函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 项的唯一解释&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d0f343b4404ef2e4264a3d3a3da18d1b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;175&quot; data-rawheight=&quot;220&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;有了满足外延性条件的作用结构之后，&lt;br&gt;我们就可以归纳的定义出&lt;b&gt;含义函数&lt;/b&gt;（meaning function） &lt;equation&gt;\mathscr{A}[\![\cdot]\!]&lt;/equation&gt; 了，&lt;/p&gt;&lt;p&gt;（1） &lt;equation&gt;\mathscr{A}[\![\varnothing\vdash c:\sigma]\!]\eta=Const(c)&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\mathscr{A}[\![x:\sigma\vdash x:\sigma]\!]\eta=\eta(x)&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;\mathscr{A}[\![\Gamma,x:\sigma\vdash M:\tau]\!]\eta=\mathscr{A}[\![\Gamma\vdash M:\tau]\!]\eta&lt;/equation&gt; &lt;br&gt;（4） &lt;equation&gt;\mathscr{A}[\![\Gamma\vdash MN:\tau]\!]\eta=App^{\sigma,\tau}~\mathscr{A}[\![\Gamma\vdash M:\sigma\to\tau]\!]\eta~\mathscr{A}[\![\Gamma\vdash N:\sigma]\!]\eta&lt;/equation&gt; &lt;br&gt;（5） &lt;equation&gt;\mathscr{A}[\![\Gamma\vdash\lambda x:\sigma.M:\sigma\to\tau]\!]\eta=&lt;/equation&gt; ，存在唯一的 &lt;equation&gt;f\in A^{\sigma\to\tau}&lt;/equation&gt; ，使得，&lt;br&gt; &lt;equation&gt;\forall d\in A^\sigma&lt;/equation&gt; ， &lt;equation&gt;App~f~d=\mathscr{A}[\![\Gamma,x:\sigma\vdash M:\tau]\!]\eta[x\mapsto d]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中， &lt;equation&gt;\eta&lt;/equation&gt; 是满足指派 &lt;equation&gt;\Gamma&lt;/equation&gt; 的环境，&lt;br&gt; &lt;equation&gt;Const&lt;/equation&gt; 是一个映射，将项常量映射到所有 &lt;equation&gt;A^\sigma&lt;/equation&gt; 并集的元素上，&lt;br&gt;使得，如果 &lt;equation&gt;c:\sigma&lt;/equation&gt; ，则 &lt;equation&gt;Const(c)\in A^\sigma&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;由于以上几个等式覆盖了所有的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，因此这样定义的含义函数是&lt;b&gt;完全的&lt;/b&gt;。&lt;br&gt;并且由于它为每一个 &lt;equation&gt;\lambda&lt;/equation&gt; 项都指定了确定的语义，因此它给出的解释方式也是唯一的。&lt;br&gt;它称为&lt;b&gt;Henkin模型&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;Henkin模型是&lt;b&gt;可靠的&lt;/b&gt;，设 &lt;equation&gt;\mathscr{A}&lt;/equation&gt; 是 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 的任意Henkin模型，&lt;br&gt; &lt;equation&gt;\Gamma\vdash M:\sigma&lt;/equation&gt; 是可证的， &lt;equation&gt;\eta&lt;/equation&gt; 是一个满足指派 &lt;equation&gt;\Gamma&lt;/equation&gt; 的环境，&lt;br&gt;则 &lt;equation&gt;\mathscr{A}[\![\Gamma\vdash M:\sigma]\!]\eta\in A^\sigma&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;即，如果一个类型断言是可证的，则它在语义上也成立。&lt;br&gt;（关于完全性的讨论，略）&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 例子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-eb39ffc5f85a13ee05646af900013807_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;283&quot; data-rawheight=&quot;178&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们可以对具有单一类型 &lt;equation&gt;nat&lt;/equation&gt; 的 &lt;equation&gt;\lambda&lt;/equation&gt; 演算，定义它的Henkin模型，&lt;br&gt;令 &lt;equation&gt;A^{nat}&lt;/equation&gt; 为自然数集， &lt;equation&gt;A^{\sigma\to\tau}&lt;/equation&gt; 为所有从 &lt;equation&gt;A^\sigma&lt;/equation&gt; 到 &lt;equation&gt;A^\tau&lt;/equation&gt; 的函数集合，&lt;br&gt;这称为&lt;b&gt;自然数上的完全集合论函数体系&lt;/b&gt;，&lt;br&gt;（full set-theoretic function hierarchy over the natural number）。&lt;/p&gt;&lt;p&gt;我们通过 &lt;equation&gt;App~f~x=f(x)&lt;/equation&gt; ，把函数 &lt;equation&gt;f\in A^{\sigma\to\tau}&lt;/equation&gt; ，作用到参数 &lt;equation&gt;x\in A^\sigma&lt;/equation&gt; 上。&lt;br&gt;下面我们得出 &lt;equation&gt;\lambda x:nat\to nat.\lambda y:nat.xy&lt;/equation&gt; 的语义。&lt;/p&gt;&lt;p&gt;由于该项是封闭项，选择什么样的环境 &lt;equation&gt;\eta&lt;/equation&gt; 都是无关紧要的。&lt;br&gt;根据上文“含义函数” &lt;equation&gt;\mathscr{A}[\![\cdot]\!]&lt;/equation&gt; 的归纳定义，我们有，&lt;br&gt; &lt;equation&gt;\mathscr{A}[\![\varnothing\vdash\lambda x:nat\to nat.\lambda y:nat.xy]\!]\eta=&lt;/equation&gt; ，唯一的 &lt;equation&gt;f\in A^{(nat\to nat)\to nat\to nat}&lt;/equation&gt; ，使得，&lt;br&gt; &lt;equation&gt;\forall h\in A^{nat\to nat}&lt;/equation&gt; ， &lt;equation&gt;App~f~h=\mathscr{A}[\![x:nat\to nat\vdash\lambda y:nat.xy]\!]\eta[x\mapsto h]&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;然后我们再来看下，&lt;br&gt; &lt;equation&gt;\mathscr{A}[\![x:nat\to nat\vdash\lambda y:nat.xy]\!]\eta[x\mapsto h]=&lt;/equation&gt; ，唯一的 &lt;equation&gt;g\in A^{nat\to nat}&lt;/equation&gt; ，使得，&lt;br&gt; &lt;equation&gt;\forall n\in A^{nat}&lt;/equation&gt; ， &lt;equation&gt;App~g~n=[\![x:nat\to nat,y:nat\vdash xy]\!]\eta[x\mapsto h][y\mapsto n]&lt;/equation&gt; ，&lt;br&gt;即，唯一的 &lt;equation&gt;g\in A^{nat\to nat}&lt;/equation&gt; ，使得， &lt;equation&gt;\forall n\in A^{nat}&lt;/equation&gt; ， &lt;equation&gt;App~g~n=App~h~n&lt;/equation&gt; 。&lt;br&gt;那么这个唯一的 &lt;equation&gt;g\in A^{nat\to nat}&lt;/equation&gt; ，实际上就是 &lt;equation&gt;h&lt;/equation&gt; 了。&lt;/p&gt;&lt;p&gt;其中， &lt;equation&gt;App~g~n=App~h~n&lt;/equation&gt; 是因为，&lt;equation&gt;App~g~n=[\![x:nat\to nat,y:nat\vdash xy]\!]\eta[x\mapsto h][y\mapsto n]&lt;/equation&gt; &lt;equation&gt;=[\![h:nat\to nat,n:nat\vdash hn]\!]\eta&lt;/equation&gt; &lt;equation&gt;=App~h~n&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;综合以上两个步骤，&lt;br&gt; &lt;equation&gt;\mathscr{A}[\![\varnothing\vdash\lambda x:nat\to nat.\lambda y:nat.xy]\!]\eta=&lt;/equation&gt; ，唯一的 &lt;equation&gt;f\in A^{(nat\to nat)\to nat\to nat}&lt;/equation&gt; ，使得，&lt;br&gt; &lt;equation&gt;\forall h\in A^{nat\to nat}&lt;/equation&gt; ， &lt;equation&gt;App~f~h=h&lt;/equation&gt; 。&lt;br&gt;因此， &lt;equation&gt;f\in A^{(nat\to nat)\to nat\to nat}&lt;/equation&gt; 的语义是一个恒等函数。&lt;/p&gt;&lt;p&gt;我们从语义上证明了以下等式，&lt;br&gt; &lt;equation&gt;\varnothing\vdash\lambda x:nat\to nat.\lambda y:nat.xy=\lambda x:nat\to nat.x&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4. 环境模型条件和组合模型条件&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b7a586ae709a511ff52009eee3e0bf71_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;520&quot; data-rawheight=&quot;424&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;以上定义的作用结构 &lt;equation&gt;App^{\sigma,\tau}&lt;/equation&gt; 称为满足&lt;b&gt;环境模型条件&lt;/b&gt;（enviroment model condition），&lt;br&gt;依赖了环境 &lt;equation&gt;\eta&lt;/equation&gt; 这一附加概念。&lt;br&gt;它使得每一个合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，都有模型中一个唯一确定的数学对象与之对应。&lt;/p&gt;&lt;p&gt;由于 &lt;equation&gt;\lambda&lt;/equation&gt; 项有 &lt;equation&gt;\lambda&lt;/equation&gt; “抽象”和 &lt;equation&gt;\lambda&lt;/equation&gt; “应用”双重复杂性，所以，建立一个合理的解释也比较麻烦。&lt;br&gt;在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34699469&quot;&gt;你好，类型&lt;/a&gt;》系列文章中，&lt;br&gt;我们介绍过组合子逻辑，我们知道可以将任意的 &lt;equation&gt;\lambda&lt;/equation&gt; 项转换成对应的 &lt;equation&gt;CL&lt;/equation&gt; 项，反之亦然。&lt;/p&gt;&lt;p&gt;因此，如果存在模型可以解释所有的 &lt;equation&gt;CL&lt;/equation&gt; 项，那么使用它也就可以解释所有 &lt;equation&gt;\lambda&lt;/equation&gt; 项了。&lt;br&gt; &lt;equation&gt;CL&lt;/equation&gt; 项比 &lt;equation&gt;\lambda&lt;/equation&gt; 项更为简洁，它不包含 &lt;equation&gt;\lambda&lt;/equation&gt; “抽象”，只包含 &lt;equation&gt;K&lt;/equation&gt; 和 &lt;equation&gt;S&lt;/equation&gt; 这两个组合子。&lt;/p&gt;&lt;p&gt;类似于 &lt;equation&gt;\lambda&lt;/equation&gt; 项的“应用”，对于 &lt;equation&gt;K&lt;/equation&gt; 和 &lt;equation&gt;S&lt;/equation&gt; 的“组合”，我们同样可以定义 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数上的一个&lt;b&gt;作用结构&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;给定 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数，对任意类型 &lt;equation&gt;\rho,\sigma,\tau&lt;/equation&gt; ，如果存在元素&lt;br&gt; &lt;equation&gt;K_{\sigma,\tau}\in A^{\sigma\to(\tau\to\sigma)}&lt;/equation&gt; ， &lt;equation&gt;S_{\rho,\sigma,\tau}\in A^{(\rho\to\sigma\to\tau)\to(\rho\to\sigma)\to\rho\tau}&lt;/equation&gt; ，&lt;br&gt;满足下列对合适类型 &lt;equation&gt;x,y,z&lt;/equation&gt; 的等式条件， &lt;equation&gt;K_{\sigma,\tau}xy=x&lt;/equation&gt; ， &lt;equation&gt;S_{\rho,\sigma,\tau}xyz=(xz)(yz)&lt;/equation&gt; ，&lt;br&gt;我们就称，该作用结构满足&lt;b&gt;组合模型条件&lt;/b&gt;（combinatory model condition）。&lt;/p&gt;&lt;p&gt;由于所有 &lt;equation&gt;CL&lt;/equation&gt; 项都可以表示成 &lt;equation&gt;K&lt;/equation&gt; 和 &lt;equation&gt;S&lt;/equation&gt; 的“组合”，&lt;br&gt;因此，满足组合模型条件的作用结构，可以唯一解释所有 &lt;equation&gt;CL&lt;/equation&gt; 项。&lt;/p&gt;&lt;p&gt;可以证明，一个满足外延性条件的作用结构，&lt;br&gt;如果它满足环境模型条件，当且仅当它也同样满足组合模型条件。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了Henkin模型作用结构所满足的条件，&lt;b&gt;环境模型条件&lt;/b&gt;和&lt;b&gt;组合模型条件&lt;/b&gt;，&lt;br&gt;它们是等价的，有了它们我们才能给出 &lt;equation&gt;\lambda&lt;/equation&gt; 项的&lt;b&gt;可靠&lt;/b&gt;解释，&lt;br&gt;即，任何合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项都有唯一解释，且在语法上可证的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，在语义上也成立。&lt;/p&gt;&lt;p&gt;下文我们开始学习范畴论，为理解笛卡尔闭范畴打好基础。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34699469&quot;&gt;你好，类型（三）：Combinatory logic&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1944729/&quot;&gt;程序设计语言理论基础&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-04-02-35170799</guid>
<pubDate>Mon, 02 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（五）：Σ代数</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-04-01-35142819.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35142819&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-034808153565717b07d4744f9dd8df32_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;698&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-034808153565717b07d4744f9dd8df32&quot; data-watermark-src=&quot;v2-13bfa86dbd2cd74be7d0a3d75c9c1078&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们介绍了哥德尔定理，它指出了&lt;b&gt;形式化方法的局限性&lt;/b&gt;，&lt;br&gt;任何包含初等算术 &lt;equation&gt;\Pi&lt;/equation&gt; 的形式理论，都是不完全的，&lt;br&gt;且自身的协调性无法在系统内部被证明。&lt;/p&gt;&lt;p&gt;为了理解这句话，上文中我们做出了严谨的定义，&lt;br&gt;仔细建立了语法和语义之间的联系。&lt;/p&gt;&lt;p&gt;实际上，语法（符号）层面的推导，属于公式的&lt;b&gt;证明&lt;/b&gt;，&lt;br&gt;而语义（模型）层面的推导，属于逻辑结论的&lt;b&gt;推理&lt;/b&gt;。&lt;br&gt;证明和推理之间的关系由系统的可靠性和完全性给出。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 简单类型化&lt;i&gt;λ&lt;/i&gt;演算&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7b5497ef5a6fe22bf3b233700e9eeee5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;260&quot; data-rawheight=&quot;262&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7b5497ef5a6fe22bf3b233700e9eeee5&quot; data-watermark-src=&quot;v2-e7acc58db936e56f4febcf7515118356&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34815896&quot;&gt;你好，类型&lt;/a&gt;》系列文章中，&lt;br&gt;我们介绍了简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算（simply typed lambda calculus） &lt;equation&gt;\lambda^\to&lt;/equation&gt; ，&lt;br&gt;它是一个形式系统，采用公理化的方式定义。&lt;/p&gt;&lt;p&gt;当时我们看来，系统中的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，只是一堆符合推导规则的符号，&lt;br&gt;我们并不知道它到底代表什么含义。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\lambda x:T.x+1&lt;/equation&gt; ，只是一个符号串，&lt;br&gt;自然数集上的后继函数&lt;code class=&quot;inline&quot;&gt;f(x)=x+1&lt;/code&gt;，能不能作为它的解释，我们是不清楚的，&lt;br&gt;只是猜想可能是。&lt;/p&gt;&lt;p&gt;不幸的是，后继函数并&lt;b&gt;不足以&lt;/b&gt;作为 &lt;equation&gt;\lambda x:T.x+1&lt;/equation&gt; 的解释，&lt;br&gt;因为，集合上的后继函数是没有不动点的，而 &lt;equation&gt;\lambda x:T.x+1&lt;/equation&gt; 有不动点 &lt;equation&gt;\perp&lt;/equation&gt; 。&lt;br&gt;我们曾经在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34604220&quot;&gt;递归函数&lt;/a&gt;》系列文章中给出过证明。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2.&lt;/b&gt; &lt;b&gt;Σ代数&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-292ed54ba3bf86dd48ebbc5ed994cce6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;258&quot; data-rawheight=&quot;196&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-292ed54ba3bf86dd48ebbc5ed994cce6&quot; data-watermark-src=&quot;v2-1e9cbd0184ce4df0998eb6104397fd8a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;一般有两种通用的方法，来给出简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 的语义，&lt;br&gt;一种是&lt;b&gt;Henkin模型&lt;/b&gt;，另一种是笛卡尔闭范畴。&lt;/p&gt;&lt;p&gt;范畴论我们可以稍后再介绍，这里先介绍Henkin模型，&lt;br&gt;不过在这之前，我们还得先了解一些 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数相关的内容。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\Sigma&lt;/equation&gt; 代数是一种数学结构，&lt;br&gt;一个 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数，包含了一个或多个集合，称为&lt;b&gt;载体&lt;/b&gt;（carrier），&lt;br&gt;以及一些&lt;b&gt;特征元素&lt;/b&gt;，和载体上的一些一阶&lt;b&gt;函数&lt;/b&gt;， &lt;equation&gt;f:A_1\times \cdots \times A_k \rightarrow A&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\Sigma&lt;/equation&gt; 代数 &lt;equation&gt;\mathscr{N}=\left \langle N,0,1,+,\cdot\right \rangle&lt;/equation&gt; ，具有载体 &lt;equation&gt;N&lt;/equation&gt; ，它是自然数集，&lt;br&gt;具有特征元素， &lt;equation&gt;0,1\in N&lt;/equation&gt; ，以及函数， &lt;equation&gt;+,*:N \times N \rightarrow N&lt;/equation&gt; 。&lt;br&gt;其中，特征元素可以看成&lt;b&gt;零元函数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;带有多个载体的例子是 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数， &lt;equation&gt;\mathscr{A}_{pcf}=\left \langle N,B,0,1,\cdots ,+,true,false,Eq?,\cdots ,\right \rangle&lt;/equation&gt; ，&lt;br&gt;其中 &lt;equation&gt;N&lt;/equation&gt; 是自然数集， &lt;equation&gt;B&lt;/equation&gt; 是布尔值集， &lt;equation&gt;0,1,\cdots&lt;/equation&gt; 是自然数， &lt;equation&gt;+&lt;/equation&gt; 是加法函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 代数数据类型的签名（signature）&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-833f6e712c91fade3f7cc868965a2a82_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;230&quot; data-rawheight=&quot;198&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-833f6e712c91fade3f7cc868965a2a82&quot; data-watermark-src=&quot;v2-e1988e84facc4da74411b540ab23a61d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 中，类型属于形式系统中的概念，&lt;br&gt;&lt;b&gt;它并不代表类型中值的集合。&lt;br&gt;&lt;/b&gt;这种认识可能有助于澄清人们对编程语言中类型的&lt;b&gt;误解&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如，我们可以为初等算术系统 &lt;equation&gt;\Pi&lt;/equation&gt; 赋予类型，&lt;br&gt;指定 &lt;equation&gt;0:nat&lt;/equation&gt; ， &lt;equation&gt;1:nat&lt;/equation&gt; ， &lt;equation&gt;+:nat\times nat\to nat&lt;/equation&gt; ， &lt;equation&gt;\cdot:nat\times nat\to nat&lt;/equation&gt; ，&lt;br&gt;分别为常元符号 &lt;equation&gt;0&lt;/equation&gt; 和 &lt;equation&gt;1&lt;/equation&gt; ，以及二元函数符号 &lt;equation&gt;+&lt;/equation&gt; 和 &lt;equation&gt;\cdot&lt;/equation&gt; 的类型。&lt;/p&gt;&lt;p&gt;常元符号也可以看成是&lt;b&gt;零元&lt;/b&gt;函数符号。&lt;/p&gt;&lt;p&gt;这里，我们称以下二元组 &lt;equation&gt;\left \langle S,F \right \rangle&lt;/equation&gt; ，为初等算术系统 &lt;equation&gt;\Pi&lt;/equation&gt; 的&lt;b&gt;类型签名&lt;/b&gt;。&lt;br&gt;其中， &lt;equation&gt;S&lt;/equation&gt; 是系统中类型的集合 &lt;equation&gt;\{nat\}&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;F&lt;/equation&gt; 是函数符号的集合 &lt;equation&gt;\{0:nat,1:nat,+:nat\times nat\to nat,\cdot:nat\times nat\to nat\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;一般的，一个&lt;b&gt;类型签名&lt;/b&gt;（signature） &lt;equation&gt;\Sigma=\left \langle S,F \right \rangle&lt;/equation&gt; ，由以下两部分构成，&lt;br&gt;（1） &lt;equation&gt;S&lt;/equation&gt; 是以类型为元素构成的集合，&lt;br&gt;（2） &lt;equation&gt;F&lt;/equation&gt; 是类型上函数符号的集合， &lt;equation&gt;F=\left \{ f:s_1\times \cdots \times s_k\rightarrow s \right \}&lt;/equation&gt; &lt;br&gt;其中， &lt;equation&gt;s_1,\cdots ,s_k,s\in S&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;并且，除了初等算术系统 &lt;equation&gt;\Pi&lt;/equation&gt; ，某些系统中可能还会包含&lt;b&gt;变量&lt;/b&gt;，&lt;br&gt;因此，为了完成类型化，我们还需为这些变量指定类型。&lt;/p&gt;&lt;p&gt;我们称有限集 &lt;equation&gt;\Gamma=\left \{ x_1:s_1,\cdots ,x_k:s_k \right \}&lt;/equation&gt; ，&lt;br&gt;为变量 &lt;equation&gt;x_1,\cdots,x_k&lt;/equation&gt; 的一个&lt;b&gt;指派&lt;/b&gt;（assignment）。&lt;br&gt;其中， &lt;equation&gt;s_1,\cdots,x_k&lt;/equation&gt; 是类型。&lt;/p&gt;&lt;p&gt;有了&lt;b&gt;签名&lt;/b&gt;和&lt;b&gt;指派&lt;/b&gt;之后，类型为 &lt;equation&gt;s&lt;/equation&gt; 的项的集合 &lt;equation&gt;Terms^s\left ( \Sigma,\Gamma \right )&lt;/equation&gt; 就可以这样定义了，&lt;br&gt;（1）如果 &lt;equation&gt;x:s\in \Gamma&lt;/equation&gt; 则 &lt;equation&gt;x\in Terms^s\left ( \Sigma,\Gamma \right )&lt;/equation&gt; &lt;br&gt;（2）如果 &lt;equation&gt;f:s_1\times \cdots \times s_k\rightarrow s&lt;/equation&gt; 且 &lt;equation&gt;M_i\in Terms^{s_i}\left ( \Sigma,\Gamma \right )&lt;/equation&gt; ， &lt;equation&gt;i=1,\cdots ,n&lt;/equation&gt; ，&lt;br&gt;则 &lt;equation&gt;fM_1\cdots M_k\in Terms^s\left ( \Sigma,\Gamma \right )&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;具有多种类型的项的集合可以记为 &lt;equation&gt;\left \{ Terms^s\left ( \Sigma,\Gamma \right ) \right \}_{s\in S}&lt;/equation&gt; ，其中 &lt;equation&gt;S&lt;/equation&gt; 为类型的集合。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4. 项的解释&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ee34ec271f8c2d19cb9e404b7ab32a13_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;310&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ee34ec271f8c2d19cb9e404b7ab32a13&quot; data-watermark-src=&quot;v2-fd34250bc10452675241a0c19d3d6ee4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;equation&gt;\Sigma&lt;/equation&gt; 代数，与类型化的项的集合之间，存在着&lt;b&gt;解释&lt;/b&gt;关系。&lt;/p&gt;&lt;p&gt;如果满足以下两个条件，&lt;br&gt;（1）对于每一个类型 &lt;equation&gt;s\in S&lt;/equation&gt; ，恰好存在 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数中的一个载体 &lt;equation&gt;A^s&lt;/equation&gt; 与之对应，&lt;br&gt;（2）每一个函数符号 &lt;equation&gt;f:s_1\times \cdots \times s_k\rightarrow s&lt;/equation&gt; ，&lt;br&gt;恰好存在集合上的一个函数 &lt;equation&gt;\mathscr{I}(f):A^{s_1}\times \cdots \times A^{s_k}\rightarrow A^s&lt;/equation&gt; 与之对应，&lt;br&gt; &lt;equation&gt;\mathscr{I}(f)&lt;/equation&gt; 也可以写成 &lt;equation&gt;f^{\mathscr{A}}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们就称 &lt;equation&gt;\mathscr{A}=\left \langle \left \{ A^s \right \}_{s\in S}, \mathscr{I} \right \rangle&lt;/equation&gt; 就是 &lt;equation&gt;\left \{ Terms^s\left ( \Sigma,\Gamma \right ) \right \}_{s\in S}&lt;/equation&gt; &lt;b&gt;所对应&lt;/b&gt;的 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数。&lt;/p&gt;&lt;p&gt;为了解释含变量的类型化的项，我们需要定义&lt;b&gt;环境&lt;/b&gt;的概念。&lt;br&gt; &lt;equation&gt;\Sigma&lt;/equation&gt; 代数 &lt;equation&gt;\mathscr{A}&lt;/equation&gt; 的环境 &lt;equation&gt;\eta&lt;/equation&gt; ，指的是把变量映射到 &lt;equation&gt;\mathscr{A}&lt;/equation&gt; 的各载体中元素的一个映射，&lt;br&gt; &lt;equation&gt;\eta :\mathscr{V} \rightarrow\cup _sA^s&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;对于含变量 &lt;equation&gt;x&lt;/equation&gt; 的项 &lt;equation&gt;M&lt;/equation&gt; ， &lt;equation&gt;\eta&lt;/equation&gt; 为它指定了载体上的一个唯一确定的值。&lt;br&gt;如果对于指派 &lt;equation&gt;\Gamma&lt;/equation&gt; 而言， &lt;equation&gt;\forall x:s\in\Gamma&lt;/equation&gt; ，都有 &lt;equation&gt;\eta(x)\in A^s&lt;/equation&gt; ，我们就说环境 &lt;equation&gt;\eta&lt;/equation&gt; &lt;b&gt;满足&lt;/b&gt;指派 &lt;equation&gt;\Gamma&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;假定 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数 &lt;equation&gt;\mathscr{A}&lt;/equation&gt; 的一个环境 &lt;equation&gt;\eta&lt;/equation&gt; 满足指派 &lt;equation&gt;\Gamma&lt;/equation&gt; ，&lt;br&gt;在这个环境中，我们就可以将任何项 &lt;equation&gt;M\in Terms\left ( \Sigma ,\Gamma \right )&lt;/equation&gt; 的含义 &lt;equation&gt;\mathscr{A}[\![M]\!]\eta&lt;/equation&gt; 定义如下，&lt;br&gt;（1） &lt;equation&gt;\mathscr{A}[\![x]\!]\eta =\eta (x)&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\mathscr{A}[\![fM_1\cdots M_k]\!]\eta =f^{\mathscr{A}}(\mathscr{A}[\![M_1]\!]\eta ,\cdots ,\mathscr{A}[\![M_k]\!]\eta )&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;&lt;b&gt;5. 例子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6ec544aeea09d77518f5f928dbe782eb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;388&quot; data-rawheight=&quot;384&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6ec544aeea09d77518f5f928dbe782eb&quot; data-watermark-src=&quot;v2-00c10ea44965a352ea337c9e8269311f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;上文我们介绍了初等算术系统 &lt;equation&gt;\Pi&lt;/equation&gt; 的类型签名 &lt;equation&gt;\left \langle S,F \right \rangle&lt;/equation&gt; ，其中， &lt;equation&gt;S=\{nat\}&lt;/equation&gt; ， &lt;br&gt;&lt;equation&gt;F=\{0:nat,1:nat,+:nat\times nat\to nat,\cdot:nat\times nat\to nat\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们可以选择 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数 &lt;equation&gt;\mathscr{N}=\left \langle N,0,1,+,\cdot\right \rangle&lt;/equation&gt; 作为它的解释，&lt;br&gt;它的载体为自然数集 &lt;equation&gt;N&lt;/equation&gt; ， &lt;equation&gt;0,1,+,\cdot&lt;/equation&gt; 分别为自然数集上的零元和一元函数。&lt;/p&gt;&lt;p&gt;如果初等算术系统 &lt;equation&gt;\Pi&lt;/equation&gt; 中的项包含变量，我们就可以为 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数 &lt;equation&gt;\mathscr{N}&lt;/equation&gt; 指定环境 &lt;equation&gt;\eta&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;例如，我们可以假定环境 &lt;equation&gt;\eta&lt;/equation&gt; 满足 &lt;equation&gt;\eta(x)=0&lt;/equation&gt; ，&lt;br&gt;则在这个环境中， &lt;equation&gt;x+1&lt;/equation&gt; 的语义就可以按下式确定了。&lt;br&gt; &lt;equation&gt;[\![x+1]\!]\eta=+^\mathscr{N}([\![x]\!]\eta,[\![1]\!])\eta=+^\mathscr{N}(\eta(x),1^\mathscr{N})=+^\mathscr{N}(0^\mathscr{N},1^\mathscr{N})=1&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了一种称为 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数的数学结构，它可以用来解释带有类型签名的项。&lt;/p&gt;&lt;p&gt;可是，要想让这样的 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数称为 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 项的模型，还是不够的，&lt;br&gt;我们还必须保证每一个 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 项的解释，都在模型中。&lt;br&gt;为此 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数还要满足一些额外的条件。&lt;/p&gt;&lt;p&gt;下文我们再详细讨论这些条件。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34815896&quot;&gt;你好，类型（六）：Simply typed lambda calculus&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34604220&quot;&gt;递归函数（九）：最小不动点定理&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1944729/&quot;&gt;程序设计语言理论基础&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-04-01-35142819</guid>
<pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（四）：哥德尔定理</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-31-35102039.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35102039&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1325c76d98cc6465a9ff96f7a0410ff0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;775&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们介绍了一阶逻辑的语义模型，它包括&lt;b&gt;结构&lt;/b&gt;和&lt;b&gt;赋值&lt;/b&gt;两个部分，&lt;br&gt;其中，结构给出了常元符号、函数符号以及谓词符号在论域中的解释，&lt;br&gt;而赋值给出了变元符号在论域中的解释。&lt;/p&gt;&lt;p&gt;我们通过这种方式，建立了形式符号和论域中数学对象之间的关联，&lt;br&gt;本文将继续研究符号和其语义之间的关系。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 语义方面（模型）&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a382081c6002b6f34fb9eee923a31cec_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;346&quot; data-rawheight=&quot;196&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;1.1 公式的可满足性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们知道在公理化系统中，逻辑公式 &lt;equation&gt;A&lt;/equation&gt; 可以用来表示推导规则的前提和结论，&lt;br&gt;它在给定模型 &lt;equation&gt;(M,\sigma)&lt;/equation&gt; 中的语义 &lt;equation&gt;A_{M[\sigma]}&lt;/equation&gt; ]是一个真假值。&lt;/p&gt;&lt;p&gt;这是合情合理的，因为推导本来就应该是从真命题推导出另一个真命题的过程。&lt;/p&gt;&lt;p&gt;由于模型是可以&lt;b&gt;人为选择&lt;/b&gt;的，所以，给定一个逻辑公式 &lt;equation&gt;A&lt;/equation&gt; ，&lt;br&gt;其语义的真假性，有可能会受到&lt;b&gt;所选模型&lt;/b&gt;的影响。&lt;/p&gt;&lt;p&gt;如果存在模型 &lt;equation&gt;(M, \sigma)&lt;/equation&gt; ，使得 &lt;equation&gt;A_{M[\sigma ]}=T&lt;/equation&gt; 成立，&lt;br&gt;我们就称公式 &lt;equation&gt;A&lt;/equation&gt; 关于模型 &lt;equation&gt;(M, \sigma )&lt;/equation&gt; 是&lt;b&gt;可满足的&lt;/b&gt;，记为 &lt;equation&gt;M\models _\sigma A&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;此外，如果有公式集 &lt;equation&gt;\Gamma&lt;/equation&gt; ，其中的每一个公式关于模型 &lt;equation&gt;(M, \sigma)&lt;/equation&gt; 都是可满足的，&lt;br&gt;我们就称，公式集 &lt;equation&gt;\Gamma&lt;/equation&gt; 关于模型 &lt;equation&gt;(M, \sigma )&lt;/equation&gt; 是可满足的，记为 &lt;equation&gt;M\models _\sigma\Gamma&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.2 重言式&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果公式 &lt;equation&gt;A&lt;/equation&gt; ，对于任意模型 &lt;equation&gt;(M, \sigma)&lt;/equation&gt; 都是可满足的，&lt;br&gt;即，对任意结构 &lt;equation&gt;M&lt;/equation&gt; 和赋值 &lt;equation&gt;\sigma&lt;/equation&gt; ， &lt;equation&gt;M\models _\sigma A&lt;/equation&gt; 都成立，&lt;br&gt;我们就称 &lt;equation&gt;A&lt;/equation&gt; 是&lt;b&gt;永真公式&lt;/b&gt;，也称为&lt;b&gt;重言式&lt;/b&gt;，记为 &lt;equation&gt;\models A&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;重言式，是与模型无关的公式，它们在任何模型下都为真。&lt;/p&gt;&lt;p&gt;例： &lt;equation&gt;A\vee \neg A&lt;/equation&gt; ， &lt;equation&gt;\forall x(x\doteq x)&lt;/equation&gt; 都是重言式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.3 逻辑推理&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e5caf356aa8a95b0df17491cb2af1e93_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;282&quot; data-rawheight=&quot;398&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;有了可满足性，我们就可以进行&lt;b&gt;逻辑推理&lt;/b&gt;了。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;A&lt;/equation&gt; 为公式， &lt;equation&gt;\Gamma&lt;/equation&gt; 为公式集， &lt;equation&gt;M&lt;/equation&gt; 为任意结构， &lt;equation&gt;\sigma&lt;/equation&gt; 为任意赋值，并且，&lt;br&gt;如果 &lt;equation&gt;M\models _\sigma \Gamma&lt;/equation&gt; 成立，就有 &lt;equation&gt;M\models _\sigma A&lt;/equation&gt; 成立，&lt;br&gt;我们就称， &lt;equation&gt;A&lt;/equation&gt; 是公式集 &lt;equation&gt;\Gamma&lt;/equation&gt; 的&lt;b&gt;逻辑结论&lt;/b&gt;或&lt;b&gt;语义结论&lt;/b&gt;，记为 &lt;equation&gt;\Gamma \models A&lt;/equation&gt; ，也称结论 &lt;equation&gt;\Gamma \models A&lt;/equation&gt; &lt;b&gt;有效&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;因此， &lt;equation&gt;\Gamma \models A&lt;/equation&gt; 表示了一种语义关系，&lt;br&gt;它指出，对任意 &lt;equation&gt;M&lt;/equation&gt; 和任意 &lt;equation&gt;\sigma&lt;/equation&gt; ，如果 &lt;equation&gt;\Gamma&lt;/equation&gt; 为真，那么 &lt;equation&gt;A&lt;/equation&gt; 也为真。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 语法方面（符号）&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1a5dafd7fc3bfc32fff64e45481116e9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;306&quot; data-rawheight=&quot;165&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;2.1 序贯&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34727603&quot;&gt;你好，类型&lt;/a&gt;》系列文章中，我们介绍过&lt;b&gt;序贯&lt;/b&gt;的概念。&lt;/p&gt;&lt;p&gt;我们知道，在公理系统中，序贯可以用来表示前提和结论之间的符号联系。&lt;br&gt;序贯 &lt;equation&gt;\Gamma\vdash\Delta&lt;/equation&gt; ，表示从公式集 &lt;equation&gt;\Gamma&lt;/equation&gt; 出发，根据推导规则，&lt;br&gt;可以证明出 &lt;equation&gt;\Delta&lt;/equation&gt; 中至少有一条公式成立。&lt;/p&gt;&lt;p&gt;习惯上，序贯 &lt;equation&gt;\Gamma\vdash\Delta&lt;/equation&gt; 成立，也称 &lt;equation&gt;\Gamma\vdash\Delta&lt;/equation&gt; &lt;b&gt;可证&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;值得注意的是，序贯谈论的都是语法层面（符号层面）上的，&lt;br&gt;和这些符号的所选择的具体语义无关。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 协调性（一致性）&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-eddfaac10cd721d5c5e4c902900c4171_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;330&quot; data-rawheight=&quot;236&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;设 &lt;equation&gt;\Gamma&lt;/equation&gt; 为公式集，如果不存在一个公式 &lt;equation&gt;A&lt;/equation&gt; 使得序贯 &lt;equation&gt;\Gamma \vdash A&lt;/equation&gt; 与 &lt;equation&gt;\Gamma \vdash \neg A&lt;/equation&gt; 均可证，&lt;br&gt;我们就称，公式集 &lt;equation&gt;\Gamma&lt;/equation&gt; 是&lt;b&gt;协调的&lt;/b&gt;，也称&lt;b&gt;一致的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;\Gamma&lt;/equation&gt; 是一阶语言 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 的公式集，该集合可以是有限集或可数集，&lt;br&gt;如果 &lt;equation&gt;\Gamma&lt;/equation&gt; 协调，则称 &lt;equation&gt;\Gamma&lt;/equation&gt; 是一阶语言 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 的&lt;b&gt;形式理论&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 语法（符号）和语义（模型）&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-55958c86528a097ecc14f7810d72de52_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;392&quot; data-rawheight=&quot;244&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;3.1 可靠性和完全性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;把公理系统的语法和语义联合起来，我们还可以定义出以下这些系统性质。&lt;/p&gt;&lt;p&gt;如果序贯 &lt;equation&gt;\Gamma \vdash \Lambda&lt;/equation&gt; 可证，那么 &lt;equation&gt;\Gamma \models \Lambda&lt;/equation&gt; 成立，就说系统是&lt;b&gt;可靠的&lt;/b&gt;。&lt;br&gt;如果 &lt;equation&gt;\Gamma \models A&lt;/equation&gt; 成立，那么 &lt;equation&gt;\Gamma \vdash A&lt;/equation&gt; 可证，就说系统是&lt;b&gt;完全的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.2 不完全性与协调性不可证&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e113b4bfc7f15a822ab451fd64b81b20_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;224&quot; data-rawheight=&quot;181&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;是不是任意一个公理系统都是可靠且完全的呢？&lt;br&gt;可惜并不是如此。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BA%93%E5%B0%94%E7%89%B9%C2%B7%E5%93%A5%E5%BE%B7%E5%B0%94&quot;&gt;哥德尔&lt;/a&gt;在1931年给出了两个定理，终结了人们的幻想，&lt;br&gt;分别称为哥德尔不完全性定理，和哥德尔协调性定理。他指出，&lt;/p&gt;&lt;p&gt;&lt;b&gt;不完全性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;\Gamma&lt;/equation&gt; 是一个有穷，并包含初等算术 &lt;equation&gt;\Pi&lt;/equation&gt; 的形式理论，&lt;br&gt;那么 &lt;equation&gt;\Gamma&lt;/equation&gt; 是一个不完全的形式理论。&lt;/p&gt;&lt;p&gt;&lt;b&gt;协调性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果形式理论 &lt;equation&gt;\Gamma&lt;/equation&gt; 包含初等算术 &lt;equation&gt;\Pi&lt;/equation&gt; ，&lt;br&gt;那么 &lt;equation&gt;\Pi&lt;/equation&gt; 的协调性不能在 &lt;equation&gt;\Gamma&lt;/equation&gt; 中被证明。&lt;/p&gt;&lt;blockquote&gt;所以，在软件开发过程中，检查一个软件系统是否符合设计要求，所使用的方法就是对它进行测试，在这个软件系统之外进行证明。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;文本介绍语法（符号证明）和语义（模型）之间的关系，&lt;br&gt;让我们认识到了形式化方法的局限性。&lt;/p&gt;&lt;p&gt;一个足够有用的系统，总会出现不可证的事实，&lt;br&gt;并且，在该系统内部，我们甚至都无法证明它是否含有矛盾。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34727603&quot;&gt;你好，类型（四）：Propositional log&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/2364517/&quot;&gt;数理逻辑&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86&quot;&gt;哥德尔不完备定理&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-31-35102039</guid>
<pubDate>Sat, 31 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（三）：语义模型</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-30-35059714.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35059714&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1c5b9d563616667cf124fead090f7f71_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;698&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1c5b9d563616667cf124fead090f7f71&quot; data-watermark-src=&quot;v2-d0aa9daa0d20e9a8443f8c396b4f160c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;1. 回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们从代数学角度重新认识了自然数，认识了自然数是如何被&lt;b&gt;编码&lt;/b&gt;为符号串的，&lt;br&gt;以及自然数在数学上是如何表示的。&lt;/p&gt;&lt;p&gt;我们的整体思路是，首先用&lt;b&gt;公理化&lt;/b&gt;的方式建立一个&lt;b&gt;形式系统&lt;/b&gt;，&lt;br&gt;然后为这个形式系统&lt;b&gt;选择&lt;/b&gt;一种数学解释作为它的语义，&lt;br&gt;这样就建立了符号和数学对象之间的对应关系。&lt;/p&gt;&lt;p&gt;一般的，这些数学对象需要具有不同的运算性质，有不同的结构，&lt;br&gt;因此构成了不同的&lt;b&gt;代数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34779520&quot;&gt;你好，类型&lt;/a&gt;》系列文章中，我们介绍了命题逻辑和一阶谓词逻辑，&lt;br&gt;当时，我们只是从形式系统（符号演算）的角度来介绍它们。&lt;/p&gt;&lt;p&gt;例如，我们只要知道公理和推导规则，就可以做出&lt;b&gt;形式证明&lt;/b&gt;，&lt;br&gt; &lt;equation&gt;\forall x(\alpha\leftrightarrow\beta)\vdash\forall x\alpha\leftrightarrow\forall x\beta&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;但是，这些符号到底代表什么含义呢？&lt;br&gt;我们当时故意没有提及。&lt;/p&gt;&lt;p&gt;本文从模型论角度来做出一些解释。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 一阶语言&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-08aff67764de6984e391923515eb467d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;476&quot; data-rawheight=&quot;266&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-08aff67764de6984e391923515eb467d&quot; data-watermark-src=&quot;v2-161f1757a81329d900360d4a6315be4b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;首先让我们回顾以下一阶谓词逻辑有哪些&lt;b&gt;符号&lt;/b&gt;构成，&lt;/p&gt;&lt;p&gt;（1）变元符号集合 &lt;equation&gt;V&lt;/equation&gt; ，&lt;br&gt;它由可数个（包括0个）变元符号组成，用 &lt;equation&gt;x_1,x_1,\cdots,x_n,\cdots&lt;/equation&gt; 表示。&lt;br&gt;（2）逻辑连接词符号集合 &lt;equation&gt;C&lt;/equation&gt; ，&lt;br&gt;它由逻辑连接词符号 &lt;equation&gt;\neg,\wedge,\vee,\rightarrow,\leftrightarrow&lt;/equation&gt; 组成。&lt;br&gt;（3）量词符号集合 &lt;equation&gt;Q&lt;/equation&gt; ，包括 &lt;equation&gt;\forall,\exists&lt;/equation&gt; 。&lt;br&gt;（4）等词符号集合 &lt;equation&gt;E&lt;/equation&gt; ，只包括一个符号 &lt;equation&gt;\doteq&lt;/equation&gt; 。&lt;br&gt;（5）括号集合，包括 &lt;equation&gt;),(&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;以上这些符号称为&lt;b&gt;逻辑符号&lt;/b&gt;，每个&lt;b&gt;一阶逻辑&lt;/b&gt;都有这些符号。&lt;br&gt;而不同的一阶逻辑，还有属于自己的&lt;b&gt;非逻辑符号&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;（1）常元符号集合 &lt;equation&gt;\mathscr{L}_c&lt;/equation&gt; ，&lt;br&gt;它由可数个（包括0个）常元符号组成，用 &lt;equation&gt;c_1,c_2,\cdots&lt;/equation&gt; 表示。&lt;br&gt;（2）函数符号集合 &lt;equation&gt;\mathscr{L}_f&lt;/equation&gt; ，&lt;br&gt;它由可数个（包括0个）函数符号组成，用 &lt;equation&gt;f_1,f_2,\cdots&lt;/equation&gt; 表示。&lt;br&gt;（3）谓词符号集合 &lt;equation&gt;\mathscr{L}_P&lt;/equation&gt; ，&lt;br&gt;它由可数个（包括0个）谓词符号组成，用 &lt;equation&gt;P_1,P_2,\cdots&lt;/equation&gt; 表示。&lt;/p&gt;&lt;p&gt;等词符号 &lt;equation&gt;\doteq&lt;/equation&gt; 实际上可以看做是一个谓词符号。&lt;/p&gt;&lt;p&gt;因此，一阶谓词逻辑是一种一阶逻辑。&lt;br&gt;一阶逻辑中的逻辑符号和非逻辑符号，称为&lt;b&gt;一阶语言&lt;/b&gt;，记为 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 初等算术语言&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0af43dcf0db17bc56a9f23629eba4fff_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;220&quot; data-rawheight=&quot;176&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0af43dcf0db17bc56a9f23629eba4fff&quot; data-watermark-src=&quot;v2-cc77c1a0365a39d0c0e7df3ec874222f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;初等算术语言&lt;/b&gt;是一个一阶语言，记为 &lt;equation&gt;\Pi&lt;/equation&gt; 。&lt;br&gt;它的常元符号集合为 &lt;equation&gt;\{0\}&lt;/equation&gt; ，函数符号集合为 &lt;equation&gt;\{S,+,\cdot\}&lt;/equation&gt; ，谓词符号集合为 &lt;equation&gt;\{&amp;lt;\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;其中， &lt;equation&gt;S&lt;/equation&gt; 可以表示算术中的后继函数，&lt;br&gt;而二元函数符号 &lt;equation&gt;+&lt;/equation&gt; 和 &lt;equation&gt;\cdot&lt;/equation&gt; 可以分别表示算术中的加法和乘法，&lt;br&gt;谓词符号 &lt;equation&gt;&amp;lt;&lt;/equation&gt; 可以描述自然数之间的小于关系。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4. 语法项和逻辑公式&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-78f72f27ec4a044bb994732c1d993c8f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;598&quot; data-rawheight=&quot;113&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-78f72f27ec4a044bb994732c1d993c8f&quot; data-watermark-src=&quot;v2-79aeae0ead5da041df93d2292081ff37&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;从形式语言的角度来看，除了知道语言包含哪些符号之外，还要指定&lt;b&gt;语法&lt;/b&gt;，&lt;br&gt;习惯上，我们经常使用&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F&quot;&gt;BNF&lt;/a&gt;来指定，&lt;br&gt; &lt;equation&gt;t::=c|x|f~t_1\cdots t_n&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;即一个合法的&lt;b&gt;项&lt;/b&gt;，可以归纳定义为，&lt;br&gt;（1）每一个常元都是合法的项，&lt;br&gt;（2）每一个变元都是合法的项，&lt;br&gt;（3）如果 &lt;equation&gt;t_1,t_2,\cdots,t_n&lt;/equation&gt; 都是合法的项，而 &lt;equation&gt;f&lt;/equation&gt; 是一个 &lt;equation&gt;n&lt;/equation&gt; 元函数符号，&lt;br&gt;那么 &lt;equation&gt;f~t_1\cdots t_n&lt;/equation&gt; 也是一个合法的项。&lt;/p&gt;&lt;p&gt;初等算术语言 &lt;equation&gt;\Pi&lt;/equation&gt; 中的合法项，以下符号串都是合法的，&lt;br&gt; &lt;equation&gt;S0&lt;/equation&gt; ， &lt;equation&gt;Sx_1&lt;/equation&gt; ， &lt;equation&gt;+S0SSx&lt;/equation&gt; ， &lt;equation&gt;\cdot x_1+Sx_1x_2&lt;/equation&gt; ，&lt;br&gt;而 &lt;equation&gt;SS&amp;lt;&lt;/equation&gt; 是不合法的。&lt;/p&gt;&lt;p&gt;我们知道逻辑证明，并不是建立在形式语法之上的，&lt;br&gt;而是建立在&lt;b&gt;公理系统&lt;/b&gt;上面，而每一个&lt;b&gt;推导规则&lt;/b&gt;都表明了前提和结论之间的关系，&lt;br&gt;这些前提和结论，称为&lt;b&gt;逻辑公式&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;一阶语言 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 中的逻辑公式，用大写字母 &lt;equation&gt;A,B,\cdots&lt;/equation&gt; 表示，定义为，&lt;br&gt; &lt;equation&gt;A ::= t_1\doteq t_2 | Rt_1\cdot \cdot \cdot t_n | \neg A | A\wedge B | A\vee B | A\rightarrow B | A\leftrightarrow B | \forall xA | \exists xA&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;即，&lt;b&gt;逻辑公式&lt;/b&gt;可以归纳的定义为，&lt;br&gt;（1）如果 &lt;equation&gt;t_1&lt;/equation&gt; 和 &lt;equation&gt;t_2&lt;/equation&gt; 是合法的项，则 &lt;equation&gt;t_1\doteq t_2&lt;/equation&gt; 是公式，&lt;br&gt;（2）如果 &lt;equation&gt;t_1, ..., t_n&lt;/equation&gt; 是合法的项，而 &lt;equation&gt;R&lt;/equation&gt; 是一个 &lt;equation&gt;n&lt;/equation&gt; 元谓词，则 &lt;equation&gt;Rt_1\cdot \cdot \cdot t_n&lt;/equation&gt; 是公式，&lt;br&gt;（3）如果 &lt;equation&gt;A&lt;/equation&gt; 是公式，则 &lt;equation&gt;\neg A&lt;/equation&gt; 是公式，&lt;br&gt;（4）若 &lt;equation&gt;A, B&lt;/equation&gt; 是公式，则 &lt;equation&gt;A\wedge B, A\vee B, A\rightarrow B, A\leftrightarrow B&lt;/equation&gt; 都是公式，&lt;br&gt;（5）若 &lt;equation&gt;A&lt;/equation&gt; 是公式并且 &lt;equation&gt;x&lt;/equation&gt; 是一个变元，那么 &lt;equation&gt;\forall xA&lt;/equation&gt; 和 &lt;equation&gt;\exists xA&lt;/equation&gt; 也是公式， &lt;equation&gt;x&lt;/equation&gt; 称为&lt;b&gt;约束变元&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例，以下符号串可以看做一个初等算术公式，&lt;br&gt; &lt;equation&gt;\forall x\neg (Sx\doteq 0), \forall x\forall y(&amp;lt; xy\rightarrow(\exists (y\doteq +xz)))&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;&lt;b&gt;5. 语义模型&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e30bba524907e7c3b6786d9bb6f3f090_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;430&quot; data-rawheight=&quot;432&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e30bba524907e7c3b6786d9bb6f3f090&quot; data-watermark-src=&quot;v2-b24b8323b235c53b820fbfa6a4ae942c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;有了一阶语言之后，我们就可以为符号选择语义了，&lt;br&gt;通常的，语言的语义有两部分组成，&lt;br&gt;其一称为&lt;b&gt;结构&lt;/b&gt;，用来解释常元符号，函数符号和谓词符号，&lt;br&gt;其二称为&lt;b&gt;赋值&lt;/b&gt;，用来解释变元符号。&lt;/p&gt;&lt;p&gt;&lt;b&gt;5.1 语言结构&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一阶语言 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 的&lt;b&gt;结构&lt;/b&gt; &lt;equation&gt;M&lt;/equation&gt; 是一个偶对，记为 &lt;equation&gt;M=(\mathbb{M}, I)&lt;/equation&gt; ，其中，&lt;br&gt;（1） &lt;equation&gt;\mathbb{M}&lt;/equation&gt; 是一个非空集合，称为&lt;b&gt;论域&lt;/b&gt;，&lt;br&gt;（2） &lt;equation&gt;I&lt;/equation&gt; 是从 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 到 &lt;equation&gt;\mathbb{M}&lt;/equation&gt; 的映射，称为&lt;b&gt;解释&lt;/b&gt;，记为 &lt;equation&gt;I:\mathscr{L} \rightarrow \mathbb{M}&lt;/equation&gt; ，它满足下面三个条件&lt;br&gt;对 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 中的每一个常元符号 &lt;equation&gt;c&lt;/equation&gt; ， &lt;equation&gt;I(c)&lt;/equation&gt; 是 &lt;equation&gt;\mathbb{M}&lt;/equation&gt; 中的元素&lt;br&gt;对 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 中的每一个 &lt;equation&gt;n&lt;/equation&gt; 元函数符号 &lt;equation&gt;f&lt;/equation&gt; ， &lt;equation&gt;I(f)&lt;/equation&gt; 是 &lt;equation&gt;\mathbb{M}&lt;/equation&gt; 上的 &lt;equation&gt;n&lt;/equation&gt; 元函数&lt;br&gt;对 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 中的每一个 &lt;equation&gt;n&lt;/equation&gt; 元谓词符号 &lt;equation&gt;P&lt;/equation&gt; ， &lt;equation&gt;I(P)&lt;/equation&gt; 是 &lt;equation&gt;\mathbb{M}&lt;/equation&gt; 上的一个 &lt;equation&gt;n&lt;/equation&gt; 元关系&lt;/p&gt;&lt;p&gt;例，我们可以指定初等算术语言 &lt;equation&gt;\Pi&lt;/equation&gt; 的结构为，偶对 &lt;equation&gt;N=(\mathbb{N}, I)&lt;/equation&gt; ，&lt;br&gt;其中论域 &lt;equation&gt;\mathbb{N}&lt;/equation&gt; 为自然数集，&lt;br&gt; &lt;equation&gt;I(S)&lt;/equation&gt; 为自然数集上的加 &lt;equation&gt;1&lt;/equation&gt; 函数， &lt;equation&gt;I(+)&lt;/equation&gt; 为自然数加法运算， &lt;equation&gt;I(\cdot)&lt;/equation&gt; 为自然数乘法运算。&lt;br&gt; &lt;equation&gt;I(&amp;lt;)&lt;/equation&gt; 为自然数集上的小于关系。&lt;/p&gt;&lt;p&gt;&lt;b&gt;5.2 变元赋值&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;赋值 &lt;/b&gt;&lt;equation&gt;\sigma&lt;/equation&gt; 是一个映射， &lt;equation&gt;\sigma:V\to\mathbb{M}&lt;/equation&gt; ，&lt;br&gt;它将 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 中的每一个变元，赋以论域 &lt;equation&gt;\mathbb{M}&lt;/equation&gt; 中的一个元素 &lt;equation&gt;a&lt;/equation&gt; ，&lt;br&gt;记为 &lt;equation&gt;\sigma(x)=a&lt;/equation&gt; ，其中 &lt;equation&gt;x\in V,a\in\mathbb{M}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;有了赋值运算之后，公式中的变元就固定下来了，&lt;br&gt;我们就可以谈论在某一指定赋值运算下公式的语义了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;5.3 模型和语义&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-66a18139c912860b6d2797c50f1d2742_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;334&quot; data-rawheight=&quot;330&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-66a18139c912860b6d2797c50f1d2742&quot; data-watermark-src=&quot;v2-6ace729d486c2e48aeca6c549627bf40&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;给定一阶语言 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; ，并指定结构 &lt;equation&gt;M&lt;/equation&gt; 和赋值 &lt;equation&gt;\sigma&lt;/equation&gt; ，&lt;br&gt;我们称 &lt;equation&gt;(M,\sigma)&lt;/equation&gt; 是，我们为语言 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 选择的一个&lt;b&gt;模型&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;项的语义&lt;/b&gt;&lt;/p&gt;&lt;p&gt;选择了模型 &lt;equation&gt;(M,\sigma)&lt;/equation&gt; 之后， &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 中的合法项 &lt;equation&gt;t&lt;/equation&gt; 的&lt;b&gt;语义&lt;/b&gt;，&lt;br&gt;就可以归纳的定义为论域 &lt;equation&gt;\mathbb{M}&lt;/equation&gt; 中的元素了，记为 &lt;equation&gt;t_{M[\sigma]}&lt;/equation&gt; 。&lt;br&gt;（1） &lt;equation&gt;x_{M[\sigma ]}=\sigma (x)&lt;/equation&gt; ， &lt;equation&gt;x&lt;/equation&gt; 为变元符号&lt;br&gt;（2） &lt;equation&gt;c_{M[\sigma ]}=c_M&lt;/equation&gt; ， &lt;equation&gt;c&lt;/equation&gt; 为常元符号&lt;br&gt;（3） &lt;equation&gt;(ft_1\cdot \cdot \cdot t_n)_{M[\sigma ]}=f_M((t_1)_{M[\sigma ]},\cdot \cdot \cdot (t_n)_{M[\sigma ]})&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;例，初等算术 &lt;equation&gt;\Pi&lt;/equation&gt; 中项的语义，&lt;br&gt; &lt;equation&gt;(+x_1Sx_7)_{N[\sigma ]}=(x_1)_{N[\sigma ]}+(Sx_7)_{N[\sigma ]}=1+((x_7)_{N[\sigma ]}+1)=1+(7+1)=9&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;逻辑公式的语义&lt;/b&gt;&lt;/p&gt;&lt;p&gt;公式 &lt;equation&gt;A&lt;/equation&gt; 在模型 &lt;equation&gt;(M, \sigma )&lt;/equation&gt; 下的&lt;b&gt;语义&lt;/b&gt;是一个真假值，用 &lt;equation&gt;A_{M[\sigma ]}&lt;/equation&gt; 表示，归纳定义如下，&lt;br&gt;（1） &lt;equation&gt;(Pt_1\cdot \cdot \cdot t_n)_{M[\sigma ]}=P_M((t_1)_{M[\sigma ]},\cdot \cdot \cdot ,(t_n)_{M[\sigma ]})&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;(t_1\doteq t_2)_{M[\sigma ]}=\begin{cases}T,&amp;amp;\text{if }(t_1)_{M[\sigma ]}=(t_2)_{M[\sigma ]}\\F,&amp;amp;\text{otherwise}\end{cases}&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;(\neg A)_{M[\sigma ]}=B_\neg (A_{M[\sigma ]})&lt;/equation&gt; &lt;br&gt;（4） &lt;equation&gt;(A\vee B)_{M[\sigma ]}=B_\vee (A_{M[\sigma ]}, B_{M[\sigma ]})&lt;/equation&gt; &lt;br&gt;（5） &lt;equation&gt;(A\wedge B)_{M[\sigma ]}=B_\wedge (A_{M[\sigma ]}, B_{M[\sigma ]})&lt;/equation&gt; &lt;br&gt;（6） &lt;equation&gt;(A\rightarrow B)_{M[\sigma ]}=B_\rightarrow (A_{M[\sigma ]}, B_{M[\sigma ]})&lt;/equation&gt; &lt;br&gt;（7） &lt;equation&gt;(A\leftrightarrow B)_{M[\sigma ]}=B_\leftrightarrow (A_{M[\sigma ]}, B_{M[\sigma ]})&lt;/equation&gt; &lt;br&gt;（8） &lt;equation&gt;(\forall x_iA)_{M[\sigma ]}=\begin{cases}T,&amp;amp;\forall a\in M, A_{M[\sigma [x_i:=a]]}=T\\F,&amp;amp;\text{otherwise}\end{cases}&lt;/equation&gt; &lt;br&gt;（9） &lt;equation&gt;(\exists x_iA)_{M[\sigma ]}=\begin{cases}T,&amp;amp;\exists a\in M, A_{M[\sigma [x_i:=a]]}=T\\F,&amp;amp;\text{otherwise}\end{cases}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中，二元真值函数 &lt;equation&gt;B_\wedge, B_\vee, B_\rightarrow, B_\leftrightarrow&lt;/equation&gt; ，分别逻辑连接词符号 &lt;equation&gt;\wedge, \vee, \rightarrow, \leftrightarrow&lt;/equation&gt; 的语义。&lt;/p&gt;&lt;p&gt;至此，我们通过为一阶语言指定模型，&lt;br&gt;将语言中所有的符号串都进行了&lt;b&gt;解释&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;6. 总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文以一阶逻辑为例，从逻辑学角度给出了&lt;b&gt;语义模型&lt;/b&gt;的定义，&lt;br&gt;由此，一阶逻辑系统中的符号串，都有了一个数学对象与之对应，&lt;br&gt;它们是论域，论域集合上的函数和运算。&lt;/p&gt;&lt;p&gt;可想而已，这些数学对象是有代数性质的，下文我们将继续深入了解。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34779520&quot;&gt;你好，类型（五）：Predicate logic&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/2364517/&quot;&gt;数理逻辑&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91&quot;&gt;一阶逻辑&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-30-35059714</guid>
<pubDate>Fri, 30 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（二）：初等代数</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-29-35017879.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35017879&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a2b350a00ab43a44fcfe38f78923048b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;698&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a2b350a00ab43a44fcfe38f78923048b&quot; data-watermark-src=&quot;v2-834251828200ebeee6f352501335c306&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文中我们介绍了一个称为“pq”的系统，并且给它&lt;b&gt;选择&lt;/b&gt;了一个合理的语义解释。&lt;br&gt;我们将&lt;code class=&quot;inline&quot;&gt;---q-p--&lt;/code&gt;解释为“3等于1加2”。&lt;/p&gt;&lt;p&gt;此外，我们还知道了，解释的方式，是随着形式系统的&lt;b&gt;公理化条件&lt;/b&gt;而改变的。&lt;br&gt;更改了“pq系统”的公理或者推导规则的时候，系统中公理和定理的&lt;b&gt;含义&lt;/b&gt;都会发生改变。&lt;/p&gt;&lt;p&gt;为此我们回顾了几何学中的欧几里得第五公设问题，&lt;br&gt;看到了语义问题对数学家们造成的困扰。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;自然数语言&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6ca1ee92d06503ca703443c055975951_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;618&quot; data-rawheight=&quot;496&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6ca1ee92d06503ca703443c055975951&quot; data-watermark-src=&quot;v2-c16ca45c9d298873b02ba98fc565ef7a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;从读小学的时候开始，我们就认识了&lt;b&gt;自然数&lt;/b&gt;，&lt;br&gt;我们可以从零开始计数，每个数字比它前面的多一， &lt;equation&gt;0~1~2~3~4~5~6~\cdots&lt;/equation&gt; &lt;br&gt;这些数字可以用来表示物品的个数。&lt;/p&gt;&lt;p&gt;它们是如此的贴近生活，如此自然，&lt;br&gt;以致我们一直以来，就把两个不同的&lt;b&gt;概念混淆&lt;/b&gt;在了一起。&lt;/p&gt;&lt;p&gt;一个概念是自然数的&lt;b&gt;语法&lt;/b&gt;构造，属于编码问题，&lt;br&gt;另一个概念则是对这种语法构造的&lt;b&gt;解释&lt;/b&gt;，属于语义问题。&lt;/p&gt;&lt;p&gt;为了看清这一点，&lt;br&gt;我们使用公理化方式定义一个&lt;b&gt;自然数形式系统&lt;/b&gt;，为此我们要问自己这些问题。&lt;/p&gt;&lt;p&gt;（1）这个形式系统包含了哪些&lt;b&gt;符号&lt;/b&gt;呢？&lt;br&gt;它只包含&lt;code class=&quot;inline&quot;&gt;0~9&lt;/code&gt;，这个十个字符。&lt;/p&gt;&lt;p&gt;（2）哪些符号串是&lt;b&gt;合法的&lt;/b&gt;？&lt;br&gt;一位符号串，或者不是&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;开头的多位符号串，都是合法的。&lt;br&gt;所有这些合法的符号串，构成了一个集合，称为该形式系统的“&lt;b&gt;语言&lt;/b&gt;”。&lt;/p&gt;&lt;p&gt;（3）哪些符号串被认为是&lt;b&gt;公理&lt;/b&gt;或&lt;b&gt;定理&lt;/b&gt;，定理之间的&lt;b&gt;推导规则&lt;/b&gt;是什么？&lt;br&gt;对于自然数形式系统来说，符号串&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;可以看做公理，后继函数可以看做推导规则。&lt;/p&gt;&lt;p&gt;（4）这些符号串的&lt;b&gt;含义&lt;/b&gt;是什么？&lt;br&gt;简单起见，我们可以直接指定符号串的含义为它所对应的那个自然数。&lt;br&gt;例如，&lt;code class=&quot;inline&quot;&gt;3&lt;/code&gt;是一个符号串，我们指定它对应 &lt;equation&gt;3&lt;/equation&gt; 这个自然数。&lt;br&gt;其中&lt;code class=&quot;inline&quot;&gt;3&lt;/code&gt;是&lt;b&gt;语法符号&lt;/b&gt;， &lt;equation&gt;3&lt;/equation&gt; 是&lt;b&gt;数学对象&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Peano系统&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-463638b4f26b795b43ffa6e69d129d99_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;719&quot; data-rawheight=&quot;283&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-463638b4f26b795b43ffa6e69d129d99&quot; data-watermark-src=&quot;v2-55bf380479312a5fe9ef07371e3e7378&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;上一节我们使用公理化的方式建立了一个形式系统，&lt;br&gt;并且选择了自然数作为该形式系统中符号串的解释。&lt;/p&gt;&lt;p&gt;可是在数学上，&lt;b&gt;自然数到底是什么呢？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;要回答这个问题，还要回顾《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34679052&quot;&gt;你好，类型&lt;/a&gt;》系列文章中介绍的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%9A%AE%E4%BA%9A%E8%AF%BA%E5%85%AC%E7%90%86&quot;&gt;Peano系统&lt;/a&gt;，&lt;br&gt;皮亚诺（&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9C%B1%E5%A1%9E%E4%BD%A9%C2%B7%E7%9A%AE%E4%BA%9E%E8%AB%BE&quot;&gt;Peano&lt;/a&gt;）将自然数理论建立在了&lt;b&gt;集合论&lt;/b&gt;之上。&lt;/p&gt;&lt;p&gt;其中， &lt;equation&gt;\{\varnothing,\varnothing^+,\varnothing^{++},\cdots\}&lt;/equation&gt; 构成了一个&lt;a href=&quot;https://thzt.github.io/2017/09/06/type-2/&quot;&gt;归纳集&lt;/a&gt;。&lt;br&gt;我们将 &lt;equation&gt;\varnothing,\varnothing^+,\varnothing^{++},\cdots&lt;/equation&gt; 定义为&lt;b&gt;自然数&lt;/b&gt;，（&lt;a href=&quot;https://en.wikipedia.org/wiki/Natural_number#Von_Neumann_construction&quot;&gt;von Neumann construction&lt;/a&gt;）&lt;br&gt;这样每一个自然数就和一个集合对应起来了。&lt;/p&gt;&lt;p&gt;因此，自然数 &lt;equation&gt;3&lt;/equation&gt; 是一个集合， &lt;equation&gt;\varnothing^{+++}=\{\varnothing,\{\varnothing\},\{\varnothing,\{\varnothing\}\}\}&lt;/equation&gt; ，&lt;br&gt;其中， &lt;equation&gt;A^+&lt;/equation&gt; 为集合 &lt;equation&gt;A&lt;/equation&gt; 的&lt;b&gt;后继运算&lt;/b&gt;， &lt;equation&gt;A^+=A\cup\{A\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;总而言之，符号串&lt;code class=&quot;inline&quot;&gt;3&lt;/code&gt;的数学解释，是一个集合 &lt;equation&gt;\varnothing^{+++}&lt;/equation&gt; 。&lt;br&gt;（不必惊讶。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;自然数代数&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9a7107c2e192d9f62649f8b1402faa96_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;390&quot; data-rawheight=&quot;300&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9a7107c2e192d9f62649f8b1402faa96&quot; data-watermark-src=&quot;v2-bba8ad8b43a82c97d564fb4b62ff187a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在读小学的时候，数学课只有一门，主要学有理数的四则运算，&lt;br&gt;而到了初中，数学就变成了两门，分为&lt;b&gt;代数&lt;/b&gt;课与&lt;b&gt;几何&lt;/b&gt;课，&lt;br&gt;代数课主要讲方程和函数，几何课主要讲平面几何。&lt;/p&gt;&lt;p&gt;平面几何是很直观的，也很容易和其他数学划清界线，&lt;br&gt;因此，初中生们对“什么是几何”都没有太多疑惑。&lt;br&gt;但是至于“&lt;b&gt;什么是代数&lt;/b&gt;”，就比较费解了，这个问题也困扰了我很久。&lt;/p&gt;&lt;p&gt;到大学，我们又学了线性代数，这种困扰日益加深，&lt;br&gt;因为居然出现了一种“线性的”“代数”，&lt;br&gt;却没有人事先告诉我们到底什么是“代数”。&lt;/p&gt;&lt;p&gt;后来我们学了抽象代数，这个问题才得以解决，我找到了一个令自己满意的答案。&lt;/p&gt;&lt;p&gt;为了说明“什么是代数”，最简单的办法就是下&lt;b&gt;定义&lt;/b&gt;，&lt;br&gt;设集合 &lt;equation&gt;M&lt;/equation&gt; 上定义了一组运算， &lt;equation&gt;a_1,a_2,\cdots,a_n&lt;/equation&gt; ，&lt;br&gt;运算结果仍是 &lt;equation&gt;M&lt;/equation&gt; 中的元素，则称 &lt;equation&gt;M&lt;/equation&gt; 相对于这 &lt;equation&gt;n&lt;/equation&gt; 个运算，构成了一个&lt;b&gt;代数&lt;/b&gt;。&lt;/p&gt;&lt;blockquote&gt;一般来说，代数问题的特点，&lt;br&gt;是对一类问题，利用统一的运算性质，求出所有可能的解答。&lt;/blockquote&gt;&lt;p&gt;因此，代数学就是研究&lt;b&gt;运算系统性质&lt;/b&gt;的学问。&lt;br&gt;而Peano系统，是最简单的运算系统之一，又称为&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%9A%AE%E4%BA%9A%E8%AF%BA%E5%85%AC%E7%90%86&quot;&gt;一阶算术系统&lt;/a&gt;。&lt;br&gt;自然数就是这个系统中的&lt;b&gt;运算对象&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;因此，小学数学也称为“算术”。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;代数学观点&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c907d127c351d66493491935cb19d4d0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;542&quot; data-rawheight=&quot;374&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c907d127c351d66493491935cb19d4d0&quot; data-watermark-src=&quot;v2-a2bf6961d44b1395b09b0b42048ab524&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;随着代数学的发展，人们发明了许多运算系统，&lt;br&gt;例如，整数的加减法，有理数的四则运算，实数的根式或指数运算，等等。&lt;br&gt;它们都有现实的对应物，&lt;b&gt;仿佛&lt;/b&gt;数学的研究对象就是现实世界一样。&lt;/p&gt;&lt;p&gt;然而，实际上并非如此。&lt;/p&gt;&lt;p&gt;例如，复数 &lt;equation&gt;1+2i&lt;/equation&gt; ，它是没有现实对应的，&lt;br&gt;但是我们仍然可以对复数进行运算。&lt;br&gt;一个三次方程可能没有实数解，但必定会存在三个复数解。&lt;/p&gt;&lt;p&gt;引入了复数之后，我们也才能体会到欧拉公式之美， &lt;equation&gt;e^{i\pi}+1=0&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;另一方面，代数学的研究重点也发生了改变，&lt;br&gt;一开始人们研究的是单个的，独立的，具体的运算系统，&lt;br&gt;但是后来人们逐渐发现，很多运算系统有相同的运算性质，&lt;br&gt;可以&lt;b&gt;抽象&lt;/b&gt;出来进行讨论。&lt;/p&gt;&lt;p&gt;例如，计算机系统中的无符号数，连同加法运算，构成了一个&lt;b&gt;阿贝尔群&lt;/b&gt;。&lt;br&gt;而阿贝尔群中的加法，满足交换律和结合律，&lt;br&gt;因此，编译器就可以采用任意的顺序进行计算，不影响最终结果。&lt;/p&gt;&lt;p&gt;&lt;b&gt;从运算性质的角度来分析问题&lt;/b&gt;，越来越流行了，&lt;br&gt;成为了现代数学不可或缺的一部分，&lt;br&gt;并且，代数学考虑问题的方法，也逐渐影响着其他学科。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文从语义和代数学角度重新认识了自然数，&lt;br&gt;自然数是Peano系统中的运算对象，&lt;br&gt;自然数集连同其上定义的后继运算，构成了一个代数（一阶算术系统）。&lt;/p&gt;&lt;p&gt;更重要的是，从代数学角度来看待问题，&lt;br&gt;有利于我们抓住系统中所隐含的&lt;b&gt;运算性质&lt;/b&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34679052&quot;&gt;你好，类型（二）：Lambda calculus&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/4114998/&quot;&gt;计算机语言的形式语义&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1833230/&quot;&gt;近世代数初步&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1896753/&quot;&gt;深入理解计算机系统&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-29-35017879</guid>
<pubDate>Thu, 29 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（一）：语义解释</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-28-34977830.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34977830&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-134995884618e02bd2e40ed91782730d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;775&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;1. 初窥语义&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34669807&quot;&gt;你好，类型&lt;/a&gt;》系列中，我们介绍了一些&lt;b&gt;形式系统&lt;/b&gt;，&lt;br&gt;例如 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 系统（ &lt;equation&gt;\lambda&lt;/equation&gt; 演算）， &lt;equation&gt;CL_w&lt;/equation&gt; （组合子逻辑），&lt;br&gt;它们由一些&lt;b&gt;合法的符号&lt;/b&gt;，以及这些符号的&lt;b&gt;推导规则&lt;/b&gt;构成，&lt;br&gt;命题逻辑与谓词逻辑，也可以用这种&lt;b&gt;公理化&lt;/b&gt;的方式构建起来。&lt;/p&gt;&lt;p&gt;然而，在讨论这些系统的时候，我们只是把它们看成了单纯的符号演算，&lt;br&gt;并没有过多考虑这些符号到底代表什么含义。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\lambda&lt;/equation&gt; 项 &lt;equation&gt;(\lambda x.x(xy))N&lt;/equation&gt; ，经过 &lt;equation&gt;\beta&lt;/equation&gt; 变换，我们可以得到， &lt;equation&gt;N(Ny)&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;(\lambda x.x(xy))N\triangleright_\beta N(Ny)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;它看起来真的&lt;b&gt;好像&lt;/b&gt;一个函数调用啊。&lt;br&gt;这就给我们带来了以下思考，是否可以把 &lt;equation&gt;(\lambda x.x(xy))&lt;/equation&gt; 解释为一个函数呢？&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;function (x){
    return x(x(y));
}&lt;/code&gt;&lt;p&gt;是否可以认为， &lt;equation&gt;(\lambda x.x(xy))N&lt;/equation&gt; 是用参数 &lt;equation&gt;N&lt;/equation&gt; 对该函数进行调用呢？&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;(function (x){
    return x(x(y));
}(N));

// 调用后相当于返回了以下结果
N(N(y))&lt;/code&gt;&lt;p&gt;这样解释的话， &lt;equation&gt;\beta&lt;/equation&gt; 变换就可以看做函数调用了。&lt;br&gt;这一切似乎顺理成章，显而易见。&lt;/p&gt;&lt;p&gt;可是，我们为什么可以这样做呢？&lt;br&gt; &lt;equation&gt;\beta&lt;/equation&gt; 变换与函数调用之间的关系是唯一确定的吗？&lt;br&gt;为了回答好这些问题，还得重新研读&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AF%AD%E4%B9%89%E5%AD%A6&quot;&gt;语义学&lt;/a&gt;这个有趣的学科。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 公理化&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-129f6b44ad6f901ec1f41203f965c775_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;806&quot; data-rawheight=&quot;393&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;首先我们先回顾一下，形式系统是怎么用公理化的方式构建的。&lt;br&gt;我们以一个称之为“pq”的系统为例。（出自《&lt;a href=&quot;https://book.douban.com/subject/1291204/&quot;&gt;哥德尔、艾舍尔、巴赫——集异璧之大成&lt;/a&gt;》）&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.1 公理化步骤&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;第一步&lt;/b&gt;，&lt;br&gt;我们要有一些&lt;b&gt;符号&lt;/b&gt;。&lt;br&gt;例如：“pq系统”只有三个符号，&lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;-&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第二步&lt;/b&gt;，&lt;br&gt;我们要说明什么样的符号串是&lt;b&gt;合法的&lt;/b&gt;，即指定一套&lt;b&gt;语法&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如，我们规定“pq系统”中合法的符号串，形如&lt;code class=&quot;inline&quot;&gt;xqypz&lt;/code&gt;，&lt;br&gt;其中，&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;z&lt;/code&gt;仅由一串短杠组成。&lt;/p&gt;&lt;code lang=&quot;bnf&quot;&gt;term := n &#39;q&#39; n &#39;p&#39; n
n := &#39;-&#39; | &#39;-&#39; n&lt;/code&gt;&lt;p&gt;因此，&lt;code class=&quot;inline&quot;&gt;--q-p-&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;---q--p-&lt;/code&gt;都是合法的符号串。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第三步，&lt;br&gt;&lt;/b&gt;我们要指定&lt;b&gt;公理&lt;/b&gt;和&lt;b&gt;推导规则&lt;/b&gt;，&lt;br&gt;其中公理是推导的出发点，由公理推导得出的符号串称为&lt;b&gt;定理&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;（1）“pq”系统的&lt;b&gt;公理&lt;/b&gt;如下，&lt;br&gt;只要&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;仅由一串短杠组成，那么&lt;code class=&quot;inline&quot;&gt;x-qxp-&lt;/code&gt;就是一条公理。&lt;/p&gt;&lt;p&gt;（2）“pq”系统的&lt;b&gt;推导规则&lt;/b&gt;是这样的，&lt;br&gt;假设&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;z&lt;/code&gt;都代表只包含短杠的特定的符号串，&lt;br&gt;并且假设&lt;code class=&quot;inline&quot;&gt;xqypz&lt;/code&gt;是一条已知的公理/定理，&lt;br&gt;那么&lt;code class=&quot;inline&quot;&gt;x-qypz-&lt;/code&gt;就是一条定理。&lt;/p&gt;&lt;p&gt;即它们满足 &lt;equation&gt;\frac{xqypz}{x-qypz-}&lt;/equation&gt; ，表示如果 &lt;equation&gt;xqypz&lt;/equation&gt; 是定理，则 &lt;equation&gt;x-qypz-&lt;/equation&gt; 也是定理。&lt;/p&gt;&lt;p&gt;例子，根据公理的定义，我们知道&lt;code class=&quot;inline&quot;&gt;--q-p-&lt;/code&gt;是一条公理，&lt;br&gt;又根据这条公理和推导规则，我们得到了&lt;code class=&quot;inline&quot;&gt;---q-p--&lt;/code&gt;是一条定理。&lt;/p&gt;&lt;p&gt;&lt;b&gt;小结：&lt;br&gt;&lt;/b&gt;以上三步我们通过公理化的方式构建了一个形式系统，&lt;br&gt;它由符号，语法，公理，推导规则组成，&lt;br&gt;我们可以用公理和旧定理生成新定理，不断演算。&lt;/p&gt;&lt;p&gt;在其他系统中，公理和定理的个数可能是有限的，而“pq”系统则是无限的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 解释&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-95ab0145a95af5914d68596e6d3d844d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;332&quot; data-rawheight=&quot;327&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们说以上“pq系统”定义了一个&lt;b&gt;形式语言&lt;/b&gt;，&lt;br&gt;这里的“语言”是一种数学上的定义，指的是&lt;b&gt;字符串的集合&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;“pq”系统的形式语言，就是系统中公理和定理的集合。&lt;/p&gt;&lt;p&gt;考察一个&lt;b&gt;形式语言&lt;/b&gt;，通常我们要研究它的两个方面，&lt;br&gt;其一，形式语言的&lt;b&gt;语法&lt;/b&gt;，指的是字符串的构成方式，&lt;br&gt;其二，形式语言的&lt;b&gt;语义&lt;/b&gt;，指的是每个字符串的含义。&lt;/p&gt;&lt;p&gt;我想大家都已经读过《&lt;a href=&quot;https://book.douban.com/subject/1148282/&quot;&gt;计算机程序的构造与解释&lt;/a&gt;》了吧，&lt;br&gt;所谓构造，指的就是语法，而解释指的就是语义。&lt;/p&gt;&lt;p&gt;那我们来看一看“pq系统”的形式语言该怎样解释吧。&lt;/p&gt;&lt;p&gt;我们可以&lt;b&gt;选择&lt;/b&gt;这样的解释方式，&lt;br&gt;例如，我们可以将&lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt;解释为“等于”，而将&lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt;解释为“加”，将短杠解释为数字。&lt;br&gt;于是，&lt;code class=&quot;inline&quot;&gt;---q-p--&lt;/code&gt;就可以被解释为“3等于1加2”了。&lt;/p&gt;&lt;p&gt;值得注意的是，合理的解释并不一定是唯一的，&lt;br&gt;例如，我们将&lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt;解释为“减”，将&lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt;解释为“等于”，也是可以的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 重新解释&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e603ce2f38b31d4a63e71f103b23171d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;398&quot; data-rawheight=&quot;298&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;上文中我们先给出了形式系统，然后再为系统选择一个合理的解释，&lt;br&gt;这种思维过程是值得提倡的。&lt;/p&gt;&lt;p&gt;考虑语义问题的时候，&lt;br&gt;我们应该总是先想想，&lt;b&gt;当前在对什么系统进行解释&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如，对“pq”系统，我们再引入一条新的公理，&lt;/p&gt;&lt;p&gt;&lt;b&gt;新公理：&lt;br&gt;&lt;/b&gt;只要&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;仅由一串短杠组成，那么&lt;code class=&quot;inline&quot;&gt;xqxp-&lt;/code&gt;也是一条公理。&lt;/p&gt;&lt;p&gt;现在来看，引入的新公理对“pq系统”产生了什么影响。&lt;br&gt;首先，&lt;code class=&quot;inline&quot;&gt;-q-p-&lt;/code&gt;在新系统中是一条公理，而在老系统中不是。&lt;br&gt;其次，根据推导规则，&lt;code class=&quot;inline&quot;&gt;--q-p--&lt;/code&gt;是新系统中的一条定理，而在老系统中也不是。&lt;/p&gt;&lt;p&gt;考虑到我们之前对符号串的解释，我们发现，&lt;br&gt;如果仍然沿用老系统对符号串的解释，&lt;code class=&quot;inline&quot;&gt;--q-p--&lt;/code&gt;应该被解释为“2等于1加2”，&lt;br&gt;这显然是不正确的。&lt;/p&gt;&lt;p&gt;因此，&lt;b&gt;在系统发生变化的时候，旧的解释可能就行不通了&lt;/b&gt;，&lt;br&gt;我们要对系统选择一个新的解释。&lt;/p&gt;&lt;p&gt;例如，我们只需要将&lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt;解释为“小于或等于”就行了。&lt;br&gt;然而，现在看来这种顺利成章的事情，却困扰了数学家们很多年。&lt;/p&gt;&lt;blockquote&gt;这是整个19世纪数学的最深刻的教训之一。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;4. 非欧几何&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f983e4bfb2298074cf707a73f22b27c8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;529&quot; data-rawheight=&quot;178&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;大家应该都听说过欧几里得&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%8C%E5%85%AC%E8%A8%AD&quot;&gt;第五公设&lt;/a&gt;的故事，欧几里得采用了&lt;b&gt;公理化&lt;/b&gt;的方式构建了几何学，&lt;br&gt;其中第五公设又称平行公设，它既不能被其他公设证明，也不能证否，&lt;br&gt;两千年来，在第五公设问题上，耗费了无数年轻数学家的生命和心血。&lt;/p&gt;&lt;blockquote&gt;如果两条直线与第三条直线相交时，在第三条直线的某一侧三条线所夹的内角之和小于两个直角的和，则那两条直线沿着这一侧延伸足够长之后必然相交&lt;/blockquote&gt;&lt;p&gt;1820年左右，俄国喀山大学教授&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B0%BC%E5%8F%A4%E6%8B%89%C2%B7%E7%BD%97%E5%B7%B4%E5%88%87%E5%A4%AB%E6%96%AF%E5%9F%BA&quot;&gt;罗巴切夫斯基&lt;/a&gt;，提出了一个与第五公设相矛盾的命题，&lt;br&gt;然后与欧几里得的前四个公设结合成一个公理系统，展开一系列的推理。&lt;br&gt;他认为如果这个系统在推理中出现矛盾，就等于证明了第五公设，此即数学中的反证法。&lt;/p&gt;&lt;p&gt;但是，在他极为细致深入的推理过程中，&lt;br&gt;得出了一个又一个在直觉上匪夷所思，&lt;br&gt;但在逻辑上毫无矛盾的命题。&lt;/p&gt;&lt;p&gt;这在当时是一件很难理解的事情，&lt;br&gt;因为人们一致认为，欧几里得几何是&lt;b&gt;物质空间中图形性质的正确理想化&lt;/b&gt;。&lt;br&gt;正确的几何结论&lt;b&gt;不应该&lt;/b&gt;与我们的直观感受不符。&lt;/p&gt;&lt;p&gt;现在看来，这样理解当然是有问题的，&lt;br&gt;因为，它&lt;b&gt;混淆了公理系统中的结论，和对这些结论的解释&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;就好像上文中我们为“pq”系统增加了新公理一样，&lt;br&gt;新定理仍然是正确推导的产物，只是不能沿用旧方式进行解释了。&lt;/p&gt;&lt;p&gt;关于欧几里得第五公设，最终人们得到了三种常用的几何学，&lt;br&gt;称为欧几里得几何，罗巴切夫斯基几何，以及黎曼几何。&lt;br&gt;这些公理系统，对研究不同的数学对象起到了关键作用。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;5. 总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文通过一个称之为“pq”的系统，介绍了形式系统公理化的典型步骤，&lt;br&gt;并且严格区分了，公理系统中的&lt;b&gt;结论&lt;/b&gt;与对它的&lt;b&gt;解释&lt;/b&gt;之间的不同。&lt;/p&gt;&lt;p&gt;通过更改公理系统，不论修改公理或者修改推导规则，我们将得到一个新的系统，&lt;br&gt;从而对新系统中的结论，我们就得采用审慎的方式&lt;b&gt;重新解释&lt;/b&gt;。&lt;br&gt;这是数学史给我们带来的最有价值的经验教训之一。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34669807&quot;&gt;你好，类型（一）：开篇&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_system&quot;&gt;Formal system&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_language&quot;&gt;Formal language&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AF%AD%E4%B9%89%E5%AD%A6&quot;&gt;语义学&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1291204/&quot;&gt;哥德尔、艾舍尔、巴赫——集异璧之大成&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%8C%E5%85%AC%E8%A8%AD&quot;&gt;平行公设&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;http://www.kepu.net.cn/gb/basic/szsx/4/44/4_44_1005.htm&quot;&gt;非欧几何学的诞生&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-28-34977830</guid>
<pubDate>Wed, 28 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（十）：Parametric polymorphism</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-27-34936637.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34936637&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6b54d583eb6b73ad8566ca881cf020a0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;698&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们介绍了&lt;b&gt;let多态&lt;/b&gt;，&lt;br&gt;将let表达式 &lt;equation&gt;let~x=t_1~in~t_2&lt;/equation&gt; ，看做了 &lt;equation&gt;[x\mapsto t_1]t_2&lt;/equation&gt; 的简写，&lt;br&gt;即，把 &lt;equation&gt;t_2&lt;/equation&gt; 中出现的所有 &lt;equation&gt;x&lt;/equation&gt; ，都用 &lt;equation&gt;t_1&lt;/equation&gt; 替换掉，因此这些副本可以具有不同的类型。&lt;/p&gt;&lt;p&gt;本文将介绍另外一种多态形式，称为&lt;b&gt;参数化多态&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Parametric_polymorphism&quot;&gt;parametric polymorphism&lt;/a&gt;），例如，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Maybe a = Nothing | Just a&lt;/code&gt;&lt;p&gt;以上Haskell代码，定义了一个&lt;code class=&quot;inline&quot;&gt;Maybe a&lt;/code&gt;类型，&lt;br&gt;其中&lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt;称为类型构造器（type constructor），&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;是它的参数。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt;不是一个合法的类型，它只有和某个具体的&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;放在一起，才是一个合法的类型，&lt;br&gt;例如，&lt;code class=&quot;inline&quot;&gt;Maybe Int&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;Maybe Char&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;System F&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2599a0bf18815b88e00dbfd51c04a385_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;270&quot;&gt;&lt;p&gt;为了实现参数化多态，我们需要对简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算（ &lt;equation&gt;\lambda^\to&lt;/equation&gt; 系统）进行扩展，&lt;br&gt;在 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 中，我们用 &lt;equation&gt;\lambda x.t&lt;/equation&gt; 来表示 &lt;equation&gt;\lambda&lt;/equation&gt; 抽象（lambda abstraction），&lt;br&gt;而使用 &lt;equation&gt;t_1~t_2&lt;/equation&gt; 来表示 &lt;equation&gt;\lambda&lt;/equation&gt; 应用（lambda application）。&lt;/p&gt;&lt;p&gt;现在我们引入一种新的抽象形式， &lt;equation&gt;\lambda X.t&lt;/equation&gt; ，它的参数 &lt;equation&gt;X&lt;/equation&gt; 是一个类型，称为&lt;b&gt;类型抽象&lt;/b&gt;，&lt;br&gt;再引入一种新的应用形式， &lt;equation&gt;t[T]&lt;/equation&gt; ，称为&lt;b&gt;类型实例化&lt;/b&gt;，其中 &lt;equation&gt;T&lt;/equation&gt; 是一个类型表达式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;求值规则&lt;/b&gt;如下，&lt;br&gt; &lt;equation&gt;(\lambda X.t)[T]\to[X\mapsto T]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;例如，我们可以这样定义一个多态函数， &lt;equation&gt;id=\lambda X.\lambda x:X.x&lt;/equation&gt; ，&lt;br&gt;当把它应用于类型 &lt;equation&gt;Nat&lt;/equation&gt; 时，&lt;br&gt; &lt;equation&gt;id[Nat]\to[X\mapsto Nat](\lambda x:X.x)=\lambda x:Nat.x&lt;/equation&gt; ，它为 &lt;equation&gt;Nat&lt;/equation&gt; 类型上的恒等函数。&lt;br&gt;而把它应用于类型 &lt;equation&gt;Bool&lt;/equation&gt; 时，&lt;br&gt; &lt;equation&gt;id[Bool]\to[X\mapsto Bool](\lambda x:X.x)=\lambda x:Bool.x&lt;/equation&gt; ，它为 &lt;equation&gt;Bool&lt;/equation&gt; 类型上的恒等函数，&lt;/p&gt;&lt;p&gt;可见， &lt;equation&gt;id&lt;/equation&gt; 的具体类型，依赖于它的&lt;b&gt;类型参数&lt;/b&gt;。&lt;br&gt;它应用于任意一个类型 &lt;equation&gt;T&lt;/equation&gt; ， &lt;equation&gt;id[T]&lt;/equation&gt; 都会得到一个类型为 &lt;equation&gt;T\to T&lt;/equation&gt; 的函数，&lt;br&gt;因此，人们通常将 &lt;equation&gt;id&lt;/equation&gt; 的类型记为 &lt;equation&gt;\forall X.X\to X&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;类型规则&lt;/b&gt;如下，&lt;/p&gt;&lt;p&gt;（1） &lt;equation&gt;\frac{\Gamma,X\vdash t:T}{\Gamma\vdash\lambda X.t:\forall X.T}&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\frac{\Gamma\vdash t_1:\forall X.T_1}{\Gamma\vdash t[T_2]:[X\mapsto T_2]T_1}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中，类型 &lt;equation&gt;\forall X.T&lt;/equation&gt; ，叫做&lt;b&gt;全称类型&lt;/b&gt;（universal type），&lt;br&gt; &lt;equation&gt;\forall&lt;/equation&gt; 称为&lt;b&gt;全称量词&lt;/b&gt;（universal quantifier），引入了全称类型之后得到的系统，称为&lt;b&gt;System F&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rank-N Types&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e7d0c235c510c23fd00f4261f94e4eb6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;698&quot;&gt;&lt;p&gt;有了全称类型之后，函数的参数类型和返回值类型，都有可能具有全称类型。&lt;br&gt;不难看出，函数返回值类型的全称量词，总是可以提取出来，放到最外面，&lt;br&gt;但是参数类型的全称量词，不能提取出来。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\forall X.X\to (\forall Y.Y\to X)&lt;/equation&gt; ，相当于 &lt;equation&gt;\forall X.\forall Y.X\to Y\to X&lt;/equation&gt; ，&lt;br&gt;而 &lt;equation&gt;(\forall X.X\to X)\to Nat&lt;/equation&gt; ，与 &lt;equation&gt;\forall X.(X\to X)\to Nat&lt;/equation&gt; 则不同。&lt;/p&gt;&lt;p&gt;不包含全称量词的类型表达式，具有&lt;b&gt;rank-0类型&lt;/b&gt;，也称为&lt;b&gt;单态类型&lt;/b&gt;（monotype），&lt;br&gt;全称量词都可以提取出来类型表达式，具有&lt;b&gt;rank-1类型&lt;/b&gt;（rank-1 type），&lt;br&gt;一个函数类型，它的入参具有&lt;b&gt;rank-n类型&lt;/b&gt;，那么该函数就具有&lt;b&gt;rank-(n+1)类型&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如，&lt;br&gt; &lt;equation&gt;((\forall X.X\to X)\to Nat)\to Bool\to Bool&lt;/equation&gt; ，具有rank-3类型，&lt;br&gt; &lt;equation&gt;Nat\to (\forall X.X\to X)&lt;/equation&gt; ，具有rank-1类型。&lt;/p&gt;&lt;p&gt;System F的功能是很强大的，但是&lt;a href=&quot;https://en.wikipedia.org/wiki/System_F#Use_in_programming_languages&quot;&gt;不幸的是&lt;/a&gt;，&lt;br&gt;人们发现，该系统中的类型推导算法是&lt;a href=&quot;https://en.wikipedia.org/wiki/Undecidable_problem&quot;&gt;不可判定的&lt;/a&gt;。&lt;br&gt;例如，一般而言，一个rank-3及其以上rank-N类型的表达式，其类型是不可确定的，&lt;br&gt;为了确定它的类型，人们不得不手工加上必要的类型信息。&lt;/p&gt;&lt;p&gt;Haskell采用了&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system&quot;&gt;Hindley–Milner类型系统&lt;/a&gt;，&lt;br&gt;它是System F的一个子集，其中包含了可判定的类型推导算法。&lt;br&gt;在Haskell中，类型参量（type variable）&lt;b&gt;默认&lt;/b&gt;具有全称类型（universally quantified），&lt;br&gt;例如，&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; a&lt;/code&gt;，实际上表示类型 &lt;equation&gt;\forall a.a\to a&lt;/equation&gt; ，&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; a&lt;/code&gt;可看做&lt;code class=&quot;inline&quot;&gt;(-&amp;gt;) a a&lt;/code&gt;类型，其中&lt;code class=&quot;inline&quot;&gt;-&amp;gt;&lt;/code&gt;为函数类型构造器。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;非直谓性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b687486615e31ac710fae4f635cc5817_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;200&quot; data-rawheight=&quot;257&quot;&gt;&lt;p&gt;在数学和逻辑学中，一个定义称为&lt;b&gt;非直谓的&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Impredicativity&quot;&gt;impredicative&lt;/a&gt;），&lt;br&gt;指的是它包含了自引用（self-reference）。&lt;/p&gt;&lt;p&gt;例如，在定义一个集合的时候，用到了正在定义的这个集合。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Russell%27s_paradox&quot;&gt;罗素悖论&lt;/a&gt;就是用非直谓的方式构造出来的，&lt;br&gt;如果我们定义 &lt;equation&gt;R=\{x|x\notin x\}&lt;/equation&gt; ，那么 &lt;equation&gt;R\in R\Leftrightarrow R\notin R&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;非直谓定义并不一定导致矛盾，有些情况下还是有用的，例如，我们可以非直谓的定义，&lt;br&gt;集合中的最小元素为， &lt;equation&gt;A_{min}=x&lt;/equation&gt; ， &lt;equation&gt;\forall y.x\leqslant y&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;具有参数化多态的类型表达式，也有直谓（predicative）和非直谓（impredicative）之分。&lt;/p&gt;&lt;p&gt;如果它可以用一个多态类型实例化，例如用它自己来实例化，&lt;br&gt;就称为&lt;b&gt;非直谓多态类型&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Parametric_polymorphism#Impredicative_polymorphism&quot;&gt;impredicative polymorphism&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;反之，如果一个多态类型表达式，只能用单态类型实例化，&lt;br&gt;就称它具有&lt;b&gt;直谓多态类型&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Parametric_polymorphism#Predicative_polymorphism&quot;&gt;predicative_polymorphism&lt;/a&gt;）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;单态限制&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9f700c8427d7653a97af35c5fa56445d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;503&quot; data-rawheight=&quot;337&quot;&gt;&lt;code lang=&quot;haskell&quot;&gt;f x = let g y z = ([x,y], z) 
      in ...&lt;/code&gt;&lt;p&gt;假设&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型为&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，那么&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的类型只能为&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; b -&amp;gt; ([a], b)&lt;/code&gt;，&lt;br&gt;其中，由于列表类型的限制，&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;必须具有相同的类型。&lt;/p&gt;&lt;p&gt;此时，只有&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;可以具有全称量词，即 &lt;equation&gt;\forall b.a\to b\to ([a],b)&lt;/equation&gt; ，&lt;br&gt;因为&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;在类型上下文中，已经出现了，不能再被实例化为其他的类型了。&lt;br&gt;我们称，&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的第一个参数&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;具有&lt;b&gt;单态性&lt;/b&gt;（monomorphism）。&lt;/p&gt;&lt;p&gt;例如，&lt;code class=&quot;inline&quot;&gt;(g True, g &#39;c&#39;)&lt;/code&gt;不是良类型的，而&lt;code class=&quot;inline&quot;&gt;(g True, g False)&lt;/code&gt;是良类型的。&lt;/p&gt;&lt;p&gt;值得一提的是，显式的给&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;注明类型，也不能阻止&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的单态行为，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;f x = let 
         g :: a -&amp;gt; b -&amp;gt; ([a],b) 
         g y z = ([x,y], z) 
      in ...&lt;/code&gt;&lt;p&gt;此时，&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;仍然是单态的。&lt;/p&gt;&lt;p&gt;在&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system&quot;&gt;Hindley–Milner类型系统&lt;/a&gt;中，&lt;br&gt;如果一个类型变量，不在类型上下文中出现，它就可以被&lt;b&gt;全称化&lt;/b&gt;（generalize）。&lt;br&gt;但是Haskell考虑到性能和模块间的类型推导，&lt;br&gt;还增加了特殊的&lt;b&gt;单态限制&lt;/b&gt;（monomorphism restriction）避免全称化。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Rule 1&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在一组相互依赖的声明中，满足以下两个条件，其中的类型变量才会被全称化，&lt;br&gt;（1）每一个变量，都被函数或模式匹配所绑定，&lt;br&gt;（2）被模式匹配绑定的变量，都有显式的类型签名。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Rule 2&lt;/b&gt;&lt;/p&gt;&lt;p&gt;导入到其他模块（module）的单态类型变量，被认为是有歧义的（ambiguous），&lt;br&gt;类型通过其来源模块内的&lt;code class=&quot;inline&quot;&gt;default&lt;/code&gt;声明来决定。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;module M1(len1) where 
  default( Int, Double ) 
  len1 = genericLength &quot;Hello&quot;

module M2 where 
  import M1(len1) 
  len2 = (2 * len1) :: Rational&lt;/code&gt;&lt;p&gt;当模块&lt;code class=&quot;inline&quot;&gt;M1&lt;/code&gt;的类型推导结束后，根据Rule 1，&lt;code class=&quot;inline&quot;&gt;len1&lt;/code&gt;具有单态类型，&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;len1 :: Num a =&amp;gt; a&lt;/code&gt;，&lt;br&gt;Rule 2表明，类型变量&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;具有歧义性，必须使用&lt;code class=&quot;inline&quot;&gt;default&lt;/code&gt;声明来解决歧义。&lt;/p&gt;&lt;p&gt;因此，根据&lt;code class=&quot;inline&quot;&gt;default( Int, Double )&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;len1&lt;/code&gt;得到了类型&lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt;，&lt;br&gt;不过，&lt;code class=&quot;inline&quot;&gt;M2&lt;/code&gt;中对&lt;code class=&quot;inline&quot;&gt;len1 :: Int&lt;/code&gt;的使用导致了类型错误。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/1761910/&quot;&gt;Types and programming languages&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.haskell.org/definition/haskell2010.pdf&quot;&gt;Haskell 2010 Language Report&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#arbitrary-rank-polymorphism&quot;&gt;Glasgow Haskell Compiler User’s Guide&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Parametric_polymorphism&quot;&gt;Parametric polymorphism&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/putting.pdf&quot;&gt;Practical type inference for arbitrary-rank types&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/System_F&quot;&gt;System F&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system&quot;&gt;Hindley–Milner type system&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-27-34936637</guid>
<pubDate>Tue, 27 Mar 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
