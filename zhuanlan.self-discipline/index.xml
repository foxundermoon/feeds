<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>业余程序员的个人修养</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Thu, 15 Mar 2018 22:00:54 +0800</lastBuildDate>
<item>
<title>递归函数（七）：不动点算子</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-15-34526779.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34526779&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;以上几篇文章中，我们讨论了可计算性理论相关的一些内容，&lt;br&gt;可计算性与递归函数论存在着千丝万缕的联系，&lt;br&gt;不动点理论也是这样的，我们定义的递归函数一定存在吗？&lt;br&gt;在什么情况下它是存在的？&lt;/p&gt;&lt;p&gt;要回答以上这些问题，还要从方程，不动点，不动点算子说起。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;约束方程&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-676edc86f9bf546b4765bf4586fc95cd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;215&quot;&gt;&lt;p&gt;在中学时代，我们学过“&lt;b&gt;方程&lt;/b&gt;”的概念，&lt;br&gt;方程可以简单表述为含有未知数的等式，例如， &lt;equation&gt;3x+3=2&lt;/equation&gt; 。&lt;br&gt;未知数可以同时出现在等式的两边，例如， &lt;equation&gt;2x+3=2-x&lt;/equation&gt; 。&lt;br&gt;通过合并同类项，我们可以求解 &lt;equation&gt;x&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;在大学时代，我们还学过&lt;b&gt;线性方程组&lt;/b&gt;和&lt;b&gt;微分方程&lt;/b&gt;，&lt;br&gt;例如，求解矩阵的特征值和特征向量， &lt;equation&gt;Av=\lambda v&lt;/equation&gt; ，&lt;br&gt;二阶常微分方程（&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%A1%9E%E5%B0%94%E5%87%BD%E6%95%B0&quot;&gt;贝塞尔方程&lt;/a&gt;）， &lt;equation&gt;x^2y&#39;&#39;+xy&#39;+(x^2-\alpha ^2)y=0&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;在计算机科学中，同样的未知“数”的思想，&lt;br&gt;还出现在了类型推导（例如：&lt;a href=&quot;https://en.wikipedia.org/wiki/Unification_(computer_science)&quot;&gt;unification&lt;/a&gt;）与递归函数的定义中。&lt;br&gt;以上这些例子，方程是“&lt;b&gt;约束&lt;/b&gt;”的一种表现形式。&lt;/p&gt;&lt;p&gt;我们回到最简单的阶乘函数&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的定义式，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact :: Int -&amp;gt; Int
fact 1 = 1
fact n = n * fact (n-1)&lt;/code&gt;&lt;p&gt;去掉语法糖，稍微修改一下，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact :: Int -&amp;gt; Int
fact n = case n of 
  1 -&amp;gt; 1
  n -&amp;gt; n * fact (n-1)&lt;/code&gt;&lt;p&gt;我们发现，&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的定义和“方程”十分相似，&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;同时出现在了等式的两边，&lt;br&gt;阶乘函数，就是这个“方程”的“解”。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;函数的不动点&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e4ccb41ef78c4fe19ec357fc532960ea_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;560&quot; data-rawheight=&quot;481&quot;&gt;&lt;p&gt;在中学数学中，我们已经学过不动点了，只是当时印象不是那么深刻，&lt;br&gt;&lt;b&gt;函数的不动点&lt;/b&gt;，是指被这个函数映射到其自身的那些点。&lt;br&gt;例如： &lt;equation&gt;f(x)=x^2-3x+4&lt;/equation&gt; ，&lt;br&gt;则 &lt;equation&gt;2&lt;/equation&gt; 是函数 &lt;equation&gt;f&lt;/equation&gt; 的一个不动点， &lt;equation&gt;f(2)=2&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;并不是每一个函数都有不动点，&lt;br&gt;例如，实数域上的函数 &lt;equation&gt;f(x)=x+1&lt;/equation&gt; ，就没有不动点，&lt;br&gt;对于任意实数 &lt;equation&gt;x&lt;/equation&gt; ，永远都不等于 &lt;equation&gt;x+1&lt;/equation&gt; 。&lt;br&gt;（不动点是和定义域有关的，以后我们还会重新讨论 &lt;equation&gt;f(x)=x+1&lt;/equation&gt; 的不动点。&lt;/p&gt;&lt;p&gt;一般的，函数 &lt;equation&gt;f(x)&lt;/equation&gt; 的&lt;b&gt;不动点&lt;/b&gt;，指的是这样的 &lt;equation&gt;x&lt;/equation&gt; ，使得 &lt;equation&gt;x=f(x)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;重新温习了不动点相关的知识之后，&lt;br&gt;我们就可以对上面的阶乘函数进行改造了，&lt;br&gt;我们要把阶乘函数看做另外一个函数的不动点。&lt;/p&gt;&lt;p&gt;定义函数 &lt;equation&gt;g&lt;/equation&gt; ，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;g :: (Int -&amp;gt; Int) -&amp;gt; Int -&amp;gt; Int
g f n = case n of 
  1 -&amp;gt; 1
  n -&amp;gt; n * f (n-1)&lt;/code&gt;&lt;p&gt;我们可以得到，&lt;code class=&quot;inline&quot;&gt;g fact = fact&lt;/code&gt;，&lt;br&gt;因此，&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;实际上就是函数&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的不动点。&lt;/p&gt;&lt;p&gt;于是，在“方程”中求解&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的过程，&lt;br&gt;就转换成了求解函数&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的不动点的过程了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;不动点算子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d17244c93688f8a33bbd53a896cbe762_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;492&quot; data-rawheight=&quot;179&quot;&gt;&lt;p&gt;我们怎样求解函数&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的不动点呢？&lt;br&gt;在Haskell中，可以很方便的定义一个高阶函数&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;，它可以用来求解任意函数的不动点，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fix :: (a -&amp;gt; a) -&amp;gt; a
fix g = let x = g x in x&lt;/code&gt;&lt;p&gt;我们试验一下&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;的强大威力，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact 10
&amp;gt; 3628800

fix g 10
&amp;gt; 3628800&lt;/code&gt;&lt;p&gt;注意，&lt;code class=&quot;inline&quot;&gt;fix g&lt;/code&gt;得到的是&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的不动点，而不是&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的不动点，&lt;br&gt;即&lt;code class=&quot;inline&quot;&gt;(fix g) = g (fix g)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;有了&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;，我们就可以构造&lt;b&gt;匿名递归函数&lt;/b&gt;了，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact&#39; :: Int -&amp;gt; Int
fact&#39; = fix $ \fact -&amp;gt; \n -&amp;gt; case n of 
  1 -&amp;gt; 1
  n -&amp;gt; n * fact (n-1)&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;后面跟的函数没有名字，它是匿名的，但是经过&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;作用后，可以产生一个递归函数。&lt;br&gt;也就是说，为了实现递归，函数是可以没有名字的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Y组合子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2434c4ee3ac9498d53d23a77e067d39f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;218&quot; data-rawheight=&quot;231&quot;&gt;&lt;p&gt;&lt;b&gt;Y组合子&lt;/b&gt;，是&lt;a href=&quot;https://zh.wikipedia.org/wiki/Haskell_Curry&quot;&gt;Haskell B. Curry&lt;/a&gt;在研究 &lt;equation&gt;\lambda&lt;/equation&gt; 演算时发现的，&lt;br&gt;它的表现形式如下， &lt;equation&gt;Y:=\lambda f.(\lambda x.(f\ (x\ x))\ \lambda x.(f\ (x\ x)))&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;在 &lt;equation&gt;\lambda&lt;/equation&gt; 演算中，（ &lt;equation&gt;\alpha&lt;/equation&gt; 转换和 &lt;equation&gt;\beta&lt;/equation&gt; 规约&lt;br&gt;我们可以证明，对于任何函数&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;， &lt;equation&gt;(Y g) = (g (Y g))&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;因此，Y组合子是一个&lt;b&gt;不动点算子&lt;/b&gt;，它可以得到任意函数的不动点。&lt;br&gt;其他的不动点算子还有图灵不动点组合子 &lt;equation&gt;\Theta&lt;/equation&gt; ， &lt;equation&gt;\Theta:=(\lambda x.\lambda y.(y\ (x\ x\ y)))\ (\lambda x.\lambda y.(y\ (x\ x\ y)))&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;讨论Y组合子在Haskell中的表示方式是有趣的，因为直接翻译过去会报类型错误，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;y :: (a -&amp;gt; a) -&amp;gt; a
y = \f -&amp;gt; (\x -&amp;gt; f (x x)) (\x -&amp;gt; f (x x))

-- Occurs check: cannot construct the infinite type: r0 ~ r0 -&amp;gt; a
-- Expected type: r0 -&amp;gt; a
--   Actual type: (r0 -&amp;gt; a) -&amp;gt; a
-- In the first argument of ‘x’, namely ‘x’
-- In the first argument of ‘f’, namely ‘(x x)’&lt;/code&gt;&lt;p&gt;类型系统无法确定&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型。&lt;/p&gt;&lt;p&gt;问题出在表达式&lt;code class=&quot;inline&quot;&gt;x x&lt;/code&gt;上面，&lt;br&gt;假设&lt;code class=&quot;inline&quot;&gt;x x&lt;/code&gt;的类型为&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，则第一个&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型就应该为&lt;code class=&quot;inline&quot;&gt;? -&amp;gt; a&lt;/code&gt;，&lt;br&gt;于是，第二个&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型肯定也应该是&lt;code class=&quot;inline&quot;&gt;? -&amp;gt; a&lt;/code&gt;。（因为都是&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt; &lt;/p&gt;&lt;p&gt;又因为&lt;code class=&quot;inline&quot;&gt;x x&lt;/code&gt;的类型为&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，&lt;br&gt;所以第一个&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型&lt;code class=&quot;inline&quot;&gt;? -&amp;gt; a&lt;/code&gt;中，&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;的类型就应该是&lt;code class=&quot;inline&quot;&gt;? -&amp;gt; a&lt;/code&gt;，&lt;br&gt;（因为&lt;code class=&quot;inline&quot;&gt;((? -&amp;gt; a) -&amp;gt; a)&lt;/code&gt;作用到&lt;code class=&quot;inline&quot;&gt;(? -&amp;gt; a)&lt;/code&gt;才能得到&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; &lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;的类型是&lt;code class=&quot;inline&quot;&gt;? -&amp;gt; a&lt;/code&gt;，因此&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;应该是一个&lt;a href=&quot;https://zh.m.wikipedia.org/wiki/%E9%80%92%E5%BD%92%E7%B1%BB%E5%9E%8B&quot;&gt;递归类型&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;下面我们来定义递归类型&lt;code class=&quot;inline&quot;&gt;Mu&lt;/code&gt;，来帮助编译器进行恰当的类型推导，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Mu a = Mu (Mu a -&amp;gt; a)

y :: (a -&amp;gt; a) -&amp;gt; a
y f = (\h -&amp;gt; h $ Mu h) (\x -&amp;gt; f . (\(Mu g) -&amp;gt; g) x $ x)&lt;/code&gt;&lt;p&gt;最后，&lt;code class=&quot;inline&quot;&gt;fact&#39;&lt;/code&gt;就可以使用Y组合子来定义了。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact&#39; :: Int -&amp;gt; Int
fact&#39; = y $ \fact -&amp;gt; \n -&amp;gt; case n of 
  1 -&amp;gt; 1
  n -&amp;gt; n * fact (n-1)&lt;/code&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文从简单的“方程”思想出发，引出了不动点的概念，&lt;br&gt;然后把递归函数看做了另外一个函数的不动点，&lt;br&gt;最后，我们讨论了Y组合子这样一个具体的不动点算子。&lt;/p&gt;&lt;p&gt;可是，这里隐藏着一个问题，我们看到&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;是可以求解任意函数的不动点的，&lt;br&gt;而对于以下递归函数&lt;code class=&quot;inline&quot;&gt;succ&lt;/code&gt;，即 &lt;equation&gt;f(x)=x+1&lt;/equation&gt; ，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;succ :: Int -&amp;gt; Int
succ n = n+1&lt;/code&gt;&lt;p&gt;在实数域上是显然没有不动点的。&lt;/p&gt;&lt;p&gt;那么&lt;code class=&quot;inline&quot;&gt;fix succ&lt;/code&gt;是什么呢？&lt;br&gt;这个问题，我们将在后文中继续讨论。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E6%96%B9%E7%A8%8B&quot;&gt;方程&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F&quot;&gt;特征值和特征向量&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B&quot;&gt;微分方程&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E4%B8%8D%E5%8A%A8%E7%82%B9&quot;&gt;不动点&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E4%B8%8D%E5%8A%A8%E7%82%B9%E7%BB%84%E5%90%88%E5%AD%90&quot;&gt;不动点组合子&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Fix_and_recursion&quot;&gt;Haskell/Fix and recursion&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;http://stackoverflow.com/questions/4273413/y-combinator-in-haskell/5885270#5885270&quot;&gt;Y Combinator in Haskell&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-15-34526779</guid>
<pubDate>Thu, 15 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（六）：最多有多少个程序</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-14-34484014.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34484014&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上一篇中，我们通过引入极小化算子定义了递归函数，&lt;br&gt;使用递归函数，我们又定义了递归集与递归可枚举集，&lt;br&gt;本文我们要讨论，为什么递归可枚举集是“可枚举”的，以及什么是可计算函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;可计算性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a4af83dc0f3607efe72758004eb1e9f5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;429&quot;&gt;&lt;p&gt;我们听说过，现代计算机在计算能力上是与图灵机等价的，&lt;br&gt;什么叫做计算能力呢？&lt;br&gt;它指的是图灵机可计算的函数集，与现代计算机可计算的函数集是相等的。&lt;/p&gt;&lt;p&gt;为了简单起见，我们不去讨论图灵机，而是从现代计算机直接说起，&lt;br&gt;设 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 是一段程序， &lt;equation&gt;n&lt;/equation&gt; 是一个正整数，&lt;br&gt;我们称数论函数 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 为&lt;b&gt;程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 所计算的&lt;/b&gt; &lt;equation&gt;n&lt;/equation&gt; 元部分函数，&lt;br&gt;如果对于相同的输入，&lt;br&gt;要么：（1）程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的计算可以终止，此时计算结果等于 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 的相应函数值；&lt;br&gt;要么：（2）程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的计算不能终止，此时 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 无定义。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;f(x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 是一个部分函数，&lt;br&gt;如果存在程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 可计算 &lt;equation&gt;f&lt;/equation&gt; ，则称 &lt;equation&gt;f&lt;/equation&gt; 是&lt;b&gt;部分可计算的&lt;/b&gt;。&lt;br&gt;如果一个函数，既是部分可计算的，又是全函数，则称这个函数是&lt;b&gt;可计算的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;可以证明，所有的原始递归函数和递归函数都是部分可计算的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;通用程序&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们使用现代计算机进行编程的时候，并不是直接把程序的输入传给程序，&lt;br&gt;而是将程序本身以及它的输入，传给计算机，最后由计算机得到计算结果，&lt;br&gt;像这种接受任何程序和它的输入作为自己的输入，返回程序执行结果的程序，称为&lt;b&gt;通用程序&lt;/b&gt;。&lt;br&gt;为此，通用程序需要把输入的程序进行&lt;b&gt;编码&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;常用的编码方法，涉及&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%85%8D%E5%AF%B9%E5%87%BD%E6%95%B0&quot;&gt;配对函数&lt;/a&gt;和&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E6%95%B0&quot;&gt;哥德尔编码&lt;/a&gt;。&lt;br&gt;为了不引入太多的复杂性，我们可以将程序的编码理解为存储程序的二进制数据，&lt;br&gt;不同的程序会有不同的二进制表示，每一个二进制表示可以对应一段程序&lt;br&gt;（虽然可能不合法）。&lt;/p&gt;&lt;p&gt;哥德尔编码做的事情就是将程序和自然数集一一对应起来。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9a7c9ce767daf3bef81c5e3e7d5c152e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;565&quot;&gt;&lt;p&gt;因此，所有程序的个数是&lt;b&gt;可数的&lt;/b&gt;，而这些程序可计算的函数个数也一定是可数的，&lt;br&gt;它们可能是全函数，也可能是部分函数。&lt;br&gt;（其中，“可数”指的是可数集，&lt;b&gt;可数集&lt;/b&gt;是与自然数集之间存在一一映射的集合。&lt;/p&gt;&lt;p&gt;然而，自然数集上的函数全体并不可数，（证略&lt;br&gt;所以肯定存在程序不可计算的函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;集合个数的可枚举性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-216f0ef423d8f37598db6eee7ed05452_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;389&quot; data-rawheight=&quot;182&quot;&gt;&lt;p&gt;程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 所计算的函数，我们可以记为 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; ，&lt;br&gt;由此，我们可以定义通用程序 &lt;equation&gt;\Phi&lt;/equation&gt; ，则有，&lt;br&gt; &lt;equation&gt;\Phi (x_1,x_2,\cdots ,x_n,y)=\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; &lt;br&gt;其中， &lt;equation&gt;y&lt;/equation&gt; 是程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的编码。&lt;/p&gt;&lt;p&gt;因为，所有的程序与自然数集一一对应，&lt;br&gt;所以， &lt;equation&gt;\Phi (x_1,x_2,\cdots ,x_n,0),\Phi (x_1,x_2,\cdots ,x_n,1),\cdots&lt;/equation&gt; &lt;b&gt;枚举了所有的 &lt;equation&gt;n&lt;/equation&gt; 元可计算函数。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们定义 &lt;equation&gt;W_y=\lbrace x\in N|\Phi(x,y)\downarrow \rbrace&lt;/equation&gt; ，&lt;br&gt;根据递归可枚举集的定义，每一个 &lt;equation&gt;W_y&lt;/equation&gt; 是一个递归可枚举集。&lt;/p&gt;&lt;p&gt;又因为 &lt;equation&gt;\Phi(x,0),\Phi(x,1),\cdots&lt;/equation&gt; 枚举了所有的可计算函数，&lt;br&gt;而上一篇中我们看到，递归可枚举集是由部分递归函数（即，可计算函数）定义的，&lt;br&gt;一个部分递归函数确定出一个递归可枚举集，&lt;br&gt;所以， &lt;equation&gt;W_0,W_1,\cdots&lt;/equation&gt; &lt;b&gt;枚举了所有的递归可枚举集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;因此，集合 &lt;equation&gt;B&lt;/equation&gt; 是递归可枚举的，当且仅当存在 &lt;equation&gt;y\in N&lt;/equation&gt; ，使得 &lt;equation&gt;B=W_y&lt;/equation&gt; ，&lt;br&gt;称为&lt;b&gt;枚举定理&lt;/b&gt;，这就是“枚举”的含义。&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;K=\lbrace n\in N|n\in W_n\rbrace&lt;/equation&gt; ，&lt;br&gt;则 &lt;equation&gt;K&lt;/equation&gt; 是递归可枚举的，但不是递归的，（证略&lt;br&gt;因此， &lt;equation&gt;\bar{K}&lt;/equation&gt; 不是递归可枚举的，否则 &lt;equation&gt;K&lt;/equation&gt; 就是递归集了。&lt;br&gt;（根据，集合 &lt;equation&gt;B&lt;/equation&gt; 是递归的当且仅当 &lt;equation&gt;B&lt;/equation&gt; 和 &lt;equation&gt;\bar{B}&lt;/equation&gt; 是递归可枚举的，见上一篇&lt;/p&gt;&lt;p&gt;因此，我们找到了一个非递归的递归可枚举集 &lt;equation&gt;K&lt;/equation&gt; ，&lt;br&gt;以及一个非递归可枚举集 &lt;equation&gt;\bar{K}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;停机问题&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2649469b93d96783266c38873773ab78_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;374&quot; data-rawheight=&quot;234&quot;&gt;&lt;p&gt;任给一个程序和一个自然数，问该程序对这个自然数输入的计算是否停止，&lt;br&gt;这个问题称为&lt;b&gt;停机问题&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;我们可以用谓词 &lt;equation&gt;H(x,y)&lt;/equation&gt; 描述这个问题，&lt;br&gt; &lt;equation&gt;H(x,y)&lt;/equation&gt; ，表示以 &lt;equation&gt;y&lt;/equation&gt; 为代码的程序对输入 &lt;equation&gt;x&lt;/equation&gt; 的计算最终停止。&lt;br&gt;那么， &lt;equation&gt;H(x,y)&lt;/equation&gt; 是不可计算的，即，不存在一个程序来计算 &lt;equation&gt;H(x,y)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们来证明一下，假设有一个程序可以计算 &lt;equation&gt;H(x,y)&lt;/equation&gt; ，&lt;br&gt;那么我们就能用它来构造一个新程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; ，它的输入是 &lt;equation&gt;x&lt;/equation&gt; ，&lt;br&gt;这段程序当 &lt;equation&gt;H(x,x)&lt;/equation&gt; 为真时，计算不停止，而当 &lt;equation&gt;H(x,x)&lt;/equation&gt; 为假时，计算停止。&lt;/p&gt;&lt;p&gt;程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 也可以进行编码，假设为 &lt;equation&gt;y_0&lt;/equation&gt; ，现在我们来判断 &lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 为真，意味着编码为 &lt;equation&gt;y_0&lt;/equation&gt; 的程序以 &lt;equation&gt;y_0&lt;/equation&gt; 作为输入最终停止，&lt;br&gt;即程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; ，输入为 &lt;equation&gt;y_0&lt;/equation&gt; 时，最终停止，&lt;br&gt;可是根据 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的定义，此时 &lt;equation&gt;H(x,x)=H(y_0,y_0)&lt;/equation&gt; 为假才会停止，矛盾。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 为假，意味着编码为 &lt;equation&gt;y_0&lt;/equation&gt; 的程序以 &lt;equation&gt;y_0&lt;/equation&gt; 作为参数最终不会停止，&lt;br&gt;即程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; ，输入为 &lt;equation&gt;y_0&lt;/equation&gt; 时，最终不停止，&lt;br&gt;可是根据 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的定义，此时 &lt;equation&gt;H(x,x)=H(y_0,y_0)&lt;/equation&gt; 为真才不会停止，矛盾。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 不能为真也不能为假，矛盾，&lt;br&gt;因此，计算 &lt;equation&gt;H(x,y)&lt;/equation&gt; 的程序&lt;b&gt;不存在&lt;/b&gt;，我们也无法用它来构造程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;可判定性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2b6940df2115ed418d982f28f5263301_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;380&quot;&gt;&lt;p&gt;&lt;b&gt;可判定性问题&lt;/b&gt;，指的是一个询问真或者假的问题是否可以被回答。&lt;br&gt;如果我们总能回答出这个问题是真或者是假，就称该问题是&lt;b&gt;可判定的&lt;/b&gt;，&lt;br&gt;如果我们只能当问题为真的时候确定为真，为假的时候所进行的计算可能不会终止，&lt;br&gt;那么就称该问题是&lt;b&gt;半可判定的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;某元素是否属于一个递归集，是可判定的，&lt;br&gt;某元素是否属于一个递归可枚举集，是半可判定的。&lt;/p&gt;&lt;p&gt;因为，递归集是使用一个递归的全函数定义的，&lt;br&gt;而递归可枚举集是使用第一个部分递归函数定义的，&lt;br&gt;我们无法判断某个部分递归函数，在接受某参数时，是没有定义，还是计算尚未停止。&lt;br&gt;即，判断元素是否属于某递归可枚举集的程序可能永不停机&lt;b&gt;。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了函数的可计算性，通用程序，以及最多有多少个程序，&lt;br&gt;还了解了停机问题和可判定性问题。&lt;/p&gt;&lt;p&gt;这些都是可计算性理论的基础，我们清晰的看到了人类的计算能力，&lt;br&gt;以及用递归所能计算的函数范围，后文中我们开始讨论不动点理论，&lt;br&gt;这同样是一个有趣的话题。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;附&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;配对函数和哥德尔数，是对数偶和有穷数列的一种编码方式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）配对函数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;\langle x,y\rangle=2^x(2y+1)-1&lt;/equation&gt; ，称 &lt;equation&gt;\langle x,y\rangle&lt;/equation&gt; 为&lt;b&gt;配对函数&lt;/b&gt;，它是一个原始递归函数。&lt;/p&gt;&lt;p&gt;任给一个数 &lt;equation&gt;z&lt;/equation&gt; ，存在唯一的一对数 &lt;equation&gt;x&lt;/equation&gt; 和 &lt;equation&gt;y&lt;/equation&gt; ，使得 &lt;equation&gt;\langle x,y\rangle =z&lt;/equation&gt; 。&lt;br&gt; &lt;equation&gt;x&lt;/equation&gt; 是 &lt;equation&gt;z+1&lt;/equation&gt; 含有因子 &lt;equation&gt;2&lt;/equation&gt; 的个数，即使得 &lt;equation&gt;2^t|(z+1)&lt;/equation&gt; 的 &lt;equation&gt;t&lt;/equation&gt; 的最大值。&lt;br&gt; &lt;equation&gt;(z+1)/2^x&lt;/equation&gt; 必为奇数， &lt;equation&gt;y&lt;/equation&gt; 是 &lt;equation&gt;2y+1=(z+1)/2^x&lt;/equation&gt; 的唯一解。&lt;/p&gt;&lt;p&gt;一般的，记 &lt;equation&gt;l(z)=x&lt;/equation&gt; ， &lt;equation&gt;r(z)=y&lt;/equation&gt; ，则 &lt;equation&gt;l(z)&lt;/equation&gt; 和 &lt;equation&gt;r(z)&lt;/equation&gt; 也是原始递归函数。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）哥德尔数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;记 &lt;equation&gt;[a_1,a_2,\cdots ,a_n]=\prod_{i=1}^{n}p_i^{a_i}&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;[a_1,a_2,\cdots ,a_n]&lt;/equation&gt; 称为有穷数列 &lt;equation&gt;(a_1,a_2,\cdots ,a_n)&lt;/equation&gt; 的哥德尔数，其中， &lt;equation&gt;p_i&lt;/equation&gt; 是第 &lt;equation&gt;i&lt;/equation&gt; 个素数。&lt;/p&gt;&lt;p&gt;例如，[ &lt;equation&gt;[2,0,1,3]=2^2\cdot 3^0\cdot 5^1\cdot 7^3=6860&lt;/equation&gt; 。&lt;br&gt;对于每一个固定的 &lt;equation&gt;n&lt;/equation&gt; ， &lt;equation&gt;[a_1,a_2,\cdots ,a_n]&lt;/equation&gt; 是原始递归函数，并且这种编码具有唯一性。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%85%8D%E5%AF%B9%E5%87%BD%E6%95%B0&quot;&gt;配对函数&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E6%95%B0&quot;&gt;哥德尔数&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%95%B8%E9%9B%86&quot;&gt;可数集&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%88%A4%E5%AE%9A%E6%80%A7&quot;&gt;可判定性&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E5%BA%B7%E6%89%98%E5%B0%94%E5%AE%9A%E7%90%86&quot;&gt;康托尔定理&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-14-34484014</guid>
<pubDate>Wed, 14 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（五）：递归集与递归可枚举集</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-13-34447250.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34447250&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文中我们讨论了全函数和部分函数，以及计算的可终止性。&lt;br&gt;本文我们从数论函数开始，给原始递归函数集增加一种新的运算，得到了一个更大的集合。&lt;br&gt;然后根据递归函数，我们可以定义递归集和递归可枚举集，&lt;br&gt;为以后讨论可计算性与可判定性打好基础。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;数论函数&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-00ebc8699bbcc75935897546101678be_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;214&quot;&gt;&lt;p&gt;自然数集一般记为 &lt;equation&gt;N=\lbrace 0,1,2,\cdots \rbrace&lt;/equation&gt; ，那么 &lt;equation&gt;n&lt;/equation&gt; 个自然数集的笛卡尔积记为 &lt;equation&gt;N^n&lt;/equation&gt; ，&lt;br&gt;于是，我们称集合 &lt;equation&gt;N^n&lt;/equation&gt; 到 &lt;equation&gt;N&lt;/equation&gt; 的部分函数为&lt;b&gt;&lt;equation&gt;n&lt;/equation&gt; 元部分数论函数&lt;/b&gt;。&lt;br&gt;作为数论函数， &lt;equation&gt;2x&lt;/equation&gt; 是一个全函数，而 &lt;equation&gt;x/2&lt;/equation&gt; ， &lt;equation&gt;x-y&lt;/equation&gt; ， &lt;equation&gt;\sqrt{x}&lt;/equation&gt; 只是部分函数，&lt;br&gt;它们的计算结果， &lt;equation&gt;3/2&lt;/equation&gt; ， &lt;equation&gt;4-6&lt;/equation&gt; ， &lt;equation&gt;\sqrt{5}&lt;/equation&gt; 都不在 &lt;equation&gt;N&lt;/equation&gt; 中，&lt;br&gt;于是相应定义域中的点可视为没有定义。&lt;/p&gt;&lt;p&gt;为什么讨论数论函数呢，其一是因为它是一个典型数学的问题，&lt;br&gt;另外一点，则是因为我们经常把其他数学问题转换成数论问题，例如，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E6%95%B0&quot;&gt;哥德尔编码&lt;/a&gt;。&lt;br&gt;本文中，使用数论函数，可以简化我们的描述方式。&lt;/p&gt;&lt;p&gt;一个&lt;b&gt;谓词&lt;/b&gt;，指的是返回布尔值的函数，&lt;br&gt;我们还可以将谓词看做值域为 &lt;equation&gt;\lbrace 0,1\rbrace&lt;/equation&gt; 的一个数论函数。&lt;br&gt; &lt;equation&gt;0&lt;/equation&gt; 代表&lt;code class=&quot;inline&quot;&gt;True&lt;/code&gt;， &lt;equation&gt;1&lt;/equation&gt; 代表&lt;code class=&quot;inline&quot;&gt;False&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;极小化算子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-cfab5b6b86d286530c4f9ea57cb8905f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;235&quot; data-rawheight=&quot;214&quot;&gt;&lt;p&gt;在前一篇中，我们从三个初始函数出发，&lt;br&gt;通过合成运算和原始递归运算，得到了原始递归函数集，&lt;br&gt;递归函数集是相对于这两种运算封闭的。&lt;/p&gt;&lt;p&gt;然而，这样定义的原始递归函数，并不能包括所有的数论函数，&lt;br&gt;一个典型的例子就是，&lt;a href=&quot;https://zh.wikipedia.org/zh/%E9%98%BF%E5%85%8B%E6%9B%BC%E5%87%BD%E6%95%B8&quot;&gt;阿克曼函数&lt;/a&gt;，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;ackermann :: Int -&amp;gt; Int -&amp;gt; Int 
ackermann 0 x = x+1
ackermann k 0 = ackermann (k-1) 1
ackermann k x = ackermann (k-1) $ ackermann k x-1&lt;/code&gt;&lt;p&gt;&lt;b&gt;它并不是一个原始递归函数&lt;/b&gt;，（证略&lt;br&gt;因此原始递归函数集并不足以表示计算机程序中的所有函数。&lt;/p&gt;&lt;p&gt;为此，我们需要对原始递归函数集进行扩充，我们定义一个新的运算，称为&lt;b&gt;极小化运算&lt;/b&gt;，&lt;br&gt;设 &lt;equation&gt;P(x_1,\cdots ,x_n,t)&lt;/equation&gt; 是一个谓词，令 &lt;equation&gt;f(x_1,\cdots ,x_n)=min\ P(x_1,\cdots ,x_n,t)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;f(x_1,\cdots ,x_n)&lt;/equation&gt; 的值，或者是使 &lt;equation&gt;P(x_1,\cdots ,x_n,t)&lt;/equation&gt; 为真的最小 &lt;equation&gt;t&lt;/equation&gt; 值，&lt;br&gt;或者无定义，此时不存在 &lt;equation&gt;t&lt;/equation&gt; 使得 &lt;equation&gt;P(x_1,\cdots ,x_n,t)&lt;/equation&gt; 为真。&lt;br&gt;这样通过 &lt;equation&gt;min&lt;/equation&gt; 得到 &lt;equation&gt;f(x_1,\cdots ,x_n)&lt;/equation&gt; 的过程称为&lt;b&gt;极小化运算&lt;/b&gt;，&lt;br&gt;也称部分函数 &lt;equation&gt;f(x_1,\cdots ,x_n)&lt;/equation&gt; 是由谓词经过极小化运算得到的。&lt;/p&gt;&lt;p&gt;以上我们给谓词定义了极小化运算，现在我们将极小化运算推广到一般的函数上面，&lt;br&gt;设 &lt;equation&gt;g(x_1,\cdots ,x_n,t)&lt;/equation&gt; 是一个 &lt;equation&gt;n+1&lt;/equation&gt; 元函数，令&lt;br&gt; &lt;equation&gt;f(x_1,\cdots ,x_n)=min\lbrace g(x_1,\cdots ,x_n,t)=0\rbrace&lt;/equation&gt; &lt;br&gt;则称部分函数 &lt;equation&gt;f(x_1,\cdots ,x_n)&lt;/equation&gt; 是由函数 &lt;equation&gt;g(x_1,\cdots ,x_n,t)&lt;/equation&gt; 经过极小化运算得到的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;递归函数集&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;和定义原始递归函数集一样，我们从以下三个初始函数出发，&lt;br&gt;（1）零函数 &lt;equation&gt;n(x)=0&lt;/equation&gt; &lt;br&gt;（2）后继函数 &lt;equation&gt;s(x)=x+1&lt;/equation&gt; &lt;br&gt;（3）投影函数 &lt;equation&gt;u^n_i(x_1,\cdots ,x_n)=x_i&lt;/equation&gt; ， &lt;equation&gt;1\leqslant i\leqslant n&lt;/equation&gt; &lt;br&gt;由初始函数，经过有限次合成运算，原始递归运算，以及极小化运算，&lt;br&gt;得到的函数称为&lt;b&gt;递归函数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;递归函数并不一定是全函数，因为极小化运算可能会导致结果函数在某些点无定义，&lt;br&gt;递归的部分函数称为&lt;b&gt;部分递归函数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;可以证明阿克曼函数是递归函数，但不是原始递归函数，&lt;br&gt;因此，原始递归函数集是递归函数集的真子集。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;递归可枚举集&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-707e7082ba20ea7f7b155d8bb50da75a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;518&quot; data-rawheight=&quot;353&quot;&gt;&lt;p&gt;在具体实践中，我们经常会遇到这样的问题，&lt;br&gt;给定一个元素，我们需要判断这个元素是否属于某个集合。&lt;br&gt;这种问题，称为集合的成员资格问题。&lt;/p&gt;&lt;p&gt;沿用这一思路，我们可以使用一个谓词 &lt;equation&gt;\chi _B&lt;/equation&gt; 来定义相应的集合 &lt;equation&gt;B\subseteq N&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;B=\lbrace x\in N|\chi _B(x)\rbrace&lt;/equation&gt; &lt;br&gt;谓词 &lt;equation&gt;\chi _B(x)&lt;/equation&gt; 为真，则 &lt;equation&gt;x\in B&lt;/equation&gt; 。&lt;br&gt;这个谓词 &lt;equation&gt;\chi _B(x)&lt;/equation&gt; ，通常称为集合 &lt;equation&gt;B&lt;/equation&gt; 的&lt;b&gt;特征函数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;如果特征函数 &lt;equation&gt;\chi _B&lt;/equation&gt; 是一个递归的全函数，&lt;br&gt;则我们总是可以判断 &lt;equation&gt;\chi _B(x)&lt;/equation&gt; 等于 &lt;equation&gt;0&lt;/equation&gt; 还是 &lt;equation&gt;1&lt;/equation&gt; ，&lt;br&gt;这样的集合 &lt;equation&gt;B&lt;/equation&gt; 称为&lt;b&gt;递归集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;如果存在部分递归函数 &lt;equation&gt;g&lt;/equation&gt; ，使得 &lt;equation&gt;B=\lbrace x\in N|g(x)\downarrow \rbrace&lt;/equation&gt; ，&lt;br&gt;即， &lt;equation&gt;x\in B&lt;/equation&gt; 当且仅当 &lt;equation&gt;g&lt;/equation&gt; 在 &lt;equation&gt;x&lt;/equation&gt; 处有定义，&lt;br&gt;则称集合 &lt;equation&gt;B&lt;/equation&gt; 是一个&lt;b&gt;递归可枚举集&lt;/b&gt;。&lt;br&gt;每一个部分递归函数，都确定出一个递归可枚举集。&lt;/p&gt;&lt;p&gt;因此，对于每一个自然数 &lt;equation&gt;x\in N&lt;/equation&gt; ，&lt;br&gt;我们总是可以通过递归集 &lt;equation&gt;B&lt;/equation&gt; 的特征函数 &lt;equation&gt;\chi _B&lt;/equation&gt; ，来判断 &lt;equation&gt;x&lt;/equation&gt; 是否 &lt;equation&gt;B&lt;/equation&gt; 的成员。&lt;br&gt;而对于递归可枚举集，就不容乐观了，&lt;br&gt;如果某个自然数 &lt;equation&gt;x\in N&lt;/equation&gt; 是 &lt;equation&gt;B&lt;/equation&gt; 的成员，那么我们可以断定这件事，因为 &lt;equation&gt;g(x)&lt;/equation&gt; 有定义，&lt;br&gt;但是如果某个自然数 &lt;equation&gt;y\in N&lt;/equation&gt; 不是 &lt;equation&gt;B&lt;/equation&gt; 的成员，我们就不能确定，因为这时候 &lt;equation&gt;g(x)&lt;/equation&gt; 无定义。&lt;br&gt;（ &lt;equation&gt;g(x)&lt;/equation&gt; 无定义，则它对应的图灵机不停机，后文我们详细讨论&lt;/p&gt;&lt;p&gt;因此，集合 &lt;equation&gt;B&lt;/equation&gt; 是递归的当且仅当 &lt;equation&gt;B&lt;/equation&gt; 和 &lt;equation&gt;\bar{B}&lt;/equation&gt; 是递归可枚举的，&lt;br&gt;其中 &lt;equation&gt;\bar{B}&lt;/equation&gt; 为 &lt;equation&gt;B&lt;/equation&gt; 的补集。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了数论函数，递归函数集，然后用递归函数分别定义了递归集和递归可枚举集，&lt;br&gt;可是为什么递归可枚举集是“可枚举”的呢？&lt;/p&gt;&lt;p&gt;是因为每一个递归可枚举集可以一一对应一个自然数，这是怎样做到的呢？&lt;br&gt;这需要我们理解总共有多少个可能的程序，以及什么是通用程序。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92%E9%9B%86%E5%90%88&quot;&gt;递归集&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92%E5%8F%AF%E6%9E%9A%E4%B8%BE%E9%9B%86%E5%90%88&quot;&gt;递归可枚举集&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-13-34447250</guid>
<pubDate>Tue, 13 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（四）：全函数与计算的可终止性</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-12-34425726.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34425726&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9488c88c2a5273ccfd75c83a424585ca_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;300&quot; data-rawheight=&quot;300&quot;&gt;&lt;p&gt;上文我们讨论了集合上的关系，还讨论了数学归纳法的一种普遍形式，称为良基归纳法，&lt;br&gt;它建立在集合上的良基关系之上。&lt;/p&gt;&lt;p&gt;本文开始讨论函数，我们将回顾函数的定义，&lt;br&gt;然后解释什么是全函数（total function），什么是部分函数（partial function）。&lt;/p&gt;&lt;p&gt;我们会看到，在证明一个递归函数是全函数时，&lt;br&gt;良基归纳法起到了重要作用。&lt;/p&gt;&lt;p&gt;在分析学中，人们似乎很少关心函数的完全性，&lt;br&gt;只关心它的连续性，可导性，可微性与可积性，等等。&lt;br&gt;而在计算机科学领域中，人们更在意计算的可终止性，&lt;br&gt;因此一个函数在某个点是否有定义将经常被提及。&lt;/p&gt;&lt;p&gt;程序中定义的函数，往往对应于某个集合上的数学函数，&lt;br&gt;为了描述程序的非终止性，就得扩充这个数学函数的定义域和值域。&lt;br&gt;为了理解这些事情，我们先要从函数的定义开始。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;函数&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;集合 &lt;equation&gt;A,B&lt;/equation&gt; 上的关系，是笛卡尔积 &lt;equation&gt;A\times B&lt;/equation&gt; 的一个子集。&lt;/p&gt;&lt;p&gt;而&lt;b&gt;函数&lt;/b&gt; &lt;equation&gt;f:A\rightarrow B&lt;/equation&gt; ，则是集合 &lt;equation&gt;A,B&lt;/equation&gt; 上的一种特殊关系，&lt;br&gt;它要求 &lt;equation&gt;A&lt;/equation&gt; 中的每一个元素，都有 &lt;equation&gt;B&lt;/equation&gt; 中&lt;b&gt;唯一确定的&lt;/b&gt;元素与之对应。&lt;br&gt;其中，集合 &lt;equation&gt;A&lt;/equation&gt; 称为函数 &lt;equation&gt;f&lt;/equation&gt; 的&lt;b&gt;定义域&lt;/b&gt;，集合 &lt;equation&gt;B&lt;/equation&gt; 称为函数的&lt;b&gt;值域&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;函数是我们熟悉的概念，这里只是提到了它本质上是集合上的一个关系。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）部分函数（partial function）&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-874ea6c6827de852cd55a96727978878_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;200&quot; data-rawheight=&quot;200&quot;&gt;&lt;p&gt;如果 &lt;equation&gt;f&lt;/equation&gt; 是从 &lt;equation&gt;A&lt;/equation&gt; 到 &lt;equation&gt;B&lt;/equation&gt; 的二元关系，且 &lt;equation&gt;\forall a\in A&lt;/equation&gt; ， &lt;equation&gt;f(a)=\varnothing&lt;/equation&gt; 或 &lt;equation&gt;\lbrace b\rbrace&lt;/equation&gt; ，&lt;br&gt;则称 &lt;equation&gt;f&lt;/equation&gt; 是从 &lt;equation&gt;A&lt;/equation&gt; 到 &lt;equation&gt;B&lt;/equation&gt; 的&lt;b&gt;部分函数&lt;/b&gt;，或 &lt;equation&gt;A&lt;/equation&gt; 上的部分函数。&lt;/p&gt;&lt;p&gt;其中，如果 &lt;equation&gt;f(a)=\lbrace b\rbrace&lt;/equation&gt; ，则称 &lt;equation&gt;f(a)&lt;/equation&gt; &lt;b&gt;有定义&lt;/b&gt;，记为 &lt;equation&gt;f(a)\downarrow&lt;/equation&gt; ，&lt;br&gt;也称 &lt;equation&gt;b&lt;/equation&gt; 为 &lt;equation&gt;f&lt;/equation&gt; 在 &lt;equation&gt;a&lt;/equation&gt; 点的函数值，记为 &lt;equation&gt;f(a)=b&lt;/equation&gt; 。&lt;br&gt;如果 &lt;equation&gt;f(a)=\varnothing&lt;/equation&gt; ，则称 &lt;equation&gt;f(a)&lt;/equation&gt;&lt;b&gt; 无定义&lt;/b&gt;，记为 &lt;equation&gt;f(a)\uparrow&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）全函数（total function）&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98cba4b9c4f902aab70190f355394426_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;200&quot; data-rawheight=&quot;200&quot;&gt;&lt;p&gt;如果 &lt;equation&gt;\forall a\in A&lt;/equation&gt; 都有 &lt;equation&gt;f(a)\downarrow&lt;/equation&gt; ，则称 &lt;equation&gt;f&lt;/equation&gt; 是 &lt;equation&gt;A&lt;/equation&gt; 上的全函数，&lt;br&gt;此时，可以记为 &lt;equation&gt;f:A\rightarrow B&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;可见，我们熟悉的函数，指的是全函数。&lt;br&gt;值得注意的是，部分函数的定义已经包含了我们学过的“函数”的定义，&lt;br&gt;后文中，我们提到的“函数”如果不强调它的完全性的话，都泛指部分函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;非终止性&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;部分函数在计算机科学中是非常重要的，&lt;br&gt;因为对于每一个 &lt;equation&gt;a\in A&lt;/equation&gt; ，一个算法可以表示为，计算出集合 &lt;equation&gt;B&lt;/equation&gt; 中与之对应元素的过程，&lt;br&gt;这个算法可能对于某些值 &lt;equation&gt;a\in A&lt;/equation&gt; 不会终止，而这种情况是很常见的。&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;f :: Int -&amp;gt; Int
f 1 = 1
f n = n + f(n-2)&lt;/code&gt;&lt;p&gt;这样定义的函数&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;，对应了数学上的一个部分函数 &lt;equation&gt;f&lt;/equation&gt; ，它只在某些情况下有意义，&lt;br&gt;只有当&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;是奇数时，我们才能得到终止性的结果。&lt;br&gt;而当&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;是偶数时，算法会无限的递归下去，直到堆栈溢出。&lt;/p&gt;&lt;p&gt;因此，将&lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt;解释为整数集 &lt;equation&gt;N&lt;/equation&gt; ，将&lt;code class=&quot;inline&quot;&gt;f :: Int -&amp;gt; Int&lt;/code&gt;解释为整数集上的函数，&lt;br&gt;似乎是有问题的，因为， &lt;equation&gt;f(2)&lt;/equation&gt; 并不是一个整数，它的计算不能终止。&lt;/p&gt;&lt;p&gt;为了描述非终止性，就需要对整数集进行扩充，&lt;br&gt;我们给整数集加上一个特殊元素“ &lt;equation&gt;\perp&lt;/equation&gt; ”，称为&lt;b&gt;bottom&lt;/b&gt;，来表示非终止性，&lt;br&gt;而将&lt;code class=&quot;inline&quot;&gt;f :: Int -&amp;gt; Int&lt;/code&gt;解释为集合 &lt;equation&gt;N\cup \lbrace \perp \rbrace&lt;/equation&gt; 上的一个数学函数。&lt;/p&gt;&lt;p&gt;像这种通过构造表达程序含义的数学对象，来对程序进行分析的方法，来自&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8C%87%E7%A7%B0%E8%AF%AD%E4%B9%89&quot;&gt;指称语义学&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;指称语义中，人们会区分函数的严格性，一个函数称为&lt;b&gt;严格的&lt;/b&gt;（strict），&lt;br&gt;如果接受一个非终止的输入表达式，函数的计算仍然不会终止，即， &lt;equation&gt;f(\perp )=\perp&lt;/equation&gt; 。&lt;br&gt;否则，称函数为&lt;b&gt;不严格的&lt;/b&gt;（non-strict）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;原始递归函数&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fcac4612d17b9df75820b2d778789687_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;271&quot; data-rawheight=&quot;186&quot;&gt;&lt;p&gt;我们看到在程序中使用递归，可能会导致非终止性的计算，而有些递归又不会。&lt;br&gt;这是为什么呢？&lt;/p&gt;&lt;p&gt;我们可以从递归函数论中找到一些线索。&lt;br&gt;递归函数论是和图灵机以及 &lt;equation&gt;\lambda&lt;/equation&gt; 演算相等价的计算模型，它从另一个角度刻画了可计算性。&lt;br&gt;可计算性是一个有趣的话题，后续文章中，我们会详细讨论。&lt;/p&gt;&lt;p&gt;在递归函数论中，人们把函数划分为了3个层次，&lt;br&gt;原始递归函数，递归函数，和其他的不能用递归函数表示的“函数”。&lt;br&gt;这些函数集合的范围越来越大。&lt;/p&gt;&lt;p&gt;本文我们先介绍原始递归函数，&lt;br&gt;为此，我们需要先定义两种运算。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）合成运算&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;f&lt;/equation&gt; 是 &lt;equation&gt;k&lt;/equation&gt; 元部分函数， &lt;equation&gt;g_1,g_2,\cdots ,g_k&lt;/equation&gt; 是 &lt;equation&gt;k&lt;/equation&gt; 个 &lt;equation&gt;n&lt;/equation&gt; 元部分函数，令，&lt;br&gt; &lt;equation&gt;h(x_1,\cdots ,x_n)=f(g_1(x_1,\cdots ,x_n),\cdots ,g_k(x_1,\cdots ,x_n))&lt;/equation&gt; &lt;br&gt;则称 &lt;equation&gt;h&lt;/equation&gt; 是由 &lt;equation&gt;f&lt;/equation&gt; 和 &lt;equation&gt;g_1,g_2,\cdots ,g_k&lt;/equation&gt; ，经过&lt;b&gt;合成运算&lt;/b&gt;得到的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）原始递归运算&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;f&lt;/equation&gt; 是一个 &lt;equation&gt;n&lt;/equation&gt; 元全函数， &lt;equation&gt;g&lt;/equation&gt; 是 &lt;equation&gt;n+2&lt;/equation&gt; 元全函数，令，&lt;br&gt; &lt;equation&gt;h(x_1,\cdots ,x_n,0)=f(x_1,\cdots ,x_n)&lt;/equation&gt; &lt;br&gt; &lt;equation&gt;h(x_1,\cdots ,x_n,t+1)=g(t,h(x_1,\cdots ,x_n,t),x_1,\cdots ,x_n)&lt;/equation&gt; &lt;br&gt;则称 &lt;equation&gt;h&lt;/equation&gt; 是由 &lt;equation&gt;f&lt;/equation&gt; 和 &lt;equation&gt;g&lt;/equation&gt; 经过&lt;b&gt;原始递归运算&lt;/b&gt;得到的。&lt;/p&gt;&lt;p&gt;于是，我们就可以定义原始递归函数了。&lt;/p&gt;&lt;p&gt;设&lt;b&gt;初始函数&lt;/b&gt;包括，&lt;br&gt;（1）零函数 &lt;equation&gt;n(x)=0&lt;/equation&gt; &lt;br&gt;（2）后继函数 &lt;equation&gt;s(x)=x+1&lt;/equation&gt; &lt;br&gt;（3）投影函数 &lt;equation&gt;u^n_i(x_1,\cdots ,x_n)=x_i&lt;/equation&gt; ， &lt;equation&gt;1\leqslant i\leqslant n&lt;/equation&gt; &lt;br&gt;则由初始函数经过有限次合成运算和原始递归运算得到的函数，称为&lt;b&gt;原始递归函数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;原始递归函数有以下这些性质：&lt;br&gt;由原始递归函数经过合成或原始递归得到的函数仍为原始递归函数，&lt;br&gt;因此，原始递归函数的集合在合成与原始递归运算下是封闭的。&lt;/p&gt;&lt;p&gt;此外，每一个原始递归函数都是全函数。&lt;br&gt;这是因为合成运算虽然是在部分函数上定义的，&lt;br&gt;但是如果 &lt;equation&gt;f&lt;/equation&gt; 和 &lt;equation&gt;g_1,g_2,\cdots ,g_k&lt;/equation&gt; 是全函数，那么 &lt;equation&gt;h&lt;/equation&gt; 也一定是全函数。&lt;/p&gt;&lt;p&gt;另一方面，在进行原始递归运算时，如果 &lt;equation&gt;f&lt;/equation&gt; 和 &lt;equation&gt;g&lt;/equation&gt; 是全函数，则 &lt;equation&gt;h&lt;/equation&gt; 也一定是全函数，&lt;br&gt;这是因为原始递归运算在 &lt;equation&gt;h&lt;/equation&gt; 的参数集上的定义了一个良基关系，&lt;br&gt;由良基归纳法可证， &lt;equation&gt;h&lt;/equation&gt; 是全函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a3866f274319c289a42997f7331f9611_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;259&quot; data-rawheight=&quot;246&quot;&gt;&lt;p&gt;本文介绍了全函数与部分函数，以及计算可终止性相关的概念，&lt;br&gt;我们对程序中函数的指称，进行了定义域和值域的扩充，&lt;br&gt;随后，我们进一步了解了原始递归函数，以及它的完全性，良基归纳法起到了关键作用。&lt;/p&gt;&lt;p&gt;下文，我们将深入到可计算性理论，&lt;br&gt;讨论部分可计算函数和可计算函数的区别，讨论递归函数与原始递归函数的关系，&lt;br&gt;引出递归可枚举集这个重要的概念。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Function_(mathematics)&quot;&gt;function (mathematics)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Strict_function&quot;&gt;strict function&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1310925/&quot;&gt;可计算性与计算复杂性导引&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-12-34425726</guid>
<pubDate>Mon, 12 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（三）：归纳原理</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-11-34287668.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34287668&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;自然数归纳法&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2dc9c1daf53982ff9dd9cd7829af8cef_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;534&quot; data-rawheight=&quot;318&quot;&gt;&lt;p&gt;自然数归纳法，是一种数学证明方法，&lt;br&gt;通常被用于证明某个给定命题在整个（或者局部）自然数范围内成立。&lt;br&gt;它可以用一个有限的方式写出一个无限的证明。&lt;/p&gt;&lt;p&gt;后续文章中我们会看到，&lt;br&gt;这种用有限表示无限的方法，其实是有局限性的，并不能用来解决所有的问题，&lt;br&gt;它能处理的只是无限中的一个子集罢了。&lt;/p&gt;&lt;p&gt;自然数归纳法，我们可以描述如下：&lt;br&gt;为证明对每一个自然数 &lt;equation&gt;n&lt;/equation&gt; ，命题 &lt;equation&gt;P(n)&lt;/equation&gt; 为真，只需要证明两件事，&lt;br&gt;（1）对于自然数 &lt;equation&gt;1&lt;/equation&gt; ，命题 &lt;equation&gt;P(1)&lt;/equation&gt; 为真&lt;br&gt;（2）如果对于自然数 &lt;equation&gt;m&lt;/equation&gt; ，命题 &lt;equation&gt;P(m)&lt;/equation&gt; 为真，那么对于自然数 &lt;equation&gt;m+1&lt;/equation&gt; ，命题 &lt;equation&gt;P(m+1)&lt;/equation&gt; 也为真&lt;/p&gt;&lt;p&gt;其中，第(1)条称为&lt;b&gt;起始条件&lt;/b&gt;，第(2)条称为&lt;b&gt;递推条件&lt;/b&gt;，或者称为&lt;b&gt;归纳步骤&lt;/b&gt;。&lt;br&gt;第(2)条中，为了证明 &lt;equation&gt;P(m+1)&lt;/equation&gt; 而假设的 &lt;equation&gt;P(m)&lt;/equation&gt; ，称为&lt;b&gt;归纳假设&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;这似乎是很显然的事情，我们可以在一张无限长的纸带开头写上初始条件 &lt;equation&gt;P(1)&lt;/equation&gt; ，&lt;br&gt;接着根据递推条件，由 &lt;equation&gt;P(1)&lt;/equation&gt; 我们可以证明 &lt;equation&gt;P(2)&lt;/equation&gt; 成立，&lt;br&gt;重复这种思想，我们可以由 &lt;equation&gt;P(2)&lt;/equation&gt; 证明 &lt;equation&gt;P(3)&lt;/equation&gt; 成立，如此不断的进行下去，&lt;br&gt;最终，对于每个自然数 &lt;equation&gt;n&lt;/equation&gt; ，我们都能证明 &lt;equation&gt;P(n)&lt;/equation&gt; 成立。&lt;/p&gt;&lt;p&gt;但是，这样并不算是一个有效的证明。&lt;br&gt;要证明自然数归纳法的正确性，我们还需要补充一些集合论方面的知识。&lt;br&gt;然而，在此之前，我们还是先来看自然数归纳法的一个例子吧。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;例子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4a82c1a5c4a25cf84243be45f3986796_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;272&quot;&gt;&lt;p&gt;在上一篇，我们在定义递归函数&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的时候，&lt;br&gt;先找到了“递推式”，再找到了“终止条件”，然后写出了&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的定义：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact :: Int -&amp;gt; Int
fact 1 = 1
fact n = n * fact (n-1)&lt;/code&gt;&lt;p&gt;我们还提到，有一个步骤是必不可少的，&lt;br&gt;那就是证明&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的正确性，即证明这样定义的&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;就是阶乘函数 &lt;equation&gt;f(n)=n!&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;现在，我们正好可以用自然数归纳法来证明它。&lt;br&gt;我们假设命题 &lt;equation&gt;P(n)&lt;/equation&gt; 为：&lt;code class=&quot;inline&quot;&gt;fact n&lt;/code&gt;的值为 &lt;equation&gt;n!&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;（1）对于自然数 &lt;equation&gt;1&lt;/equation&gt; ，命题 &lt;equation&gt;P(1)&lt;/equation&gt; ：&lt;code class=&quot;inline&quot;&gt;fact 1&lt;/code&gt;的值为 &lt;equation&gt;1!=1&lt;/equation&gt; ，成立&lt;br&gt;（2）假设对于自然数 &lt;equation&gt;m&lt;/equation&gt; ，命题 &lt;equation&gt;P(m)&lt;/equation&gt; ：&lt;code class=&quot;inline&quot;&gt;fact m&lt;/code&gt;的值为 &lt;equation&gt;m!&lt;/equation&gt; ，成立&lt;/p&gt;&lt;p&gt;那么，我们可以得到&lt;code class=&quot;inline&quot;&gt;fact (m+1) = (m+1) * fact m&lt;/code&gt;，值为 &lt;equation&gt;(m+1)*m!=(m+1)!&lt;/equation&gt; ，也成立。&lt;/p&gt;&lt;p&gt;所以，对于任意自然数（ &lt;equation&gt;n\geqslant 1&lt;/equation&gt; ），&lt;code class=&quot;inline&quot;&gt;fact n&lt;/code&gt;的值就是 &lt;equation&gt;n!&lt;/equation&gt; 。&lt;br&gt;于是，我们证明了&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;就是阶乘函数 &lt;equation&gt;f(n)=n!&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;自然数归纳法还有另外一种等价形式，&lt;br&gt;如果要证明 &lt;equation&gt;P(n)&lt;/equation&gt; 对每一个自然数 &lt;equation&gt;n&lt;/equation&gt; 为真，&lt;br&gt;只要证明对于任意自然数 &lt;equation&gt;m&lt;/equation&gt; ，如果 &lt;equation&gt;P(i)&lt;/equation&gt; 当 &lt;equation&gt;i&amp;lt;m&lt;/equation&gt; 为真，那么 &lt;equation&gt;P(m)&lt;/equation&gt; 也为真。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;集合上的关系&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a9ac2524ee3db1b8d2e19a941ffcfda5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;210&quot; data-rawheight=&quot;179&quot;&gt;&lt;p&gt;关系是一个日常生活用语，例如，“同学关系”，“我们的关系很好”之类的。&lt;br&gt;然而，它也是一个集合论中的概念，这给我们带来了很多困扰。&lt;br&gt;为了避免歧义，本文中从这里开始，我们开始谈论数学，我们要对集合上的“关系”进行定义。&lt;/p&gt;&lt;p&gt;直观的说，集合 &lt;equation&gt;A&lt;/equation&gt; 的元素和集合 &lt;equation&gt;B&lt;/equation&gt; 的元素之间的&lt;b&gt;关系&lt;/b&gt;是一个二元性质 &lt;equation&gt;R&lt;/equation&gt; ，&lt;br&gt;使得对于每个 &lt;equation&gt;a\in A&lt;/equation&gt; 和 &lt;equation&gt;b\in B&lt;/equation&gt; 而言， &lt;equation&gt;R(a,b)&lt;/equation&gt; 要么为真，要么为假。&lt;/p&gt;&lt;p&gt;关系通常表示为一个集合，它是笛卡尔积的子集，即，&lt;br&gt;集合 &lt;equation&gt;A&lt;/equation&gt; 和集合 &lt;equation&gt;B&lt;/equation&gt; 之间的关系 &lt;equation&gt;R&lt;/equation&gt; 是它们笛卡尔积的一个子集 &lt;equation&gt;R\subseteq A\times B&lt;/equation&gt; 。&lt;br&gt;如果序对 &lt;equation&gt;(a,b)&lt;/equation&gt; 属于子集 &lt;equation&gt;R&lt;/equation&gt; ，则认为 &lt;equation&gt;a&lt;/equation&gt; 与 &lt;equation&gt;b&lt;/equation&gt; 之间的关系为真，&lt;br&gt;否则认为 &lt;equation&gt;a&lt;/equation&gt; 与 &lt;equation&gt;b&lt;/equation&gt; 之间的关系为假。&lt;/p&gt;&lt;p&gt;通常关系直接描述为 &lt;equation&gt;R(a,b)&lt;/equation&gt; ，或者 &lt;equation&gt;aRb&lt;/equation&gt; ，而不用 &lt;equation&gt;(a,b)\in R&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;除了二元关系之外，对任何正整数 &lt;equation&gt;k&lt;/equation&gt; ，还可以定义&lt;b&gt;&lt;equation&gt;k&lt;/equation&gt; 元关系&lt;/b&gt;。&lt;br&gt;如果 &lt;equation&gt;A_1,\cdots,A_k&lt;/equation&gt; 为集合，则在 &lt;equation&gt;A_1,\cdots,A_k&lt;/equation&gt; 上的 &lt;equation&gt;k&lt;/equation&gt; 元关系，&lt;br&gt;是笛卡尔积 &lt;equation&gt;A_1\times \cdots \times A_k&lt;/equation&gt; 的一个子集。&lt;/p&gt;&lt;p&gt;某个集合上的二元关系有很多性质，例如自反性，对称性，反对称性，传递性。&lt;br&gt;一个关系 &lt;equation&gt;R\subseteq A\times A&lt;/equation&gt; 是&lt;b&gt;自反的&lt;/b&gt;，如果 &lt;equation&gt;R(a,a)&lt;/equation&gt; 对于所有的 &lt;equation&gt;a\in A&lt;/equation&gt; 成立；&lt;br&gt;是&lt;b&gt;对称的&lt;/b&gt;，如果 &lt;equation&gt;R(a,b)&lt;/equation&gt; 就有 &lt;equation&gt;R(b,a)&lt;/equation&gt; ，对于所有的 &lt;equation&gt;a,b\in A&lt;/equation&gt; 都成立；&lt;br&gt;是&lt;b&gt;反对称的&lt;/b&gt;，如果 &lt;equation&gt;R(a,b)&lt;/equation&gt; 且 &lt;equation&gt;R(b,a)&lt;/equation&gt; 则 &lt;equation&gt;a,b&lt;/equation&gt; 是同一个元素，对于所有的 &lt;equation&gt;a,b\in A&lt;/equation&gt; 都成立；&lt;br&gt;是&lt;b&gt;传递的&lt;/b&gt;，如果 &lt;equation&gt;R(a,b)&lt;/equation&gt; 和 &lt;equation&gt;R(b,c)&lt;/equation&gt; 能推出 &lt;equation&gt;R(a,c)&lt;/equation&gt; ，对于所有的 &lt;equation&gt;a,b,c\in A&lt;/equation&gt; 都成立。&lt;br&gt;（注意，反对称性不是对称性的否定。&lt;/p&gt;&lt;p&gt;&lt;b&gt;等价关系&lt;/b&gt;是同时具有自反性，对称性和传递性的关系。&lt;br&gt;&lt;b&gt;偏序关系&lt;/b&gt;是具有自反性，反对称性和传递性的关系。&lt;br&gt;等价关系的一个例子就是相等性，相等性关系 &lt;equation&gt;R(a,b)&lt;/equation&gt; 当且仅当 &lt;equation&gt;a,b&lt;/equation&gt; 是同一个元素。&lt;br&gt;偏序关系，例如通常的序关系 &lt;equation&gt;R\subseteq N\times N&lt;/equation&gt; ， &lt;equation&gt;R(a,b)&lt;/equation&gt; 当且仅当 &lt;equation&gt;a\leqslant b&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;良基关系&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-143831fefb5a8e05dbb75c4a045c419f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;408&quot; data-rawheight=&quot;292&quot;&gt;&lt;p&gt;归纳法有各种各样的形式，自然数归纳法只是其中的一种应用，&lt;br&gt;在数理逻辑和形式语言理论中，用的最多的是结构归纳法，在树形结构上进行归纳，后续文章中我们会提到。&lt;/p&gt;&lt;p&gt;人们总结了各种归纳法的共性，提出了&lt;b&gt;良基关系&lt;/b&gt;的概念，&lt;br&gt;于是，自然数归纳法和结构归纳法都变成了在良基关系上通用归纳法的具体应用了。&lt;/p&gt;&lt;p&gt;集合 &lt;equation&gt;A&lt;/equation&gt; 上的&lt;b&gt;良基关系&lt;/b&gt;（well-founded relation），是 &lt;equation&gt;A&lt;/equation&gt; 上的一个二元关系 &lt;equation&gt;\prec&lt;/equation&gt; ，&lt;br&gt;如果不存在无限下降序列（infinite descending sequence） &lt;equation&gt;a_0\succ a_1\succ a_2\cdots&lt;/equation&gt; 。&lt;br&gt;例如，自然数上的关系 &lt;equation&gt;&amp;lt;&lt;/equation&gt; ，就是一个良基关系。&lt;br&gt;但是 &lt;equation&gt;\leqslant&lt;/equation&gt; 却不是，因为存在一个无限下降序列 &lt;equation&gt;a_0\geqslant a_1\geqslant a_2\cdots&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;根据良基关系，我们可以定义集合中的&lt;b&gt;最小元&lt;/b&gt;，&lt;br&gt;&lt;equation&gt;a\in A&lt;/equation&gt; 为最小元，如果不存在 &lt;equation&gt;a&#39;\in A&lt;/equation&gt; ，使得 &lt;equation&gt;a&#39;\prec a&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;对于良基关系，有一个等价的定义，&lt;br&gt;&lt;b&gt;&lt;equation&gt;A&lt;/equation&gt; 上的二元关系 &lt;equation&gt;\prec&lt;/equation&gt; 是良基的，当且仅当 &lt;equation&gt;A&lt;/equation&gt; 的每一个非空子集 &lt;equation&gt;B&lt;/equation&gt; 有最小元。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们可以证明一下这两种说法等价性。&lt;br&gt;要证当且仅当，我们需要证明充分性和必要性，&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）充分性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;要证： &lt;equation&gt;A&lt;/equation&gt; 上的二元关系 &lt;equation&gt;\prec&lt;/equation&gt; 是良基的，则 &lt;equation&gt;A&lt;/equation&gt; 的每一个非空子集 &lt;equation&gt;B&lt;/equation&gt; 有最小元。&lt;br&gt;使用反证法，如果 &lt;equation&gt;B&lt;/equation&gt; 没有最小元，则对于每个 &lt;equation&gt;a\in B&lt;/equation&gt; ，&lt;br&gt;总可以找到 &lt;equation&gt;a&#39;\in B&lt;/equation&gt; ，使得 &lt;equation&gt;a&#39;\prec a&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;但是，如果这样的话，我们就可以对任何 &lt;equation&gt;a_0\in B&lt;/equation&gt; ，以 &lt;equation&gt;a_0&lt;/equation&gt; 开始构造一个无限下降序列 &lt;equation&gt;a_0\succ a_1\succ a_2\cdots&lt;/equation&gt; ，这与 &lt;equation&gt;\prec&lt;/equation&gt; 是一个良基关系矛盾。&lt;/p&gt;&lt;p&gt;充分性证毕。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2） 必要性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;要证：如果 &lt;equation&gt;A&lt;/equation&gt; 的每一个非空子集 &lt;equation&gt;B&lt;/equation&gt; 都有最小元，&lt;br&gt;则 &lt;equation&gt;A&lt;/equation&gt; 上用于比较的二元关系 &lt;equation&gt;\prec&lt;/equation&gt; 是良基的。&lt;/p&gt;&lt;p&gt;由于 &lt;equation&gt;A&lt;/equation&gt; 的每一个非空子集 &lt;equation&gt;B&lt;/equation&gt; 都有最小元，&lt;br&gt;则不可能存在无限下降序列 &lt;equation&gt;a_0\succ a_1\succ a_2\cdots&lt;/equation&gt; ，因此， &lt;equation&gt;\prec&lt;/equation&gt; 是良基的。&lt;/p&gt;&lt;p&gt;必要性证毕。&lt;/p&gt;&lt;p&gt;因此， &lt;equation&gt;A&lt;/equation&gt; 上的二元关系 &lt;equation&gt;\prec&lt;/equation&gt; 是良基的，当且仅当 &lt;equation&gt;A&lt;/equation&gt; 的每一个非空子集 &lt;equation&gt;B&lt;/equation&gt; 有最小元。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;良基归纳法&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2c813b575e2e614578b648087e3df9a4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;568&quot; data-rawheight=&quot;465&quot;&gt;&lt;p&gt;设 &lt;equation&gt;\prec&lt;/equation&gt; 为集合 &lt;equation&gt;A&lt;/equation&gt; 上的良基二元关系，并且设 &lt;equation&gt;P&lt;/equation&gt; 为关于 &lt;equation&gt;A&lt;/equation&gt; 中元素的某个命题，&lt;br&gt;如果 &lt;equation&gt;P(b)&lt;/equation&gt; 对于所有的 &lt;equation&gt;b\prec a&lt;/equation&gt; 成立，就必然有 &lt;equation&gt;P(a)&lt;/equation&gt; 成立，&lt;br&gt;那么 &lt;equation&gt;P(a)&lt;/equation&gt; 就对所有的 &lt;equation&gt;a\in A&lt;/equation&gt; 成立。&lt;/p&gt;&lt;p&gt;我们看到 &lt;equation&gt;&amp;lt;&lt;/equation&gt; 确实是自然数集上的良基关系，因此自然数归纳法只是良基归纳法的一种特例。&lt;/p&gt;&lt;p&gt;现在我们有了足够的能力来证明自然数归纳法的正确性了，&lt;br&gt;只要我们证明了良基归纳法是正确的。&lt;/p&gt;&lt;p&gt;还是用&lt;b&gt;反证法&lt;/b&gt;：&lt;/p&gt;&lt;p&gt;我们期望证明，&lt;br&gt;&lt;b&gt;前提：&lt;/b&gt;如果 &lt;equation&gt;P(b)&lt;/equation&gt; 对于所有的 &lt;equation&gt;b\prec a&lt;/equation&gt; 成立，必然有 &lt;equation&gt;P(a)&lt;/equation&gt; 成立，&lt;br&gt;&lt;b&gt;结论：&lt;/b&gt;那么对于所有的 &lt;equation&gt;a\in A&lt;/equation&gt; ， &lt;equation&gt;P(a)&lt;/equation&gt; 都成立。&lt;/p&gt;&lt;p&gt;如若不然，假设存在 &lt;equation&gt;x\in A&lt;/equation&gt; ，使得 &lt;equation&gt;P(x)&lt;/equation&gt; 不成立，&lt;br&gt;则集合 &lt;equation&gt;B=\{a\in A\ |\ \neg P(a)\}&lt;/equation&gt; 非空，&lt;br&gt;因此根据良基关系的等价定义，集合 &lt;equation&gt;B&lt;/equation&gt; 必有最小元 &lt;equation&gt;m\prec B\subseteq A&lt;/equation&gt; ，&lt;br&gt;而且， &lt;equation&gt;\neg P(m)&lt;/equation&gt; 成立。&lt;/p&gt;&lt;p&gt;则根据前提的逆否命题，一定存在 &lt;equation&gt;b\prec m&lt;/equation&gt; ，使得 &lt;equation&gt;\neg P(b)&lt;/equation&gt; 成立，&lt;br&gt;所以，我们有 &lt;equation&gt;b\in B&lt;/equation&gt; ，且 &lt;equation&gt;b \prec m&lt;/equation&gt; ，与 &lt;equation&gt;m&lt;/equation&gt; 是 &lt;equation&gt;B&lt;/equation&gt; 的最小元矛盾。&lt;/p&gt;&lt;p&gt;证毕。&lt;/p&gt;&lt;p&gt;由此，我们证明了良基归纳法的正确性。&lt;br&gt;理解良基关系和偏序关系，是理解递归和不动点算子的第一步。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a4cae22aff8b6d791971cfcc0d2a8de2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;220&quot; data-rawheight=&quot;361&quot;&gt;&lt;p&gt;本文从自然数归纳法出发，补充了一些集合论方面的知识，&lt;br&gt;让我们熟悉了集合上的几种常用关系，例如，等价关系，偏序关系和良基关系，&lt;br&gt;这些关系在以后的文章中还会被再次提到。&lt;/p&gt;&lt;p&gt;最后，我们证明了良基归纳法，从而证明了自然数归纳法的正确性。&lt;br&gt;不知道是否很明显了，递归的步骤和归纳的步骤，简直是太像了，&lt;br&gt;这一定不是偶然。&lt;/p&gt;&lt;p&gt;在&lt;a href=&quot;https://book.douban.com/subject/26429992/&quot;&gt;The Little Prover&lt;/a&gt;一书中，为了证明递归函数是否全函数（total function），&lt;br&gt;作者使用了测度（measure）的概念，这实际上定义了参数集上的一个良基关系。&lt;br&gt;全函数是可计算理论中一个很重要的概念，&lt;br&gt;到底什么是全函数，什么是测度？下文我们再详细讨论。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95&quot;&gt;维基百科 - 数学归纳法&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB&quot;&gt;维基百科 - 二元关系&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%89%AF%E5%9F%BA%E5%85%B3%E7%B3%BB&quot;&gt;维基百科 - 良基关系&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1144542/&quot;&gt;程序设计语言的形式语义&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-11-34287668</guid>
<pubDate>Sun, 11 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（二）：编写递归函数的思路和技巧</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-10-34287414.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34287414&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bc103055d4f8d209a9087df68eeddf49_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;680&quot; data-rawheight=&quot;310&quot;&gt;&lt;p&gt;递归，是一个熟悉而陌生的概念，说它熟悉，是因为人们经常提起它，&lt;br&gt;而说它陌生，指的是人们在实际编程中几乎不会主动使用它。&lt;/p&gt;&lt;p&gt;给定一个问题，如果本质上它能看做一个调用自身的规模较小的一个子问题来求解，&lt;br&gt;那么给出一个递归的算法解，就是很自然的。&lt;br&gt;然而，即使是这样，编制一个递归函数也是一件令人头疼的事情。&lt;/p&gt;&lt;p&gt;本系列文章的目的，可能并不局限于指出如何编写一个递归函数，&lt;br&gt;而是期望想从递归函数开始，了解它相关的科学知识，以达到对不同领域触类旁通的效果。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 从一个简单的例子开始&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;首先，我们来重温一下递归的概念，&lt;br&gt;维基百科上是这样描述的，&lt;/p&gt;&lt;blockquote&gt;递归（recursion），在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。&lt;/blockquote&gt;&lt;p&gt;我们来看一个简单的例子吧。（&lt;a href=&quot;https://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt;代码&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact :: Int -&amp;gt; Int
fact 1 = 1
fact n = n * fact (n-1)&lt;/code&gt;&lt;p&gt;在这个例子中，&lt;br&gt;第一行&lt;code class=&quot;inline&quot;&gt;fact :: Int -&amp;gt; Int&lt;/code&gt;表示了&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;函数的类型，&lt;br&gt;第二行和第三行定义了函数&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;，&lt;br&gt;我们看到第三行，在对&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;函数定义的时候，等式右边又出现了&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;，&lt;br&gt;这样定义的函数&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;是递归的。&lt;/p&gt;&lt;p&gt;我们调用一下&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;，来看看结果，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact 10
3628800&lt;/code&gt;&lt;p&gt;嗯嗯，&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;就是阶乘函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 写递归函数的步骤&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;那么，给定一个问题，我们编写一个递归函数，要如何开始呢？&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）递推式&lt;/b&gt;&lt;/p&gt;&lt;p&gt;首先，我们要找到“递推式”。&lt;/p&gt;&lt;p&gt;例如，在数学上阶乘的定义是， &lt;equation&gt;f(n)=n!&lt;/equation&gt; ，这样的表述形式，不具有递推性。&lt;br&gt;我们先要想办法把 &lt;equation&gt;f(n)&lt;/equation&gt; 用 &lt;equation&gt;f(n-1)&lt;/equation&gt; 表示出来。&lt;/p&gt;&lt;p&gt;经过思考之后，我们可以证明， &lt;equation&gt;f(n)=n*f(n-1)&lt;/equation&gt; ，&lt;br&gt;于是，我们就走出了关键的第一步，得到了“递推式”。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）找出终止条件&lt;/b&gt;&lt;/p&gt;&lt;p&gt;有了“递推式”还不行，我们还需要确定递推在什么时候终止。&lt;br&gt;我们知道 &lt;equation&gt;f(1)=1&lt;/equation&gt; ， &lt;equation&gt;f(2)=2*f(1)&lt;/equation&gt; ， &lt;equation&gt;f(3)=3*f(2)&lt;/equation&gt; ，等等，&lt;br&gt;因此，我们只需要指定 &lt;equation&gt;f(1)=1&lt;/equation&gt; ，那么递推就会在 &lt;equation&gt;f(n)&lt;/equation&gt; ，当 &lt;equation&gt;n=1&lt;/equation&gt; 的时候终止了。&lt;/p&gt;&lt;p&gt;终止，就是不再调用规模更小的问题了。&lt;br&gt;这时，终止条件是 &lt;equation&gt;f(1)=1&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（3）用数学归纳法证明解的正确性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这一步是很重要的，有很多人都缺少证明递推式正确性的环节，&lt;br&gt;但是，考虑到介绍&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95&quot;&gt;数学归纳法&lt;/a&gt;及其扩展会占用不少篇幅，&lt;br&gt;这里先略去，下一篇我们再回来讨论它。&lt;/p&gt;&lt;p&gt;这里，我们先假定，根据“递推式”和“终止条件”，使用数学归纳法，&lt;br&gt;我们已经证明了这样定义的 &lt;equation&gt;f(n)&lt;/equation&gt; 就是 &lt;equation&gt;n!&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（4）根据递推式和终止条件，编写程序&lt;/b&gt;&lt;/p&gt;&lt;p&gt;有了“递推式”和“终止条件”，再编写程序就水到渠成了。&lt;br&gt;很多人一上来就开始编码，就会感觉毫无头绪。&lt;/p&gt;&lt;p&gt;我们再来看下那段程序，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact :: Int -&amp;gt; Int
fact 1 = 1
fact n = n * fact (n-1)&lt;/code&gt;&lt;p&gt;这不就是“递推式”和“终止条件”的忠实表示吗？&lt;br&gt;我们用&lt;code class=&quot;inline&quot;&gt;fact 1 = 1&lt;/code&gt;表示了 &lt;equation&gt;f(1)=1&lt;/equation&gt; ，&lt;br&gt;用&lt;code class=&quot;inline&quot;&gt;fact n = n * fact (n-1)&lt;/code&gt;表示了 &lt;equation&gt;f(n)=n*f(n-1)&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 小技巧&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们再看个复杂一点的例子。&lt;/p&gt;&lt;p&gt;在实际项目中，我们可能会遇到循环 &lt;equation&gt;n&lt;/equation&gt; 次的场景，&lt;br&gt;在循环过程中，我们会根据索引进行运算，然后将某些符合条件的运算放到最终的结果中。&lt;/p&gt;&lt;p&gt;例如，我们选择10以内的所有偶数，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;[x|x &amp;lt;- [0..9], x `mod` 2 == 0]
[0,2,4,6,8]&lt;/code&gt;&lt;p&gt;使用以上列表解析（&lt;a href=&quot;http://www.haskell.org/haskellwiki/List_comprehension&quot;&gt;list comprehension&lt;/a&gt;）的方法，我们可以快速得到结果。&lt;br&gt;但是这里，我们想要拿它来举例，介绍一个编写递归函数常用的小技巧。&lt;/p&gt;&lt;p&gt;为了通用性，我们考虑循环&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;次，将索引传入函数&lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt;，&lt;br&gt;根据&lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt;的返回值，将结果放入一个列表中，完成这个功能的函数我们记为&lt;code class=&quot;inline&quot;&gt;myLoop&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）困境&lt;/b&gt;&lt;/p&gt;&lt;p&gt;根据前文介绍的编写步骤，我们需要先找到“递推式”和“终止条件”。&lt;/p&gt;&lt;p&gt;“终止条件”怎么写呢？&lt;br&gt;假如我们定义的递归函数称为&lt;code class=&quot;inline&quot;&gt;myLoop&lt;/code&gt;，那么 &lt;equation&gt;myLoop(0,fn)&lt;/equation&gt; 就是终止条件，它应该返回一个列表。但是这个列表在参数中没有，它随着递归调用的过程“积累”得到的。&lt;/p&gt;&lt;p&gt;好吧，那我们看“递推式”。&lt;br&gt;&lt;equation&gt;myLoop(n,fn)&lt;/equation&gt; 要用 &lt;equation&gt;myLoop(n-1,fn)&lt;/equation&gt; 的结果计算出来，&lt;br&gt;我们需要先用索引调用&lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt;，然后再根据&lt;code class=&quot;inline&quot;&gt;fn&lt;/code&gt;的返回值，放入结果列表，再继续调用 &lt;equation&gt;myLoop(n-1,fn)&lt;/equation&gt; 。可是，索引从哪来呢？&lt;br&gt;（&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;不是索引，因为索引从0开始，而&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;是逐渐变小的。&lt;/p&gt;&lt;p&gt;这是两个典型的困难，&lt;br&gt;其一，我们在递归的过程中“积累”了某些东西，&lt;br&gt;其二，我们需要传递和递归过程相关的“索引”。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）解法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这时候，我们的小技巧就有用武之地了。&lt;/p&gt;&lt;blockquote&gt;我们可以编写一个辅助的递归函数，通过增加参数的办法，提高灵活性。&lt;/blockquote&gt;&lt;p&gt;例如，我们可以编写一个辅助函数&lt;code class=&quot;inline&quot;&gt;myLoop&#39;&lt;/code&gt;，然后用&lt;code class=&quot;inline&quot;&gt;myLoop&#39;&lt;/code&gt;来实现&lt;code class=&quot;inline&quot;&gt;myLoop&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;myLoop :: Int -&amp;gt; (Int -&amp;gt; Maybe a) -&amp;gt; [a]
myLoop n fn = myLoop&#39; n 0 fn []

myLoop&#39; :: Int -&amp;gt; Int -&amp;gt; (Int -&amp;gt; Maybe a) -&amp;gt; [a] -&amp;gt; [a]
myLoop&#39; 0 i fn lst = lst
myLoop&#39; n i fn lst = case fn i of
  Just x -&amp;gt; myLoop&#39; (n-1) (i+1) fn (lst++[x])
  Nothing -&amp;gt; myLoop&#39; (n-1) (i+1) fn lst&lt;/code&gt;&lt;p&gt;以上，我们为&lt;code class=&quot;inline&quot;&gt;myLoop&#39;&lt;/code&gt;增加了参数&lt;code class=&quot;inline&quot;&gt;i&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;lst&lt;/code&gt;，分别表示“索引”和“积累”的列表。&lt;br&gt;然后，&lt;code class=&quot;inline&quot;&gt;myLoop&lt;/code&gt;就可以用&lt;code class=&quot;inline&quot;&gt;myLoop&#39;&lt;/code&gt;来实现了。&lt;/p&gt;&lt;p&gt;别忘了测试一下最终的结果，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;myLoop 10 (\x -&amp;gt; if x `mod` 2 == 0 then Just x else Nothing)
[0,2,4,6,8]&lt;/code&gt;&lt;p&gt;&lt;b&gt;（3）其他考虑&lt;/b&gt;&lt;/p&gt;&lt;p&gt;合理的利用递归函数的返回值，会减少附加参数的数量，例如，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;myLoop :: Int -&amp;gt; (Int -&amp;gt; Maybe a) -&amp;gt; [a]
myLoop n fn = myLoop&#39; n 0 fn

myLoop&#39; :: Int -&amp;gt; Int -&amp;gt; (Int -&amp;gt; Maybe a) -&amp;gt; [a]
myLoop&#39; 0 i fn = []
myLoop&#39; n i fn = case fn i of
  Just x -&amp;gt; x:(myLoop&#39; (n-1) (i+1) fn)
  Nothing -&amp;gt; myLoop&#39; (n-1) (i+1) fn&lt;/code&gt;&lt;p&gt;但最终得到的递归函数就不是&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8&quot;&gt;尾递归&lt;/a&gt;了，&lt;br&gt;关于尾递归，我们将在后续文章中讨论它。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92&quot;&gt;维基百科 - 递归&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%81%9E%E8%BF%B4%E9%97%9C%E4%BF%82%E5%BC%8F&quot;&gt;维基百科 - 递推关系式&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-10-34287414</guid>
<pubDate>Sat, 10 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（一）：开篇</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-10-34287397.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34287397&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;提到函数式编程，人们最多想到的可能是它的某些性质，&lt;br&gt;例如，不可变性，无副作用，惰性求值，类型推导，等等。&lt;/p&gt;&lt;p&gt;然而，这些性质可能并不是它能吸引粉丝的根本原因，&lt;br&gt;而是它从工业界触手可及的直接应用出发，带我们看到了人类能力的边界，&lt;br&gt;函数式编程仿佛一座桥梁，让我们普通程序员也能窥探计算机科学的奥秘。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\lambda&lt;/equation&gt; 演算是一个简洁的演算系统，但是它的计算能力却能比肩复杂的现代计算机，&lt;br&gt;因为它的简洁性质，以及与Lisp语言的紧密关系，对 &lt;equation&gt;\lambda&lt;/equation&gt; 演算有所了解的程序员也比较多。&lt;/p&gt;&lt;p&gt;提到编程语言，上下文无关文法，以及正则文法，熟悉的人可能会更多，&lt;br&gt;书写正则表达式，开发和应用DSL，甚至阅读编程语言的语法规范，都离不开它们。&lt;/p&gt;&lt;p&gt;然而，逻辑系统和递归函数论却鲜有人提及，&lt;br&gt;对如何书写递归函数人们可能仍旧心存畏惧，对类型的推导过程和原理也如坠迷雾。&lt;/p&gt;&lt;p&gt;其实，这是一块广袤的领域，其背景知识可能涉及了数学归纳法，良基或结构归纳法，&lt;br&gt;可计算性理论，不动点算子，哥德尔定理，以及证明论，模型论，等等。&lt;br&gt;数学背景，我们可能还需要补充，抽象代数，集合论，数理逻辑等离散数学的内容。&lt;/p&gt;&lt;p&gt;然而，我们的收获将是巨大的，&lt;br&gt;我们会看到用有限表示无限的递归思想，以及由这种思想导致的各种计算模型的能力限制。&lt;br&gt;递归与其他领域触类旁通之后，我们将走到数学，逻辑，计算机科学的交叉点上，&lt;br&gt;我认为这是一件值得高兴的事情。&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-10-34287397</guid>
<pubDate>Sat, 10 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Emacs之魂（九）：读取器宏</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-09-34106631.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34106631&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;1. 编译器宏&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2bb31943cb05a4b66f1109da6cfaef2f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;516&quot;&gt;&lt;p&gt;Lisp源代码文本，首先经过读取器，得到了一系列语法对象，&lt;br&gt;这些语法对象，在宏展开阶段进行变换，最终由编译器/解释器继续处理。&lt;/p&gt;&lt;p&gt;以下我们使用&lt;code class=&quot;inline&quot;&gt;defmacro&lt;/code&gt;定义了一个宏&lt;code class=&quot;inline&quot;&gt;inc&lt;/code&gt;，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(defmacro inc (var)
    `(setq ,var (1+ ,var)))&lt;/code&gt;&lt;p&gt;它可以将&lt;code class=&quot;inline&quot;&gt;(inc x)&lt;/code&gt;展开为&lt;code class=&quot;inline&quot;&gt;(setq x (1+ x))&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;inc&lt;/code&gt;宏可以看做对编译器/解释器进行“编程”，它影响了最终被编译/解释的程序。&lt;br&gt;因此，类似&lt;code class=&quot;inline&quot;&gt;inc&lt;/code&gt;这样的宏，称为&lt;b&gt;编译器宏&lt;/b&gt;（compiler macro）。&lt;/p&gt;&lt;p&gt;此外，还有一种宏，称为&lt;b&gt;读取器宏&lt;/b&gt;（reader macro），&lt;br&gt;它在源代码的读取阶段，以自定义的方式，将文本转换为语法对象。&lt;/p&gt;&lt;p&gt;引用（quote）“&lt;code class=&quot;inline&quot;&gt;&#39;&lt;/code&gt;”，就是一个读取器宏，&lt;br&gt;它将源代码文本&lt;code class=&quot;inline&quot;&gt;&#39;(1 2)&lt;/code&gt;转换成&lt;code class=&quot;inline&quot;&gt;(quote (1 2))&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 用户定义的读取器宏&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;虽然，引用“&lt;code class=&quot;inline&quot;&gt;&#39;&lt;/code&gt;”是一个读取器宏，但它却不是由用户定义的，&lt;br&gt;支持用户自定义的读取器宏，是一个很强大的语言特性，&lt;br&gt;它可以让我们摆脱语法的束缚，创建自己的语言。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.1 Common Lisp&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ac0034f27d908e076b8f1c5c6c59b47c_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;160&quot; data-rawheight=&quot;160&quot;&gt;&lt;p&gt;（1）set-macro-character&lt;br&gt;在Common Lisp中，我们可以使用&lt;code class=&quot;inline&quot;&gt;set-macro-character&lt;/code&gt;，来模拟引用“&lt;code class=&quot;inline&quot;&gt;&#39;&lt;/code&gt;”的定义，&lt;/p&gt;&lt;code lang=&quot;common-lisp&quot;&gt;(set-macro-character #\&#39;
    #&#39;(lambda (stream char) 
        (list (quote quote) (read stream t nil t))))&lt;/code&gt;&lt;p&gt;当读取器遇到&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;的时候，会返回&lt;code class=&quot;inline&quot;&gt;(quote a)&lt;/code&gt;。&lt;br&gt;其中&lt;code class=&quot;inline&quot;&gt;read&lt;/code&gt;函数可以参考：&lt;a href=&quot;http://www.lispworks.com/documentation/HyperSpec/Body/f_rd_rd.htm&quot;&gt;read&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;（2）set-dispatch-macro-character&lt;br&gt;我们还可以自定义捕获字符（dispatch macro character），&lt;br&gt;例如，我们定义&lt;code class=&quot;inline&quot;&gt;#?&lt;/code&gt;来捕获后面的文本，&lt;/p&gt;&lt;code lang=&quot;common-lisp&quot;&gt;(set-dispatch-macro-character #\# #\?
    #&#39;(lambda (stream char1 char2)
        (list &#39;quote
            (let ((lst nil))
                (dotimes (i (+ (read stream t nil t) 1))
                    (push i lst))
                (nreverse lst)))))&lt;/code&gt;&lt;p&gt;读取器会将&lt;code class=&quot;inline&quot;&gt;#?7&lt;/code&gt;转换成&lt;code class=&quot;inline&quot;&gt;(0 1 2 3 4 5 6 7)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;（3）get-macro-character&lt;br&gt;我们还可以自定义分隔符，例如，以下我们定义了&lt;code class=&quot;inline&quot;&gt;#{ ... }&lt;/code&gt;分隔符，&lt;/p&gt;&lt;code lang=&quot;common-lisp&quot;&gt;(set-macro-character #\}
    (get-macro-character #\)))

(set-dispatch-macro-character #\# #\{
    #&#39;(lambda (stream char1 char2)
        (let ((accum nil)
              (pair (read-delimited-list #\} stream t)))
            (do ((i (car pair) (+ i 1)))
                ((&amp;gt; i (cadr pair))
                (list &#39;quote (nreverse accum)))
              (push i accum)))))&lt;/code&gt;&lt;p&gt;读取器会将&lt;code class=&quot;inline&quot;&gt;#{2 7}&lt;/code&gt;转换成&lt;code class=&quot;inline&quot;&gt;(2 3 4 5 6 7)&lt;/code&gt;。&lt;br&gt;其中，&lt;code class=&quot;inline&quot;&gt;get-macro-character&lt;/code&gt;可以参考：&lt;a href=&quot;http://www.lispworks.com/documentation/HyperSpec/Body/f_set_ma.htm&quot;&gt;GET-MACRO-CHARACTER&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 Racket&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-584cf7576c72a6d7d170c52876cec178_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;160&quot; data-rawheight=&quot;159&quot;&gt;&lt;p&gt;在Racket中，我们可以通过创建自定义的读取器，得到一门新语言，&lt;br&gt;例如，下面两个文件&lt;code class=&quot;inline&quot;&gt;language.rkt&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;main.rkt&lt;/code&gt;，&lt;/p&gt;&lt;p&gt;（1）&lt;code class=&quot;inline&quot;&gt;language.rkt&lt;/code&gt;模块创建了一个读取器，&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang racket
(require syntax/strip-context)

(provide (rename-out [literal-read read]
                     [literal-read-syntax read-syntax]))

(define (literal-read in)
  (syntax-&amp;gt;datum
   (literal-read-syntax #f in)))

(define (literal-read-syntax src in)
  (with-syntax ([str (port-&amp;gt;string in)])
    (strip-context
     #&#39;(module anything racket
         (provide data)
         (define data &#39;str)))))&lt;/code&gt;&lt;p&gt;（2）&lt;code class=&quot;inline&quot;&gt;main.rkt&lt;/code&gt;模块，就可以用新语法进行编写了，&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;#lang reader &quot;language.rkt&quot;
Hello World!&lt;/code&gt;&lt;p&gt;然后，我们载入&lt;code class=&quot;inline&quot;&gt;main.rkt&lt;/code&gt;，查看该模块导出的&lt;code class=&quot;inline&quot;&gt;data&lt;/code&gt;变量，&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;&amp;gt; (require (file &quot;~/Test/main.rkt&quot;))
&amp;gt; data
&quot;\nHello World!&quot;&lt;/code&gt;&lt;p&gt;在&lt;code class=&quot;inline&quot;&gt;main.rkt&lt;/code&gt;中，&lt;br&gt;我们通过&lt;code class=&quot;inline&quot;&gt;#lang reader &quot;language.rkt&quot;&lt;/code&gt;，载入了一个自定义的读取器模块，&lt;br&gt;该模块必须导出&lt;code class=&quot;inline&quot;&gt;read&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;read-syntax&lt;/code&gt;两个函数。&lt;/p&gt;&lt;p&gt;这里，&lt;code class=&quot;inline&quot;&gt;read-syntax&lt;/code&gt;只是简单的获取源代码，导出到&lt;code class=&quot;inline&quot;&gt;data&lt;/code&gt;变量中，&lt;br&gt;最终返回了一个用于模块定义的语法对象&lt;code class=&quot;inline&quot;&gt;(module ...)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在本例中，它把&lt;code class=&quot;inline&quot;&gt;&quot;Hello World!&quot;&lt;/code&gt;转换成了一个模块定义表达式，&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;(module anything racket
    (provide data)
    (define data &quot;Hello World!&quot;))&lt;/code&gt;&lt;p&gt;其中，&lt;code class=&quot;inline&quot;&gt;anything&lt;/code&gt;是模块名，&lt;code class=&quot;inline&quot;&gt;racket&lt;/code&gt;是该模块的依赖。&lt;br&gt;所以，当载入&lt;code class=&quot;inline&quot;&gt;main.rkt&lt;/code&gt;后，我们就可以获取&lt;code class=&quot;inline&quot;&gt;data&lt;/code&gt;的值了。&lt;/p&gt;&lt;p&gt;在实际应用中，我们还可以对源代码进行任意解析，创建自己的语言。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3 Emacs Lisp&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0bb085922b8effdfa6e998c8a4306626_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;160&quot; data-rawheight=&quot;159&quot;&gt;&lt;p&gt;Emacs Lisp内置的读取器，并不支持自定义的读取器宏，&lt;br&gt;为了实现读取器宏，我们需要重写Emacs内置的&lt;code class=&quot;inline&quot;&gt;read&lt;/code&gt;函数，&lt;br&gt;例如，&lt;a href=&quot;https://github.com/mishoo/elisp-reader.el&quot;&gt;elisp-reader&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;Emacs在启动时，会自动载入&lt;code class=&quot;inline&quot;&gt;~/.emacs.d/init.el&lt;/code&gt;文件，然后执行其中的配置脚本，&lt;br&gt;因此，我们可以在&lt;code class=&quot;inline&quot;&gt;init.el&lt;/code&gt;中调用&lt;a href=&quot;https://github.com/mishoo/elisp-reader.el&quot;&gt;elisp-reader&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;（1）创建&lt;code class=&quot;inline&quot;&gt;~/.emacs.d/init.el&lt;/code&gt;文件，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(add-to-list &#39;load-path &quot;~/.emacs.d/package/elisp-reader/&quot;)
(require &#39;elisp-reader)&lt;/code&gt;&lt;p&gt;（2）使用git克隆&lt;a href=&quot;https://github.com/mishoo/elisp-reader.el&quot;&gt;elisp-reader&lt;/a&gt;仓库到&lt;code class=&quot;inline&quot;&gt;~/.emacas.d/package&lt;/code&gt;文件夹，&lt;/p&gt;&lt;code lang=&quot;bash&quot;&gt;git clone https://github.com/mishoo/elisp-reader.el.git ~/.emacs.d/package/elisp-reader&lt;/code&gt;&lt;p&gt;（3）打开Emacs，自动执行&lt;code class=&quot;inline&quot;&gt;init.el&lt;/code&gt;中的配置，&lt;/p&gt;&lt;p&gt;（4）在Emacs中定义一个读取器宏，然后求值整个Buffer，（&lt;code class=&quot;inline&quot;&gt;M-x ev-b&lt;/code&gt;）&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(require &#39;cl-macs)

(def-reader-syntax ?{
    (lambda (in ch)
      (let ((list (er-read-list in ?} t)))
        `(list ,@(cl-loop for (key val) on list by #&#39;cddr
                          collect `(cons ,key ,val))))))&lt;/code&gt;&lt;p&gt;（5）测试&lt;code class=&quot;inline&quot;&gt;read&lt;/code&gt;函数的执行结果，（&lt;code class=&quot;inline&quot;&gt;C-x C-e&lt;/code&gt;）&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(read &quot;{ :foo 1 :bar \&quot;string\&quot; :baz (+ 2 3) }&quot;)
&amp;gt; (list (cons :foo 1) (cons :bar &quot;string&quot;) (cons :baz (+ 2 3)))

(car { :foo 1 :bar &quot;string&quot; :baz (+ 2 3) })
&amp;gt; (:foo . 1)&lt;/code&gt;&lt;p&gt;源代码&lt;code class=&quot;inline&quot;&gt;{ :foo 1 :bar &quot;string&quot; :baz (+ 2 3) }&lt;/code&gt;被直接读取成了一个列表对象，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;((:foo . 1) (:bar &quot;string&quot;) (:baz (+ 2 3)))&lt;/code&gt;&lt;p&gt;对&lt;code class=&quot;inline&quot;&gt;car&lt;/code&gt;函数而言，它看到的是列表对象，并不知道具体的语法是什么。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了读取器宏的概念，Lisp各方言中会对读取器宏有不同程度的支持，&lt;br&gt;我们分析了Common Lisp，Racket以及Emacs Lisp的做法。&lt;/p&gt;&lt;p&gt;读取器宏直接作用到源代码文本上，用户定义的读取器宏可以对读取器进行“编程”，&lt;br&gt;借此可以支持自由灵活的语法，它是设计和使用DSL的神兵利器。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node101.html&quot;&gt;Common Lisp the Language, 2nd Edition: 8.4 Compiler Macros&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1456906/&quot;&gt;ANSI Common Lisp: 14.3 Read-Macros&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/3864436/&quot;&gt;Let Over Lambda: 4. Read Macros&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://docs.racket-lang.org/guide/hash-lang_reader.html?q=%23lang%20reader&quot;&gt;The Racket Reference: 17.3.2 Using #lang reader&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://github.com/mishoo/elisp-reader.el&quot;&gt;Github: elisp-reader&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-09-34106631</guid>
<pubDate>Fri, 09 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Emacs之魂（八）：反引用与嵌套反引用</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-08-34106584.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34106584&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;1. 反引用&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们介绍了如何使用&lt;code class=&quot;inline&quot;&gt;defmacro&lt;/code&gt;定义宏，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(defmacro inc (var)
    (list &#39;setq var (list &#39;1+ var)))&lt;/code&gt;&lt;p&gt;我们定义了&lt;code class=&quot;inline&quot;&gt;inc&lt;/code&gt;宏，&lt;code class=&quot;inline&quot;&gt;(inc x)&lt;/code&gt;会被展开为&lt;code class=&quot;inline&quot;&gt;(setq x (1+ x))&lt;/code&gt;，因此，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(defvar x 0)
(inc x)

x    ; 1&lt;/code&gt;&lt;p&gt;宏做的是语法对象的变换操作，因此几乎每个宏最后都返回一个列表，&lt;br&gt;可是，类似上述&lt;code class=&quot;inline&quot;&gt;inc&lt;/code&gt;宏那样，每次都使用&lt;code class=&quot;inline&quot;&gt;list&lt;/code&gt;来创建列表，是一件麻烦的事情，&lt;br&gt;所以，Lisp提供了反引用（quasiquote/backquote），可以便捷的生成列表。&lt;/p&gt;&lt;p&gt;例如，以上&lt;code class=&quot;inline&quot;&gt;inc&lt;/code&gt;宏使用反引用来生成列表，可以修改为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(defmacro inc (var)
    `(setq ,var (1+ ,var)))&lt;/code&gt;&lt;p&gt;可以看到，反引用`&lt;code class=&quot;inline&quot;&gt;(setq ,var (1+ ,var)))&lt;/code&gt;与&lt;code class=&quot;inline&quot;&gt;(inc x)&lt;/code&gt;的展开式&lt;code class=&quot;inline&quot;&gt;(setq x (1+ x))&lt;/code&gt;非常相像，&lt;br&gt;我们只需要将反引号去掉，然后将反引用表达式中的逗号表达式&lt;code class=&quot;inline&quot;&gt;,var&lt;/code&gt;，替换为&lt;code class=&quot;inline&quot;&gt;var&lt;/code&gt;绑定的值&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;即可。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 反引用表达式的求值规则&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面我们通过几个例子来说明反引用的使用方式，其中&lt;code class=&quot;inline&quot;&gt;=&amp;gt;&lt;/code&gt;表示“求值为”。&lt;/p&gt;&lt;p&gt;&lt;b&gt;求值规则：&lt;/b&gt;&lt;br&gt;（1）如果反引用表达式中不包含逗号&lt;code class=&quot;inline&quot;&gt;,&lt;/code&gt;，那么它和引用表达式是一样的，&lt;br&gt;因此反引用通常被看做是一种特殊的引用（quote）&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;`(a list of (+ 2 3) elements)
=&amp;gt; (a list of (+ 2 3) elements)&lt;/code&gt;&lt;p&gt;（2）反引用表达式中的逗号表达式会被求值&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;`(a list of ,(+ 2 3) elements)
=&amp;gt; (a list of 5 elements)&lt;/code&gt;&lt;p&gt;（3）反引用表达式中的&lt;code class=&quot;inline&quot;&gt;,@&lt;/code&gt;表达式，也会被求值，但是要求其结果必须是一个列表，&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;,@&lt;/code&gt;会去掉列表的括号，将列表中的元素放到&lt;code class=&quot;inline&quot;&gt;,@&lt;/code&gt;表达式出现的位置&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(defvar x &#39;(2 3))

`(1 ,@x 4)
=&amp;gt; (1 2 3 4)

`(1 ,@(cdr &#39;(1 2 3)) 4)
=&amp;gt; (1 2 3 4)&lt;/code&gt;&lt;h2&gt;&lt;b&gt;3. 生成宏定义的宏&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ebfff027a1484901c7e30166fdebff56_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;600&quot;&gt;&lt;p&gt;以上，我们定义了宏&lt;code class=&quot;inline&quot;&gt;inc&lt;/code&gt;，&lt;br&gt;宏调用&lt;code class=&quot;inline&quot;&gt;(inc x)&lt;/code&gt;，会被展开为&lt;code class=&quot;inline&quot;&gt;(setq x (1+ x))&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在编写宏的时候，一个常用的思路是，&lt;br&gt;&lt;b&gt;先考虑展开关系，即我们期望将A展开为B，再根据这个线索编写相应的宏&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;那么，我们可否编写一个宏，让它展开成&lt;code class=&quot;inline&quot;&gt;(defmacro ...)&lt;/code&gt;呢？&lt;br&gt;是可以的，这是一种展开为宏定义的宏，它可以作为&lt;code class=&quot;inline&quot;&gt;defmacro&lt;/code&gt;来使用。&lt;/p&gt;&lt;p&gt;考虑展开关系，我们期望将&lt;code class=&quot;inline&quot;&gt;(create-inc)&lt;/code&gt;展开为&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(defmacro inc (var) 
    `(setq ,var (1+ ,var)))&lt;/code&gt;&lt;p&gt;于是，宏&lt;code class=&quot;inline&quot;&gt;create-inc&lt;/code&gt;就应该被这样定义，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(defmacro create-inc ()
    `(defmacro inc (var)
        `(setq ,var (1+ ,var))))&lt;/code&gt;&lt;p&gt;我们来试验一下，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(create-inc)    ; 定义了inc

(defvar x 0)
(inc x)    ; 使用inc

x    ; 1&lt;/code&gt;&lt;p&gt;我们还可以给&lt;code class=&quot;inline&quot;&gt;create-inc&lt;/code&gt;加上参数。&lt;br&gt;考虑展开关系，我们将&lt;code class=&quot;inline&quot;&gt;(create-inc-n y)&lt;/code&gt;展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(defmacro inc-n (var)
    `(setq ,var (+ y ,var)))&lt;/code&gt;&lt;p&gt;那么&lt;code class=&quot;inline&quot;&gt;create-inc-n&lt;/code&gt;应该怎么定义呢？事实上，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(defmacro create-inc-n (num)
    `(defmacro inc-n (var)
        `(setq ,var (+ ,&#39;,num ,var))))&lt;/code&gt;&lt;p&gt;第一次看到&lt;code class=&quot;inline&quot;&gt;,&#39;,num&lt;/code&gt;的时候，我非常惊讶，这到底是什么？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4. 嵌套反引用&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a29fd78ff28a7273dafd5a8fc7e9bc54_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;450&quot; data-rawheight=&quot;300&quot;&gt;&lt;p&gt;嵌套反引用指的是，一个反引用表达式中嵌套出现了另一个反引用表达式。&lt;br&gt;在生成宏定义的宏中，嵌套反引用经常出现。&lt;/p&gt;&lt;p&gt;嵌套反引用表达式中，经常会出现类似&lt;code class=&quot;inline&quot;&gt;,&#39;,num&lt;/code&gt;这样的表达式，&lt;br&gt;它不能被写成&lt;code class=&quot;inline&quot;&gt;,num&lt;/code&gt;，也不能被写成&lt;code class=&quot;inline&quot;&gt;,,num&lt;/code&gt;，下面我们进行仔细的分析。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）&lt;code class=&quot;inline&quot;&gt;,num&lt;/code&gt;为什么不正确&lt;/b&gt;&lt;/p&gt;&lt;p&gt;先看一下展开关系，我们期望将&lt;code class=&quot;inline&quot;&gt;(create-inc-n y)&lt;/code&gt;展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(defmacro inc-n (var)
    `(setq ,var (+ y ,var)))&lt;/code&gt;&lt;p&gt;即，嵌套反引用表达式，应该按下述方式求值，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;`(defmacro inc-n (var)
    `(setq ,var (+ ,&#39;,num ,var))))

=&amp;gt; (defmacro inc-n (var)
    `(setq ,var (+ y ,var)))&lt;/code&gt;&lt;p&gt;其中，&lt;code class=&quot;inline&quot;&gt;,var&lt;/code&gt;是不应该被求值的，因为这是内层反引用需要的，&lt;br&gt;如果我们将&lt;code class=&quot;inline&quot;&gt;,&#39;,num&lt;/code&gt;写成&lt;code class=&quot;inline&quot;&gt;,num&lt;/code&gt;，那么它就和&lt;code class=&quot;inline&quot;&gt;,var&lt;/code&gt;一样不会被求值了，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;`(defmacro inc-n (var)
    `(setq ,var (+ ,num ,var))))

=&amp;gt; (defmacro inc-n (var)
    `(setq ,var (+ ,num ,var)))&lt;/code&gt;&lt;p&gt;这和我们期望的展开关系不同。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）&lt;code class=&quot;inline&quot;&gt;,,num&lt;/code&gt;为什么不正确&lt;/b&gt;&lt;/p&gt;&lt;p&gt;写成&lt;code class=&quot;inline&quot;&gt;,,num&lt;/code&gt;在求值最外层反引用表达式的时候，确实会求值&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;的值，&lt;br&gt;但是，在求值内层反引用表达式的时候，这个值还会被再求值一次。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;(create-inc-n y)&lt;/code&gt;将被展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;`(defmacro inc-n (var)
    `(setq ,var (+ ,,num ,var)))

=&amp;gt; (defmacro inc-n (var)
    `(setq ,var (+ ,y ,var)))&lt;/code&gt;&lt;p&gt;可是，在进行宏调用&lt;code class=&quot;inline&quot;&gt;(create-inc-n y)&lt;/code&gt;的时候，我们不应该关心&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;的值是什么，&lt;br&gt;因为在宏展开阶段，&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;可能还没有值。&lt;/p&gt;&lt;p&gt;而且，该展开式和我们预期的展开结果也不相同。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（3）&lt;code class=&quot;inline&quot;&gt;,&#39;,num&lt;/code&gt;是怎么来的&lt;/b&gt;&lt;/p&gt;&lt;p&gt;综上分析，我们需要在外层反引用表达式被求值的时候，求值&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;，&lt;br&gt;而在内层反引用表达式被求值的时候，不再继续求值&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;的值，&lt;br&gt;因此，我们需要给&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;的值加上一个引用来“阻止”求值。&lt;/p&gt;&lt;p&gt;因此，&lt;code class=&quot;inline&quot;&gt;(create-inc-n y)&lt;/code&gt;会被展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;`(defmacro inc-n (var)
    `(setq ,var (+ ,&#39;,num ,var))))

=&amp;gt; (defmacro inc-n (var)
    `(setq ,var (+ ,&#39;y ,var)))&lt;/code&gt;&lt;p&gt;而内层反引用表达式被求值的时候，&lt;code class=&quot;inline&quot;&gt;,&#39;y&lt;/code&gt;将求值为&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;所以，&lt;code class=&quot;inline&quot;&gt;(inc-n x)&lt;/code&gt;将被展开为&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;`(setq ,var (+ ,&#39;y ,var))
=&amp;gt; (setq x (+ y x))&lt;/code&gt;&lt;p&gt;和我们期望的展开结果相同。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;5. 嵌套反引用的求值规则&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bc1e5e9d3b329383e71a9eaa68d29c3b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;308&quot; data-rawheight=&quot;56&quot;&gt;&lt;p&gt;在生成宏定义的宏中，经常会出现嵌套反引用，&lt;br&gt;如果我们定义了另一个宏&lt;code class=&quot;inline&quot;&gt;other-macro&lt;/code&gt;来生成&lt;code class=&quot;inline&quot;&gt;create-inc-n&lt;/code&gt;的定义，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(defmacro other-macro ()
    `(defmacro create-inc-n (num)
        `(defmacro inc-n (var)
            `(setq ,var (+ ,&#39;,num ,var)))))&lt;/code&gt;&lt;p&gt;那么，将出现三层嵌套反引用。&lt;br&gt;不过，不用担心，嵌套反引用也是有求值规则的，以下我们用两层嵌套反引用作为例子来说明。&lt;/p&gt;&lt;p&gt;&lt;b&gt;求值规则：&lt;/b&gt;&lt;br&gt;（1）嵌套反引用被求值的时候，&lt;b&gt;一次求值，只去掉一层反引用&lt;/b&gt;，内层反引用不受影响，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;`(defmacro inc-n (var)
    `(setq ,var (+ ,&#39;,num ,var))))

=&amp;gt; (defmacro inc-n (var)
    `(setq ,var (+ ,&#39;y ,var)))&lt;/code&gt;&lt;p&gt;（2）嵌套反引用表达式中的逗号表达式，是否被求值，要根据情况来定，&lt;br&gt;如果最外层嵌套反引用总共有&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;层，那么一定不会出现包含大于&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;个逗号的表达式，&lt;br&gt;且包含逗号数目小于&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;的表达式不会被求值，&lt;b&gt;只有逗号数目等于&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;的表达式才会被求值&lt;/b&gt;。&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;`(defmacro inc-n (var)
    `(setq ,var (+ ,&#39;,num ,var))))

=&amp;gt; (defmacro inc-n (var)
    `(setq ,var (+ ,&#39;y ,var)))&lt;/code&gt;&lt;p&gt;最外层嵌套反引用总共有&lt;code class=&quot;inline&quot;&gt;n=2&lt;/code&gt;层，&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;,var&lt;/code&gt;表达式包含一个逗号，&lt;code class=&quot;inline&quot;&gt;1&amp;lt;n&lt;/code&gt;，不会被求值，&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;,&#39;,num&lt;/code&gt;表达式包含两个逗号，&lt;code class=&quot;inline&quot;&gt;2=n&lt;/code&gt;，会被求值。&lt;/p&gt;&lt;p&gt;（3）被求值的逗号表达式，其求值方式是，&lt;br&gt;&lt;b&gt;去掉最右边的一个逗号，然后将表达式替换成它的值&lt;/b&gt;。&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;`(defmacro inc-n (var)
    `(setq ,var (+ ,&#39;,num ,var))))

=&amp;gt; (defmacro inc-n (var)
    `(setq ,var (+ ,&#39;y ,var)))&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;,&#39;,num&lt;/code&gt;，去掉最右边的逗号&lt;code class=&quot;inline&quot;&gt;,&#39;num&lt;/code&gt;，然后将&lt;code class=&quot;inline&quot;&gt;num&lt;/code&gt;替换成它的值&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;，&lt;br&gt;于是得到了&lt;code class=&quot;inline&quot;&gt;,&#39;y&lt;/code&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/elisp.html&quot;&gt;GNU Emacs Lisp Reference Manual&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1456906/&quot;&gt;ANSI Common Lisp&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1432683/&quot;&gt;On Lisp&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/3864436/&quot;&gt;Let Over Lambda&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-08-34106584</guid>
<pubDate>Thu, 08 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Emacs之魂（七）：变量捕获与卫生宏</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-07-34106490.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34106490&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-be0646e5c6a0b48056bfdf78f3442375_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;843&quot; data-rawheight=&quot;370&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们介绍了宏，它与函数是不同的，函数调用发生在程序执行期间，函数在调用之前，会先对它所有的实参进行求值，然后将形参绑定到这些实参的求值结果上，函数的返回值会作为函数调用表达式的值，Lisp求值器不断的求值表达式，从而程序得以运行。&lt;/p&gt;&lt;p&gt;宏调用（macro call）发生在程序的编译期，或者说，宏调用发生在表达式的求值之前，在执行宏调用的过程中，宏形参直接绑定为实参所代表的语法对象（syntax object）上，宏调用的返回值，会进行表达式替换，将宏调用表达式替换为它的返回值，这个过程称为宏展开（macro expansion），之后在运行时，求值器就不会遇到宏了，所进行求值的只有被展开之后的表达式。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 交互函数&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在介绍常用的宏之前，我们先介绍Emacs中交互函数（interactive function）的概念。&lt;br&gt;交互函数可以使用&lt;code class=&quot;inline&quot;&gt;M-x&lt;/code&gt;在echo area中通过输入函数名进行调用（交互式调用），所以交互函数也称为命令（command）。&lt;br&gt;交互函数也可以被Lisp程序中的其他函数直接调用，这种调用方式称为非交互式调用。&lt;/p&gt;&lt;p&gt;Emacs中函数定义&lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Defining-Functions.html#Defining-Functions&quot;&gt;defun&lt;/a&gt;&lt;/code&gt;包含以下几个部分，&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;defun name args [doc] [declare] [interactive] body ...&lt;/code&gt;&lt;p&gt;其中，&lt;code class=&quot;inline&quot;&gt;doc&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;declare&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;interactive&lt;/code&gt;都是可选的。&lt;/p&gt;&lt;p&gt;交互函数的定义中，具有&lt;code class=&quot;inline&quot;&gt;interactive&lt;/code&gt;部分，&lt;br&gt;它是一个形如&lt;code class=&quot;inline&quot;&gt;(interactive arg-descriptor)&lt;/code&gt;的表达式，用来指定该函数被交互调用时的行为，&lt;br&gt;对于非交互式调用，&lt;code class=&quot;inline&quot;&gt;interactive&lt;/code&gt;部分将失去作用。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;arg-descriptor&lt;/code&gt;有三种可能的写法：省略，一个字符串，或者一个Lisp表达式。&lt;br&gt;具体情况可能会比较复杂，可以参考&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Using-Interactive.html#Using-Interactive&quot;&gt;Using-Interactive&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.1 describe-key&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;describe-key&lt;/code&gt;是一个交互函数，用来展示某个快键键相关的文档信息，&lt;br&gt;我们可以使用&lt;code class=&quot;inline&quot;&gt;M-x describe-key&lt;/code&gt;来调用它，echo area中会显示如下内容，等待我们键入一个快捷键，&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e9c4d71238a11558bae673bd850860ce_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;678&quot; data-rawheight=&quot;121&quot;&gt;&lt;p&gt;如果我们键入一个快捷键，例如&lt;code class=&quot;inline&quot;&gt;C-a&lt;/code&gt;，Emacs就会展示出与&lt;code class=&quot;inline&quot;&gt;C-a&lt;/code&gt;相关的文档信息了。我们还可以使用快捷键&lt;code class=&quot;inline&quot;&gt;C-h k&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;C-h k&lt;/code&gt;相当于&lt;code class=&quot;inline&quot;&gt;M-x describe-key&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;C-a runs the command move-beginning-of-line (found in global-map),
which is an interactive compiled Lisp function in ‘simple.el’.

It is bound to C-a.

(move-beginning-of-line ARG)

Move point to beginning of current line as displayed.
(If there’s an image in the line, this disregards newlines
which are part of the text that the image rests on.)

With argument ARG not nil or 1, move forward ARG - 1 lines first.
If point reaches the beginning or end of buffer, it stops there.
To ignore intangibility, bind ‘inhibit-point-motion-hooks’ to t.&lt;/code&gt;&lt;p&gt;&lt;b&gt;1.2 describe-function&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;describe-function&lt;/code&gt;也是一个交互函数，用来展示某个函数（或者宏）相关的文档信息，它绑定到了快捷键&lt;code class=&quot;inline&quot;&gt;C-h f&lt;/code&gt;上，&lt;br&gt;调用后，echo area中会显示如下内容，等待我们输入函数（或者宏）的名字，&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d8c0390d2d4077bcdac4cdd5b810cf44_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;674&quot; data-rawheight=&quot;117&quot;&gt;&lt;p&gt;例如，&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;相关的文档信息如下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;when is a Lisp macro in ‘subr.el’.

(when COND BODY...)

If COND yields non-nil, do BODY, else return nil.
When COND yields non-nil, eval BODY forms sequentially and return
value of last one, or nil if there are none.&lt;/code&gt;&lt;p&gt;它指出，&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;是一个宏，并且定义在&lt;code class=&quot;inline&quot;&gt;subr.el&lt;/code&gt;文件中。&lt;/p&gt;&lt;p&gt;鼠标左键点击&lt;code class=&quot;inline&quot;&gt;subr.el&lt;/code&gt;，会打开本地&lt;code class=&quot;inline&quot;&gt;subr.el.gz&lt;/code&gt;文件中&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;的定义，如下，&lt;br&gt;（文件路径为：&lt;code class=&quot;inline&quot;&gt;/Applications/Emacs.app/Contents/Resources/lisp/subr.el.gz&lt;/code&gt;&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(defmacro when (cond &amp;amp;rest body)
  &quot;If COND yields non-nil, do BODY, else return nil.
When COND yields non-nil, eval BODY forms sequentially and return
value of last one, or nil if there are none.
\(fn COND BODY...)&quot;
  (declare (indent 1) (debug t))
  (list &#39;if cond (cons &#39;progn body)))&lt;/code&gt;&lt;p&gt;可见，&lt;code class=&quot;inline&quot;&gt;when&lt;/code&gt;只是一个语法糖，最终会展开成&lt;code class=&quot;inline&quot;&gt;if&lt;/code&gt;表达式。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;subr.el.gz&lt;/code&gt;文件中包含了很多常用的宏，&lt;br&gt;我们可以访问线上地址&lt;a href=&quot;https://github.com/emacs-mirror/emacs/blob/master/lisp/subr.el&quot;&gt;Github: emacs-mirror/emacs subr.el&lt;/a&gt;进行查阅。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 变量捕获&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;2.1 插入一个绑定&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-52535d0d127c59e76c691246b377b071_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;421&quot; data-rawheight=&quot;334&quot;&gt;&lt;code lang=&quot;emacs&quot;&gt;; -*- lexical-binding: t -*-

(defmacro insert-binding (x)
    `(let ((a 1))
        (+ ,x a)))&lt;/code&gt;&lt;p&gt;以上代码定义了一个宏&lt;code class=&quot;inline&quot;&gt;insert-binding&lt;/code&gt;，它将展开成一个&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;表达式，&lt;br&gt;将&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;插入到一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;值为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;的词法环境中。&lt;/p&gt;&lt;p&gt;其中，`&lt;code class=&quot;inline&quot;&gt;(let ((a 1)) (+ ,x a)))&lt;/code&gt;是反引用表达式，&lt;br&gt;下一篇文章中我们再详细讨论。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;(insert-binding 3)&lt;/code&gt;将展开成，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 1))
    (+ 3 a))    ; 4&lt;/code&gt;&lt;p&gt;然而，如果&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;中包含&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，就会引发歧义，例如，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (insert-binding (+ a 3)))&lt;/code&gt;&lt;p&gt;上式会展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (let ((a 1))
        (+ (+ a 3) a)))    ; 5&lt;/code&gt;&lt;p&gt;我们看表达式&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a))&lt;/code&gt;，&lt;br&gt;其中，左边第一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开之前的词法绑定，即，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (insert-binding (+ a 3)))&lt;/code&gt;&lt;p&gt;而第二个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开式中的词法绑定，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;`(let ((a 1))
        (+ ,x a))&lt;/code&gt;&lt;p&gt;在进行宏定义时，我们并不知道&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;中有没有&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，&lt;br&gt;结果导致了，宏展开式中的词法绑定意外捕获了&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;中的&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在本例中，&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;就是&lt;code class=&quot;inline&quot;&gt;(+ a 3)&lt;/code&gt;，其中&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值本来应该是&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;，&lt;br&gt;结果展开后，被宏展开式所捕获，值变成了&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，&lt;br&gt;我们通过插入一个词法绑定，完成了本例。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 插入一个自由变量&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a5d6fa2b397681d42d4ca20162e8ff13_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;403&quot; data-rawheight=&quot;328&quot;&gt;&lt;code lang=&quot;emacs&quot;&gt;; -*- lexical-binding: t -*-

(let ((a 1))
    (defmacro insert-free (x)
        `(+ ,x a)))&lt;/code&gt;&lt;p&gt;以上代码定义了一个宏&lt;code class=&quot;inline&quot;&gt;insert-free&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;(insert-free 3)&lt;/code&gt;将展开为&lt;code class=&quot;inline&quot;&gt;(+ 3 a)&lt;/code&gt;，其中&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;是自由变量，&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值取决于&lt;code class=&quot;inline&quot;&gt;(insert-free 3)&lt;/code&gt;在何处被展开。&lt;/p&gt;&lt;p&gt;例如，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (insert-free (+ a 3)))&lt;/code&gt;&lt;p&gt;将展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (+ (+ a 3) a))    ; 7&lt;/code&gt;&lt;p&gt;我们再来看表达式&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a))&lt;/code&gt;，&lt;br&gt;其中，左边第一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开之前的词法绑定，即，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (insert-free (+ a 3)))&lt;/code&gt;&lt;p&gt;而第二个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开式中的词法绑定，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 1))
    (defmacro insert-free (x)
        `(+ ,x a)))&lt;/code&gt;&lt;p&gt;在进行宏定义时，虽然我们显式的将&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;绑定为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，&lt;br&gt;但是&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;中包含的绑定，意外影响到了它，使得&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值变成了&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;。&lt;br&gt;我们通过插入一个含自由变量的表达式，让它受展开式所处的位置影响。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3 hygienic macro&lt;/b&gt;&lt;/p&gt;&lt;p&gt;以上两个例子中，插入一个绑定会污染宏展开后的环境，而插入一个自由变量会被宏展开后环境所影响，&lt;br&gt;它们都有变量捕获问题，都不是卫生的（hygienic）。&lt;/p&gt;&lt;p&gt;hygienic macro通常翻译成“卫生宏”，是一种避免变量捕获的技术，&lt;br&gt;如果所使用的宏是卫生的，那么以上两个例子中，最后的求值结果应该都是&lt;code class=&quot;inline&quot;&gt;6&lt;/code&gt;，而不是&lt;code class=&quot;inline&quot;&gt;5&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;7&lt;/code&gt;。&lt;br&gt;卫生宏是一种语言特性，&lt;a href=&quot;http://community.schemewiki.org/?RnRS&quot;&gt;Scheme&lt;/a&gt;中的宏是卫生的，而Emacs Lisp不是。&lt;/p&gt;&lt;p&gt;&lt;b&gt;如果一个宏是卫生的，&lt;/b&gt; &lt;b&gt;那么宏展开式中的所有标识符，仍处于其来源处的词法作用域中。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;（1）例如，根据&lt;code class=&quot;inline&quot;&gt;insert-binding&lt;/code&gt;的定义，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;; -*- lexical-binding: t -*-

(let ((a 1))
    (defmacro insert-free (x)
        `(+ ,x a)))
(let ((a 2))
    (insert-binding (+ a 3)))&lt;/code&gt;&lt;p&gt;将展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (let ((a 1))
        (+ (+ a 3) a)))&lt;/code&gt;&lt;p&gt;其中，&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a)&lt;/code&gt;中，&lt;br&gt;第一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开之前的词法环境，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值为&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;，&lt;br&gt;第二个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏定义式，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，&lt;br&gt;因此，&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a)&lt;/code&gt;求值为&lt;code class=&quot;inline&quot;&gt;6&lt;/code&gt;。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0f0d0d03df4a9d2654648399f00f87d1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;358&quot;&gt;&lt;p&gt;（2）又例，根据&lt;code class=&quot;inline&quot;&gt;insert-free&lt;/code&gt;的定义，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;; -*- lexical-binding: t -*-

(let ((a 1))
    (defmacro insert-free (x)
        `(+ ,x a)))
(let ((a 2))
    (insert-free (+ a 3)))&lt;/code&gt;&lt;p&gt;将展开为，&lt;/p&gt;&lt;code lang=&quot;emacs&quot;&gt;(let ((a 2))
    (+ (+ a 3) a))&lt;/code&gt;&lt;p&gt;同理，&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a)&lt;/code&gt;中，&lt;br&gt;第一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏展开之前的词法环境，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值为&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;，&lt;br&gt;第二个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，来源于宏定义式，这个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的值为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，&lt;br&gt;因此，&lt;code class=&quot;inline&quot;&gt;(+ (+ a 3) a)&lt;/code&gt;的值也为&lt;code class=&quot;inline&quot;&gt;6&lt;/code&gt;。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d506193ef43253a3bd3b2ed80fc56297_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;352&quot;&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了交互函数，介绍了如何查看一个函数或者宏的文档和定义，&lt;br&gt;一些常用的宏，都可以通过查看&lt;code class=&quot;inline&quot;&gt;subr.el&lt;/code&gt;来找到它们。&lt;br&gt;然后，我们介绍了两种与宏相关的变量捕获问题，引出了卫生宏的概念。&lt;/p&gt;&lt;p&gt;下文，我们继续讨论宏，来看一看展开为宏定义的宏之强大威力。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/elisp.html&quot;&gt;GNU Emacs Lisp Reference Manual&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1432683/&quot;&gt;On Lisp&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/3864436/&quot;&gt;Let Over Lambda&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;http://www.scheme.com/tspl4/&quot;&gt;The Scheme Programming Language&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-07-34106490</guid>
<pubDate>Wed, 07 Mar 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
