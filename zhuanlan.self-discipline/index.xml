<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>业余程序员的个人修养</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Tue, 20 Mar 2018 09:28:41 +0800</lastBuildDate>
<item>
<title>你好，类型（三）：Combinatory logic</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-20-34699469.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34699469&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-287adfd6b025ac4b76c62ee1f9ff40d5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;698&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上一篇中，我们介绍了 &lt;equation&gt;\lambda&lt;/equation&gt; 演算，它是由一堆&lt;b&gt;合法的符号&lt;/b&gt;和一些&lt;b&gt;推导规则&lt;/b&gt;构成的&lt;b&gt;公理系统&lt;/b&gt;，&lt;br&gt;在众多 &lt;equation&gt;\lambda&lt;/equation&gt; 演算中，我们介绍了最常用的 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 系统，&lt;br&gt;它指定了 &lt;equation&gt;\alpha&lt;/equation&gt; 和 &lt;equation&gt;\beta&lt;/equation&gt; 两种对 &lt;equation&gt;\lambda&lt;/equation&gt; 项的变换规则。&lt;/p&gt;&lt;p&gt;作为形式系统，上一篇中，我们展现了它的编码能力，&lt;br&gt;将邱奇编码，与公理集合论中自然数的归纳集定义，进行了对比。&lt;/p&gt;&lt;p&gt;本文我们将介绍另一套形式系统，&lt;b&gt;组合子逻辑&lt;/b&gt;（combinatory logic）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 组合子逻辑&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ef80bd38f8b0ceeaa3a69f47020c193d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;379&quot; data-rawheight=&quot;133&quot;&gt;&lt;p&gt;&lt;equation&gt;CL&lt;/equation&gt; （&lt;b&gt;组合子逻辑&lt;/b&gt;），与 &lt;equation&gt;\lambda&lt;/equation&gt; 演算很相似，只是不需要对变量进行绑定，&lt;br&gt;和函数作用在值上不同的是，组合子作用在函数上，从而生成另一个函数。&lt;/p&gt;&lt;p&gt;例如，我们可以定义一个组合子 &lt;equation&gt;B&lt;/equation&gt; ，使得 &lt;equation&gt;(B(f,g))(x) = f(g(x))&lt;/equation&gt; ，&lt;br&gt;其中， &lt;equation&gt;f&lt;/equation&gt; 和 &lt;equation&gt;g&lt;/equation&gt; 都是函数。&lt;/p&gt;&lt;p&gt;为了避免过早的谈及语义，我们和 &lt;equation&gt;\lambda&lt;/equation&gt; 演算一样，使用公理化的方法来定义它，&lt;br&gt;首先我们要说明什么是&lt;b&gt;公理&lt;/b&gt;，即什么是&lt;b&gt;合法的 &lt;equation&gt;CL&lt;/equation&gt; 项&lt;/b&gt;，&lt;br&gt;（1）所有的变量，常量，以及组合子 &lt;equation&gt;I&lt;/equation&gt; ， &lt;equation&gt;K&lt;/equation&gt; ， &lt;equation&gt;S&lt;/equation&gt; ，都是合法的 &lt;equation&gt;CL&lt;/equation&gt; 项，&lt;br&gt;（2）如果 &lt;equation&gt;X&lt;/equation&gt; 和 &lt;equation&gt;Y&lt;/equation&gt; 是合法的 &lt;equation&gt;CL&lt;/equation&gt; 项，那么 &lt;equation&gt;(XY)&lt;/equation&gt; 也是。&lt;/p&gt;&lt;p&gt;例如，以下字符串都是合法的 &lt;equation&gt;CL&lt;/equation&gt; 项， &lt;equation&gt;((S(KS))K)&lt;/equation&gt; ， &lt;equation&gt;((S(Kv_0))((SK)K))&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;同样为了简化，某些情况下括号是可以省略的，如果我们默认各个 &lt;equation&gt;CL&lt;/equation&gt; 项都是左结合的，&lt;br&gt;因此， &lt;equation&gt;(((UV)W)X)&lt;/equation&gt; 可以简写为 &lt;equation&gt;UVWX&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. Weak reduction&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-039de867b1267bba559051a625e3300a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;340&quot;&gt;&lt;p&gt;现在，我们要完成公理化的第二步了，那就是给合法的 &lt;equation&gt;CL&lt;/equation&gt; 项指定&lt;b&gt;变换规则&lt;/b&gt;，&lt;br&gt;在 &lt;equation&gt;CL&lt;/equation&gt; （组合子逻辑中）中，我们称之为&lt;b&gt;weak reduction&lt;/b&gt;，即我们令，&lt;br&gt;（1） &lt;equation&gt;IX&lt;/equation&gt; ，可以变换为 &lt;equation&gt;X&lt;/equation&gt; ，&lt;br&gt;（2） &lt;equation&gt;KXY&lt;/equation&gt; ，可以变换为 &lt;equation&gt;X&lt;/equation&gt; ，&lt;br&gt;（3） &lt;equation&gt;SXYZ&lt;/equation&gt; ，可以变换为 &lt;equation&gt;XZ(YZ)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;U&lt;/equation&gt; 经过有限步weak reduction转换为 &lt;equation&gt;V&lt;/equation&gt; ，就写为 &lt;equation&gt;U\triangleright_w V&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;与 &lt;equation&gt;\lambda&lt;/equation&gt; 项的 &lt;equation&gt;\beta&lt;/equation&gt; 范式一样，我们将不能再继续进行weak reduction的 &lt;equation&gt;CL&lt;/equation&gt; 项，&lt;br&gt;称为&lt;b&gt;weak范式&lt;/b&gt;（weak normal form）。&lt;/p&gt;&lt;p&gt;我们来看一个例子，设 &lt;equation&gt;B=S(KS)K&lt;/equation&gt; ，来计算 &lt;equation&gt;BXYZ&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;BXYZ=S(KS)KXYZ&lt;/equation&gt; &lt;br&gt; &lt;equation&gt;\triangleright_w KSX(KX)YZ&lt;/equation&gt; ，因为 &lt;equation&gt;S(KS)KX\triangleright_w KSX(KX)&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\triangleright_w S(KX)YZ&lt;/equation&gt; ，因为 &lt;equation&gt;KSX\triangleright_w S&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\triangleright_w KXZ(YZ)&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\triangleright_w X(YZ)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;有了合法的 &lt;equation&gt;CL&lt;/equation&gt; 项（公理），以及weak reduction（推导规则），&lt;br&gt;我们就建立了另一个形式系统 &lt;equation&gt;CL_w&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3.&lt;/b&gt; &lt;b&gt;CL与&lt;i&gt;λ&lt;/i&gt;演算之间的关系&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9d8d89d30817ab781c9e69e1a14bb7eb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;513&quot; data-rawheight=&quot;190&quot;&gt;&lt;p&gt;以上我们看到 &lt;equation&gt;CL&lt;/equation&gt; 项，似乎只能进行项的应用（application）操作，&lt;br&gt;对应于 &lt;equation&gt;\lambda&lt;/equation&gt; 项的用法为 &lt;equation&gt;(MN)&lt;/equation&gt; ，&lt;br&gt;然而，其实 &lt;equation&gt;CL&lt;/equation&gt; 的威力却不止于此，它的&lt;b&gt;计算能力&lt;/b&gt;是与 &lt;equation&gt;\lambda&lt;/equation&gt; 演算相当的。&lt;/p&gt;&lt;p&gt;为了证明等价性，建立 &lt;equation&gt;CL&lt;/equation&gt; 项与 &lt;equation&gt;\lambda&lt;/equation&gt; 项之间的关系，&lt;br&gt;现在我们用 &lt;equation&gt;I&lt;/equation&gt; ， &lt;equation&gt;K&lt;/equation&gt; ， &lt;equation&gt;S&lt;/equation&gt; 三个组合子，来定义与 &lt;equation&gt;\lambda x.M&lt;/equation&gt; 相似的概念。&lt;/p&gt;&lt;p&gt;对于任意的 &lt;equation&gt;CL&lt;/equation&gt; 项 &lt;equation&gt;M&lt;/equation&gt; ，以及任意的变量 &lt;equation&gt;x&lt;/equation&gt; ，我们定义 &lt;equation&gt;[x].M&lt;/equation&gt; 用如下方式表示，&lt;br&gt;（1） &lt;equation&gt;[x].M=KM&lt;/equation&gt; ，如果 &lt;equation&gt;M&lt;/equation&gt; 中不含有 &lt;equation&gt;x&lt;/equation&gt; ，&lt;br&gt;（2） &lt;equation&gt;[x].x=I&lt;/equation&gt; ，&lt;br&gt;（3） &lt;equation&gt;[x].Ux=U&lt;/equation&gt; ，如果 &lt;equation&gt;U&lt;/equation&gt; 中不含有 &lt;equation&gt;x&lt;/equation&gt; ，&lt;br&gt;（4） &lt;equation&gt;[x].UV=S([x].U)([x].V)&lt;/equation&gt; ，如果（1）和（3）都不适用的话。&lt;/p&gt;&lt;p&gt;例如，&lt;br&gt; &lt;equation&gt;[x].xy=S([x].x)([x].y)=SI(Ky)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;可见， &lt;equation&gt;[x].M&lt;/equation&gt; 可以完全用 &lt;equation&gt;I&lt;/equation&gt; ， &lt;equation&gt;K&lt;/equation&gt; ， &lt;equation&gt;S&lt;/equation&gt; 三个组合子来构建出来，&lt;br&gt;它表示了与 &lt;equation&gt;\lambda x.M&lt;/equation&gt; 相对应的概念。&lt;/p&gt;&lt;p&gt;因此，我们可以建立 &lt;equation&gt;\lambda&lt;/equation&gt; 项与 &lt;equation&gt;CL&lt;/equation&gt; 项的对应关系了，&lt;br&gt;在 &lt;equation&gt;CL&lt;/equation&gt; 中， &lt;equation&gt;X=Y&lt;/equation&gt; ，相当于 &lt;equation&gt;\lambda&lt;/equation&gt; 演算中， &lt;equation&gt;X\equiv_\alpha Y&lt;/equation&gt; ，可以统一记为 &lt;equation&gt;X\equiv Y&lt;/equation&gt; 。&lt;br&gt; &lt;equation&gt;X\triangleright_w Y&lt;/equation&gt; ，相当于 &lt;equation&gt;X\triangleright_\beta Y&lt;/equation&gt; ，可以统一记为 &lt;equation&gt;X\triangleright_{\beta,w} Y&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;相应的， &lt;equation&gt;I&lt;/equation&gt; ， &lt;equation&gt;K&lt;/equation&gt; ， &lt;equation&gt;S&lt;/equation&gt; 也可以使用 &lt;equation&gt;\lambda&lt;/equation&gt; 项来表示，&lt;br&gt; &lt;equation&gt;I=\lambda x.x&lt;/equation&gt; ， &lt;equation&gt;K=\lambda xy.x&lt;/equation&gt; ， &lt;equation&gt;S=\lambda xyz.xz(yz)&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4. 不动点定理&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在 &lt;equation&gt;\lambda&lt;/equation&gt; 演算和 &lt;equation&gt;CL&lt;/equation&gt; 中，存在组合子 &lt;equation&gt;Y&lt;/equation&gt; ，使得 &lt;equation&gt;Yx\triangleright_{\beta,w} x(Yx)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;证明：令 &lt;equation&gt;U=\lambda ux.x(uux)&lt;/equation&gt; ， &lt;equation&gt;Y=UU&lt;/equation&gt; ，则，&lt;br&gt; &lt;equation&gt;Yx=(\lambda u.(\lambda x.x(uux)))Ux=x(UUx)=x(Yx)&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文我们用公理化的方法，创建了另一个形式系统 &lt;equation&gt;CL_w&lt;/equation&gt; ，&lt;br&gt;接着，我们发现 &lt;equation&gt;CL_w&lt;/equation&gt; 实际上是与 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 等价的。&lt;/p&gt;&lt;p&gt;可悲的是，知道 &lt;equation&gt;\lambda&lt;/equation&gt; 演算的人很多，&lt;br&gt;但是知道 &lt;equation&gt;CL&lt;/equation&gt; （组合子逻辑）的人却很少，这简直是不可思议的。&lt;br&gt;下文中，我们将继续沿着公理化和形式系统的道路向前走，敲开数理逻辑的大门。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/4323391/&quot;&gt;Lambda-Calculus and Combinators，an Introduction&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-20-34699469</guid>
<pubDate>Tue, 20 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（二）：Lambda calculus</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-19-34679052.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34679052&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;1. 匿名函数&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-87da900f32e0f115836e7d63a9a89421_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;395&quot; data-rawheight=&quot;376&quot;&gt;&lt;p&gt;现在很多种编程语言都支持匿名函数了，&lt;br&gt;例如，&lt;a href=&quot;https://msdn.microsoft.com/zh-sg/library/bb397687&quot;&gt;C# 3.0&lt;/a&gt;，&lt;a href=&quot;https://zh.wikipedia.org/wiki/C%2B%2B11&quot;&gt;C++ 11&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_version_history#Java_SE_8&quot;&gt;Java 8&lt;/a&gt;中的lambda表达式，&lt;br&gt;又例如，&lt;a href=&quot;https://docs.python.org/release/2.2.2/ref/ref.html&quot;&gt;Python 2.2.2&lt;/a&gt;中的lambda，&lt;a href=&quot;http://www-archive.mozilla.org/js/language/E262-3.pdf&quot;&gt;ECMAScript 3&lt;/a&gt;的匿名函数，&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ECMAScript 2015&lt;/a&gt;的箭头函数（arrow function）等等。&lt;/p&gt;&lt;p&gt;更不论，&lt;a href=&quot;https://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp&quot;&gt;Lisp&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_ML&quot;&gt;Standard ML&lt;/a&gt;，这些函数式编程语言了。&lt;/p&gt;&lt;p&gt;越来越多的语言拥抱匿名函数，是因为在很多场景中，我们无需给函数事先指定一个名字，&lt;br&gt;并且结合&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E4%BD%9C%E7%94%A8%E5%9F%9F&quot;&gt;词法作用域&lt;/a&gt;和高阶函数，会使某些问题用更直观的方式得以解决。&lt;/p&gt;&lt;p&gt;从理论上来讲，匿名函数具有和一般函数同样的计算能力，&lt;br&gt;使用某些技术手段，可以让匿名函数支持递归运算，从而完成任何&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E5%8F%AF%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0&quot;&gt;图灵可计算&lt;/a&gt;的任务。&lt;/p&gt;&lt;p&gt;然而，要想理解这一切，我们首先还得静下心来，从基础的 &lt;equation&gt;\lambda&lt;/equation&gt; 演算开始吧。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 自然数&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1ad49d6d8ff89cd3eb9d8e93fb8e2aec_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;495&quot; data-rawheight=&quot;316&quot;&gt;&lt;p&gt;&lt;equation&gt;\lambda&lt;/equation&gt; 演算听起来是一个高大上的概念，实际上它只是一套“符号推导系统”。&lt;/p&gt;&lt;p&gt;人们首先定义某些&lt;b&gt;合法的符号&lt;/b&gt;，然后再定义一些符号&lt;b&gt;推导规则&lt;/b&gt;，&lt;br&gt;最后就可以计算了，从一堆合法的符号得到另一堆，&lt;br&gt;这种推导过程称之为“&lt;b&gt;演算&lt;/b&gt;”。&lt;/p&gt;&lt;p&gt;为了让 &lt;equation&gt;\lambda&lt;/equation&gt; 演算更容易被接受，我们暂时先岔开话题，看看自然数是怎么定义的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.1 Peano系统&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1889年，皮亚诺（&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9C%B1%E5%A1%9E%E4%BD%A9%C2%B7%E7%9A%AE%E4%BA%9E%E8%AB%BE&quot;&gt;Peano&lt;/a&gt;）为了给出自然数的集合论定义，&lt;br&gt;他建立了一个包含5条公设的&lt;b&gt;公理系统&lt;/b&gt;，后人称之为&lt;b&gt;Peano系统&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;Peano系统是满足以下公设的有序三元组 &lt;equation&gt;(M,F,e)&lt;/equation&gt; ，&lt;br&gt;其中 &lt;equation&gt;M&lt;/equation&gt; 为一个集合， &lt;equation&gt;F&lt;/equation&gt; 是 &lt;equation&gt;M&lt;/equation&gt; 到 &lt;equation&gt;M&lt;/equation&gt; 的函数， &lt;equation&gt;e&lt;/equation&gt; 为首元素，&lt;br&gt;（1） &lt;equation&gt;e\in M&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;M&lt;/equation&gt; 在 &lt;equation&gt;F&lt;/equation&gt; 下是封闭的&lt;br&gt;（3） &lt;equation&gt;e&lt;/equation&gt; 不在 &lt;equation&gt;F&lt;/equation&gt; 的值域中&lt;br&gt;（4） &lt;equation&gt;F&lt;/equation&gt; 是单射&lt;br&gt;（5）如果 &lt;equation&gt;M&lt;/equation&gt; 的子集 &lt;equation&gt;A&lt;/equation&gt; 满足， &lt;equation&gt;e\in A&lt;/equation&gt; ，且 &lt;equation&gt;A&lt;/equation&gt; 在 &lt;equation&gt;F&lt;/equation&gt; 下封闭，则 &lt;equation&gt;A=M&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 后继&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;A&lt;/equation&gt; 为一个集合，我们称 &lt;equation&gt;A\cup\{A\}&lt;/equation&gt; 为 &lt;equation&gt;A&lt;/equation&gt; 的&lt;b&gt;后继&lt;/b&gt;，记作 &lt;equation&gt;A^+&lt;/equation&gt; ，&lt;br&gt;求集合后继的操作，称为&lt;b&gt;后继运算&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如，&lt;br&gt; &lt;equation&gt;\varnothing^+=\varnothing\cup\{\varnothing\}=\{\varnothing\}&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\varnothing^{++}=\varnothing^+\cup\{\varnothing^+\}=\{\varnothing\}\cup\{\{\varnothing\}\}=\{\varnothing,\{\varnothing\}\}&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\varnothing^{+++}=\{\varnothing,\{\varnothing\},\{\varnothing,\{\varnothing\}\}\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3 归纳集&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;A&lt;/equation&gt; 为一个集合，若 &lt;equation&gt;A&lt;/equation&gt; 满足，&lt;br&gt;（1） &lt;equation&gt;\varnothing\in A&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\forall a\in A&lt;/equation&gt; ， &lt;equation&gt;a^+\in A&lt;/equation&gt; &lt;br&gt;则称 &lt;equation&gt;A&lt;/equation&gt; 是&lt;b&gt;归纳集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\{\varnothing,\varnothing^+,\varnothing^{++},\cdots\}&lt;/equation&gt; 是一个归纳集。&lt;br&gt;从归纳集的定义可知， &lt;equation&gt;\varnothing,\varnothing^+,\varnothing^{++},\cdots&lt;/equation&gt; 是所有归纳集的元素，&lt;br&gt;于是，可以将它们定义为&lt;b&gt;自然数&lt;/b&gt;，自然数集记为 &lt;equation&gt;N&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;\sigma:N\rightarrow N&lt;/equation&gt; ，满足 &lt;equation&gt;\sigma(n)=n^+&lt;/equation&gt; ，则称 &lt;equation&gt;\sigma&lt;/equation&gt; 为&lt;b&gt;后继函数&lt;/b&gt;，&lt;br&gt;则可以证明 &lt;equation&gt;(N,\sigma,\varnothing)&lt;/equation&gt; 是一个Peano系统。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3.&lt;/b&gt; &lt;b&gt;&lt;i&gt;λ&lt;/i&gt;演算&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-72ffbc783aaa5cdc2ea8cabeae5f415a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;496&quot; data-rawheight=&quot;213&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97&quot;&gt;λ演算&lt;/a&gt;，是1930年由邱奇（&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87&quot;&gt;Alonzo Church&lt;/a&gt;）发明的一套&lt;a href=&quot;https://zh.wikipedia.org/zh/%E5%BD%A2%E5%BC%8F%E7%B3%BB%E7%B5%B1&quot;&gt;形式系统&lt;/a&gt;，&lt;br&gt;它是从具体的函数定义，函数调用和函数复合中，抽象出来的数学概念。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.1 语法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;形式上， &lt;equation&gt;\lambda&lt;/equation&gt; 演算由3种语法项（term）组成，&lt;br&gt;（1）一个变量 &lt;equation&gt;x&lt;/equation&gt; 本身，是一个合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，&lt;br&gt;（2） &lt;equation&gt;\lambda x.t_1&lt;/equation&gt; ，是一个合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，称为从项 &lt;equation&gt;t_1&lt;/equation&gt; 中抽象出 &lt;equation&gt;x&lt;/equation&gt; ，&lt;br&gt;（3） &lt;equation&gt;t_1 t_2&lt;/equation&gt; ，是一个合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，称为将 &lt;equation&gt;t_1&lt;/equation&gt; 应用于 &lt;equation&gt;t_2&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;(\lambda x.(xy))&lt;/equation&gt; ， &lt;equation&gt;(x (\lambda x.(\lambda x.x)))&lt;/equation&gt; ， &lt;equation&gt;((\lambda y.y)(\lambda x.(xy)))&lt;/equation&gt; ，都是合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项。&lt;br&gt;为了简化描述，我们通常会省略一些括号，以上三个 &lt;equation&gt;\lambda&lt;/equation&gt; 项可以写成，&lt;br&gt; &lt;equation&gt;\lambda x.xy&lt;/equation&gt; ， &lt;equation&gt;x (\lambda x.\lambda x.x)&lt;/equation&gt; ， &lt;equation&gt;(\lambda y.y)(\lambda x.xy)&lt;/equation&gt; ，&lt;br&gt;对于形如 &lt;equation&gt;\lambda x.t_1&lt;/equation&gt; 的 &lt;equation&gt;\lambda&lt;/equation&gt; 项来说，“ &lt;equation&gt;.&lt;/equation&gt; ”后面会&lt;b&gt;向右包含尽量多&lt;/b&gt;的内容。&lt;/p&gt;&lt;p&gt;现在我们有了一堆合法的字符串了。&lt;br&gt;可是，在给定&lt;b&gt;推导规则&lt;/b&gt;之前，这些字符串之间都是没有关联的。&lt;br&gt;而且，我们也还没有为这些符号指定语义，它们到底代表什么也是不清楚的。&lt;/p&gt;&lt;p&gt;很显然&lt;b&gt;给这些符号指定不同的推导规则，会得到不同的公理系统&lt;/b&gt;，&lt;br&gt;在众多 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统中，最简单的是 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 系统，它指定了 &lt;equation&gt;\alpha&lt;/equation&gt; 和 &lt;equation&gt;\beta&lt;/equation&gt; 两种变换。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.2&lt;/b&gt; &lt;b&gt;&lt;i&gt;α&lt;/i&gt;变换&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;\lambda&lt;/equation&gt; 项 &lt;equation&gt;P&lt;/equation&gt; 中包含了 &lt;equation&gt;\lambda x.M&lt;/equation&gt; ，&lt;br&gt;则我们可以把 &lt;equation&gt;M&lt;/equation&gt; 中所有&lt;b&gt;自由出现&lt;/b&gt;的 &lt;equation&gt;x&lt;/equation&gt; ，全都换成 &lt;equation&gt;y&lt;/equation&gt; ，即 &lt;equation&gt;\lambda y.[y/x]M&lt;/equation&gt; ，&lt;br&gt;这种更名变换，称为 &lt;equation&gt;\alpha&lt;/equation&gt; &lt;b&gt;变换&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;其中，“&lt;b&gt;自由出现&lt;/b&gt;”指的是 &lt;equation&gt;x&lt;/equation&gt; 不被其他 &lt;equation&gt;\lambda&lt;/equation&gt; 抽象所绑定，&lt;br&gt;例如， &lt;equation&gt;\lambda x.xy&lt;/equation&gt; 中， &lt;equation&gt;y&lt;/equation&gt; 是自由的，&lt;br&gt;而 &lt;equation&gt;x&lt;/equation&gt; 就不是自由的，因为它被 &lt;equation&gt;\lambda x.&lt;/equation&gt; 绑定了。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;P&lt;/equation&gt; 可以经过有限步 &lt;equation&gt;\alpha&lt;/equation&gt; 变换转换为 &lt;equation&gt;Q&lt;/equation&gt; ，就写为 &lt;equation&gt;P\equiv_\alpha Q&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;例如，&lt;br&gt; &lt;equation&gt;\lambda xy.x(xy)=\lambda x.(\lambda y.x(xy))&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;\equiv_\alpha\lambda x.(\lambda v.x(xv))&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;\equiv_\alpha\lambda u.(\lambda v.u(uv))&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;=\lambda uv.u(uv)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;3.3&lt;/b&gt; &lt;b&gt;&lt;i&gt;β&lt;/i&gt;变换&lt;/b&gt;&lt;/p&gt;&lt;p&gt;形如 &lt;equation&gt;(\lambda x.M)N&lt;/equation&gt; 的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，可以经由&lt;b&gt;&lt;equation&gt;\beta&lt;/equation&gt; 变换&lt;/b&gt;转换为 &lt;equation&gt;[N/x]M&lt;/equation&gt; ，&lt;br&gt;指的是，把 &lt;equation&gt;M&lt;/equation&gt; 中所有自由出现的 &lt;equation&gt;x&lt;/equation&gt; 都换成 &lt;equation&gt;N&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;P&lt;/equation&gt; 可以经过有限步 &lt;equation&gt;\beta&lt;/equation&gt; 变换转换为 &lt;equation&gt;Q&lt;/equation&gt; ，就写为 &lt;equation&gt;P\triangleright_\beta Q&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;例如，&lt;br&gt; &lt;equation&gt;(\lambda x.x(xy))N\triangleright_\beta N(Ny)&lt;/equation&gt; &lt;equation&gt;(\lambda x.xx)(\lambda x.xx)\triangleright_\beta [(\lambda x.xx)/x](xx)=(\lambda x.xx)(\lambda x.xx)\triangleright_\beta\cdots&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;我们发现，某些 &lt;equation&gt;\lambda&lt;/equation&gt; 项，可以无限进行 &lt;equation&gt;\beta&lt;/equation&gt; 变换。&lt;br&gt;而那些最终会终止的 &lt;equation&gt;\beta&lt;/equation&gt; 变换的结果，称为 &lt;b&gt;&lt;equation&gt;\beta&lt;/equation&gt; 范式&lt;/b&gt;（ &lt;equation&gt;\beta&lt;/equation&gt;  normal form）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.4 邱奇编码&lt;/b&gt;&lt;/p&gt;&lt;p&gt;现在我们有 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 公理系统了，就可以依照 &lt;equation&gt;\alpha&lt;/equation&gt; 或 &lt;equation&gt;\beta&lt;/equation&gt; 变换，对任意合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项进行变换。&lt;/p&gt;&lt;p&gt;假设我们有一个 &lt;equation&gt;\lambda&lt;/equation&gt; 项， &lt;equation&gt;\lambda f.\lambda x.x&lt;/equation&gt; ，&lt;br&gt;还有另外一个 &lt;equation&gt;\lambda&lt;/equation&gt; 项， &lt;equation&gt;\lambda n.\lambda f.\lambda x.f(nfx)&lt;/equation&gt; ，记为 &lt;equation&gt;succ&lt;/equation&gt; ，&lt;br&gt;我们来计算， &lt;equation&gt;succ(\lambda f.\lambda x.x)&lt;/equation&gt; ，&lt;br&gt;可得， &lt;equation&gt;(\lambda n.\lambda f.\lambda x.f(nfx))(\lambda f.\lambda x.x)\triangleright_\beta\lambda f.\lambda x.fx&lt;/equation&gt; ，&lt;br&gt;我们再运用一次 &lt;equation&gt;succ&lt;/equation&gt; ， &lt;equation&gt;succ(\lambda f.\lambda x.fx)\triangleright_\beta\lambda f.\lambda x.f(fx)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们发现每次应用 &lt;equation&gt;succ&lt;/equation&gt; ，都会给 &lt;equation&gt;\lambda f.\lambda x.x&lt;/equation&gt; 中加一个 &lt;equation&gt;f&lt;/equation&gt; ，&lt;br&gt;最终我们可以得到以下这些 &lt;equation&gt;\lambda&lt;/equation&gt; 项，&lt;br&gt; &lt;equation&gt;\lambda f.\lambda x.x&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;\lambda f.\lambda x.fx&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;\lambda f.\lambda x.f(fx)&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;\lambda f.\lambda x.f(f(fx))&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;\cdots&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;\lambda f.\lambda x.f^nx&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;如果我们记 &lt;equation&gt;\lambda f.\lambda x.x\equiv 0&lt;/equation&gt; ， &lt;equation&gt;\lambda f.\lambda x.fx\equiv 1&lt;/equation&gt; ， &lt;equation&gt;\cdots&lt;/equation&gt; ， &lt;equation&gt;\lambda f.\lambda x.f^nx\equiv n&lt;/equation&gt; ，&lt;br&gt;我们就得到了&lt;b&gt;自然数的另一种表示方式&lt;/b&gt;，称之为&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%82%B1%E5%A5%87%E6%95%B0&quot;&gt;邱奇编码&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;可以看到邱奇编码与归纳集之间有异曲同工之妙。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.5 语义&lt;/b&gt;&lt;/p&gt;&lt;p&gt;到目前为止，我们并未谈及 &lt;equation&gt;\lambda&lt;/equation&gt; 项到底表示什么&lt;b&gt;含义&lt;/b&gt;，&lt;br&gt;虽然 &lt;equation&gt;\lambda x.M&lt;/equation&gt; 看起来像是函数定义， &lt;equation&gt;(\lambda x.M)N&lt;/equation&gt; 看起来像是函数调用。&lt;/p&gt;&lt;p&gt;我们谨慎的使用&lt;b&gt;公理化方法&lt;/b&gt;，从什么是合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项出发，&lt;br&gt;定义 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 系统中的&lt;b&gt;公理&lt;/b&gt;——合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，&lt;br&gt;然后又指定了该系统中的&lt;b&gt;推导规则&lt;/b&gt;—— &lt;equation&gt;\alpha&lt;/equation&gt; 和 &lt;equation&gt;\beta&lt;/equation&gt; 变换，&lt;br&gt;最终得到了一个形式化的公理系统（公理+推导规则）。&lt;/p&gt;&lt;p&gt;后文中，我们将谈及 &lt;equation&gt;\lambda&lt;/equation&gt; 项的语义，然后再逐渐给它加上类型。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/1230394/&quot;&gt;离散数学教程&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/4323391/&quot;&gt;Lambda-Calculus and Combinators，an Introduction&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://www.irif.fr/~mellies/mpri/mpri-ens/biblio/Selinger-Lambda-Calculus-Notes.pdf&quot;&gt;Lecture Notes on the Lambda Calculus&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-19-34679052</guid>
<pubDate>Mon, 19 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（一）：开篇</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-18-34669807.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34669807&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类型（type），是编程语言中一个经常被人们提及的概念，&lt;br&gt;当我们看待一门编程语言的时候，言必谈之&lt;b&gt;类型系统&lt;/b&gt;（type system）。&lt;/p&gt;&lt;p&gt;它到底是显式类型的（explicit typing），还是隐式类型的（implicit typing），&lt;br&gt;是静态类型的（static typing），还是动态类型的（dynamic typing），&lt;br&gt;类型检查（type check）是较强的（stronger），还是较弱的（weaker）。&lt;/p&gt;&lt;p&gt;它是否支持高阶类型（high-order type），是否支持递归类型（recusive type），&lt;br&gt;是否支持子类型（subtype），是否支持多态（polymorphism）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;这些都是一个有主见的技术爱好者，乐于去了解的内容。&lt;/b&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;然而，我发现理解它们并不容易，我们欠缺最基本的数理逻辑和证明论相关的知识。&lt;br&gt;类型系统，可以看做是附着在语言语法之上的一套符号证明系统。&lt;/p&gt;&lt;blockquote&gt;In programming languages, a type system is a set of rules that assigns a property called type to the various constructs of a computer program, such as variables, expressions, functions or modules.&lt;/blockquote&gt;&lt;p&gt;给表达式确定类型的过程，相当于对程序应该具备的属性做形式证明，&lt;br&gt;因此，&lt;b&gt;数理逻辑是我们的朋友&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;另一方面，从语义（semantics）角度对类型进行理解，我们会遇到更大的阻碍，&lt;br&gt;因为，这又涉及到了公理集合论和代数学相关的必备知识。&lt;/p&gt;&lt;p&gt;&lt;b&gt;不过，这些仍然是一个有主见的技术爱好者，乐于去了解的内容。&lt;/b&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;本系列文章，&lt;br&gt;我计划从无类型 &lt;equation&gt;\lambda&lt;/equation&gt; 演算开始，逐步介绍简单类型（simply typed） &lt;equation&gt;\lambda&lt;/equation&gt; 演算，&lt;br&gt;介绍递归类型和不动点（fixed point）之间关系，介绍组合子逻辑（combinatory logic）。&lt;/p&gt;&lt;p&gt;然后，回归到本原，学习命题逻辑和一阶谓词逻辑相关的内容，&lt;br&gt;建立起逻辑学与类型理论之间的桥梁。&lt;/p&gt;&lt;p&gt;时间允许的话，我们还可以探讨模型论相关的内容，在补充了代数学相关的内容之后，&lt;br&gt;我们就可以讨论CPO，Henkin模型，Kripke模型，以及笛卡儿闭范畴（CCC）了。&lt;/p&gt;&lt;p&gt;有的人说，讨论这些其实一点用都没有，&lt;br&gt;&lt;b&gt;我只想说，作为一个有主见的技术爱好者，请别忘了咱们的初心是什么。&lt;/b&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-18-34669807</guid>
<pubDate>Sun, 18 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（九）：最小不动点定理</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-17-34604220.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34604220&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们讨论了集合上的偏序结构，之所以谈论它们是因为，&lt;br&gt;完全偏序集上的连续函数具有最小不动点，这称之为最小不动点定理，&lt;br&gt;除了集合论的一些知识之外，我们还要讨论到底什么是连续函数，以及什么是完全偏序集。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;有向子集与完全偏序&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-798a5d7b110884184ff24d74e9a1378b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;246&quot; data-rawheight=&quot;197&quot;&gt;&lt;p&gt;偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 的非空子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; 叫做&lt;b&gt;有向子集&lt;/b&gt;（directed subset），&lt;br&gt;当且仅当，对于 &lt;equation&gt;S&lt;/equation&gt; 中的任意元素 &lt;equation&gt;a,b\in S&lt;/equation&gt; ，&lt;br&gt;存在 &lt;equation&gt;S&lt;/equation&gt; 中的一个元素 &lt;equation&gt;c&lt;/equation&gt; ，有 &lt;equation&gt;a\leqslant c&lt;/equation&gt; 且 &lt;equation&gt;b\leqslant c&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果一个偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 的每个有向子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; 都有上确界（记为 &lt;equation&gt;\bigvee S&lt;/equation&gt; ），&lt;br&gt;就称它是一个&lt;b&gt;有向完全偏序集&lt;/b&gt;，&lt;br&gt;此外，如果它还有最小元，就称它是一个&lt;b&gt;完全偏序集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;注意，完全偏序集并不是每一个子集都有上确界，&lt;br&gt;而是它的每一个有向子集都有上确界。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;连续函数&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-1540a3cecd3b2e0877758d2ddfb0401f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;228&quot; data-rawheight=&quot;124&quot;&gt;&lt;p&gt;假设 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 与 &lt;equation&gt;(E,\leqslant )&lt;/equation&gt; 是完全偏序集， &lt;equation&gt;f:D\rightarrow E&lt;/equation&gt; 是集合上定义的一个函数，&lt;br&gt;如果 &lt;equation&gt;S\subseteq D&lt;/equation&gt; ，则 &lt;equation&gt;f(S)&lt;/equation&gt; 为 &lt;equation&gt;E&lt;/equation&gt; 的子集，其中 &lt;equation&gt;f(S)=\lbrace f(d)|\ d\in S \rbrace&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;对于任意的 &lt;equation&gt;d,d&#39;\in D&lt;/equation&gt; ，如果 &lt;equation&gt;d\leqslant d&#39;&lt;/equation&gt; 就有 &lt;equation&gt;f(d)\leqslant f(d&#39;)&lt;/equation&gt; ，我们就说 &lt;equation&gt;f&lt;/equation&gt; 是&lt;b&gt;单调的&lt;/b&gt;。&lt;br&gt;可以看出，如果 &lt;equation&gt;f&lt;/equation&gt; 是单调的，且 &lt;equation&gt;S&lt;/equation&gt; 是 &lt;equation&gt;D&lt;/equation&gt; 的有向子集，那么 &lt;equation&gt;f(S)&lt;/equation&gt; 也是 &lt;equation&gt;E&lt;/equation&gt; 的有向子集。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;f&lt;/equation&gt; 是单调的，且对于任意有向子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; ，有 &lt;equation&gt;f(\bigvee S)=\bigvee f(S)&lt;/equation&gt; ，&lt;br&gt;就称 &lt;equation&gt;f&lt;/equation&gt; 是&lt;b&gt;连续的&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;连续函数集上的偏序结构&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-222b5763dca58d03cdca2d16977a654d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;251&quot;&gt;&lt;p&gt;完全偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 到 &lt;equation&gt;(E,\leqslant )&lt;/equation&gt; 的连续函数，也可以定义出一个偏序结构，&lt;br&gt;我们称 &lt;equation&gt;f\leqslant g&lt;/equation&gt; ，当且仅当对于每一个 &lt;equation&gt;d\in D&lt;/equation&gt; ，我们有 &lt;equation&gt;f(d)\leqslant g(d)&lt;/equation&gt; 。&lt;br&gt;这样我们就得到了一个&lt;b&gt;元素为连续函数&lt;/b&gt;的偏序集， &lt;equation&gt;(D\rightarrow E,\leqslant )&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;可以证明， &lt;equation&gt;(D\rightarrow E,\leqslant )&lt;/equation&gt; 也是一个完全偏序集。（证略&lt;/p&gt;&lt;h2&gt;&lt;b&gt;最小不动点定理&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f19cc00b5a9f0b65494bc8bd66858f57_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;683&quot; data-rawheight=&quot;72&quot;&gt;&lt;p&gt;如果 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 是一个完全偏序集，且 &lt;equation&gt;f:D\rightarrow D&lt;/equation&gt; 是连续的，&lt;br&gt;则 &lt;equation&gt;f&lt;/equation&gt; 有&lt;b&gt;最小不动点&lt;/b&gt;， &lt;equation&gt;fix_D\ f=\bigvee \lbrace f^n(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;因为 &lt;equation&gt;\perp&lt;/equation&gt; 是 &lt;equation&gt;D&lt;/equation&gt; 中的最小元，且 &lt;equation&gt;f(\perp )\in D&lt;/equation&gt; ，所以， &lt;equation&gt;\perp \leqslant f(\perp )&lt;/equation&gt; ，&lt;br&gt;因为 &lt;equation&gt;f&lt;/equation&gt; 是连续的，所以 &lt;equation&gt;f&lt;/equation&gt; 也一定是单调的，所以， &lt;equation&gt;f(\perp )\leqslant f^2(\perp )&lt;/equation&gt; ，&lt;br&gt;继而， &lt;equation&gt;f^n(\perp )\leqslant f^{n+1}(\perp )&lt;/equation&gt; ，对于任意的 &lt;equation&gt;n\geqslant 0&lt;/equation&gt; 都成立。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\lbrace f^n(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; 构成了一个全序集，&lt;br&gt;所以，它是完全偏序集 &lt;equation&gt;(D\rightarrow E,\leqslant)&lt;/equation&gt; 的一个有向子集，必有上确界。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;a&lt;/equation&gt; 是上确界， &lt;equation&gt;a=\bigvee \lbrace f^n(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; ，则 &lt;b&gt;&lt;equation&gt;a&lt;/equation&gt; 是 &lt;equation&gt;f&lt;/equation&gt; 的不动点&lt;/b&gt;。&lt;br&gt;因为由 &lt;equation&gt;f&lt;/equation&gt; 的连续性， &lt;equation&gt;f(a)=f(\bigvee \lbrace f^n(\perp )|\ n\geqslant 0 \rbrace )=\bigvee \lbrace f^{(n+1)}(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; ，&lt;br&gt;而 &lt;equation&gt;\lbrace f^n(\perp ) \rbrace&lt;/equation&gt; 与 &lt;equation&gt;\lbrace f^{(n+1)}(\perp ) \rbrace&lt;/equation&gt; 有同样的上确界，所以 &lt;equation&gt;f(a)=a&lt;/equation&gt; ，即 &lt;equation&gt;a&lt;/equation&gt; 是 &lt;equation&gt;f&lt;/equation&gt; 的不动点。&lt;/p&gt;&lt;p&gt;其次， &lt;b&gt;&lt;equation&gt;a&lt;/equation&gt; 是 &lt;equation&gt;f&lt;/equation&gt; 的最小不动点&lt;/b&gt;，&lt;br&gt;假设 &lt;equation&gt;b=f(b)&lt;/equation&gt; 是 &lt;equation&gt;f&lt;/equation&gt; 的任意不动点，因为 &lt;equation&gt;\perp \leqslant b&lt;/equation&gt; ，所以 &lt;equation&gt;f(\perp )\leqslant f(b)&lt;/equation&gt; ，&lt;br&gt;类似的，对于任意的 &lt;equation&gt;n\geqslant 0&lt;/equation&gt; ， &lt;equation&gt;f^n(\perp )\leqslant f^n(b)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;而 &lt;equation&gt;b&lt;/equation&gt; 是 &lt;equation&gt;f&lt;/equation&gt; 的不动点，所以 &lt;equation&gt;f^n(b)=b&lt;/equation&gt; ，因此 &lt;equation&gt;b&lt;/equation&gt; 是集合 &lt;equation&gt;\lbrace f^n(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; 的上界。&lt;br&gt;由于集合的最小上界是 &lt;equation&gt;a&lt;/equation&gt; ，所以有 &lt;equation&gt;a\leqslant b&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;后继函数的不动点&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-85a40c8188217b5e65567daefb51447b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;342&quot; data-rawheight=&quot;147&quot;&gt;&lt;code lang=&quot;haskell&quot;&gt;succ :: Int -&amp;gt; Int
succ n = n+1&lt;/code&gt;&lt;p&gt;在第七篇中，我们说&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;可以得到任意函数的不动点，&lt;br&gt;那么这个&lt;code class=&quot;inline&quot;&gt;succ&lt;/code&gt;函数呢？它有没有不动点？&lt;code class=&quot;inline&quot;&gt;fix succ&lt;/code&gt;是什么？&lt;/p&gt;&lt;p&gt;现在我们有了&lt;b&gt;最小不动点定理&lt;/b&gt;，&lt;br&gt;就得验证&lt;code class=&quot;inline&quot;&gt;succ&lt;/code&gt;所指称的数学函数，是不是一个完全偏序集上的连续函数，&lt;br&gt;如果是的话，它就有不动点。&lt;/p&gt;&lt;p&gt;在第四篇为了表示计算的不可终止性，我们对自然数集进行了扩充， &lt;equation&gt;N\cup \lbrace \perp \rbrace&lt;/equation&gt; ，&lt;br&gt;然后用这个集合作为程序中&lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt;类型的值的解释。&lt;/p&gt;&lt;p&gt;然而， &lt;equation&gt;N\cup \lbrace \perp \rbrace&lt;/equation&gt; 不是一个完全偏序集，原因是它没有上界，&lt;br&gt;如果我们额外加入一个比其他的自然都大的元素 &lt;equation&gt;+\infty&lt;/equation&gt; ，&lt;br&gt;则我们就得到了一个&lt;b&gt;完全偏序集&lt;/b&gt;， &lt;equation&gt;N\cup \lbrace \perp \rbrace\cup \lbrace +\infty \rbrace&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;然后，我们看&lt;code class=&quot;inline&quot;&gt;succ&lt;/code&gt;连续吗？&lt;br&gt;首先，它是单调的，如果我们再定义 &lt;equation&gt;succ(+\infty )=+\infty&lt;/equation&gt; ，&lt;br&gt;就有 &lt;equation&gt;succ(\bigvee N)=\bigvee succ(N)&lt;/equation&gt; ，因此，&lt;code class=&quot;inline&quot;&gt;succ&lt;/code&gt;是一个连续函数。&lt;/p&gt;&lt;p&gt;根据最小不动点定理，&lt;code class=&quot;inline&quot;&gt;succ&lt;/code&gt;的&lt;b&gt;最小不动点&lt;/b&gt;是， &lt;equation&gt;fix\ succ=\bigvee \lbrace succ^n(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;由于 &lt;equation&gt;succ(\perp )=\perp&lt;/equation&gt; ，即对于非终止的输入&lt;code class=&quot;inline&quot;&gt;succ&lt;/code&gt;的计算也不会终止，所以 &lt;equation&gt;succ^n(\perp )=\perp&lt;/equation&gt; ，&lt;br&gt;因此， &lt;equation&gt;fix\ succ=\bigvee \lbrace succ^n(\perp )|\ n\geqslant 0 \rbrace =\perp&lt;/equation&gt; ，&lt;br&gt;即，&lt;code class=&quot;inline&quot;&gt;succ&lt;/code&gt;的最小不动点是 &lt;equation&gt;\perp&lt;/equation&gt; ，&lt;code class=&quot;inline&quot;&gt;fix succ&lt;/code&gt;的&lt;b&gt;计算不会终止&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;求解阶乘函数&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上一篇中，我们证明了阶乘函数&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;是以下函数的不动点，&lt;code class=&quot;inline&quot;&gt;fact = fix g&lt;/code&gt;，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;g :: (Int -&amp;gt; Int) -&amp;gt; Int -&amp;gt; Int
g f n = case n of
  1 -&amp;gt; 1
  _ -&amp;gt; n * f (n-1)&lt;/code&gt;&lt;p&gt;现在我们来看一下，如何运用最小不动点定理来得到这个答案。&lt;br&gt;为了避免篇幅过长，关于&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;函数的连续性证明暂略，&lt;br&gt;我们直接使用公式， &lt;equation&gt;fix\ g=\bigvee \lbrace g^n(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; ，&lt;br&gt;即，&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;函数的&lt;b&gt;最小不动点&lt;/b&gt;，就是集合 &lt;equation&gt;D=\lbrace g^n(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; 的&lt;b&gt;上确界&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;我们先来看一下这个集合 &lt;equation&gt;D&lt;/equation&gt; 中有哪些元素，&lt;br&gt;其中， &lt;equation&gt;g(\perp )\in D&lt;/equation&gt; ，我们将 &lt;equation&gt;\perp&lt;/equation&gt; 传入 &lt;equation&gt;g&lt;/equation&gt; 中，看看会得到什么，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;f1 = \n -&amp;gt; case n of 
  1 -&amp;gt; 1
  _ -&amp;gt; ...&lt;/code&gt;&lt;p&gt;这个函数能计算&lt;code class=&quot;inline&quot;&gt;f1 1&lt;/code&gt;，但是不能计算&lt;code class=&quot;inline&quot;&gt;f1 2&lt;/code&gt;，恰好是&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;函数有限展开的一阶项。&lt;/p&gt;&lt;p&gt;我们再来看 &lt;equation&gt;g^2(\perp )\in D&lt;/equation&gt; ，它等于 &lt;equation&gt;g(f1)&lt;/equation&gt; ，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;f2 = \n -&amp;gt; case n of 
  1 -&amp;gt; 1
  _ -&amp;gt; n * f1 (n-1)&lt;/code&gt;&lt;p&gt;这个函数能计算&lt;code class=&quot;inline&quot;&gt;f2 1&lt;/code&gt;以及&lt;code class=&quot;inline&quot;&gt;f2 2&lt;/code&gt;，但是不能计算&lt;code class=&quot;inline&quot;&gt;f2 3&lt;/code&gt;，&lt;br&gt;恰好是&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;函数展开的二阶项。&lt;/p&gt;&lt;p&gt;由此，我们看出了规律， &lt;equation&gt;g^n(\perp )\in D&lt;/equation&gt; 就是&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;函数有限展开的第 &lt;equation&gt;n&lt;/equation&gt; 阶项。&lt;br&gt;上一篇中，我们已经证明了，当 &lt;equation&gt;n\rightarrow \infty&lt;/equation&gt; 时，它就是&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;函数，&lt;br&gt;考虑到 &lt;equation&gt;f1,f2,\cdots&lt;/equation&gt; 这些函数的序关系，因此，我们有 &lt;equation&gt;fact=\bigvee \lbrace g^n(\perp )|\ n\geqslant 0 \rbrace&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;即，&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;函数就是&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;函数的最小不动点。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;到此为止，我想这个系列的文章已经讨论完了，&lt;br&gt;本系列文章一直围绕着递归函数和不动点进行分析，&lt;br&gt;在内容上可以分为两个部分，前半部分主要与可计算性理论有关，&lt;br&gt;后半部分与不动点定理有关，希望对大家有所帮助。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E9%9B%86%E5%90%88&quot;&gt;有向集合&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E5%81%8F%E5%BA%8F&quot;&gt;完全偏序&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Kleene_fixed-point_theorem&quot;&gt;Kleene fixed-point theorem&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1761918/&quot;&gt;Foundations for Programming Languages&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-17-34604220</guid>
<pubDate>Sat, 17 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（八）：偏序结构</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-16-34576092.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34576092&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上一篇我们介绍了不动点算子和Y组合子，以及Y组合子的具体表现形式，&lt;br&gt;这一篇我们根据不动点算子的性质来证明&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;函数就是&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;函数的不动点。&lt;br&gt;随后，我们回归到了数学中，讨论集合上的一种偏序结构，&lt;br&gt;这为下文完全偏序集，以及完全偏序集上连续函数的不动点定理做好准备。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;不动点算子的性质&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5aa0f01d21740986634a9e6bf34c3d48_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;259&quot; data-rawheight=&quot;246&quot;&gt;&lt;p&gt;上文我们介绍了不动点算子&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;，&lt;br&gt;它可以用来求取任意函数的不动点。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fix :: (a -&amp;gt; a) -&amp;gt; a
fix f = let x = f x in x&lt;/code&gt;&lt;p&gt;并且我们说以下函数的不动点为&lt;code class=&quot;inline&quot;&gt;fact = fix g&lt;/code&gt;，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;g :: (Int -&amp;gt; Int) -&amp;gt; Int -&amp;gt; Int
g f n = case n of
  1 -&amp;gt; 1
  _ -&amp;gt; n * f (n-1)&lt;/code&gt;&lt;p&gt;但是上文中，我们只是对它们的计算结果进行比对，&lt;br&gt;并没有对它进行&lt;b&gt;证明&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;考虑到&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;的性质，&lt;code class=&quot;inline&quot;&gt;fix g = g (fix g)&lt;/code&gt;，&lt;br&gt;（因为&lt;code class=&quot;inline&quot;&gt;fix g&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的不动点，令&lt;code class=&quot;inline&quot;&gt;h = fix g&lt;/code&gt;，上式为&lt;code class=&quot;inline&quot;&gt;h = g h&lt;/code&gt; &lt;br&gt;我们可以使用&lt;b&gt;数学归纳法&lt;/b&gt;，证明对于任意的自然数 &lt;equation&gt;n&lt;/equation&gt; ，&lt;code class=&quot;inline&quot;&gt;fact n = fix g n&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我们先证&lt;b&gt;初始条件&lt;/b&gt;，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fix g 1 
= g (fix g) 1 
= case 1 of 
    1 -&amp;gt; 1
    _ -&amp;gt; ...
= 1
= fact 1&lt;/code&gt;&lt;p&gt;然后再证&lt;b&gt;递推条件&lt;/b&gt;，假设&lt;code class=&quot;inline&quot;&gt;fact k = fix g k&lt;/code&gt;，&lt;br&gt;我们要推出&lt;code class=&quot;inline&quot;&gt;fact (k+1) = fix g (k+1)&lt;/code&gt;，其中， &lt;equation&gt;k &amp;gt; 0&lt;/equation&gt; 。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fix g (k+1)
= g (fix g) (k+1)
= case (k+1) of 
    1 -&amp;gt; 1
    _ -&amp;gt; (k+1) * (fix g) k
= (k+1) * (fix g) k
= (k+1) * fact k
= fact (k+1)&lt;/code&gt;&lt;p&gt;因此，对于任意的自然数 &lt;equation&gt;n&lt;/equation&gt; ，&lt;code class=&quot;inline&quot;&gt;fact n = fix g n&lt;/code&gt;。&lt;br&gt;即，&lt;code class=&quot;inline&quot;&gt;fact = fix g&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;不动点算子的有限展开&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2982ac05515d431e35d327be6238dfa6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;332&quot; data-rawheight=&quot;116&quot;&gt;&lt;p&gt;根据上一节&lt;code class=&quot;inline&quot;&gt;fact = fix g&lt;/code&gt;的证明，我们看到，&lt;br&gt;每一步递推，我们都使用了不动点算子&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;的性质&lt;code class=&quot;inline&quot;&gt;fix g = g (fix g)&lt;/code&gt;，&lt;br&gt;但是对于一个具有有限存储空间的机器来说，递推的步骤不可能是无限的。&lt;/p&gt;&lt;p&gt;为了界定最多使用多少次递推，我们定义， &lt;equation&gt;fix^{[n+1]}\ g = g\ (fix^{[n]} g)&lt;/equation&gt; ，&lt;br&gt;并且认为 &lt;equation&gt;fix^{[0]}\ g&lt;/equation&gt; 对于任意的 &lt;equation&gt;n&lt;/equation&gt; 无定义，&lt;br&gt; &lt;equation&gt;fix^{[1]}\ g\ 1 = 1&lt;/equation&gt; ，而 &lt;equation&gt;fix^{[1]}\ g\ n&lt;/equation&gt; 在 &lt;equation&gt;n &amp;gt; 1&lt;/equation&gt; 时没有定义，&lt;br&gt; &lt;equation&gt;fix^{[2]}\ g\ 1 = 1&lt;/equation&gt; ， &lt;equation&gt;fix^{[2]}\ g\ 2 = 2&lt;/equation&gt; ，而 &lt;equation&gt;fix^{[2]}\ g\ n&lt;/equation&gt; 在 &lt;equation&gt;n &amp;gt; 2&lt;/equation&gt; 时没有定义。&lt;/p&gt;&lt;p&gt;因此， &lt;equation&gt;fix^{[n]}\ g&lt;/equation&gt; 是一个&lt;b&gt;部分函数&lt;/b&gt;，且，&lt;br&gt; &lt;equation&gt;fix^{[n+1]}\ g&lt;/equation&gt; 所表示的函数，总是比 &lt;equation&gt;fix^{[n]}\ g&lt;/equation&gt; 的计算能力更强一些，离&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;更近一些。&lt;br&gt;当 &lt;equation&gt;n\rightarrow \infty&lt;/equation&gt; 时， &lt;equation&gt;fix^{[\infty ]}\ g&lt;/equation&gt; 就是阶乘函数&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;即， &lt;equation&gt;\lbrace fix^{[n]} g|\ n\geqslant 0 \rbrace&lt;/equation&gt; 的&lt;b&gt;最小上界&lt;/b&gt;，就是&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的不动点。&lt;br&gt;那么，什么样的&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;才能保证这个集合具有最小上界呢？&lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BA%8F%E7%90%86%E8%AE%BA&quot;&gt;序理论&lt;/a&gt;指出，&lt;b&gt;完全偏序集上的序保持自映射具有最小不动点&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;为此，我们需要先认识什么是偏序集，什么是连续函数。&lt;br&gt;使用完全偏序集上的连续函数解释程序中函数的方式，称为&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%9F%9F%E7%90%86%E8%AE%BA&quot;&gt;域论模型&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;偏序集与哈斯图&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ca7cf8adbf29c978933a475f247bebde_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;292&quot; data-rawheight=&quot;222&quot;&gt;&lt;p&gt;在第三篇中，我们讨论过&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB&quot;&gt;偏序关系&lt;/a&gt;，&lt;br&gt;一个&lt;b&gt;偏序集&lt;/b&gt; &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 是一个集合 &lt;equation&gt;D&lt;/equation&gt; ，并且在这个集合上定义了一个&lt;b&gt;偏序关系&lt;/b&gt; &lt;equation&gt;\leqslant&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;A&lt;/equation&gt; 为实数集的一个非空子集，我们定义 &lt;equation&gt;A&lt;/equation&gt; 上的偏序关系为 &lt;equation&gt;\leqslant&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;x\leqslant y&lt;/equation&gt; 当且仅当 &lt;equation&gt;x&lt;/equation&gt; 是小或等于 &lt;equation&gt;y&lt;/equation&gt; 的实数，则 &lt;equation&gt;(A,\leqslant )&lt;/equation&gt; 是一个偏序集。&lt;/p&gt;&lt;p&gt;偏序集反映了集合上的一种偏序结构，它比我们想象中的更为常见，&lt;br&gt;例如，一个集合 &lt;equation&gt;A&lt;/equation&gt; ，对于任意两个元素 &lt;equation&gt;x,y\in A&lt;/equation&gt; ，我们定义 &lt;equation&gt;x\leqslant y&lt;/equation&gt; 当且仅当 &lt;equation&gt;x=y&lt;/equation&gt; ，&lt;br&gt;那么 &lt;equation&gt;(A,\leqslant )&lt;/equation&gt; 是一个偏序集。&lt;/p&gt;&lt;p&gt;因此，如果某个集合构成了一个偏序集，这完全取决于我们怎样定义偏序关系。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 是一个偏序集，&lt;br&gt;对于任意的 &lt;equation&gt;x,y\in D&lt;/equation&gt; ，如果总是有 &lt;equation&gt;x\leqslant y&lt;/equation&gt; 或者 &lt;equation&gt;y\leqslant x&lt;/equation&gt; 成立，&lt;br&gt;则称 &lt;equation&gt;x&lt;/equation&gt; 和 &lt;equation&gt;y&lt;/equation&gt; 是&lt;b&gt;可比的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;x\leqslant y&lt;/equation&gt; ，且 &lt;equation&gt;x\neq y&lt;/equation&gt; ，则记为 &lt;equation&gt;x&amp;lt;y&lt;/equation&gt; 。&lt;br&gt;如果 &lt;equation&gt;x&lt;/equation&gt; 和 &lt;equation&gt;y&lt;/equation&gt; 是可比的，且 &lt;equation&gt;x&amp;lt;y&lt;/equation&gt; ，如果不存在 &lt;equation&gt;z\in D&lt;/equation&gt; ，使得 &lt;equation&gt;x&amp;lt;z&amp;lt;y&lt;/equation&gt; ，&lt;br&gt;则称 &lt;equation&gt;y&lt;/equation&gt;&lt;b&gt; 覆盖 &lt;/b&gt;&lt;equation&gt;x&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;根据可比性和覆盖性，我们就可以将偏序关系用&lt;b&gt;无向图&lt;/b&gt;表示出来了，&lt;br&gt;其中，顶点表示元素，边表示覆盖关系，并且省去图中每个顶点处的环，&lt;br&gt; &lt;equation&gt;y&lt;/equation&gt; 覆盖 &lt;equation&gt;x&lt;/equation&gt; 就将代表 &lt;equation&gt;y&lt;/equation&gt; 的顶点放在代表 &lt;equation&gt;x&lt;/equation&gt; 的顶点之上，并在 &lt;equation&gt;x&lt;/equation&gt; 和 &lt;equation&gt;y&lt;/equation&gt; 之间连线，&lt;br&gt;如果 &lt;equation&gt;x&amp;lt;y&lt;/equation&gt; ，但是 &lt;equation&gt;y&lt;/equation&gt; 不覆盖 &lt;equation&gt;x&lt;/equation&gt; ，就省掉 &lt;equation&gt;x&lt;/equation&gt; 与 &lt;equation&gt;y&lt;/equation&gt; 之间的连线。&lt;/p&gt;&lt;p&gt;这样用来表示有限偏序集的无向图，称为&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%88%E6%96%AF%E5%9C%96&quot;&gt;哈斯图&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;例如，易证&lt;b&gt;整除关系&lt;/b&gt;是整数集上的一种偏序关系，&lt;br&gt;我们可以画出偏序集 &lt;equation&gt;\lbrace 1,2,3,4,5,6,9,10,15 \rbrace&lt;/equation&gt; 对应的哈斯图，如下，&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-dafdb936b22c79c6840bae5bbbb84fc6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;220&quot; data-rawheight=&quot;173&quot;&gt;&lt;h2&gt;&lt;b&gt;全序集与拟序集&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a27366c2bff2c9c470d571693f760ed4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;530&quot; data-rawheight=&quot;200&quot;&gt;&lt;p&gt;设 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 是一个偏序集，如果对于任意 &lt;equation&gt;x,y\in D&lt;/equation&gt; ， &lt;equation&gt;x&lt;/equation&gt; 和 &lt;equation&gt;y&lt;/equation&gt; 都可比，&lt;br&gt;则称 &lt;equation&gt;\leqslant&lt;/equation&gt; 为 &lt;equation&gt;D&lt;/equation&gt; 上的&lt;b&gt;全序关系&lt;/b&gt;，此时称 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; 为&lt;b&gt;全序集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;可见，实数集以及实数集上的小于等于关系 &lt;equation&gt;\leqslant&lt;/equation&gt; ，构成了一个全序集。&lt;br&gt;哈斯图为从下至上的“一条线”，是全序集的充要条件。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;R&lt;/equation&gt; 是非空集合 &lt;equation&gt;A&lt;/equation&gt; 上的，反自反的和传递的二元关系，&lt;br&gt;则称 &lt;equation&gt;R&lt;/equation&gt; 为 &lt;equation&gt;A&lt;/equation&gt; 上的&lt;b&gt;拟序关系&lt;/b&gt;，常将拟序关系记为 &lt;equation&gt;&amp;lt;&lt;/equation&gt; ，并称 &lt;equation&gt;(A,&amp;lt;)&lt;/equation&gt; 为&lt;b&gt;拟序集&lt;/b&gt;。&lt;br&gt;拟序关系自然具有反对称性。&lt;br&gt;（其中，反自反关系，指的是不存在 &lt;equation&gt;x\in A&lt;/equation&gt; ，使得 &lt;equation&gt;x&amp;lt;x&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;拟序关系与偏序关系的哈斯图在画法上完全相同，&lt;br&gt;只是拟序关系的哈斯图的各顶点都没有环。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;(A,&amp;lt;)&lt;/equation&gt; 是一个拟序集，如果对于任意的 &lt;equation&gt;x,y\in A&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;x&amp;lt;y&lt;/equation&gt; ， &lt;equation&gt;x=y&lt;/equation&gt; ， &lt;equation&gt;y&amp;lt;x&lt;/equation&gt; 三式有且仅有一式成立，则称 &lt;equation&gt;&amp;lt;&lt;/equation&gt; 具有&lt;b&gt;三歧性&lt;/b&gt;，&lt;br&gt;这样的拟序关系 &lt;equation&gt;&amp;lt;&lt;/equation&gt; ，称为&lt;b&gt;拟全序关系&lt;/b&gt;，这样的拟序集 &lt;equation&gt;(A,&amp;lt;)&lt;/equation&gt; ，称为&lt;b&gt;拟全序集&lt;/b&gt;。&lt;br&gt;拟全序集的哈斯图也是“一条线”。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;最小元与上确界&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3fa180632f5a71452ddd338e9867be18_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;187&quot;&gt;&lt;p&gt;对于偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; ，以及它的一个子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; ，&lt;br&gt;如果存在 &lt;equation&gt;y\in S&lt;/equation&gt; ，且对于任意的 &lt;equation&gt;x\in S&lt;/equation&gt; ，有 &lt;equation&gt;y\leqslant x&lt;/equation&gt; ，则称 &lt;equation&gt;y&lt;/equation&gt; 为 &lt;equation&gt;S&lt;/equation&gt; 的&lt;b&gt;最小元&lt;/b&gt;。&lt;br&gt;（相似的我们可以定义最大元&lt;/p&gt;&lt;p&gt;如果存在 &lt;equation&gt;y\in S&lt;/equation&gt; ，对于任意的 &lt;equation&gt;x\in S&lt;/equation&gt; ，&lt;br&gt;如果 &lt;equation&gt;x\leqslant y&lt;/equation&gt; 那么就有 &lt;equation&gt;x=y&lt;/equation&gt; ，则称 &lt;equation&gt;y&lt;/equation&gt; 为 &lt;equation&gt;S&lt;/equation&gt; 的&lt;b&gt;极小元&lt;/b&gt;。&lt;br&gt;（相似的我们可以定义极大元&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;S&lt;/equation&gt; 是有穷集，则 &lt;equation&gt;S&lt;/equation&gt; 的极小元一定存在，并且可能有多个，&lt;br&gt;但是最小元却不一定存在。&lt;/p&gt;&lt;p&gt;上文中，我们画出了偏序集 &lt;equation&gt;A=\lbrace 1,2,3,4,5,6,9,10,15 \rbrace&lt;/equation&gt; 对应的哈斯图，&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-086295e163bc5eaff1567167b64beca3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;220&quot; data-rawheight=&quot;173&quot;&gt;&lt;p&gt;我们取 &lt;equation&gt;B_1=\lbrace 1,2,3 \rbrace&lt;/equation&gt; ， &lt;equation&gt;B_2=\lbrace 3,5,15 \rbrace&lt;/equation&gt; ， &lt;equation&gt;B_3=A&lt;/equation&gt; ，&lt;br&gt;则 &lt;equation&gt;1&lt;/equation&gt; 是 &lt;equation&gt;B_1&lt;/equation&gt; 的最小元，也是极小元， &lt;equation&gt;2,3&lt;/equation&gt; 是 &lt;equation&gt;B_1&lt;/equation&gt; 的极大元，但 &lt;equation&gt;B_1&lt;/equation&gt; 没有最大元。&lt;br&gt; &lt;equation&gt;3,5&lt;/equation&gt; 是 &lt;equation&gt;B_2&lt;/equation&gt; 的极小元，但 &lt;equation&gt;B_2&lt;/equation&gt; 没有最小元， &lt;equation&gt;15&lt;/equation&gt; 是 &lt;equation&gt;B_2&lt;/equation&gt; 的最大元，也是极大元。&lt;br&gt; &lt;equation&gt;1&lt;/equation&gt; 是 &lt;equation&gt;B_3&lt;/equation&gt; 的最小元，也是极小元， &lt;equation&gt;4,6,9,10,15&lt;/equation&gt; 是 &lt;equation&gt;B_3&lt;/equation&gt; 的极大元，但是 &lt;equation&gt;B_3&lt;/equation&gt; 没有最大元。&lt;/p&gt;&lt;p&gt;对于偏序集 &lt;equation&gt;(D,\leqslant )&lt;/equation&gt; ，以及它的一个子集 &lt;equation&gt;S\subseteq D&lt;/equation&gt; ，&lt;br&gt;如果存在 &lt;equation&gt;y\in D&lt;/equation&gt; ，（注意，不一定是 &lt;equation&gt;y\in S&lt;/equation&gt; &lt;br&gt;使得对于任意的 &lt;equation&gt;x\in S&lt;/equation&gt; ， &lt;equation&gt;x\leqslant y&lt;/equation&gt; ，则称 &lt;equation&gt;y&lt;/equation&gt; 为 &lt;equation&gt;S&lt;/equation&gt; 的&lt;b&gt;上界&lt;/b&gt;，&lt;br&gt;如果 &lt;equation&gt;S&lt;/equation&gt; 的所有上界存在最小元，则称它为 &lt;equation&gt;S&lt;/equation&gt; &lt;b&gt;最小上界&lt;/b&gt;，或&lt;b&gt;上确界&lt;/b&gt;。&lt;br&gt;（相似的可以定义下确界&lt;/p&gt;&lt;p&gt;&lt;equation&gt;S&lt;/equation&gt; 的上界和下界不一定存在，即使存在，上确界和下确界也不一定存在。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;(A,&amp;lt;)&lt;/equation&gt; 是一个拟全序集，如果对于 &lt;equation&gt;A&lt;/equation&gt; 中的任何非空子集 &lt;equation&gt;S&lt;/equation&gt; 都有最小元，&lt;br&gt;则称 &lt;equation&gt;&amp;lt;&lt;/equation&gt; 是一个&lt;b&gt;良序关系&lt;/b&gt;， &lt;equation&gt;(A,&amp;lt;)&lt;/equation&gt; 是一个&lt;b&gt;良序集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如，自然数集以及自然数集上的小于关系，构成了一个良序集 &lt;equation&gt;(N,&amp;lt;)&lt;/equation&gt; ，&lt;br&gt;但是，整数集以及整数集上的小于关系，并不构成良序集，而仅仅是一个拟全序集。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文从一个证明出发，我们了解了不动点算子的工作原理，&lt;br&gt;然后引出了一些数学概念，序关系在不动点算子理论中占有很重要的地位，&lt;br&gt;所以，这里给出了详细的介绍，下文我们开始讨论最小不动点定理。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BA%8F%E7%90%86%E8%AE%BA&quot;&gt;序理论&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%9F%9F%E7%90%86%E8%AE%BA&quot;&gt;域论模型&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB&quot;&gt;偏序关系&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1230394/&quot;&gt;离散数学教程&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-16-34576092</guid>
<pubDate>Fri, 16 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（七）：不动点算子</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-15-34526779.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34526779&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;以上几篇文章中，我们讨论了可计算性理论相关的一些内容，&lt;br&gt;可计算性与递归函数论存在着千丝万缕的联系，&lt;br&gt;不动点理论也是这样的，我们定义的递归函数一定存在吗？&lt;br&gt;在什么情况下它是存在的？&lt;/p&gt;&lt;p&gt;要回答以上这些问题，还要从方程，不动点，不动点算子说起。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;约束方程&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-676edc86f9bf546b4765bf4586fc95cd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;215&quot;&gt;&lt;p&gt;在中学时代，我们学过“&lt;b&gt;方程&lt;/b&gt;”的概念，&lt;br&gt;方程可以简单表述为含有未知数的等式，例如， &lt;equation&gt;3x+3=2&lt;/equation&gt; 。&lt;br&gt;未知数可以同时出现在等式的两边，例如， &lt;equation&gt;2x+3=2-x&lt;/equation&gt; 。&lt;br&gt;通过合并同类项，我们可以求解 &lt;equation&gt;x&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;在大学时代，我们还学过&lt;b&gt;线性方程组&lt;/b&gt;和&lt;b&gt;微分方程&lt;/b&gt;，&lt;br&gt;例如，求解矩阵的特征值和特征向量， &lt;equation&gt;Av=\lambda v&lt;/equation&gt; ，&lt;br&gt;二阶常微分方程（&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%A1%9E%E5%B0%94%E5%87%BD%E6%95%B0&quot;&gt;贝塞尔方程&lt;/a&gt;）， &lt;equation&gt;x^2y&#39;&#39;+xy&#39;+(x^2-\alpha ^2)y=0&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;在计算机科学中，同样的未知“数”的思想，&lt;br&gt;还出现在了类型推导（例如：&lt;a href=&quot;https://en.wikipedia.org/wiki/Unification_(computer_science)&quot;&gt;unification&lt;/a&gt;）与递归函数的定义中。&lt;br&gt;以上这些例子，方程是“&lt;b&gt;约束&lt;/b&gt;”的一种表现形式。&lt;/p&gt;&lt;p&gt;我们回到最简单的阶乘函数&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的定义式，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact :: Int -&amp;gt; Int
fact 1 = 1
fact n = n * fact (n-1)&lt;/code&gt;&lt;p&gt;去掉语法糖，稍微修改一下，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact :: Int -&amp;gt; Int
fact n = case n of 
  1 -&amp;gt; 1
  n -&amp;gt; n * fact (n-1)&lt;/code&gt;&lt;p&gt;我们发现，&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的定义和“方程”十分相似，&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;同时出现在了等式的两边，&lt;br&gt;阶乘函数，就是这个“方程”的“解”。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;函数的不动点&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e4ccb41ef78c4fe19ec357fc532960ea_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;560&quot; data-rawheight=&quot;481&quot;&gt;&lt;p&gt;在中学数学中，我们已经学过不动点了，只是当时印象不是那么深刻，&lt;br&gt;&lt;b&gt;函数的不动点&lt;/b&gt;，是指被这个函数映射到其自身的那些点。&lt;br&gt;例如： &lt;equation&gt;f(x)=x^2-3x+4&lt;/equation&gt; ，&lt;br&gt;则 &lt;equation&gt;2&lt;/equation&gt; 是函数 &lt;equation&gt;f&lt;/equation&gt; 的一个不动点， &lt;equation&gt;f(2)=2&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;并不是每一个函数都有不动点，&lt;br&gt;例如，实数域上的函数 &lt;equation&gt;f(x)=x+1&lt;/equation&gt; ，就没有不动点，&lt;br&gt;对于任意实数 &lt;equation&gt;x&lt;/equation&gt; ，永远都不等于 &lt;equation&gt;x+1&lt;/equation&gt; 。&lt;br&gt;（不动点是和定义域有关的，以后我们还会重新讨论 &lt;equation&gt;f(x)=x+1&lt;/equation&gt; 的不动点。&lt;/p&gt;&lt;p&gt;一般的，函数 &lt;equation&gt;f(x)&lt;/equation&gt; 的&lt;b&gt;不动点&lt;/b&gt;，指的是这样的 &lt;equation&gt;x&lt;/equation&gt; ，使得 &lt;equation&gt;x=f(x)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;重新温习了不动点相关的知识之后，&lt;br&gt;我们就可以对上面的阶乘函数进行改造了，&lt;br&gt;我们要把阶乘函数看做另外一个函数的不动点。&lt;/p&gt;&lt;p&gt;定义函数 &lt;equation&gt;g&lt;/equation&gt; ，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;g :: (Int -&amp;gt; Int) -&amp;gt; Int -&amp;gt; Int
g f n = case n of 
  1 -&amp;gt; 1
  n -&amp;gt; n * f (n-1)&lt;/code&gt;&lt;p&gt;我们可以得到，&lt;code class=&quot;inline&quot;&gt;g fact = fact&lt;/code&gt;，&lt;br&gt;因此，&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;实际上就是函数&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的不动点。&lt;/p&gt;&lt;p&gt;于是，在“方程”中求解&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的过程，&lt;br&gt;就转换成了求解函数&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的不动点的过程了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;不动点算子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d17244c93688f8a33bbd53a896cbe762_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;492&quot; data-rawheight=&quot;179&quot;&gt;&lt;p&gt;我们怎样求解函数&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的不动点呢？&lt;br&gt;在Haskell中，可以很方便的定义一个高阶函数&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;，它可以用来求解任意函数的不动点，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fix :: (a -&amp;gt; a) -&amp;gt; a
fix g = let x = g x in x&lt;/code&gt;&lt;p&gt;我们试验一下&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;的强大威力，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact 10
&amp;gt; 3628800

fix g 10
&amp;gt; 3628800&lt;/code&gt;&lt;p&gt;注意，&lt;code class=&quot;inline&quot;&gt;fix g&lt;/code&gt;得到的是&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的不动点，而不是&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的不动点，&lt;br&gt;即&lt;code class=&quot;inline&quot;&gt;(fix g) = g (fix g)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;有了&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;，我们就可以构造&lt;b&gt;匿名递归函数&lt;/b&gt;了，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact&#39; :: Int -&amp;gt; Int
fact&#39; = fix $ \fact -&amp;gt; \n -&amp;gt; case n of 
  1 -&amp;gt; 1
  n -&amp;gt; n * fact (n-1)&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;后面跟的函数没有名字，它是匿名的，但是经过&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;作用后，可以产生一个递归函数。&lt;br&gt;也就是说，为了实现递归，函数是可以没有名字的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Y组合子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2434c4ee3ac9498d53d23a77e067d39f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;218&quot; data-rawheight=&quot;231&quot;&gt;&lt;p&gt;&lt;b&gt;Y组合子&lt;/b&gt;，是&lt;a href=&quot;https://zh.wikipedia.org/wiki/Haskell_Curry&quot;&gt;Haskell B. Curry&lt;/a&gt;在研究 &lt;equation&gt;\lambda&lt;/equation&gt; 演算时发现的，&lt;br&gt;它的表现形式如下， &lt;equation&gt;Y:=\lambda f.(\lambda x.(f\ (x\ x))\ \lambda x.(f\ (x\ x)))&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;在 &lt;equation&gt;\lambda&lt;/equation&gt; 演算中，（ &lt;equation&gt;\alpha&lt;/equation&gt; 转换和 &lt;equation&gt;\beta&lt;/equation&gt; 规约&lt;br&gt;我们可以证明，对于任何函数&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;， &lt;equation&gt;(Y g) = (g (Y g))&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;因此，Y组合子是一个&lt;b&gt;不动点算子&lt;/b&gt;，它可以得到任意函数的不动点。&lt;br&gt;其他的不动点算子还有图灵不动点组合子 &lt;equation&gt;\Theta&lt;/equation&gt; ， &lt;equation&gt;\Theta:=(\lambda x.\lambda y.(y\ (x\ x\ y)))\ (\lambda x.\lambda y.(y\ (x\ x\ y)))&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;讨论Y组合子在Haskell中的表示方式是有趣的，因为直接翻译过去会报类型错误，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;y :: (a -&amp;gt; a) -&amp;gt; a
y = \f -&amp;gt; (\x -&amp;gt; f (x x)) (\x -&amp;gt; f (x x))

-- Occurs check: cannot construct the infinite type: r0 ~ r0 -&amp;gt; a
-- Expected type: r0 -&amp;gt; a
--   Actual type: (r0 -&amp;gt; a) -&amp;gt; a
-- In the first argument of ‘x’, namely ‘x’
-- In the first argument of ‘f’, namely ‘(x x)’&lt;/code&gt;&lt;p&gt;类型系统无法确定&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型。&lt;/p&gt;&lt;p&gt;问题出在表达式&lt;code class=&quot;inline&quot;&gt;x x&lt;/code&gt;上面，&lt;br&gt;假设&lt;code class=&quot;inline&quot;&gt;x x&lt;/code&gt;的类型为&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，则第一个&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型就应该为&lt;code class=&quot;inline&quot;&gt;? -&amp;gt; a&lt;/code&gt;，&lt;br&gt;于是，第二个&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型肯定也应该是&lt;code class=&quot;inline&quot;&gt;? -&amp;gt; a&lt;/code&gt;。（因为都是&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt; &lt;/p&gt;&lt;p&gt;又因为&lt;code class=&quot;inline&quot;&gt;x x&lt;/code&gt;的类型为&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，&lt;br&gt;所以第一个&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型&lt;code class=&quot;inline&quot;&gt;? -&amp;gt; a&lt;/code&gt;中，&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;的类型就应该是&lt;code class=&quot;inline&quot;&gt;? -&amp;gt; a&lt;/code&gt;，&lt;br&gt;（因为&lt;code class=&quot;inline&quot;&gt;((? -&amp;gt; a) -&amp;gt; a)&lt;/code&gt;作用到&lt;code class=&quot;inline&quot;&gt;(? -&amp;gt; a)&lt;/code&gt;才能得到&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt; &lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;的类型是&lt;code class=&quot;inline&quot;&gt;? -&amp;gt; a&lt;/code&gt;，因此&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;应该是一个&lt;a href=&quot;https://zh.m.wikipedia.org/wiki/%E9%80%92%E5%BD%92%E7%B1%BB%E5%9E%8B&quot;&gt;递归类型&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;下面我们来定义递归类型&lt;code class=&quot;inline&quot;&gt;Mu&lt;/code&gt;，来帮助编译器进行恰当的类型推导，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;newtype Mu a = Mu (Mu a -&amp;gt; a)

y :: (a -&amp;gt; a) -&amp;gt; a
y f = (\h -&amp;gt; h $ Mu h) (\x -&amp;gt; f . (\(Mu g) -&amp;gt; g) x $ x)&lt;/code&gt;&lt;p&gt;最后，&lt;code class=&quot;inline&quot;&gt;fact&#39;&lt;/code&gt;就可以使用Y组合子来定义了。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact&#39; :: Int -&amp;gt; Int
fact&#39; = y $ \fact -&amp;gt; \n -&amp;gt; case n of 
  1 -&amp;gt; 1
  n -&amp;gt; n * fact (n-1)&lt;/code&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文从简单的“方程”思想出发，引出了不动点的概念，&lt;br&gt;然后把递归函数看做了另外一个函数的不动点，&lt;br&gt;最后，我们讨论了Y组合子这样一个具体的不动点算子。&lt;/p&gt;&lt;p&gt;可是，这里隐藏着一个问题，我们看到&lt;code class=&quot;inline&quot;&gt;fix&lt;/code&gt;是可以求解任意函数的不动点的，&lt;br&gt;而对于以下递归函数&lt;code class=&quot;inline&quot;&gt;succ&lt;/code&gt;，即 &lt;equation&gt;f(x)=x+1&lt;/equation&gt; ，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;succ :: Int -&amp;gt; Int
succ n = n+1&lt;/code&gt;&lt;p&gt;在实数域上是显然没有不动点的。&lt;/p&gt;&lt;p&gt;那么&lt;code class=&quot;inline&quot;&gt;fix succ&lt;/code&gt;是什么呢？&lt;br&gt;这个问题，我们将在后文中继续讨论。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E6%96%B9%E7%A8%8B&quot;&gt;方程&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F&quot;&gt;特征值和特征向量&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B&quot;&gt;微分方程&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E4%B8%8D%E5%8A%A8%E7%82%B9&quot;&gt;不动点&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E4%B8%8D%E5%8A%A8%E7%82%B9%E7%BB%84%E5%90%88%E5%AD%90&quot;&gt;不动点组合子&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Fix_and_recursion&quot;&gt;Haskell/Fix and recursion&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;http://stackoverflow.com/questions/4273413/y-combinator-in-haskell/5885270#5885270&quot;&gt;Y Combinator in Haskell&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-15-34526779</guid>
<pubDate>Thu, 15 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（六）：最多有多少个程序</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-14-34484014.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34484014&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上一篇中，我们通过引入极小化算子定义了递归函数，&lt;br&gt;使用递归函数，我们又定义了递归集与递归可枚举集，&lt;br&gt;本文我们要讨论，为什么递归可枚举集是“可枚举”的，以及什么是可计算函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;可计算性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a4af83dc0f3607efe72758004eb1e9f5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;410&quot; data-rawheight=&quot;429&quot;&gt;&lt;p&gt;我们听说过，现代计算机在计算能力上是与图灵机等价的，&lt;br&gt;什么叫做计算能力呢？&lt;br&gt;它指的是图灵机可计算的函数集，与现代计算机可计算的函数集是相等的。&lt;/p&gt;&lt;p&gt;为了简单起见，我们不去讨论图灵机，而是从现代计算机直接说起，&lt;br&gt;设 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 是一段程序， &lt;equation&gt;n&lt;/equation&gt; 是一个正整数，&lt;br&gt;我们称数论函数 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 为&lt;b&gt;程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 所计算的&lt;/b&gt; &lt;equation&gt;n&lt;/equation&gt; 元部分函数，&lt;br&gt;如果对于相同的输入，&lt;br&gt;要么：（1）程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的计算可以终止，此时计算结果等于 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 的相应函数值；&lt;br&gt;要么：（2）程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的计算不能终止，此时 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 无定义。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;f(x_1,x_2,\cdots ,x_n)&lt;/equation&gt; 是一个部分函数，&lt;br&gt;如果存在程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 可计算 &lt;equation&gt;f&lt;/equation&gt; ，则称 &lt;equation&gt;f&lt;/equation&gt; 是&lt;b&gt;部分可计算的&lt;/b&gt;。&lt;br&gt;如果一个函数，既是部分可计算的，又是全函数，则称这个函数是&lt;b&gt;可计算的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;可以证明，所有的原始递归函数和递归函数都是部分可计算的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;通用程序&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们使用现代计算机进行编程的时候，并不是直接把程序的输入传给程序，&lt;br&gt;而是将程序本身以及它的输入，传给计算机，最后由计算机得到计算结果，&lt;br&gt;像这种接受任何程序和它的输入作为自己的输入，返回程序执行结果的程序，称为&lt;b&gt;通用程序&lt;/b&gt;。&lt;br&gt;为此，通用程序需要把输入的程序进行&lt;b&gt;编码&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;常用的编码方法，涉及&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%85%8D%E5%AF%B9%E5%87%BD%E6%95%B0&quot;&gt;配对函数&lt;/a&gt;和&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E6%95%B0&quot;&gt;哥德尔编码&lt;/a&gt;。&lt;br&gt;为了不引入太多的复杂性，我们可以将程序的编码理解为存储程序的二进制数据，&lt;br&gt;不同的程序会有不同的二进制表示，每一个二进制表示可以对应一段程序&lt;br&gt;（虽然可能不合法）。&lt;/p&gt;&lt;p&gt;哥德尔编码做的事情就是将程序和自然数集一一对应起来。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9a7c9ce767daf3bef81c5e3e7d5c152e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;565&quot;&gt;&lt;p&gt;因此，所有程序的个数是&lt;b&gt;可数的&lt;/b&gt;，而这些程序可计算的函数个数也一定是可数的，&lt;br&gt;它们可能是全函数，也可能是部分函数。&lt;br&gt;（其中，“可数”指的是可数集，&lt;b&gt;可数集&lt;/b&gt;是与自然数集之间存在一一映射的集合。&lt;/p&gt;&lt;p&gt;然而，自然数集上的函数全体并不可数，（证略&lt;br&gt;所以肯定存在程序不可计算的函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;集合个数的可枚举性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-216f0ef423d8f37598db6eee7ed05452_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;389&quot; data-rawheight=&quot;182&quot;&gt;&lt;p&gt;程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 所计算的函数，我们可以记为 &lt;equation&gt;\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; ，&lt;br&gt;由此，我们可以定义通用程序 &lt;equation&gt;\Phi&lt;/equation&gt; ，则有，&lt;br&gt; &lt;equation&gt;\Phi (x_1,x_2,\cdots ,x_n,y)=\psi (x_1,x_2,\cdots ,x_n)&lt;/equation&gt; &lt;br&gt;其中， &lt;equation&gt;y&lt;/equation&gt; 是程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的编码。&lt;/p&gt;&lt;p&gt;因为，所有的程序与自然数集一一对应，&lt;br&gt;所以， &lt;equation&gt;\Phi (x_1,x_2,\cdots ,x_n,0),\Phi (x_1,x_2,\cdots ,x_n,1),\cdots&lt;/equation&gt; &lt;b&gt;枚举了所有的 &lt;equation&gt;n&lt;/equation&gt; 元可计算函数。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们定义 &lt;equation&gt;W_y=\lbrace x\in N|\Phi(x,y)\downarrow \rbrace&lt;/equation&gt; ，&lt;br&gt;根据递归可枚举集的定义，每一个 &lt;equation&gt;W_y&lt;/equation&gt; 是一个递归可枚举集。&lt;/p&gt;&lt;p&gt;又因为 &lt;equation&gt;\Phi(x,0),\Phi(x,1),\cdots&lt;/equation&gt; 枚举了所有的可计算函数，&lt;br&gt;而上一篇中我们看到，递归可枚举集是由部分递归函数（即，可计算函数）定义的，&lt;br&gt;一个部分递归函数确定出一个递归可枚举集，&lt;br&gt;所以， &lt;equation&gt;W_0,W_1,\cdots&lt;/equation&gt; &lt;b&gt;枚举了所有的递归可枚举集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;因此，集合 &lt;equation&gt;B&lt;/equation&gt; 是递归可枚举的，当且仅当存在 &lt;equation&gt;y\in N&lt;/equation&gt; ，使得 &lt;equation&gt;B=W_y&lt;/equation&gt; ，&lt;br&gt;称为&lt;b&gt;枚举定理&lt;/b&gt;，这就是“枚举”的含义。&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;K=\lbrace n\in N|n\in W_n\rbrace&lt;/equation&gt; ，&lt;br&gt;则 &lt;equation&gt;K&lt;/equation&gt; 是递归可枚举的，但不是递归的，（证略&lt;br&gt;因此， &lt;equation&gt;\bar{K}&lt;/equation&gt; 不是递归可枚举的，否则 &lt;equation&gt;K&lt;/equation&gt; 就是递归集了。&lt;br&gt;（根据，集合 &lt;equation&gt;B&lt;/equation&gt; 是递归的当且仅当 &lt;equation&gt;B&lt;/equation&gt; 和 &lt;equation&gt;\bar{B}&lt;/equation&gt; 是递归可枚举的，见上一篇&lt;/p&gt;&lt;p&gt;因此，我们找到了一个非递归的递归可枚举集 &lt;equation&gt;K&lt;/equation&gt; ，&lt;br&gt;以及一个非递归可枚举集 &lt;equation&gt;\bar{K}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;停机问题&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2649469b93d96783266c38873773ab78_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;374&quot; data-rawheight=&quot;234&quot;&gt;&lt;p&gt;任给一个程序和一个自然数，问该程序对这个自然数输入的计算是否停止，&lt;br&gt;这个问题称为&lt;b&gt;停机问题&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;我们可以用谓词 &lt;equation&gt;H(x,y)&lt;/equation&gt; 描述这个问题，&lt;br&gt; &lt;equation&gt;H(x,y)&lt;/equation&gt; ，表示以 &lt;equation&gt;y&lt;/equation&gt; 为代码的程序对输入 &lt;equation&gt;x&lt;/equation&gt; 的计算最终停止。&lt;br&gt;那么， &lt;equation&gt;H(x,y)&lt;/equation&gt; 是不可计算的，即，不存在一个程序来计算 &lt;equation&gt;H(x,y)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们来证明一下，假设有一个程序可以计算 &lt;equation&gt;H(x,y)&lt;/equation&gt; ，&lt;br&gt;那么我们就能用它来构造一个新程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; ，它的输入是 &lt;equation&gt;x&lt;/equation&gt; ，&lt;br&gt;这段程序当 &lt;equation&gt;H(x,x)&lt;/equation&gt; 为真时，计算不停止，而当 &lt;equation&gt;H(x,x)&lt;/equation&gt; 为假时，计算停止。&lt;/p&gt;&lt;p&gt;程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 也可以进行编码，假设为 &lt;equation&gt;y_0&lt;/equation&gt; ，现在我们来判断 &lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 为真，意味着编码为 &lt;equation&gt;y_0&lt;/equation&gt; 的程序以 &lt;equation&gt;y_0&lt;/equation&gt; 作为输入最终停止，&lt;br&gt;即程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; ，输入为 &lt;equation&gt;y_0&lt;/equation&gt; 时，最终停止，&lt;br&gt;可是根据 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的定义，此时 &lt;equation&gt;H(x,x)=H(y_0,y_0)&lt;/equation&gt; 为假才会停止，矛盾。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 为假，意味着编码为 &lt;equation&gt;y_0&lt;/equation&gt; 的程序以 &lt;equation&gt;y_0&lt;/equation&gt; 作为参数最终不会停止，&lt;br&gt;即程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; ，输入为 &lt;equation&gt;y_0&lt;/equation&gt; 时，最终不停止，&lt;br&gt;可是根据 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 的定义，此时 &lt;equation&gt;H(x,x)=H(y_0,y_0)&lt;/equation&gt; 为真才不会停止，矛盾。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;H(y_0,y_0)&lt;/equation&gt; 不能为真也不能为假，矛盾，&lt;br&gt;因此，计算 &lt;equation&gt;H(x,y)&lt;/equation&gt; 的程序&lt;b&gt;不存在&lt;/b&gt;，我们也无法用它来构造程序 &lt;equation&gt;\mathscr{P}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;可判定性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2b6940df2115ed418d982f28f5263301_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;380&quot;&gt;&lt;p&gt;&lt;b&gt;可判定性问题&lt;/b&gt;，指的是一个询问真或者假的问题是否可以被回答。&lt;br&gt;如果我们总能回答出这个问题是真或者是假，就称该问题是&lt;b&gt;可判定的&lt;/b&gt;，&lt;br&gt;如果我们只能当问题为真的时候确定为真，为假的时候所进行的计算可能不会终止，&lt;br&gt;那么就称该问题是&lt;b&gt;半可判定的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;某元素是否属于一个递归集，是可判定的，&lt;br&gt;某元素是否属于一个递归可枚举集，是半可判定的。&lt;/p&gt;&lt;p&gt;因为，递归集是使用一个递归的全函数定义的，&lt;br&gt;而递归可枚举集是使用第一个部分递归函数定义的，&lt;br&gt;我们无法判断某个部分递归函数，在接受某参数时，是没有定义，还是计算尚未停止。&lt;br&gt;即，判断元素是否属于某递归可枚举集的程序可能永不停机&lt;b&gt;。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了函数的可计算性，通用程序，以及最多有多少个程序，&lt;br&gt;还了解了停机问题和可判定性问题。&lt;/p&gt;&lt;p&gt;这些都是可计算性理论的基础，我们清晰的看到了人类的计算能力，&lt;br&gt;以及用递归所能计算的函数范围，后文中我们开始讨论不动点理论，&lt;br&gt;这同样是一个有趣的话题。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;附&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;配对函数和哥德尔数，是对数偶和有穷数列的一种编码方式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）配对函数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;令 &lt;equation&gt;\langle x,y\rangle=2^x(2y+1)-1&lt;/equation&gt; ，称 &lt;equation&gt;\langle x,y\rangle&lt;/equation&gt; 为&lt;b&gt;配对函数&lt;/b&gt;，它是一个原始递归函数。&lt;/p&gt;&lt;p&gt;任给一个数 &lt;equation&gt;z&lt;/equation&gt; ，存在唯一的一对数 &lt;equation&gt;x&lt;/equation&gt; 和 &lt;equation&gt;y&lt;/equation&gt; ，使得 &lt;equation&gt;\langle x,y\rangle =z&lt;/equation&gt; 。&lt;br&gt; &lt;equation&gt;x&lt;/equation&gt; 是 &lt;equation&gt;z+1&lt;/equation&gt; 含有因子 &lt;equation&gt;2&lt;/equation&gt; 的个数，即使得 &lt;equation&gt;2^t|(z+1)&lt;/equation&gt; 的 &lt;equation&gt;t&lt;/equation&gt; 的最大值。&lt;br&gt; &lt;equation&gt;(z+1)/2^x&lt;/equation&gt; 必为奇数， &lt;equation&gt;y&lt;/equation&gt; 是 &lt;equation&gt;2y+1=(z+1)/2^x&lt;/equation&gt; 的唯一解。&lt;/p&gt;&lt;p&gt;一般的，记 &lt;equation&gt;l(z)=x&lt;/equation&gt; ， &lt;equation&gt;r(z)=y&lt;/equation&gt; ，则 &lt;equation&gt;l(z)&lt;/equation&gt; 和 &lt;equation&gt;r(z)&lt;/equation&gt; 也是原始递归函数。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）哥德尔数&lt;/b&gt;&lt;/p&gt;&lt;p&gt;记 &lt;equation&gt;[a_1,a_2,\cdots ,a_n]=\prod_{i=1}^{n}p_i^{a_i}&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;[a_1,a_2,\cdots ,a_n]&lt;/equation&gt; 称为有穷数列 &lt;equation&gt;(a_1,a_2,\cdots ,a_n)&lt;/equation&gt; 的哥德尔数，其中， &lt;equation&gt;p_i&lt;/equation&gt; 是第 &lt;equation&gt;i&lt;/equation&gt; 个素数。&lt;/p&gt;&lt;p&gt;例如，[ &lt;equation&gt;[2,0,1,3]=2^2\cdot 3^0\cdot 5^1\cdot 7^3=6860&lt;/equation&gt; 。&lt;br&gt;对于每一个固定的 &lt;equation&gt;n&lt;/equation&gt; ， &lt;equation&gt;[a_1,a_2,\cdots ,a_n]&lt;/equation&gt; 是原始递归函数，并且这种编码具有唯一性。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%85%8D%E5%AF%B9%E5%87%BD%E6%95%B0&quot;&gt;配对函数&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E6%95%B0&quot;&gt;哥德尔数&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%95%B8%E9%9B%86&quot;&gt;可数集&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%88%A4%E5%AE%9A%E6%80%A7&quot;&gt;可判定性&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E5%BA%B7%E6%89%98%E5%B0%94%E5%AE%9A%E7%90%86&quot;&gt;康托尔定理&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-14-34484014</guid>
<pubDate>Wed, 14 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（五）：递归集与递归可枚举集</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-13-34447250.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34447250&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文中我们讨论了全函数和部分函数，以及计算的可终止性。&lt;br&gt;本文我们从数论函数开始，给原始递归函数集增加一种新的运算，得到了一个更大的集合。&lt;br&gt;然后根据递归函数，我们可以定义递归集和递归可枚举集，&lt;br&gt;为以后讨论可计算性与可判定性打好基础。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;数论函数&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-00ebc8699bbcc75935897546101678be_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;415&quot; data-rawheight=&quot;214&quot;&gt;&lt;p&gt;自然数集一般记为 &lt;equation&gt;N=\lbrace 0,1,2,\cdots \rbrace&lt;/equation&gt; ，那么 &lt;equation&gt;n&lt;/equation&gt; 个自然数集的笛卡尔积记为 &lt;equation&gt;N^n&lt;/equation&gt; ，&lt;br&gt;于是，我们称集合 &lt;equation&gt;N^n&lt;/equation&gt; 到 &lt;equation&gt;N&lt;/equation&gt; 的部分函数为&lt;b&gt;&lt;equation&gt;n&lt;/equation&gt; 元部分数论函数&lt;/b&gt;。&lt;br&gt;作为数论函数， &lt;equation&gt;2x&lt;/equation&gt; 是一个全函数，而 &lt;equation&gt;x/2&lt;/equation&gt; ， &lt;equation&gt;x-y&lt;/equation&gt; ， &lt;equation&gt;\sqrt{x}&lt;/equation&gt; 只是部分函数，&lt;br&gt;它们的计算结果， &lt;equation&gt;3/2&lt;/equation&gt; ， &lt;equation&gt;4-6&lt;/equation&gt; ， &lt;equation&gt;\sqrt{5}&lt;/equation&gt; 都不在 &lt;equation&gt;N&lt;/equation&gt; 中，&lt;br&gt;于是相应定义域中的点可视为没有定义。&lt;/p&gt;&lt;p&gt;为什么讨论数论函数呢，其一是因为它是一个典型数学的问题，&lt;br&gt;另外一点，则是因为我们经常把其他数学问题转换成数论问题，例如，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E6%95%B0&quot;&gt;哥德尔编码&lt;/a&gt;。&lt;br&gt;本文中，使用数论函数，可以简化我们的描述方式。&lt;/p&gt;&lt;p&gt;一个&lt;b&gt;谓词&lt;/b&gt;，指的是返回布尔值的函数，&lt;br&gt;我们还可以将谓词看做值域为 &lt;equation&gt;\lbrace 0,1\rbrace&lt;/equation&gt; 的一个数论函数。&lt;br&gt; &lt;equation&gt;0&lt;/equation&gt; 代表&lt;code class=&quot;inline&quot;&gt;True&lt;/code&gt;， &lt;equation&gt;1&lt;/equation&gt; 代表&lt;code class=&quot;inline&quot;&gt;False&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;极小化算子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-cfab5b6b86d286530c4f9ea57cb8905f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;235&quot; data-rawheight=&quot;214&quot;&gt;&lt;p&gt;在前一篇中，我们从三个初始函数出发，&lt;br&gt;通过合成运算和原始递归运算，得到了原始递归函数集，&lt;br&gt;递归函数集是相对于这两种运算封闭的。&lt;/p&gt;&lt;p&gt;然而，这样定义的原始递归函数，并不能包括所有的数论函数，&lt;br&gt;一个典型的例子就是，&lt;a href=&quot;https://zh.wikipedia.org/zh/%E9%98%BF%E5%85%8B%E6%9B%BC%E5%87%BD%E6%95%B8&quot;&gt;阿克曼函数&lt;/a&gt;，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;ackermann :: Int -&amp;gt; Int -&amp;gt; Int 
ackermann 0 x = x+1
ackermann k 0 = ackermann (k-1) 1
ackermann k x = ackermann (k-1) $ ackermann k x-1&lt;/code&gt;&lt;p&gt;&lt;b&gt;它并不是一个原始递归函数&lt;/b&gt;，（证略&lt;br&gt;因此原始递归函数集并不足以表示计算机程序中的所有函数。&lt;/p&gt;&lt;p&gt;为此，我们需要对原始递归函数集进行扩充，我们定义一个新的运算，称为&lt;b&gt;极小化运算&lt;/b&gt;，&lt;br&gt;设 &lt;equation&gt;P(x_1,\cdots ,x_n,t)&lt;/equation&gt; 是一个谓词，令 &lt;equation&gt;f(x_1,\cdots ,x_n)=min\ P(x_1,\cdots ,x_n,t)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;f(x_1,\cdots ,x_n)&lt;/equation&gt; 的值，或者是使 &lt;equation&gt;P(x_1,\cdots ,x_n,t)&lt;/equation&gt; 为真的最小 &lt;equation&gt;t&lt;/equation&gt; 值，&lt;br&gt;或者无定义，此时不存在 &lt;equation&gt;t&lt;/equation&gt; 使得 &lt;equation&gt;P(x_1,\cdots ,x_n,t)&lt;/equation&gt; 为真。&lt;br&gt;这样通过 &lt;equation&gt;min&lt;/equation&gt; 得到 &lt;equation&gt;f(x_1,\cdots ,x_n)&lt;/equation&gt; 的过程称为&lt;b&gt;极小化运算&lt;/b&gt;，&lt;br&gt;也称部分函数 &lt;equation&gt;f(x_1,\cdots ,x_n)&lt;/equation&gt; 是由谓词经过极小化运算得到的。&lt;/p&gt;&lt;p&gt;以上我们给谓词定义了极小化运算，现在我们将极小化运算推广到一般的函数上面，&lt;br&gt;设 &lt;equation&gt;g(x_1,\cdots ,x_n,t)&lt;/equation&gt; 是一个 &lt;equation&gt;n+1&lt;/equation&gt; 元函数，令&lt;br&gt; &lt;equation&gt;f(x_1,\cdots ,x_n)=min\lbrace g(x_1,\cdots ,x_n,t)=0\rbrace&lt;/equation&gt; &lt;br&gt;则称部分函数 &lt;equation&gt;f(x_1,\cdots ,x_n)&lt;/equation&gt; 是由函数 &lt;equation&gt;g(x_1,\cdots ,x_n,t)&lt;/equation&gt; 经过极小化运算得到的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;递归函数集&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;和定义原始递归函数集一样，我们从以下三个初始函数出发，&lt;br&gt;（1）零函数 &lt;equation&gt;n(x)=0&lt;/equation&gt; &lt;br&gt;（2）后继函数 &lt;equation&gt;s(x)=x+1&lt;/equation&gt; &lt;br&gt;（3）投影函数 &lt;equation&gt;u^n_i(x_1,\cdots ,x_n)=x_i&lt;/equation&gt; ， &lt;equation&gt;1\leqslant i\leqslant n&lt;/equation&gt; &lt;br&gt;由初始函数，经过有限次合成运算，原始递归运算，以及极小化运算，&lt;br&gt;得到的函数称为&lt;b&gt;递归函数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;递归函数并不一定是全函数，因为极小化运算可能会导致结果函数在某些点无定义，&lt;br&gt;递归的部分函数称为&lt;b&gt;部分递归函数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;可以证明阿克曼函数是递归函数，但不是原始递归函数，&lt;br&gt;因此，原始递归函数集是递归函数集的真子集。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;递归可枚举集&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-707e7082ba20ea7f7b155d8bb50da75a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;518&quot; data-rawheight=&quot;353&quot;&gt;&lt;p&gt;在具体实践中，我们经常会遇到这样的问题，&lt;br&gt;给定一个元素，我们需要判断这个元素是否属于某个集合。&lt;br&gt;这种问题，称为集合的成员资格问题。&lt;/p&gt;&lt;p&gt;沿用这一思路，我们可以使用一个谓词 &lt;equation&gt;\chi _B&lt;/equation&gt; 来定义相应的集合 &lt;equation&gt;B\subseteq N&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;B=\lbrace x\in N|\chi _B(x)\rbrace&lt;/equation&gt; &lt;br&gt;谓词 &lt;equation&gt;\chi _B(x)&lt;/equation&gt; 为真，则 &lt;equation&gt;x\in B&lt;/equation&gt; 。&lt;br&gt;这个谓词 &lt;equation&gt;\chi _B(x)&lt;/equation&gt; ，通常称为集合 &lt;equation&gt;B&lt;/equation&gt; 的&lt;b&gt;特征函数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;如果特征函数 &lt;equation&gt;\chi _B&lt;/equation&gt; 是一个递归的全函数，&lt;br&gt;则我们总是可以判断 &lt;equation&gt;\chi _B(x)&lt;/equation&gt; 等于 &lt;equation&gt;0&lt;/equation&gt; 还是 &lt;equation&gt;1&lt;/equation&gt; ，&lt;br&gt;这样的集合 &lt;equation&gt;B&lt;/equation&gt; 称为&lt;b&gt;递归集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;如果存在部分递归函数 &lt;equation&gt;g&lt;/equation&gt; ，使得 &lt;equation&gt;B=\lbrace x\in N|g(x)\downarrow \rbrace&lt;/equation&gt; ，&lt;br&gt;即， &lt;equation&gt;x\in B&lt;/equation&gt; 当且仅当 &lt;equation&gt;g&lt;/equation&gt; 在 &lt;equation&gt;x&lt;/equation&gt; 处有定义，&lt;br&gt;则称集合 &lt;equation&gt;B&lt;/equation&gt; 是一个&lt;b&gt;递归可枚举集&lt;/b&gt;。&lt;br&gt;每一个部分递归函数，都确定出一个递归可枚举集。&lt;/p&gt;&lt;p&gt;因此，对于每一个自然数 &lt;equation&gt;x\in N&lt;/equation&gt; ，&lt;br&gt;我们总是可以通过递归集 &lt;equation&gt;B&lt;/equation&gt; 的特征函数 &lt;equation&gt;\chi _B&lt;/equation&gt; ，来判断 &lt;equation&gt;x&lt;/equation&gt; 是否 &lt;equation&gt;B&lt;/equation&gt; 的成员。&lt;br&gt;而对于递归可枚举集，就不容乐观了，&lt;br&gt;如果某个自然数 &lt;equation&gt;x\in N&lt;/equation&gt; 是 &lt;equation&gt;B&lt;/equation&gt; 的成员，那么我们可以断定这件事，因为 &lt;equation&gt;g(x)&lt;/equation&gt; 有定义，&lt;br&gt;但是如果某个自然数 &lt;equation&gt;y\in N&lt;/equation&gt; 不是 &lt;equation&gt;B&lt;/equation&gt; 的成员，我们就不能确定，因为这时候 &lt;equation&gt;g(x)&lt;/equation&gt; 无定义。&lt;br&gt;（ &lt;equation&gt;g(x)&lt;/equation&gt; 无定义，则它对应的图灵机不停机，后文我们详细讨论&lt;/p&gt;&lt;p&gt;因此，集合 &lt;equation&gt;B&lt;/equation&gt; 是递归的当且仅当 &lt;equation&gt;B&lt;/equation&gt; 和 &lt;equation&gt;\bar{B}&lt;/equation&gt; 是递归可枚举的，&lt;br&gt;其中 &lt;equation&gt;\bar{B}&lt;/equation&gt; 为 &lt;equation&gt;B&lt;/equation&gt; 的补集。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了数论函数，递归函数集，然后用递归函数分别定义了递归集和递归可枚举集，&lt;br&gt;可是为什么递归可枚举集是“可枚举”的呢？&lt;/p&gt;&lt;p&gt;是因为每一个递归可枚举集可以一一对应一个自然数，这是怎样做到的呢？&lt;br&gt;这需要我们理解总共有多少个可能的程序，以及什么是通用程序。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92%E9%9B%86%E5%90%88&quot;&gt;递归集&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92%E5%8F%AF%E6%9E%9A%E4%B8%BE%E9%9B%86%E5%90%88&quot;&gt;递归可枚举集&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-13-34447250</guid>
<pubDate>Tue, 13 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（四）：全函数与计算的可终止性</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-12-34425726.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34425726&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9488c88c2a5273ccfd75c83a424585ca_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;300&quot; data-rawheight=&quot;300&quot;&gt;&lt;p&gt;上文我们讨论了集合上的关系，还讨论了数学归纳法的一种普遍形式，称为良基归纳法，&lt;br&gt;它建立在集合上的良基关系之上。&lt;/p&gt;&lt;p&gt;本文开始讨论函数，我们将回顾函数的定义，&lt;br&gt;然后解释什么是全函数（total function），什么是部分函数（partial function）。&lt;/p&gt;&lt;p&gt;我们会看到，在证明一个递归函数是全函数时，&lt;br&gt;良基归纳法起到了重要作用。&lt;/p&gt;&lt;p&gt;在分析学中，人们似乎很少关心函数的完全性，&lt;br&gt;只关心它的连续性，可导性，可微性与可积性，等等。&lt;br&gt;而在计算机科学领域中，人们更在意计算的可终止性，&lt;br&gt;因此一个函数在某个点是否有定义将经常被提及。&lt;/p&gt;&lt;p&gt;程序中定义的函数，往往对应于某个集合上的数学函数，&lt;br&gt;为了描述程序的非终止性，就得扩充这个数学函数的定义域和值域。&lt;br&gt;为了理解这些事情，我们先要从函数的定义开始。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;函数&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;集合 &lt;equation&gt;A,B&lt;/equation&gt; 上的关系，是笛卡尔积 &lt;equation&gt;A\times B&lt;/equation&gt; 的一个子集。&lt;/p&gt;&lt;p&gt;而&lt;b&gt;函数&lt;/b&gt; &lt;equation&gt;f:A\rightarrow B&lt;/equation&gt; ，则是集合 &lt;equation&gt;A,B&lt;/equation&gt; 上的一种特殊关系，&lt;br&gt;它要求 &lt;equation&gt;A&lt;/equation&gt; 中的每一个元素，都有 &lt;equation&gt;B&lt;/equation&gt; 中&lt;b&gt;唯一确定的&lt;/b&gt;元素与之对应。&lt;br&gt;其中，集合 &lt;equation&gt;A&lt;/equation&gt; 称为函数 &lt;equation&gt;f&lt;/equation&gt; 的&lt;b&gt;定义域&lt;/b&gt;，集合 &lt;equation&gt;B&lt;/equation&gt; 称为函数的&lt;b&gt;值域&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;函数是我们熟悉的概念，这里只是提到了它本质上是集合上的一个关系。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）部分函数（partial function）&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-874ea6c6827de852cd55a96727978878_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;200&quot; data-rawheight=&quot;200&quot;&gt;&lt;p&gt;如果 &lt;equation&gt;f&lt;/equation&gt; 是从 &lt;equation&gt;A&lt;/equation&gt; 到 &lt;equation&gt;B&lt;/equation&gt; 的二元关系，且 &lt;equation&gt;\forall a\in A&lt;/equation&gt; ， &lt;equation&gt;f(a)=\varnothing&lt;/equation&gt; 或 &lt;equation&gt;\lbrace b\rbrace&lt;/equation&gt; ，&lt;br&gt;则称 &lt;equation&gt;f&lt;/equation&gt; 是从 &lt;equation&gt;A&lt;/equation&gt; 到 &lt;equation&gt;B&lt;/equation&gt; 的&lt;b&gt;部分函数&lt;/b&gt;，或 &lt;equation&gt;A&lt;/equation&gt; 上的部分函数。&lt;/p&gt;&lt;p&gt;其中，如果 &lt;equation&gt;f(a)=\lbrace b\rbrace&lt;/equation&gt; ，则称 &lt;equation&gt;f(a)&lt;/equation&gt; &lt;b&gt;有定义&lt;/b&gt;，记为 &lt;equation&gt;f(a)\downarrow&lt;/equation&gt; ，&lt;br&gt;也称 &lt;equation&gt;b&lt;/equation&gt; 为 &lt;equation&gt;f&lt;/equation&gt; 在 &lt;equation&gt;a&lt;/equation&gt; 点的函数值，记为 &lt;equation&gt;f(a)=b&lt;/equation&gt; 。&lt;br&gt;如果 &lt;equation&gt;f(a)=\varnothing&lt;/equation&gt; ，则称 &lt;equation&gt;f(a)&lt;/equation&gt;&lt;b&gt; 无定义&lt;/b&gt;，记为 &lt;equation&gt;f(a)\uparrow&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）全函数（total function）&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-98cba4b9c4f902aab70190f355394426_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;200&quot; data-rawheight=&quot;200&quot;&gt;&lt;p&gt;如果 &lt;equation&gt;\forall a\in A&lt;/equation&gt; 都有 &lt;equation&gt;f(a)\downarrow&lt;/equation&gt; ，则称 &lt;equation&gt;f&lt;/equation&gt; 是 &lt;equation&gt;A&lt;/equation&gt; 上的全函数，&lt;br&gt;此时，可以记为 &lt;equation&gt;f:A\rightarrow B&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;可见，我们熟悉的函数，指的是全函数。&lt;br&gt;值得注意的是，部分函数的定义已经包含了我们学过的“函数”的定义，&lt;br&gt;后文中，我们提到的“函数”如果不强调它的完全性的话，都泛指部分函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;非终止性&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;部分函数在计算机科学中是非常重要的，&lt;br&gt;因为对于每一个 &lt;equation&gt;a\in A&lt;/equation&gt; ，一个算法可以表示为，计算出集合 &lt;equation&gt;B&lt;/equation&gt; 中与之对应元素的过程，&lt;br&gt;这个算法可能对于某些值 &lt;equation&gt;a\in A&lt;/equation&gt; 不会终止，而这种情况是很常见的。&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;f :: Int -&amp;gt; Int
f 1 = 1
f n = n + f(n-2)&lt;/code&gt;&lt;p&gt;这样定义的函数&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;，对应了数学上的一个部分函数 &lt;equation&gt;f&lt;/equation&gt; ，它只在某些情况下有意义，&lt;br&gt;只有当&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;是奇数时，我们才能得到终止性的结果。&lt;br&gt;而当&lt;code class=&quot;inline&quot;&gt;n&lt;/code&gt;是偶数时，算法会无限的递归下去，直到堆栈溢出。&lt;/p&gt;&lt;p&gt;因此，将&lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt;解释为整数集 &lt;equation&gt;N&lt;/equation&gt; ，将&lt;code class=&quot;inline&quot;&gt;f :: Int -&amp;gt; Int&lt;/code&gt;解释为整数集上的函数，&lt;br&gt;似乎是有问题的，因为， &lt;equation&gt;f(2)&lt;/equation&gt; 并不是一个整数，它的计算不能终止。&lt;/p&gt;&lt;p&gt;为了描述非终止性，就需要对整数集进行扩充，&lt;br&gt;我们给整数集加上一个特殊元素“ &lt;equation&gt;\perp&lt;/equation&gt; ”，称为&lt;b&gt;bottom&lt;/b&gt;，来表示非终止性，&lt;br&gt;而将&lt;code class=&quot;inline&quot;&gt;f :: Int -&amp;gt; Int&lt;/code&gt;解释为集合 &lt;equation&gt;N\cup \lbrace \perp \rbrace&lt;/equation&gt; 上的一个数学函数。&lt;/p&gt;&lt;p&gt;像这种通过构造表达程序含义的数学对象，来对程序进行分析的方法，来自&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8C%87%E7%A7%B0%E8%AF%AD%E4%B9%89&quot;&gt;指称语义学&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;指称语义中，人们会区分函数的严格性，一个函数称为&lt;b&gt;严格的&lt;/b&gt;（strict），&lt;br&gt;如果接受一个非终止的输入表达式，函数的计算仍然不会终止，即， &lt;equation&gt;f(\perp )=\perp&lt;/equation&gt; 。&lt;br&gt;否则，称函数为&lt;b&gt;不严格的&lt;/b&gt;（non-strict）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;原始递归函数&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fcac4612d17b9df75820b2d778789687_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;271&quot; data-rawheight=&quot;186&quot;&gt;&lt;p&gt;我们看到在程序中使用递归，可能会导致非终止性的计算，而有些递归又不会。&lt;br&gt;这是为什么呢？&lt;/p&gt;&lt;p&gt;我们可以从递归函数论中找到一些线索。&lt;br&gt;递归函数论是和图灵机以及 &lt;equation&gt;\lambda&lt;/equation&gt; 演算相等价的计算模型，它从另一个角度刻画了可计算性。&lt;br&gt;可计算性是一个有趣的话题，后续文章中，我们会详细讨论。&lt;/p&gt;&lt;p&gt;在递归函数论中，人们把函数划分为了3个层次，&lt;br&gt;原始递归函数，递归函数，和其他的不能用递归函数表示的“函数”。&lt;br&gt;这些函数集合的范围越来越大。&lt;/p&gt;&lt;p&gt;本文我们先介绍原始递归函数，&lt;br&gt;为此，我们需要先定义两种运算。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）合成运算&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;f&lt;/equation&gt; 是 &lt;equation&gt;k&lt;/equation&gt; 元部分函数， &lt;equation&gt;g_1,g_2,\cdots ,g_k&lt;/equation&gt; 是 &lt;equation&gt;k&lt;/equation&gt; 个 &lt;equation&gt;n&lt;/equation&gt; 元部分函数，令，&lt;br&gt; &lt;equation&gt;h(x_1,\cdots ,x_n)=f(g_1(x_1,\cdots ,x_n),\cdots ,g_k(x_1,\cdots ,x_n))&lt;/equation&gt; &lt;br&gt;则称 &lt;equation&gt;h&lt;/equation&gt; 是由 &lt;equation&gt;f&lt;/equation&gt; 和 &lt;equation&gt;g_1,g_2,\cdots ,g_k&lt;/equation&gt; ，经过&lt;b&gt;合成运算&lt;/b&gt;得到的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）原始递归运算&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;f&lt;/equation&gt; 是一个 &lt;equation&gt;n&lt;/equation&gt; 元全函数， &lt;equation&gt;g&lt;/equation&gt; 是 &lt;equation&gt;n+2&lt;/equation&gt; 元全函数，令，&lt;br&gt; &lt;equation&gt;h(x_1,\cdots ,x_n,0)=f(x_1,\cdots ,x_n)&lt;/equation&gt; &lt;br&gt; &lt;equation&gt;h(x_1,\cdots ,x_n,t+1)=g(t,h(x_1,\cdots ,x_n,t),x_1,\cdots ,x_n)&lt;/equation&gt; &lt;br&gt;则称 &lt;equation&gt;h&lt;/equation&gt; 是由 &lt;equation&gt;f&lt;/equation&gt; 和 &lt;equation&gt;g&lt;/equation&gt; 经过&lt;b&gt;原始递归运算&lt;/b&gt;得到的。&lt;/p&gt;&lt;p&gt;于是，我们就可以定义原始递归函数了。&lt;/p&gt;&lt;p&gt;设&lt;b&gt;初始函数&lt;/b&gt;包括，&lt;br&gt;（1）零函数 &lt;equation&gt;n(x)=0&lt;/equation&gt; &lt;br&gt;（2）后继函数 &lt;equation&gt;s(x)=x+1&lt;/equation&gt; &lt;br&gt;（3）投影函数 &lt;equation&gt;u^n_i(x_1,\cdots ,x_n)=x_i&lt;/equation&gt; ， &lt;equation&gt;1\leqslant i\leqslant n&lt;/equation&gt; &lt;br&gt;则由初始函数经过有限次合成运算和原始递归运算得到的函数，称为&lt;b&gt;原始递归函数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;原始递归函数有以下这些性质：&lt;br&gt;由原始递归函数经过合成或原始递归得到的函数仍为原始递归函数，&lt;br&gt;因此，原始递归函数的集合在合成与原始递归运算下是封闭的。&lt;/p&gt;&lt;p&gt;此外，每一个原始递归函数都是全函数。&lt;br&gt;这是因为合成运算虽然是在部分函数上定义的，&lt;br&gt;但是如果 &lt;equation&gt;f&lt;/equation&gt; 和 &lt;equation&gt;g_1,g_2,\cdots ,g_k&lt;/equation&gt; 是全函数，那么 &lt;equation&gt;h&lt;/equation&gt; 也一定是全函数。&lt;/p&gt;&lt;p&gt;另一方面，在进行原始递归运算时，如果 &lt;equation&gt;f&lt;/equation&gt; 和 &lt;equation&gt;g&lt;/equation&gt; 是全函数，则 &lt;equation&gt;h&lt;/equation&gt; 也一定是全函数，&lt;br&gt;这是因为原始递归运算在 &lt;equation&gt;h&lt;/equation&gt; 的参数集上的定义了一个良基关系，&lt;br&gt;由良基归纳法可证， &lt;equation&gt;h&lt;/equation&gt; 是全函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a3866f274319c289a42997f7331f9611_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;259&quot; data-rawheight=&quot;246&quot;&gt;&lt;p&gt;本文介绍了全函数与部分函数，以及计算可终止性相关的概念，&lt;br&gt;我们对程序中函数的指称，进行了定义域和值域的扩充，&lt;br&gt;随后，我们进一步了解了原始递归函数，以及它的完全性，良基归纳法起到了关键作用。&lt;/p&gt;&lt;p&gt;下文，我们将深入到可计算性理论，&lt;br&gt;讨论部分可计算函数和可计算函数的区别，讨论递归函数与原始递归函数的关系，&lt;br&gt;引出递归可枚举集这个重要的概念。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Function_(mathematics)&quot;&gt;function (mathematics)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Strict_function&quot;&gt;strict function&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1310925/&quot;&gt;可计算性与计算复杂性导引&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-12-34425726</guid>
<pubDate>Mon, 12 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>递归函数（三）：归纳原理</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-11-34287668.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34287668&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;自然数归纳法&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2dc9c1daf53982ff9dd9cd7829af8cef_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;534&quot; data-rawheight=&quot;318&quot;&gt;&lt;p&gt;自然数归纳法，是一种数学证明方法，&lt;br&gt;通常被用于证明某个给定命题在整个（或者局部）自然数范围内成立。&lt;br&gt;它可以用一个有限的方式写出一个无限的证明。&lt;/p&gt;&lt;p&gt;后续文章中我们会看到，&lt;br&gt;这种用有限表示无限的方法，其实是有局限性的，并不能用来解决所有的问题，&lt;br&gt;它能处理的只是无限中的一个子集罢了。&lt;/p&gt;&lt;p&gt;自然数归纳法，我们可以描述如下：&lt;br&gt;为证明对每一个自然数 &lt;equation&gt;n&lt;/equation&gt; ，命题 &lt;equation&gt;P(n)&lt;/equation&gt; 为真，只需要证明两件事，&lt;br&gt;（1）对于自然数 &lt;equation&gt;1&lt;/equation&gt; ，命题 &lt;equation&gt;P(1)&lt;/equation&gt; 为真&lt;br&gt;（2）如果对于自然数 &lt;equation&gt;m&lt;/equation&gt; ，命题 &lt;equation&gt;P(m)&lt;/equation&gt; 为真，那么对于自然数 &lt;equation&gt;m+1&lt;/equation&gt; ，命题 &lt;equation&gt;P(m+1)&lt;/equation&gt; 也为真&lt;/p&gt;&lt;p&gt;其中，第(1)条称为&lt;b&gt;起始条件&lt;/b&gt;，第(2)条称为&lt;b&gt;递推条件&lt;/b&gt;，或者称为&lt;b&gt;归纳步骤&lt;/b&gt;。&lt;br&gt;第(2)条中，为了证明 &lt;equation&gt;P(m+1)&lt;/equation&gt; 而假设的 &lt;equation&gt;P(m)&lt;/equation&gt; ，称为&lt;b&gt;归纳假设&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;这似乎是很显然的事情，我们可以在一张无限长的纸带开头写上初始条件 &lt;equation&gt;P(1)&lt;/equation&gt; ，&lt;br&gt;接着根据递推条件，由 &lt;equation&gt;P(1)&lt;/equation&gt; 我们可以证明 &lt;equation&gt;P(2)&lt;/equation&gt; 成立，&lt;br&gt;重复这种思想，我们可以由 &lt;equation&gt;P(2)&lt;/equation&gt; 证明 &lt;equation&gt;P(3)&lt;/equation&gt; 成立，如此不断的进行下去，&lt;br&gt;最终，对于每个自然数 &lt;equation&gt;n&lt;/equation&gt; ，我们都能证明 &lt;equation&gt;P(n)&lt;/equation&gt; 成立。&lt;/p&gt;&lt;p&gt;但是，这样并不算是一个有效的证明。&lt;br&gt;要证明自然数归纳法的正确性，我们还需要补充一些集合论方面的知识。&lt;br&gt;然而，在此之前，我们还是先来看自然数归纳法的一个例子吧。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;例子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-4a82c1a5c4a25cf84243be45f3986796_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;272&quot;&gt;&lt;p&gt;在上一篇，我们在定义递归函数&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的时候，&lt;br&gt;先找到了“递推式”，再找到了“终止条件”，然后写出了&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的定义：&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact :: Int -&amp;gt; Int
fact 1 = 1
fact n = n * fact (n-1)&lt;/code&gt;&lt;p&gt;我们还提到，有一个步骤是必不可少的，&lt;br&gt;那就是证明&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;的正确性，即证明这样定义的&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;就是阶乘函数 &lt;equation&gt;f(n)=n!&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;现在，我们正好可以用自然数归纳法来证明它。&lt;br&gt;我们假设命题 &lt;equation&gt;P(n)&lt;/equation&gt; 为：&lt;code class=&quot;inline&quot;&gt;fact n&lt;/code&gt;的值为 &lt;equation&gt;n!&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;（1）对于自然数 &lt;equation&gt;1&lt;/equation&gt; ，命题 &lt;equation&gt;P(1)&lt;/equation&gt; ：&lt;code class=&quot;inline&quot;&gt;fact 1&lt;/code&gt;的值为 &lt;equation&gt;1!=1&lt;/equation&gt; ，成立&lt;br&gt;（2）假设对于自然数 &lt;equation&gt;m&lt;/equation&gt; ，命题 &lt;equation&gt;P(m)&lt;/equation&gt; ：&lt;code class=&quot;inline&quot;&gt;fact m&lt;/code&gt;的值为 &lt;equation&gt;m!&lt;/equation&gt; ，成立&lt;/p&gt;&lt;p&gt;那么，我们可以得到&lt;code class=&quot;inline&quot;&gt;fact (m+1) = (m+1) * fact m&lt;/code&gt;，值为 &lt;equation&gt;(m+1)*m!=(m+1)!&lt;/equation&gt; ，也成立。&lt;/p&gt;&lt;p&gt;所以，对于任意自然数（ &lt;equation&gt;n\geqslant 1&lt;/equation&gt; ），&lt;code class=&quot;inline&quot;&gt;fact n&lt;/code&gt;的值就是 &lt;equation&gt;n!&lt;/equation&gt; 。&lt;br&gt;于是，我们证明了&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;就是阶乘函数 &lt;equation&gt;f(n)=n!&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;自然数归纳法还有另外一种等价形式，&lt;br&gt;如果要证明 &lt;equation&gt;P(n)&lt;/equation&gt; 对每一个自然数 &lt;equation&gt;n&lt;/equation&gt; 为真，&lt;br&gt;只要证明对于任意自然数 &lt;equation&gt;m&lt;/equation&gt; ，如果 &lt;equation&gt;P(i)&lt;/equation&gt; 当 &lt;equation&gt;i&amp;lt;m&lt;/equation&gt; 为真，那么 &lt;equation&gt;P(m)&lt;/equation&gt; 也为真。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;集合上的关系&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a9ac2524ee3db1b8d2e19a941ffcfda5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;210&quot; data-rawheight=&quot;179&quot;&gt;&lt;p&gt;关系是一个日常生活用语，例如，“同学关系”，“我们的关系很好”之类的。&lt;br&gt;然而，它也是一个集合论中的概念，这给我们带来了很多困扰。&lt;br&gt;为了避免歧义，本文中从这里开始，我们开始谈论数学，我们要对集合上的“关系”进行定义。&lt;/p&gt;&lt;p&gt;直观的说，集合 &lt;equation&gt;A&lt;/equation&gt; 的元素和集合 &lt;equation&gt;B&lt;/equation&gt; 的元素之间的&lt;b&gt;关系&lt;/b&gt;是一个二元性质 &lt;equation&gt;R&lt;/equation&gt; ，&lt;br&gt;使得对于每个 &lt;equation&gt;a\in A&lt;/equation&gt; 和 &lt;equation&gt;b\in B&lt;/equation&gt; 而言， &lt;equation&gt;R(a,b)&lt;/equation&gt; 要么为真，要么为假。&lt;/p&gt;&lt;p&gt;关系通常表示为一个集合，它是笛卡尔积的子集，即，&lt;br&gt;集合 &lt;equation&gt;A&lt;/equation&gt; 和集合 &lt;equation&gt;B&lt;/equation&gt; 之间的关系 &lt;equation&gt;R&lt;/equation&gt; 是它们笛卡尔积的一个子集 &lt;equation&gt;R\subseteq A\times B&lt;/equation&gt; 。&lt;br&gt;如果序对 &lt;equation&gt;(a,b)&lt;/equation&gt; 属于子集 &lt;equation&gt;R&lt;/equation&gt; ，则认为 &lt;equation&gt;a&lt;/equation&gt; 与 &lt;equation&gt;b&lt;/equation&gt; 之间的关系为真，&lt;br&gt;否则认为 &lt;equation&gt;a&lt;/equation&gt; 与 &lt;equation&gt;b&lt;/equation&gt; 之间的关系为假。&lt;/p&gt;&lt;p&gt;通常关系直接描述为 &lt;equation&gt;R(a,b)&lt;/equation&gt; ，或者 &lt;equation&gt;aRb&lt;/equation&gt; ，而不用 &lt;equation&gt;(a,b)\in R&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;除了二元关系之外，对任何正整数 &lt;equation&gt;k&lt;/equation&gt; ，还可以定义&lt;b&gt;&lt;equation&gt;k&lt;/equation&gt; 元关系&lt;/b&gt;。&lt;br&gt;如果 &lt;equation&gt;A_1,\cdots,A_k&lt;/equation&gt; 为集合，则在 &lt;equation&gt;A_1,\cdots,A_k&lt;/equation&gt; 上的 &lt;equation&gt;k&lt;/equation&gt; 元关系，&lt;br&gt;是笛卡尔积 &lt;equation&gt;A_1\times \cdots \times A_k&lt;/equation&gt; 的一个子集。&lt;/p&gt;&lt;p&gt;某个集合上的二元关系有很多性质，例如自反性，对称性，反对称性，传递性。&lt;br&gt;一个关系 &lt;equation&gt;R\subseteq A\times A&lt;/equation&gt; 是&lt;b&gt;自反的&lt;/b&gt;，如果 &lt;equation&gt;R(a,a)&lt;/equation&gt; 对于所有的 &lt;equation&gt;a\in A&lt;/equation&gt; 成立；&lt;br&gt;是&lt;b&gt;对称的&lt;/b&gt;，如果 &lt;equation&gt;R(a,b)&lt;/equation&gt; 就有 &lt;equation&gt;R(b,a)&lt;/equation&gt; ，对于所有的 &lt;equation&gt;a,b\in A&lt;/equation&gt; 都成立；&lt;br&gt;是&lt;b&gt;反对称的&lt;/b&gt;，如果 &lt;equation&gt;R(a,b)&lt;/equation&gt; 且 &lt;equation&gt;R(b,a)&lt;/equation&gt; 则 &lt;equation&gt;a,b&lt;/equation&gt; 是同一个元素，对于所有的 &lt;equation&gt;a,b\in A&lt;/equation&gt; 都成立；&lt;br&gt;是&lt;b&gt;传递的&lt;/b&gt;，如果 &lt;equation&gt;R(a,b)&lt;/equation&gt; 和 &lt;equation&gt;R(b,c)&lt;/equation&gt; 能推出 &lt;equation&gt;R(a,c)&lt;/equation&gt; ，对于所有的 &lt;equation&gt;a,b,c\in A&lt;/equation&gt; 都成立。&lt;br&gt;（注意，反对称性不是对称性的否定。&lt;/p&gt;&lt;p&gt;&lt;b&gt;等价关系&lt;/b&gt;是同时具有自反性，对称性和传递性的关系。&lt;br&gt;&lt;b&gt;偏序关系&lt;/b&gt;是具有自反性，反对称性和传递性的关系。&lt;br&gt;等价关系的一个例子就是相等性，相等性关系 &lt;equation&gt;R(a,b)&lt;/equation&gt; 当且仅当 &lt;equation&gt;a,b&lt;/equation&gt; 是同一个元素。&lt;br&gt;偏序关系，例如通常的序关系 &lt;equation&gt;R\subseteq N\times N&lt;/equation&gt; ， &lt;equation&gt;R(a,b)&lt;/equation&gt; 当且仅当 &lt;equation&gt;a\leqslant b&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;良基关系&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-143831fefb5a8e05dbb75c4a045c419f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;408&quot; data-rawheight=&quot;292&quot;&gt;&lt;p&gt;归纳法有各种各样的形式，自然数归纳法只是其中的一种应用，&lt;br&gt;在数理逻辑和形式语言理论中，用的最多的是结构归纳法，在树形结构上进行归纳，后续文章中我们会提到。&lt;/p&gt;&lt;p&gt;人们总结了各种归纳法的共性，提出了&lt;b&gt;良基关系&lt;/b&gt;的概念，&lt;br&gt;于是，自然数归纳法和结构归纳法都变成了在良基关系上通用归纳法的具体应用了。&lt;/p&gt;&lt;p&gt;集合 &lt;equation&gt;A&lt;/equation&gt; 上的&lt;b&gt;良基关系&lt;/b&gt;（well-founded relation），是 &lt;equation&gt;A&lt;/equation&gt; 上的一个二元关系 &lt;equation&gt;\prec&lt;/equation&gt; ，&lt;br&gt;如果不存在无限下降序列（infinite descending sequence） &lt;equation&gt;a_0\succ a_1\succ a_2\cdots&lt;/equation&gt; 。&lt;br&gt;例如，自然数上的关系 &lt;equation&gt;&amp;lt;&lt;/equation&gt; ，就是一个良基关系。&lt;br&gt;但是 &lt;equation&gt;\leqslant&lt;/equation&gt; 却不是，因为存在一个无限下降序列 &lt;equation&gt;a_0\geqslant a_1\geqslant a_2\cdots&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;根据良基关系，我们可以定义集合中的&lt;b&gt;最小元&lt;/b&gt;，&lt;br&gt;&lt;equation&gt;a\in A&lt;/equation&gt; 为最小元，如果不存在 &lt;equation&gt;a&#39;\in A&lt;/equation&gt; ，使得 &lt;equation&gt;a&#39;\prec a&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;对于良基关系，有一个等价的定义，&lt;br&gt;&lt;b&gt;&lt;equation&gt;A&lt;/equation&gt; 上的二元关系 &lt;equation&gt;\prec&lt;/equation&gt; 是良基的，当且仅当 &lt;equation&gt;A&lt;/equation&gt; 的每一个非空子集 &lt;equation&gt;B&lt;/equation&gt; 有最小元。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们可以证明一下这两种说法等价性。&lt;br&gt;要证当且仅当，我们需要证明充分性和必要性，&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）充分性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;要证： &lt;equation&gt;A&lt;/equation&gt; 上的二元关系 &lt;equation&gt;\prec&lt;/equation&gt; 是良基的，则 &lt;equation&gt;A&lt;/equation&gt; 的每一个非空子集 &lt;equation&gt;B&lt;/equation&gt; 有最小元。&lt;br&gt;使用反证法，如果 &lt;equation&gt;B&lt;/equation&gt; 没有最小元，则对于每个 &lt;equation&gt;a\in B&lt;/equation&gt; ，&lt;br&gt;总可以找到 &lt;equation&gt;a&#39;\in B&lt;/equation&gt; ，使得 &lt;equation&gt;a&#39;\prec a&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;但是，如果这样的话，我们就可以对任何 &lt;equation&gt;a_0\in B&lt;/equation&gt; ，以 &lt;equation&gt;a_0&lt;/equation&gt; 开始构造一个无限下降序列 &lt;equation&gt;a_0\succ a_1\succ a_2\cdots&lt;/equation&gt; ，这与 &lt;equation&gt;\prec&lt;/equation&gt; 是一个良基关系矛盾。&lt;/p&gt;&lt;p&gt;充分性证毕。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2） 必要性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;要证：如果 &lt;equation&gt;A&lt;/equation&gt; 的每一个非空子集 &lt;equation&gt;B&lt;/equation&gt; 都有最小元，&lt;br&gt;则 &lt;equation&gt;A&lt;/equation&gt; 上用于比较的二元关系 &lt;equation&gt;\prec&lt;/equation&gt; 是良基的。&lt;/p&gt;&lt;p&gt;由于 &lt;equation&gt;A&lt;/equation&gt; 的每一个非空子集 &lt;equation&gt;B&lt;/equation&gt; 都有最小元，&lt;br&gt;则不可能存在无限下降序列 &lt;equation&gt;a_0\succ a_1\succ a_2\cdots&lt;/equation&gt; ，因此， &lt;equation&gt;\prec&lt;/equation&gt; 是良基的。&lt;/p&gt;&lt;p&gt;必要性证毕。&lt;/p&gt;&lt;p&gt;因此， &lt;equation&gt;A&lt;/equation&gt; 上的二元关系 &lt;equation&gt;\prec&lt;/equation&gt; 是良基的，当且仅当 &lt;equation&gt;A&lt;/equation&gt; 的每一个非空子集 &lt;equation&gt;B&lt;/equation&gt; 有最小元。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;良基归纳法&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2c813b575e2e614578b648087e3df9a4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;568&quot; data-rawheight=&quot;465&quot;&gt;&lt;p&gt;设 &lt;equation&gt;\prec&lt;/equation&gt; 为集合 &lt;equation&gt;A&lt;/equation&gt; 上的良基二元关系，并且设 &lt;equation&gt;P&lt;/equation&gt; 为关于 &lt;equation&gt;A&lt;/equation&gt; 中元素的某个命题，&lt;br&gt;如果 &lt;equation&gt;P(b)&lt;/equation&gt; 对于所有的 &lt;equation&gt;b\prec a&lt;/equation&gt; 成立，就必然有 &lt;equation&gt;P(a)&lt;/equation&gt; 成立，&lt;br&gt;那么 &lt;equation&gt;P(a)&lt;/equation&gt; 就对所有的 &lt;equation&gt;a\in A&lt;/equation&gt; 成立。&lt;/p&gt;&lt;p&gt;我们看到 &lt;equation&gt;&amp;lt;&lt;/equation&gt; 确实是自然数集上的良基关系，因此自然数归纳法只是良基归纳法的一种特例。&lt;/p&gt;&lt;p&gt;现在我们有了足够的能力来证明自然数归纳法的正确性了，&lt;br&gt;只要我们证明了良基归纳法是正确的。&lt;/p&gt;&lt;p&gt;还是用&lt;b&gt;反证法&lt;/b&gt;：&lt;/p&gt;&lt;p&gt;我们期望证明，&lt;br&gt;&lt;b&gt;前提：&lt;/b&gt;如果 &lt;equation&gt;P(b)&lt;/equation&gt; 对于所有的 &lt;equation&gt;b\prec a&lt;/equation&gt; 成立，必然有 &lt;equation&gt;P(a)&lt;/equation&gt; 成立，&lt;br&gt;&lt;b&gt;结论：&lt;/b&gt;那么对于所有的 &lt;equation&gt;a\in A&lt;/equation&gt; ， &lt;equation&gt;P(a)&lt;/equation&gt; 都成立。&lt;/p&gt;&lt;p&gt;如若不然，假设存在 &lt;equation&gt;x\in A&lt;/equation&gt; ，使得 &lt;equation&gt;P(x)&lt;/equation&gt; 不成立，&lt;br&gt;则集合 &lt;equation&gt;B=\{a\in A\ |\ \neg P(a)\}&lt;/equation&gt; 非空，&lt;br&gt;因此根据良基关系的等价定义，集合 &lt;equation&gt;B&lt;/equation&gt; 必有最小元 &lt;equation&gt;m\prec B\subseteq A&lt;/equation&gt; ，&lt;br&gt;而且， &lt;equation&gt;\neg P(m)&lt;/equation&gt; 成立。&lt;/p&gt;&lt;p&gt;则根据前提的逆否命题，一定存在 &lt;equation&gt;b\prec m&lt;/equation&gt; ，使得 &lt;equation&gt;\neg P(b)&lt;/equation&gt; 成立，&lt;br&gt;所以，我们有 &lt;equation&gt;b\in B&lt;/equation&gt; ，且 &lt;equation&gt;b \prec m&lt;/equation&gt; ，与 &lt;equation&gt;m&lt;/equation&gt; 是 &lt;equation&gt;B&lt;/equation&gt; 的最小元矛盾。&lt;/p&gt;&lt;p&gt;证毕。&lt;/p&gt;&lt;p&gt;由此，我们证明了良基归纳法的正确性。&lt;br&gt;理解良基关系和偏序关系，是理解递归和不动点算子的第一步。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a4cae22aff8b6d791971cfcc0d2a8de2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;220&quot; data-rawheight=&quot;361&quot;&gt;&lt;p&gt;本文从自然数归纳法出发，补充了一些集合论方面的知识，&lt;br&gt;让我们熟悉了集合上的几种常用关系，例如，等价关系，偏序关系和良基关系，&lt;br&gt;这些关系在以后的文章中还会被再次提到。&lt;/p&gt;&lt;p&gt;最后，我们证明了良基归纳法，从而证明了自然数归纳法的正确性。&lt;br&gt;不知道是否很明显了，递归的步骤和归纳的步骤，简直是太像了，&lt;br&gt;这一定不是偶然。&lt;/p&gt;&lt;p&gt;在&lt;a href=&quot;https://book.douban.com/subject/26429992/&quot;&gt;The Little Prover&lt;/a&gt;一书中，为了证明递归函数是否全函数（total function），&lt;br&gt;作者使用了测度（measure）的概念，这实际上定义了参数集上的一个良基关系。&lt;br&gt;全函数是可计算理论中一个很重要的概念，&lt;br&gt;到底什么是全函数，什么是测度？下文我们再详细讨论。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95&quot;&gt;维基百科 - 数学归纳法&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB&quot;&gt;维基百科 - 二元关系&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%89%AF%E5%9F%BA%E5%85%B3%E7%B3%BB&quot;&gt;维基百科 - 良基关系&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1144542/&quot;&gt;程序设计语言的形式语义&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-11-34287668</guid>
<pubDate>Sun, 11 Mar 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
