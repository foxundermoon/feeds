<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>业余程序员的个人修养</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Wed, 28 Mar 2018 21:50:58 +0800</lastBuildDate>
<item>
<title>语言背后的代数学（一）：语义解释</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-28-34977830.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34977830&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-134995884618e02bd2e40ed91782730d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;775&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;1. 初窥语义&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34669807&quot;&gt;你好，类型&lt;/a&gt;》系列中，我们介绍了一些&lt;b&gt;形式系统&lt;/b&gt;，&lt;br&gt;例如 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 系统（ &lt;equation&gt;\lambda&lt;/equation&gt; 演算）， &lt;equation&gt;CL_w&lt;/equation&gt; （组合子逻辑），&lt;br&gt;它们由一些&lt;b&gt;合法的符号&lt;/b&gt;，以及这些符号的&lt;b&gt;推导规则&lt;/b&gt;构成，&lt;br&gt;命题逻辑与谓词逻辑，也可以用这种&lt;b&gt;公理化&lt;/b&gt;的方式构建起来。&lt;/p&gt;&lt;p&gt;然而，在讨论这些系统的时候，我们只是把它们看成了单纯的符号演算，&lt;br&gt;并没有过多考虑这些符号到底代表什么含义。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\lambda&lt;/equation&gt; 项 &lt;equation&gt;(\lambda x.x(xy))N&lt;/equation&gt; ，经过 &lt;equation&gt;\beta&lt;/equation&gt; 变换，我们可以得到， &lt;equation&gt;N(Ny)&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;(\lambda x.x(xy))N\triangleright_\beta N(Ny)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;它看起来真的&lt;b&gt;好像&lt;/b&gt;一个函数调用啊。&lt;br&gt;这就给我们带来了以下思考，是否可以把 &lt;equation&gt;(\lambda x.x(xy))&lt;/equation&gt; 解释为一个函数呢？&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;function (x){
    return x(x(y));
}&lt;/code&gt;&lt;p&gt;是否可以认为， &lt;equation&gt;(\lambda x.x(xy))N&lt;/equation&gt; 是用参数 &lt;equation&gt;N&lt;/equation&gt; 对该函数进行调用呢？&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;(function (x){
    return x(x(y));
}(N));

// 调用后相当于返回了以下结果
N(N(y))&lt;/code&gt;&lt;p&gt;这样解释的话， &lt;equation&gt;\beta&lt;/equation&gt; 变换就可以看做函数调用了。&lt;br&gt;这一切似乎顺理成章，显而易见。&lt;/p&gt;&lt;p&gt;可是，我们为什么可以这样做呢？&lt;br&gt; &lt;equation&gt;\beta&lt;/equation&gt; 变换与函数调用之间的关系是唯一确定的吗？&lt;br&gt;为了回答好这些问题，还得重新研读&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AF%AD%E4%B9%89%E5%AD%A6&quot;&gt;语义学&lt;/a&gt;这个有趣的学科。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 公理化&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-129f6b44ad6f901ec1f41203f965c775_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;806&quot; data-rawheight=&quot;393&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;首先我们先回顾一下，形式系统是怎么用公理化的方式构建的。&lt;br&gt;我们以一个称之为“pq”的系统为例。（出自《&lt;a href=&quot;https://book.douban.com/subject/1291204/&quot;&gt;哥德尔、艾舍尔、巴赫——集异璧之大成&lt;/a&gt;》）&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.1 公理化步骤&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;第一步&lt;/b&gt;，&lt;br&gt;我们要有一些&lt;b&gt;符号&lt;/b&gt;。&lt;br&gt;例如：“pq系统”只有三个符号，&lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;-&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第二步&lt;/b&gt;，&lt;br&gt;我们要说明什么样的符号串是&lt;b&gt;合法的&lt;/b&gt;，即指定一套&lt;b&gt;语法&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如，我们规定“pq系统”中合法的符号串，形如&lt;code class=&quot;inline&quot;&gt;xqypz&lt;/code&gt;，&lt;br&gt;其中，&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;z&lt;/code&gt;仅由一串短杠组成。&lt;/p&gt;&lt;code lang=&quot;bnf&quot;&gt;term := n &#39;q&#39; n &#39;p&#39; n
n := &#39;-&#39; | &#39;-&#39; n&lt;/code&gt;&lt;p&gt;因此，&lt;code class=&quot;inline&quot;&gt;--q-p-&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;---q--p-&lt;/code&gt;都是合法的符号串。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第三步，&lt;br&gt;&lt;/b&gt;我们要指定&lt;b&gt;公理&lt;/b&gt;和&lt;b&gt;推导规则&lt;/b&gt;，&lt;br&gt;其中公理是推导的出发点，由公理推导得出的符号串称为&lt;b&gt;定理&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;（1）“pq”系统的&lt;b&gt;公理&lt;/b&gt;如下，&lt;br&gt;只要&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;仅由一串短杠组成，那么&lt;code class=&quot;inline&quot;&gt;x-qxp-&lt;/code&gt;就是一条公理。&lt;/p&gt;&lt;p&gt;（2）“pq”系统的&lt;b&gt;推导规则&lt;/b&gt;是这样的，&lt;br&gt;假设&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;z&lt;/code&gt;都代表只包含短杠的特定的符号串，&lt;br&gt;并且假设&lt;code class=&quot;inline&quot;&gt;xqypz&lt;/code&gt;是一条已知的公理/定理，&lt;br&gt;那么&lt;code class=&quot;inline&quot;&gt;x-qypz-&lt;/code&gt;就是一条定理。&lt;/p&gt;&lt;p&gt;即它们满足 &lt;equation&gt;\frac{xqypz}{x-qypz-}&lt;/equation&gt; ，表示如果 &lt;equation&gt;xqypz&lt;/equation&gt; 是定理，则 &lt;equation&gt;x-qypz-&lt;/equation&gt; 也是定理。&lt;/p&gt;&lt;p&gt;例子，根据公理的定义，我们知道&lt;code class=&quot;inline&quot;&gt;--q-p-&lt;/code&gt;是一条公理，&lt;br&gt;又根据这条公理和推导规则，我们得到了&lt;code class=&quot;inline&quot;&gt;---q-p--&lt;/code&gt;是一条定理。&lt;/p&gt;&lt;p&gt;&lt;b&gt;小结：&lt;br&gt;&lt;/b&gt;以上三步我们通过公理化的方式构建了一个形式系统，&lt;br&gt;它由符号，语法，公理，推导规则组成，&lt;br&gt;我们可以用公理和旧定理生成新定理，不断演算。&lt;/p&gt;&lt;p&gt;在其他系统中，公理和定理的个数可能是有限的，而“pq”系统则是无限的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 解释&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-95ab0145a95af5914d68596e6d3d844d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;332&quot; data-rawheight=&quot;327&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们说以上“pq系统”定义了一个&lt;b&gt;形式语言&lt;/b&gt;，&lt;br&gt;这里的“语言”是一种数学上的定义，指的是&lt;b&gt;字符串的集合&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;“pq”系统的形式语言，就是系统中公理和定理的集合。&lt;/p&gt;&lt;p&gt;考察一个&lt;b&gt;形式语言&lt;/b&gt;，通常我们要研究它的两个方面，&lt;br&gt;其一，形式语言的&lt;b&gt;语法&lt;/b&gt;，指的是字符串的构成方式，&lt;br&gt;其二，形式语言的&lt;b&gt;语义&lt;/b&gt;，指的是每个字符串的含义。&lt;/p&gt;&lt;p&gt;我想大家都已经读过《&lt;a href=&quot;https://book.douban.com/subject/1148282/&quot;&gt;计算机程序的构造与解释&lt;/a&gt;》了吧，&lt;br&gt;所谓构造，指的就是语法，而解释指的就是语义。&lt;/p&gt;&lt;p&gt;那我们来看一看“pq系统”的形式语言该怎样解释吧。&lt;/p&gt;&lt;p&gt;我们可以&lt;b&gt;选择&lt;/b&gt;这样的解释方式，&lt;br&gt;例如，我们可以将&lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt;解释为“等于”，而将&lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt;解释为“加”，将短杠解释为数字。&lt;br&gt;于是，&lt;code class=&quot;inline&quot;&gt;---q-p--&lt;/code&gt;就可以被解释为“3等于1加2”了。&lt;/p&gt;&lt;p&gt;值得注意的是，合理的解释并不一定是唯一的，&lt;br&gt;例如，我们将&lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt;解释为“减”，将&lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt;解释为“等于”，也是可以的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 重新解释&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e603ce2f38b31d4a63e71f103b23171d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;398&quot; data-rawheight=&quot;298&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;上文中我们先给出了形式系统，然后再为系统选择一个合理的解释，&lt;br&gt;这种思维过程是值得提倡的。&lt;/p&gt;&lt;p&gt;考虑语义问题的时候，&lt;br&gt;我们应该总是先想想，&lt;b&gt;当前在对什么系统进行解释&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如，对“pq”系统，我们再引入一条新的公理，&lt;/p&gt;&lt;p&gt;&lt;b&gt;新公理：&lt;br&gt;&lt;/b&gt;只要&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;仅由一串短杠组成，那么&lt;code class=&quot;inline&quot;&gt;xqxp-&lt;/code&gt;也是一条公理。&lt;/p&gt;&lt;p&gt;现在来看，引入的新公理对“pq系统”产生了什么影响。&lt;br&gt;首先，&lt;code class=&quot;inline&quot;&gt;-q-p-&lt;/code&gt;在新系统中是一条公理，而在老系统中不是。&lt;br&gt;其次，根据推导规则，&lt;code class=&quot;inline&quot;&gt;--q-p--&lt;/code&gt;是新系统中的一条定理，而在老系统中也不是。&lt;/p&gt;&lt;p&gt;考虑到我们之前对符号串的解释，我们发现，&lt;br&gt;如果仍然沿用老系统对符号串的解释，&lt;code class=&quot;inline&quot;&gt;--q-p--&lt;/code&gt;应该被解释为“2等于1加2”，&lt;br&gt;这显然是不正确的。&lt;/p&gt;&lt;p&gt;因此，&lt;b&gt;在系统发生变化的时候，旧的解释可能就行不通了&lt;/b&gt;，&lt;br&gt;我们要对系统选择一个新的解释。&lt;/p&gt;&lt;p&gt;例如，我们只需要将&lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt;解释为“小于或等于”就行了。&lt;br&gt;然而，现在看来这种顺利成章的事情，却困扰了数学家们很多年。&lt;/p&gt;&lt;blockquote&gt;这是整个19世纪数学的最深刻的教训之一。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;4. 非欧几何&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f983e4bfb2298074cf707a73f22b27c8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;529&quot; data-rawheight=&quot;178&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;大家应该都听说过欧几里得&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%8C%E5%85%AC%E8%A8%AD&quot;&gt;第五公设&lt;/a&gt;的故事，欧几里得采用了&lt;b&gt;公理化&lt;/b&gt;的方式构建了几何学，&lt;br&gt;其中第五公设又称平行公设，它既不能被其他公设证明，也不能证否，&lt;br&gt;两千年来，在第五公设问题上，耗费了无数年轻数学家的生命和心血。&lt;/p&gt;&lt;blockquote&gt;如果两条直线与第三条直线相交时，在第三条直线的某一侧三条线所夹的内角之和小于两个直角的和，则那两条直线沿着这一侧延伸足够长之后必然相交&lt;/blockquote&gt;&lt;p&gt;1820年左右，俄国喀山大学教授&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B0%BC%E5%8F%A4%E6%8B%89%C2%B7%E7%BD%97%E5%B7%B4%E5%88%87%E5%A4%AB%E6%96%AF%E5%9F%BA&quot;&gt;罗巴切夫斯基&lt;/a&gt;，提出了一个与第五公设相矛盾的命题，&lt;br&gt;然后与欧几里得的前四个公设结合成一个公理系统，展开一系列的推理。&lt;br&gt;他认为如果这个系统在推理中出现矛盾，就等于证明了第五公设，此即数学中的反证法。&lt;/p&gt;&lt;p&gt;但是，在他极为细致深入的推理过程中，&lt;br&gt;得出了一个又一个在直觉上匪夷所思，&lt;br&gt;但在逻辑上毫无矛盾的命题。&lt;/p&gt;&lt;p&gt;这在当时是一件很难理解的事情，&lt;br&gt;因为人们一致认为，欧几里得几何是&lt;b&gt;物质空间中图形性质的正确理想化&lt;/b&gt;。&lt;br&gt;正确的几何结论&lt;b&gt;不应该&lt;/b&gt;与我们的直观感受不符。&lt;/p&gt;&lt;p&gt;现在看来，这样理解当然是有问题的，&lt;br&gt;因为，它&lt;b&gt;混淆了公理系统中的结论，和对这些结论的解释&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;就好像上文中我们为“pq”系统增加了新公理一样，&lt;br&gt;新定理仍然是正确推导的产物，只是不能沿用旧方式进行解释了。&lt;/p&gt;&lt;p&gt;关于欧几里得第五公设，最终人们得到了三种常用的几何学，&lt;br&gt;称为欧几里得几何，罗巴切夫斯基几何，以及黎曼几何。&lt;br&gt;这些公理系统，对研究不同的数学对象起到了关键作用。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;5. 总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文通过一个称之为“pq”的系统，介绍了形式系统公理化的典型步骤，&lt;br&gt;并且严格区分了，公理系统中的&lt;b&gt;结论&lt;/b&gt;与对它的&lt;b&gt;解释&lt;/b&gt;之间的不同。&lt;/p&gt;&lt;p&gt;通过更改公理系统，不论修改公理或者修改推导规则，我们将得到一个新的系统，&lt;br&gt;从而对新系统中的结论，我们就得采用审慎的方式&lt;b&gt;重新解释&lt;/b&gt;。&lt;br&gt;这是数学史给我们带来的最有价值的经验教训之一。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34669807&quot;&gt;你好，类型（一）：开篇&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_system&quot;&gt;Formal system&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_language&quot;&gt;Formal language&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AF%AD%E4%B9%89%E5%AD%A6&quot;&gt;语义学&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1291204/&quot;&gt;哥德尔、艾舍尔、巴赫——集异璧之大成&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%8C%E5%85%AC%E8%A8%AD&quot;&gt;平行公设&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;http://www.kepu.net.cn/gb/basic/szsx/4/44/4_44_1005.htm&quot;&gt;非欧几何学的诞生&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-28-34977830</guid>
<pubDate>Wed, 28 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（十）：Parametric polymorphism</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-27-34936637.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34936637&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6b54d583eb6b73ad8566ca881cf020a0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;698&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们介绍了&lt;b&gt;let多态&lt;/b&gt;，&lt;br&gt;将let表达式 &lt;equation&gt;let~x=t_1~in~t_2&lt;/equation&gt; ，看做了 &lt;equation&gt;[x\mapsto t_1]t_2&lt;/equation&gt; 的简写，&lt;br&gt;即，把 &lt;equation&gt;t_2&lt;/equation&gt; 中出现的所有 &lt;equation&gt;x&lt;/equation&gt; ，都用 &lt;equation&gt;t_1&lt;/equation&gt; 替换掉，因此这些副本可以具有不同的类型。&lt;/p&gt;&lt;p&gt;本文将介绍另外一种多态形式，称为&lt;b&gt;参数化多态&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Parametric_polymorphism&quot;&gt;parametric polymorphism&lt;/a&gt;），例如，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Maybe a = Nothing | Just a&lt;/code&gt;&lt;p&gt;以上Haskell代码，定义了一个&lt;code class=&quot;inline&quot;&gt;Maybe a&lt;/code&gt;类型，&lt;br&gt;其中&lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt;称为类型构造器（type constructor），&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;是它的参数。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt;不是一个合法的类型，它只有和某个具体的&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;放在一起，才是一个合法的类型，&lt;br&gt;例如，&lt;code class=&quot;inline&quot;&gt;Maybe Int&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;Maybe Char&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;System F&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2599a0bf18815b88e00dbfd51c04a385_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;270&quot;&gt;&lt;p&gt;为了实现参数化多态，我们需要对简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算（ &lt;equation&gt;\lambda^\to&lt;/equation&gt; 系统）进行扩展，&lt;br&gt;在 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 中，我们用 &lt;equation&gt;\lambda x.t&lt;/equation&gt; 来表示 &lt;equation&gt;\lambda&lt;/equation&gt; 抽象（lambda abstraction），&lt;br&gt;而使用 &lt;equation&gt;t_1~t_2&lt;/equation&gt; 来表示 &lt;equation&gt;\lambda&lt;/equation&gt; 应用（lambda application）。&lt;/p&gt;&lt;p&gt;现在我们引入一种新的抽象形式， &lt;equation&gt;\lambda X.t&lt;/equation&gt; ，它的参数 &lt;equation&gt;X&lt;/equation&gt; 是一个类型，称为&lt;b&gt;类型抽象&lt;/b&gt;，&lt;br&gt;再引入一种新的应用形式， &lt;equation&gt;t[T]&lt;/equation&gt; ，称为&lt;b&gt;类型实例化&lt;/b&gt;，其中 &lt;equation&gt;T&lt;/equation&gt; 是一个类型表达式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;求值规则&lt;/b&gt;如下，&lt;br&gt; &lt;equation&gt;(\lambda X.t)[T]\to[X\mapsto T]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;例如，我们可以这样定义一个多态函数， &lt;equation&gt;id=\lambda X.\lambda x:X.x&lt;/equation&gt; ，&lt;br&gt;当把它应用于类型 &lt;equation&gt;Nat&lt;/equation&gt; 时，&lt;br&gt; &lt;equation&gt;id[Nat]\to[X\mapsto Nat](\lambda x:X.x)=\lambda x:Nat.x&lt;/equation&gt; ，它为 &lt;equation&gt;Nat&lt;/equation&gt; 类型上的恒等函数。&lt;br&gt;而把它应用于类型 &lt;equation&gt;Bool&lt;/equation&gt; 时，&lt;br&gt; &lt;equation&gt;id[Bool]\to[X\mapsto Bool](\lambda x:X.x)=\lambda x:Bool.x&lt;/equation&gt; ，它为 &lt;equation&gt;Bool&lt;/equation&gt; 类型上的恒等函数，&lt;/p&gt;&lt;p&gt;可见， &lt;equation&gt;id&lt;/equation&gt; 的具体类型，依赖于它的&lt;b&gt;类型参数&lt;/b&gt;。&lt;br&gt;它应用于任意一个类型 &lt;equation&gt;T&lt;/equation&gt; ， &lt;equation&gt;id[T]&lt;/equation&gt; 都会得到一个类型为 &lt;equation&gt;T\to T&lt;/equation&gt; 的函数，&lt;br&gt;因此，人们通常将 &lt;equation&gt;id&lt;/equation&gt; 的类型记为 &lt;equation&gt;\forall X.X\to X&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;类型规则&lt;/b&gt;如下，&lt;/p&gt;&lt;p&gt;（1） &lt;equation&gt;\frac{\Gamma,X\vdash t:T}{\Gamma\vdash\lambda X.t:\forall X.T}&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\frac{\Gamma\vdash t_1:\forall X.T_1}{\Gamma\vdash t[T_2]:[X\mapsto T_2]T_1}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中，类型 &lt;equation&gt;\forall X.T&lt;/equation&gt; ，叫做&lt;b&gt;全称类型&lt;/b&gt;（universal type），&lt;br&gt; &lt;equation&gt;\forall&lt;/equation&gt; 称为&lt;b&gt;全称量词&lt;/b&gt;（universal quantifier），引入了全称类型之后得到的系统，称为&lt;b&gt;System F&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rank-N Types&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e7d0c235c510c23fd00f4261f94e4eb6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;698&quot;&gt;&lt;p&gt;有了全称类型之后，函数的参数类型和返回值类型，都有可能具有全称类型。&lt;br&gt;不难看出，函数返回值类型的全称量词，总是可以提取出来，放到最外面，&lt;br&gt;但是参数类型的全称量词，不能提取出来。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\forall X.X\to (\forall Y.Y\to X)&lt;/equation&gt; ，相当于 &lt;equation&gt;\forall X.\forall Y.X\to Y\to X&lt;/equation&gt; ，&lt;br&gt;而 &lt;equation&gt;(\forall X.X\to X)\to Nat&lt;/equation&gt; ，与 &lt;equation&gt;\forall X.(X\to X)\to Nat&lt;/equation&gt; 则不同。&lt;/p&gt;&lt;p&gt;不包含全称量词的类型表达式，具有&lt;b&gt;rank-0类型&lt;/b&gt;，也称为&lt;b&gt;单态类型&lt;/b&gt;（monotype），&lt;br&gt;全称量词都可以提取出来类型表达式，具有&lt;b&gt;rank-1类型&lt;/b&gt;（rank-1 type），&lt;br&gt;一个函数类型，它的入参具有&lt;b&gt;rank-n类型&lt;/b&gt;，那么该函数就具有&lt;b&gt;rank-(n+1)类型&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如，&lt;br&gt; &lt;equation&gt;((\forall X.X\to X)\to Nat)\to Bool\to Bool&lt;/equation&gt; ，具有rank-3类型，&lt;br&gt; &lt;equation&gt;Nat\to (\forall X.X\to X)&lt;/equation&gt; ，具有rank-1类型。&lt;/p&gt;&lt;p&gt;System F的功能是很强大的，但是&lt;a href=&quot;https://en.wikipedia.org/wiki/System_F#Use_in_programming_languages&quot;&gt;不幸的是&lt;/a&gt;，&lt;br&gt;人们发现，该系统中的类型推导算法是&lt;a href=&quot;https://en.wikipedia.org/wiki/Undecidable_problem&quot;&gt;不可判定的&lt;/a&gt;。&lt;br&gt;例如，一般而言，一个rank-3及其以上rank-N类型的表达式，其类型是不可确定的，&lt;br&gt;为了确定它的类型，人们不得不手工加上必要的类型信息。&lt;/p&gt;&lt;p&gt;Haskell采用了&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system&quot;&gt;Hindley–Milner类型系统&lt;/a&gt;，&lt;br&gt;它是System F的一个子集，其中包含了可判定的类型推导算法。&lt;br&gt;在Haskell中，类型参量（type variable）&lt;b&gt;默认&lt;/b&gt;具有全称类型（universally quantified），&lt;br&gt;例如，&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; a&lt;/code&gt;，实际上表示类型 &lt;equation&gt;\forall a.a\to a&lt;/equation&gt; ，&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; a&lt;/code&gt;可看做&lt;code class=&quot;inline&quot;&gt;(-&amp;gt;) a a&lt;/code&gt;类型，其中&lt;code class=&quot;inline&quot;&gt;-&amp;gt;&lt;/code&gt;为函数类型构造器。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;非直谓性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b687486615e31ac710fae4f635cc5817_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;200&quot; data-rawheight=&quot;257&quot;&gt;&lt;p&gt;在数学和逻辑学中，一个定义称为&lt;b&gt;非直谓的&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Impredicativity&quot;&gt;impredicative&lt;/a&gt;），&lt;br&gt;指的是它包含了自引用（self-reference）。&lt;/p&gt;&lt;p&gt;例如，在定义一个集合的时候，用到了正在定义的这个集合。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Russell%27s_paradox&quot;&gt;罗素悖论&lt;/a&gt;就是用非直谓的方式构造出来的，&lt;br&gt;如果我们定义 &lt;equation&gt;R=\{x|x\notin x\}&lt;/equation&gt; ，那么 &lt;equation&gt;R\in R\Leftrightarrow R\notin R&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;非直谓定义并不一定导致矛盾，有些情况下还是有用的，例如，我们可以非直谓的定义，&lt;br&gt;集合中的最小元素为， &lt;equation&gt;A_{min}=x&lt;/equation&gt; ， &lt;equation&gt;\forall y.x\leqslant y&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;具有参数化多态的类型表达式，也有直谓（predicative）和非直谓（impredicative）之分。&lt;/p&gt;&lt;p&gt;如果它可以用一个多态类型实例化，例如用它自己来实例化，&lt;br&gt;就称为&lt;b&gt;非直谓多态类型&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Parametric_polymorphism#Impredicative_polymorphism&quot;&gt;impredicative polymorphism&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;反之，如果一个多态类型表达式，只能用单态类型实例化，&lt;br&gt;就称它具有&lt;b&gt;直谓多态类型&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Parametric_polymorphism#Predicative_polymorphism&quot;&gt;predicative_polymorphism&lt;/a&gt;）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;单态限制&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9f700c8427d7653a97af35c5fa56445d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;503&quot; data-rawheight=&quot;337&quot;&gt;&lt;code lang=&quot;haskell&quot;&gt;f x = let g y z = ([x,y], z) 
      in ...&lt;/code&gt;&lt;p&gt;假设&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型为&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，那么&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的类型只能为&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; b -&amp;gt; ([a], b)&lt;/code&gt;，&lt;br&gt;其中，由于列表类型的限制，&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;必须具有相同的类型。&lt;/p&gt;&lt;p&gt;此时，只有&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;可以具有全称量词，即 &lt;equation&gt;\forall b.a\to b\to ([a],b)&lt;/equation&gt; ，&lt;br&gt;因为&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;在类型上下文中，已经出现了，不能再被实例化为其他的类型了。&lt;br&gt;我们称，&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的第一个参数&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;具有&lt;b&gt;单态性&lt;/b&gt;（monomorphism）。&lt;/p&gt;&lt;p&gt;例如，&lt;code class=&quot;inline&quot;&gt;(g True, g &#39;c&#39;)&lt;/code&gt;不是良类型的，而&lt;code class=&quot;inline&quot;&gt;(g True, g False)&lt;/code&gt;是良类型的。&lt;/p&gt;&lt;p&gt;值得一提的是，显式的给&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;注明类型，也不能阻止&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的单态行为，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;f x = let 
         g :: a -&amp;gt; b -&amp;gt; ([a],b) 
         g y z = ([x,y], z) 
      in ...&lt;/code&gt;&lt;p&gt;此时，&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;仍然是单态的。&lt;/p&gt;&lt;p&gt;在&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system&quot;&gt;Hindley–Milner类型系统&lt;/a&gt;中，&lt;br&gt;如果一个类型变量，不在类型上下文中出现，它就可以被&lt;b&gt;全称化&lt;/b&gt;（generalize）。&lt;br&gt;但是Haskell考虑到性能和模块间的类型推导，&lt;br&gt;还增加了特殊的&lt;b&gt;单态限制&lt;/b&gt;（monomorphism restriction）避免全称化。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Rule 1&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在一组相互依赖的声明中，满足以下两个条件，其中的类型变量才会被全称化，&lt;br&gt;（1）每一个变量，都被函数或模式匹配所绑定，&lt;br&gt;（2）被模式匹配绑定的变量，都有显式的类型签名。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Rule 2&lt;/b&gt;&lt;/p&gt;&lt;p&gt;导入到其他模块（module）的单态类型变量，被认为是有歧义的（ambiguous），&lt;br&gt;类型通过其来源模块内的&lt;code class=&quot;inline&quot;&gt;default&lt;/code&gt;声明来决定。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;module M1(len1) where 
  default( Int, Double ) 
  len1 = genericLength &quot;Hello&quot;

module M2 where 
  import M1(len1) 
  len2 = (2 * len1) :: Rational&lt;/code&gt;&lt;p&gt;当模块&lt;code class=&quot;inline&quot;&gt;M1&lt;/code&gt;的类型推导结束后，根据Rule 1，&lt;code class=&quot;inline&quot;&gt;len1&lt;/code&gt;具有单态类型，&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;len1 :: Num a =&amp;gt; a&lt;/code&gt;，&lt;br&gt;Rule 2表明，类型变量&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;具有歧义性，必须使用&lt;code class=&quot;inline&quot;&gt;default&lt;/code&gt;声明来解决歧义。&lt;/p&gt;&lt;p&gt;因此，根据&lt;code class=&quot;inline&quot;&gt;default( Int, Double )&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;len1&lt;/code&gt;得到了类型&lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt;，&lt;br&gt;不过，&lt;code class=&quot;inline&quot;&gt;M2&lt;/code&gt;中对&lt;code class=&quot;inline&quot;&gt;len1 :: Int&lt;/code&gt;的使用导致了类型错误。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/1761910/&quot;&gt;Types and programming languages&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.haskell.org/definition/haskell2010.pdf&quot;&gt;Haskell 2010 Language Report&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#arbitrary-rank-polymorphism&quot;&gt;Glasgow Haskell Compiler User’s Guide&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Parametric_polymorphism&quot;&gt;Parametric polymorphism&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/putting.pdf&quot;&gt;Practical type inference for arbitrary-rank types&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/System_F&quot;&gt;System F&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system&quot;&gt;Hindley–Milner type system&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-27-34936637</guid>
<pubDate>Tue, 27 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（九）：Let polymorphism</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-26-34915143.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34915143&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d8893deacbd14601cc4881797561323d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;500&quot;&gt;&lt;h2&gt;&lt;b&gt;类型变量&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;到目前为止，我们遇到的每一个 &lt;equation&gt;\lambda&lt;/equation&gt; 项都有唯一确定的类型，&lt;br&gt;因为，项的类型都被显式的注释在了它的后面。&lt;br&gt;例如，我们可以定义一个恒等函数 &lt;equation&gt;id=\lambda x:Nat.~x:Nat\to Nat&lt;/equation&gt; ，&lt;br&gt;则 &lt;equation&gt;id&lt;/equation&gt; 的类型就是固定的， &lt;equation&gt;Nat\to Nat&lt;/equation&gt; ，而 &lt;equation&gt;id~true&lt;/equation&gt; 就不是良类型的。&lt;/p&gt;&lt;p&gt;为每一个类型的恒等函数都定义各自的版本，是非常繁琐的，&lt;br&gt;因此，一个自然的想法是，我们能否让 &lt;equation&gt;id&lt;/equation&gt; 的类型&lt;b&gt;参数化&lt;/b&gt;，&lt;br&gt;让它在不同的上下文中，实例化为不同的具体类型。&lt;br&gt;例如， &lt;equation&gt;id=\lambda x:X.~x:X\to X&lt;/equation&gt; ，其中 &lt;equation&gt;X&lt;/equation&gt; 是&lt;b&gt;类型参量&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;类型代换&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;类型代换&lt;/b&gt; &lt;equation&gt;\sigma&lt;/equation&gt; ，指的是一个从类型变量到类型的有限映射。&lt;br&gt;例如， &lt;equation&gt;\sigma=[X\mapsto T,Y\mapsto U]&lt;/equation&gt; ，会将类型变量 &lt;equation&gt;X,Y&lt;/equation&gt; 分别代换为 &lt;equation&gt;T,U&lt;/equation&gt; 。&lt;br&gt;其中， &lt;equation&gt;X,Y&lt;/equation&gt; 称为代换 &lt;equation&gt;\sigma&lt;/equation&gt; 的&lt;b&gt;定义域&lt;/b&gt;，记为 &lt;equation&gt;dom(\sigma)&lt;/equation&gt; ，&lt;br&gt;而 &lt;equation&gt;T,U&lt;/equation&gt; 称为代换 &lt;equation&gt;\sigma&lt;/equation&gt; 的&lt;b&gt;值域&lt;/b&gt;，记为 &lt;equation&gt;range(\sigma)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;值得一提的是，所有的代换都是同时进行的， &lt;equation&gt;\sigma=[X\mapsto Bool,Y\mapsto X\to X]&lt;/equation&gt; ，&lt;br&gt;是将 &lt;equation&gt;X&lt;/equation&gt; 映射成 &lt;equation&gt;Bool&lt;/equation&gt; ，将 &lt;equation&gt;Y&lt;/equation&gt; 映射成 &lt;equation&gt;X\to X&lt;/equation&gt; ，而不是 &lt;equation&gt;Bool\to Bool&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;代换&lt;/b&gt;可以用下面的方式来定义，&lt;br&gt;（1） &lt;equation&gt;\sigma(X)=X&lt;/equation&gt; ，如果 &lt;equation&gt;X\notin dom(\sigma)&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\sigma(X)=T&lt;/equation&gt; ，如果 &lt;equation&gt;(X\mapsto T)\in\sigma&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;\sigma(Nat)=Nat&lt;/equation&gt; ， &lt;equation&gt;\sigma(Bool)=Bool&lt;/equation&gt; &lt;br&gt;（4） &lt;equation&gt;\sigma(T_1\to T_2)=\sigma T_1\to\sigma T_2&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;对于类型上下文 &lt;equation&gt;\Gamma=\{x_1:T_1,\cdots,x_n:T_n\}&lt;/equation&gt; 来说， &lt;equation&gt;\sigma\Gamma=\{x_1:\sigma T_1,\cdots,x_n:\sigma T_n\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;类型代换的一个重要特性是它保留了类型声明的有效性，&lt;br&gt;如果包含类型变量的项是良类型的，那么它的所有代换实例也都是良类型的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;类型推断&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-691c692ba80fac2d4b7d02741c0a3da2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;753&quot; data-rawheight=&quot;496&quot;&gt;&lt;p&gt;在类型上下文 &lt;equation&gt;\Gamma&lt;/equation&gt; 中，对于包含类型变量的项 &lt;equation&gt;t&lt;/equation&gt; ，我们通常会提出两个问题，&lt;/p&gt;&lt;p&gt;（1）它的所有代换实例，是否都是良类型的？&lt;br&gt;即，是否 &lt;equation&gt;\forall\sigma\exists T,\sigma\Gamma\vdash\sigma t:T&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;（2）是否存在良类型的代换实例？&lt;br&gt;即，是否 &lt;equation&gt;\exists\sigma\exists T,\sigma\Gamma\vdash\sigma t:T&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;对于第一个问题，将引出&lt;b&gt;参数化多态&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Parametric_polymorphism&quot;&gt;parametric polymorphism&lt;/a&gt;），&lt;br&gt;例如， &lt;equation&gt;\lambda f:X\to X.\lambda a:X.f(f(a))&lt;/equation&gt; ，它的类型为 &lt;equation&gt;(X\to X)\to X\to X&lt;/equation&gt; ，&lt;br&gt;无论用什么具体类型 &lt;equation&gt;T&lt;/equation&gt; 来代换 &lt;equation&gt;X&lt;/equation&gt; ，代换实例都是良类型的。&lt;/p&gt;&lt;p&gt;对于第二个问题，原始的项可能不是良类型的，&lt;br&gt;但是可以选择合适的类型代换使之实例化为良类型的项。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\lambda f:Y.\lambda a:X.f(f(a))&lt;/equation&gt; ，是不可类型化的，&lt;br&gt;但是如果用 &lt;equation&gt;Nat\to Nat&lt;/equation&gt; 代换 &lt;equation&gt;Y&lt;/equation&gt; ，用 &lt;equation&gt;Nat&lt;/equation&gt; 代换 &lt;equation&gt;X&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\sigma=[X\mapsto Nat,Y\mapsto Nat\to Nat]&lt;/equation&gt; ，&lt;br&gt;就可以得到， &lt;equation&gt;\lambda f:Nat\to Nat.\lambda a:Nat.f(f(a))&lt;/equation&gt; ，&lt;br&gt;可类型化为 &lt;equation&gt;(Nat\to Nat)\to Nat\to Nat&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;或者，取 &lt;equation&gt;\sigma&#39;=[Y\mapsto X\to X]&lt;/equation&gt; ，结果也能得到一个良类型的项，尽管仍包含变量。&lt;/p&gt;&lt;p&gt;在寻找类型变量有效实例的过程中，出现了&lt;b&gt;类型推断&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Type_inference&quot;&gt;type inference&lt;/a&gt;）的概念。&lt;br&gt;意味着由编译器来帮助推断 &lt;equation&gt;\lambda&lt;/equation&gt; 项的具体类型，&lt;br&gt;在&lt;a href=&quot;https://en.wikipedia.org/wiki/ML_(programming_language)&quot;&gt;ML&lt;/a&gt;语言中，程序员可以忽略所有的类型注释——隐式类型（&lt;a href=&quot;http://wiki.c2.com/?ImplicitTyping&quot;&gt;implicit typing&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;在进行推断的时候，对每一个原始的 &lt;equation&gt;\lambda&lt;/equation&gt; 抽象 &lt;equation&gt;\lambda x.t&lt;/equation&gt; ，&lt;br&gt;都用新的类型变量进行注释，写成 &lt;equation&gt;\lambda x:X.t&lt;/equation&gt; ，&lt;br&gt;然后采取特定的类型推导算法，找到使项通过类型检查的一个最一般化的解。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;\Gamma&lt;/equation&gt; 为类型上下文， &lt;equation&gt;t&lt;/equation&gt; 为项，&lt;br&gt; &lt;equation&gt;(\Gamma,t)&lt;/equation&gt; 的&lt;b&gt;解&lt;/b&gt;，是指这样的一个序对 &lt;equation&gt;(\sigma,T)&lt;/equation&gt; ，使得 &lt;equation&gt;\sigma\Gamma\vdash\sigma t:T&lt;/equation&gt; 成立。&lt;/p&gt;&lt;p&gt;例如，设 &lt;equation&gt;\Gamma=f:X,a:Y&lt;/equation&gt; ， &lt;equation&gt;t=f~a&lt;/equation&gt; ，则&lt;br&gt; &lt;equation&gt;(\sigma=[X\mapsto Y\to Nat],Nat)&lt;/equation&gt; ， &lt;equation&gt;(\sigma=[X\mapsto Y\to Z],Z)&lt;/equation&gt; ，都是 &lt;equation&gt;(\Gamma,t)&lt;/equation&gt; 的解。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;基于约束的类型化&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-281fd8e3781690168c07b31e22bc9325_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;333&quot; data-rawheight=&quot;109&quot;&gt;&lt;p&gt;&lt;b&gt;（1）约束集&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在实际情况中， &lt;equation&gt;(\Gamma,t)&lt;/equation&gt; 的解，并不一定满足其他类型表达式的约束条件，&lt;br&gt;所以，我们寻找的是满足这些约束条件的特解。&lt;/p&gt;&lt;p&gt;所谓&lt;b&gt;约束条件&lt;/b&gt;，实际上指的是约束集 &lt;equation&gt;C&lt;/equation&gt; ，&lt;br&gt;它由一些包含类型参量的项的等式构成， &lt;equation&gt;\{S_i=T_i|i\in l..n\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果一个代换 &lt;equation&gt;\sigma&lt;/equation&gt; 的代换实例， &lt;equation&gt;\sigma S&lt;/equation&gt; 和 &lt;equation&gt;\sigma T&lt;/equation&gt; 相同，则称该代换&lt;b&gt;合一&lt;/b&gt;（unify）了等式 &lt;equation&gt;S=T&lt;/equation&gt; 。&lt;br&gt;如果 &lt;equation&gt;\sigma&lt;/equation&gt; 能合一 &lt;equation&gt;C&lt;/equation&gt; 中的所有等式，则称 &lt;equation&gt;\sigma&lt;/equation&gt; 能&lt;b&gt;合一&lt;/b&gt;（unify）或满足（satisfy） &lt;equation&gt;C&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们用 &lt;equation&gt;\Gamma\vdash t:T|_\chi C&lt;/equation&gt; ，来表示约束集 &lt;equation&gt;C&lt;/equation&gt; 满足时，项 &lt;equation&gt;t&lt;/equation&gt; 在 &lt;equation&gt;\Gamma&lt;/equation&gt; 下的类型为 &lt;equation&gt;T&lt;/equation&gt; ，&lt;br&gt;其中 &lt;equation&gt;\chi&lt;/equation&gt; 为约束集中，所有类型变量的集合，有时为了讨论方便可以省略它。&lt;/p&gt;&lt;p&gt;例如，对于项 &lt;equation&gt;t=\lambda x:X\to Y.x~0&lt;/equation&gt; ，&lt;br&gt;约束集可以写为 &lt;equation&gt;\{Nat\to Z=X\to Y\}&lt;/equation&gt; ，则 &lt;equation&gt;t&lt;/equation&gt; 类型为 &lt;equation&gt;(X\to Y)\to Z&lt;/equation&gt; 。（算法略）&lt;br&gt;而代换 &lt;equation&gt;\sigma=[X\mapsto Nat,Z\mapsto Bool,Y\mapsto Bool]&lt;/equation&gt; ，使得等式 &lt;equation&gt;Nat\to Z=X\to Y&lt;/equation&gt; 成立，&lt;br&gt;所以，我们推断出了 &lt;equation&gt;(Nat\to Bool)\to Bool&lt;/equation&gt; 是项 &lt;equation&gt;t&lt;/equation&gt; 的一个可能类型。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）约束集的解&lt;/b&gt;&lt;/p&gt;&lt;p&gt;约束集的解一般不是唯一的，所以一个关键问题是如何确定一个“最好”的解。&lt;/p&gt;&lt;p&gt;我们称代换 &lt;equation&gt;\sigma&lt;/equation&gt; 比 &lt;equation&gt;\sigma&#39;&lt;/equation&gt; &lt;b&gt;更具一般性&lt;/b&gt;（more general），如果 &lt;equation&gt;\sigma&#39;=\gamma\circ\sigma&lt;/equation&gt; ，记为 &lt;equation&gt;\sigma\sqsubseteq\sigma&#39;&lt;/equation&gt; ，&lt;br&gt;其中， &lt;equation&gt;\gamma&lt;/equation&gt; 为一个代换， &lt;equation&gt;\gamma\circ\sigma&lt;/equation&gt; 表示代换的复合， &lt;equation&gt;(\gamma\circ\sigma)S=\gamma(\sigma S)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;约束集 &lt;equation&gt;C&lt;/equation&gt; 的&lt;b&gt;主合一子&lt;/b&gt;（principal unifier）指的是代换 &lt;equation&gt;\sigma&lt;/equation&gt; ，&lt;br&gt;它能满足 &lt;equation&gt;C&lt;/equation&gt; ，且对于所有满足 &lt;equation&gt;C&lt;/equation&gt; 的代换 &lt;equation&gt;\sigma&#39;&lt;/equation&gt; ，都有 &lt;equation&gt;\sigma\sqsubseteq\sigma&#39;&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;(\Gamma,t,S,C)&lt;/equation&gt; 的解 &lt;equation&gt;(\sigma,T)&lt;/equation&gt; ，对于任何其他解 &lt;equation&gt;(\sigma&#39;,T&#39;)&lt;/equation&gt; ，都有 &lt;equation&gt;\sigma\sqsubseteq\sigma&#39;&lt;/equation&gt; ，&lt;br&gt;则称 &lt;equation&gt;(\sigma,T)&lt;/equation&gt; 是一个&lt;b&gt;主解&lt;/b&gt;（principal solution），称 &lt;equation&gt;T&lt;/equation&gt;  为 &lt;equation&gt;t&lt;/equation&gt; 的&lt;b&gt;主类型&lt;/b&gt;（principal type）。&lt;br&gt;可以证明，如果 &lt;equation&gt;(\Gamma,t,S,C)&lt;/equation&gt; 有解，则它必有一个主解。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;let多态&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-98db611b8facd70dd4be4eebdc7e1212_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;633&quot; data-rawheight=&quot;357&quot;&gt;&lt;p&gt;&lt;b&gt;多态&lt;/b&gt;（polymorphism）指的是单独一段程序能在不同的上下文中实例化为不同的类型。&lt;br&gt;其中let多态，是由let表达式引入的多态性。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）单态性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;假设我们定义了一个 &lt;equation&gt;double&lt;/equation&gt; 函数，它能将一个函数对参数应用两次，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:Nat\to Nat.\lambda a:Nat.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~double~(\lambda x:Nat.succ~x)~1&lt;/equation&gt; &lt;br&gt;此时， &lt;equation&gt;double&lt;/equation&gt; 的类型为 &lt;equation&gt;(Nat\to Nat)\to Nat\to Nat&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果我们想将 &lt;equation&gt;double&lt;/equation&gt; 应用于其他类型，就必须重写一个新的 &lt;equation&gt;double&#39;&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;let~double&#39;=\lambda f:Bool\to Bool.\lambda a:Bool.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~double&#39;~(\lambda x:Bool.x)~true&lt;/equation&gt; &lt;br&gt;此时 &lt;equation&gt;double&#39;&lt;/equation&gt; 的类型为 &lt;equation&gt;(Bool\to Bool)\to Bool\to Bool&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们不能让一个 &lt;equation&gt;double&lt;/equation&gt; 函数，既能用于 &lt;equation&gt;Nat&lt;/equation&gt; 类型，又能用于 &lt;equation&gt;Bool&lt;/equation&gt; 类型。&lt;br&gt;即使在 &lt;equation&gt;double&lt;/equation&gt; 中用类型变量也没有用，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in~\cdots&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;例如，如果写，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~let~a=double~(\lambda x:Nat.succ~x)~1~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~~~~~let~b=double~(\lambda x:Bool.x)~true~in~\cdots&lt;/equation&gt; &lt;br&gt;则在 &lt;equation&gt;a&lt;/equation&gt; 定义中使用 &lt;equation&gt;double&lt;/equation&gt; ，会产生一个约束 &lt;equation&gt;X\to X=Nat\to Nat&lt;/equation&gt; ，&lt;br&gt;而在 &lt;equation&gt;b&lt;/equation&gt; 定义中使用 &lt;equation&gt;double&lt;/equation&gt; ，则会产生约束 &lt;equation&gt;X\to X=Bool\to Bool&lt;/equation&gt; ，&lt;br&gt;这样会使类型变量 &lt;equation&gt;X&lt;/equation&gt; 的求解发生矛盾，导致整个程序不可类型化。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）多态性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;let多态所做的事情，就是打破这个限制，&lt;br&gt;让类型参量 &lt;equation&gt;X&lt;/equation&gt; 在上述不同的上下文中，可以分别实例化为 &lt;equation&gt;Nat&lt;/equation&gt; 和 &lt;equation&gt;Bool&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;这需要改变与let表达式相关的类型推导规则，在第七篇中，我们提到过，&lt;br&gt; &lt;equation&gt;\frac{\Gamma\vdash t_1:T_1~~~~\Gamma,x:T_1\vdash t_2:T_2}{\Gamma\vdash let~x:T_1=t_1~in~t_2:T_2}&lt;/equation&gt; &lt;br&gt;它会首先计算 &lt;equation&gt;T_1&lt;/equation&gt; 作为 &lt;equation&gt;x&lt;/equation&gt; 的类型，然后再用 &lt;equation&gt;x&lt;/equation&gt; 来确定 &lt;equation&gt;T_2&lt;/equation&gt; 的类型。&lt;br&gt;此时，let表达式 &lt;equation&gt;let~x=t_1:T_1~in~t_2&lt;/equation&gt; ，可以看做 &lt;equation&gt;(\lambda x:T_1.t_2)t_1&lt;/equation&gt; 的简写。&lt;/p&gt;&lt;p&gt;为了引入多态性，我们需要对上述类型推导规则进行修改，&lt;br&gt; &lt;equation&gt;\frac{\Gamma\vdash[x\mapsto t_1]t_2:T_2}{\Gamma\vdash let~x=t_1~in~t_2:T_2}&lt;/equation&gt; &lt;br&gt;它表示，先将 &lt;equation&gt;t_2&lt;/equation&gt; 中的 &lt;equation&gt;x&lt;/equation&gt; 用 &lt;equation&gt;t_1&lt;/equation&gt; 代换掉，然后再确定 &lt;equation&gt;t_2&lt;/equation&gt; 的类型。&lt;/p&gt;&lt;p&gt;这样的话，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~let~a=double~(\lambda x:Nat.succ~x)~1~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~~~~~let~b=double~(\lambda x:Bool.x)~true~in~\cdots&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;就相当于，&lt;br&gt; &lt;equation&gt;let~a=\lambda f:X\to X.\lambda a:X.f(f(a))~(\lambda x:Nat.succ~x)~1~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~let~b=\lambda f:Y\to Y.\lambda a:Y.f(f(a))~(\lambda x:Bool.x)~true~in~\cdots&lt;/equation&gt; &lt;br&gt;通过let多态，产生了 &lt;equation&gt;double&lt;/equation&gt; 的两个&lt;b&gt;副本&lt;/b&gt;，并为之分配了不同的类型参量。&lt;/p&gt;&lt;p&gt;此时，let表达式 &lt;equation&gt;let~x=t_1~in~t_2&lt;/equation&gt; ，可以看做 &lt;equation&gt;[x\mapsto t_1]t_2&lt;/equation&gt; 的简写。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Let-polymorphism&quot;&gt;Hindley–Milner type system&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1761910/&quot;&gt;Types and programming languages&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.haskell.org/definition/haskell2010.pdf&quot;&gt;Haskell 2010 Language Report&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-26-34915143</guid>
<pubDate>Mon, 26 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（八）：Subtype</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-25-34887359.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34887359&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ef77da94879248acb923dc4d037b5b31_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;900&quot; data-rawheight=&quot;554&quot;&gt;&lt;h2&gt;&lt;b&gt;对象和类&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;子类型几乎是面向对象编程语言所特有的，&lt;br&gt;在面向对象的编程语言中，计算是由&lt;b&gt;对象和对象之间消息传递&lt;/b&gt;来完成的，&lt;br&gt;对象（object）通常包含两个组成部分，数据（data）和代码（method）。&lt;/p&gt;&lt;p&gt;其中数据（data）一般是可变的，由每个对象所专有，通常称之为&lt;b&gt;对象的状态&lt;/b&gt;（state）。&lt;br&gt;代码（method）通常是不可变的。&lt;/p&gt;&lt;p&gt;大部分面向对象的编程语言是基于类（class）的，但类（class）却并不是必须的，&lt;br&gt;一个支持&lt;b&gt;词法作用域&lt;/b&gt;的编程语言中，&lt;b&gt;闭包&lt;/b&gt;（closure）就是包含内部状态的对象（object）。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;; let over lambda
(define counter
    (let ((n 0)) 
        (lambda () (set! n (+ n 1)) n)))
(counter)    ; 1
(counter)    ; 2&lt;/code&gt;&lt;p&gt;类（class）实际上可以看做一个工厂函数，用来生成对象。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;; lambda over let over lambda
(define create-counter
    (lambda () 
        (let ((n 0)) 
            (lambda () (set! n (+ n 1)) n))))
(define counter 
    (create-counter))
(counter)    ; 1
(counter)    ; 2&lt;/code&gt;&lt;h2&gt;&lt;b&gt;类型和类&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-695c87c5b9dd61927f549375f2286d3d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;463&quot; data-rawheight=&quot;180&quot;&gt;&lt;p&gt;类型（type）是与类（class）不同的概念。&lt;br&gt;对象所属的类（class）是它的工厂函数，&lt;br&gt;而对象的类型（type），是它在形式系统中，所具有的逻辑性质（logical property）。&lt;/p&gt;&lt;p&gt;子类（subclass），通过编写与父类之间的差别，创建一个新类，目的是&lt;b&gt;代码复用&lt;/b&gt;。&lt;/p&gt;&lt;blockquote&gt;A subclass is a differential description of a class.&lt;/blockquote&gt;&lt;p&gt;包含子类（subclass）之后，众多类（class）之间，&lt;br&gt;构成一个&lt;b&gt;前序关系&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Preorder&quot;&gt;preorder&lt;/a&gt;）（自反，传递）。&lt;/p&gt;&lt;p&gt;而引入子类型（subtype）是为了放宽类型系统的约束条件。&lt;br&gt;例如， &lt;equation&gt;(\lambda r:\{x:Nat\}.~r.x)~\{x=0,y=1\}&lt;/equation&gt; &lt;br&gt;其中， &lt;equation&gt;r&lt;/equation&gt; 的类型为 &lt;equation&gt;\{x:Nat\}&lt;/equation&gt; ，表示&lt;b&gt;记录类型&lt;/b&gt;（record）。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\{x=0,y=1\}&lt;/equation&gt; 的类型为 &lt;equation&gt;\{x:Nat,y:Nat\}&lt;/equation&gt; ，与 &lt;equation&gt;r&lt;/equation&gt; 的类型不同，&lt;br&gt;根据推导规则， &lt;equation&gt;\frac{\Gamma\vdash t_1:T_1\to T_2~~~~\Gamma\vdash t_2:T_1}{\Gamma\vdash t_1~t_2:T_2}&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;(\lambda r:\{x:Nat\}.~r.x)~\{x=0,y=1\}&lt;/equation&gt; 将无法通过类型检查。&lt;/p&gt;&lt;p&gt;可是，函数中确实只用到了 &lt;equation&gt;r.x&lt;/equation&gt; ，多传一个 &lt;equation&gt;y&lt;/equation&gt; 理应总是安全的。&lt;br&gt;因此，不带子类型的简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算，它的推导规则就显得过于严谨了。&lt;/p&gt;&lt;p&gt;我们可以引入记录类型（record）之间的&lt;b&gt;子类型关系&lt;/b&gt;，记为，&lt;br&gt; &lt;equation&gt;\{x:Nat,y:Nat\}&amp;lt;:\{x:Nat\}&lt;/equation&gt; &lt;br&gt;用于表示类型 &lt;equation&gt;\{x:Nat,y:Nat\}&lt;/equation&gt; 是 &lt;equation&gt;\{x:Nat\}&lt;/equation&gt; 的子类型。&lt;/p&gt;&lt;p&gt;对于记录类型来说，这里可能有些奇怪，因为更“小”的类型却包含更多的字段。&lt;/p&gt;&lt;p&gt;一般的， &lt;equation&gt;S&amp;lt;:T&lt;/equation&gt; 表示 &lt;equation&gt;S&lt;/equation&gt; 为 &lt;equation&gt;T&lt;/equation&gt; 的&lt;b&gt;子类型&lt;/b&gt;，&lt;br&gt;如果在某个上下文中，期待一个 &lt;equation&gt;T&lt;/equation&gt; 类型的项，那么 &lt;equation&gt;S&lt;/equation&gt; 在这个上下文中也是合法的，&lt;br&gt;即， &lt;equation&gt;\frac{\Gamma\vdash t:S~~~~S&amp;lt;:T}{\Gamma\vdash t:T}&lt;/equation&gt; ，该推导规则，通常称之为&lt;b&gt;安全替换原则&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;为了能够安全替换，子类型应该具有&lt;b&gt;自反性&lt;/b&gt;： &lt;equation&gt;S&amp;lt;:S&lt;/equation&gt; ，&lt;br&gt;还应该具有&lt;b&gt;传递性&lt;/b&gt;， &lt;equation&gt;\frac{S&amp;lt;:U~~~~U&amp;lt;:T}{S&amp;lt;:T}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Top类型与Bottom类型&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7bdba08bbfb0afbb007f92fcc302e575_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;596&quot; data-rawheight=&quot;436&quot;&gt;&lt;p&gt;&lt;b&gt;（1）Top类型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;理解了子类型之后，我们就可以引入一个新的类型常量 &lt;equation&gt;Top&lt;/equation&gt; ，称为&lt;b&gt;Top类型&lt;/b&gt;。&lt;br&gt;所有其它类型都是它的子类型， &lt;equation&gt;S&amp;lt;:Top&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;因为具有自反性和传递性，子类型之间构成了一个&lt;b&gt;前序关系&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Preorder&quot;&gt;preorder&lt;/a&gt;），&lt;br&gt;由于记录类型中的字段，顺序是可以置换的，&lt;br&gt; &lt;equation&gt;\{x:Nat,y:Nat\}&lt;/equation&gt; 和 &lt;equation&gt;\{y:Nat,x:Nat\}&lt;/equation&gt; 分别为另一个的子类型，&lt;br&gt;因此，子类型关系不是一个&lt;b&gt;偏序关系&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Partially_ordered_set#Formal_definition&quot;&gt;partial order&lt;/a&gt;）（自反，传递，反对称）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）Bottom类型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;除了Top类型之外，我们很自然的会问，&lt;br&gt;是否存在一个类型，它是所有其他类型的子类型，&lt;br&gt;为此，我们需要对类型系统再扩展，引入 &lt;equation&gt;Bot&lt;/equation&gt; 类型常量，称为&lt;b&gt;Bottom类型&lt;/b&gt;，&lt;br&gt;满足 &lt;equation&gt;Bot&amp;lt;:T&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;Bot&lt;/equation&gt; 类型中是不能有&lt;b&gt;闭值&lt;/b&gt;的，否则，假设 &lt;equation&gt;v&lt;/equation&gt; 是 &lt;equation&gt;Bot&lt;/equation&gt; 类型的一个值，&lt;br&gt;则根据安全替换原则有 &lt;equation&gt;v:Top\to Top&lt;/equation&gt; ，表明 &lt;equation&gt;v&lt;/equation&gt; 是一个函数，&lt;br&gt;此外还有 &lt;equation&gt;v:\{\}&lt;/equation&gt; ，表明 &lt;equation&gt;v&lt;/equation&gt; 是一个记录，&lt;br&gt;但是 &lt;equation&gt;v&lt;/equation&gt; 作为一个值，不可能既是函数又是记录，矛盾。&lt;/p&gt;&lt;p&gt;我们在第六篇中提到过，所谓&lt;b&gt;封闭&lt;/b&gt;，指的是不含自由变量。&lt;br&gt;所谓&lt;b&gt;值&lt;/b&gt;，就是事先约定好的&lt;b&gt;项的子集&lt;/b&gt;。&lt;br&gt;值都是&lt;b&gt;范式&lt;/b&gt;，没有求值规则可被继续使用，是对&lt;b&gt;项&lt;/b&gt;求值的最终结果。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;Bot&lt;/equation&gt; 类型中虽然不能有闭值，&lt;br&gt;但是却可以包含&lt;b&gt;受阻项&lt;/b&gt;，即事先约定好的&lt;b&gt;不是值的范式&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如，我们可以指定 &lt;equation&gt;error&lt;/equation&gt; 是一个受阻项（不给它指定求值规则），&lt;br&gt;再指定它为&lt;b&gt;Bottom类型&lt;/b&gt;， &lt;equation&gt;error:Bot&lt;/equation&gt; 。&lt;br&gt;这样 &lt;equation&gt;error&lt;/equation&gt; 就可以在不同的上下文中，被提升为不同的类型了。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\lambda x:T.&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~if ... then&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~~~~~result&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~else&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~~~~~error&lt;/equation&gt;&lt;br&gt;以上 &lt;equation&gt;\lambda&lt;/equation&gt; 项是良类型的（well typed），无论 &lt;equation&gt;result&lt;/equation&gt; 是何种类型。&lt;/p&gt;&lt;p&gt;关于Top类型和Bottom类型，我们最后再看一个例子，&lt;br&gt;&lt;a href=&quot;https://www.typescriptlang.org/index.html&quot;&gt;TypeScript&lt;/a&gt;中的&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/basic-types.html#any&quot;&gt;any&lt;/a&gt;类型，是一个Top类型，&lt;br&gt;而&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/basic-types.html#never&quot;&gt;never&lt;/a&gt;类型，是一个Bottom类型。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文为简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算添加了子类型，&lt;br&gt;并且对比了类（class）与类型（type）这两个概念。&lt;/p&gt;&lt;p&gt;lambda calculus是函数式编程语言的计算模型，&lt;br&gt;前几篇，我们保持基本的演算系统（求值规则）不变，&lt;br&gt;给它添加了不同的类型推导规则，得到了不同的类型系统。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.nada.kth.se/~karlm/ooteori/ObjectCalculus.pdf&quot;&gt;object calculus&lt;/a&gt;是面向对象语言的计算模型，&lt;br&gt;在它之上，我们同样可以添加相似的类型系统。&lt;/p&gt;&lt;p&gt;因此，类型系统是与演算（calculus）独立的概念。&lt;br&gt;这印证了我们之前在第一篇中提到的一句话，&lt;br&gt;类型系统，可以看做是附着在语言语法之上的一套符号证明系统。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/3864436/&quot;&gt;Let Over Lambda&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1761910/&quot;&gt;Types and programming languages&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://lucacardelli.name/Talks/1997-06%20A%20Theory%20of%20Object%20(LICS).pdf&quot;&gt;A Theory of Objects&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-25-34887359</guid>
<pubDate>Sun, 25 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（七）：Recursive type</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-24-34861374.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34861374&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-052f4243204bd6731d6fe46e0070730e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;380&quot;&gt;&lt;p&gt;上文我们介绍了简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统 &lt;equation&gt;\lambda^\to&lt;/equation&gt; ，并给它扩充了单位类型，&lt;br&gt;本文继续为它添加新的特性。&lt;/p&gt;&lt;p&gt;我们将提到&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;letrec&lt;/code&gt;表达式，函数的不动点，&lt;br&gt;代数数据类型，以及递归类型。&lt;/p&gt;&lt;p&gt;最后我们发现，无类型系统实际上是具有，唯一递归类型的一种情形。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;let绑定&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当写一个复杂表达式的时候，为了避免重复和增加可读性，&lt;br&gt;通常我们会给某些子表达式命名，其中一个常用办法是，使用&lt;b&gt;&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;表达式&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;为此，我们要对简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 进行扩展，&lt;br&gt;添加&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;表达式的语法项，求值规则以及类型规则。&lt;/p&gt;&lt;p&gt;&lt;b&gt;新的语法：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;equation&gt;t::=...|let~x:T=t~in~t&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;新的求值规则：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;equation&gt;let~x:T=v~in~t\to [x\mapsto v]t&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;\frac{t_1\to t&#39;_1}{let~x:T_1=t_1~in~t_2\to let~x:T_1=t&#39;_1~in~t_2}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;新的类型规则：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\frac{\Gamma\vdash t_1:T_1~~~~\Gamma,x:T_1\vdash t_2:T_2}{\Gamma\vdash let~x:T_1=t_1~in~t_2:T_2}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这样我们就可以写出&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;表达式了， &lt;equation&gt;let~x:T_1=t_1~in~t_2&lt;/equation&gt; ，&lt;br&gt;它表示，求值表达式 &lt;equation&gt;t_1&lt;/equation&gt; ，然后将其绑定到 &lt;equation&gt;t_2&lt;/equation&gt; 中自由出现的 &lt;equation&gt;x&lt;/equation&gt; 上面，&lt;br&gt;即在当前这种情况下（顾及&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Let-polymorphism&quot;&gt;let polymorphism&lt;/a&gt;），&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;可以表示为， &lt;equation&gt;(\lambda x:T_1.t_2)t_1&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;不动点&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6cfcb32e2362408c47cd0d6629e1f93f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;264&quot; data-rawheight=&quot;191&quot;&gt;&lt;p&gt;以上&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;表达式， &lt;equation&gt;let~x:T_1=t_1~in~t_2&lt;/equation&gt; ，&lt;br&gt;对 &lt;equation&gt;t_1&lt;/equation&gt; 求值的时候有一个限制，那就是 &lt;equation&gt;t_1&lt;/equation&gt; 中不能出现 &lt;equation&gt;x&lt;/equation&gt; ，&lt;br&gt;否则就像方程一样， &lt;equation&gt;x&lt;/equation&gt; 出现在了等式的两边， &lt;equation&gt;x=t_1(x)&lt;/equation&gt; ，&lt;br&gt;此时， &lt;equation&gt;t_2&lt;/equation&gt; 中自由出现的 &lt;equation&gt;x&lt;/equation&gt; ，将是这个方程的解。&lt;/p&gt;&lt;p&gt;不过，通常而言， &lt;equation&gt;t_1&lt;/equation&gt; 中是可以出现 &lt;equation&gt;x&lt;/equation&gt; 的，这时候我们就需要使用&lt;code class=&quot;inline&quot;&gt;letrec&lt;/code&gt;进行绑定了。&lt;/p&gt;&lt;p&gt;为了看清&lt;code class=&quot;inline&quot;&gt;letrec&lt;/code&gt;的真面目，我们用一个求阶乘的例子来说明问题，&lt;br&gt; &lt;equation&gt;letrec~f:nat\to nat=\lambda y:nat.(if~Eq?~y~0~then~1~else~y*f(y-1))~in~f~5&lt;/equation&gt; &lt;br&gt;其中， &lt;equation&gt;nat&lt;/equation&gt; 表示整数类型。&lt;/p&gt;&lt;p&gt;为了求解 &lt;equation&gt;f=\lambda y:nat.(if~Eq?~y~0~then~1~else~y*f(y-1))&lt;/equation&gt; ，&lt;br&gt;我们定义一个新函数 &lt;equation&gt;F&lt;/equation&gt; ，使得，&lt;br&gt; &lt;equation&gt;F=\lambda f:nat\to nat.\lambda y:nat.(if~Eq?~y~0~then~1~else~y*f(y-1))&lt;/equation&gt; ，&lt;br&gt;注意到 &lt;equation&gt;f=F(f)&lt;/equation&gt; ，所以 &lt;equation&gt;f&lt;/equation&gt; 是 &lt;equation&gt;F&lt;/equation&gt; 的&lt;b&gt;不动点&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;这里我们暂且不讨论不动点的存在性和唯一性问题，&lt;br&gt;只是引入一个不动点算子， &lt;equation&gt;fix_\sigma:(\sigma\to\sigma)\to\sigma&lt;/equation&gt; ，&lt;br&gt;它可以用来计算任意函数 &lt;equation&gt;F:\sigma\to\sigma&lt;/equation&gt; 的不动点。&lt;/p&gt;&lt;p&gt;为了达到这个目的， &lt;equation&gt;fix_\sigma&lt;/equation&gt; 必须满足以下约束条件， &lt;equation&gt;fix_\sigma=\lambda f:\sigma\to\sigma.f(fix_\sigma f)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;引入了 &lt;equation&gt;fix_\sigma&lt;/equation&gt; 之后，&lt;code class=&quot;inline&quot;&gt;letrec&lt;/code&gt;就可以用&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;表示出来了，&lt;br&gt; &lt;equation&gt;letrec~f:\sigma=t_1~in~t_2\Leftrightarrow let~f:\sigma=(fix_\sigma\lambda f:\sigma.t_1)~in~t_2&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;&lt;b&gt;代数数据类型&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4f3fd841349e86357a6d5a48a4ef4187_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;220&quot; data-rawheight=&quot;129&quot;&gt;&lt;p&gt;在某些编程语言中，可以自定义递归类型，例如在Haskell中，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data List a = Nil | Cons a (List a)
lst :: List Int 
lst = Cons 1 $ Cons 2 $ Nil&lt;/code&gt;&lt;p&gt;以上定义采用了递归的方式，定义了一个&lt;a href=&quot;https://wiki.haskell.org/Algebraic_data_type&quot;&gt;代数数据类型&lt;/a&gt;&lt;code class=&quot;inline&quot;&gt;List&lt;/code&gt;，&lt;br&gt;所谓代数数据类型，是由基本类型经过复合运算，得来的类型。&lt;/p&gt;&lt;p&gt;Haskell中，使用&lt;code class=&quot;inline&quot;&gt;|&lt;/code&gt;表示&lt;b&gt;和类型&lt;/b&gt;（sum type），&lt;br&gt;而带参数值构造器（value constructor）&lt;code class=&quot;inline&quot;&gt;Cons&lt;/code&gt;，&lt;br&gt;用于表示各参数（&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;List a&lt;/code&gt;）类型的&lt;b&gt;积类型&lt;/b&gt;（product type），&lt;br&gt;无参构造器&lt;code class=&quot;inline&quot;&gt;Nil&lt;/code&gt;，用来表示&lt;b&gt;单位乘积类型&lt;/b&gt;（empty product）。&lt;/p&gt;&lt;p&gt;（关于函数类型与指数的关系，以后有机会再介绍。）&lt;/p&gt;&lt;p&gt;和&lt;code class=&quot;inline&quot;&gt;letrec&lt;/code&gt;中的场景相似的是，&lt;code class=&quot;inline&quot;&gt;List&lt;/code&gt;也出现在了等式的两边，&lt;br&gt;于是，我们定义 &lt;equation&gt;\mu t.\sigma&lt;/equation&gt; ，表示满足等式 &lt;equation&gt;t=\sigma&lt;/equation&gt; 的最小类型，&lt;br&gt;其中， &lt;equation&gt;t&lt;/equation&gt; 和 &lt;equation&gt;\sigma&lt;/equation&gt; 是类型，且 &lt;equation&gt;t&lt;/equation&gt; 通常会在 &lt;equation&gt;\sigma&lt;/equation&gt; 中出现。&lt;/p&gt;&lt;p&gt;因此，以上递归定义的&lt;code class=&quot;inline&quot;&gt;List&lt;/code&gt;类型可以表示为， &lt;equation&gt;\mu\phi.\lambda\alpha.(1+\alpha\times(\phi~\alpha))&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中， &lt;equation&gt;\alpha&lt;/equation&gt; 表示类型参数&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，&lt;br&gt; &lt;equation&gt;\phi&lt;/equation&gt; 是一个函数，用于表示类型构造器（data constructor）&lt;code class=&quot;inline&quot;&gt;List&lt;/code&gt;，&lt;br&gt; &lt;equation&gt;\mu&lt;/equation&gt; 算子用来计算类型的不动点。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;无类型&lt;i&gt;λ&lt;/i&gt;演算&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-42709a95436618c777b3032e41fb6eff_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;337&quot; data-rawheight=&quot;76&quot;&gt;&lt;p&gt;在无类型 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 中，定义递归类型， &lt;equation&gt;\mu t.t\to t&lt;/equation&gt; ，它满足类型等式 &lt;equation&gt;t=t\to t&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;这样的话，无类型 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; ，就可以无缝的&lt;b&gt;嵌入到&lt;/b&gt;一个类型化的系统中去了，&lt;br&gt;该系统只存在一个类型，即递归类型 &lt;equation&gt;\mu t.t\to t&lt;/equation&gt; ，&lt;br&gt;所有的项，都具有这个类型。&lt;/p&gt;&lt;p&gt;因此，对于支持递归类型的系统而言，&lt;br&gt;无类型相当于具有唯一类型（&lt;b&gt;Untyped means uni-typed&lt;/b&gt;）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了递归类型，引入了两个算子 &lt;equation&gt;fix_\sigma&lt;/equation&gt; 和 &lt;equation&gt;\mu&lt;/equation&gt; ，分别用来求解函数和类型的不动点。&lt;br&gt;但是，待求的不动点是否存在，是否唯一，我们仍不能确定。&lt;/p&gt;&lt;p&gt;要想证明这件事情并不简单，需要补充很多额外的数学知识，&lt;br&gt;例如，良基归纳法和最小不动点定理，&lt;br&gt;此外，不动点的存在性，和递归的终止性也有关系。&lt;/p&gt;&lt;p&gt;好在我们所遇到的大多数场景，都是满足这些要求的，&lt;br&gt;因为，我们总是先确信这个解是存在的，然后再去编程，例如，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact :: Int -&amp;gt; Int 
fact 1 = 1
fact n = n * fact (n - 1)&lt;/code&gt;&lt;p&gt;将&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;写到等式两边，能让我们更方便对&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;进行定义。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Algebraic_data_type&quot;&gt;Algebraic data type&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Empty_product&quot;&gt;Empty product&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1761918/&quot;&gt;Foundations for programmming languages&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/26782198/&quot;&gt;Practical Foundations for Programming Languages&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-24-34861374</guid>
<pubDate>Sat, 24 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（六）：Simply typed lambda calculus</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-23-34815896.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34815896&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-36c3e68ae0c501adae575be51013b97e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;683&quot;&gt;&lt;p&gt;简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算（simply typed lambda calculus） &lt;equation&gt;\lambda^\to&lt;/equation&gt; ，是无类型 &lt;equation&gt;\lambda&lt;/equation&gt; 演算的类型化版本，&lt;br&gt;它是众多类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算中最简单的一个。&lt;/p&gt;&lt;p&gt;它只包含一个类型构造器（type constructor） &lt;equation&gt;\to&lt;/equation&gt; ，&lt;br&gt;即，接受两个类型 &lt;equation&gt;T_1,T_2&lt;/equation&gt; 作为参数，返回一个函数类型 &lt;equation&gt;T_1\to T_2&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;下文中，我们首先从最基础的概念说起，详细的区分&lt;b&gt;项&lt;/b&gt;（term）和&lt;b&gt;值&lt;/b&gt;（value）的概念，&lt;br&gt;然后介绍简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统的求值规则和类型规则。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 项和值&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d545f73a2ab9958178ad019e84cc6162_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;620&quot; data-rawheight=&quot;330&quot;&gt;&lt;p&gt;&lt;b&gt;1.1 项&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;项&lt;/b&gt;（term）是一个语法概念，一个合法的项，指的是一段&lt;b&gt;符合语法&lt;/b&gt;的字符串。&lt;br&gt;例如，在 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 系统中，项的定义如下，&lt;br&gt; &lt;equation&gt;t::=x|\lambda x.t|t~t&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;它表明，一个合法的 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 项，要么是一个变量 &lt;equation&gt;x&lt;/equation&gt; ，&lt;br&gt;要么是一个 &lt;equation&gt;\lambda&lt;/equation&gt; &lt;b&gt;抽象&lt;/b&gt;（abstraction） &lt;equation&gt;\lambda x.t&lt;/equation&gt; ，要么是一个 &lt;equation&gt;\lambda&lt;/equation&gt; &lt;b&gt;应用&lt;/b&gt;（application） &lt;equation&gt;t~t&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.2 值&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;值&lt;/b&gt;（value）是一个和&lt;b&gt;语义&lt;/b&gt;相关的概念，有三种常用的方法为项指定语义。&lt;br&gt;（1）操作语义，通过定义一个简单的抽象机器，来说明一个程序语言的行为。&lt;br&gt;（2）指称语义，一个项的语义是一个数学对象。&lt;br&gt;（3）公理语义，不是首先定义程序的行为，而是用项所满足的规则限定它的语义。&lt;/p&gt;&lt;p&gt;下面我们采用操作语义的方法，来定义求值的概念。&lt;br&gt;首先，我们&lt;b&gt;人为指定项的一个子集&lt;/b&gt;，将其中的元素称为&lt;b&gt;值&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;假如项的定义如下， &lt;equation&gt;t::=true|false|if~t~then~t~else~t&lt;/equation&gt; ，&lt;br&gt;我们可以定义值， &lt;equation&gt;v::=true|false&lt;/equation&gt; 。&lt;br&gt;值可能是项被求值的最终结果，但也&lt;b&gt;不全是&lt;/b&gt;，因为对某些项的求值过程可能不会终止。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.3 求值规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;求值规则，是定义在项上的推导规则，例如，&lt;br&gt;（1） &lt;equation&gt;if~true~then~t_1~else~t_2\to t_1&lt;/equation&gt; ，&lt;br&gt;（2） &lt;equation&gt;if~false~then~t_1~else~t_2\to t_2&lt;/equation&gt; ，&lt;br&gt;（3） &lt;equation&gt;\frac{t_1\to t&#39;_1}{if~t_1~then~t_2~else~t_3\to if~t&#39;_1~then~t_2~else~t_3}&lt;/equation&gt; &lt;br&gt;其中， &lt;equation&gt;x\to y&lt;/equation&gt; 表示，项 &lt;equation&gt;x&lt;/equation&gt; 可以一步求值为项 &lt;equation&gt;y&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.4 范式&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一个不含自由变量的项，称为&lt;b&gt;封闭项&lt;/b&gt;，封闭项也称为&lt;b&gt;组合子&lt;/b&gt;。&lt;br&gt;例如，恒等函数 &lt;equation&gt;id=\lambda x.x&lt;/equation&gt; 就是一个封闭项。&lt;/p&gt;&lt;p&gt;如果没有求值规则可用于项 &lt;equation&gt;t&lt;/equation&gt; ，就称该项是一个&lt;b&gt;范式&lt;/b&gt;。&lt;br&gt;范式可能是一个值，也可能不是，但每一个值都应该是范式。&lt;/p&gt;&lt;p&gt;如果一个封闭项是一个范式，但不是一个值，就称该项&lt;b&gt;受阻&lt;/b&gt;。&lt;br&gt;不是值的范式，在运行时间错误分析中起着极其重要的作用。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 类型&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e58cfc7a10ec61f71b2d4cc93530652e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;480&quot; data-rawheight=&quot;280&quot;&gt;&lt;p&gt;&lt;b&gt;2.1 类型上下文&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一个&lt;b&gt;类型上下文&lt;/b&gt;（也称&lt;b&gt;类型环境&lt;/b&gt;） &lt;equation&gt;\Gamma&lt;/equation&gt; ，是一个变量和类型之间绑定关系的集合。&lt;br&gt;空上下文，可以记为 &lt;equation&gt;\varnothing&lt;/equation&gt; ，但是我们经常省略它。&lt;/p&gt;&lt;p&gt;用逗号可以在 &lt;equation&gt;\Gamma&lt;/equation&gt; 右边加入一个新的&lt;b&gt;绑定&lt;/b&gt;，例如， &lt;equation&gt;\Gamma,x:T&lt;/equation&gt; 。&lt;br&gt; &lt;equation&gt;\vdash t:T&lt;/equation&gt; ，表示项 &lt;equation&gt;t&lt;/equation&gt; 在空的类型上下文中，有类型 &lt;equation&gt;T&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.1 类型规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\lambda^\to&lt;/equation&gt; 是一个新的系统，比起 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 而言，增加了一些基于类型的推导规则。&lt;/p&gt;&lt;p&gt;其中， &lt;equation&gt;\lambda^\to&lt;/equation&gt; 中 &lt;equation&gt;\lambda&lt;/equation&gt; 项的语法如下：&lt;br&gt;（1） &lt;equation&gt;t::=x|\lambda x:T.t|t~t&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;T::=T\to T&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;\Gamma::=\varnothing|\Gamma,x:T&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;推导规则：&lt;br&gt;（1） &lt;equation&gt;\frac{x:T\in\Gamma}{\Gamma\vdash x:T}&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\frac{\Gamma,x:T_1\vdash t:T_2}{\Gamma\vdash\lambda x:T_1.t:T_1\to T_2}&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;\frac{\Gamma\vdash t_1:T_1\to T_2~~~~\Gamma\vdash t_2:T_1}{\Gamma\vdash t_1~t_2:T_2}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;根据以上的推导规则，我们可以证明， &lt;equation&gt;\vdash(\lambda x:Bool.x)~true:Bool&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3 求值规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\lambda^\to&lt;/equation&gt; 系统中，值的定义如下：&lt;br&gt;（1） &lt;equation&gt;v::=\lambda x:T.t&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;求值规则，定义如下：&lt;br&gt;（1） &lt;equation&gt;\frac{t_1\to t&#39;_1}{t_1~t_2\to t&#39;_1~t_2}&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\frac{t_2\to t&#39;_2}{t_1~t_2\to t_1~t&#39;_2}&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;(\lambda x:T.t)~v\to [x\mapsto v]t&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中（2），相当于 &lt;equation&gt;\beta&lt;/equation&gt; 变换，&lt;br&gt; &lt;equation&gt;[x\mapsto v]t&lt;/equation&gt; ，表示将 &lt;equation&gt;t&lt;/equation&gt; 中所有自由出现的 &lt;equation&gt;x&lt;/equation&gt; 换为 &lt;equation&gt;v&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.4 Curry-style and Church-style&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对于 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 系统来说，通常有两种不同风格的解释方式，&lt;br&gt;如果我们首先定义项，然后定义项的求值规则——语义，&lt;br&gt;最后再定义一个类型系统，用以排除掉我们不需要的项，&lt;br&gt;这种语义先于类型的定义方式，称为&lt;b&gt;Curry-style&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;另一方面，如果我们定义项，然后再给出良类型的定义，&lt;br&gt;最后再给出这些良类型项的语义，就称为&lt;b&gt;Church-style&lt;/b&gt;，类型先于语义，&lt;br&gt;在Church-style的系统中，我们不关心不良类型项的语义。&lt;/p&gt;&lt;p&gt;历史上，隐式类型的 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统，通常是Curry-style的，&lt;br&gt;而显式类型的 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统，通常是Church-style的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 关于单位类型&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算，直接用起来可能并不好用，&lt;br&gt;人们会再为它扩充一些类型，例如，添加一些基本类型 &lt;equation&gt;Bool&lt;/equation&gt; ， &lt;equation&gt;Nat&lt;/equation&gt; 或者 &lt;equation&gt;String&lt;/equation&gt; ，&lt;br&gt;定义单位类型，列表类型，元组类型，和类型，等等。&lt;/p&gt;&lt;p&gt;下面我们选择&lt;b&gt;单位类型&lt;/b&gt;进行介绍。&lt;/p&gt;&lt;p&gt;满足单位类型的项只有一个，为此我们新增一个项的定义，&lt;br&gt; &lt;equation&gt;t::=...|unit&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;再新增一个类型的定义，&lt;br&gt; &lt;equation&gt;T::=Unit&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;以及一个推导规则，&lt;br&gt; &lt;equation&gt;\Gamma\vdash unit:Unit&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;Unit&lt;/equation&gt; 的作用类似于C和Java中的 &lt;equation&gt;void&lt;/equation&gt; 类型，主要用于表示副作用，&lt;br&gt;在这样的语言中，我们往往并不关心表达式的结果，而只关心它的副作用，&lt;br&gt;因此，用 &lt;equation&gt;Unit&lt;/equation&gt; 来表示结果的类型，是一个合适的选择。&lt;/p&gt;&lt;p&gt;这里提到单位类型，是为以后Top类型和Bot类型做铺垫。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus&quot;&gt;Wikipedia: Simply typed lambda calculus&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1318672/&quot;&gt;类型和程序设计语言&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-23-34815896</guid>
<pubDate>Fri, 23 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（五）：Predicate logic</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-22-34779520.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34779520&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-091d7c00fbbec8cf93cdba5bf3847b5e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;960&quot; data-rawheight=&quot;600&quot;&gt;&lt;p&gt;从形式系统的角度来看，&lt;br&gt;一阶谓词逻辑，只是比命题逻辑多添加了一些公理，&lt;br&gt;或者多添加了一些推导规则，&lt;br&gt;然而，这样的举动，却会让形式系统截然不同。&lt;/p&gt;&lt;p&gt;欧几里得第五公设，是一个公理，无法由前四个公设推导证明，&lt;br&gt;在原来的欧氏几何中去掉它，然后添加上不同的第五公设，就变成了不同的几何，&lt;br&gt;黎曼几何与闵可夫斯基几何。&lt;/p&gt;&lt;p&gt;因此，&lt;b&gt;不同的公理和推导规则，构成了不同的形式系统&lt;/b&gt;，哪怕是有很小的变化。&lt;br&gt;本文我们来扩充前一篇中提到的，命题逻辑形式系统 &lt;equation&gt;P&lt;/equation&gt; ，&lt;br&gt;以及，命题逻辑的自然演绎系统 &lt;equation&gt;N&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 一阶谓词逻辑形式系统&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;1.1 公理和推导规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;命题逻辑形式系统 &lt;equation&gt;P&lt;/equation&gt; ，只有三条公理，一条推导规则，&lt;br&gt;以下我们保持推导规则不变，为它添加四条公理，这样得到的系统，我们记为 &lt;equation&gt;K_\mathscr{L}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;公理：&lt;/b&gt;（有7条公理）&lt;/p&gt;&lt;p&gt;（1）~（3）与命题逻辑形式系统 &lt;equation&gt;P&lt;/equation&gt; 相同&lt;br&gt;（4） &lt;equation&gt;\forall x\alpha\to\alpha(x/t)&lt;/equation&gt; ，若 &lt;equation&gt;t&lt;/equation&gt; 对 &lt;equation&gt;x&lt;/equation&gt; 在 &lt;equation&gt;\alpha&lt;/equation&gt; 中自由出现&lt;br&gt;（5） &lt;equation&gt;\alpha\to\forall x\alpha&lt;/equation&gt; ，若 &lt;equation&gt;x&lt;/equation&gt; 不在 &lt;equation&gt;\alpha&lt;/equation&gt; 中自由出现&lt;br&gt;（6） &lt;equation&gt;\forall x(\alpha\to\beta)\to(\forall x\alpha\to\forall x\beta)&lt;/equation&gt; &lt;br&gt;（7）若 &lt;equation&gt;\alpha&lt;/equation&gt; 是 &lt;equation&gt;K_\mathscr{L}&lt;/equation&gt; 的一个公理，则 &lt;equation&gt;\forall x\alpha&lt;/equation&gt; 也为 &lt;equation&gt;K_\mathscr{L}&lt;/equation&gt; 的一个公理&lt;/p&gt;&lt;p&gt;&lt;b&gt;推导规则：&lt;/b&gt;(只有一条)&lt;/p&gt;&lt;p&gt;（1）与命题逻辑形式系统 &lt;equation&gt;P&lt;/equation&gt; 相同&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c9a2f0658bc6e1397789a599eaad2858_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;284&quot; data-rawheight=&quot;240&quot;&gt;&lt;p&gt;&lt;b&gt;1.2 辖域和自由出现&lt;/b&gt;&lt;/p&gt;&lt;p&gt;其中（5）和（6）中提到了“自由出现”的概念，现在解释如下。&lt;/p&gt;&lt;p&gt;我们称公式 &lt;equation&gt;\forall x\alpha&lt;/equation&gt; 中的 &lt;equation&gt;\alpha&lt;/equation&gt; ，为量词 &lt;equation&gt;\forall x&lt;/equation&gt; 的&lt;b&gt;辖域&lt;/b&gt;。&lt;br&gt;变元符号 &lt;equation&gt;x&lt;/equation&gt; 在公式 &lt;equation&gt;\alpha&lt;/equation&gt; 中的某处出现，如果是在量词 &lt;equation&gt;\forall x&lt;/equation&gt; 的辖域内，&lt;br&gt;则称为&lt;b&gt;约束出现&lt;/b&gt;，否则称为&lt;b&gt;自由出现&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\forall x_1 F(x_1)\to F(x_1)&lt;/equation&gt; ，&lt;br&gt;由于 &lt;equation&gt;\to&lt;/equation&gt; 的优先级比较低，上式相当于 &lt;equation&gt;(\forall x_1 F(x_1))\to F(x_1)&lt;/equation&gt; ，&lt;br&gt;所以，第一个 &lt;equation&gt;x_1&lt;/equation&gt; 是约束出现，第二个 &lt;equation&gt;x_1&lt;/equation&gt; 是自由出现。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.3 例式&lt;/b&gt;&lt;/p&gt;&lt;p&gt;上述公理（4）中，出现了 &lt;equation&gt;\alpha(x/t)&lt;/equation&gt; ，它称为公式 &lt;equation&gt;\alpha&lt;/equation&gt; 的&lt;b&gt;例式&lt;/b&gt;。&lt;br&gt;它表示，将 &lt;equation&gt;\alpha&lt;/equation&gt; 中每一个自由出现的 &lt;equation&gt;x&lt;/equation&gt; ，都替换为项 &lt;equation&gt;t&lt;/equation&gt; 之后，得到的公式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.4 简写&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们记，&lt;br&gt; &lt;equation&gt;\alpha\lor\beta&lt;/equation&gt; ，为 &lt;equation&gt;\neg\alpha\to\beta&lt;/equation&gt; 的简写，&lt;br&gt; &lt;equation&gt;\alpha\land\beta&lt;/equation&gt; ，为 &lt;equation&gt;\neg(\neg\alpha\lor\neg\beta)&lt;/equation&gt; 的简写，&lt;br&gt; &lt;equation&gt;\alpha\leftrightarrow\beta&lt;/equation&gt; ，为 &lt;equation&gt;(\alpha\to\beta)\land(\beta\to\alpha)&lt;/equation&gt; 的简写，&lt;br&gt; &lt;equation&gt;\exists x\alpha&lt;/equation&gt; ，为 &lt;equation&gt;\neg\forall x(\neg\alpha)&lt;/equation&gt; 的简写。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.5 举个例子&lt;/b&gt;&lt;/p&gt;&lt;p&gt;求证：设项 &lt;equation&gt;t&lt;/equation&gt; 对变元符号 &lt;equation&gt;x&lt;/equation&gt; 在 &lt;equation&gt;\alpha&lt;/equation&gt; 中自由，则 &lt;equation&gt;\alpha(x/t)\to\exists x\alpha&lt;/equation&gt; 是 &lt;equation&gt;K_\mathscr{L}&lt;/equation&gt; 是一条定理。&lt;/p&gt;&lt;p&gt;&lt;b&gt;证明：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;因为 &lt;equation&gt;(\neg\alpha)(x/t)=\neg(\alpha(x/t))&lt;/equation&gt; ，&lt;br&gt;又根据公理（4）， &lt;equation&gt;\forall x(\neg\alpha)\to(\neg\alpha)(x/t)&lt;/equation&gt; ，&lt;br&gt;所以， &lt;equation&gt;\forall x(\neg\alpha)\to\neg(\alpha(x/t))&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;又根据公理（3）， &lt;equation&gt;(\neg\alpha\to\neg\beta)\to(\beta\to\alpha)&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\forall x(\neg\alpha)\to\neg(\alpha(x/t))\to(\alpha(x/t)\to\neg\forall x(\neg\alpha))&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;再根据推导规则（1）， &lt;equation&gt;\frac{\alpha\to\beta,\alpha}{\beta}&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\alpha(x/t)\to\neg\forall x(\neg\alpha)&lt;/equation&gt; ，即 &lt;equation&gt;\alpha(x/t)\to\exists x\alpha&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;证毕。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 一阶谓词逻辑的自然演绎系统&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9d597cd7d783566ac68247109b5a9b95_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;440&quot; data-rawheight=&quot;128&quot;&gt;&lt;p&gt;上一篇中我们介绍了命题逻辑的自然演绎系统 &lt;equation&gt;N&lt;/equation&gt; ，&lt;br&gt;而且，我们知道了 &lt;equation&gt;N&lt;/equation&gt; 是与命题逻辑形式系统 &lt;equation&gt;P&lt;/equation&gt; 是等价的。&lt;/p&gt;&lt;p&gt;现在我们扩充 &lt;equation&gt;N&lt;/equation&gt; ，得到一阶谓词逻辑的自然演绎系统 &lt;equation&gt;N_\mathscr{L}&lt;/equation&gt; ，&lt;br&gt;它与一阶谓词逻辑形式系统 &lt;equation&gt;K_\mathscr{L}&lt;/equation&gt; 也是等价的。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;K_\mathscr{L}&lt;/equation&gt; 和 &lt;equation&gt;P&lt;/equation&gt; 一样，是Hilbert-style演绎系统，它们具有更多的公理，更少的推导规则，&lt;br&gt;而 &lt;equation&gt;N_\mathscr{L}&lt;/equation&gt; 和 &lt;equation&gt;N&lt;/equation&gt; ，是Gentzen-style自然演绎（natural dedution）系统，&lt;br&gt;它们具有更少的公理，更多的推导规则。&lt;/p&gt;&lt;p&gt;由于 &lt;equation&gt;N_\mathscr{L}&lt;/equation&gt; 是对 &lt;equation&gt;N&lt;/equation&gt; 的扩充，下文中，我们只列出新增的公理和推导规则。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.1 公理和推导规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;公理：&lt;/b&gt;（有零条公理）&lt;/p&gt;&lt;p&gt;公理集仍为空集。&lt;/p&gt;&lt;p&gt;&lt;b&gt;推导规则：&lt;/b&gt;（有15条）&lt;/p&gt;&lt;p&gt;（1）~（10）与命题逻辑的自然演绎系统 &lt;equation&gt;N&lt;/equation&gt; 相同&lt;br&gt;（11）增加前提律： &lt;equation&gt;\frac{\Gamma\vdash\alpha}{\Gamma,\beta\vdash\alpha}&lt;/equation&gt; &lt;br&gt;（12） &lt;equation&gt;\forall&lt;/equation&gt; 消去律： &lt;equation&gt;\frac{\Gamma\vdash\forall x\alpha}{\Gamma\vdash\alpha(x/t)}&lt;/equation&gt; ， &lt;equation&gt;t&lt;/equation&gt; 对 &lt;equation&gt;x&lt;/equation&gt; 在 &lt;equation&gt;\alpha&lt;/equation&gt; 中自由出现&lt;br&gt;（13） &lt;equation&gt;\forall&lt;/equation&gt; 引入律： &lt;equation&gt;\frac{\Gamma\vdash\alpha}{\Gamma\vdash\forall x\alpha}&lt;/equation&gt; &lt;br&gt;（14） &lt;equation&gt;\exists&lt;/equation&gt; 消去律： &lt;equation&gt;\frac{\Gamma,\alpha\vdash\beta}{\Gamma\cup\{\exists x\alpha\}\vdash\beta}&lt;/equation&gt; ， &lt;equation&gt;x&lt;/equation&gt; 不在 &lt;equation&gt;\Gamma\cup\{\beta\}&lt;/equation&gt; 中自由出现&lt;br&gt;（15） &lt;equation&gt;\exists&lt;/equation&gt; 引入律： &lt;equation&gt;\frac{\Gamma\vdash\alpha(x/t)}{\Gamma\vdash\exists x\alpha}&lt;/equation&gt; ， &lt;equation&gt;t&lt;/equation&gt; 对 &lt;equation&gt;x&lt;/equation&gt; 在 &lt;equation&gt;\alpha&lt;/equation&gt; 中自由出现&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 举个例子&lt;/b&gt;&lt;/p&gt;&lt;p&gt;求证： &lt;equation&gt;\forall x(\alpha\leftrightarrow\beta)\vdash\forall x\alpha\leftrightarrow\forall x\beta&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;证明：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;根据规则（1）包含律，&lt;br&gt;（1） &lt;equation&gt;\forall x(\alpha\leftrightarrow\beta),\forall x\alpha\vdash\forall x(\alpha\leftrightarrow\beta)&lt;/equation&gt; ，&lt;br&gt;（2） &lt;equation&gt;\forall x(\alpha\leftrightarrow\beta),\forall x\alpha\vdash\forall x\alpha&lt;/equation&gt; ，&lt;/p&gt;&lt;p&gt;根据规则（12） &lt;equation&gt;\forall&lt;/equation&gt; 消去律，&lt;br&gt;（3） &lt;equation&gt;\forall x(\alpha\leftrightarrow\beta),\forall x\alpha\vdash\alpha\leftrightarrow\beta&lt;/equation&gt; ，&lt;br&gt;（4） &lt;equation&gt;\forall x(\alpha\leftrightarrow\beta),\forall x\alpha\vdash\alpha&lt;/equation&gt; ，&lt;/p&gt;&lt;p&gt;式（3）（4），根据规则（9） &lt;equation&gt;\leftrightarrow&lt;/equation&gt; 消去律，&lt;br&gt;（5） &lt;equation&gt;\forall x(\alpha\leftrightarrow\beta),\forall x\alpha\vdash\beta&lt;/equation&gt; ，&lt;/p&gt;&lt;p&gt;式（4）（5），根据规则（13） &lt;equation&gt;\forall&lt;/equation&gt; 引入律，&lt;br&gt;（6） &lt;equation&gt;\forall x(\alpha\leftrightarrow\beta),\forall x\alpha\vdash\forall x\alpha&lt;/equation&gt; ，&lt;br&gt;（7） &lt;equation&gt;\forall x(\alpha\leftrightarrow\beta),\forall x\alpha\vdash\forall x\beta&lt;/equation&gt; ，&lt;/p&gt;&lt;p&gt;式（6）（7），根据规则（10） &lt;equation&gt;\leftrightarrow&lt;/equation&gt; 引入律，&lt;br&gt;（8） &lt;equation&gt;\forall x(\alpha\leftrightarrow\beta),\forall x\alpha\vdash\forall x\alpha\leftrightarrow\forall x\beta&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;证毕。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了两种风格的一阶谓词逻辑演算系统，&lt;br&gt;其中 &lt;equation&gt;K_\mathscr{L}&lt;/equation&gt; 是Hilbert-style演绎系统， &lt;equation&gt;N_\mathscr{L}&lt;/equation&gt; 是Gentzen-style自然演绎系统，&lt;br&gt;可以证明它们是等价的。&lt;/p&gt;&lt;p&gt;结合上一篇，我们已经从形式系统的角度介绍了命题逻辑和一阶谓词逻辑，&lt;br&gt;我们有了足够的基础之后，就可以给 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 系统加上类型，&lt;br&gt;开始介绍简单类型 &lt;equation&gt;\lambda&lt;/equation&gt; 演算了。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/1230394/&quot;&gt;离散数学教程&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-22-34779520</guid>
<pubDate>Thu, 22 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（四）：Propositional logic</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-21-34727603.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34727603&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-897ab7cefcbb564c85f1957197277fd4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1000&quot; data-rawheight=&quot;667&quot;&gt;&lt;p&gt;前两篇中，我们介绍了 &lt;equation&gt;\lambda&lt;/equation&gt; 演算和 &lt;equation&gt;CL&lt;/equation&gt; （组合子逻辑），&lt;br&gt;我们采用了&lt;b&gt;公理化&lt;/b&gt;的方法，先定义系统中的&lt;b&gt;公理&lt;/b&gt;，然后定义&lt;b&gt;推导规则&lt;/b&gt;，&lt;br&gt;最终得到了两个形式系统， &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 系统以及 &lt;equation&gt;CL_w&lt;/equation&gt; 系统。&lt;/p&gt;&lt;p&gt;值得注意的是，公理系统不仅仅包含由公理和推导构成的形式系统，&lt;br&gt;还包含给这个形式系统所选择的&lt;b&gt;语义&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;给形式系统选择一个可靠的语义，是复杂的，我们将在后文再详细介绍。&lt;br&gt;从这一篇开始，我们先开始介绍数理逻辑，看看逻辑学是怎么看待形式化问题的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 命题逻辑形式系统&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-89691c7db7db4be90b3d28d1f7109e3d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;499&quot; data-rawheight=&quot;411&quot;&gt;&lt;p&gt;下文中，我们采用与 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 系统， &lt;equation&gt;CL_w&lt;/equation&gt; 系统相同的方式，&lt;br&gt;来介绍&lt;b&gt;命题逻辑&lt;/b&gt;（&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91&quot;&gt;propositional logic&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;命题逻辑，是在研究命题的证明和推理的过程中抽象出来的，&lt;br&gt;先不考虑语义，仅仅从符号的角度（形式化）来考虑它，则是更简单直接的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.1 公理和推导规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;首先我们给出命题逻辑形式系统中的&lt;b&gt;公理&lt;/b&gt;（有三条公理），&lt;br&gt;（1） &lt;equation&gt;\alpha\to(\beta\to\alpha)&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;(\alpha\to(\beta\to\gamma))\to((\alpha\to\beta)\to(\alpha\to\gamma))&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;(\neg\alpha\to\neg\beta)\to(\beta\to\alpha)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;然后，我们给出命题逻辑形式系统中的&lt;b&gt;推导规则&lt;/b&gt;（只有一条），&lt;br&gt;（1） &lt;equation&gt;\frac{\alpha,\alpha\to\beta}{\beta}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;以上推导规则可以理解为，如果 &lt;equation&gt;\alpha&lt;/equation&gt; 和 &lt;equation&gt;\alpha\to\beta&lt;/equation&gt; 成立，则 &lt;equation&gt;\beta&lt;/equation&gt; 成立。&lt;/p&gt;&lt;p&gt;这里我们采用了&lt;b&gt;推导规则&lt;/b&gt;的常用写法， &lt;equation&gt;\frac{P_1,P_2,\cdots,P_n}{C}&lt;/equation&gt; ，&lt;br&gt;横线上面的部分“ &lt;equation&gt;P_1,P_2,\cdots,P_n&lt;/equation&gt; ”称为规则的&lt;b&gt;前提&lt;/b&gt;（premise），&lt;br&gt;横线下面的部分“ &lt;equation&gt;C&lt;/equation&gt; ”，称为&lt;b&gt;结论&lt;/b&gt;（conclusion）。&lt;/p&gt;&lt;p&gt;在命题逻辑中，根据公理和推导规则，得到的公式称为&lt;b&gt;定理&lt;/b&gt;。&lt;br&gt;根据公理，定理和推导规则，得到的公式也是定理。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.2 例子&lt;/b&gt;&lt;/p&gt;&lt;p&gt;下面我们来看一个例子，&lt;br&gt;求证： &lt;equation&gt;(\alpha\to\beta)\to(\alpha\to\alpha)&lt;/equation&gt; 是一个定理。&lt;/p&gt;&lt;p&gt;&lt;b&gt;证明：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;首先，我们使用公理（1），我们有下式成立，&lt;br&gt; &lt;equation&gt;\alpha\to(\beta\to\alpha)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;然后，我们使用公理（2），并令其中的 &lt;equation&gt;\gamma=\alpha&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;(\alpha\to(\beta\to\alpha))\to((\alpha\to\beta)\to(\alpha\to\alpha))&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;最后，我们结合以上两个结论，再使用推导规则（1），就得到了，&lt;br&gt; &lt;equation&gt;(\alpha\to\beta)\to(\alpha\to\alpha)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;证毕。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. Hilbert-style和Gentzen-style&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bfab9a70c00bf9246a1a0017ba822571_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;547&quot; data-rawheight=&quot;294&quot;&gt;&lt;p&gt;以上的证明过程中，每一行断言，是一个不包含条件的定理，&lt;br&gt;这种风格的演绎系统（deduction system）称为具有&lt;b&gt;Hilbert-style&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;\Gamma,\Delta&lt;/equation&gt; 是有限的公式集合，则， &lt;equation&gt;\Gamma\vdash\Delta&lt;/equation&gt; ，称为一个&lt;b&gt;序贯&lt;/b&gt;（sequent）。&lt;br&gt;其中， &lt;equation&gt;\Gamma&lt;/equation&gt; 称为序贯的&lt;b&gt;前提&lt;/b&gt;（antecedent）， &lt;equation&gt;\Delta&lt;/equation&gt; 称为序贯的&lt;b&gt;结论&lt;/b&gt;（succedent）。&lt;br&gt;它表示，如果公式集 &lt;equation&gt;\Gamma&lt;/equation&gt; 都成立，那么 &lt;equation&gt;\Delta&lt;/equation&gt; 中&lt;b&gt;至少有一个&lt;/b&gt;成立。&lt;/p&gt;&lt;p&gt;如果证明过程中，每一行断言是一个序贯，&lt;br&gt;这种风格的演绎系统，称为具有&lt;b&gt;Gentzen-style&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;Hilbert-style演绎系统，通常具有较多的公理，但是具有较少的推导规则，&lt;br&gt;Gentzen-style演绎系统，则反之，具有较少的公理，却具有较多的推导规则。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;\Delta&lt;/equation&gt; 中总是只包含一个公式，&lt;br&gt;则称该演绎系统为&lt;b&gt;自然演绎系统&lt;/b&gt;（natural deduction system）。&lt;/p&gt;&lt;p&gt;如果有限序列， &lt;equation&gt;\Gamma_1\vdash\alpha_1,\Gamma_2\vdash\alpha_2,\cdots,\Gamma_n\vdash\alpha_n&lt;/equation&gt; ，满足，&lt;br&gt;（1） &lt;equation&gt;\Gamma_1,\Gamma_2,\cdots,\Gamma_n&lt;/equation&gt; 为有限公式集，&lt;br&gt;（2） &lt;equation&gt;\alpha_1,\alpha_2,\cdots,\alpha_n&lt;/equation&gt; 为公式，&lt;br&gt;（3）每个 &lt;equation&gt;\Gamma_i\vdash\alpha_i&lt;/equation&gt; ， &lt;equation&gt;(1\leqslant i\leqslant n)&lt;/equation&gt; ，都是它之前若干个 &lt;equation&gt;\Gamma_j\vdash\alpha_j&lt;/equation&gt; ， &lt;equation&gt;(1\leqslant j&amp;lt;i\leqslant n)&lt;/equation&gt; ，应用某条推导规则得到的。&lt;/p&gt;&lt;p&gt;我们就称这个有限序列，为 &lt;equation&gt;\Gamma_n\vdash\alpha_n&lt;/equation&gt; 的一个&lt;b&gt;（形式）证明序列&lt;/b&gt;。&lt;br&gt;此时，也称 &lt;equation&gt;\alpha_n&lt;/equation&gt; 可由 &lt;equation&gt;\Gamma_n&lt;/equation&gt; &lt;b&gt;（形式）证明&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 命题逻辑的自然演绎系统&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9d18dc0eed74c1cef9fe9300c5e17d51_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;290&quot; data-rawheight=&quot;207&quot;&gt;&lt;p&gt;以上定义的形式系统，称为命题逻辑形式系统 &lt;equation&gt;P&lt;/equation&gt; ，&lt;br&gt;下面我们再定义一个与之等价的，命题逻辑的自然演绎系统 &lt;equation&gt;N&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.1 语法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;（1）可数个命题符号： &lt;equation&gt;p_1,p_2,\cdots&lt;/equation&gt; &lt;br&gt;（2）5个联接词符号： &lt;equation&gt;\neg,\lor,\land,\to,\leftrightarrow&lt;/equation&gt; &lt;br&gt;（3）2个辅助符号： &lt;equation&gt;),(&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;3.2 合法的公式&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们使用&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F&quot;&gt;BNF&lt;/a&gt;来定义，&lt;br&gt; &lt;equation&gt;\alpha::=p|(\neg\alpha)|(\alpha_1\lor\alpha_2)|(\alpha_1\land\alpha_2)|(\alpha_1\to\alpha_2)|(\alpha_1\leftrightarrow\alpha_2)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;3.3 推导规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;（1）包含律： &lt;equation&gt;\frac{\alpha\in\Gamma}{\Gamma\vdash\alpha}&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\neg&lt;/equation&gt; 消去律： &lt;equation&gt;\frac{\Gamma,\neg\alpha\vdash\beta;\Gamma,\neg\alpha\vdash\neg\beta}{\Gamma\vdash\alpha}&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;\to&lt;/equation&gt; 消去律： &lt;equation&gt;\frac{\Gamma\vdash(\alpha\to\beta);\Gamma\to\alpha}{\Gamma\vdash\beta}&lt;/equation&gt; &lt;br&gt;（4） &lt;equation&gt;\to&lt;/equation&gt; 引入律： &lt;equation&gt;\frac{\Gamma,\alpha\vdash\beta}{\Gamma\vdash\alpha\to\beta}&lt;/equation&gt; &lt;br&gt;（5） &lt;equation&gt;\lor&lt;/equation&gt; 消去律： &lt;equation&gt;\frac{\Gamma,\alpha\vdash\gamma;\Gamma,\beta\vdash\gamma}{\Gamma,\alpha\lor\beta\vdash\gamma}&lt;/equation&gt; &lt;br&gt;（6） &lt;equation&gt;\lor&lt;/equation&gt; 引入律： &lt;equation&gt;\frac{\Gamma\vdash\alpha}{\Gamma\vdash\alpha\lor\beta;\Gamma\vdash\beta\lor\alpha}&lt;/equation&gt; &lt;br&gt;（7） &lt;equation&gt;\land&lt;/equation&gt; 消去律： &lt;equation&gt;\frac{\Gamma\vdash\alpha\land\beta}{\Gamma\vdash\alpha;\Gamma\vdash\beta}&lt;/equation&gt; &lt;br&gt;（8） &lt;equation&gt;\land&lt;/equation&gt; 引入律： &lt;equation&gt;\frac{\Gamma\vdash\alpha;\Gamma\vdash\beta}{\Gamma\vdash\alpha\land\beta}&lt;/equation&gt; &lt;br&gt;（9） &lt;equation&gt;\leftrightarrow&lt;/equation&gt; 消去律： &lt;equation&gt;\frac{\Gamma\vdash\alpha\leftrightarrow\beta;\Gamma\vdash\alpha}{\Gamma\vdash\beta}&lt;/equation&gt; ， &lt;equation&gt;\frac{\Gamma\vdash\alpha\leftrightarrow\beta;\Gamma\vdash\beta}{\Gamma\vdash\alpha}&lt;/equation&gt; &lt;br&gt;（10） &lt;equation&gt;\leftrightarrow&lt;/equation&gt; 引入律： &lt;equation&gt;\frac{\Gamma,\alpha\vdash\beta;\Gamma,\beta\vdash\alpha}{\Gamma\vdash\alpha\leftrightarrow\beta}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;3.4 例子&lt;/b&gt;&lt;/p&gt;&lt;p&gt;以上，我们定义了命题逻辑的自然演绎系统 &lt;equation&gt;N&lt;/equation&gt; ，&lt;br&gt;它比命题逻辑形式系统 &lt;equation&gt;P&lt;/equation&gt; 更复杂一些，但是这两个系统是等价的。&lt;/p&gt;&lt;p&gt;我们来看一个例子。&lt;br&gt;求证， &lt;equation&gt;\alpha\to\beta,\alpha\vdash\beta&lt;/equation&gt; 是一个定理。&lt;/p&gt;&lt;p&gt;&lt;b&gt;证明：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;首先，我们根据包含律有，&lt;br&gt; &lt;equation&gt;\alpha\to\beta,\alpha\vdash\alpha\to\beta&lt;/equation&gt; &lt;br&gt; &lt;equation&gt;\alpha\to\beta,\alpha\vdash\alpha&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;然后，根据这两个结论，以及 &lt;equation&gt;\to&lt;/equation&gt; 消去律，就有，&lt;br&gt; &lt;equation&gt;\alpha\to\beta,\alpha\vdash\beta&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;证毕。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4. 系统N和系统P的等价性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d23fadb77f80512ad40a2cdd2f57e184_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;376&quot;&gt;&lt;p&gt;本文我们介绍了两个形式系统，&lt;br&gt;命题逻辑形式系统 &lt;equation&gt;P&lt;/equation&gt; ，以及命题逻辑的自然演绎系统 &lt;equation&gt;N&lt;/equation&gt; ，&lt;br&gt;可以证明，对于 &lt;equation&gt;P&lt;/equation&gt; （或 &lt;equation&gt;N&lt;/equation&gt; ）中的公式 &lt;equation&gt;\alpha&lt;/equation&gt; ， &lt;equation&gt;\vdash_N\alpha&lt;/equation&gt; 当且仅当 &lt;equation&gt;\vdash_P\alpha&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;因此，这两个系统中的定理集是一样的，&lt;br&gt;某个定理在 &lt;equation&gt;P&lt;/equation&gt; 中可证，当且仅当在 &lt;equation&gt;N&lt;/equation&gt; 中也可证。&lt;/p&gt;&lt;p&gt;其中，我们令，&lt;br&gt; &lt;equation&gt;\neg\alpha\to\beta&lt;/equation&gt; ，表示 &lt;equation&gt;\alpha\lor\beta&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\neg(\neg\alpha\lor\neg\beta)&lt;/equation&gt; ，表示 &lt;equation&gt;\alpha\land\beta&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;(\alpha\to\beta)\land(\beta\to\alpha)&lt;/equation&gt; ，表示 &lt;equation&gt;\alpha\leftrightarrow\beta&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;对于这两个系统而言，如上文所示，&lt;br&gt;我们只进行了符号的推导操作，即对公式进行形式证明，&lt;br&gt;至于这些符号到底代表什么意思，我们却故意没有提及。&lt;/p&gt;&lt;p&gt;我们并没有说 &lt;equation&gt;\lor&lt;/equation&gt; 表示“或”，也没有说 &lt;equation&gt;\land&lt;/equation&gt; 表示“与”，&lt;br&gt;在学数理逻辑的时候，一开始就将&lt;b&gt;形式系统&lt;/b&gt;与它的&lt;b&gt;语义模型&lt;/b&gt;相区分，&lt;br&gt;是非常有益的，后文我们将看到这样做的好处。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;5. 总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了命题逻辑，以及与之相关的两个形式系统 &lt;equation&gt;P&lt;/equation&gt; 和 &lt;equation&gt;N&lt;/equation&gt; ，&lt;br&gt;和 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; ， &lt;equation&gt;CL_w&lt;/equation&gt; 一样，我们采用了公理化的方式构建它们，&lt;br&gt;这样得到的形式系统，只是符号演算，还没有被赋予特定的语义，&lt;br&gt;下文我们开始介绍一阶谓词逻辑。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/1230394/&quot;&gt;离散数学教程&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/2364517/&quot;&gt;数理逻辑&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Proof_calculus&quot;&gt;Proof calculus&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hilbert_system&quot;&gt;Hilbert system&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Natural_deduction&quot;&gt;Natural deduction&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sequent_calculus&quot;&gt;Sequent calculus&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/11632210/&quot;&gt;Practical Foundations for Programming Languages&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/4323391/&quot;&gt;Lambda-Calculus and Combinators，an Introduction&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-21-34727603</guid>
<pubDate>Wed, 21 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（三）：Combinatory logic</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-20-34699469.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34699469&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-287adfd6b025ac4b76c62ee1f9ff40d5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;698&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上一篇中，我们介绍了 &lt;equation&gt;\lambda&lt;/equation&gt; 演算，它是由一堆&lt;b&gt;合法的符号&lt;/b&gt;和一些&lt;b&gt;推导规则&lt;/b&gt;构成的&lt;b&gt;公理系统&lt;/b&gt;，&lt;br&gt;在众多 &lt;equation&gt;\lambda&lt;/equation&gt; 演算中，我们介绍了最常用的 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 系统，&lt;br&gt;它指定了 &lt;equation&gt;\alpha&lt;/equation&gt; 和 &lt;equation&gt;\beta&lt;/equation&gt; 两种对 &lt;equation&gt;\lambda&lt;/equation&gt; 项的变换规则。&lt;/p&gt;&lt;p&gt;作为形式系统，上一篇中，我们展现了它的编码能力，&lt;br&gt;将邱奇编码，与公理集合论中自然数的归纳集定义，进行了对比。&lt;/p&gt;&lt;p&gt;本文我们将介绍另一套形式系统，&lt;b&gt;组合子逻辑&lt;/b&gt;（combinatory logic）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 组合子逻辑&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ef80bd38f8b0ceeaa3a69f47020c193d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;379&quot; data-rawheight=&quot;133&quot;&gt;&lt;p&gt;&lt;equation&gt;CL&lt;/equation&gt; （&lt;b&gt;组合子逻辑&lt;/b&gt;），与 &lt;equation&gt;\lambda&lt;/equation&gt; 演算很相似，只是不需要对变量进行绑定，&lt;br&gt;和函数作用在值上不同的是，组合子作用在函数上，从而生成另一个函数。&lt;/p&gt;&lt;p&gt;例如，我们可以定义一个组合子 &lt;equation&gt;B&lt;/equation&gt; ，使得 &lt;equation&gt;(B(f,g))(x) = f(g(x))&lt;/equation&gt; ，&lt;br&gt;其中， &lt;equation&gt;f&lt;/equation&gt; 和 &lt;equation&gt;g&lt;/equation&gt; 都是函数。&lt;/p&gt;&lt;p&gt;为了避免过早的谈及语义，我们和 &lt;equation&gt;\lambda&lt;/equation&gt; 演算一样，使用公理化的方法来定义它，&lt;br&gt;首先我们要说明什么是&lt;b&gt;公理&lt;/b&gt;，即什么是&lt;b&gt;合法的 &lt;equation&gt;CL&lt;/equation&gt; 项&lt;/b&gt;，&lt;br&gt;（1）所有的变量，常量，以及组合子 &lt;equation&gt;I&lt;/equation&gt; ， &lt;equation&gt;K&lt;/equation&gt; ， &lt;equation&gt;S&lt;/equation&gt; ，都是合法的 &lt;equation&gt;CL&lt;/equation&gt; 项，&lt;br&gt;（2）如果 &lt;equation&gt;X&lt;/equation&gt; 和 &lt;equation&gt;Y&lt;/equation&gt; 是合法的 &lt;equation&gt;CL&lt;/equation&gt; 项，那么 &lt;equation&gt;(XY)&lt;/equation&gt; 也是。&lt;/p&gt;&lt;p&gt;例如，以下字符串都是合法的 &lt;equation&gt;CL&lt;/equation&gt; 项， &lt;equation&gt;((S(KS))K)&lt;/equation&gt; ， &lt;equation&gt;((S(Kv_0))((SK)K))&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;同样为了简化，某些情况下括号是可以省略的，如果我们默认各个 &lt;equation&gt;CL&lt;/equation&gt; 项都是左结合的，&lt;br&gt;因此， &lt;equation&gt;(((UV)W)X)&lt;/equation&gt; 可以简写为 &lt;equation&gt;UVWX&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. Weak reduction&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-039de867b1267bba559051a625e3300a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;340&quot;&gt;&lt;p&gt;现在，我们要完成公理化的第二步了，那就是给合法的 &lt;equation&gt;CL&lt;/equation&gt; 项指定&lt;b&gt;变换规则&lt;/b&gt;，&lt;br&gt;在 &lt;equation&gt;CL&lt;/equation&gt; （组合子逻辑中）中，我们称之为&lt;b&gt;weak reduction&lt;/b&gt;，即我们令，&lt;br&gt;（1） &lt;equation&gt;IX&lt;/equation&gt; ，可以变换为 &lt;equation&gt;X&lt;/equation&gt; ，&lt;br&gt;（2） &lt;equation&gt;KXY&lt;/equation&gt; ，可以变换为 &lt;equation&gt;X&lt;/equation&gt; ，&lt;br&gt;（3） &lt;equation&gt;SXYZ&lt;/equation&gt; ，可以变换为 &lt;equation&gt;XZ(YZ)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;U&lt;/equation&gt; 经过有限步weak reduction转换为 &lt;equation&gt;V&lt;/equation&gt; ，就写为 &lt;equation&gt;U\triangleright_w V&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;与 &lt;equation&gt;\lambda&lt;/equation&gt; 项的 &lt;equation&gt;\beta&lt;/equation&gt; 范式一样，我们将不能再继续进行weak reduction的 &lt;equation&gt;CL&lt;/equation&gt; 项，&lt;br&gt;称为&lt;b&gt;weak范式&lt;/b&gt;（weak normal form）。&lt;/p&gt;&lt;p&gt;我们来看一个例子，设 &lt;equation&gt;B=S(KS)K&lt;/equation&gt; ，来计算 &lt;equation&gt;BXYZ&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;BXYZ=S(KS)KXYZ&lt;/equation&gt; &lt;br&gt; &lt;equation&gt;\triangleright_w KSX(KX)YZ&lt;/equation&gt; ，因为 &lt;equation&gt;S(KS)KX\triangleright_w KSX(KX)&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\triangleright_w S(KX)YZ&lt;/equation&gt; ，因为 &lt;equation&gt;KSX\triangleright_w S&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\triangleright_w KXZ(YZ)&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\triangleright_w X(YZ)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;有了合法的 &lt;equation&gt;CL&lt;/equation&gt; 项（公理），以及weak reduction（推导规则），&lt;br&gt;我们就建立了另一个形式系统 &lt;equation&gt;CL_w&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3.&lt;/b&gt; &lt;b&gt;CL与&lt;i&gt;λ&lt;/i&gt;演算之间的关系&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9d8d89d30817ab781c9e69e1a14bb7eb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;513&quot; data-rawheight=&quot;190&quot;&gt;&lt;p&gt;以上我们看到 &lt;equation&gt;CL&lt;/equation&gt; 项，似乎只能进行项的应用（application）操作，&lt;br&gt;对应于 &lt;equation&gt;\lambda&lt;/equation&gt; 项的用法为 &lt;equation&gt;(MN)&lt;/equation&gt; ，&lt;br&gt;然而，其实 &lt;equation&gt;CL&lt;/equation&gt; 的威力却不止于此，它的&lt;b&gt;计算能力&lt;/b&gt;是与 &lt;equation&gt;\lambda&lt;/equation&gt; 演算相当的。&lt;/p&gt;&lt;p&gt;为了证明等价性，建立 &lt;equation&gt;CL&lt;/equation&gt; 项与 &lt;equation&gt;\lambda&lt;/equation&gt; 项之间的关系，&lt;br&gt;现在我们用 &lt;equation&gt;I&lt;/equation&gt; ， &lt;equation&gt;K&lt;/equation&gt; ， &lt;equation&gt;S&lt;/equation&gt; 三个组合子，来定义与 &lt;equation&gt;\lambda x.M&lt;/equation&gt; 相似的概念。&lt;/p&gt;&lt;p&gt;对于任意的 &lt;equation&gt;CL&lt;/equation&gt; 项 &lt;equation&gt;M&lt;/equation&gt; ，以及任意的变量 &lt;equation&gt;x&lt;/equation&gt; ，我们定义 &lt;equation&gt;[x].M&lt;/equation&gt; 用如下方式表示，&lt;br&gt;（1） &lt;equation&gt;[x].M=KM&lt;/equation&gt; ，如果 &lt;equation&gt;M&lt;/equation&gt; 中不含有 &lt;equation&gt;x&lt;/equation&gt; ，&lt;br&gt;（2） &lt;equation&gt;[x].x=I&lt;/equation&gt; ，&lt;br&gt;（3） &lt;equation&gt;[x].Ux=U&lt;/equation&gt; ，如果 &lt;equation&gt;U&lt;/equation&gt; 中不含有 &lt;equation&gt;x&lt;/equation&gt; ，&lt;br&gt;（4） &lt;equation&gt;[x].UV=S([x].U)([x].V)&lt;/equation&gt; ，如果（1）和（3）都不适用的话。&lt;/p&gt;&lt;p&gt;例如，&lt;br&gt; &lt;equation&gt;[x].xy=S([x].x)([x].y)=SI(Ky)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;可见， &lt;equation&gt;[x].M&lt;/equation&gt; 可以完全用 &lt;equation&gt;I&lt;/equation&gt; ， &lt;equation&gt;K&lt;/equation&gt; ， &lt;equation&gt;S&lt;/equation&gt; 三个组合子来构建出来，&lt;br&gt;它表示了与 &lt;equation&gt;\lambda x.M&lt;/equation&gt; 相对应的概念。&lt;/p&gt;&lt;p&gt;因此，我们可以建立 &lt;equation&gt;\lambda&lt;/equation&gt; 项与 &lt;equation&gt;CL&lt;/equation&gt; 项的对应关系了，&lt;br&gt;在 &lt;equation&gt;CL&lt;/equation&gt; 中， &lt;equation&gt;X=Y&lt;/equation&gt; ，相当于 &lt;equation&gt;\lambda&lt;/equation&gt; 演算中， &lt;equation&gt;X\equiv_\alpha Y&lt;/equation&gt; ，可以统一记为 &lt;equation&gt;X\equiv Y&lt;/equation&gt; 。&lt;br&gt; &lt;equation&gt;X\triangleright_w Y&lt;/equation&gt; ，相当于 &lt;equation&gt;X\triangleright_\beta Y&lt;/equation&gt; ，可以统一记为 &lt;equation&gt;X\triangleright_{\beta,w} Y&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;相应的， &lt;equation&gt;I&lt;/equation&gt; ， &lt;equation&gt;K&lt;/equation&gt; ， &lt;equation&gt;S&lt;/equation&gt; 也可以使用 &lt;equation&gt;\lambda&lt;/equation&gt; 项来表示，&lt;br&gt; &lt;equation&gt;I=\lambda x.x&lt;/equation&gt; ， &lt;equation&gt;K=\lambda xy.x&lt;/equation&gt; ， &lt;equation&gt;S=\lambda xyz.xz(yz)&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4. 不动点定理&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在 &lt;equation&gt;\lambda&lt;/equation&gt; 演算和 &lt;equation&gt;CL&lt;/equation&gt; 中，存在组合子 &lt;equation&gt;Y&lt;/equation&gt; ，使得 &lt;equation&gt;Yx\triangleright_{\beta,w} x(Yx)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;证明：令 &lt;equation&gt;U=\lambda ux.x(uux)&lt;/equation&gt; ， &lt;equation&gt;Y=UU&lt;/equation&gt; ，则，&lt;br&gt; &lt;equation&gt;Yx=(\lambda u.(\lambda x.x(uux)))Ux=x(UUx)=x(Yx)&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文我们用公理化的方法，创建了另一个形式系统 &lt;equation&gt;CL_w&lt;/equation&gt; ，&lt;br&gt;接着，我们发现 &lt;equation&gt;CL_w&lt;/equation&gt; 实际上是与 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 等价的。&lt;/p&gt;&lt;p&gt;可悲的是，知道 &lt;equation&gt;\lambda&lt;/equation&gt; 演算的人很多，&lt;br&gt;但是知道 &lt;equation&gt;CL&lt;/equation&gt; （组合子逻辑）的人却很少，这简直是不可思议的。&lt;br&gt;下文中，我们将继续沿着公理化和形式系统的道路向前走，敲开数理逻辑的大门。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/4323391/&quot;&gt;Lambda-Calculus and Combinators，an Introduction&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-20-34699469</guid>
<pubDate>Tue, 20 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（二）：Lambda calculus</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-19-34679052.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34679052&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;b&gt;1. 匿名函数&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-87da900f32e0f115836e7d63a9a89421_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;395&quot; data-rawheight=&quot;376&quot;&gt;&lt;p&gt;现在很多种编程语言都支持匿名函数了，&lt;br&gt;例如，&lt;a href=&quot;https://msdn.microsoft.com/zh-sg/library/bb397687&quot;&gt;C# 3.0&lt;/a&gt;，&lt;a href=&quot;https://zh.wikipedia.org/wiki/C%2B%2B11&quot;&gt;C++ 11&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_version_history#Java_SE_8&quot;&gt;Java 8&lt;/a&gt;中的lambda表达式，&lt;br&gt;又例如，&lt;a href=&quot;https://docs.python.org/release/2.2.2/ref/ref.html&quot;&gt;Python 2.2.2&lt;/a&gt;中的lambda，&lt;a href=&quot;http://www-archive.mozilla.org/js/language/E262-3.pdf&quot;&gt;ECMAScript 3&lt;/a&gt;的匿名函数，&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ECMAScript 2015&lt;/a&gt;的箭头函数（arrow function）等等。&lt;/p&gt;&lt;p&gt;更不论，&lt;a href=&quot;https://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp&quot;&gt;Lisp&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_ML&quot;&gt;Standard ML&lt;/a&gt;，这些函数式编程语言了。&lt;/p&gt;&lt;p&gt;越来越多的语言拥抱匿名函数，是因为在很多场景中，我们无需给函数事先指定一个名字，&lt;br&gt;并且结合&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E4%BD%9C%E7%94%A8%E5%9F%9F&quot;&gt;词法作用域&lt;/a&gt;和高阶函数，会使某些问题用更直观的方式得以解决。&lt;/p&gt;&lt;p&gt;从理论上来讲，匿名函数具有和一般函数同样的计算能力，&lt;br&gt;使用某些技术手段，可以让匿名函数支持递归运算，从而完成任何&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E5%8F%AF%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0&quot;&gt;图灵可计算&lt;/a&gt;的任务。&lt;/p&gt;&lt;p&gt;然而，要想理解这一切，我们首先还得静下心来，从基础的 &lt;equation&gt;\lambda&lt;/equation&gt; 演算开始吧。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 自然数&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1ad49d6d8ff89cd3eb9d8e93fb8e2aec_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;495&quot; data-rawheight=&quot;316&quot;&gt;&lt;p&gt;&lt;equation&gt;\lambda&lt;/equation&gt; 演算听起来是一个高大上的概念，实际上它只是一套“符号推导系统”。&lt;/p&gt;&lt;p&gt;人们首先定义某些&lt;b&gt;合法的符号&lt;/b&gt;，然后再定义一些符号&lt;b&gt;推导规则&lt;/b&gt;，&lt;br&gt;最后就可以计算了，从一堆合法的符号得到另一堆，&lt;br&gt;这种推导过程称之为“&lt;b&gt;演算&lt;/b&gt;”。&lt;/p&gt;&lt;p&gt;为了让 &lt;equation&gt;\lambda&lt;/equation&gt; 演算更容易被接受，我们暂时先岔开话题，看看自然数是怎么定义的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.1 Peano系统&lt;/b&gt;&lt;/p&gt;&lt;p&gt;1889年，皮亚诺（&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9C%B1%E5%A1%9E%E4%BD%A9%C2%B7%E7%9A%AE%E4%BA%9E%E8%AB%BE&quot;&gt;Peano&lt;/a&gt;）为了给出自然数的集合论定义，&lt;br&gt;他建立了一个包含5条公设的&lt;b&gt;公理系统&lt;/b&gt;，后人称之为&lt;b&gt;Peano系统&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;Peano系统是满足以下公设的有序三元组 &lt;equation&gt;(M,F,e)&lt;/equation&gt; ，&lt;br&gt;其中 &lt;equation&gt;M&lt;/equation&gt; 为一个集合， &lt;equation&gt;F&lt;/equation&gt; 是 &lt;equation&gt;M&lt;/equation&gt; 到 &lt;equation&gt;M&lt;/equation&gt; 的函数， &lt;equation&gt;e&lt;/equation&gt; 为首元素，&lt;br&gt;（1） &lt;equation&gt;e\in M&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;M&lt;/equation&gt; 在 &lt;equation&gt;F&lt;/equation&gt; 下是封闭的&lt;br&gt;（3） &lt;equation&gt;e&lt;/equation&gt; 不在 &lt;equation&gt;F&lt;/equation&gt; 的值域中&lt;br&gt;（4） &lt;equation&gt;F&lt;/equation&gt; 是单射&lt;br&gt;（5）如果 &lt;equation&gt;M&lt;/equation&gt; 的子集 &lt;equation&gt;A&lt;/equation&gt; 满足， &lt;equation&gt;e\in A&lt;/equation&gt; ，且 &lt;equation&gt;A&lt;/equation&gt; 在 &lt;equation&gt;F&lt;/equation&gt; 下封闭，则 &lt;equation&gt;A=M&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 后继&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;A&lt;/equation&gt; 为一个集合，我们称 &lt;equation&gt;A\cup\{A\}&lt;/equation&gt; 为 &lt;equation&gt;A&lt;/equation&gt; 的&lt;b&gt;后继&lt;/b&gt;，记作 &lt;equation&gt;A^+&lt;/equation&gt; ，&lt;br&gt;求集合后继的操作，称为&lt;b&gt;后继运算&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如，&lt;br&gt; &lt;equation&gt;\varnothing^+=\varnothing\cup\{\varnothing\}=\{\varnothing\}&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\varnothing^{++}=\varnothing^+\cup\{\varnothing^+\}=\{\varnothing\}\cup\{\{\varnothing\}\}=\{\varnothing,\{\varnothing\}\}&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\varnothing^{+++}=\{\varnothing,\{\varnothing\},\{\varnothing,\{\varnothing\}\}\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3 归纳集&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;A&lt;/equation&gt; 为一个集合，若 &lt;equation&gt;A&lt;/equation&gt; 满足，&lt;br&gt;（1） &lt;equation&gt;\varnothing\in A&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\forall a\in A&lt;/equation&gt; ， &lt;equation&gt;a^+\in A&lt;/equation&gt; &lt;br&gt;则称 &lt;equation&gt;A&lt;/equation&gt; 是&lt;b&gt;归纳集&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\{\varnothing,\varnothing^+,\varnothing^{++},\cdots\}&lt;/equation&gt; 是一个归纳集。&lt;br&gt;从归纳集的定义可知， &lt;equation&gt;\varnothing,\varnothing^+,\varnothing^{++},\cdots&lt;/equation&gt; 是所有归纳集的元素，&lt;br&gt;于是，可以将它们定义为&lt;b&gt;自然数&lt;/b&gt;，自然数集记为 &lt;equation&gt;N&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;\sigma:N\rightarrow N&lt;/equation&gt; ，满足 &lt;equation&gt;\sigma(n)=n^+&lt;/equation&gt; ，则称 &lt;equation&gt;\sigma&lt;/equation&gt; 为&lt;b&gt;后继函数&lt;/b&gt;，&lt;br&gt;则可以证明 &lt;equation&gt;(N,\sigma,\varnothing)&lt;/equation&gt; 是一个Peano系统。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3.&lt;/b&gt; &lt;b&gt;&lt;i&gt;λ&lt;/i&gt;演算&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-72ffbc783aaa5cdc2ea8cabeae5f415a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;496&quot; data-rawheight=&quot;213&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97&quot;&gt;λ演算&lt;/a&gt;，是1930年由邱奇（&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87&quot;&gt;Alonzo Church&lt;/a&gt;）发明的一套&lt;a href=&quot;https://zh.wikipedia.org/zh/%E5%BD%A2%E5%BC%8F%E7%B3%BB%E7%B5%B1&quot;&gt;形式系统&lt;/a&gt;，&lt;br&gt;它是从具体的函数定义，函数调用和函数复合中，抽象出来的数学概念。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.1 语法&lt;/b&gt;&lt;/p&gt;&lt;p&gt;形式上， &lt;equation&gt;\lambda&lt;/equation&gt; 演算由3种语法项（term）组成，&lt;br&gt;（1）一个变量 &lt;equation&gt;x&lt;/equation&gt; 本身，是一个合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，&lt;br&gt;（2） &lt;equation&gt;\lambda x.t_1&lt;/equation&gt; ，是一个合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，称为从项 &lt;equation&gt;t_1&lt;/equation&gt; 中抽象出 &lt;equation&gt;x&lt;/equation&gt; ，&lt;br&gt;（3） &lt;equation&gt;t_1 t_2&lt;/equation&gt; ，是一个合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，称为将 &lt;equation&gt;t_1&lt;/equation&gt; 应用于 &lt;equation&gt;t_2&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;(\lambda x.(xy))&lt;/equation&gt; ， &lt;equation&gt;(x (\lambda x.(\lambda x.x)))&lt;/equation&gt; ， &lt;equation&gt;((\lambda y.y)(\lambda x.(xy)))&lt;/equation&gt; ，都是合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项。&lt;br&gt;为了简化描述，我们通常会省略一些括号，以上三个 &lt;equation&gt;\lambda&lt;/equation&gt; 项可以写成，&lt;br&gt; &lt;equation&gt;\lambda x.xy&lt;/equation&gt; ， &lt;equation&gt;x (\lambda x.\lambda x.x)&lt;/equation&gt; ， &lt;equation&gt;(\lambda y.y)(\lambda x.xy)&lt;/equation&gt; ，&lt;br&gt;对于形如 &lt;equation&gt;\lambda x.t_1&lt;/equation&gt; 的 &lt;equation&gt;\lambda&lt;/equation&gt; 项来说，“ &lt;equation&gt;.&lt;/equation&gt; ”后面会&lt;b&gt;向右包含尽量多&lt;/b&gt;的内容。&lt;/p&gt;&lt;p&gt;现在我们有了一堆合法的字符串了。&lt;br&gt;可是，在给定&lt;b&gt;推导规则&lt;/b&gt;之前，这些字符串之间都是没有关联的。&lt;br&gt;而且，我们也还没有为这些符号指定语义，它们到底代表什么也是不清楚的。&lt;/p&gt;&lt;p&gt;很显然&lt;b&gt;给这些符号指定不同的推导规则，会得到不同的公理系统&lt;/b&gt;，&lt;br&gt;在众多 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统中，最简单的是 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 系统，它指定了 &lt;equation&gt;\alpha&lt;/equation&gt; 和 &lt;equation&gt;\beta&lt;/equation&gt; 两种变换。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.2&lt;/b&gt; &lt;b&gt;&lt;i&gt;α&lt;/i&gt;变换&lt;/b&gt;&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;\lambda&lt;/equation&gt; 项 &lt;equation&gt;P&lt;/equation&gt; 中包含了 &lt;equation&gt;\lambda x.M&lt;/equation&gt; ，&lt;br&gt;则我们可以把 &lt;equation&gt;M&lt;/equation&gt; 中所有&lt;b&gt;自由出现&lt;/b&gt;的 &lt;equation&gt;x&lt;/equation&gt; ，全都换成 &lt;equation&gt;y&lt;/equation&gt; ，即 &lt;equation&gt;\lambda y.[y/x]M&lt;/equation&gt; ，&lt;br&gt;这种更名变换，称为 &lt;equation&gt;\alpha&lt;/equation&gt; &lt;b&gt;变换&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;其中，“&lt;b&gt;自由出现&lt;/b&gt;”指的是 &lt;equation&gt;x&lt;/equation&gt; 不被其他 &lt;equation&gt;\lambda&lt;/equation&gt; 抽象所绑定，&lt;br&gt;例如， &lt;equation&gt;\lambda x.xy&lt;/equation&gt; 中， &lt;equation&gt;y&lt;/equation&gt; 是自由的，&lt;br&gt;而 &lt;equation&gt;x&lt;/equation&gt; 就不是自由的，因为它被 &lt;equation&gt;\lambda x.&lt;/equation&gt; 绑定了。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;P&lt;/equation&gt; 可以经过有限步 &lt;equation&gt;\alpha&lt;/equation&gt; 变换转换为 &lt;equation&gt;Q&lt;/equation&gt; ，就写为 &lt;equation&gt;P\equiv_\alpha Q&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;例如，&lt;br&gt; &lt;equation&gt;\lambda xy.x(xy)=\lambda x.(\lambda y.x(xy))&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;\equiv_\alpha\lambda x.(\lambda v.x(xv))&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;\equiv_\alpha\lambda u.(\lambda v.u(uv))&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;=\lambda uv.u(uv)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;3.3&lt;/b&gt; &lt;b&gt;&lt;i&gt;β&lt;/i&gt;变换&lt;/b&gt;&lt;/p&gt;&lt;p&gt;形如 &lt;equation&gt;(\lambda x.M)N&lt;/equation&gt; 的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，可以经由&lt;b&gt;&lt;equation&gt;\beta&lt;/equation&gt; 变换&lt;/b&gt;转换为 &lt;equation&gt;[N/x]M&lt;/equation&gt; ，&lt;br&gt;指的是，把 &lt;equation&gt;M&lt;/equation&gt; 中所有自由出现的 &lt;equation&gt;x&lt;/equation&gt; 都换成 &lt;equation&gt;N&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;P&lt;/equation&gt; 可以经过有限步 &lt;equation&gt;\beta&lt;/equation&gt; 变换转换为 &lt;equation&gt;Q&lt;/equation&gt; ，就写为 &lt;equation&gt;P\triangleright_\beta Q&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;例如，&lt;br&gt; &lt;equation&gt;(\lambda x.x(xy))N\triangleright_\beta N(Ny)&lt;/equation&gt; &lt;equation&gt;(\lambda x.xx)(\lambda x.xx)\triangleright_\beta [(\lambda x.xx)/x](xx)=(\lambda x.xx)(\lambda x.xx)\triangleright_\beta\cdots&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;我们发现，某些 &lt;equation&gt;\lambda&lt;/equation&gt; 项，可以无限进行 &lt;equation&gt;\beta&lt;/equation&gt; 变换。&lt;br&gt;而那些最终会终止的 &lt;equation&gt;\beta&lt;/equation&gt; 变换的结果，称为 &lt;b&gt;&lt;equation&gt;\beta&lt;/equation&gt; 范式&lt;/b&gt;（ &lt;equation&gt;\beta&lt;/equation&gt;  normal form）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.4 邱奇编码&lt;/b&gt;&lt;/p&gt;&lt;p&gt;现在我们有 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 公理系统了，就可以依照 &lt;equation&gt;\alpha&lt;/equation&gt; 或 &lt;equation&gt;\beta&lt;/equation&gt; 变换，对任意合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项进行变换。&lt;/p&gt;&lt;p&gt;假设我们有一个 &lt;equation&gt;\lambda&lt;/equation&gt; 项， &lt;equation&gt;\lambda f.\lambda x.x&lt;/equation&gt; ，&lt;br&gt;还有另外一个 &lt;equation&gt;\lambda&lt;/equation&gt; 项， &lt;equation&gt;\lambda n.\lambda f.\lambda x.f(nfx)&lt;/equation&gt; ，记为 &lt;equation&gt;succ&lt;/equation&gt; ，&lt;br&gt;我们来计算， &lt;equation&gt;succ(\lambda f.\lambda x.x)&lt;/equation&gt; ，&lt;br&gt;可得， &lt;equation&gt;(\lambda n.\lambda f.\lambda x.f(nfx))(\lambda f.\lambda x.x)\triangleright_\beta\lambda f.\lambda x.fx&lt;/equation&gt; ，&lt;br&gt;我们再运用一次 &lt;equation&gt;succ&lt;/equation&gt; ， &lt;equation&gt;succ(\lambda f.\lambda x.fx)\triangleright_\beta\lambda f.\lambda x.f(fx)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们发现每次应用 &lt;equation&gt;succ&lt;/equation&gt; ，都会给 &lt;equation&gt;\lambda f.\lambda x.x&lt;/equation&gt; 中加一个 &lt;equation&gt;f&lt;/equation&gt; ，&lt;br&gt;最终我们可以得到以下这些 &lt;equation&gt;\lambda&lt;/equation&gt; 项，&lt;br&gt; &lt;equation&gt;\lambda f.\lambda x.x&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;\lambda f.\lambda x.fx&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;\lambda f.\lambda x.f(fx)&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;\lambda f.\lambda x.f(f(fx))&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;\cdots&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;\lambda f.\lambda x.f^nx&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;如果我们记 &lt;equation&gt;\lambda f.\lambda x.x\equiv 0&lt;/equation&gt; ， &lt;equation&gt;\lambda f.\lambda x.fx\equiv 1&lt;/equation&gt; ， &lt;equation&gt;\cdots&lt;/equation&gt; ， &lt;equation&gt;\lambda f.\lambda x.f^nx\equiv n&lt;/equation&gt; ，&lt;br&gt;我们就得到了&lt;b&gt;自然数的另一种表示方式&lt;/b&gt;，称之为&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%82%B1%E5%A5%87%E6%95%B0&quot;&gt;邱奇编码&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;可以看到邱奇编码与归纳集之间有异曲同工之妙。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.5 语义&lt;/b&gt;&lt;/p&gt;&lt;p&gt;到目前为止，我们并未谈及 &lt;equation&gt;\lambda&lt;/equation&gt; 项到底表示什么&lt;b&gt;含义&lt;/b&gt;，&lt;br&gt;虽然 &lt;equation&gt;\lambda x.M&lt;/equation&gt; 看起来像是函数定义， &lt;equation&gt;(\lambda x.M)N&lt;/equation&gt; 看起来像是函数调用。&lt;/p&gt;&lt;p&gt;我们谨慎的使用&lt;b&gt;公理化方法&lt;/b&gt;，从什么是合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项出发，&lt;br&gt;定义 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 系统中的&lt;b&gt;公理&lt;/b&gt;——合法的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，&lt;br&gt;然后又指定了该系统中的&lt;b&gt;推导规则&lt;/b&gt;—— &lt;equation&gt;\alpha&lt;/equation&gt; 和 &lt;equation&gt;\beta&lt;/equation&gt; 变换，&lt;br&gt;最终得到了一个形式化的公理系统（公理+推导规则）。&lt;/p&gt;&lt;p&gt;后文中，我们将谈及 &lt;equation&gt;\lambda&lt;/equation&gt; 项的语义，然后再逐渐给它加上类型。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/1230394/&quot;&gt;离散数学教程&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/4323391/&quot;&gt;Lambda-Calculus and Combinators，an Introduction&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://www.irif.fr/~mellies/mpri/mpri-ens/biblio/Selinger-Lambda-Calculus-Notes.pdf&quot;&gt;Lecture Notes on the Lambda Calculus&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-19-34679052</guid>
<pubDate>Mon, 19 Mar 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
