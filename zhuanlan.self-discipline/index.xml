<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>业余程序员的个人修养</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Sun, 01 Apr 2018 17:04:06 +0800</lastBuildDate>
<item>
<title>语言背后的代数学（五）：Σ代数</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-04-01-35142819.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35142819&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-034808153565717b07d4744f9dd8df32_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;698&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-034808153565717b07d4744f9dd8df32&quot; data-watermark-src=&quot;v2-13bfa86dbd2cd74be7d0a3d75c9c1078&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们介绍了哥德尔定理，它指出了&lt;b&gt;形式化方法的局限性&lt;/b&gt;，&lt;br&gt;任何包含初等算术 &lt;equation&gt;\Pi&lt;/equation&gt; 的形式理论，都是不完全的，&lt;br&gt;且自身的协调性无法在系统内部被证明。&lt;/p&gt;&lt;p&gt;为了理解这句话，上文中我们做出了严谨的定义，&lt;br&gt;仔细建立了语法和语义之间的联系。&lt;/p&gt;&lt;p&gt;实际上，语法（符号）层面的推导，属于公式的&lt;b&gt;证明&lt;/b&gt;，&lt;br&gt;而语义（模型）层面的推导，属于逻辑结论的&lt;b&gt;推理&lt;/b&gt;。&lt;br&gt;证明和推理之间的关系由系统的可靠性和完全性给出。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 简单类型化&lt;i&gt;λ&lt;/i&gt;演算&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7b5497ef5a6fe22bf3b233700e9eeee5_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;260&quot; data-rawheight=&quot;262&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7b5497ef5a6fe22bf3b233700e9eeee5&quot; data-watermark-src=&quot;v2-e7acc58db936e56f4febcf7515118356&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34815896&quot;&gt;你好，类型&lt;/a&gt;》系列文章中，&lt;br&gt;我们介绍了简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算（simply typed lambda calculus） &lt;equation&gt;\lambda^\to&lt;/equation&gt; ，&lt;br&gt;它是一个形式系统，采用公理化的方式定义。&lt;/p&gt;&lt;p&gt;当时我们看来，系统中的 &lt;equation&gt;\lambda&lt;/equation&gt; 项，只是一堆符合推导规则的符号，&lt;br&gt;我们并不知道它到底代表什么含义。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\lambda x:T.x+1&lt;/equation&gt; ，只是一个符号串，&lt;br&gt;自然数集上的后继函数&lt;code class=&quot;inline&quot;&gt;f(x)=x+1&lt;/code&gt;，能不能作为它的解释，我们是不清楚的，&lt;br&gt;只是猜想可能是。&lt;/p&gt;&lt;p&gt;不幸的是，后继函数并&lt;b&gt;不足以&lt;/b&gt;作为 &lt;equation&gt;\lambda x:T.x+1&lt;/equation&gt; 的解释，&lt;br&gt;因为，集合上的后继函数是没有不动点的，而 &lt;equation&gt;\lambda x:T.x+1&lt;/equation&gt; 有不动点 &lt;equation&gt;\perp&lt;/equation&gt; 。&lt;br&gt;我们曾经在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34604220&quot;&gt;递归函数&lt;/a&gt;》系列文章中给出过证明。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2.&lt;/b&gt; &lt;b&gt;Σ代数&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-292ed54ba3bf86dd48ebbc5ed994cce6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;258&quot; data-rawheight=&quot;196&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-292ed54ba3bf86dd48ebbc5ed994cce6&quot; data-watermark-src=&quot;v2-1e9cbd0184ce4df0998eb6104397fd8a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;一般有两种通用的方法，来给出简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 的语义，&lt;br&gt;一种是&lt;b&gt;Henkin模型&lt;/b&gt;，另一种是笛卡尔闭范畴。&lt;/p&gt;&lt;p&gt;范畴论我们可以稍后再介绍，这里先介绍Henkin模型，&lt;br&gt;不过在这之前，我们还得先了解一些 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数相关的内容。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\Sigma&lt;/equation&gt; 代数是一种数学结构，&lt;br&gt;一个 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数，包含了一个或多个集合，称为&lt;b&gt;载体&lt;/b&gt;（carrier），&lt;br&gt;以及一些&lt;b&gt;特征元素&lt;/b&gt;，和载体上的一些一阶&lt;b&gt;函数&lt;/b&gt;， &lt;equation&gt;f:A_1\times \cdots \times A_k \rightarrow A&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\Sigma&lt;/equation&gt; 代数 &lt;equation&gt;\mathscr{N}=\left \langle N,0,1,+,\cdot\right \rangle&lt;/equation&gt; ，具有载体 &lt;equation&gt;N&lt;/equation&gt; ，它是自然数集，&lt;br&gt;具有特征元素， &lt;equation&gt;0,1\in N&lt;/equation&gt; ，以及函数， &lt;equation&gt;+,*:N \times N \rightarrow N&lt;/equation&gt; 。&lt;br&gt;其中，特征元素可以看成&lt;b&gt;零元函数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;带有多个载体的例子是 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数， &lt;equation&gt;\mathscr{A}_{pcf}=\left \langle N,B,0,1,\cdots ,+,true,false,Eq?,\cdots ,\right \rangle&lt;/equation&gt; ，&lt;br&gt;其中 &lt;equation&gt;N&lt;/equation&gt; 是自然数集， &lt;equation&gt;B&lt;/equation&gt; 是布尔值集， &lt;equation&gt;0,1,\cdots&lt;/equation&gt; 是自然数， &lt;equation&gt;+&lt;/equation&gt; 是加法函数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 代数数据类型的签名（signature）&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-833f6e712c91fade3f7cc868965a2a82_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;230&quot; data-rawheight=&quot;198&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-833f6e712c91fade3f7cc868965a2a82&quot; data-watermark-src=&quot;v2-e1988e84facc4da74411b540ab23a61d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 中，类型属于形式系统中的概念，&lt;br&gt;&lt;b&gt;它并不代表类型中值的集合。&lt;br&gt;&lt;/b&gt;这种认识可能有助于澄清人们对编程语言中类型的&lt;b&gt;误解&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如，我们可以为初等算术系统 &lt;equation&gt;\Pi&lt;/equation&gt; 赋予类型，&lt;br&gt;指定 &lt;equation&gt;0:nat&lt;/equation&gt; ， &lt;equation&gt;1:nat&lt;/equation&gt; ， &lt;equation&gt;+:nat\times nat\to nat&lt;/equation&gt; ， &lt;equation&gt;\cdot:nat\times nat\to nat&lt;/equation&gt; ，&lt;br&gt;分别为常元符号 &lt;equation&gt;0&lt;/equation&gt; 和 &lt;equation&gt;1&lt;/equation&gt; ，以及二元函数符号 &lt;equation&gt;+&lt;/equation&gt; 和 &lt;equation&gt;\cdot&lt;/equation&gt; 的类型。&lt;/p&gt;&lt;p&gt;常元符号也可以看成是&lt;b&gt;零元&lt;/b&gt;函数符号。&lt;/p&gt;&lt;p&gt;这里，我们称以下二元组 &lt;equation&gt;\left \langle S,F \right \rangle&lt;/equation&gt; ，为初等算术系统 &lt;equation&gt;\Pi&lt;/equation&gt; 的&lt;b&gt;类型签名&lt;/b&gt;。&lt;br&gt;其中， &lt;equation&gt;S&lt;/equation&gt; 是系统中类型的集合 &lt;equation&gt;\{nat\}&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;F&lt;/equation&gt; 是函数符号的集合 &lt;equation&gt;\{0:nat,1:nat,+:nat\times nat\to nat,\cdot:nat\times nat\to nat\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;一般的，一个&lt;b&gt;类型签名&lt;/b&gt;（signature） &lt;equation&gt;\Sigma=\left \langle S,F \right \rangle&lt;/equation&gt; ，由以下两部分构成，&lt;br&gt;（1） &lt;equation&gt;S&lt;/equation&gt; 是以类型为元素构成的集合，&lt;br&gt;（2） &lt;equation&gt;F&lt;/equation&gt; 是类型上函数符号的集合， &lt;equation&gt;F=\left \{ f:s_1\times \cdots \times s_k\rightarrow s \right \}&lt;/equation&gt; &lt;br&gt;其中， &lt;equation&gt;s_1,\cdots ,s_k,s\in S&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;并且，除了初等算术系统 &lt;equation&gt;\Pi&lt;/equation&gt; ，某些系统中可能还会包含&lt;b&gt;变量&lt;/b&gt;，&lt;br&gt;因此，为了完成类型化，我们还需为这些变量指定类型。&lt;/p&gt;&lt;p&gt;我们称有限集 &lt;equation&gt;\Gamma=\left \{ x_1:s_1,\cdots ,x_k:s_k \right \}&lt;/equation&gt; ，&lt;br&gt;为变量 &lt;equation&gt;x_1,\cdots,x_k&lt;/equation&gt; 的一个&lt;b&gt;指派&lt;/b&gt;（assignment）。&lt;br&gt;其中， &lt;equation&gt;s_1,\cdots,x_k&lt;/equation&gt; 是类型。&lt;/p&gt;&lt;p&gt;有了&lt;b&gt;签名&lt;/b&gt;和&lt;b&gt;指派&lt;/b&gt;之后，类型为 &lt;equation&gt;s&lt;/equation&gt; 的项的集合 &lt;equation&gt;Terms^s\left ( \Sigma,\Gamma \right )&lt;/equation&gt; 就可以这样定义了，&lt;br&gt;（1）如果 &lt;equation&gt;x:s\in \Gamma&lt;/equation&gt; 则 &lt;equation&gt;x\in Terms^s\left ( \Sigma,\Gamma \right )&lt;/equation&gt; &lt;br&gt;（2）如果 &lt;equation&gt;f:s_1\times \cdots \times s_k\rightarrow s&lt;/equation&gt; 且 &lt;equation&gt;M_i\in Terms^{s_i}\left ( \Sigma,\Gamma \right )&lt;/equation&gt; ， &lt;equation&gt;i=1,\cdots ,n&lt;/equation&gt; ，&lt;br&gt;则 &lt;equation&gt;fM_1\cdots M_k\in Terms^s\left ( \Sigma,\Gamma \right )&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;具有多种类型的项的集合可以记为 &lt;equation&gt;\left \{ Terms^s\left ( \Sigma,\Gamma \right ) \right \}_{s\in S}&lt;/equation&gt; ，其中 &lt;equation&gt;S&lt;/equation&gt; 为类型的集合。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4. 项的解释&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ee34ec271f8c2d19cb9e404b7ab32a13_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;310&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ee34ec271f8c2d19cb9e404b7ab32a13&quot; data-watermark-src=&quot;v2-fd34250bc10452675241a0c19d3d6ee4&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;equation&gt;\Sigma&lt;/equation&gt; 代数，与类型化的项的集合之间，存在着&lt;b&gt;解释&lt;/b&gt;关系。&lt;/p&gt;&lt;p&gt;如果满足以下两个条件，&lt;br&gt;（1）对于每一个类型 &lt;equation&gt;s\in S&lt;/equation&gt; ，恰好存在 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数中的一个载体 &lt;equation&gt;A^s&lt;/equation&gt; 与之对应，&lt;br&gt;（2）每一个函数符号 &lt;equation&gt;f:s_1\times \cdots \times s_k\rightarrow s&lt;/equation&gt; ，&lt;br&gt;恰好存在集合上的一个函数 &lt;equation&gt;\mathscr{I}(f):A^{s_1}\times \cdots \times A^{s_k}\rightarrow A^s&lt;/equation&gt; 与之对应，&lt;br&gt; &lt;equation&gt;\mathscr{I}(f)&lt;/equation&gt; 也可以写成 &lt;equation&gt;f^{\mathscr{A}}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们就称 &lt;equation&gt;\mathscr{A}=\left \langle \left \{ A^s \right \}_{s\in S}, \mathscr{I} \right \rangle&lt;/equation&gt; 就是 &lt;equation&gt;\left \{ Terms^s\left ( \Sigma,\Gamma \right ) \right \}_{s\in S}&lt;/equation&gt; &lt;b&gt;所对应&lt;/b&gt;的 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数。&lt;/p&gt;&lt;p&gt;为了解释含变量的类型化的项，我们需要定义&lt;b&gt;环境&lt;/b&gt;的概念。&lt;br&gt; &lt;equation&gt;\Sigma&lt;/equation&gt; 代数 &lt;equation&gt;\mathscr{A}&lt;/equation&gt; 的环境 &lt;equation&gt;\eta&lt;/equation&gt; ，指的是把变量映射到 &lt;equation&gt;\mathscr{A}&lt;/equation&gt; 的各载体中元素的一个映射，&lt;br&gt; &lt;equation&gt;\eta :\mathscr{V} \rightarrow\cup _sA^s&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;对于含变量 &lt;equation&gt;x&lt;/equation&gt; 的项 &lt;equation&gt;M&lt;/equation&gt; ， &lt;equation&gt;\eta&lt;/equation&gt; 为它指定了载体上的一个唯一确定的值。&lt;br&gt;如果对于指派 &lt;equation&gt;\Gamma&lt;/equation&gt; 而言， &lt;equation&gt;\forall x:s\in\Gamma&lt;/equation&gt; ，都有 &lt;equation&gt;\eta(x)\in A^s&lt;/equation&gt; ，我们就说环境 &lt;equation&gt;\eta&lt;/equation&gt; &lt;b&gt;满足&lt;/b&gt;指派 &lt;equation&gt;\Gamma&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;假定 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数 &lt;equation&gt;\mathscr{A}&lt;/equation&gt; 的一个环境 &lt;equation&gt;\eta&lt;/equation&gt; 满足指派 &lt;equation&gt;\Gamma&lt;/equation&gt; ，&lt;br&gt;在这个环境中，我们就可以将任何项 &lt;equation&gt;M\in Terms\left ( \Sigma ,\Gamma \right )&lt;/equation&gt; 的含义 &lt;equation&gt;\mathscr{A}[\![M]\!]\eta&lt;/equation&gt; 定义如下，&lt;br&gt;（1） &lt;equation&gt;\mathscr{A}[\![x]\!]\eta =\eta (x)&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\mathscr{A}[\![fM_1\cdots M_k]\!]\eta =f^{\mathscr{A}}(\mathscr{A}[\![M_1]\!]\eta ,\cdots ,\mathscr{A}[\![M_k]\!]\eta )&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;&lt;b&gt;5. 例子&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6ec544aeea09d77518f5f928dbe782eb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;388&quot; data-rawheight=&quot;384&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6ec544aeea09d77518f5f928dbe782eb&quot; data-watermark-src=&quot;v2-00c10ea44965a352ea337c9e8269311f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;上文我们介绍了初等算术系统 &lt;equation&gt;\Pi&lt;/equation&gt; 的类型签名 &lt;equation&gt;\left \langle S,F \right \rangle&lt;/equation&gt; ，其中， &lt;equation&gt;S=\{nat\}&lt;/equation&gt; ， &lt;br&gt;&lt;equation&gt;F=\{0:nat,1:nat,+:nat\times nat\to nat,\cdot:nat\times nat\to nat\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们可以选择 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数 &lt;equation&gt;\mathscr{N}=\left \langle N,0,1,+,\cdot\right \rangle&lt;/equation&gt; 作为它的解释，&lt;br&gt;它的载体为自然数集 &lt;equation&gt;N&lt;/equation&gt; ， &lt;equation&gt;0,1,+,\cdot&lt;/equation&gt; 分别为自然数集上的零元和一元函数。&lt;/p&gt;&lt;p&gt;如果初等算术系统 &lt;equation&gt;\Pi&lt;/equation&gt; 中的项包含变量，我们就可以为 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数 &lt;equation&gt;\mathscr{N}&lt;/equation&gt; 指定环境 &lt;equation&gt;\eta&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;例如，我们可以假定环境 &lt;equation&gt;\eta&lt;/equation&gt; 满足 &lt;equation&gt;\eta(x)=0&lt;/equation&gt; ，&lt;br&gt;则在这个环境中， &lt;equation&gt;x+1&lt;/equation&gt; 的语义就可以按下式确定了。&lt;br&gt; &lt;equation&gt;[\![x+1]\!]\eta=+^\mathscr{N}([\![x]\!]\eta,[\![1]\!])\eta=+^\mathscr{N}(\eta(x),1^\mathscr{N})=+^\mathscr{N}(0^\mathscr{N},1^\mathscr{N})=1&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了一种称为 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数的数学结构，它可以用来解释带有类型签名的项。&lt;/p&gt;&lt;p&gt;可是，要想让这样的 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数称为 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 项的模型，还是不够的，&lt;br&gt;我们还必须保证每一个 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 项的解释，都在模型中。&lt;br&gt;为此 &lt;equation&gt;\Sigma&lt;/equation&gt; 代数还要满足一些额外的条件。&lt;/p&gt;&lt;p&gt;下文我们再详细讨论这些条件。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34815896&quot;&gt;你好，类型（六）：Simply typed lambda calculus&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34604220&quot;&gt;递归函数（九）：最小不动点定理&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1944729/&quot;&gt;程序设计语言理论基础&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-04-01-35142819</guid>
<pubDate>Sun, 01 Apr 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（四）：哥德尔定理</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-31-35102039.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35102039&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1325c76d98cc6465a9ff96f7a0410ff0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;775&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们介绍了一阶逻辑的语义模型，它包括&lt;b&gt;结构&lt;/b&gt;和&lt;b&gt;赋值&lt;/b&gt;两个部分，&lt;br&gt;其中，结构给出了常元符号、函数符号以及谓词符号在论域中的解释，&lt;br&gt;而赋值给出了变元符号在论域中的解释。&lt;/p&gt;&lt;p&gt;我们通过这种方式，建立了形式符号和论域中数学对象之间的关联，&lt;br&gt;本文将继续研究符号和其语义之间的关系。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 语义方面（模型）&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a382081c6002b6f34fb9eee923a31cec_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;346&quot; data-rawheight=&quot;196&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;1.1 公式的可满足性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们知道在公理化系统中，逻辑公式 &lt;equation&gt;A&lt;/equation&gt; 可以用来表示推导规则的前提和结论，&lt;br&gt;它在给定模型 &lt;equation&gt;(M,\sigma)&lt;/equation&gt; 中的语义 &lt;equation&gt;A_{M[\sigma]}&lt;/equation&gt; ]是一个真假值。&lt;/p&gt;&lt;p&gt;这是合情合理的，因为推导本来就应该是从真命题推导出另一个真命题的过程。&lt;/p&gt;&lt;p&gt;由于模型是可以&lt;b&gt;人为选择&lt;/b&gt;的，所以，给定一个逻辑公式 &lt;equation&gt;A&lt;/equation&gt; ，&lt;br&gt;其语义的真假性，有可能会受到&lt;b&gt;所选模型&lt;/b&gt;的影响。&lt;/p&gt;&lt;p&gt;如果存在模型 &lt;equation&gt;(M, \sigma)&lt;/equation&gt; ，使得 &lt;equation&gt;A_{M[\sigma ]}=T&lt;/equation&gt; 成立，&lt;br&gt;我们就称公式 &lt;equation&gt;A&lt;/equation&gt; 关于模型 &lt;equation&gt;(M, \sigma )&lt;/equation&gt; 是&lt;b&gt;可满足的&lt;/b&gt;，记为 &lt;equation&gt;M\models _\sigma A&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;此外，如果有公式集 &lt;equation&gt;\Gamma&lt;/equation&gt; ，其中的每一个公式关于模型 &lt;equation&gt;(M, \sigma)&lt;/equation&gt; 都是可满足的，&lt;br&gt;我们就称，公式集 &lt;equation&gt;\Gamma&lt;/equation&gt; 关于模型 &lt;equation&gt;(M, \sigma )&lt;/equation&gt; 是可满足的，记为 &lt;equation&gt;M\models _\sigma\Gamma&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.2 重言式&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果公式 &lt;equation&gt;A&lt;/equation&gt; ，对于任意模型 &lt;equation&gt;(M, \sigma)&lt;/equation&gt; 都是可满足的，&lt;br&gt;即，对任意结构 &lt;equation&gt;M&lt;/equation&gt; 和赋值 &lt;equation&gt;\sigma&lt;/equation&gt; ， &lt;equation&gt;M\models _\sigma A&lt;/equation&gt; 都成立，&lt;br&gt;我们就称 &lt;equation&gt;A&lt;/equation&gt; 是&lt;b&gt;永真公式&lt;/b&gt;，也称为&lt;b&gt;重言式&lt;/b&gt;，记为 &lt;equation&gt;\models A&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;重言式，是与模型无关的公式，它们在任何模型下都为真。&lt;/p&gt;&lt;p&gt;例： &lt;equation&gt;A\vee \neg A&lt;/equation&gt; ， &lt;equation&gt;\forall x(x\doteq x)&lt;/equation&gt; 都是重言式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.3 逻辑推理&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e5caf356aa8a95b0df17491cb2af1e93_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;282&quot; data-rawheight=&quot;398&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;有了可满足性，我们就可以进行&lt;b&gt;逻辑推理&lt;/b&gt;了。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;A&lt;/equation&gt; 为公式， &lt;equation&gt;\Gamma&lt;/equation&gt; 为公式集， &lt;equation&gt;M&lt;/equation&gt; 为任意结构， &lt;equation&gt;\sigma&lt;/equation&gt; 为任意赋值，并且，&lt;br&gt;如果 &lt;equation&gt;M\models _\sigma \Gamma&lt;/equation&gt; 成立，就有 &lt;equation&gt;M\models _\sigma A&lt;/equation&gt; 成立，&lt;br&gt;我们就称， &lt;equation&gt;A&lt;/equation&gt; 是公式集 &lt;equation&gt;\Gamma&lt;/equation&gt; 的&lt;b&gt;逻辑结论&lt;/b&gt;或&lt;b&gt;语义结论&lt;/b&gt;，记为 &lt;equation&gt;\Gamma \models A&lt;/equation&gt; ，也称结论 &lt;equation&gt;\Gamma \models A&lt;/equation&gt; &lt;b&gt;有效&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;因此， &lt;equation&gt;\Gamma \models A&lt;/equation&gt; 表示了一种语义关系，&lt;br&gt;它指出，对任意 &lt;equation&gt;M&lt;/equation&gt; 和任意 &lt;equation&gt;\sigma&lt;/equation&gt; ，如果 &lt;equation&gt;\Gamma&lt;/equation&gt; 为真，那么 &lt;equation&gt;A&lt;/equation&gt; 也为真。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 语法方面（符号）&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1a5dafd7fc3bfc32fff64e45481116e9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;306&quot; data-rawheight=&quot;165&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;2.1 序贯&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34727603&quot;&gt;你好，类型&lt;/a&gt;》系列文章中，我们介绍过&lt;b&gt;序贯&lt;/b&gt;的概念。&lt;/p&gt;&lt;p&gt;我们知道，在公理系统中，序贯可以用来表示前提和结论之间的符号联系。&lt;br&gt;序贯 &lt;equation&gt;\Gamma\vdash\Delta&lt;/equation&gt; ，表示从公式集 &lt;equation&gt;\Gamma&lt;/equation&gt; 出发，根据推导规则，&lt;br&gt;可以证明出 &lt;equation&gt;\Delta&lt;/equation&gt; 中至少有一条公式成立。&lt;/p&gt;&lt;p&gt;习惯上，序贯 &lt;equation&gt;\Gamma\vdash\Delta&lt;/equation&gt; 成立，也称 &lt;equation&gt;\Gamma\vdash\Delta&lt;/equation&gt; &lt;b&gt;可证&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;值得注意的是，序贯谈论的都是语法层面（符号层面）上的，&lt;br&gt;和这些符号的所选择的具体语义无关。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 协调性（一致性）&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-eddfaac10cd721d5c5e4c902900c4171_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;330&quot; data-rawheight=&quot;236&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;设 &lt;equation&gt;\Gamma&lt;/equation&gt; 为公式集，如果不存在一个公式 &lt;equation&gt;A&lt;/equation&gt; 使得序贯 &lt;equation&gt;\Gamma \vdash A&lt;/equation&gt; 与 &lt;equation&gt;\Gamma \vdash \neg A&lt;/equation&gt; 均可证，&lt;br&gt;我们就称，公式集 &lt;equation&gt;\Gamma&lt;/equation&gt; 是&lt;b&gt;协调的&lt;/b&gt;，也称&lt;b&gt;一致的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;\Gamma&lt;/equation&gt; 是一阶语言 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 的公式集，该集合可以是有限集或可数集，&lt;br&gt;如果 &lt;equation&gt;\Gamma&lt;/equation&gt; 协调，则称 &lt;equation&gt;\Gamma&lt;/equation&gt; 是一阶语言 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 的&lt;b&gt;形式理论&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 语法（符号）和语义（模型）&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-55958c86528a097ecc14f7810d72de52_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;392&quot; data-rawheight=&quot;244&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;3.1 可靠性和完全性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;把公理系统的语法和语义联合起来，我们还可以定义出以下这些系统性质。&lt;/p&gt;&lt;p&gt;如果序贯 &lt;equation&gt;\Gamma \vdash \Lambda&lt;/equation&gt; 可证，那么 &lt;equation&gt;\Gamma \models \Lambda&lt;/equation&gt; 成立，就说系统是&lt;b&gt;可靠的&lt;/b&gt;。&lt;br&gt;如果 &lt;equation&gt;\Gamma \models A&lt;/equation&gt; 成立，那么 &lt;equation&gt;\Gamma \vdash A&lt;/equation&gt; 可证，就说系统是&lt;b&gt;完全的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;3.2 不完全性与协调性不可证&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e113b4bfc7f15a822ab451fd64b81b20_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;224&quot; data-rawheight=&quot;181&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;是不是任意一个公理系统都是可靠且完全的呢？&lt;br&gt;可惜并不是如此。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BA%93%E5%B0%94%E7%89%B9%C2%B7%E5%93%A5%E5%BE%B7%E5%B0%94&quot;&gt;哥德尔&lt;/a&gt;在1931年给出了两个定理，终结了人们的幻想，&lt;br&gt;分别称为哥德尔不完全性定理，和哥德尔协调性定理。他指出，&lt;/p&gt;&lt;p&gt;&lt;b&gt;不完全性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;\Gamma&lt;/equation&gt; 是一个有穷，并包含初等算术 &lt;equation&gt;\Pi&lt;/equation&gt; 的形式理论，&lt;br&gt;那么 &lt;equation&gt;\Gamma&lt;/equation&gt; 是一个不完全的形式理论。&lt;/p&gt;&lt;p&gt;&lt;b&gt;协调性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果形式理论 &lt;equation&gt;\Gamma&lt;/equation&gt; 包含初等算术 &lt;equation&gt;\Pi&lt;/equation&gt; ，&lt;br&gt;那么 &lt;equation&gt;\Pi&lt;/equation&gt; 的协调性不能在 &lt;equation&gt;\Gamma&lt;/equation&gt; 中被证明。&lt;/p&gt;&lt;blockquote&gt;所以，在软件开发过程中，检查一个软件系统是否符合设计要求，所使用的方法就是对它进行测试，在这个软件系统之外进行证明。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;文本介绍语法（符号证明）和语义（模型）之间的关系，&lt;br&gt;让我们认识到了形式化方法的局限性。&lt;/p&gt;&lt;p&gt;一个足够有用的系统，总会出现不可证的事实，&lt;br&gt;并且，在该系统内部，我们甚至都无法证明它是否含有矛盾。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34727603&quot;&gt;你好，类型（四）：Propositional log&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/2364517/&quot;&gt;数理逻辑&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86&quot;&gt;哥德尔不完备定理&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-31-35102039</guid>
<pubDate>Sat, 31 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（三）：语义模型</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-30-35059714.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35059714&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1c5b9d563616667cf124fead090f7f71_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;698&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-1c5b9d563616667cf124fead090f7f71&quot; data-watermark-src=&quot;v2-d0aa9daa0d20e9a8443f8c396b4f160c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;1. 回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们从代数学角度重新认识了自然数，认识了自然数是如何被&lt;b&gt;编码&lt;/b&gt;为符号串的，&lt;br&gt;以及自然数在数学上是如何表示的。&lt;/p&gt;&lt;p&gt;我们的整体思路是，首先用&lt;b&gt;公理化&lt;/b&gt;的方式建立一个&lt;b&gt;形式系统&lt;/b&gt;，&lt;br&gt;然后为这个形式系统&lt;b&gt;选择&lt;/b&gt;一种数学解释作为它的语义，&lt;br&gt;这样就建立了符号和数学对象之间的对应关系。&lt;/p&gt;&lt;p&gt;一般的，这些数学对象需要具有不同的运算性质，有不同的结构，&lt;br&gt;因此构成了不同的&lt;b&gt;代数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34779520&quot;&gt;你好，类型&lt;/a&gt;》系列文章中，我们介绍了命题逻辑和一阶谓词逻辑，&lt;br&gt;当时，我们只是从形式系统（符号演算）的角度来介绍它们。&lt;/p&gt;&lt;p&gt;例如，我们只要知道公理和推导规则，就可以做出&lt;b&gt;形式证明&lt;/b&gt;，&lt;br&gt; &lt;equation&gt;\forall x(\alpha\leftrightarrow\beta)\vdash\forall x\alpha\leftrightarrow\forall x\beta&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;但是，这些符号到底代表什么含义呢？&lt;br&gt;我们当时故意没有提及。&lt;/p&gt;&lt;p&gt;本文从模型论角度来做出一些解释。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 一阶语言&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-08aff67764de6984e391923515eb467d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;476&quot; data-rawheight=&quot;266&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-08aff67764de6984e391923515eb467d&quot; data-watermark-src=&quot;v2-161f1757a81329d900360d4a6315be4b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;首先让我们回顾以下一阶谓词逻辑有哪些&lt;b&gt;符号&lt;/b&gt;构成，&lt;/p&gt;&lt;p&gt;（1）变元符号集合 &lt;equation&gt;V&lt;/equation&gt; ，&lt;br&gt;它由可数个（包括0个）变元符号组成，用 &lt;equation&gt;x_1,x_1,\cdots,x_n,\cdots&lt;/equation&gt; 表示。&lt;br&gt;（2）逻辑连接词符号集合 &lt;equation&gt;C&lt;/equation&gt; ，&lt;br&gt;它由逻辑连接词符号 &lt;equation&gt;\neg,\wedge,\vee,\rightarrow,\leftrightarrow&lt;/equation&gt; 组成。&lt;br&gt;（3）量词符号集合 &lt;equation&gt;Q&lt;/equation&gt; ，包括 &lt;equation&gt;\forall,\exists&lt;/equation&gt; 。&lt;br&gt;（4）等词符号集合 &lt;equation&gt;E&lt;/equation&gt; ，只包括一个符号 &lt;equation&gt;\doteq&lt;/equation&gt; 。&lt;br&gt;（5）括号集合，包括 &lt;equation&gt;),(&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;以上这些符号称为&lt;b&gt;逻辑符号&lt;/b&gt;，每个&lt;b&gt;一阶逻辑&lt;/b&gt;都有这些符号。&lt;br&gt;而不同的一阶逻辑，还有属于自己的&lt;b&gt;非逻辑符号&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;（1）常元符号集合 &lt;equation&gt;\mathscr{L}_c&lt;/equation&gt; ，&lt;br&gt;它由可数个（包括0个）常元符号组成，用 &lt;equation&gt;c_1,c_2,\cdots&lt;/equation&gt; 表示。&lt;br&gt;（2）函数符号集合 &lt;equation&gt;\mathscr{L}_f&lt;/equation&gt; ，&lt;br&gt;它由可数个（包括0个）函数符号组成，用 &lt;equation&gt;f_1,f_2,\cdots&lt;/equation&gt; 表示。&lt;br&gt;（3）谓词符号集合 &lt;equation&gt;\mathscr{L}_P&lt;/equation&gt; ，&lt;br&gt;它由可数个（包括0个）谓词符号组成，用 &lt;equation&gt;P_1,P_2,\cdots&lt;/equation&gt; 表示。&lt;/p&gt;&lt;p&gt;等词符号 &lt;equation&gt;\doteq&lt;/equation&gt; 实际上可以看做是一个谓词符号。&lt;/p&gt;&lt;p&gt;因此，一阶谓词逻辑是一种一阶逻辑。&lt;br&gt;一阶逻辑中的逻辑符号和非逻辑符号，称为&lt;b&gt;一阶语言&lt;/b&gt;，记为 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 初等算术语言&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0af43dcf0db17bc56a9f23629eba4fff_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;220&quot; data-rawheight=&quot;176&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0af43dcf0db17bc56a9f23629eba4fff&quot; data-watermark-src=&quot;v2-cc77c1a0365a39d0c0e7df3ec874222f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;b&gt;初等算术语言&lt;/b&gt;是一个一阶语言，记为 &lt;equation&gt;\Pi&lt;/equation&gt; 。&lt;br&gt;它的常元符号集合为 &lt;equation&gt;\{0\}&lt;/equation&gt; ，函数符号集合为 &lt;equation&gt;\{S,+,\cdot\}&lt;/equation&gt; ，谓词符号集合为 &lt;equation&gt;\{&amp;lt;\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;其中， &lt;equation&gt;S&lt;/equation&gt; 可以表示算术中的后继函数，&lt;br&gt;而二元函数符号 &lt;equation&gt;+&lt;/equation&gt; 和 &lt;equation&gt;\cdot&lt;/equation&gt; 可以分别表示算术中的加法和乘法，&lt;br&gt;谓词符号 &lt;equation&gt;&amp;lt;&lt;/equation&gt; 可以描述自然数之间的小于关系。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;4. 语法项和逻辑公式&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-78f72f27ec4a044bb994732c1d993c8f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;598&quot; data-rawheight=&quot;113&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-78f72f27ec4a044bb994732c1d993c8f&quot; data-watermark-src=&quot;v2-79aeae0ead5da041df93d2292081ff37&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;从形式语言的角度来看，除了知道语言包含哪些符号之外，还要指定&lt;b&gt;语法&lt;/b&gt;，&lt;br&gt;习惯上，我们经常使用&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F&quot;&gt;BNF&lt;/a&gt;来指定，&lt;br&gt; &lt;equation&gt;t::=c|x|f~t_1\cdots t_n&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;即一个合法的&lt;b&gt;项&lt;/b&gt;，可以归纳定义为，&lt;br&gt;（1）每一个常元都是合法的项，&lt;br&gt;（2）每一个变元都是合法的项，&lt;br&gt;（3）如果 &lt;equation&gt;t_1,t_2,\cdots,t_n&lt;/equation&gt; 都是合法的项，而 &lt;equation&gt;f&lt;/equation&gt; 是一个 &lt;equation&gt;n&lt;/equation&gt; 元函数符号，&lt;br&gt;那么 &lt;equation&gt;f~t_1\cdots t_n&lt;/equation&gt; 也是一个合法的项。&lt;/p&gt;&lt;p&gt;初等算术语言 &lt;equation&gt;\Pi&lt;/equation&gt; 中的合法项，以下符号串都是合法的，&lt;br&gt; &lt;equation&gt;S0&lt;/equation&gt; ， &lt;equation&gt;Sx_1&lt;/equation&gt; ， &lt;equation&gt;+S0SSx&lt;/equation&gt; ， &lt;equation&gt;\cdot x_1+Sx_1x_2&lt;/equation&gt; ，&lt;br&gt;而 &lt;equation&gt;SS&amp;lt;&lt;/equation&gt; 是不合法的。&lt;/p&gt;&lt;p&gt;我们知道逻辑证明，并不是建立在形式语法之上的，&lt;br&gt;而是建立在&lt;b&gt;公理系统&lt;/b&gt;上面，而每一个&lt;b&gt;推导规则&lt;/b&gt;都表明了前提和结论之间的关系，&lt;br&gt;这些前提和结论，称为&lt;b&gt;逻辑公式&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;一阶语言 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 中的逻辑公式，用大写字母 &lt;equation&gt;A,B,\cdots&lt;/equation&gt; 表示，定义为，&lt;br&gt; &lt;equation&gt;A ::= t_1\doteq t_2 | Rt_1\cdot \cdot \cdot t_n | \neg A | A\wedge B | A\vee B | A\rightarrow B | A\leftrightarrow B | \forall xA | \exists xA&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;即，&lt;b&gt;逻辑公式&lt;/b&gt;可以归纳的定义为，&lt;br&gt;（1）如果 &lt;equation&gt;t_1&lt;/equation&gt; 和 &lt;equation&gt;t_2&lt;/equation&gt; 是合法的项，则 &lt;equation&gt;t_1\doteq t_2&lt;/equation&gt; 是公式，&lt;br&gt;（2）如果 &lt;equation&gt;t_1, ..., t_n&lt;/equation&gt; 是合法的项，而 &lt;equation&gt;R&lt;/equation&gt; 是一个 &lt;equation&gt;n&lt;/equation&gt; 元谓词，则 &lt;equation&gt;Rt_1\cdot \cdot \cdot t_n&lt;/equation&gt; 是公式，&lt;br&gt;（3）如果 &lt;equation&gt;A&lt;/equation&gt; 是公式，则 &lt;equation&gt;\neg A&lt;/equation&gt; 是公式，&lt;br&gt;（4）若 &lt;equation&gt;A, B&lt;/equation&gt; 是公式，则 &lt;equation&gt;A\wedge B, A\vee B, A\rightarrow B, A\leftrightarrow B&lt;/equation&gt; 都是公式，&lt;br&gt;（5）若 &lt;equation&gt;A&lt;/equation&gt; 是公式并且 &lt;equation&gt;x&lt;/equation&gt; 是一个变元，那么 &lt;equation&gt;\forall xA&lt;/equation&gt; 和 &lt;equation&gt;\exists xA&lt;/equation&gt; 也是公式， &lt;equation&gt;x&lt;/equation&gt; 称为&lt;b&gt;约束变元&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例，以下符号串可以看做一个初等算术公式，&lt;br&gt; &lt;equation&gt;\forall x\neg (Sx\doteq 0), \forall x\forall y(&amp;lt; xy\rightarrow(\exists (y\doteq +xz)))&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;&lt;b&gt;5. 语义模型&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e30bba524907e7c3b6786d9bb6f3f090_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;430&quot; data-rawheight=&quot;432&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-e30bba524907e7c3b6786d9bb6f3f090&quot; data-watermark-src=&quot;v2-b24b8323b235c53b820fbfa6a4ae942c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;有了一阶语言之后，我们就可以为符号选择语义了，&lt;br&gt;通常的，语言的语义有两部分组成，&lt;br&gt;其一称为&lt;b&gt;结构&lt;/b&gt;，用来解释常元符号，函数符号和谓词符号，&lt;br&gt;其二称为&lt;b&gt;赋值&lt;/b&gt;，用来解释变元符号。&lt;/p&gt;&lt;p&gt;&lt;b&gt;5.1 语言结构&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一阶语言 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 的&lt;b&gt;结构&lt;/b&gt; &lt;equation&gt;M&lt;/equation&gt; 是一个偶对，记为 &lt;equation&gt;M=(\mathbb{M}, I)&lt;/equation&gt; ，其中，&lt;br&gt;（1） &lt;equation&gt;\mathbb{M}&lt;/equation&gt; 是一个非空集合，称为&lt;b&gt;论域&lt;/b&gt;，&lt;br&gt;（2） &lt;equation&gt;I&lt;/equation&gt; 是从 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 到 &lt;equation&gt;\mathbb{M}&lt;/equation&gt; 的映射，称为&lt;b&gt;解释&lt;/b&gt;，记为 &lt;equation&gt;I:\mathscr{L} \rightarrow \mathbb{M}&lt;/equation&gt; ，它满足下面三个条件&lt;br&gt;对 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 中的每一个常元符号 &lt;equation&gt;c&lt;/equation&gt; ， &lt;equation&gt;I(c)&lt;/equation&gt; 是 &lt;equation&gt;\mathbb{M}&lt;/equation&gt; 中的元素&lt;br&gt;对 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 中的每一个 &lt;equation&gt;n&lt;/equation&gt; 元函数符号 &lt;equation&gt;f&lt;/equation&gt; ， &lt;equation&gt;I(f)&lt;/equation&gt; 是 &lt;equation&gt;\mathbb{M}&lt;/equation&gt; 上的 &lt;equation&gt;n&lt;/equation&gt; 元函数&lt;br&gt;对 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 中的每一个 &lt;equation&gt;n&lt;/equation&gt; 元谓词符号 &lt;equation&gt;P&lt;/equation&gt; ， &lt;equation&gt;I(P)&lt;/equation&gt; 是 &lt;equation&gt;\mathbb{M}&lt;/equation&gt; 上的一个 &lt;equation&gt;n&lt;/equation&gt; 元关系&lt;/p&gt;&lt;p&gt;例，我们可以指定初等算术语言 &lt;equation&gt;\Pi&lt;/equation&gt; 的结构为，偶对 &lt;equation&gt;N=(\mathbb{N}, I)&lt;/equation&gt; ，&lt;br&gt;其中论域 &lt;equation&gt;\mathbb{N}&lt;/equation&gt; 为自然数集，&lt;br&gt; &lt;equation&gt;I(S)&lt;/equation&gt; 为自然数集上的加 &lt;equation&gt;1&lt;/equation&gt; 函数， &lt;equation&gt;I(+)&lt;/equation&gt; 为自然数加法运算， &lt;equation&gt;I(\cdot)&lt;/equation&gt; 为自然数乘法运算。&lt;br&gt; &lt;equation&gt;I(&amp;lt;)&lt;/equation&gt; 为自然数集上的小于关系。&lt;/p&gt;&lt;p&gt;&lt;b&gt;5.2 变元赋值&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;赋值 &lt;/b&gt;&lt;equation&gt;\sigma&lt;/equation&gt; 是一个映射， &lt;equation&gt;\sigma:V\to\mathbb{M}&lt;/equation&gt; ，&lt;br&gt;它将 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 中的每一个变元，赋以论域 &lt;equation&gt;\mathbb{M}&lt;/equation&gt; 中的一个元素 &lt;equation&gt;a&lt;/equation&gt; ，&lt;br&gt;记为 &lt;equation&gt;\sigma(x)=a&lt;/equation&gt; ，其中 &lt;equation&gt;x\in V,a\in\mathbb{M}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;有了赋值运算之后，公式中的变元就固定下来了，&lt;br&gt;我们就可以谈论在某一指定赋值运算下公式的语义了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;5.3 模型和语义&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-66a18139c912860b6d2797c50f1d2742_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;334&quot; data-rawheight=&quot;330&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-66a18139c912860b6d2797c50f1d2742&quot; data-watermark-src=&quot;v2-6ace729d486c2e48aeca6c549627bf40&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;给定一阶语言 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; ，并指定结构 &lt;equation&gt;M&lt;/equation&gt; 和赋值 &lt;equation&gt;\sigma&lt;/equation&gt; ，&lt;br&gt;我们称 &lt;equation&gt;(M,\sigma)&lt;/equation&gt; 是，我们为语言 &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 选择的一个&lt;b&gt;模型&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;项的语义&lt;/b&gt;&lt;/p&gt;&lt;p&gt;选择了模型 &lt;equation&gt;(M,\sigma)&lt;/equation&gt; 之后， &lt;equation&gt;\mathscr{L}&lt;/equation&gt; 中的合法项 &lt;equation&gt;t&lt;/equation&gt; 的&lt;b&gt;语义&lt;/b&gt;，&lt;br&gt;就可以归纳的定义为论域 &lt;equation&gt;\mathbb{M}&lt;/equation&gt; 中的元素了，记为 &lt;equation&gt;t_{M[\sigma]}&lt;/equation&gt; 。&lt;br&gt;（1） &lt;equation&gt;x_{M[\sigma ]}=\sigma (x)&lt;/equation&gt; ， &lt;equation&gt;x&lt;/equation&gt; 为变元符号&lt;br&gt;（2） &lt;equation&gt;c_{M[\sigma ]}=c_M&lt;/equation&gt; ， &lt;equation&gt;c&lt;/equation&gt; 为常元符号&lt;br&gt;（3） &lt;equation&gt;(ft_1\cdot \cdot \cdot t_n)_{M[\sigma ]}=f_M((t_1)_{M[\sigma ]},\cdot \cdot \cdot (t_n)_{M[\sigma ]})&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;例，初等算术 &lt;equation&gt;\Pi&lt;/equation&gt; 中项的语义，&lt;br&gt; &lt;equation&gt;(+x_1Sx_7)_{N[\sigma ]}=(x_1)_{N[\sigma ]}+(Sx_7)_{N[\sigma ]}=1+((x_7)_{N[\sigma ]}+1)=1+(7+1)=9&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;逻辑公式的语义&lt;/b&gt;&lt;/p&gt;&lt;p&gt;公式 &lt;equation&gt;A&lt;/equation&gt; 在模型 &lt;equation&gt;(M, \sigma )&lt;/equation&gt; 下的&lt;b&gt;语义&lt;/b&gt;是一个真假值，用 &lt;equation&gt;A_{M[\sigma ]}&lt;/equation&gt; 表示，归纳定义如下，&lt;br&gt;（1） &lt;equation&gt;(Pt_1\cdot \cdot \cdot t_n)_{M[\sigma ]}=P_M((t_1)_{M[\sigma ]},\cdot \cdot \cdot ,(t_n)_{M[\sigma ]})&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;(t_1\doteq t_2)_{M[\sigma ]}=\begin{cases}T,&amp;amp;\text{if }(t_1)_{M[\sigma ]}=(t_2)_{M[\sigma ]}\\F,&amp;amp;\text{otherwise}\end{cases}&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;(\neg A)_{M[\sigma ]}=B_\neg (A_{M[\sigma ]})&lt;/equation&gt; &lt;br&gt;（4） &lt;equation&gt;(A\vee B)_{M[\sigma ]}=B_\vee (A_{M[\sigma ]}, B_{M[\sigma ]})&lt;/equation&gt; &lt;br&gt;（5） &lt;equation&gt;(A\wedge B)_{M[\sigma ]}=B_\wedge (A_{M[\sigma ]}, B_{M[\sigma ]})&lt;/equation&gt; &lt;br&gt;（6） &lt;equation&gt;(A\rightarrow B)_{M[\sigma ]}=B_\rightarrow (A_{M[\sigma ]}, B_{M[\sigma ]})&lt;/equation&gt; &lt;br&gt;（7） &lt;equation&gt;(A\leftrightarrow B)_{M[\sigma ]}=B_\leftrightarrow (A_{M[\sigma ]}, B_{M[\sigma ]})&lt;/equation&gt; &lt;br&gt;（8） &lt;equation&gt;(\forall x_iA)_{M[\sigma ]}=\begin{cases}T,&amp;amp;\forall a\in M, A_{M[\sigma [x_i:=a]]}=T\\F,&amp;amp;\text{otherwise}\end{cases}&lt;/equation&gt; &lt;br&gt;（9） &lt;equation&gt;(\exists x_iA)_{M[\sigma ]}=\begin{cases}T,&amp;amp;\exists a\in M, A_{M[\sigma [x_i:=a]]}=T\\F,&amp;amp;\text{otherwise}\end{cases}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中，二元真值函数 &lt;equation&gt;B_\wedge, B_\vee, B_\rightarrow, B_\leftrightarrow&lt;/equation&gt; ，分别逻辑连接词符号 &lt;equation&gt;\wedge, \vee, \rightarrow, \leftrightarrow&lt;/equation&gt; 的语义。&lt;/p&gt;&lt;p&gt;至此，我们通过为一阶语言指定模型，&lt;br&gt;将语言中所有的符号串都进行了&lt;b&gt;解释&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;6. 总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文以一阶逻辑为例，从逻辑学角度给出了&lt;b&gt;语义模型&lt;/b&gt;的定义，&lt;br&gt;由此，一阶逻辑系统中的符号串，都有了一个数学对象与之对应，&lt;br&gt;它们是论域，论域集合上的函数和运算。&lt;/p&gt;&lt;p&gt;可想而已，这些数学对象是有代数性质的，下文我们将继续深入了解。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34779520&quot;&gt;你好，类型（五）：Predicate logic&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/2364517/&quot;&gt;数理逻辑&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91&quot;&gt;一阶逻辑&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-30-35059714</guid>
<pubDate>Fri, 30 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（二）：初等代数</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-29-35017879.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35017879&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a2b350a00ab43a44fcfe38f78923048b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;698&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-a2b350a00ab43a44fcfe38f78923048b&quot; data-watermark-src=&quot;v2-834251828200ebeee6f352501335c306&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文中我们介绍了一个称为“pq”的系统，并且给它&lt;b&gt;选择&lt;/b&gt;了一个合理的语义解释。&lt;br&gt;我们将&lt;code class=&quot;inline&quot;&gt;---q-p--&lt;/code&gt;解释为“3等于1加2”。&lt;/p&gt;&lt;p&gt;此外，我们还知道了，解释的方式，是随着形式系统的&lt;b&gt;公理化条件&lt;/b&gt;而改变的。&lt;br&gt;更改了“pq系统”的公理或者推导规则的时候，系统中公理和定理的&lt;b&gt;含义&lt;/b&gt;都会发生改变。&lt;/p&gt;&lt;p&gt;为此我们回顾了几何学中的欧几里得第五公设问题，&lt;br&gt;看到了语义问题对数学家们造成的困扰。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;自然数语言&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6ca1ee92d06503ca703443c055975951_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;618&quot; data-rawheight=&quot;496&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-6ca1ee92d06503ca703443c055975951&quot; data-watermark-src=&quot;v2-c16ca45c9d298873b02ba98fc565ef7a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;从读小学的时候开始，我们就认识了&lt;b&gt;自然数&lt;/b&gt;，&lt;br&gt;我们可以从零开始计数，每个数字比它前面的多一， &lt;equation&gt;0~1~2~3~4~5~6~\cdots&lt;/equation&gt; &lt;br&gt;这些数字可以用来表示物品的个数。&lt;/p&gt;&lt;p&gt;它们是如此的贴近生活，如此自然，&lt;br&gt;以致我们一直以来，就把两个不同的&lt;b&gt;概念混淆&lt;/b&gt;在了一起。&lt;/p&gt;&lt;p&gt;一个概念是自然数的&lt;b&gt;语法&lt;/b&gt;构造，属于编码问题，&lt;br&gt;另一个概念则是对这种语法构造的&lt;b&gt;解释&lt;/b&gt;，属于语义问题。&lt;/p&gt;&lt;p&gt;为了看清这一点，&lt;br&gt;我们使用公理化方式定义一个&lt;b&gt;自然数形式系统&lt;/b&gt;，为此我们要问自己这些问题。&lt;/p&gt;&lt;p&gt;（1）这个形式系统包含了哪些&lt;b&gt;符号&lt;/b&gt;呢？&lt;br&gt;它只包含&lt;code class=&quot;inline&quot;&gt;0~9&lt;/code&gt;，这个十个字符。&lt;/p&gt;&lt;p&gt;（2）哪些符号串是&lt;b&gt;合法的&lt;/b&gt;？&lt;br&gt;一位符号串，或者不是&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;开头的多位符号串，都是合法的。&lt;br&gt;所有这些合法的符号串，构成了一个集合，称为该形式系统的“&lt;b&gt;语言&lt;/b&gt;”。&lt;/p&gt;&lt;p&gt;（3）哪些符号串被认为是&lt;b&gt;公理&lt;/b&gt;或&lt;b&gt;定理&lt;/b&gt;，定理之间的&lt;b&gt;推导规则&lt;/b&gt;是什么？&lt;br&gt;对于自然数形式系统来说，符号串&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;可以看做公理，后继函数可以看做推导规则。&lt;/p&gt;&lt;p&gt;（4）这些符号串的&lt;b&gt;含义&lt;/b&gt;是什么？&lt;br&gt;简单起见，我们可以直接指定符号串的含义为它所对应的那个自然数。&lt;br&gt;例如，&lt;code class=&quot;inline&quot;&gt;3&lt;/code&gt;是一个符号串，我们指定它对应 &lt;equation&gt;3&lt;/equation&gt; 这个自然数。&lt;br&gt;其中&lt;code class=&quot;inline&quot;&gt;3&lt;/code&gt;是&lt;b&gt;语法符号&lt;/b&gt;， &lt;equation&gt;3&lt;/equation&gt; 是&lt;b&gt;数学对象&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Peano系统&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-463638b4f26b795b43ffa6e69d129d99_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;719&quot; data-rawheight=&quot;283&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-463638b4f26b795b43ffa6e69d129d99&quot; data-watermark-src=&quot;v2-55bf380479312a5fe9ef07371e3e7378&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;上一节我们使用公理化的方式建立了一个形式系统，&lt;br&gt;并且选择了自然数作为该形式系统中符号串的解释。&lt;/p&gt;&lt;p&gt;可是在数学上，&lt;b&gt;自然数到底是什么呢？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;要回答这个问题，还要回顾《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34679052&quot;&gt;你好，类型&lt;/a&gt;》系列文章中介绍的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%9A%AE%E4%BA%9A%E8%AF%BA%E5%85%AC%E7%90%86&quot;&gt;Peano系统&lt;/a&gt;，&lt;br&gt;皮亚诺（&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9C%B1%E5%A1%9E%E4%BD%A9%C2%B7%E7%9A%AE%E4%BA%9E%E8%AB%BE&quot;&gt;Peano&lt;/a&gt;）将自然数理论建立在了&lt;b&gt;集合论&lt;/b&gt;之上。&lt;/p&gt;&lt;p&gt;其中， &lt;equation&gt;\{\varnothing,\varnothing^+,\varnothing^{++},\cdots\}&lt;/equation&gt; 构成了一个&lt;a href=&quot;https://thzt.github.io/2017/09/06/type-2/&quot;&gt;归纳集&lt;/a&gt;。&lt;br&gt;我们将 &lt;equation&gt;\varnothing,\varnothing^+,\varnothing^{++},\cdots&lt;/equation&gt; 定义为&lt;b&gt;自然数&lt;/b&gt;，（&lt;a href=&quot;https://en.wikipedia.org/wiki/Natural_number#Von_Neumann_construction&quot;&gt;von Neumann construction&lt;/a&gt;）&lt;br&gt;这样每一个自然数就和一个集合对应起来了。&lt;/p&gt;&lt;p&gt;因此，自然数 &lt;equation&gt;3&lt;/equation&gt; 是一个集合， &lt;equation&gt;\varnothing^{+++}=\{\varnothing,\{\varnothing\},\{\varnothing,\{\varnothing\}\}\}&lt;/equation&gt; ，&lt;br&gt;其中， &lt;equation&gt;A^+&lt;/equation&gt; 为集合 &lt;equation&gt;A&lt;/equation&gt; 的&lt;b&gt;后继运算&lt;/b&gt;， &lt;equation&gt;A^+=A\cup\{A\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;总而言之，符号串&lt;code class=&quot;inline&quot;&gt;3&lt;/code&gt;的数学解释，是一个集合 &lt;equation&gt;\varnothing^{+++}&lt;/equation&gt; 。&lt;br&gt;（不必惊讶。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;自然数代数&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9a7107c2e192d9f62649f8b1402faa96_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;390&quot; data-rawheight=&quot;300&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9a7107c2e192d9f62649f8b1402faa96&quot; data-watermark-src=&quot;v2-bba8ad8b43a82c97d564fb4b62ff187a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;在读小学的时候，数学课只有一门，主要学有理数的四则运算，&lt;br&gt;而到了初中，数学就变成了两门，分为&lt;b&gt;代数&lt;/b&gt;课与&lt;b&gt;几何&lt;/b&gt;课，&lt;br&gt;代数课主要讲方程和函数，几何课主要讲平面几何。&lt;/p&gt;&lt;p&gt;平面几何是很直观的，也很容易和其他数学划清界线，&lt;br&gt;因此，初中生们对“什么是几何”都没有太多疑惑。&lt;br&gt;但是至于“&lt;b&gt;什么是代数&lt;/b&gt;”，就比较费解了，这个问题也困扰了我很久。&lt;/p&gt;&lt;p&gt;到大学，我们又学了线性代数，这种困扰日益加深，&lt;br&gt;因为居然出现了一种“线性的”“代数”，&lt;br&gt;却没有人事先告诉我们到底什么是“代数”。&lt;/p&gt;&lt;p&gt;后来我们学了抽象代数，这个问题才得以解决，我找到了一个令自己满意的答案。&lt;/p&gt;&lt;p&gt;为了说明“什么是代数”，最简单的办法就是下&lt;b&gt;定义&lt;/b&gt;，&lt;br&gt;设集合 &lt;equation&gt;M&lt;/equation&gt; 上定义了一组运算， &lt;equation&gt;a_1,a_2,\cdots,a_n&lt;/equation&gt; ，&lt;br&gt;运算结果仍是 &lt;equation&gt;M&lt;/equation&gt; 中的元素，则称 &lt;equation&gt;M&lt;/equation&gt; 相对于这 &lt;equation&gt;n&lt;/equation&gt; 个运算，构成了一个&lt;b&gt;代数&lt;/b&gt;。&lt;/p&gt;&lt;blockquote&gt;一般来说，代数问题的特点，&lt;br&gt;是对一类问题，利用统一的运算性质，求出所有可能的解答。&lt;/blockquote&gt;&lt;p&gt;因此，代数学就是研究&lt;b&gt;运算系统性质&lt;/b&gt;的学问。&lt;br&gt;而Peano系统，是最简单的运算系统之一，又称为&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%9A%AE%E4%BA%9A%E8%AF%BA%E5%85%AC%E7%90%86&quot;&gt;一阶算术系统&lt;/a&gt;。&lt;br&gt;自然数就是这个系统中的&lt;b&gt;运算对象&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;因此，小学数学也称为“算术”。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;代数学观点&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c907d127c351d66493491935cb19d4d0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;542&quot; data-rawheight=&quot;374&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c907d127c351d66493491935cb19d4d0&quot; data-watermark-src=&quot;v2-a2bf6961d44b1395b09b0b42048ab524&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;随着代数学的发展，人们发明了许多运算系统，&lt;br&gt;例如，整数的加减法，有理数的四则运算，实数的根式或指数运算，等等。&lt;br&gt;它们都有现实的对应物，&lt;b&gt;仿佛&lt;/b&gt;数学的研究对象就是现实世界一样。&lt;/p&gt;&lt;p&gt;然而，实际上并非如此。&lt;/p&gt;&lt;p&gt;例如，复数 &lt;equation&gt;1+2i&lt;/equation&gt; ，它是没有现实对应的，&lt;br&gt;但是我们仍然可以对复数进行运算。&lt;br&gt;一个三次方程可能没有实数解，但必定会存在三个复数解。&lt;/p&gt;&lt;p&gt;引入了复数之后，我们也才能体会到欧拉公式之美， &lt;equation&gt;e^{i\pi}+1=0&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;另一方面，代数学的研究重点也发生了改变，&lt;br&gt;一开始人们研究的是单个的，独立的，具体的运算系统，&lt;br&gt;但是后来人们逐渐发现，很多运算系统有相同的运算性质，&lt;br&gt;可以&lt;b&gt;抽象&lt;/b&gt;出来进行讨论。&lt;/p&gt;&lt;p&gt;例如，计算机系统中的无符号数，连同加法运算，构成了一个&lt;b&gt;阿贝尔群&lt;/b&gt;。&lt;br&gt;而阿贝尔群中的加法，满足交换律和结合律，&lt;br&gt;因此，编译器就可以采用任意的顺序进行计算，不影响最终结果。&lt;/p&gt;&lt;p&gt;&lt;b&gt;从运算性质的角度来分析问题&lt;/b&gt;，越来越流行了，&lt;br&gt;成为了现代数学不可或缺的一部分，&lt;br&gt;并且，代数学考虑问题的方法，也逐渐影响着其他学科。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文从语义和代数学角度重新认识了自然数，&lt;br&gt;自然数是Peano系统中的运算对象，&lt;br&gt;自然数集连同其上定义的后继运算，构成了一个代数（一阶算术系统）。&lt;/p&gt;&lt;p&gt;更重要的是，从代数学角度来看待问题，&lt;br&gt;有利于我们抓住系统中所隐含的&lt;b&gt;运算性质&lt;/b&gt;。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34679052&quot;&gt;你好，类型（二）：Lambda calculus&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/4114998/&quot;&gt;计算机语言的形式语义&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1833230/&quot;&gt;近世代数初步&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1896753/&quot;&gt;深入理解计算机系统&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-29-35017879</guid>
<pubDate>Thu, 29 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>语言背后的代数学（一）：语义解释</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-28-34977830.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34977830&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-134995884618e02bd2e40ed91782730d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;775&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;h2&gt;&lt;b&gt;1. 初窥语义&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34669807&quot;&gt;你好，类型&lt;/a&gt;》系列中，我们介绍了一些&lt;b&gt;形式系统&lt;/b&gt;，&lt;br&gt;例如 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 系统（ &lt;equation&gt;\lambda&lt;/equation&gt; 演算）， &lt;equation&gt;CL_w&lt;/equation&gt; （组合子逻辑），&lt;br&gt;它们由一些&lt;b&gt;合法的符号&lt;/b&gt;，以及这些符号的&lt;b&gt;推导规则&lt;/b&gt;构成，&lt;br&gt;命题逻辑与谓词逻辑，也可以用这种&lt;b&gt;公理化&lt;/b&gt;的方式构建起来。&lt;/p&gt;&lt;p&gt;然而，在讨论这些系统的时候，我们只是把它们看成了单纯的符号演算，&lt;br&gt;并没有过多考虑这些符号到底代表什么含义。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\lambda&lt;/equation&gt; 项 &lt;equation&gt;(\lambda x.x(xy))N&lt;/equation&gt; ，经过 &lt;equation&gt;\beta&lt;/equation&gt; 变换，我们可以得到， &lt;equation&gt;N(Ny)&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;(\lambda x.x(xy))N\triangleright_\beta N(Ny)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;它看起来真的&lt;b&gt;好像&lt;/b&gt;一个函数调用啊。&lt;br&gt;这就给我们带来了以下思考，是否可以把 &lt;equation&gt;(\lambda x.x(xy))&lt;/equation&gt; 解释为一个函数呢？&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;function (x){
    return x(x(y));
}&lt;/code&gt;&lt;p&gt;是否可以认为， &lt;equation&gt;(\lambda x.x(xy))N&lt;/equation&gt; 是用参数 &lt;equation&gt;N&lt;/equation&gt; 对该函数进行调用呢？&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;(function (x){
    return x(x(y));
}(N));

// 调用后相当于返回了以下结果
N(N(y))&lt;/code&gt;&lt;p&gt;这样解释的话， &lt;equation&gt;\beta&lt;/equation&gt; 变换就可以看做函数调用了。&lt;br&gt;这一切似乎顺理成章，显而易见。&lt;/p&gt;&lt;p&gt;可是，我们为什么可以这样做呢？&lt;br&gt; &lt;equation&gt;\beta&lt;/equation&gt; 变换与函数调用之间的关系是唯一确定的吗？&lt;br&gt;为了回答好这些问题，还得重新研读&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AF%AD%E4%B9%89%E5%AD%A6&quot;&gt;语义学&lt;/a&gt;这个有趣的学科。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 公理化&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-129f6b44ad6f901ec1f41203f965c775_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;806&quot; data-rawheight=&quot;393&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;首先我们先回顾一下，形式系统是怎么用公理化的方式构建的。&lt;br&gt;我们以一个称之为“pq”的系统为例。（出自《&lt;a href=&quot;https://book.douban.com/subject/1291204/&quot;&gt;哥德尔、艾舍尔、巴赫——集异璧之大成&lt;/a&gt;》）&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.1 公理化步骤&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;第一步&lt;/b&gt;，&lt;br&gt;我们要有一些&lt;b&gt;符号&lt;/b&gt;。&lt;br&gt;例如：“pq系统”只有三个符号，&lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;-&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第二步&lt;/b&gt;，&lt;br&gt;我们要说明什么样的符号串是&lt;b&gt;合法的&lt;/b&gt;，即指定一套&lt;b&gt;语法&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如，我们规定“pq系统”中合法的符号串，形如&lt;code class=&quot;inline&quot;&gt;xqypz&lt;/code&gt;，&lt;br&gt;其中，&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;z&lt;/code&gt;仅由一串短杠组成。&lt;/p&gt;&lt;code lang=&quot;bnf&quot;&gt;term := n &#39;q&#39; n &#39;p&#39; n
n := &#39;-&#39; | &#39;-&#39; n&lt;/code&gt;&lt;p&gt;因此，&lt;code class=&quot;inline&quot;&gt;--q-p-&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;---q--p-&lt;/code&gt;都是合法的符号串。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第三步，&lt;br&gt;&lt;/b&gt;我们要指定&lt;b&gt;公理&lt;/b&gt;和&lt;b&gt;推导规则&lt;/b&gt;，&lt;br&gt;其中公理是推导的出发点，由公理推导得出的符号串称为&lt;b&gt;定理&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;（1）“pq”系统的&lt;b&gt;公理&lt;/b&gt;如下，&lt;br&gt;只要&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;仅由一串短杠组成，那么&lt;code class=&quot;inline&quot;&gt;x-qxp-&lt;/code&gt;就是一条公理。&lt;/p&gt;&lt;p&gt;（2）“pq”系统的&lt;b&gt;推导规则&lt;/b&gt;是这样的，&lt;br&gt;假设&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;z&lt;/code&gt;都代表只包含短杠的特定的符号串，&lt;br&gt;并且假设&lt;code class=&quot;inline&quot;&gt;xqypz&lt;/code&gt;是一条已知的公理/定理，&lt;br&gt;那么&lt;code class=&quot;inline&quot;&gt;x-qypz-&lt;/code&gt;就是一条定理。&lt;/p&gt;&lt;p&gt;即它们满足 &lt;equation&gt;\frac{xqypz}{x-qypz-}&lt;/equation&gt; ，表示如果 &lt;equation&gt;xqypz&lt;/equation&gt; 是定理，则 &lt;equation&gt;x-qypz-&lt;/equation&gt; 也是定理。&lt;/p&gt;&lt;p&gt;例子，根据公理的定义，我们知道&lt;code class=&quot;inline&quot;&gt;--q-p-&lt;/code&gt;是一条公理，&lt;br&gt;又根据这条公理和推导规则，我们得到了&lt;code class=&quot;inline&quot;&gt;---q-p--&lt;/code&gt;是一条定理。&lt;/p&gt;&lt;p&gt;&lt;b&gt;小结：&lt;br&gt;&lt;/b&gt;以上三步我们通过公理化的方式构建了一个形式系统，&lt;br&gt;它由符号，语法，公理，推导规则组成，&lt;br&gt;我们可以用公理和旧定理生成新定理，不断演算。&lt;/p&gt;&lt;p&gt;在其他系统中，公理和定理的个数可能是有限的，而“pq”系统则是无限的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.2 解释&lt;/b&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-95ab0145a95af5914d68596e6d3d844d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;332&quot; data-rawheight=&quot;327&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;我们说以上“pq系统”定义了一个&lt;b&gt;形式语言&lt;/b&gt;，&lt;br&gt;这里的“语言”是一种数学上的定义，指的是&lt;b&gt;字符串的集合&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;“pq”系统的形式语言，就是系统中公理和定理的集合。&lt;/p&gt;&lt;p&gt;考察一个&lt;b&gt;形式语言&lt;/b&gt;，通常我们要研究它的两个方面，&lt;br&gt;其一，形式语言的&lt;b&gt;语法&lt;/b&gt;，指的是字符串的构成方式，&lt;br&gt;其二，形式语言的&lt;b&gt;语义&lt;/b&gt;，指的是每个字符串的含义。&lt;/p&gt;&lt;p&gt;我想大家都已经读过《&lt;a href=&quot;https://book.douban.com/subject/1148282/&quot;&gt;计算机程序的构造与解释&lt;/a&gt;》了吧，&lt;br&gt;所谓构造，指的就是语法，而解释指的就是语义。&lt;/p&gt;&lt;p&gt;那我们来看一看“pq系统”的形式语言该怎样解释吧。&lt;/p&gt;&lt;p&gt;我们可以&lt;b&gt;选择&lt;/b&gt;这样的解释方式，&lt;br&gt;例如，我们可以将&lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt;解释为“等于”，而将&lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt;解释为“加”，将短杠解释为数字。&lt;br&gt;于是，&lt;code class=&quot;inline&quot;&gt;---q-p--&lt;/code&gt;就可以被解释为“3等于1加2”了。&lt;/p&gt;&lt;p&gt;值得注意的是，合理的解释并不一定是唯一的，&lt;br&gt;例如，我们将&lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt;解释为“减”，将&lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt;解释为“等于”，也是可以的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 重新解释&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e603ce2f38b31d4a63e71f103b23171d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;398&quot; data-rawheight=&quot;298&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;上文中我们先给出了形式系统，然后再为系统选择一个合理的解释，&lt;br&gt;这种思维过程是值得提倡的。&lt;/p&gt;&lt;p&gt;考虑语义问题的时候，&lt;br&gt;我们应该总是先想想，&lt;b&gt;当前在对什么系统进行解释&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如，对“pq”系统，我们再引入一条新的公理，&lt;/p&gt;&lt;p&gt;&lt;b&gt;新公理：&lt;br&gt;&lt;/b&gt;只要&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;仅由一串短杠组成，那么&lt;code class=&quot;inline&quot;&gt;xqxp-&lt;/code&gt;也是一条公理。&lt;/p&gt;&lt;p&gt;现在来看，引入的新公理对“pq系统”产生了什么影响。&lt;br&gt;首先，&lt;code class=&quot;inline&quot;&gt;-q-p-&lt;/code&gt;在新系统中是一条公理，而在老系统中不是。&lt;br&gt;其次，根据推导规则，&lt;code class=&quot;inline&quot;&gt;--q-p--&lt;/code&gt;是新系统中的一条定理，而在老系统中也不是。&lt;/p&gt;&lt;p&gt;考虑到我们之前对符号串的解释，我们发现，&lt;br&gt;如果仍然沿用老系统对符号串的解释，&lt;code class=&quot;inline&quot;&gt;--q-p--&lt;/code&gt;应该被解释为“2等于1加2”，&lt;br&gt;这显然是不正确的。&lt;/p&gt;&lt;p&gt;因此，&lt;b&gt;在系统发生变化的时候，旧的解释可能就行不通了&lt;/b&gt;，&lt;br&gt;我们要对系统选择一个新的解释。&lt;/p&gt;&lt;p&gt;例如，我们只需要将&lt;code class=&quot;inline&quot;&gt;q&lt;/code&gt;解释为“小于或等于”就行了。&lt;br&gt;然而，现在看来这种顺利成章的事情，却困扰了数学家们很多年。&lt;/p&gt;&lt;blockquote&gt;这是整个19世纪数学的最深刻的教训之一。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;4. 非欧几何&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f983e4bfb2298074cf707a73f22b27c8_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;529&quot; data-rawheight=&quot;178&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;大家应该都听说过欧几里得&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%8C%E5%85%AC%E8%A8%AD&quot;&gt;第五公设&lt;/a&gt;的故事，欧几里得采用了&lt;b&gt;公理化&lt;/b&gt;的方式构建了几何学，&lt;br&gt;其中第五公设又称平行公设，它既不能被其他公设证明，也不能证否，&lt;br&gt;两千年来，在第五公设问题上，耗费了无数年轻数学家的生命和心血。&lt;/p&gt;&lt;blockquote&gt;如果两条直线与第三条直线相交时，在第三条直线的某一侧三条线所夹的内角之和小于两个直角的和，则那两条直线沿着这一侧延伸足够长之后必然相交&lt;/blockquote&gt;&lt;p&gt;1820年左右，俄国喀山大学教授&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B0%BC%E5%8F%A4%E6%8B%89%C2%B7%E7%BD%97%E5%B7%B4%E5%88%87%E5%A4%AB%E6%96%AF%E5%9F%BA&quot;&gt;罗巴切夫斯基&lt;/a&gt;，提出了一个与第五公设相矛盾的命题，&lt;br&gt;然后与欧几里得的前四个公设结合成一个公理系统，展开一系列的推理。&lt;br&gt;他认为如果这个系统在推理中出现矛盾，就等于证明了第五公设，此即数学中的反证法。&lt;/p&gt;&lt;p&gt;但是，在他极为细致深入的推理过程中，&lt;br&gt;得出了一个又一个在直觉上匪夷所思，&lt;br&gt;但在逻辑上毫无矛盾的命题。&lt;/p&gt;&lt;p&gt;这在当时是一件很难理解的事情，&lt;br&gt;因为人们一致认为，欧几里得几何是&lt;b&gt;物质空间中图形性质的正确理想化&lt;/b&gt;。&lt;br&gt;正确的几何结论&lt;b&gt;不应该&lt;/b&gt;与我们的直观感受不符。&lt;/p&gt;&lt;p&gt;现在看来，这样理解当然是有问题的，&lt;br&gt;因为，它&lt;b&gt;混淆了公理系统中的结论，和对这些结论的解释&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;就好像上文中我们为“pq”系统增加了新公理一样，&lt;br&gt;新定理仍然是正确推导的产物，只是不能沿用旧方式进行解释了。&lt;/p&gt;&lt;p&gt;关于欧几里得第五公设，最终人们得到了三种常用的几何学，&lt;br&gt;称为欧几里得几何，罗巴切夫斯基几何，以及黎曼几何。&lt;br&gt;这些公理系统，对研究不同的数学对象起到了关键作用。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;5. 总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文通过一个称之为“pq”的系统，介绍了形式系统公理化的典型步骤，&lt;br&gt;并且严格区分了，公理系统中的&lt;b&gt;结论&lt;/b&gt;与对它的&lt;b&gt;解释&lt;/b&gt;之间的不同。&lt;/p&gt;&lt;p&gt;通过更改公理系统，不论修改公理或者修改推导规则，我们将得到一个新的系统，&lt;br&gt;从而对新系统中的结论，我们就得采用审慎的方式&lt;b&gt;重新解释&lt;/b&gt;。&lt;br&gt;这是数学史给我们带来的最有价值的经验教训之一。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34669807&quot;&gt;你好，类型（一）：开篇&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_system&quot;&gt;Formal system&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Formal_language&quot;&gt;Formal language&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AF%AD%E4%B9%89%E5%AD%A6&quot;&gt;语义学&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1291204/&quot;&gt;哥德尔、艾舍尔、巴赫——集异璧之大成&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%8C%E5%85%AC%E8%A8%AD&quot;&gt;平行公设&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;http://www.kepu.net.cn/gb/basic/szsx/4/44/4_44_1005.htm&quot;&gt;非欧几何学的诞生&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-28-34977830</guid>
<pubDate>Wed, 28 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（十）：Parametric polymorphism</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-27-34936637.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34936637&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6b54d583eb6b73ad8566ca881cf020a0_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;698&quot;&gt;&lt;h2&gt;&lt;b&gt;回顾&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;上文我们介绍了&lt;b&gt;let多态&lt;/b&gt;，&lt;br&gt;将let表达式 &lt;equation&gt;let~x=t_1~in~t_2&lt;/equation&gt; ，看做了 &lt;equation&gt;[x\mapsto t_1]t_2&lt;/equation&gt; 的简写，&lt;br&gt;即，把 &lt;equation&gt;t_2&lt;/equation&gt; 中出现的所有 &lt;equation&gt;x&lt;/equation&gt; ，都用 &lt;equation&gt;t_1&lt;/equation&gt; 替换掉，因此这些副本可以具有不同的类型。&lt;/p&gt;&lt;p&gt;本文将介绍另外一种多态形式，称为&lt;b&gt;参数化多态&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Parametric_polymorphism&quot;&gt;parametric polymorphism&lt;/a&gt;），例如，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data Maybe a = Nothing | Just a&lt;/code&gt;&lt;p&gt;以上Haskell代码，定义了一个&lt;code class=&quot;inline&quot;&gt;Maybe a&lt;/code&gt;类型，&lt;br&gt;其中&lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt;称为类型构造器（type constructor），&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;是它的参数。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Maybe&lt;/code&gt;不是一个合法的类型，它只有和某个具体的&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;放在一起，才是一个合法的类型，&lt;br&gt;例如，&lt;code class=&quot;inline&quot;&gt;Maybe Int&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;Maybe Char&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;System F&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2599a0bf18815b88e00dbfd51c04a385_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;270&quot;&gt;&lt;p&gt;为了实现参数化多态，我们需要对简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算（ &lt;equation&gt;\lambda^\to&lt;/equation&gt; 系统）进行扩展，&lt;br&gt;在 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 中，我们用 &lt;equation&gt;\lambda x.t&lt;/equation&gt; 来表示 &lt;equation&gt;\lambda&lt;/equation&gt; 抽象（lambda abstraction），&lt;br&gt;而使用 &lt;equation&gt;t_1~t_2&lt;/equation&gt; 来表示 &lt;equation&gt;\lambda&lt;/equation&gt; 应用（lambda application）。&lt;/p&gt;&lt;p&gt;现在我们引入一种新的抽象形式， &lt;equation&gt;\lambda X.t&lt;/equation&gt; ，它的参数 &lt;equation&gt;X&lt;/equation&gt; 是一个类型，称为&lt;b&gt;类型抽象&lt;/b&gt;，&lt;br&gt;再引入一种新的应用形式， &lt;equation&gt;t[T]&lt;/equation&gt; ，称为&lt;b&gt;类型实例化&lt;/b&gt;，其中 &lt;equation&gt;T&lt;/equation&gt; 是一个类型表达式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;求值规则&lt;/b&gt;如下，&lt;br&gt; &lt;equation&gt;(\lambda X.t)[T]\to[X\mapsto T]&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;例如，我们可以这样定义一个多态函数， &lt;equation&gt;id=\lambda X.\lambda x:X.x&lt;/equation&gt; ，&lt;br&gt;当把它应用于类型 &lt;equation&gt;Nat&lt;/equation&gt; 时，&lt;br&gt; &lt;equation&gt;id[Nat]\to[X\mapsto Nat](\lambda x:X.x)=\lambda x:Nat.x&lt;/equation&gt; ，它为 &lt;equation&gt;Nat&lt;/equation&gt; 类型上的恒等函数。&lt;br&gt;而把它应用于类型 &lt;equation&gt;Bool&lt;/equation&gt; 时，&lt;br&gt; &lt;equation&gt;id[Bool]\to[X\mapsto Bool](\lambda x:X.x)=\lambda x:Bool.x&lt;/equation&gt; ，它为 &lt;equation&gt;Bool&lt;/equation&gt; 类型上的恒等函数，&lt;/p&gt;&lt;p&gt;可见， &lt;equation&gt;id&lt;/equation&gt; 的具体类型，依赖于它的&lt;b&gt;类型参数&lt;/b&gt;。&lt;br&gt;它应用于任意一个类型 &lt;equation&gt;T&lt;/equation&gt; ， &lt;equation&gt;id[T]&lt;/equation&gt; 都会得到一个类型为 &lt;equation&gt;T\to T&lt;/equation&gt; 的函数，&lt;br&gt;因此，人们通常将 &lt;equation&gt;id&lt;/equation&gt; 的类型记为 &lt;equation&gt;\forall X.X\to X&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;类型规则&lt;/b&gt;如下，&lt;/p&gt;&lt;p&gt;（1） &lt;equation&gt;\frac{\Gamma,X\vdash t:T}{\Gamma\vdash\lambda X.t:\forall X.T}&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\frac{\Gamma\vdash t_1:\forall X.T_1}{\Gamma\vdash t[T_2]:[X\mapsto T_2]T_1}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中，类型 &lt;equation&gt;\forall X.T&lt;/equation&gt; ，叫做&lt;b&gt;全称类型&lt;/b&gt;（universal type），&lt;br&gt; &lt;equation&gt;\forall&lt;/equation&gt; 称为&lt;b&gt;全称量词&lt;/b&gt;（universal quantifier），引入了全称类型之后得到的系统，称为&lt;b&gt;System F&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rank-N Types&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e7d0c235c510c23fd00f4261f94e4eb6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1240&quot; data-rawheight=&quot;698&quot;&gt;&lt;p&gt;有了全称类型之后，函数的参数类型和返回值类型，都有可能具有全称类型。&lt;br&gt;不难看出，函数返回值类型的全称量词，总是可以提取出来，放到最外面，&lt;br&gt;但是参数类型的全称量词，不能提取出来。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\forall X.X\to (\forall Y.Y\to X)&lt;/equation&gt; ，相当于 &lt;equation&gt;\forall X.\forall Y.X\to Y\to X&lt;/equation&gt; ，&lt;br&gt;而 &lt;equation&gt;(\forall X.X\to X)\to Nat&lt;/equation&gt; ，与 &lt;equation&gt;\forall X.(X\to X)\to Nat&lt;/equation&gt; 则不同。&lt;/p&gt;&lt;p&gt;不包含全称量词的类型表达式，具有&lt;b&gt;rank-0类型&lt;/b&gt;，也称为&lt;b&gt;单态类型&lt;/b&gt;（monotype），&lt;br&gt;全称量词都可以提取出来类型表达式，具有&lt;b&gt;rank-1类型&lt;/b&gt;（rank-1 type），&lt;br&gt;一个函数类型，它的入参具有&lt;b&gt;rank-n类型&lt;/b&gt;，那么该函数就具有&lt;b&gt;rank-(n+1)类型&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如，&lt;br&gt; &lt;equation&gt;((\forall X.X\to X)\to Nat)\to Bool\to Bool&lt;/equation&gt; ，具有rank-3类型，&lt;br&gt; &lt;equation&gt;Nat\to (\forall X.X\to X)&lt;/equation&gt; ，具有rank-1类型。&lt;/p&gt;&lt;p&gt;System F的功能是很强大的，但是&lt;a href=&quot;https://en.wikipedia.org/wiki/System_F#Use_in_programming_languages&quot;&gt;不幸的是&lt;/a&gt;，&lt;br&gt;人们发现，该系统中的类型推导算法是&lt;a href=&quot;https://en.wikipedia.org/wiki/Undecidable_problem&quot;&gt;不可判定的&lt;/a&gt;。&lt;br&gt;例如，一般而言，一个rank-3及其以上rank-N类型的表达式，其类型是不可确定的，&lt;br&gt;为了确定它的类型，人们不得不手工加上必要的类型信息。&lt;/p&gt;&lt;p&gt;Haskell采用了&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system&quot;&gt;Hindley–Milner类型系统&lt;/a&gt;，&lt;br&gt;它是System F的一个子集，其中包含了可判定的类型推导算法。&lt;br&gt;在Haskell中，类型参量（type variable）&lt;b&gt;默认&lt;/b&gt;具有全称类型（universally quantified），&lt;br&gt;例如，&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; a&lt;/code&gt;，实际上表示类型 &lt;equation&gt;\forall a.a\to a&lt;/equation&gt; ，&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; a&lt;/code&gt;可看做&lt;code class=&quot;inline&quot;&gt;(-&amp;gt;) a a&lt;/code&gt;类型，其中&lt;code class=&quot;inline&quot;&gt;-&amp;gt;&lt;/code&gt;为函数类型构造器。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;非直谓性&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b687486615e31ac710fae4f635cc5817_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;200&quot; data-rawheight=&quot;257&quot;&gt;&lt;p&gt;在数学和逻辑学中，一个定义称为&lt;b&gt;非直谓的&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Impredicativity&quot;&gt;impredicative&lt;/a&gt;），&lt;br&gt;指的是它包含了自引用（self-reference）。&lt;/p&gt;&lt;p&gt;例如，在定义一个集合的时候，用到了正在定义的这个集合。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Russell%27s_paradox&quot;&gt;罗素悖论&lt;/a&gt;就是用非直谓的方式构造出来的，&lt;br&gt;如果我们定义 &lt;equation&gt;R=\{x|x\notin x\}&lt;/equation&gt; ，那么 &lt;equation&gt;R\in R\Leftrightarrow R\notin R&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;非直谓定义并不一定导致矛盾，有些情况下还是有用的，例如，我们可以非直谓的定义，&lt;br&gt;集合中的最小元素为， &lt;equation&gt;A_{min}=x&lt;/equation&gt; ， &lt;equation&gt;\forall y.x\leqslant y&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;具有参数化多态的类型表达式，也有直谓（predicative）和非直谓（impredicative）之分。&lt;/p&gt;&lt;p&gt;如果它可以用一个多态类型实例化，例如用它自己来实例化，&lt;br&gt;就称为&lt;b&gt;非直谓多态类型&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Parametric_polymorphism#Impredicative_polymorphism&quot;&gt;impredicative polymorphism&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;反之，如果一个多态类型表达式，只能用单态类型实例化，&lt;br&gt;就称它具有&lt;b&gt;直谓多态类型&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Parametric_polymorphism#Predicative_polymorphism&quot;&gt;predicative_polymorphism&lt;/a&gt;）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;单态限制&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9f700c8427d7653a97af35c5fa56445d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;503&quot; data-rawheight=&quot;337&quot;&gt;&lt;code lang=&quot;haskell&quot;&gt;f x = let g y z = ([x,y], z) 
      in ...&lt;/code&gt;&lt;p&gt;假设&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的类型为&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，那么&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的类型只能为&lt;code class=&quot;inline&quot;&gt;a -&amp;gt; b -&amp;gt; ([a], b)&lt;/code&gt;，&lt;br&gt;其中，由于列表类型的限制，&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;必须具有相同的类型。&lt;/p&gt;&lt;p&gt;此时，只有&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;可以具有全称量词，即 &lt;equation&gt;\forall b.a\to b\to ([a],b)&lt;/equation&gt; ，&lt;br&gt;因为&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;在类型上下文中，已经出现了，不能再被实例化为其他的类型了。&lt;br&gt;我们称，&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;的第一个参数&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;具有&lt;b&gt;单态性&lt;/b&gt;（monomorphism）。&lt;/p&gt;&lt;p&gt;例如，&lt;code class=&quot;inline&quot;&gt;(g True, g &#39;c&#39;)&lt;/code&gt;不是良类型的，而&lt;code class=&quot;inline&quot;&gt;(g True, g False)&lt;/code&gt;是良类型的。&lt;/p&gt;&lt;p&gt;值得一提的是，显式的给&lt;code class=&quot;inline&quot;&gt;g&lt;/code&gt;注明类型，也不能阻止&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的单态行为，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;f x = let 
         g :: a -&amp;gt; b -&amp;gt; ([a],b) 
         g y z = ([x,y], z) 
      in ...&lt;/code&gt;&lt;p&gt;此时，&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;仍然是单态的。&lt;/p&gt;&lt;p&gt;在&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system&quot;&gt;Hindley–Milner类型系统&lt;/a&gt;中，&lt;br&gt;如果一个类型变量，不在类型上下文中出现，它就可以被&lt;b&gt;全称化&lt;/b&gt;（generalize）。&lt;br&gt;但是Haskell考虑到性能和模块间的类型推导，&lt;br&gt;还增加了特殊的&lt;b&gt;单态限制&lt;/b&gt;（monomorphism restriction）避免全称化。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Rule 1&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在一组相互依赖的声明中，满足以下两个条件，其中的类型变量才会被全称化，&lt;br&gt;（1）每一个变量，都被函数或模式匹配所绑定，&lt;br&gt;（2）被模式匹配绑定的变量，都有显式的类型签名。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Rule 2&lt;/b&gt;&lt;/p&gt;&lt;p&gt;导入到其他模块（module）的单态类型变量，被认为是有歧义的（ambiguous），&lt;br&gt;类型通过其来源模块内的&lt;code class=&quot;inline&quot;&gt;default&lt;/code&gt;声明来决定。&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;module M1(len1) where 
  default( Int, Double ) 
  len1 = genericLength &quot;Hello&quot;

module M2 where 
  import M1(len1) 
  len2 = (2 * len1) :: Rational&lt;/code&gt;&lt;p&gt;当模块&lt;code class=&quot;inline&quot;&gt;M1&lt;/code&gt;的类型推导结束后，根据Rule 1，&lt;code class=&quot;inline&quot;&gt;len1&lt;/code&gt;具有单态类型，&lt;br&gt;&lt;code class=&quot;inline&quot;&gt;len1 :: Num a =&amp;gt; a&lt;/code&gt;，&lt;br&gt;Rule 2表明，类型变量&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;具有歧义性，必须使用&lt;code class=&quot;inline&quot;&gt;default&lt;/code&gt;声明来解决歧义。&lt;/p&gt;&lt;p&gt;因此，根据&lt;code class=&quot;inline&quot;&gt;default( Int, Double )&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;len1&lt;/code&gt;得到了类型&lt;code class=&quot;inline&quot;&gt;Int&lt;/code&gt;，&lt;br&gt;不过，&lt;code class=&quot;inline&quot;&gt;M2&lt;/code&gt;中对&lt;code class=&quot;inline&quot;&gt;len1 :: Int&lt;/code&gt;的使用导致了类型错误。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/1761910/&quot;&gt;Types and programming languages&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.haskell.org/definition/haskell2010.pdf&quot;&gt;Haskell 2010 Language Report&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#arbitrary-rank-polymorphism&quot;&gt;Glasgow Haskell Compiler User’s Guide&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Parametric_polymorphism&quot;&gt;Parametric polymorphism&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/putting.pdf&quot;&gt;Practical type inference for arbitrary-rank types&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/System_F&quot;&gt;System F&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system&quot;&gt;Hindley–Milner type system&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-27-34936637</guid>
<pubDate>Tue, 27 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（九）：Let polymorphism</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-26-34915143.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34915143&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d8893deacbd14601cc4881797561323d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;500&quot;&gt;&lt;h2&gt;&lt;b&gt;类型变量&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;到目前为止，我们遇到的每一个 &lt;equation&gt;\lambda&lt;/equation&gt; 项都有唯一确定的类型，&lt;br&gt;因为，项的类型都被显式的注释在了它的后面。&lt;br&gt;例如，我们可以定义一个恒等函数 &lt;equation&gt;id=\lambda x:Nat.~x:Nat\to Nat&lt;/equation&gt; ，&lt;br&gt;则 &lt;equation&gt;id&lt;/equation&gt; 的类型就是固定的， &lt;equation&gt;Nat\to Nat&lt;/equation&gt; ，而 &lt;equation&gt;id~true&lt;/equation&gt; 就不是良类型的。&lt;/p&gt;&lt;p&gt;为每一个类型的恒等函数都定义各自的版本，是非常繁琐的，&lt;br&gt;因此，一个自然的想法是，我们能否让 &lt;equation&gt;id&lt;/equation&gt; 的类型&lt;b&gt;参数化&lt;/b&gt;，&lt;br&gt;让它在不同的上下文中，实例化为不同的具体类型。&lt;br&gt;例如， &lt;equation&gt;id=\lambda x:X.~x:X\to X&lt;/equation&gt; ，其中 &lt;equation&gt;X&lt;/equation&gt; 是&lt;b&gt;类型参量&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;类型代换&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;类型代换&lt;/b&gt; &lt;equation&gt;\sigma&lt;/equation&gt; ，指的是一个从类型变量到类型的有限映射。&lt;br&gt;例如， &lt;equation&gt;\sigma=[X\mapsto T,Y\mapsto U]&lt;/equation&gt; ，会将类型变量 &lt;equation&gt;X,Y&lt;/equation&gt; 分别代换为 &lt;equation&gt;T,U&lt;/equation&gt; 。&lt;br&gt;其中， &lt;equation&gt;X,Y&lt;/equation&gt; 称为代换 &lt;equation&gt;\sigma&lt;/equation&gt; 的&lt;b&gt;定义域&lt;/b&gt;，记为 &lt;equation&gt;dom(\sigma)&lt;/equation&gt; ，&lt;br&gt;而 &lt;equation&gt;T,U&lt;/equation&gt; 称为代换 &lt;equation&gt;\sigma&lt;/equation&gt; 的&lt;b&gt;值域&lt;/b&gt;，记为 &lt;equation&gt;range(\sigma)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;值得一提的是，所有的代换都是同时进行的， &lt;equation&gt;\sigma=[X\mapsto Bool,Y\mapsto X\to X]&lt;/equation&gt; ，&lt;br&gt;是将 &lt;equation&gt;X&lt;/equation&gt; 映射成 &lt;equation&gt;Bool&lt;/equation&gt; ，将 &lt;equation&gt;Y&lt;/equation&gt; 映射成 &lt;equation&gt;X\to X&lt;/equation&gt; ，而不是 &lt;equation&gt;Bool\to Bool&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;代换&lt;/b&gt;可以用下面的方式来定义，&lt;br&gt;（1） &lt;equation&gt;\sigma(X)=X&lt;/equation&gt; ，如果 &lt;equation&gt;X\notin dom(\sigma)&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\sigma(X)=T&lt;/equation&gt; ，如果 &lt;equation&gt;(X\mapsto T)\in\sigma&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;\sigma(Nat)=Nat&lt;/equation&gt; ， &lt;equation&gt;\sigma(Bool)=Bool&lt;/equation&gt; &lt;br&gt;（4） &lt;equation&gt;\sigma(T_1\to T_2)=\sigma T_1\to\sigma T_2&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;对于类型上下文 &lt;equation&gt;\Gamma=\{x_1:T_1,\cdots,x_n:T_n\}&lt;/equation&gt; 来说， &lt;equation&gt;\sigma\Gamma=\{x_1:\sigma T_1,\cdots,x_n:\sigma T_n\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;类型代换的一个重要特性是它保留了类型声明的有效性，&lt;br&gt;如果包含类型变量的项是良类型的，那么它的所有代换实例也都是良类型的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;类型推断&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-691c692ba80fac2d4b7d02741c0a3da2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;753&quot; data-rawheight=&quot;496&quot;&gt;&lt;p&gt;在类型上下文 &lt;equation&gt;\Gamma&lt;/equation&gt; 中，对于包含类型变量的项 &lt;equation&gt;t&lt;/equation&gt; ，我们通常会提出两个问题，&lt;/p&gt;&lt;p&gt;（1）它的所有代换实例，是否都是良类型的？&lt;br&gt;即，是否 &lt;equation&gt;\forall\sigma\exists T,\sigma\Gamma\vdash\sigma t:T&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;（2）是否存在良类型的代换实例？&lt;br&gt;即，是否 &lt;equation&gt;\exists\sigma\exists T,\sigma\Gamma\vdash\sigma t:T&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;对于第一个问题，将引出&lt;b&gt;参数化多态&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Parametric_polymorphism&quot;&gt;parametric polymorphism&lt;/a&gt;），&lt;br&gt;例如， &lt;equation&gt;\lambda f:X\to X.\lambda a:X.f(f(a))&lt;/equation&gt; ，它的类型为 &lt;equation&gt;(X\to X)\to X\to X&lt;/equation&gt; ，&lt;br&gt;无论用什么具体类型 &lt;equation&gt;T&lt;/equation&gt; 来代换 &lt;equation&gt;X&lt;/equation&gt; ，代换实例都是良类型的。&lt;/p&gt;&lt;p&gt;对于第二个问题，原始的项可能不是良类型的，&lt;br&gt;但是可以选择合适的类型代换使之实例化为良类型的项。&lt;/p&gt;&lt;p&gt;例如， &lt;equation&gt;\lambda f:Y.\lambda a:X.f(f(a))&lt;/equation&gt; ，是不可类型化的，&lt;br&gt;但是如果用 &lt;equation&gt;Nat\to Nat&lt;/equation&gt; 代换 &lt;equation&gt;Y&lt;/equation&gt; ，用 &lt;equation&gt;Nat&lt;/equation&gt; 代换 &lt;equation&gt;X&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;\sigma=[X\mapsto Nat,Y\mapsto Nat\to Nat]&lt;/equation&gt; ，&lt;br&gt;就可以得到， &lt;equation&gt;\lambda f:Nat\to Nat.\lambda a:Nat.f(f(a))&lt;/equation&gt; ，&lt;br&gt;可类型化为 &lt;equation&gt;(Nat\to Nat)\to Nat\to Nat&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;或者，取 &lt;equation&gt;\sigma&#39;=[Y\mapsto X\to X]&lt;/equation&gt; ，结果也能得到一个良类型的项，尽管仍包含变量。&lt;/p&gt;&lt;p&gt;在寻找类型变量有效实例的过程中，出现了&lt;b&gt;类型推断&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Type_inference&quot;&gt;type inference&lt;/a&gt;）的概念。&lt;br&gt;意味着由编译器来帮助推断 &lt;equation&gt;\lambda&lt;/equation&gt; 项的具体类型，&lt;br&gt;在&lt;a href=&quot;https://en.wikipedia.org/wiki/ML_(programming_language)&quot;&gt;ML&lt;/a&gt;语言中，程序员可以忽略所有的类型注释——隐式类型（&lt;a href=&quot;http://wiki.c2.com/?ImplicitTyping&quot;&gt;implicit typing&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;在进行推断的时候，对每一个原始的 &lt;equation&gt;\lambda&lt;/equation&gt; 抽象 &lt;equation&gt;\lambda x.t&lt;/equation&gt; ，&lt;br&gt;都用新的类型变量进行注释，写成 &lt;equation&gt;\lambda x:X.t&lt;/equation&gt; ，&lt;br&gt;然后采取特定的类型推导算法，找到使项通过类型检查的一个最一般化的解。&lt;/p&gt;&lt;p&gt;设 &lt;equation&gt;\Gamma&lt;/equation&gt; 为类型上下文， &lt;equation&gt;t&lt;/equation&gt; 为项，&lt;br&gt; &lt;equation&gt;(\Gamma,t)&lt;/equation&gt; 的&lt;b&gt;解&lt;/b&gt;，是指这样的一个序对 &lt;equation&gt;(\sigma,T)&lt;/equation&gt; ，使得 &lt;equation&gt;\sigma\Gamma\vdash\sigma t:T&lt;/equation&gt; 成立。&lt;/p&gt;&lt;p&gt;例如，设 &lt;equation&gt;\Gamma=f:X,a:Y&lt;/equation&gt; ， &lt;equation&gt;t=f~a&lt;/equation&gt; ，则&lt;br&gt; &lt;equation&gt;(\sigma=[X\mapsto Y\to Nat],Nat)&lt;/equation&gt; ， &lt;equation&gt;(\sigma=[X\mapsto Y\to Z],Z)&lt;/equation&gt; ，都是 &lt;equation&gt;(\Gamma,t)&lt;/equation&gt; 的解。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;基于约束的类型化&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-281fd8e3781690168c07b31e22bc9325_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;333&quot; data-rawheight=&quot;109&quot;&gt;&lt;p&gt;&lt;b&gt;（1）约束集&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在实际情况中， &lt;equation&gt;(\Gamma,t)&lt;/equation&gt; 的解，并不一定满足其他类型表达式的约束条件，&lt;br&gt;所以，我们寻找的是满足这些约束条件的特解。&lt;/p&gt;&lt;p&gt;所谓&lt;b&gt;约束条件&lt;/b&gt;，实际上指的是约束集 &lt;equation&gt;C&lt;/equation&gt; ，&lt;br&gt;它由一些包含类型参量的项的等式构成， &lt;equation&gt;\{S_i=T_i|i\in l..n\}&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果一个代换 &lt;equation&gt;\sigma&lt;/equation&gt; 的代换实例， &lt;equation&gt;\sigma S&lt;/equation&gt; 和 &lt;equation&gt;\sigma T&lt;/equation&gt; 相同，则称该代换&lt;b&gt;合一&lt;/b&gt;（unify）了等式 &lt;equation&gt;S=T&lt;/equation&gt; 。&lt;br&gt;如果 &lt;equation&gt;\sigma&lt;/equation&gt; 能合一 &lt;equation&gt;C&lt;/equation&gt; 中的所有等式，则称 &lt;equation&gt;\sigma&lt;/equation&gt; 能&lt;b&gt;合一&lt;/b&gt;（unify）或满足（satisfy） &lt;equation&gt;C&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们用 &lt;equation&gt;\Gamma\vdash t:T|_\chi C&lt;/equation&gt; ，来表示约束集 &lt;equation&gt;C&lt;/equation&gt; 满足时，项 &lt;equation&gt;t&lt;/equation&gt; 在 &lt;equation&gt;\Gamma&lt;/equation&gt; 下的类型为 &lt;equation&gt;T&lt;/equation&gt; ，&lt;br&gt;其中 &lt;equation&gt;\chi&lt;/equation&gt; 为约束集中，所有类型变量的集合，有时为了讨论方便可以省略它。&lt;/p&gt;&lt;p&gt;例如，对于项 &lt;equation&gt;t=\lambda x:X\to Y.x~0&lt;/equation&gt; ，&lt;br&gt;约束集可以写为 &lt;equation&gt;\{Nat\to Z=X\to Y\}&lt;/equation&gt; ，则 &lt;equation&gt;t&lt;/equation&gt; 类型为 &lt;equation&gt;(X\to Y)\to Z&lt;/equation&gt; 。（算法略）&lt;br&gt;而代换 &lt;equation&gt;\sigma=[X\mapsto Nat,Z\mapsto Bool,Y\mapsto Bool]&lt;/equation&gt; ，使得等式 &lt;equation&gt;Nat\to Z=X\to Y&lt;/equation&gt; 成立，&lt;br&gt;所以，我们推断出了 &lt;equation&gt;(Nat\to Bool)\to Bool&lt;/equation&gt; 是项 &lt;equation&gt;t&lt;/equation&gt; 的一个可能类型。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）约束集的解&lt;/b&gt;&lt;/p&gt;&lt;p&gt;约束集的解一般不是唯一的，所以一个关键问题是如何确定一个“最好”的解。&lt;/p&gt;&lt;p&gt;我们称代换 &lt;equation&gt;\sigma&lt;/equation&gt; 比 &lt;equation&gt;\sigma&#39;&lt;/equation&gt; &lt;b&gt;更具一般性&lt;/b&gt;（more general），如果 &lt;equation&gt;\sigma&#39;=\gamma\circ\sigma&lt;/equation&gt; ，记为 &lt;equation&gt;\sigma\sqsubseteq\sigma&#39;&lt;/equation&gt; ，&lt;br&gt;其中， &lt;equation&gt;\gamma&lt;/equation&gt; 为一个代换， &lt;equation&gt;\gamma\circ\sigma&lt;/equation&gt; 表示代换的复合， &lt;equation&gt;(\gamma\circ\sigma)S=\gamma(\sigma S)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;约束集 &lt;equation&gt;C&lt;/equation&gt; 的&lt;b&gt;主合一子&lt;/b&gt;（principal unifier）指的是代换 &lt;equation&gt;\sigma&lt;/equation&gt; ，&lt;br&gt;它能满足 &lt;equation&gt;C&lt;/equation&gt; ，且对于所有满足 &lt;equation&gt;C&lt;/equation&gt; 的代换 &lt;equation&gt;\sigma&#39;&lt;/equation&gt; ，都有 &lt;equation&gt;\sigma\sqsubseteq\sigma&#39;&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;(\Gamma,t,S,C)&lt;/equation&gt; 的解 &lt;equation&gt;(\sigma,T)&lt;/equation&gt; ，对于任何其他解 &lt;equation&gt;(\sigma&#39;,T&#39;)&lt;/equation&gt; ，都有 &lt;equation&gt;\sigma\sqsubseteq\sigma&#39;&lt;/equation&gt; ，&lt;br&gt;则称 &lt;equation&gt;(\sigma,T)&lt;/equation&gt; 是一个&lt;b&gt;主解&lt;/b&gt;（principal solution），称 &lt;equation&gt;T&lt;/equation&gt;  为 &lt;equation&gt;t&lt;/equation&gt; 的&lt;b&gt;主类型&lt;/b&gt;（principal type）。&lt;br&gt;可以证明，如果 &lt;equation&gt;(\Gamma,t,S,C)&lt;/equation&gt; 有解，则它必有一个主解。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;let多态&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-98db611b8facd70dd4be4eebdc7e1212_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;633&quot; data-rawheight=&quot;357&quot;&gt;&lt;p&gt;&lt;b&gt;多态&lt;/b&gt;（polymorphism）指的是单独一段程序能在不同的上下文中实例化为不同的类型。&lt;br&gt;其中let多态，是由let表达式引入的多态性。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（1）单态性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;假设我们定义了一个 &lt;equation&gt;double&lt;/equation&gt; 函数，它能将一个函数对参数应用两次，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:Nat\to Nat.\lambda a:Nat.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~double~(\lambda x:Nat.succ~x)~1&lt;/equation&gt; &lt;br&gt;此时， &lt;equation&gt;double&lt;/equation&gt; 的类型为 &lt;equation&gt;(Nat\to Nat)\to Nat\to Nat&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;如果我们想将 &lt;equation&gt;double&lt;/equation&gt; 应用于其他类型，就必须重写一个新的 &lt;equation&gt;double&#39;&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;let~double&#39;=\lambda f:Bool\to Bool.\lambda a:Bool.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~double&#39;~(\lambda x:Bool.x)~true&lt;/equation&gt; &lt;br&gt;此时 &lt;equation&gt;double&#39;&lt;/equation&gt; 的类型为 &lt;equation&gt;(Bool\to Bool)\to Bool\to Bool&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们不能让一个 &lt;equation&gt;double&lt;/equation&gt; 函数，既能用于 &lt;equation&gt;Nat&lt;/equation&gt; 类型，又能用于 &lt;equation&gt;Bool&lt;/equation&gt; 类型。&lt;br&gt;即使在 &lt;equation&gt;double&lt;/equation&gt; 中用类型变量也没有用，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in~\cdots&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;例如，如果写，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~let~a=double~(\lambda x:Nat.succ~x)~1~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~~~~~let~b=double~(\lambda x:Bool.x)~true~in~\cdots&lt;/equation&gt; &lt;br&gt;则在 &lt;equation&gt;a&lt;/equation&gt; 定义中使用 &lt;equation&gt;double&lt;/equation&gt; ，会产生一个约束 &lt;equation&gt;X\to X=Nat\to Nat&lt;/equation&gt; ，&lt;br&gt;而在 &lt;equation&gt;b&lt;/equation&gt; 定义中使用 &lt;equation&gt;double&lt;/equation&gt; ，则会产生约束 &lt;equation&gt;X\to X=Bool\to Bool&lt;/equation&gt; ，&lt;br&gt;这样会使类型变量 &lt;equation&gt;X&lt;/equation&gt; 的求解发生矛盾，导致整个程序不可类型化。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）多态性&lt;/b&gt;&lt;/p&gt;&lt;p&gt;let多态所做的事情，就是打破这个限制，&lt;br&gt;让类型参量 &lt;equation&gt;X&lt;/equation&gt; 在上述不同的上下文中，可以分别实例化为 &lt;equation&gt;Nat&lt;/equation&gt; 和 &lt;equation&gt;Bool&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;这需要改变与let表达式相关的类型推导规则，在第七篇中，我们提到过，&lt;br&gt; &lt;equation&gt;\frac{\Gamma\vdash t_1:T_1~~~~\Gamma,x:T_1\vdash t_2:T_2}{\Gamma\vdash let~x:T_1=t_1~in~t_2:T_2}&lt;/equation&gt; &lt;br&gt;它会首先计算 &lt;equation&gt;T_1&lt;/equation&gt; 作为 &lt;equation&gt;x&lt;/equation&gt; 的类型，然后再用 &lt;equation&gt;x&lt;/equation&gt; 来确定 &lt;equation&gt;T_2&lt;/equation&gt; 的类型。&lt;br&gt;此时，let表达式 &lt;equation&gt;let~x=t_1:T_1~in~t_2&lt;/equation&gt; ，可以看做 &lt;equation&gt;(\lambda x:T_1.t_2)t_1&lt;/equation&gt; 的简写。&lt;/p&gt;&lt;p&gt;为了引入多态性，我们需要对上述类型推导规则进行修改，&lt;br&gt; &lt;equation&gt;\frac{\Gamma\vdash[x\mapsto t_1]t_2:T_2}{\Gamma\vdash let~x=t_1~in~t_2:T_2}&lt;/equation&gt; &lt;br&gt;它表示，先将 &lt;equation&gt;t_2&lt;/equation&gt; 中的 &lt;equation&gt;x&lt;/equation&gt; 用 &lt;equation&gt;t_1&lt;/equation&gt; 代换掉，然后再确定 &lt;equation&gt;t_2&lt;/equation&gt; 的类型。&lt;/p&gt;&lt;p&gt;这样的话，&lt;br&gt; &lt;equation&gt;let~double=\lambda f:X\to X.\lambda a:X.f(f(a))~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~let~a=double~(\lambda x:Nat.succ~x)~1~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~~~~~let~b=double~(\lambda x:Bool.x)~true~in~\cdots&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;就相当于，&lt;br&gt; &lt;equation&gt;let~a=\lambda f:X\to X.\lambda a:X.f(f(a))~(\lambda x:Nat.succ~x)~1~in&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~let~b=\lambda f:Y\to Y.\lambda a:Y.f(f(a))~(\lambda x:Bool.x)~true~in~\cdots&lt;/equation&gt; &lt;br&gt;通过let多态，产生了 &lt;equation&gt;double&lt;/equation&gt; 的两个&lt;b&gt;副本&lt;/b&gt;，并为之分配了不同的类型参量。&lt;/p&gt;&lt;p&gt;此时，let表达式 &lt;equation&gt;let~x=t_1~in~t_2&lt;/equation&gt; ，可以看做 &lt;equation&gt;[x\mapsto t_1]t_2&lt;/equation&gt; 的简写。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Let-polymorphism&quot;&gt;Hindley–Milner type system&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1761910/&quot;&gt;Types and programming languages&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.haskell.org/definition/haskell2010.pdf&quot;&gt;Haskell 2010 Language Report&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-26-34915143</guid>
<pubDate>Mon, 26 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（八）：Subtype</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-25-34887359.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34887359&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ef77da94879248acb923dc4d037b5b31_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;900&quot; data-rawheight=&quot;554&quot;&gt;&lt;h2&gt;&lt;b&gt;对象和类&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;子类型几乎是面向对象编程语言所特有的，&lt;br&gt;在面向对象的编程语言中，计算是由&lt;b&gt;对象和对象之间消息传递&lt;/b&gt;来完成的，&lt;br&gt;对象（object）通常包含两个组成部分，数据（data）和代码（method）。&lt;/p&gt;&lt;p&gt;其中数据（data）一般是可变的，由每个对象所专有，通常称之为&lt;b&gt;对象的状态&lt;/b&gt;（state）。&lt;br&gt;代码（method）通常是不可变的。&lt;/p&gt;&lt;p&gt;大部分面向对象的编程语言是基于类（class）的，但类（class）却并不是必须的，&lt;br&gt;一个支持&lt;b&gt;词法作用域&lt;/b&gt;的编程语言中，&lt;b&gt;闭包&lt;/b&gt;（closure）就是包含内部状态的对象（object）。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;; let over lambda
(define counter
    (let ((n 0)) 
        (lambda () (set! n (+ n 1)) n)))
(counter)    ; 1
(counter)    ; 2&lt;/code&gt;&lt;p&gt;类（class）实际上可以看做一个工厂函数，用来生成对象。&lt;/p&gt;&lt;code lang=&quot;racket&quot;&gt;; lambda over let over lambda
(define create-counter
    (lambda () 
        (let ((n 0)) 
            (lambda () (set! n (+ n 1)) n))))
(define counter 
    (create-counter))
(counter)    ; 1
(counter)    ; 2&lt;/code&gt;&lt;h2&gt;&lt;b&gt;类型和类&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-695c87c5b9dd61927f549375f2286d3d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;463&quot; data-rawheight=&quot;180&quot;&gt;&lt;p&gt;类型（type）是与类（class）不同的概念。&lt;br&gt;对象所属的类（class）是它的工厂函数，&lt;br&gt;而对象的类型（type），是它在形式系统中，所具有的逻辑性质（logical property）。&lt;/p&gt;&lt;p&gt;子类（subclass），通过编写与父类之间的差别，创建一个新类，目的是&lt;b&gt;代码复用&lt;/b&gt;。&lt;/p&gt;&lt;blockquote&gt;A subclass is a differential description of a class.&lt;/blockquote&gt;&lt;p&gt;包含子类（subclass）之后，众多类（class）之间，&lt;br&gt;构成一个&lt;b&gt;前序关系&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Preorder&quot;&gt;preorder&lt;/a&gt;）（自反，传递）。&lt;/p&gt;&lt;p&gt;而引入子类型（subtype）是为了放宽类型系统的约束条件。&lt;br&gt;例如， &lt;equation&gt;(\lambda r:\{x:Nat\}.~r.x)~\{x=0,y=1\}&lt;/equation&gt; &lt;br&gt;其中， &lt;equation&gt;r&lt;/equation&gt; 的类型为 &lt;equation&gt;\{x:Nat\}&lt;/equation&gt; ，表示&lt;b&gt;记录类型&lt;/b&gt;（record）。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\{x=0,y=1\}&lt;/equation&gt; 的类型为 &lt;equation&gt;\{x:Nat,y:Nat\}&lt;/equation&gt; ，与 &lt;equation&gt;r&lt;/equation&gt; 的类型不同，&lt;br&gt;根据推导规则， &lt;equation&gt;\frac{\Gamma\vdash t_1:T_1\to T_2~~~~\Gamma\vdash t_2:T_1}{\Gamma\vdash t_1~t_2:T_2}&lt;/equation&gt; ，&lt;br&gt; &lt;equation&gt;(\lambda r:\{x:Nat\}.~r.x)~\{x=0,y=1\}&lt;/equation&gt; 将无法通过类型检查。&lt;/p&gt;&lt;p&gt;可是，函数中确实只用到了 &lt;equation&gt;r.x&lt;/equation&gt; ，多传一个 &lt;equation&gt;y&lt;/equation&gt; 理应总是安全的。&lt;br&gt;因此，不带子类型的简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算，它的推导规则就显得过于严谨了。&lt;/p&gt;&lt;p&gt;我们可以引入记录类型（record）之间的&lt;b&gt;子类型关系&lt;/b&gt;，记为，&lt;br&gt; &lt;equation&gt;\{x:Nat,y:Nat\}&amp;lt;:\{x:Nat\}&lt;/equation&gt; &lt;br&gt;用于表示类型 &lt;equation&gt;\{x:Nat,y:Nat\}&lt;/equation&gt; 是 &lt;equation&gt;\{x:Nat\}&lt;/equation&gt; 的子类型。&lt;/p&gt;&lt;p&gt;对于记录类型来说，这里可能有些奇怪，因为更“小”的类型却包含更多的字段。&lt;/p&gt;&lt;p&gt;一般的， &lt;equation&gt;S&amp;lt;:T&lt;/equation&gt; 表示 &lt;equation&gt;S&lt;/equation&gt; 为 &lt;equation&gt;T&lt;/equation&gt; 的&lt;b&gt;子类型&lt;/b&gt;，&lt;br&gt;如果在某个上下文中，期待一个 &lt;equation&gt;T&lt;/equation&gt; 类型的项，那么 &lt;equation&gt;S&lt;/equation&gt; 在这个上下文中也是合法的，&lt;br&gt;即， &lt;equation&gt;\frac{\Gamma\vdash t:S~~~~S&amp;lt;:T}{\Gamma\vdash t:T}&lt;/equation&gt; ，该推导规则，通常称之为&lt;b&gt;安全替换原则&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;为了能够安全替换，子类型应该具有&lt;b&gt;自反性&lt;/b&gt;： &lt;equation&gt;S&amp;lt;:S&lt;/equation&gt; ，&lt;br&gt;还应该具有&lt;b&gt;传递性&lt;/b&gt;， &lt;equation&gt;\frac{S&amp;lt;:U~~~~U&amp;lt;:T}{S&amp;lt;:T}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Top类型与Bottom类型&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7bdba08bbfb0afbb007f92fcc302e575_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;596&quot; data-rawheight=&quot;436&quot;&gt;&lt;p&gt;&lt;b&gt;（1）Top类型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;理解了子类型之后，我们就可以引入一个新的类型常量 &lt;equation&gt;Top&lt;/equation&gt; ，称为&lt;b&gt;Top类型&lt;/b&gt;。&lt;br&gt;所有其它类型都是它的子类型， &lt;equation&gt;S&amp;lt;:Top&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;因为具有自反性和传递性，子类型之间构成了一个&lt;b&gt;前序关系&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Preorder&quot;&gt;preorder&lt;/a&gt;），&lt;br&gt;由于记录类型中的字段，顺序是可以置换的，&lt;br&gt; &lt;equation&gt;\{x:Nat,y:Nat\}&lt;/equation&gt; 和 &lt;equation&gt;\{y:Nat,x:Nat\}&lt;/equation&gt; 分别为另一个的子类型，&lt;br&gt;因此，子类型关系不是一个&lt;b&gt;偏序关系&lt;/b&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Partially_ordered_set#Formal_definition&quot;&gt;partial order&lt;/a&gt;）（自反，传递，反对称）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;（2）Bottom类型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;除了Top类型之外，我们很自然的会问，&lt;br&gt;是否存在一个类型，它是所有其他类型的子类型，&lt;br&gt;为此，我们需要对类型系统再扩展，引入 &lt;equation&gt;Bot&lt;/equation&gt; 类型常量，称为&lt;b&gt;Bottom类型&lt;/b&gt;，&lt;br&gt;满足 &lt;equation&gt;Bot&amp;lt;:T&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;Bot&lt;/equation&gt; 类型中是不能有&lt;b&gt;闭值&lt;/b&gt;的，否则，假设 &lt;equation&gt;v&lt;/equation&gt; 是 &lt;equation&gt;Bot&lt;/equation&gt; 类型的一个值，&lt;br&gt;则根据安全替换原则有 &lt;equation&gt;v:Top\to Top&lt;/equation&gt; ，表明 &lt;equation&gt;v&lt;/equation&gt; 是一个函数，&lt;br&gt;此外还有 &lt;equation&gt;v:\{\}&lt;/equation&gt; ，表明 &lt;equation&gt;v&lt;/equation&gt; 是一个记录，&lt;br&gt;但是 &lt;equation&gt;v&lt;/equation&gt; 作为一个值，不可能既是函数又是记录，矛盾。&lt;/p&gt;&lt;p&gt;我们在第六篇中提到过，所谓&lt;b&gt;封闭&lt;/b&gt;，指的是不含自由变量。&lt;br&gt;所谓&lt;b&gt;值&lt;/b&gt;，就是事先约定好的&lt;b&gt;项的子集&lt;/b&gt;。&lt;br&gt;值都是&lt;b&gt;范式&lt;/b&gt;，没有求值规则可被继续使用，是对&lt;b&gt;项&lt;/b&gt;求值的最终结果。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;Bot&lt;/equation&gt; 类型中虽然不能有闭值，&lt;br&gt;但是却可以包含&lt;b&gt;受阻项&lt;/b&gt;，即事先约定好的&lt;b&gt;不是值的范式&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;例如，我们可以指定 &lt;equation&gt;error&lt;/equation&gt; 是一个受阻项（不给它指定求值规则），&lt;br&gt;再指定它为&lt;b&gt;Bottom类型&lt;/b&gt;， &lt;equation&gt;error:Bot&lt;/equation&gt; 。&lt;br&gt;这样 &lt;equation&gt;error&lt;/equation&gt; 就可以在不同的上下文中，被提升为不同的类型了。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\lambda x:T.&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~if ... then&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~~~~~result&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~else&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;~~~~~~~~error&lt;/equation&gt;&lt;br&gt;以上 &lt;equation&gt;\lambda&lt;/equation&gt; 项是良类型的（well typed），无论 &lt;equation&gt;result&lt;/equation&gt; 是何种类型。&lt;/p&gt;&lt;p&gt;关于Top类型和Bottom类型，我们最后再看一个例子，&lt;br&gt;&lt;a href=&quot;https://www.typescriptlang.org/index.html&quot;&gt;TypeScript&lt;/a&gt;中的&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/basic-types.html#any&quot;&gt;any&lt;/a&gt;类型，是一个Top类型，&lt;br&gt;而&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/basic-types.html#never&quot;&gt;never&lt;/a&gt;类型，是一个Bottom类型。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文为简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算添加了子类型，&lt;br&gt;并且对比了类（class）与类型（type）这两个概念。&lt;/p&gt;&lt;p&gt;lambda calculus是函数式编程语言的计算模型，&lt;br&gt;前几篇，我们保持基本的演算系统（求值规则）不变，&lt;br&gt;给它添加了不同的类型推导规则，得到了不同的类型系统。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.nada.kth.se/~karlm/ooteori/ObjectCalculus.pdf&quot;&gt;object calculus&lt;/a&gt;是面向对象语言的计算模型，&lt;br&gt;在它之上，我们同样可以添加相似的类型系统。&lt;/p&gt;&lt;p&gt;因此，类型系统是与演算（calculus）独立的概念。&lt;br&gt;这印证了我们之前在第一篇中提到的一句话，&lt;br&gt;类型系统，可以看做是附着在语言语法之上的一套符号证明系统。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/3864436/&quot;&gt;Let Over Lambda&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1761910/&quot;&gt;Types and programming languages&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://lucacardelli.name/Talks/1997-06%20A%20Theory%20of%20Object%20(LICS).pdf&quot;&gt;A Theory of Objects&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-25-34887359</guid>
<pubDate>Sun, 25 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（七）：Recursive type</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-24-34861374.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34861374&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-052f4243204bd6731d6fe46e0070730e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;380&quot;&gt;&lt;p&gt;上文我们介绍了简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统 &lt;equation&gt;\lambda^\to&lt;/equation&gt; ，并给它扩充了单位类型，&lt;br&gt;本文继续为它添加新的特性。&lt;/p&gt;&lt;p&gt;我们将提到&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;letrec&lt;/code&gt;表达式，函数的不动点，&lt;br&gt;代数数据类型，以及递归类型。&lt;/p&gt;&lt;p&gt;最后我们发现，无类型系统实际上是具有，唯一递归类型的一种情形。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;let绑定&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当写一个复杂表达式的时候，为了避免重复和增加可读性，&lt;br&gt;通常我们会给某些子表达式命名，其中一个常用办法是，使用&lt;b&gt;&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;表达式&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;为此，我们要对简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 进行扩展，&lt;br&gt;添加&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;表达式的语法项，求值规则以及类型规则。&lt;/p&gt;&lt;p&gt;&lt;b&gt;新的语法：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;equation&gt;t::=...|let~x:T=t~in~t&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;新的求值规则：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;equation&gt;let~x:T=v~in~t\to [x\mapsto v]t&lt;/equation&gt; &lt;br&gt;&lt;equation&gt;\frac{t_1\to t&#39;_1}{let~x:T_1=t_1~in~t_2\to let~x:T_1=t&#39;_1~in~t_2}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;新的类型规则：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\frac{\Gamma\vdash t_1:T_1~~~~\Gamma,x:T_1\vdash t_2:T_2}{\Gamma\vdash let~x:T_1=t_1~in~t_2:T_2}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这样我们就可以写出&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;表达式了， &lt;equation&gt;let~x:T_1=t_1~in~t_2&lt;/equation&gt; ，&lt;br&gt;它表示，求值表达式 &lt;equation&gt;t_1&lt;/equation&gt; ，然后将其绑定到 &lt;equation&gt;t_2&lt;/equation&gt; 中自由出现的 &lt;equation&gt;x&lt;/equation&gt; 上面，&lt;br&gt;即在当前这种情况下（顾及&lt;a href=&quot;https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Let-polymorphism&quot;&gt;let polymorphism&lt;/a&gt;），&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;可以表示为， &lt;equation&gt;(\lambda x:T_1.t_2)t_1&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;不动点&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6cfcb32e2362408c47cd0d6629e1f93f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;264&quot; data-rawheight=&quot;191&quot;&gt;&lt;p&gt;以上&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;表达式， &lt;equation&gt;let~x:T_1=t_1~in~t_2&lt;/equation&gt; ，&lt;br&gt;对 &lt;equation&gt;t_1&lt;/equation&gt; 求值的时候有一个限制，那就是 &lt;equation&gt;t_1&lt;/equation&gt; 中不能出现 &lt;equation&gt;x&lt;/equation&gt; ，&lt;br&gt;否则就像方程一样， &lt;equation&gt;x&lt;/equation&gt; 出现在了等式的两边， &lt;equation&gt;x=t_1(x)&lt;/equation&gt; ，&lt;br&gt;此时， &lt;equation&gt;t_2&lt;/equation&gt; 中自由出现的 &lt;equation&gt;x&lt;/equation&gt; ，将是这个方程的解。&lt;/p&gt;&lt;p&gt;不过，通常而言， &lt;equation&gt;t_1&lt;/equation&gt; 中是可以出现 &lt;equation&gt;x&lt;/equation&gt; 的，这时候我们就需要使用&lt;code class=&quot;inline&quot;&gt;letrec&lt;/code&gt;进行绑定了。&lt;/p&gt;&lt;p&gt;为了看清&lt;code class=&quot;inline&quot;&gt;letrec&lt;/code&gt;的真面目，我们用一个求阶乘的例子来说明问题，&lt;br&gt; &lt;equation&gt;letrec~f:nat\to nat=\lambda y:nat.(if~Eq?~y~0~then~1~else~y*f(y-1))~in~f~5&lt;/equation&gt; &lt;br&gt;其中， &lt;equation&gt;nat&lt;/equation&gt; 表示整数类型。&lt;/p&gt;&lt;p&gt;为了求解 &lt;equation&gt;f=\lambda y:nat.(if~Eq?~y~0~then~1~else~y*f(y-1))&lt;/equation&gt; ，&lt;br&gt;我们定义一个新函数 &lt;equation&gt;F&lt;/equation&gt; ，使得，&lt;br&gt; &lt;equation&gt;F=\lambda f:nat\to nat.\lambda y:nat.(if~Eq?~y~0~then~1~else~y*f(y-1))&lt;/equation&gt; ，&lt;br&gt;注意到 &lt;equation&gt;f=F(f)&lt;/equation&gt; ，所以 &lt;equation&gt;f&lt;/equation&gt; 是 &lt;equation&gt;F&lt;/equation&gt; 的&lt;b&gt;不动点&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;这里我们暂且不讨论不动点的存在性和唯一性问题，&lt;br&gt;只是引入一个不动点算子， &lt;equation&gt;fix_\sigma:(\sigma\to\sigma)\to\sigma&lt;/equation&gt; ，&lt;br&gt;它可以用来计算任意函数 &lt;equation&gt;F:\sigma\to\sigma&lt;/equation&gt; 的不动点。&lt;/p&gt;&lt;p&gt;为了达到这个目的， &lt;equation&gt;fix_\sigma&lt;/equation&gt; 必须满足以下约束条件， &lt;equation&gt;fix_\sigma=\lambda f:\sigma\to\sigma.f(fix_\sigma f)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;引入了 &lt;equation&gt;fix_\sigma&lt;/equation&gt; 之后，&lt;code class=&quot;inline&quot;&gt;letrec&lt;/code&gt;就可以用&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;表示出来了，&lt;br&gt; &lt;equation&gt;letrec~f:\sigma=t_1~in~t_2\Leftrightarrow let~f:\sigma=(fix_\sigma\lambda f:\sigma.t_1)~in~t_2&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;&lt;b&gt;代数数据类型&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4f3fd841349e86357a6d5a48a4ef4187_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;220&quot; data-rawheight=&quot;129&quot;&gt;&lt;p&gt;在某些编程语言中，可以自定义递归类型，例如在Haskell中，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;data List a = Nil | Cons a (List a)
lst :: List Int 
lst = Cons 1 $ Cons 2 $ Nil&lt;/code&gt;&lt;p&gt;以上定义采用了递归的方式，定义了一个&lt;a href=&quot;https://wiki.haskell.org/Algebraic_data_type&quot;&gt;代数数据类型&lt;/a&gt;&lt;code class=&quot;inline&quot;&gt;List&lt;/code&gt;，&lt;br&gt;所谓代数数据类型，是由基本类型经过复合运算，得来的类型。&lt;/p&gt;&lt;p&gt;Haskell中，使用&lt;code class=&quot;inline&quot;&gt;|&lt;/code&gt;表示&lt;b&gt;和类型&lt;/b&gt;（sum type），&lt;br&gt;而带参数值构造器（value constructor）&lt;code class=&quot;inline&quot;&gt;Cons&lt;/code&gt;，&lt;br&gt;用于表示各参数（&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;List a&lt;/code&gt;）类型的&lt;b&gt;积类型&lt;/b&gt;（product type），&lt;br&gt;无参构造器&lt;code class=&quot;inline&quot;&gt;Nil&lt;/code&gt;，用来表示&lt;b&gt;单位乘积类型&lt;/b&gt;（empty product）。&lt;/p&gt;&lt;p&gt;（关于函数类型与指数的关系，以后有机会再介绍。）&lt;/p&gt;&lt;p&gt;和&lt;code class=&quot;inline&quot;&gt;letrec&lt;/code&gt;中的场景相似的是，&lt;code class=&quot;inline&quot;&gt;List&lt;/code&gt;也出现在了等式的两边，&lt;br&gt;于是，我们定义 &lt;equation&gt;\mu t.\sigma&lt;/equation&gt; ，表示满足等式 &lt;equation&gt;t=\sigma&lt;/equation&gt; 的最小类型，&lt;br&gt;其中， &lt;equation&gt;t&lt;/equation&gt; 和 &lt;equation&gt;\sigma&lt;/equation&gt; 是类型，且 &lt;equation&gt;t&lt;/equation&gt; 通常会在 &lt;equation&gt;\sigma&lt;/equation&gt; 中出现。&lt;/p&gt;&lt;p&gt;因此，以上递归定义的&lt;code class=&quot;inline&quot;&gt;List&lt;/code&gt;类型可以表示为， &lt;equation&gt;\mu\phi.\lambda\alpha.(1+\alpha\times(\phi~\alpha))&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中， &lt;equation&gt;\alpha&lt;/equation&gt; 表示类型参数&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，&lt;br&gt; &lt;equation&gt;\phi&lt;/equation&gt; 是一个函数，用于表示类型构造器（data constructor）&lt;code class=&quot;inline&quot;&gt;List&lt;/code&gt;，&lt;br&gt; &lt;equation&gt;\mu&lt;/equation&gt; 算子用来计算类型的不动点。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;无类型&lt;i&gt;λ&lt;/i&gt;演算&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-42709a95436618c777b3032e41fb6eff_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;337&quot; data-rawheight=&quot;76&quot;&gt;&lt;p&gt;在无类型 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 中，定义递归类型， &lt;equation&gt;\mu t.t\to t&lt;/equation&gt; ，它满足类型等式 &lt;equation&gt;t=t\to t&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;这样的话，无类型 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; ，就可以无缝的&lt;b&gt;嵌入到&lt;/b&gt;一个类型化的系统中去了，&lt;br&gt;该系统只存在一个类型，即递归类型 &lt;equation&gt;\mu t.t\to t&lt;/equation&gt; ，&lt;br&gt;所有的项，都具有这个类型。&lt;/p&gt;&lt;p&gt;因此，对于支持递归类型的系统而言，&lt;br&gt;无类型相当于具有唯一类型（&lt;b&gt;Untyped means uni-typed&lt;/b&gt;）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文介绍了递归类型，引入了两个算子 &lt;equation&gt;fix_\sigma&lt;/equation&gt; 和 &lt;equation&gt;\mu&lt;/equation&gt; ，分别用来求解函数和类型的不动点。&lt;br&gt;但是，待求的不动点是否存在，是否唯一，我们仍不能确定。&lt;/p&gt;&lt;p&gt;要想证明这件事情并不简单，需要补充很多额外的数学知识，&lt;br&gt;例如，良基归纳法和最小不动点定理，&lt;br&gt;此外，不动点的存在性，和递归的终止性也有关系。&lt;/p&gt;&lt;p&gt;好在我们所遇到的大多数场景，都是满足这些要求的，&lt;br&gt;因为，我们总是先确信这个解是存在的，然后再去编程，例如，&lt;/p&gt;&lt;code lang=&quot;haskell&quot;&gt;fact :: Int -&amp;gt; Int 
fact 1 = 1
fact n = n * fact (n - 1)&lt;/code&gt;&lt;p&gt;将&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;写到等式两边，能让我们更方便对&lt;code class=&quot;inline&quot;&gt;fact&lt;/code&gt;进行定义。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Algebraic_data_type&quot;&gt;Algebraic data type&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Empty_product&quot;&gt;Empty product&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1761918/&quot;&gt;Foundations for programmming languages&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/26782198/&quot;&gt;Practical Foundations for Programming Languages&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-24-34861374</guid>
<pubDate>Sat, 24 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>你好，类型（六）：Simply typed lambda calculus</title>
<link>https://henix.github.io/feeds/zhuanlan.self-discipline/2018-03-23-34815896.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34815896&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-36c3e68ae0c501adae575be51013b97e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;683&quot;&gt;&lt;p&gt;简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算（simply typed lambda calculus） &lt;equation&gt;\lambda^\to&lt;/equation&gt; ，是无类型 &lt;equation&gt;\lambda&lt;/equation&gt; 演算的类型化版本，&lt;br&gt;它是众多类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算中最简单的一个。&lt;/p&gt;&lt;p&gt;它只包含一个类型构造器（type constructor） &lt;equation&gt;\to&lt;/equation&gt; ，&lt;br&gt;即，接受两个类型 &lt;equation&gt;T_1,T_2&lt;/equation&gt; 作为参数，返回一个函数类型 &lt;equation&gt;T_1\to T_2&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;下文中，我们首先从最基础的概念说起，详细的区分&lt;b&gt;项&lt;/b&gt;（term）和&lt;b&gt;值&lt;/b&gt;（value）的概念，&lt;br&gt;然后介绍简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统的求值规则和类型规则。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;1. 项和值&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d545f73a2ab9958178ad019e84cc6162_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;620&quot; data-rawheight=&quot;330&quot;&gt;&lt;p&gt;&lt;b&gt;1.1 项&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;项&lt;/b&gt;（term）是一个语法概念，一个合法的项，指的是一段&lt;b&gt;符合语法&lt;/b&gt;的字符串。&lt;br&gt;例如，在 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 系统中，项的定义如下，&lt;br&gt; &lt;equation&gt;t::=x|\lambda x.t|t~t&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;它表明，一个合法的 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 项，要么是一个变量 &lt;equation&gt;x&lt;/equation&gt; ，&lt;br&gt;要么是一个 &lt;equation&gt;\lambda&lt;/equation&gt; &lt;b&gt;抽象&lt;/b&gt;（abstraction） &lt;equation&gt;\lambda x.t&lt;/equation&gt; ，要么是一个 &lt;equation&gt;\lambda&lt;/equation&gt; &lt;b&gt;应用&lt;/b&gt;（application） &lt;equation&gt;t~t&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.2 值&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;值&lt;/b&gt;（value）是一个和&lt;b&gt;语义&lt;/b&gt;相关的概念，有三种常用的方法为项指定语义。&lt;br&gt;（1）操作语义，通过定义一个简单的抽象机器，来说明一个程序语言的行为。&lt;br&gt;（2）指称语义，一个项的语义是一个数学对象。&lt;br&gt;（3）公理语义，不是首先定义程序的行为，而是用项所满足的规则限定它的语义。&lt;/p&gt;&lt;p&gt;下面我们采用操作语义的方法，来定义求值的概念。&lt;br&gt;首先，我们&lt;b&gt;人为指定项的一个子集&lt;/b&gt;，将其中的元素称为&lt;b&gt;值&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;假如项的定义如下， &lt;equation&gt;t::=true|false|if~t~then~t~else~t&lt;/equation&gt; ，&lt;br&gt;我们可以定义值， &lt;equation&gt;v::=true|false&lt;/equation&gt; 。&lt;br&gt;值可能是项被求值的最终结果，但也&lt;b&gt;不全是&lt;/b&gt;，因为对某些项的求值过程可能不会终止。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.3 求值规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;求值规则，是定义在项上的推导规则，例如，&lt;br&gt;（1） &lt;equation&gt;if~true~then~t_1~else~t_2\to t_1&lt;/equation&gt; ，&lt;br&gt;（2） &lt;equation&gt;if~false~then~t_1~else~t_2\to t_2&lt;/equation&gt; ，&lt;br&gt;（3） &lt;equation&gt;\frac{t_1\to t&#39;_1}{if~t_1~then~t_2~else~t_3\to if~t&#39;_1~then~t_2~else~t_3}&lt;/equation&gt; &lt;br&gt;其中， &lt;equation&gt;x\to y&lt;/equation&gt; 表示，项 &lt;equation&gt;x&lt;/equation&gt; 可以一步求值为项 &lt;equation&gt;y&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.4 范式&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一个不含自由变量的项，称为&lt;b&gt;封闭项&lt;/b&gt;，封闭项也称为&lt;b&gt;组合子&lt;/b&gt;。&lt;br&gt;例如，恒等函数 &lt;equation&gt;id=\lambda x.x&lt;/equation&gt; 就是一个封闭项。&lt;/p&gt;&lt;p&gt;如果没有求值规则可用于项 &lt;equation&gt;t&lt;/equation&gt; ，就称该项是一个&lt;b&gt;范式&lt;/b&gt;。&lt;br&gt;范式可能是一个值，也可能不是，但每一个值都应该是范式。&lt;/p&gt;&lt;p&gt;如果一个封闭项是一个范式，但不是一个值，就称该项&lt;b&gt;受阻&lt;/b&gt;。&lt;br&gt;不是值的范式，在运行时间错误分析中起着极其重要的作用。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;2. 类型&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e58cfc7a10ec61f71b2d4cc93530652e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;480&quot; data-rawheight=&quot;280&quot;&gt;&lt;p&gt;&lt;b&gt;2.1 类型上下文&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一个&lt;b&gt;类型上下文&lt;/b&gt;（也称&lt;b&gt;类型环境&lt;/b&gt;） &lt;equation&gt;\Gamma&lt;/equation&gt; ，是一个变量和类型之间绑定关系的集合。&lt;br&gt;空上下文，可以记为 &lt;equation&gt;\varnothing&lt;/equation&gt; ，但是我们经常省略它。&lt;/p&gt;&lt;p&gt;用逗号可以在 &lt;equation&gt;\Gamma&lt;/equation&gt; 右边加入一个新的&lt;b&gt;绑定&lt;/b&gt;，例如， &lt;equation&gt;\Gamma,x:T&lt;/equation&gt; 。&lt;br&gt; &lt;equation&gt;\vdash t:T&lt;/equation&gt; ，表示项 &lt;equation&gt;t&lt;/equation&gt; 在空的类型上下文中，有类型 &lt;equation&gt;T&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.1 类型规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\lambda^\to&lt;/equation&gt; 是一个新的系统，比起 &lt;equation&gt;\lambda_\beta&lt;/equation&gt; 而言，增加了一些基于类型的推导规则。&lt;/p&gt;&lt;p&gt;其中， &lt;equation&gt;\lambda^\to&lt;/equation&gt; 中 &lt;equation&gt;\lambda&lt;/equation&gt; 项的语法如下：&lt;br&gt;（1） &lt;equation&gt;t::=x|\lambda x:T.t|t~t&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;T::=T\to T&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;\Gamma::=\varnothing|\Gamma,x:T&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;推导规则：&lt;br&gt;（1） &lt;equation&gt;\frac{x:T\in\Gamma}{\Gamma\vdash x:T}&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\frac{\Gamma,x:T_1\vdash t:T_2}{\Gamma\vdash\lambda x:T_1.t:T_1\to T_2}&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;\frac{\Gamma\vdash t_1:T_1\to T_2~~~~\Gamma\vdash t_2:T_1}{\Gamma\vdash t_1~t_2:T_2}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;根据以上的推导规则，我们可以证明， &lt;equation&gt;\vdash(\lambda x:Bool.x)~true:Bool&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;b&gt;2.3 求值规则&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\lambda^\to&lt;/equation&gt; 系统中，值的定义如下：&lt;br&gt;（1） &lt;equation&gt;v::=\lambda x:T.t&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;求值规则，定义如下：&lt;br&gt;（1） &lt;equation&gt;\frac{t_1\to t&#39;_1}{t_1~t_2\to t&#39;_1~t_2}&lt;/equation&gt; &lt;br&gt;（2） &lt;equation&gt;\frac{t_2\to t&#39;_2}{t_1~t_2\to t_1~t&#39;_2}&lt;/equation&gt; &lt;br&gt;（3） &lt;equation&gt;(\lambda x:T.t)~v\to [x\mapsto v]t&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;其中（2），相当于 &lt;equation&gt;\beta&lt;/equation&gt; 变换，&lt;br&gt; &lt;equation&gt;[x\mapsto v]t&lt;/equation&gt; ，表示将 &lt;equation&gt;t&lt;/equation&gt; 中所有自由出现的 &lt;equation&gt;x&lt;/equation&gt; 换为 &lt;equation&gt;v&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.4 Curry-style and Church-style&lt;/b&gt;&lt;/p&gt;&lt;p&gt;对于 &lt;equation&gt;\lambda^\to&lt;/equation&gt; 系统来说，通常有两种不同风格的解释方式，&lt;br&gt;如果我们首先定义项，然后定义项的求值规则——语义，&lt;br&gt;最后再定义一个类型系统，用以排除掉我们不需要的项，&lt;br&gt;这种语义先于类型的定义方式，称为&lt;b&gt;Curry-style&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;另一方面，如果我们定义项，然后再给出良类型的定义，&lt;br&gt;最后再给出这些良类型项的语义，就称为&lt;b&gt;Church-style&lt;/b&gt;，类型先于语义，&lt;br&gt;在Church-style的系统中，我们不关心不良类型项的语义。&lt;/p&gt;&lt;p&gt;历史上，隐式类型的 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统，通常是Curry-style的，&lt;br&gt;而显式类型的 &lt;equation&gt;\lambda&lt;/equation&gt; 演算系统，通常是Church-style的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;3. 关于单位类型&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;简单类型化 &lt;equation&gt;\lambda&lt;/equation&gt; 演算，直接用起来可能并不好用，&lt;br&gt;人们会再为它扩充一些类型，例如，添加一些基本类型 &lt;equation&gt;Bool&lt;/equation&gt; ， &lt;equation&gt;Nat&lt;/equation&gt; 或者 &lt;equation&gt;String&lt;/equation&gt; ，&lt;br&gt;定义单位类型，列表类型，元组类型，和类型，等等。&lt;/p&gt;&lt;p&gt;下面我们选择&lt;b&gt;单位类型&lt;/b&gt;进行介绍。&lt;/p&gt;&lt;p&gt;满足单位类型的项只有一个，为此我们新增一个项的定义，&lt;br&gt; &lt;equation&gt;t::=...|unit&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;再新增一个类型的定义，&lt;br&gt; &lt;equation&gt;T::=Unit&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;以及一个推导规则，&lt;br&gt; &lt;equation&gt;\Gamma\vdash unit:Unit&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;Unit&lt;/equation&gt; 的作用类似于C和Java中的 &lt;equation&gt;void&lt;/equation&gt; 类型，主要用于表示副作用，&lt;br&gt;在这样的语言中，我们往往并不关心表达式的结果，而只关心它的副作用，&lt;br&gt;因此，用 &lt;equation&gt;Unit&lt;/equation&gt; 来表示结果的类型，是一个合适的选择。&lt;/p&gt;&lt;p&gt;这里提到单位类型，是为以后Top类型和Bot类型做铺垫。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus&quot;&gt;Wikipedia: Simply typed lambda calculus&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/1318672/&quot;&gt;类型和程序设计语言&lt;/a&gt;&lt;/p&gt;</description>
<author>何幻</author>
<guid isPermaLink="false">2018-03-23-34815896</guid>
<pubDate>Fri, 23 Mar 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
