<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>时光与精神小屋</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Tue, 04 Dec 2018 02:54:45 +0800</lastBuildDate>
<item>
<title>「付费阅读」如何为Rust语言做贡献</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-03-51479889.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51479889&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5d4a713aff10d99bf7e2d48b68018ce4_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;本文基于macOSX平台，通过对Rust 1.32 Nightly版本中rustdoc的一个ICE问题进行复盘，分析并记录整个Bug修复的过程。主要目的是，通过这个过程，来学习如何给Rust做贡献。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;（阅读时间：17m）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1. 缘起&lt;/p&gt;&lt;p&gt;2. Rust本地调试环境准备&lt;/p&gt;&lt;p&gt;3. ICE问题分析&lt;/p&gt;&lt;p&gt;4. 调试代码&lt;/p&gt;&lt;p&gt;5. 提交PR说明&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;---&lt;/p&gt;&lt;h2&gt;&lt;b&gt;缘起：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在两周前，我发现了一个rustdoc的[ICE(issue 55723)](&lt;a href=&quot;https://github.com/rust-lang/rust/issues/55723&quot;&gt;https://github.com/rust-lang/rust/issues/55723&lt;/a&gt;)，提交给了官方。但是官方指派修复此Bug的开发者QuietMisdreavus 难以复现该Bug。我本来以为Bug是因为多字节字符（比如全角符号之类）引起的，然而经过我仔细的测试，发现问题的根源在于尾随的「空格」。&lt;/p&gt;&lt;h2&gt;更多内容请花&lt;b&gt;一元查看&lt;/b&gt;：&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-233a6d659a6944c30a4d23a1cf8054aa_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;659&quot; data-rawheight=&quot;1920&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-233a6d659a6944c30a4d23a1cf8054aa&quot; data-watermark-src=&quot;v2-0a81c5365a61d19ca3a2bc04d60b2416&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-03-51479889</guid>
<pubDate>Mon, 03 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 3</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-03-51433417.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51433417&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;-  &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 3:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S {
    x: i32,
}

const S: S = S { x: 2 };

fn main() {
    let v = &amp;amp;mut S;
    v.x += 1;
    S.x += 1;
    print!(&quot;{}{}&quot;, v.x, S.x);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 32&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;考察要点： &lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;可变引用&lt;/li&gt;&lt;li&gt;结构体实例化不需要构造函数&lt;/li&gt;&lt;li&gt;const语义&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;代码中定义了一个具名结构体&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，包含了一个字段&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;。接下来又定义了一个&lt;code class=&quot;inline&quot;&gt;const&lt;/code&gt;常量，同样命名为&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，并且将一个结构体&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的实例赋值给它。&lt;/p&gt;&lt;p&gt;要注意区分这两个&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;。常量&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，是代表值，而结构体&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，则代表类型。在Rust中，分别将这两个S，存储在&lt;code class=&quot;inline&quot;&gt;值命名空间(Value NameSpace)&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;类型命名空间(Type NameSpace)&lt;/code&gt;中，所以可以同时存在两个相同的S。&lt;/p&gt;&lt;p&gt;常量S，会内联到用它的具体使用的地方。在语义层面，就是表示它的值会替换到使用它的每个地方。&lt;/p&gt;&lt;p&gt;&lt;b&gt;在main函数中， 常量S会被内联到两个地方：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;第一个地方&lt;/b&gt;是： &lt;code class=&quot;inline&quot;&gt;let v = &amp;amp;mut S;&lt;/code&gt;， 这里的S，是一个值，要被const S替换掉。等价于:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let mut _tmp = S {x: 2} ; 
let v = &amp;amp;mut tmp_;&lt;/code&gt;&lt;p&gt;所以，当执行 &lt;code class=&quot;inline&quot;&gt;v.x += 1&lt;/code&gt; 之后，&lt;code class=&quot;inline&quot;&gt;v.x&lt;/code&gt;的值就是：3。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第二个地方&lt;/b&gt;是：&lt;code class=&quot;inline&quot;&gt;S.x += 1;&lt;/code&gt;，这里的S同样会被替换为const S的值。等价于:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;S {x: 2}.x += 1;&lt;/code&gt;&lt;p&gt;而此时，这个S {: 2}是一个新的结构体实例，和上面的S已经无关，所以改变它的值，并不影响到&lt;code class=&quot;inline&quot;&gt;S.x&lt;/code&gt;的值，所以结果是: 2。&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-03-51433417</guid>
<pubDate>Mon, 03 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读： Quiz 2</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-02-51366804.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51366804&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;&lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 2:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S(i32);

impl std::ops::BitAnd&amp;lt;S&amp;gt; for () {
    type Output = ();

    fn bitand(self, rhs: S) {
        print!(&quot;{}&quot;, rhs.0);
    }
}

fn main() {
    let f = || ( () &amp;amp; S(1) );
    let g = || { () &amp;amp; S(2) };
    let h = || ( {} &amp;amp; S(3) );
    let i = || { {} &amp;amp; S(4) };
    f();
    g();
    h();
    i();
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果：123&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点： &lt;/p&gt;&lt;ol&gt;&lt;li&gt;trait：操作符重载&lt;/li&gt;&lt;li&gt;trait：关联类型&lt;/li&gt;&lt;li&gt;单元类型 ()&lt;/li&gt;&lt;li&gt;元组结构体&lt;/li&gt;&lt;li&gt;闭包使用圆括号和块的差异&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;代码中定义了元组结构体S(i32)，又为其实现了&lt;code class=&quot;inline&quot;&gt;std::ops::BitAdd&amp;lt;s&amp;gt;&lt;/code&gt; trait，意味着，该元组结构体就有了位运算&lt;code class=&quot;inline&quot;&gt;&amp;amp;&lt;/code&gt;的能力。&lt;/p&gt;&lt;p&gt;在实现BitAdd的代码中，指定了关联类型为单元类型&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;，在bitand方法中，省略了返回类型。等价于下面代码。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fn bitand(self, rhs: S) -&amp;gt; () { ... }&lt;/code&gt;&lt;p&gt;那么在main函数中：&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let f = || ( () &amp;amp; S(1) );&lt;/code&gt;  ， 这行代码中，f绑定的是一个闭包。闭包中&lt;code class=&quot;inline&quot;&gt;() &amp;amp; S(1)&lt;/code&gt;是一个位操作&lt;code class=&quot;inline&quot;&gt;&amp;amp;&lt;/code&gt;表达式。最终结果当然是输出&lt;code class=&quot;inline&quot;&gt;rhs.0&lt;/code&gt;，也就是：1。元组结构体和元组的用法是一样的。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let g = || { () &amp;amp; S(2) };&lt;/code&gt;， 这行代码中，g绑定的依然是一个闭包。闭包可以用圆括号，也可以用花括号。闭包内，&lt;code class=&quot;inline&quot;&gt;() &amp;amp; S(2)&lt;/code&gt;依然是一个完整的表达式，求值结果是：2。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let h = || ( {} &amp;amp; S(3) );&lt;/code&gt;，这行代码中，h同样是一个闭包，但注意这里闭包是用圆括号来表示，这代表，&lt;code class=&quot;inline&quot;&gt;{} &amp;amp; S(3)&lt;/code&gt;按一个完整独立的表达式来处理。其中&lt;code class=&quot;inline&quot;&gt;{}&lt;/code&gt;表达式求值结果是&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;，再和&lt;code class=&quot;inline&quot;&gt;S(3)&lt;/code&gt;进行与操作，得到最终值： 3。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let i = || { {} &amp;amp; S(4) };&lt;/code&gt;，这行代码中， i同样是一个闭包，然而，它是以花括号构成。花括号和圆括号的区别在于，花括号代表一个块（block），它默认按多条表达式语句进行解析。所以，&lt;code class=&quot;inline&quot;&gt;{} &amp;amp; S(4)&lt;/code&gt;，实际上被看作两条语句&lt;code class=&quot;inline&quot;&gt;{}&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&amp;amp;S(4)&lt;/code&gt;，最终闭包执行结果是返回一个&lt;code class=&quot;inline&quot;&gt;S(4)&lt;/code&gt;的引用。和位操作没有啥关系，最终也没有任何输出结果。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;{}&lt;/code&gt;的区别，不仅仅在于闭包，在写声明宏或者其他地方都是一致的。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/2&quot;&gt;点此查看 Rust Quiz 2 &lt;/a&gt; &lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-02-51366804</guid>
<pubDate>Sun, 02 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「Rust每日新闻」本周精选 • 第二十二期</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-02-51361684.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51361684&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-308c039c05fe1f2803788cde5b0b5f1a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;前言： 从2018年开始，我每天会花1个小时关注Rust社区动态，并且在&lt;a href=&quot;http://rust.cc/&quot;&gt;Rust.CC论坛&lt;/a&gt;、&lt;a href=&quot;https://t.me/rust_daily_news&quot;&gt;tg channel&lt;/a&gt;、&lt;a href=&quot;https://steemit.com/@blackanger&quot;&gt;Steemit&lt;/a&gt;、&lt;a href=&quot;https://github.com/RustStudy/rust_daily_news&quot;&gt;GitHub&lt;/a&gt;、&lt;a href=&quot;https://www.yuque.com/chaosbot/rustnews&quot;&gt;语雀订阅&lt;/a&gt;都开通了Rust每日新闻，分享我每天的见闻，偶尔也夹杂了一些个人的观点。大半年过去了，Rust每日新闻已经成为了Rust社区群大家每天必看的内容。在这个知乎专栏里，每周会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。 2018-12-02&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;官方新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;「通告」Rust 2018 新的Beta版发布！&lt;/h2&gt;&lt;p&gt;Rust 2018已经进入了最终的倒计时，官方刚刚发布了一个最新测试版。新的测试版包含了一些最近新稳定的功能和一些Bug修复。还包含一些工具的改进：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Rustfmt 1.0&lt;/li&gt;&lt;li&gt;RLS和Clpippy可以直接安装，不再是“preview”组件了。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;来帮助检测是否存在Bug。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://internals.rust-lang.org/t/announcing-rust-2018-beta-release/8901&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「官方」Rust 2018年度调查报告&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51018048&quot;&gt;中文&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html&quot;&gt;英文&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「官方」演变中的Tide中间件&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51048926&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「官方网络工作组」2018调查报告&lt;/h2&gt;&lt;p&gt;此次是网络工作组的报告，一共收到1000多条回复。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5409f04de7cc9a60cc28ec824ad2e208_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;427&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5409f04de7cc9a60cc28ec824ad2e208&quot; data-watermark-src=&quot;v2-d88e4f6aeac2b53dd2803933bb40e973&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在Web方面，流行的框架是Rocket和Actix，分别占比27%和24%。也有其他框架的选择，但是有20%的人不选择任何框架，而是在hyper上自行搭建服务。&lt;/p&gt;&lt;p&gt;存在的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;65%的人认为缺乏示例是目前生态系统中的问题，其次是缺乏文档。这也是Tokio Doc Push和Rust异步之书正在解决的问题。&lt;/li&gt;&lt;li&gt;缺乏一个真正的框架，类似于Rails或Django那样的。这也是网络工作组正在考虑的事情。为此官方构建了Tide，为打算使用Rust构建Web应用提供一个良好的开端，另一个目标是想要深入挖掘并学习如何在Rust中编写Web框架的人提供一个文档。&lt;/li&gt;&lt;li&gt;在构建应用程序时缺乏对框架和服务的一些绑定。包括绑定应用程序，比如各种NoSql数据库、支持在K8S上运行、编排容器框架和LDAP认证协议。以及对数据库的异步访问支持等，并没有一个惯用法的指南。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://rust-lang-nursery.github.io/wg-net/2018/11/28/wg-net-survey.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust官网界面改版引发争议&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://beta.rust-lang.org/&quot;&gt;官网改版测试界面&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ee7f2368481669814d6562478b86312f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;363&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ee7f2368481669814d6562478b86312f&quot; data-watermark-src=&quot;v2-af1cdfe38767b50686edefad0ed9f539&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;官方Rust Book现在有Epub版本下载&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.jyotirmoy.net/posts/2018-12-01-rust-book.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;社区新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;AWS Lambda已经支持Rust&lt;/h2&gt;&lt;p&gt;使用该库可以在AWS Lambda上运行Rust实现的函数&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/awslabs/aws-lambda-rust-runtime&quot;&gt;aws-lambda-rust-runtime&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/cn/blogs/opensource/rust-runtime-for-aws-lambda/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「游戏」Amethyst基金会成立了&lt;/h2&gt;&lt;p&gt;好消息。Amethyst是一款免费的开源游戏引擎。它是用Rust编写的，其核心是ECS架构。现在成立了基金会是为了组建一个官方的非盈利组织。这对于Amethyst的发展应该是非常有好处的了。当然，现在的状态只是提交了文件，还在等待最后的审批。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.amethyst.rs/blog/non-profit-announce/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「演讲」低延迟音频合成&lt;/h2&gt;&lt;p&gt;包含了演讲视频、代码和Slides。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://youtu.be/-F7whGjquHI?t=3150&quot;&gt;视频&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/raphlinus/synthesizer-io&quot;&gt;Code&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1cm9QaV_UjgvgBaWszHsR_w5EVre5O1D5kJUpMKQYo4I/edit?usp=sharing&quot;&gt;Slides&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;也可以多关注下后续，会有详细的博文放出。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://synthesize.rs/nov-2018-talk/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust Belt Rust 2018 大会 视频合集&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&quot;&gt;视频合集&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;AWS 出品 :  Firecracker&lt;/h2&gt;&lt;p&gt;Firecracker是一种开源虚拟化技术，专门用于创建和管理安全，多租户容器和基于功能的服务，提供无服务器操作模型。 Firecracker在轻量级虚拟机中运行工作负载，称为microVM，它将硬件虚拟化技术提供的安全性和隔离性与容器的速度和灵活性相结合。&lt;/p&gt;&lt;p&gt;看上去应该是兼容docker生态链，倾向于Serverless。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/firecracker-microvm/firecracker&quot;&gt;firecracker&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://firecracker-microvm.github.io/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/cn/blogs/aws/firecracker-lightweight-virtualization-for-serverless-computing/&quot;&gt;More Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「博文」Bitfury公司的工程师为俄罗斯邮政服务设计区块链&lt;/h2&gt;&lt;blockquote&gt; 本月，Bitfury®工程师Yury Yanovich，Ivan Prokhorov，Darya Korepanova和Sergey Vorobyov与Skolkovo科学技术研究所（Skoltech）的计算和数据密集型科学与工程中心一起在科学研究期刊Informatics上发表; 信息传输问题研究所数据挖掘和预测建模实验室; 罗蒙诺索夫莫斯科国立大学世界经济地理系; 和高等经济学院的工作是设计一个基于区块链的供应链，以防止印章伪造。 &lt;br&gt; &lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://www.mdpi.com/2227-9709/5/4/42/pdf&quot;&gt;论文&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/korepkorep/russian-post&quot;&gt;代码原型&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;RustQuiz: 26个在线Rust面试题&lt;/h2&gt;&lt;p&gt;来自于RustFest 2018 大会的轻演讲主题：Rust Quiz&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;RustaCUDA v0.1.0发布&lt;/h2&gt;&lt;p&gt;RustaCUDA是对CUDA API的Rust包装。允许分配和释放GPU内存，从GPU复制数据，加载CUDA模块和启动内核，所有这些都具有最安全，程序员友好的Rusty接口。 它可以加载和启动用任何CUDA兼容语言编写的内核，而不仅仅是Rust。&lt;/p&gt;&lt;p&gt;该作者对Rust支持CUDA作出了很多努力。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://bheisler.github.io/post/announcing-rustacuda/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/bheisler/RustaCUDA&quot;&gt;RustaCUDA&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Rocket v0.4 RC2版本发布&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://rocket.rs/v0.4/news/2018-11-30-version-0.4-rc-2/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;TOML规范 0.5中文翻译发布了&lt;/h2&gt;&lt;p&gt;从0.5开始，TOML规范趋于稳定。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/toml-lang/toml/blob/master/versions/cn/toml-v0.5.0.md&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Atom 1.33发布，内置Rust支持&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://blog.atom.io/2018/11/28/atom-1-33.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;改进的Rust贴纸，超酷&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://i.redd.it/206f9o60u0121.png&quot;&gt;下载&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「投票结果」你主要用什么操作系统构建Rust代码&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-26d65473d8e17fa47a494062e8486ce7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;752&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-26d65473d8e17fa47a494062e8486ce7&quot; data-watermark-src=&quot;v2-2193884c07be1e393268069632f3b76d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;学习资源&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;「付费」《如何系统地学习Rust》&lt;/h2&gt;&lt;p&gt;为你精心打造Rust必学第一课。 &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/lives/1043463438202249216&quot;&gt;知乎Live (已完结，可回看，9.9¥)&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust语言CheatSheet&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://cheats.rs/&quot;&gt;Cheats.rs&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust Quiz 解读： Quiz 1&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51304039&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;AoC 2018谜题Rust解决方案&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://adventofcode.com/&quot;&gt;AOC官网&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/BurntSushi/advent-of-code&quot;&gt;BurntSushi的解决方案&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/BenoitZugmeyer/RustyAdventOfCode#other-rust-implementations&quot;&gt;历年谜题解决方案&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;新书：用Rust编写WebAssembly&lt;/h2&gt;&lt;p&gt;beta版可预定。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://pragprog.com/book/khrust/programming-webassembly-with-rust&quot;&gt;programming-webassembly-with-rust&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「系列文章」数独谜题生成器 pt.3: 使用WebAssembly&lt;/h2&gt;&lt;p&gt;作者想用一个数独谜题生成器来检测WebAssembly的性能，他写了一系列文章，本文是第三篇，用Rust的wasm-bindgen工具来创建数独生成器的wasm模块。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/@rossharrison/generating-sudoku-boards-pt-3-rust-for-webassembly-85bd7294c34a&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「博文」如何将Tokio的AsyncRead和AsyncWrite转换为Futures, Sinks和Streams&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;AsyncRead to Future, 一次性读&lt;/li&gt;&lt;li&gt;AsyncRead to Stream, 持续读&lt;/li&gt;&lt;li&gt;AsyncWrite to Sink, 持续写&lt;/li&gt;&lt;li&gt;AsyncWrite to Future, 一次性写&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://jsdw.me/posts/rust-futures-tokio/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/jsdw/jsdw.me/blob/master/content/posts/rust-futures-tokio/src/main.rs&quot;&gt;Sample Code&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「博文」在Nightly版下使用async/await&lt;/h2&gt;&lt;p&gt;本文介绍了async/await，并且介绍了如何在最新的生态系统中使用老的futures 0.1。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://jsdw.me/posts/rust-asyncawait-preview/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「视频」使用Rust和Amethyst引擎进行游戏开发&lt;/h2&gt;&lt;p&gt;视频演讲中以一个开源的消除游戏everpuzzle为示例进行介绍。 [大约1小时]&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Skytrias/everpuzzle&quot;&gt;everpuzzle Code&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=P_9A7P0uNpY&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「嵌入式Rust」嵌入式开发环境&lt;/h2&gt;&lt;p&gt;作者尝试玩嵌入式，选择了以自定义一个ErgoDox键盘作为尝试。本教程介绍了相关的开发环境准备。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://josh.robsonchase.com/embedded-bootstrapping/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;在Android开发中使用Rust&lt;/h2&gt;&lt;p&gt;国内社区小伙伴写的文章，介绍如何在Android中使用Rust。&lt;/p&gt;&lt;p&gt;基于 &lt;a href=&quot;http://github.com/jni-rs/jni-rs&quot;&gt;jni-rs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50123055&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;使用Rust和Efflux编写 MapReduce Jobs&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://whitfin.io/writing-mapreduce-jobs-using-rust/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/whitfin/efflux&quot;&gt;efflux&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;项目&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;romio：异步网络原语&lt;/h2&gt;&lt;p&gt;无船同志写的 ：Mio + Future + Tokio = Romio。&lt;/p&gt;&lt;p&gt;（ 八卦： tokio作者不原意跟进Futures最新版，所以官方派出无船同志完成这项推动Rust异步历史进程的艰巨任务。） &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/withoutboats/romio&quot;&gt;romio&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Sequoia: OpenPGP的一个Rust实现&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://media.ccc.de/v/rustfest-rome-6-sequoia&quot;&gt;RustFest Roma上的演讲&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt; 关于Sequoia：Sequoia由三位前GnuPG开发商Neal H. Walfield，Justus Winter和Kai Michaelis开发。为了缓解许多常见的安全问题，Sequoia是用强类型语言Rust编写的，它提供了时间和空间内存安全性。 Rust还为将库嵌入其他语言提供了出色的支持。 Sequoia已经提供了C绑定，并且正在积极开发Python绑定。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://gitlab.com/sequoia-pgp/sequoia&quot;&gt;sequoia&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;秘猿开源CKB和CKB-VM&lt;/h2&gt;&lt;p&gt;Nervos CKB是一个公共授权区块链，是Nervos网络的共识层。CKB的VM是基于RISC-V指令集实现的。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/nervosnetwork/ckb&quot;&gt;ckb&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/nervosnetwork/ckb-vm&quot;&gt;ckb-vm&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;高性能JavaScript到JavaScript编译器&lt;/h2&gt;&lt;p&gt;基于Rust和Wasm实现&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ratel-rust/ratel-core&quot;&gt;ratel-core&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;使用Cranelift实现的玩具语言JIT&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/CraneStation/simplejit-demo&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Atlasr： 免费的地图预览器&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/atlasr-org/atlasr&quot;&gt;atlasr&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Tange：基于任务的并行框架&lt;/h2&gt;&lt;p&gt;“任务并行”是指一个或多个独立的任务同时运行。 可以用来做并行计算。用于：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;数据处理&lt;/li&gt;&lt;li&gt;分布式机器学习算法&lt;/li&gt;&lt;li&gt;一般的并行计算&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Refefer/tange&quot;&gt;tange&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;工具与库&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;tr: 国际化（i18n）库&lt;/h2&gt;&lt;p&gt;刚发布，现在找人使用，并且想得到更多反馈。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/a09b0n/tr_a_crate_for_internationalizationof_rust_code/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「工具」宣布RustPräzi：为crates.io构建整个调用图(call graph)&lt;/h2&gt;&lt;blockquote&gt; 我们很高兴地宣布我们的第一个版本的RustPräzi，一个PoC（概念验证）项目，它从crates.io 3下载所有crate版本，构建LLVM调用图并将它们链接到一个大型版本的基于呼叫的依赖网络。与常规依赖关系网络不同，基于调用的依赖关系网络表示包内和包之间的函数调用链，支持图形分析/查询&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;一个CG是表示整个程序中方法（函数）之间调用关系的图，图中的节点是方法，边表示调用关系。例如方法foo()调用了方法bar()，则CG中应有一条从foo()到bar()的有向边。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://users.rust-lang.org/t/announcing-rustprazi-a-tool-to-build-an-entire-call-graph-of-crates-io/22696&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;高效diff算法库&lt;/h2&gt;&lt;p&gt;pijul开源了它们用的diff算法。pijul是基于Rust实现的类Git版本控制工具，&lt;a href=&quot;https://jneem.github.io/pijul/&quot;&gt;用法介绍&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://docs.rs/diffs/0.1.0/diffs/&quot;&gt;diffs&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;招聘&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;「招聘」位于美国旧金山市中心的公司招Rust工程师&lt;/h2&gt;&lt;p&gt;这是去矿上工作啊。想用Rust构建大型的数字货币和大型采矿系统。没看到说可以远程的信息，应该是不能远程了。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;薪水 120k ~ 160k美刀 + 股权&lt;/li&gt;&lt;li&gt;旧金山软件工程师的平均工资是134,000美元&lt;/li&gt;&lt;li&gt;旧金山的失业率为3％&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://functional.works-hub.com/jobs/rust-engineer-in-san-francisco-united-states-of-america-3a18b&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-02-51361684</guid>
<pubDate>Sun, 02 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读： Quiz 1</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-01-51304039.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51304039&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/p&gt;&lt;h2&gt;Quiz 1:&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;macro_rules! m {
    ($($s:stmt)*) =&amp;gt; {
        $(
            { stringify!($s); 1 }
        )&amp;lt;&amp;lt;*
    };
}

fn main() {
    print!(
        &quot;{}{}{}&quot;,
        m! { return || true },
        m! { (return) || true },
        m! { {return} || true },
    );
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 112&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;考察要点： &lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;声明宏的语法&lt;/li&gt;&lt;li&gt;Rust中语句（statements）的区分&lt;/li&gt;&lt;li&gt;操作符优先级&lt;/li&gt;&lt;li&gt;return作为表达式产生的值是Never Type类型(!)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;上面代码中，宏声明代码中火箭符（=&amp;gt;）左边的是匹配表达式，其中&lt;code class=&quot;inline&quot;&gt;$s:stmt&lt;/code&gt;  代表匹配语句（statements），而&lt;code class=&quot;inline&quot;&gt;$( )*&lt;/code&gt;这样的语法，类似于正则表达式，代表匹配零个或多个。那么&lt;code class=&quot;inline&quot;&gt;$($S: stmt)*&lt;/code&gt;就代表匹配零个或多个语句tokens。&lt;/p&gt;&lt;p&gt;在火箭符的右侧，&lt;code class=&quot;inline&quot;&gt;{stringify!($s); 1}&lt;/code&gt;  其中的stringily!宏是将匹配的语句$s转换为字符串，  &lt;code class=&quot;inline&quot;&gt;$( )&amp;lt;&amp;lt;*&lt;/code&gt;  对应于左边匹配表达式，生成零个或多个形如&lt;code class=&quot;inline&quot;&gt;... &amp;lt;&amp;lt; ... &amp;lt;&amp;lt;&lt;/code&gt;这样的语句。&lt;/p&gt;&lt;p&gt;&lt;b&gt;再来看main函数中：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;m!{ return || true}&lt;/code&gt;  ，等价于&lt;code class=&quot;inline&quot;&gt;return (|| true )&lt;/code&gt; ，返回一个闭包。这属于一条独立语句。所以 最终宏生成的代码是 &lt;code class=&quot;inline&quot;&gt;{&quot;return || true&quot;; 1}&lt;/code&gt;，最终在print!语句中执行结果是返回块代码中最后一个表达式的值：1.&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;m!{(return) || true}&lt;/code&gt;，这里面return被括号隔离，那么整个语句是或操作。这里return 是一个表达式，它产生的值是NeverType（!）。右边表达式是true，所以是一个独立的语句。最终宏生成的代码是 &lt;code class=&quot;inline&quot;&gt;{&quot;(return) || true&quot;; 1}&lt;/code&gt;，最终的值是：1。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;m!{ {return} || true }&lt;/code&gt;，这里rutrn用花括号隔开，代表它是一个独立的语句，后面的&lt;code class=&quot;inline&quot;&gt;|| true&lt;/code&gt;就会被看做一个独立的闭包。那么这里存在两条语句，最终宏生成的代码是&lt;code class=&quot;inline&quot;&gt;{&quot;{true}&quot;; 1} &amp;lt;&amp;lt; {&quot;|| true&quot;; 1}&lt;/code&gt;，那么最终的值就是&lt;code class=&quot;inline&quot;&gt;1&amp;lt;&amp;lt;1&lt;/code&gt;，也就是：2。&lt;/p&gt;&lt;p&gt;所以代码的执行结果就是112。&lt;/p&gt;&lt;p&gt;点此查看原题，及更多解释：&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/1&quot;&gt;Rust Quiz 1 &lt;/a&gt; &lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-01-51304039</guid>
<pubDate>Sat, 01 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「官方」演变中的Tide中间件</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-11-28-51048926.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51048926&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-67e9a14fec18c48abf4869dba6dde2da_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;Tide，是Rust官方出品的异步Web开发框架，为了构建生态标准而创建。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在上篇文章里说到，Tide借鉴了actix-web中before/after风格的中间件。然而&lt;a href=&quot;https://steemit.com/@tirr-c&quot;&gt;@tirr-c&lt;/a&gt;基于此又发现了更好的抽象方式。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;/// Middleware that wraps around remaining middleware chain.
pub trait Middleware&amp;lt;Data&amp;gt;: Send + Sync {
    /// Asynchronously handle the request, and return a response.
    fn handle&amp;lt;&#39;a&amp;gt;(&amp;amp;&#39;a self, ctx: RequestContext&amp;lt;&#39;a, Data&amp;gt;) -&amp;gt; FutureObj&amp;lt;&#39;a, Response&amp;gt;;
}&lt;/code&gt;&lt;p&gt;新的trait使用一个方便的RequestContext，封装了中间件可用的所有上下文信息。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub struct RequestContext&amp;lt;&#39;a, Data&amp;gt; {
    pub app_data: Data,
    pub req: Request,
    pub params: RouteMatch&amp;lt;&#39;a&amp;gt;,
    // plus additional, private fields
}

impl&amp;lt;&#39;a, Data: Clone + Send&amp;gt; RequestContext&amp;lt;&#39;a, Data&amp;gt; {
    /// Consume this context, and run remaining middleware chain to completion.
    pub fn next(self) -&amp;gt; FutureObj&amp;lt;&#39;a, Response&amp;gt; { ... }
}&lt;/code&gt;&lt;p&gt;在这种方法中，每个中间件都可以完全控制剩余的请求处理管道。在此接口上构建before/after的中间件构造函数很简单。但使用这种around中间件作为核心接口有一些关键的优势：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在before/after发生的步骤之间传递数据要更简单。&lt;/li&gt;&lt;li&gt;之前的方法强制为每个请求分配FutureObj，但是现在的around风格中间件只需要在执行异步工作或管道其余部分需要的时候再分配新的FutureObj&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;新的接口可以说更简单、更整洁。&lt;/p&gt;&lt;p&gt;Tide也新增了带有自定义中间件的嵌套路由。现在使用nest方法可以将中间件应用于具有公共路由的子路由里。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let mut app = App::new(your_data);

app.at(&quot;/some/prefix&quot;).nest(|r| {
    r.middleware(some_middleware);      // applies to everything under `/some/prefix`
    r.at(&quot;/&quot;).get(prefix_top_endpoint); // matches `/some/prefix`
    r.at(&quot;/foo&quot;).get(foo_endpoint);     // matches `/some/prefix/foo`
});

// no middleware is applied to this route
app.at(&quot;/&quot;).get(index_endpoint);

app.serve(address);&lt;/code&gt;&lt;p&gt;nest方法实现：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;impl&amp;lt;&#39;a, Data&amp;gt; Resource&amp;lt;&#39;a, Data&amp;gt; {
    /// &quot;Nest&quot; a subrouter to the path.
    ///
    /// This method will build a fresh `Router` and give a mutable reference to it to the builder
    /// function. Builder can set up a subrouter using the `Router`. All middleware applied inside
    /// the builder will be local to the subrouter and its descendents.
    pub fn nest(self, builder: impl FnOnce(&amp;amp;mut Router&amp;lt;Data&amp;gt;));
}&lt;/code&gt;&lt;p&gt;另外还增加了一个使用计算值的示例：&lt;a href=&quot;https://github.com/rust-net-web/tide/blob/master/examples/computed_values.rs&quot;&gt;computed_values&lt;/a&gt;&lt;/p&gt;&lt;p&gt;原文中列出了还待解决的一些问题列表，你也可以来参与。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://rust-lang-nursery.github.io/wg-net/2018/11/27/tide-middleware-evolution.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-11-28-51048926</guid>
<pubDate>Wed, 28 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「官方」Rust 2018年度调查报告</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-11-28-51018048.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51018048&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-938be19e928e7da9e957e2223c134d5f_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;原文：&lt;a href=&quot;https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html&quot;&gt;The Rust Programming Language Blog&lt;/a&gt;  &lt;/blockquote&gt;&lt;p&gt;一年一度的Rust调查报告，今年已经是第三次了。今年这份调查报告首次以多种语言推出，除英语外，一共有14种语言。非英语语言的结果占所有回复的25%。此次报告一共产生&lt;b&gt;5991个回复记录。&lt;/b&gt;在展现最终报告分析结果之前，我们想给所有花时间回应并将你的想法告诉我们的人一个大大的感谢。因为有你们的帮助，Rust才将年复一年地持续完善。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust Users &lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2f3176b25e759da6616cf7d02b7b47a3_r.jpg&quot; data-rawwidth=&quot;662&quot; data-rawheight=&quot;358&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;尽管回复的总数有所增加，但今年Rust用户的比例也同样有所增加。Rust用户占比，与去年的66.9%相比，今年占到了将近3/4。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Time with Rust&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8ad4b0c8522da223ef37ee11d5ee3653_r.jpg&quot; data-rawwidth=&quot;581&quot; data-rawheight=&quot;364&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以看到，Rust新用户源源不断。在调查时，约有23%的用户使用它3个月或更短的时间。同样，近1/4用户使用Rust至少两年。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0965735bcc5220f9bab6b82b1f96cfe1_r.jpg&quot; data-rawwidth=&quot;583&quot; data-rawheight=&quot;356&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;超过40%的用户在使用Rust不到一个月的时间内感受到了Rust的开发效率，超过70%的人在第一年感到高效。然而，用户之间存在明显差异，超过22%的人尚未对Rust感到富有成效。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-458ce501853b8e7dab39bde1027f8aaf_r.jpg&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;359&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;仔细观察那些使用Rust没有产生效果的用户，只有大约25％的用户只使用Rust不到一个月。 这里面临的挑战是找到帮助用户实现生产力的方法，以免他们陷入困境。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;How much do you use Rust?&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-833a6ad8bc02247a404f3c97def4130c_r.jpg&quot; data-rawwidth=&quot;773&quot; data-rawheight=&quot;484&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;随着整体投入的增加，Rust项目将继续趋向更大规模。 Rust的中到大投入（分别超过10k和10万行代码）。从2016年的8.9％增长到2017年的16％，今年增长到23％。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-349c4c0c97c2a5d9ff1bfddb4b2069b6_r.jpg&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;354&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们也看到了Rust常规使用量的增长。 从去年的17.5％上升到现在Rust每日使用量现已接近用户的四分之一。 总的来说，Rust每周的总使用量从60.8％上升到66.4％。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust expertise&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-580920510a3233043cbe5e6562ced8f7_r.jpg&quot; data-rawwidth=&quot;584&quot; data-rawheight=&quot;358&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust专业知识，不仅仅是一条简单的曲线，还有两个高峰：一个围绕「3」，另一个围绕「7」，这表明用户倾向于认为自己只是初学者或经验丰富，而不是专家。&lt;/p&gt;&lt;p&gt;（原问题已经关闭，忘记3和7指代的是什么了，多半是所有权相关的吧）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6edc8762e09f21e13473b212a60866c1_r.jpg&quot; data-rawwidth=&quot;676&quot; data-rawheight=&quot;422&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust用户普遍认为Enums和Cargo在很大程度上是简单的概念; 其次是迭代器，模块和trait。 接下来是更具挑战性的Trait Bounds和Unsafe概念。 最后，最具挑战性的概念是Macros，Ownership＆Borrowing和Lifetimes。 这些挑战与我们过去几年听到的反馈密切相关，并继续成为持续提高生产力的重点，如NLL和持续的宏观系统改进。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0e2a29bd4ac4069f9edcb2ec191a1e25_r.jpg&quot; data-rawwidth=&quot;581&quot; data-rawheight=&quot;353&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;幽默地说，我们发现Rust实际上并不是用户熟悉的顶级编程语言。 相反，它落后于Python，位落第二。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust toolchain&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ba0faf9866b979fff72213f6e2d24b8f_r.jpg&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;347&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们看到当前稳定版本的用户数量和去年相似。 也许令人惊讶的是，我们仍然看到在其工作流程中使用Nightly编译器的用户数量有所增加。 连续第二年，Nightly使用量持续上升，现在超过56％（高于去年的51.6％）。当被问到为什么他们使用Nightly时，人们回应的原因很多，包括：访问2018版，asm，async / await，clippy，嵌入式开发，Rocket，NLL，proc宏和wasm。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b62e84db6514c0d89f93bb2242908a1e_r.jpg&quot; data-rawwidth=&quot;963&quot; data-rawheight=&quot;584&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;在常规编译器更新期间看到breakage的人的百分比自去年以来保持不变，7.4％的人表示他们经历过breakage。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-12e6593fb098964fdf10c99a92456513_r.jpg&quot; data-rawwidth=&quot;585&quot; data-rawheight=&quot;361&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;breakage通常倾向于需要一些小的修复，尽管有些人报告说有一些中等或主要的修复程序可以升级到下一个稳定的编译器。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-57454f1484b2df14ec92519b31855957_r.jpg&quot; data-rawwidth=&quot;579&quot; data-rawheight=&quot;318&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;我们再次看到rustup的遥遥领先，它继续保持在Rust安装工具的90％。 Linux发行版以17％的速度遥遥领先。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-61fd8dcfdece8d66555ecaca55a6c529_r.jpg&quot; data-rawwidth=&quot;635&quot; data-rawheight=&quot;393&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;像rustfmt和rustdoc这样的工具有很强的表现力，有很多积极的支持。 接下来是clippy工具 - 尽管用户较少，但其用户喜欢这个工具。 IDE支持工具Rust Language Server和racer得到了积极的支持，但不幸的是，在调查的工具中，产生了一些不喜欢的投票和评论。 bindgen工具具有相对较小的用户群。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust workflow&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5e3b82e9e816ce75b60bfc0527347fa1_r.jpg&quot; data-rawwidth=&quot;589&quot; data-rawheight=&quot;349&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;Linux仍然是Rust开发人员的强大动力，占据了大约80％的Rust开发人员。 Windows的使用量从去年的31％略微增长到今年的34％，这是其连续第二年增长。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-905ace7fb667df117d890671400c64e3_r.jpg&quot; data-rawwidth=&quot;808&quot; data-rawheight=&quot;492&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;Linux和Windows继续作为Rust应用程序的目标而遥遥领先。 其他平台与去年大致相同，但有一个例外：WebAssembly。 这项新技术取得了令人瞩目的增长，从去年的13％增长到今年的24％，几乎翻了一番。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3bb61de3903d1b05cbf199cf0f0e475a_r.jpg&quot; data-rawwidth=&quot;757&quot; data-rawheight=&quot;351&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;领跑两年的Vim现在终于被VSCode击败了，VSCode从33.8％Rust开发者增长到今年的44.4％。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust at work&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fbf36f828e1bf592d3278d888c6546a7_r.jpg&quot; data-rawwidth=&quot;896&quot; data-rawheight=&quot;555&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;Rust继续在商业生产领域缓慢而稳定地增长。 我们现在看到全职和兼职Rust的同比增长，从去年4.4％的全职和16.6％的兼职增长到今年的8.9％的全职和21.2％的兼职 ，全职Rust商业用途增加一倍。 Rust的商业使用总量从Rust用户的21％增长到略高于30％。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5a92aef27ce4f5f2e6f7265bca1e92ee_r.jpg&quot; data-rawwidth=&quot;588&quot; data-rawheight=&quot;352&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust有更多的空间发展到更多的公司中，超过三分之一的用户报告目前还没有考虑在未来一年中评估Rust。 将近一半的非Rust用户需要公司支持，这表明需要进一步的公司拓展或更多关于Rust的公司信息。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Feeling welcome&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3de641b0bb462331d250d2e70c00e18c_r.jpg&quot; data-rawwidth=&quot;584&quot; data-rawheight=&quot;360&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust社区工作的一个重要部分是确保Rust项目对其用户来说是一个温馨的地方。 新用户应该感到鼓励去探索，分享想法，并且做他们自己。当被问到时，目前Rust用户和非Rust用户都受到欢迎，尽管超过四分之一的回复并不确定。 这些答复中也存在一些区域差异。 例如，对俄罗斯版本调查的回复显示，不受欢迎的感觉比例为4％。 中国大陆的增幅更高，为8％。这里有一个挑战是帮助全球的Rust社区感觉他们是Rust独特的一部分，因为Rust继续在世界更多地区发展壮大。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0625940f2b31368453116034d7abe796_r.jpg&quot; data-rawwidth=&quot;1049&quot; data-rawheight=&quot;377&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust自称为技术人员不足的人数逐年增长缓慢。 该调查还强调了一些挑战，因为女性人数仍然低于编程领域女性的行业平均水平。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust Non-Users&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-542d0c174b5bd46a97313d4c7fda4a01_r.jpg&quot; data-rawwidth=&quot;588&quot; data-rawheight=&quot;357&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;只有不到50％的人在不到一个月的时间内停止使用Rust。 同样地，大约50％离开Rust的人在停止之前设法使用它超过一个月。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cb651a46dd35f4841b508098a755afee_r.jpg&quot; data-rawwidth=&quot;994&quot; data-rawheight=&quot;607&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;许多非Rust用户表示他们确实想学习Rust，但有些因素会减慢他们的速度。 其中首先是他们工作的公司本身不使用Rust。 近一半的非Rust用户因缺乏公司支持而受阻。此外，由于Rust的感觉过于可怕或复杂，四分之一的非Rust用户因此而放慢了学习的速度。 改进Rust IDE支持的工作有所帮助（从25％降至16％），尽管我们仍然看到强烈推动非Rust用户提供更好的IDE支持。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;挑战&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;正如我们在过去几年所做的那样，我们询问您对Rust可以有哪方面改进。今年，我们在这个反馈中看到了一些熟悉的主题以及一些新的主题。今年十大主题是：&lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;需要更好的库支持&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;更好的IDE体验&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;需要更广泛地采用Rust&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;更丰富的工具和生态系统支持&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;改善学习曲线&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;需要重要的语言功能和板条箱才能稳定和支持&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;支持异步编程&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;支持GUI开发&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;更好的文档&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;改进编译时间&lt;/b&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;b&gt;今年，GUI开发支持是不断增长的新需求，表明Rust不仅在服务器上继续增长，而且人们感觉需要延伸到应用程序开发。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;“加强Rust的推广，很多人还不知道它”&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;此回复提醒我们虽然Rust在某些圈子中可能是众所周知的，但它仍有成长空间，在许多科技界，Rust可能还不为人所熟知。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;“专注于采纳教程/书籍/新手经验，将在未来几年带来好处。”&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;除了延伸内容之外，更广泛的文档将帮助更广泛的受众。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;“开发人员工具的稳定性和成熟度，使得更容易获得工作设置和调试应用程序”&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;许多人对IDE支持发表了评论，不仅指出了RLS中的不稳定性或不准确性，而且还需要更强大的IDE支持，涵盖更多领域，比如更容易调试。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;“生态系统和库的成熟。拥有一个良好的“标准”库生态系统是该语言未来的关键”&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;一个共同的主题仍然是需要推动库完成并增加用户可以使用的“标准”库集。一些评论指出，这不是维护者的错，他们已经在努力编写和发布crate，但通常更多的公司需要参与并提供商业支持。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;“开发体验和可发现性” ”&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;有些人指出，开发体验与更丰富的文档齐头并进，认为这些不是单独的概念，而是应该以统一的方法解决。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;期待&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;今年是最强的调查。它不仅是最大的社区调查，也是第一个涵盖英语以外语言的调查。 Rust继续稳步增长，并且随之而来的是，它的优势和挑战都被引入更广泛的受众。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;我们期待在2019年的规划中使用您的反馈，并且很期望看到接下来我们能把Rust带向何方。&lt;/b&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-11-28-51018048</guid>
<pubDate>Wed, 28 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「Rust每日新闻」本周精选 • 第二十一期</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-11-24-50737367.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50737367&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-308c039c05fe1f2803788cde5b0b5f1a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;前言： 从2018年开始，我每天会花1个小时关注Rust社区动态，并且在&lt;a href=&quot;http://rust.cc/&quot;&gt;Rust.CC论坛&lt;/a&gt;、&lt;a href=&quot;https://t.me/rust_daily_news&quot;&gt;tg channel&lt;/a&gt;、&lt;a href=&quot;https://steemit.com/@blackanger&quot;&gt;Steemit&lt;/a&gt;、&lt;a href=&quot;https://github.com/RustStudy/rust_daily_news&quot;&gt;GitHub&lt;/a&gt;、&lt;a href=&quot;https://www.yuque.com/chaosbot/rustnews&quot;&gt;语雀订阅&lt;/a&gt;都开通了Rust每日新闻，分享我每天的见闻，偶尔也夹杂了一些个人的观点。大半年过去了，Rust每日新闻已经成为了Rust社区群大家每天必看的内容。在这个知乎专栏里，每周会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。 2018-11-24&lt;/blockquote&gt;&lt;h2&gt;官方新闻&lt;/h2&gt;&lt;h2&gt;「官方」crates.io帐号审核措施&lt;/h2&gt;&lt;p&gt;从2019-02-28开始，需要经过验证电子邮件地址的帐号才能往crates.io发布crate。所以，之前注册帐号的，2019-02-28之前，可能会收到警告，要求你去验证注册的email地址。如果不验证，2019-02-28之后就会收到发布错误了。 crates.io承诺将保护好你的隐私。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://users.rust-lang.org/t/a-verified-email-address-will-be-required-to-publish-to-crates-io-starting-on-2019-02-28/22425&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「CLI工作组」Cli Book新发布了打包章节的第一个版本&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://rust-lang-nursery.github.io/cli-wg/tutorial/packaging.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;社区新闻&lt;/h2&gt;&lt;h2&gt;RustFest Roma大会开始了&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/hashtag/RustFest?src=hash&quot;&gt;twitter话题&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;塞萨洛尼基（希腊古城） GNOME+Rust Hackfest 活动记录&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.guillaume-gomez.fr/articles/2018-11-19+GNOME%2BRust+Hackfest+in+Thessaloniki&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;TiKV Rust Client呼吁社区开发者参与&lt;/h2&gt;&lt;p&gt;TiKV Rust Client 的RFC马上完工，现在呼吁社区开发者为其做贡献。也是一次最佳练手的机会。 当然，如果你对去PingCAP工作感兴趣的话，也许也是一次绝佳的机会。&lt;/p&gt;&lt;p&gt;如何参与？&lt;/p&gt;&lt;p&gt;开发环境配置：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;最简单的就是本机启动一个pd（Placement Driver ），然后启动一个 Tikv，都用默认的配置应该就能跑起来。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/tikv/tikv/blob/master/docs/op-guide/deploy-tikv-using-binary.md&quot;&gt;部署TiKV&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/tikv/rfcs/pull/7&quot;&gt;RFC-7&lt;/a&gt;&lt;/p&gt;&lt;p&gt;然后提交PR或Issues就可以了。&lt;/p&gt;&lt;h2&gt;RedHat发布对Rust、Go、Clang/LLVM6.0的支持计划&lt;/h2&gt;&lt;p&gt;RedHat对Rust1.29、Go1.10和Clang/LLVM6.0的可用性评估之后，现在已经将它们提升到了完全支持状态。在完全支持阶段，一些合格的重要的勘误表（RHSA）和一些选定的高优先级的错误修复表（RHBA）将会在可用时及时发布。&lt;/p&gt;&lt;p&gt;由于这些包正在快速发展阶段，RedHat将对它们提供特别的更新支持。Rust每个季度会有更新，对于LLVM和Go，则是半年一次。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://developers.redhat.com/blog/2018/11/20/support-lifecycle-for-clang-llvm-go-and-rust/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;2018 JS状态报告里提到了Rust&lt;/h2&gt;&lt;blockquote&gt; With projects like Web Assembly arriving on the scene, writing code directly in JavaScript might soon seem quaint as developers embrace languages like Rust instead.&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c9361997bcb07a8cdfabdb8308e70703_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;360&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c9361997bcb07a8cdfabdb8308e70703&quot; data-watermark-src=&quot;v2-344b01c08c09ee212695cbbc7877212a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://2018.stateofjs.com/javascript-flavors/conclusion&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust中的泛型方法：Exonum如何从Iron迁移到Actix-Web&lt;/h2&gt;&lt;p&gt;本文是Exonum工程师记录了使用泛型编程将Iron迁移到Actix-Web框架的过程。&lt;/p&gt;&lt;p&gt;由于平台自身的增长需求，需要从同步迁移到异步，Iron是同步框架，已经无法满足需求，所以选择了actix-web。&lt;/p&gt;&lt;p&gt;他们不仅仅是迁移Web框架，更重要的是，重新设计新的API体系。本文较长，其中详细给出了如何利用泛型编程对API进行设计的思考，感兴趣的可以看看。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/meetbitfury/generic-methods-in-rust-how-exonum-shifted-from-iron-to-actix-web-7a2752171388&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;学习资源&lt;/h2&gt;&lt;h2&gt;使用Rust为PostgreSQL编写扩展函数&lt;/h2&gt;&lt;p&gt;作者提供了一个库pgxr，可以方便地使用该库提供的宏来编写postgresql的扩展函数&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/clia/pgxr&quot;&gt;pgxr&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9y2yjq/write_postgresql_extension_functions_as_stored/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;无等待线程本地存储&lt;/h2&gt;&lt;p&gt;本文介绍了一种无等待线程本地存储。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://bzim.gitlab.io/blog/posts/wait-free-per-object-thread-local-storage.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;PHP中运行WASM&lt;/h2&gt;&lt;p&gt;用C语言编写的PHP扩展，通过FFI调用Rust lib，用wasmi来执行wasm。 只是一个POC版本！&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/paritytech/wasmi&quot;&gt;wasmi&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Hywan/php-ext-wasm&quot;&gt;php-ext-wasm&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9y7wl6/run_wasm_in_php_natively_php_extension_written_in/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「教程」Rust中的编译时Features Flag&lt;/h2&gt;&lt;p&gt;Features Flag用于启用或禁用features的配置。本文讲解了如何在项目里使用它。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.worthe-it.co.za/programming/2018/11/18/compile-time-feature-flags-in-rust.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这篇文章是作者参加一个2018 塔防游戏机器人大赛过程中总结出来的。&lt;/p&gt;&lt;p&gt;也是用Rust实现，源码： &lt;a href=&quot;https://github.com/JWorthe/entelect-challenge-tower-defence&quot;&gt;entelect-challenge-tower-defence&lt;/a&gt;&lt;/p&gt;&lt;p&gt;游戏官网： &lt;a href=&quot;https://challenge.entelect.co.za/&quot;&gt;challenge.entelect.co.za/&lt;/a&gt; ，好像挺好玩。&lt;/p&gt;&lt;h2&gt;使用Pest实现EBNF语法&lt;/h2&gt;&lt;p&gt;作者在实现一个XML解析器，这篇文章记录了使用Pest来实现使用EBNF-esque形式的词法分析器。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/compenguy/xml-grimoire&quot;&gt;xml-grimoire&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://compenguy.github.io/hobbies/rust/ebnf-to-pest.html&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「演讲」ADC&#39;18大会:  Rust音频编程&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9z4z9o/adc18_introduction_to_rust_for_audio_programming/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/irh/freeverb-rs&quot;&gt;freeverb-rs&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust+WASM实现的小程序&lt;/h2&gt;&lt;p&gt;群友@JiaYe 使用Rust和WASM实现了Gif图片制作的小程序。&lt;/p&gt;&lt;p&gt;让小程序加载wasm模块，还需要做一些针对性修改，可以在该源码里看到。感兴趣的可以看看。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/planet0104/miniprogram-gifmaker/blob/master/README.md&quot;&gt;miniprogram-gifmaker&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;项目&lt;/h2&gt;&lt;h2&gt;建立在mio之上的网络库：Sonr&lt;/h2&gt;&lt;p&gt;相比于Tokio来说，更加轻量。但不晓得是不是玩票之作，至少可以满足学习的需求。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/hagsteel/sonr&quot;&gt;sonr&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;TypedHtml: 带类型检查的JSX模板&lt;/h2&gt;&lt;p&gt;这个库上次（前几天）介绍还是100左右的star，现在已经上升到800多star了。也增加了Readme说明。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/bodil/typed-html&quot;&gt;typed-html&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Vulkano：Vulkan API的Rust安全绑定&lt;/h2&gt;&lt;blockquote&gt; Vulkan是由Khronos Group组织（知道OpenGL的话应该都听过这个组织）提供的一个新型的图形接口，它对现代图形显卡做了一个更好的抽象。跟现有的图形接口例如OpenGL和DirectX相比，Vulkan的性能更加强劲，驱动表现更加符合预期行为。Vulkan背后的设计思路跟 Direct3D 12 和 Metal 类似，但它具有跨平台的优势，可以让你同时在windows，linux和android上进行开发。 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/26938967&quot;&gt;来源&lt;/a&gt;&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://vulkano.rs/guide/acquire-present&quot;&gt;vulkano教程&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://vulkano.rs/&quot;&gt;vulkano.rs&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;用Rust实现ecmascript 2019 parser和ast visitor&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/swc-project/swc&quot;&gt;swc&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/swc-project/swc/blob/c816d699ca57fc50ff272dde8e441e15ecc093ac/ecmascript/parser/Cargo.toml&quot;&gt;swc_ecma_parser&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9yqufy/javascript_parser_and_ast_visitor_written_in_rust/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;wasmer: 高性能WASM JIT解释器&lt;/h2&gt;&lt;p&gt;基于Cranelift 代码生成引擎实现的。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/WAFoundation/wasmer&quot;&gt;wasmer&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;quinn : Rust实现的QUIC协议&lt;/h2&gt;&lt;p&gt;也就是HTTP3，这两天火了呢。&lt;/p&gt;&lt;p&gt;注意看项目Readme，有相关演讲。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/djc/quinn&quot;&gt;quinn&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「嵌入式」 Rust实现的闹钟&lt;/h2&gt;&lt;p&gt;纯Rust打造的DIY液晶闹钟，很酷。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/TeXitoi/rusty-clock&quot;&gt;rusty-clock&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;pijul 0.11发布&lt;/h2&gt;&lt;p&gt;pijul是基于Rust实现的类Git版本控制工具，&lt;a href=&quot;https://jneem.github.io/pijul/&quot;&gt;用法介绍&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://pijul.org/posts/2018-11-20-pijul-0.11/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;amp: 类Vim的终端文本编辑器&lt;/h2&gt;&lt;p&gt;这个库最近在GitHub趋势榜上升很快，最近几天发布了0.5.2版本。使用Vim的核心的交互模型，但是对其做了简化。其内部结构（工具集）已经独立为scribe库，包含数据结构、语法高亮、工作空间管理等功能。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/jmacdonald/amp&quot;&gt;amp&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/jmacdonald/scribe&quot;&gt;scribe&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;drone: Rust无人机项目&lt;/h2&gt;&lt;p&gt;四轴飞行器&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/martindeegan/drone&quot;&gt;drone&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Proptest：Rust实现的属性测试框架&lt;/h2&gt;&lt;p&gt;Proptest受Python Hypotheis测试框架启发，而Hypotheis是由Haskell的QuickCheck包启发而成的。&lt;/p&gt;&lt;p&gt;本质上它是用来产生测试数据的，但是它会注意到内存泄露以及越界等会使测试崩溃的问题，因而，在某种程度上它可以为你编写单元测试。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/AltSysrq/proptest&quot;&gt;proptest&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;工具与库&lt;/h2&gt;&lt;h2&gt;Wither 0.6发布&lt;/h2&gt;&lt;p&gt;wither是为Mongodb编写的Rust驱动。可以参考宣传文章，有更多介绍。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/thedodd/wither&quot;&gt;wither&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://medium.com/docql/https-medium-com-docql-rust-mongodb-wither-13e803c9ae72&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;命令行HTTP客户端&lt;/h2&gt;&lt;p&gt;一个Rust实现的类crul命令行http客户端，灵感来自于Python的HTTPie&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://gitlab.com/rakenodiax/rust-client&quot;&gt;rust_client&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-11-24-50737367</guid>
<pubDate>Sat, 24 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「Rust每日新闻」本周精选 • 第二十期</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-11-18-50212359.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50212359&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-308c039c05fe1f2803788cde5b0b5f1a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;前言： 从2018年开始，我每天会花1个小时关注Rust社区动态，并且在&lt;a href=&quot;http://rust.cc/&quot;&gt;Rust.CC论坛&lt;/a&gt;、&lt;a href=&quot;https://t.me/rust_daily_news&quot;&gt;tg channel&lt;/a&gt;、&lt;a href=&quot;https://steemit.com/@blackanger&quot;&gt;Steemit&lt;/a&gt;、&lt;a href=&quot;https://github.com/RustStudy/rust_daily_news&quot;&gt;GitHub&lt;/a&gt;、&lt;a href=&quot;https://www.yuque.com/chaosbot/rustnews&quot;&gt;语雀订阅&lt;/a&gt;都开通了Rust每日新闻，分享我每天的见闻，偶尔也夹杂了一些个人的观点。大半年过去了，Rust每日新闻已经成为了Rust社区群大家每天必看的内容。在这个知乎专栏里，每周会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。 2018-11-18&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;官方新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;「官方」await语法方面的进展&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49440981&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「嵌入式工作组」嵌入式Rust年度回顾&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49921783&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「官方」如何检测Unsafe代码中的UB&lt;/h2&gt;&lt;p&gt;ralfj比较高产，他负责Unsafe下内存模型相关的工作，目的是用miri来检测unsafe中的UB行为。&lt;/p&gt;&lt;p&gt;该模型用于定义在unsafe内存模型中允许哪种别名。建立合理的别名规则，才能基于miri来检查unsafe下的UB行为。&lt;/p&gt;&lt;p&gt;该模型的核心思想是： 对于一个内存位置，逐步建立可跟踪的引用，形成一个栈结构。比如有一个&amp;amp;mut i32，可以对其重新借用获得一个新引用。这个新引用是必须用于此位置的引用，建立在旧引用之上。当新引用过期的时候，旧引用会被激活，就好像是栈结构push和pop。&lt;/p&gt;&lt;p&gt;在今天这篇文章中，ralfj写了实现上述模型的进展。&lt;/p&gt;&lt;p&gt;在Safe Rust中，通常有借用检查来保护内存。但是在编写Unsafe代码的时候，借用检查就无法提供帮助了。所以，Rust核心团队就必须要定义一组规则，即使对于Unsafe代码来说也是非常有意义的。在本篇文章中，ralfj会再次解释这些规则，但是和上次的有所不同，因为ralfj在这三个月对栈式借用实现的过程中，对这些规则理解更深了&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html&quot;&gt;前篇：栈式借用模型&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/nikomatsakis/rust-memory-model/issues/26&quot;&gt;关于别名规则issues&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;社区新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;Rust与游戏开发&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50066484&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「安全呼吁」互联网存在一个巨大的C/C++安全隐患&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50069980&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「演讲」平台价值观、Rust以及对系统软件的启示&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50209719&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;GitHub上Rust颜色变更事件&lt;/h2&gt;&lt;p&gt;之前有人修改了Rust的颜色，并给出了修改的理由：&lt;/p&gt;&lt;blockquote&gt; The Rust color on GitHub doesn&#39;t look much like rust, and I don&#39;t see where it could have come from (not on the website or part of the logo). In fact, it looks rather pale and sickly, rather than vibrant and robust.&lt;br&gt; a62c00 is much nicer. It resembles the red paints that have traditionally been made with iron oxide.&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;作者认为，新颜色是正宗氧化铁的颜色，应该改成这个。其实我比较喜欢新颜色，像「血液」的颜色，也可以赋予其象征意义：「热血」、「新鲜血液」&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/github/linguist/pull/4319&quot;&gt;肇事者PR&lt;/a&gt;&lt;/p&gt;&lt;p&gt;但是引起了Rust社区的强烈反响，之后linguist项目的维护者不得不将颜色又改了回去，还向社区道了歉。&lt;/p&gt;&lt;p&gt;所以，如果你在GitHub上要是搜Rust项目，发现存在两种颜色的时候，不要惊讶。&lt;/p&gt;&lt;h2&gt;「RustRush 2018」莫斯科举办的国际Rust大会&lt;/h2&gt;&lt;p&gt;看来战斗民族也挺喜欢Rust。最近国际上的其他Rust大会：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Rome at @RustFest Nov 23-28&lt;/li&gt;&lt;li&gt;Cologne at @RustCologne Dec 5&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://www.papercall.io/rustrush&quot;&gt;rustrush&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9we3oe/rustrush_2018_the_rust_conference_in_moscow/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust如何帮助Kentik提升性能&lt;/h2&gt;&lt;p&gt;美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：&lt;/p&gt;&lt;blockquote&gt; Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于&lt;a href=&quot;http://crates.io&quot;&gt;http://crates.io&lt;/a&gt;上可用的强大的开源库生态系统。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。&lt;/p&gt;&lt;p&gt;这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。&lt;/p&gt;&lt;p&gt;所以，你如果对Rust感兴趣，赶紧试试吧。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik&#39;s-performance-on-high/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;如何跟踪async/await进展状态&lt;/h2&gt;&lt;p&gt;这篇reddit帖子评论区罗列出了async/await相关的issues、pr等，可以关注async/await的进展&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9wrtgs/asyncawait_status_and_tracking/&quot;&gt;Reddit讨论&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「Cpp 2018」在Clang中实现C++ Core Guidelines生命周期安全&lt;/h2&gt;&lt;p&gt;对CPP熟悉的朋友可以关注下，也许通过该视频可以对Rust的生命周期有更深入的理解。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=sjnp3P9x5jA&quot;&gt;youtube&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;探索用Rust实现程序合成的可能性&lt;/h2&gt;&lt;p&gt;该文作者受&lt;a href=&quot;https://www.cs.cornell.edu/~asampson/blog/minisynth.html&quot;&gt;程序合成是可能的&lt;/a&gt;这篇文章影响，实现了一个Rust版本。&lt;/p&gt;&lt;p&gt;程序合成是指按特定的规则自动生成程序。有一个设想，就是在未来没有程序员这一行业，有的只是设计师。设计师设计好功能，交给电脑，自动合成程序。 本文就是一种尝试。&lt;/p&gt;&lt;p&gt;现在有基于机器学习人工智能的程序合成引擎，但大家放心，还没到足以能让程序员失业的那一天。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://fitzgeraldnick.com/2018/11/15/program-synthesis-is-possible-in-rust.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://people.csail.mit.edu/asolar/manual.pdf&quot;&gt;相关论文&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/fitzgen/minisynth-rs&quot;&gt;代码实现&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「撕逼贴」Rust、Debian和librsvg&lt;/h2&gt;&lt;p&gt;在LWN社区发布的一篇新闻。Debian支持许多（CPU）架构，即使对于那些没有正式支持的架构，也有Debian Port试图填补空白。对于大多数应用程序来说，主要是为相关架构启动并运行GCC，然后构建Debian提供的所有不同软件包。但是对于需要使用Rust构建的LLVM应用程序或库构建的软件包，则变得更加复杂。最近librsvg就引起一场风波。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://lwn.net/SubscriberLink/771355/1c4ca5254f22dbdf/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Gutenberg改名为Zola并发布0.5版&lt;/h2&gt;&lt;p&gt;Rust实现的静态网站生成工具Gutenberg改成了Zola（之前的名字确实太长）。改名的原因是和Wrodpress的某个工具重名了。新名字Zola来源于 Emile Zola • 【埃米尔·左拉（法国作家）。&lt;/p&gt;&lt;p&gt;Zola名言：「生活的道路一旦选定了，就要勇敢的走下去，绝不走回头路。」&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.vincentprouillet.com/blog/releasing-zola-0-5-0/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Cranelift： 一个rustc的新编译后端&lt;/h2&gt;&lt;p&gt;当前还属于实验阶段。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/bjorn3/rustc_codegen_cranelift&quot;&gt;cranelift&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;学习资源&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;「油管」Rust中的Futures和async/await&lt;/h2&gt;&lt;p&gt;该视频长约4小时，详细介绍了Future和async/await，包括tokio等内容。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=9_3krAQtD2k&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「算法」探索航线谜题&lt;/h2&gt;&lt;p&gt;在这系列文章里，作者探索了一道算法题：航线谜题（shipping puzzle）&lt;/p&gt;&lt;p&gt;第二篇是Rust实现方案。&lt;/p&gt;&lt;p&gt;航线谜题：&lt;/p&gt;&lt;p&gt;给定一组航段（leg）集合，每条航段分别对应于一周内的一天，包括起点和终点：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;M PDX SEA （周一 PDX SEA）
T PDX SFO （周二 PDX SFO）
T SEA DEN （周二 SEA DEN）
W DEN PDX （周三 DEN PDX）
R PDX DEN （周四 PDX DEN）
F DEN JFK （周五 DEN JFK）&lt;/code&gt;&lt;p&gt;如何将以上航段划分为单个飞机的航线，受以下条件限制：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一条航段的目的地必须与下一条航段的起点相匹配&lt;/li&gt;&lt;li&gt;飞机必须持续航行（比如，一条航线不能包括：星期一 西雅图 -&amp;gt; 波特兰，然后是星期三 波特兰 -&amp;gt; 塔科马，此航线飞机在周二是闲置的。）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;满足这些限制的简单方案是，将每条航段看作是一条单独的航线，但是需要多架飞机，但是一架飞机可以连续飞行的航段也可以看作是一条航线。现在问题是，如何找到最少的路线，也就是找到最少的飞机数。在此例中，我们最少需要两条航线。一种可能的解决方案是：让一架飞机飞行PDX、SEA、DEN、PDX、DEN、JFK航线，并且第二架飞机只在周二从PDX飞到SFO。&lt;/p&gt;&lt;p&gt;这里有一个&lt;a href=&quot;https://gist.github.com/lynaghk/0c75252b455e744ed3a8a0d09b493223&quot;&gt;1w条航段的数据集&lt;/a&gt;。可以开干了。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://kevinlynagh.com/notes/shipping-puzzle/&quot;&gt;part 1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://kevinlynagh.com/notes/shipping-puzzle/part-2/&quot;&gt;part 2&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「长文」那些Rust不允许你干的事&lt;/h2&gt;&lt;p&gt;本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust Flow: 数据流与Rust中方法调用链&lt;/h2&gt;&lt;p&gt;本文探讨了Rust对实现方法调用链的支持。&lt;/p&gt;&lt;p&gt;观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://myrrlyn.net/blog/misc/rust-flow&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;如何使用&lt;code class=&quot;inline&quot;&gt;-Zprint-type-sizes&lt;/code&gt;获取Rust类型大小&lt;/h2&gt;&lt;p&gt;在编译时使用&lt;code class=&quot;inline&quot;&gt;-Zprint-type-sizes&lt;/code&gt;可以得到比&lt;code class=&quot;inline&quot;&gt;std::mem::size_of&lt;/code&gt;方法更加详细的信息。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.mozilla.org/nnethercote/2018/11/09/how-to-get-the-size-of-rust-types-with-zprint-type-sizes/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「大学课程CS242」斯坦福的Rust课程: V2版&lt;/h2&gt;&lt;p&gt;斯坦福CS242编程语言课程升级到V2版，增加了新的内容。除了Rust，还涵盖了WebAssembly。&lt;/p&gt;&lt;p&gt;在官网中有详细的课程表和slides、笔记下载。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://cs242.stanford.edu/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9wlcis/rust_in_stanfords_pl_course_v2_webassembly/&quot;&gt;Reddit&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;开始使用rs-pbrt&lt;/h2&gt;&lt;p&gt;rs_pbrt是对《Physically Based Rendering,PBRT(光线跟踪：基于物理的渲染) 》这本书中代码的Rust实现。&lt;/p&gt;&lt;p&gt;这篇文章是一个使用rs_pbrt的简单教程。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.rs-pbrt.org/blog/2018-11-16-getting-started/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/wahn/rs_pbrt&quot;&gt;rs_pbrt&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「系列文章」Pest vs Nom&lt;/h2&gt;&lt;p&gt;该作者正在编写glsl方面的库，他之前使用了nom，现在又引入了pest。然后通过写这一系列文章，来比较这两者在实践应用中的区别和定位。&lt;/p&gt;&lt;p&gt;Pest:&lt;/p&gt;&lt;p&gt;Pest在编译时使用一个文件，其中包含定义要解析的输入格式的PEG语法。PEG, 表示解析表达式语法，是一种形式语言，使你能够用规则描述自己的语言。这些规则是用一些属于语言理论的基本块编写的。如果你曾经听说过Stephen Kleene及其着名的Kleene star，你就会对PEG感到熟悉。&lt;/p&gt;&lt;p&gt;作者喜欢PEG的是，通过一组非常有限的结构，可以描述很多决定论语言。在GLSL450的情况下 - 这是glsl crate可以解析的语言 - 它是一种无上下文和确定性的语言。因此，整个语言可以根据（递归）PEG规则来定义。&lt;/p&gt;&lt;p&gt;Pest不是解析器，它应该是一种词法分析器。AST解析还需要自己来弄。也有人推荐用&lt;a href=&quot;https://github.com/pest-parser/ast&quot;&gt;pest-ast&lt;/a&gt;来处理AST。&lt;/p&gt;&lt;p&gt;Nom：&lt;/p&gt;&lt;p&gt;nom是一个解析器组合器。这意味着您可以通过组合小解析器来构建更大的解析器。关于nom的正确术语是它是一个无扫描器解析器：它不需要在解析之前生成令牌，并且更喜欢同时执行两者。 nom解析器通常使用像preceded！，delimited！，take_until！，tag！，value!和do_parse!等宏，允许匹配（lexing）切片的字节/字符，并使用你选择的类型将它们解析为实际值。&lt;/p&gt;&lt;p&gt;然而，Pest依赖于PEG文件，表示要标记的语言的正式语法。该词法分析器阶段发生并且必须能够在返回之前对整个输入进行标记。我不确定我什么时候说这个（但我很有说服力就是这种情况）：Pest不支持流输入，因为它需要吃特殊规则EOI（End Of Input ）， 或者在返回之前吃规则错误（使用先前的规则成功或向上传播错误）。但是，nom可以用来吃掉字节流。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://phaazon.net/blog/glsl-pest-part-1&quot;&gt;Part I&lt;/a&gt; &lt;a href=&quot;https://phaazon.net/blog/glsl-pest-part-2&quot;&gt;Part II&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;项目&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;Rust实现的寄存器式虚拟机&lt;/h2&gt;&lt;p&gt;大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。&lt;/p&gt;&lt;p&gt;Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。&lt;/p&gt;&lt;p&gt;感兴趣的可以关注下。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/playXE/Jazz&quot;&gt;Jazz&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;jsc：Rust实现的js编译器&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/eatonphil/jsc&quot;&gt;jsc&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;又一个JavaScript解释器&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/dherman/esprit&quot;&gt;esprit&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;将Elm架构引入Rust和WebAssembly&lt;/h2&gt;&lt;p&gt;Elm生态系统有一个架构，叫做TEA，The Elm Architecture。然后该文作者将TEA引入了Rust和WASM体系里。并且通过此实验，了解Rust和WASM在web开发方面能走多远。结论是：他想在日程工作中都能用Rust编写webapp。&lt;/p&gt;&lt;p&gt;代码实现： &lt;a href=&quot;https://github.com/sindreij/willow&quot;&gt;willow&lt;/a&gt;&lt;/p&gt;&lt;p&gt;其中还包含了两个demo。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://sindrejohansen.no/blog/willow/rust/elm/2018/11/16/willow-elm-in-rust.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「小游戏」 使用Amethyst引擎实现的经典游戏Asteroids&lt;/h2&gt;&lt;p&gt;基于Rust 2018 版本&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/udoprog/asteroids-amethyst&quot;&gt;asteroids-amethyst&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「库」typed-html： Rust模板库&lt;/h2&gt;&lt;p&gt;TypedHtml是一个带类型检查的HTML模板，现在支持了纯wasm实现的虚拟dom渲染HTML&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/bodil/typed-html&quot;&gt;typed-html&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;介绍Mundane&lt;/h2&gt;&lt;p&gt;Mundane 基于BoringSSL的Rust加密库。BoringSSL 是由谷歌从 OpenSSL 中抽出来后独立发展的作品。&lt;/p&gt;&lt;p&gt;之前新闻中介绍过该库。今天是相关开发者写博文详细介绍了Mundane的起源和实现。&lt;/p&gt;&lt;p&gt;why mundane?&lt;/p&gt;&lt;p&gt;Mundane存在的理由是提供一种难以滥用的API。经验表明，密码学中最常见的失败模式之一就是不正确的实现，并且，通常失败都发生在应用程序和加密库之间。鉴于此原因，Mundane采取的方法是为开发者提供尽可能少的自由度。做正确的事，很容易，但是想做错事，则会很困难，理想情况下完全不可能。（和Rust的理念相似，这也是他们使用Rust开发的理由）。&lt;/p&gt;&lt;p&gt;Mundane也是Google Fuchsia操作系统的主要加密库。Mundane完全依赖BoringSSL，是因为信任BoringSSL。BoringSSL团队都是密码学专家。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/google/mundane&quot;&gt;mundane&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://joshlf.com/post/2018/11/06/introducing-mundane/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「区块链」零知识证明库Bulletproofs ：pre-release版本发布&lt;/h2&gt;&lt;p&gt;预发布版本号称性能大幅提升：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;比libsecp实现快1.83倍（使用endomorphisms）;&lt;/li&gt;&lt;li&gt;比libsecp实现快2.00倍（没有endomorphisms）;&lt;/li&gt;&lt;li&gt;比Monero实施快4.63倍。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;并且还提供了干净、安全可扩展的API。&lt;/p&gt;&lt;p&gt;Bulletproofs是由斯坦福大学应用加密学小组最近发表的一篇有关于保密交易的有效范围证明的研究论文，文中提出了一种可以大幅降低区块链存储数据大小（约为十倍）的方法。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://crypto.stanford.edu/bulletproofs/&quot;&gt;基于Bulletproofs 论文&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/dalek-cryptography/bulletproofs/&quot;&gt;Bulletproofs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;是之前这个库&lt;a href=&quot;https://github.com/chain/ristretto-bulletproofs/&quot;&gt;ristretto-bulletproofs&lt;/a&gt;迁移到了新的仓库里。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/interstellar/bulletproofs-pre-release-fcb1feb36d4b&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;工具与库&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;rand库 0.6版发布&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-random/rand/blob/master/CHANGELOG.md&quot;&gt;changelog&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://rust-random.github.io/book/update-0.6.html&quot;&gt;update guide&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://rust-random.github.io/book/&quot;&gt;rand book&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Rust实现可生成3D网格的库&lt;/h2&gt;&lt;p&gt;灵感来自于structure Synth&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9y1efh/generate_3d_meshes_in_rust/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50212359/Synthesizing%20Structures%20with%20immense&quot;&gt;使用指南&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「工具」 按时区查看日志的工具&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/thecasualcoder/tztail&quot;&gt;tztail&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「小工具」检测no_std兼容性&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/hobofan/cargo-nono&quot;&gt;cargo-nono&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;lifeguard 0.6 发布&lt;/h2&gt;&lt;p&gt;lifeguard是Rust实现的一个对象池管理库，用来创建可重用的值，避免不断分配新值造成的开销。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/zslayton/lifeguard&quot;&gt;lifeguard&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-11-18-50212359</guid>
<pubDate>Sun, 18 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「演讲」平台价值观、Rust以及对系统软件的启示</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-11-18-50209719.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50209719&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-fbc87a2b1a097bcbf8c506ff3dbc94cb_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;这是Bryan Cantrill（云计算平台joyent的CTO ）在最近某次Scala大会上的分享。&lt;br&gt;&lt;br&gt;更多内容请参看 &lt;a href=&quot;https://www.slideshare.net/bcantrill/platform-values-rust-and-the-implications-for-system-software?from_action=save&quot;&gt;Slides&lt;/a&gt; &lt;/blockquote&gt;&lt;hr&gt;&lt;p&gt;选择一门编程语言，一个平台，一个操作系统，是一个重大且最重要的决定，具有持久的影响。因为你不仅仅是选择一个工具，更多的是选择它所代表的意义。&lt;/p&gt;&lt;p&gt;比如，&lt;/p&gt;&lt;p&gt;&lt;b&gt;C的平台价值观：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Interoperability「互操性」&lt;/li&gt;&lt;li&gt;Performance「性能」&lt;/li&gt;&lt;li&gt;Portability「可移植性」&lt;/li&gt;&lt;li&gt;Simplicity「简单性」&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;C++的平台价值观：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Expressiveness 「表达能力」&lt;/li&gt;&lt;li&gt;Performance 「性能」&lt;/li&gt;&lt;li&gt;Portability 「可移植性」&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;Scala的平台价值观：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Composability「可组合性」&lt;/li&gt;&lt;li&gt;Expressiveness「表达能力」&lt;/li&gt;&lt;li&gt;Interoperability「互操性」&lt;/li&gt;&lt;li&gt;Integrity「完整性」&lt;/li&gt;&lt;li&gt;Robustness「健壮性」&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;近十年来，系统软件编程语言所拥有的价值观和软件本身必须保持的价值观之间存在巨大差异。现在的系统软件已经能够提供相对安全和可靠的系统，但这一切是因为编程语言吗？不是！我们是否可以做的更好？&lt;/p&gt;&lt;p&gt;来看看Rust吧！&lt;/p&gt;&lt;p&gt;&lt;b&gt;Rust的平台价值观：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Composability 「可组合性」&lt;/li&gt;&lt;li&gt;Expressiveness 「表达能力」&lt;/li&gt;&lt;li&gt;Extensibility 「可扩展性」&lt;/li&gt;&lt;li&gt;Interoperability 「互操性」&lt;/li&gt;&lt;li&gt;Integrity 「完整性」&lt;/li&gt;&lt;li&gt;Performance 「性能」&lt;/li&gt;&lt;li&gt;Rigor 「严谨性」&lt;/li&gt;&lt;li&gt;Robustness 「健壮性」&lt;/li&gt;&lt;li&gt;Safety 「安全性」&lt;/li&gt;&lt;li&gt;Security 「安全保障」&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在此演讲中，作者还提供了三种使用Rust进行混合系统开发的方法：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Rust子系统。不要用Rust重写旧系统，Rust适合新的开发。这方面在FreeBSD里有一个示例应用。&lt;/li&gt;&lt;li&gt;Rust组件系统。传统的系统软件应用很广，而且都以组件方式发布，这里面有很多组件有问题，这正是Rust的应用之地。&lt;/li&gt;&lt;li&gt;Rust固件。操作系统之下，硬件之上的固件。可能更适合Rust。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Rust告诉我们：我们可以拥有更美好的东西。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-11-18-50209719</guid>
<pubDate>Sun, 18 Nov 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
