<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>时光与精神小屋</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Wed, 28 Nov 2018 14:27:09 +0800</lastBuildDate>
<item>
<title>「官方」演变中的Tide中间件</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-11-28-51048926.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51048926&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-67e9a14fec18c48abf4869dba6dde2da_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;Tide，是Rust官方出品的异步Web开发框架，为了构建生态标准而创建。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在上篇文章里说到，Tide借鉴了actix-web中before/after风格的中间件。然而&lt;a href=&quot;https://steemit.com/@tirr-c&quot;&gt;@tirr-c&lt;/a&gt;基于此又发现了更好的抽象方式。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;/// Middleware that wraps around remaining middleware chain.
pub trait Middleware&amp;lt;Data&amp;gt;: Send + Sync {
    /// Asynchronously handle the request, and return a response.
    fn handle&amp;lt;&#39;a&amp;gt;(&amp;amp;&#39;a self, ctx: RequestContext&amp;lt;&#39;a, Data&amp;gt;) -&amp;gt; FutureObj&amp;lt;&#39;a, Response&amp;gt;;
}&lt;/code&gt;&lt;p&gt;新的trait使用一个方便的RequestContext，封装了中间件可用的所有上下文信息。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub struct RequestContext&amp;lt;&#39;a, Data&amp;gt; {
    pub app_data: Data,
    pub req: Request,
    pub params: RouteMatch&amp;lt;&#39;a&amp;gt;,
    // plus additional, private fields
}

impl&amp;lt;&#39;a, Data: Clone + Send&amp;gt; RequestContext&amp;lt;&#39;a, Data&amp;gt; {
    /// Consume this context, and run remaining middleware chain to completion.
    pub fn next(self) -&amp;gt; FutureObj&amp;lt;&#39;a, Response&amp;gt; { ... }
}&lt;/code&gt;&lt;p&gt;在这种方法中，每个中间件都可以完全控制剩余的请求处理管道。在此接口上构建before/after的中间件构造函数很简单。但使用这种around中间件作为核心接口有一些关键的优势：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在before/after发生的步骤之间传递数据要更简单。&lt;/li&gt;&lt;li&gt;之前的方法强制为每个请求分配FutureObj，但是现在的around风格中间件只需要在执行异步工作或管道其余部分需要的时候再分配新的FutureObj&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;新的接口可以说更简单、更整洁。&lt;/p&gt;&lt;p&gt;Tide也新增了带有自定义中间件的嵌套路由。现在使用nest方法可以将中间件应用于具有公共路由的子路由里。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let mut app = App::new(your_data);

app.at(&quot;/some/prefix&quot;).nest(|r| {
    r.middleware(some_middleware);      // applies to everything under `/some/prefix`
    r.at(&quot;/&quot;).get(prefix_top_endpoint); // matches `/some/prefix`
    r.at(&quot;/foo&quot;).get(foo_endpoint);     // matches `/some/prefix/foo`
});

// no middleware is applied to this route
app.at(&quot;/&quot;).get(index_endpoint);

app.serve(address);&lt;/code&gt;&lt;p&gt;nest方法实现：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;impl&amp;lt;&#39;a, Data&amp;gt; Resource&amp;lt;&#39;a, Data&amp;gt; {
    /// &quot;Nest&quot; a subrouter to the path.
    ///
    /// This method will build a fresh `Router` and give a mutable reference to it to the builder
    /// function. Builder can set up a subrouter using the `Router`. All middleware applied inside
    /// the builder will be local to the subrouter and its descendents.
    pub fn nest(self, builder: impl FnOnce(&amp;amp;mut Router&amp;lt;Data&amp;gt;));
}&lt;/code&gt;&lt;p&gt;另外还增加了一个使用计算值的示例：&lt;a href=&quot;https://github.com/rust-net-web/tide/blob/master/examples/computed_values.rs&quot;&gt;computed_values&lt;/a&gt;&lt;/p&gt;&lt;p&gt;原文中列出了还待解决的一些问题列表，你也可以来参与。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://rust-lang-nursery.github.io/wg-net/2018/11/27/tide-middleware-evolution.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-11-28-51048926</guid>
<pubDate>Wed, 28 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「官方」Rust 2018年度调查报告</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-11-28-51018048.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51018048&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-938be19e928e7da9e957e2223c134d5f_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;原文：&lt;a href=&quot;https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html&quot;&gt;The Rust Programming Language Blog&lt;/a&gt;  &lt;/blockquote&gt;&lt;p&gt;一年一度的Rust调查报告，今年已经是第三次了。今年这份调查报告首次以多种语言推出，除英语外，一共有14种语言。非英语语言的结果占所有回复的25%。此次报告一共产生&lt;b&gt;5991个回复记录。&lt;/b&gt;在展现最终报告分析结果之前，我们想给所有花时间回应并将你的想法告诉我们的人一个大大的感谢。因为有你们的帮助，Rust才将年复一年地持续完善。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust Users &lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2f3176b25e759da6616cf7d02b7b47a3_r.jpg&quot; data-rawwidth=&quot;662&quot; data-rawheight=&quot;358&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;尽管回复的总数有所增加，但今年Rust用户的比例也同样有所增加。Rust用户占比，与去年的66.9%相比，今年占到了将近3/4。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Time with Rust&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8ad4b0c8522da223ef37ee11d5ee3653_r.jpg&quot; data-rawwidth=&quot;581&quot; data-rawheight=&quot;364&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以看到，Rust新用户源源不断。在调查时，约有23%的用户使用它3个月或更短的时间。同样，近1/4用户使用Rust至少两年。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0965735bcc5220f9bab6b82b1f96cfe1_r.jpg&quot; data-rawwidth=&quot;583&quot; data-rawheight=&quot;356&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;超过40%的用户在使用Rust不到一个月的时间内感受到了Rust的开发效率，超过70%的人在第一年感到高效。然而，用户之间存在明显差异，超过22%的人尚未对Rust感到富有成效。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-458ce501853b8e7dab39bde1027f8aaf_r.jpg&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;359&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;仔细观察那些使用Rust没有产生效果的用户，只有大约25％的用户只使用Rust不到一个月。 这里面临的挑战是找到帮助用户实现生产力的方法，以免他们陷入困境。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;How much do you use Rust?&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-833a6ad8bc02247a404f3c97def4130c_r.jpg&quot; data-rawwidth=&quot;773&quot; data-rawheight=&quot;484&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;随着整体投入的增加，Rust项目将继续趋向更大规模。 Rust的中到大投入（分别超过10k和10万行代码）。从2016年的8.9％增长到2017年的16％，今年增长到23％。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-349c4c0c97c2a5d9ff1bfddb4b2069b6_r.jpg&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;354&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们也看到了Rust常规使用量的增长。 从去年的17.5％上升到现在Rust每日使用量现已接近用户的四分之一。 总的来说，Rust每周的总使用量从60.8％上升到66.4％。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust expertise&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-580920510a3233043cbe5e6562ced8f7_r.jpg&quot; data-rawwidth=&quot;584&quot; data-rawheight=&quot;358&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust专业知识，不仅仅是一条简单的曲线，还有两个高峰：一个围绕「3」，另一个围绕「7」，这表明用户倾向于认为自己只是初学者或经验丰富，而不是专家。&lt;/p&gt;&lt;p&gt;（原问题已经关闭，忘记3和7指代的是什么了，多半是所有权相关的吧）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6edc8762e09f21e13473b212a60866c1_r.jpg&quot; data-rawwidth=&quot;676&quot; data-rawheight=&quot;422&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust用户普遍认为Enums和Cargo在很大程度上是简单的概念; 其次是迭代器，模块和trait。 接下来是更具挑战性的Trait Bounds和Unsafe概念。 最后，最具挑战性的概念是Macros，Ownership＆Borrowing和Lifetimes。 这些挑战与我们过去几年听到的反馈密切相关，并继续成为持续提高生产力的重点，如NLL和持续的宏观系统改进。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0e2a29bd4ac4069f9edcb2ec191a1e25_r.jpg&quot; data-rawwidth=&quot;581&quot; data-rawheight=&quot;353&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;幽默地说，我们发现Rust实际上并不是用户熟悉的顶级编程语言。 相反，它落后于Python，位落第二。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust toolchain&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ba0faf9866b979fff72213f6e2d24b8f_r.jpg&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;347&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们看到当前稳定版本的用户数量和去年相似。 也许令人惊讶的是，我们仍然看到在其工作流程中使用Nightly编译器的用户数量有所增加。 连续第二年，Nightly使用量持续上升，现在超过56％（高于去年的51.6％）。当被问到为什么他们使用Nightly时，人们回应的原因很多，包括：访问2018版，asm，async / await，clippy，嵌入式开发，Rocket，NLL，proc宏和wasm。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b62e84db6514c0d89f93bb2242908a1e_r.jpg&quot; data-rawwidth=&quot;963&quot; data-rawheight=&quot;584&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;在常规编译器更新期间看到breakage的人的百分比自去年以来保持不变，7.4％的人表示他们经历过breakage。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-12e6593fb098964fdf10c99a92456513_r.jpg&quot; data-rawwidth=&quot;585&quot; data-rawheight=&quot;361&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;breakage通常倾向于需要一些小的修复，尽管有些人报告说有一些中等或主要的修复程序可以升级到下一个稳定的编译器。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-57454f1484b2df14ec92519b31855957_r.jpg&quot; data-rawwidth=&quot;579&quot; data-rawheight=&quot;318&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;我们再次看到rustup的遥遥领先，它继续保持在Rust安装工具的90％。 Linux发行版以17％的速度遥遥领先。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-61fd8dcfdece8d66555ecaca55a6c529_r.jpg&quot; data-rawwidth=&quot;635&quot; data-rawheight=&quot;393&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;像rustfmt和rustdoc这样的工具有很强的表现力，有很多积极的支持。 接下来是clippy工具 - 尽管用户较少，但其用户喜欢这个工具。 IDE支持工具Rust Language Server和racer得到了积极的支持，但不幸的是，在调查的工具中，产生了一些不喜欢的投票和评论。 bindgen工具具有相对较小的用户群。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust workflow&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5e3b82e9e816ce75b60bfc0527347fa1_r.jpg&quot; data-rawwidth=&quot;589&quot; data-rawheight=&quot;349&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;Linux仍然是Rust开发人员的强大动力，占据了大约80％的Rust开发人员。 Windows的使用量从去年的31％略微增长到今年的34％，这是其连续第二年增长。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-905ace7fb667df117d890671400c64e3_r.jpg&quot; data-rawwidth=&quot;808&quot; data-rawheight=&quot;492&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;Linux和Windows继续作为Rust应用程序的目标而遥遥领先。 其他平台与去年大致相同，但有一个例外：WebAssembly。 这项新技术取得了令人瞩目的增长，从去年的13％增长到今年的24％，几乎翻了一番。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3bb61de3903d1b05cbf199cf0f0e475a_r.jpg&quot; data-rawwidth=&quot;757&quot; data-rawheight=&quot;351&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;领跑两年的Vim现在终于被VSCode击败了，VSCode从33.8％Rust开发者增长到今年的44.4％。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust at work&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fbf36f828e1bf592d3278d888c6546a7_r.jpg&quot; data-rawwidth=&quot;896&quot; data-rawheight=&quot;555&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;Rust继续在商业生产领域缓慢而稳定地增长。 我们现在看到全职和兼职Rust的同比增长，从去年4.4％的全职和16.6％的兼职增长到今年的8.9％的全职和21.2％的兼职 ，全职Rust商业用途增加一倍。 Rust的商业使用总量从Rust用户的21％增长到略高于30％。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5a92aef27ce4f5f2e6f7265bca1e92ee_r.jpg&quot; data-rawwidth=&quot;588&quot; data-rawheight=&quot;352&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust有更多的空间发展到更多的公司中，超过三分之一的用户报告目前还没有考虑在未来一年中评估Rust。 将近一半的非Rust用户需要公司支持，这表明需要进一步的公司拓展或更多关于Rust的公司信息。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Feeling welcome&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3de641b0bb462331d250d2e70c00e18c_r.jpg&quot; data-rawwidth=&quot;584&quot; data-rawheight=&quot;360&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust社区工作的一个重要部分是确保Rust项目对其用户来说是一个温馨的地方。 新用户应该感到鼓励去探索，分享想法，并且做他们自己。当被问到时，目前Rust用户和非Rust用户都受到欢迎，尽管超过四分之一的回复并不确定。 这些答复中也存在一些区域差异。 例如，对俄罗斯版本调查的回复显示，不受欢迎的感觉比例为4％。 中国大陆的增幅更高，为8％。这里有一个挑战是帮助全球的Rust社区感觉他们是Rust独特的一部分，因为Rust继续在世界更多地区发展壮大。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0625940f2b31368453116034d7abe796_r.jpg&quot; data-rawwidth=&quot;1049&quot; data-rawheight=&quot;377&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust自称为技术人员不足的人数逐年增长缓慢。 该调查还强调了一些挑战，因为女性人数仍然低于编程领域女性的行业平均水平。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust Non-Users&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-542d0c174b5bd46a97313d4c7fda4a01_r.jpg&quot; data-rawwidth=&quot;588&quot; data-rawheight=&quot;357&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;只有不到50％的人在不到一个月的时间内停止使用Rust。 同样地，大约50％离开Rust的人在停止之前设法使用它超过一个月。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cb651a46dd35f4841b508098a755afee_r.jpg&quot; data-rawwidth=&quot;994&quot; data-rawheight=&quot;607&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;许多非Rust用户表示他们确实想学习Rust，但有些因素会减慢他们的速度。 其中首先是他们工作的公司本身不使用Rust。 近一半的非Rust用户因缺乏公司支持而受阻。此外，由于Rust的感觉过于可怕或复杂，四分之一的非Rust用户因此而放慢了学习的速度。 改进Rust IDE支持的工作有所帮助（从25％降至16％），尽管我们仍然看到强烈推动非Rust用户提供更好的IDE支持。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;挑战&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;正如我们在过去几年所做的那样，我们询问您对Rust可以有哪方面改进。今年，我们在这个反馈中看到了一些熟悉的主题以及一些新的主题。今年十大主题是：&lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;需要更好的库支持&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;更好的IDE体验&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;需要更广泛地采用Rust&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;更丰富的工具和生态系统支持&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;改善学习曲线&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;需要重要的语言功能和板条箱才能稳定和支持&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;支持异步编程&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;支持GUI开发&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;更好的文档&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;改进编译时间&lt;/b&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;b&gt;今年，GUI开发支持是不断增长的新需求，表明Rust不仅在服务器上继续增长，而且人们感觉需要延伸到应用程序开发。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;“加强Rust的推广，很多人还不知道它”&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;此回复提醒我们虽然Rust在某些圈子中可能是众所周知的，但它仍有成长空间，在许多科技界，Rust可能还不为人所熟知。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;“专注于采纳教程/书籍/新手经验，将在未来几年带来好处。”&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;除了延伸内容之外，更广泛的文档将帮助更广泛的受众。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;“开发人员工具的稳定性和成熟度，使得更容易获得工作设置和调试应用程序”&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;许多人对IDE支持发表了评论，不仅指出了RLS中的不稳定性或不准确性，而且还需要更强大的IDE支持，涵盖更多领域，比如更容易调试。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;“生态系统和库的成熟。拥有一个良好的“标准”库生态系统是该语言未来的关键”&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;一个共同的主题仍然是需要推动库完成并增加用户可以使用的“标准”库集。一些评论指出，这不是维护者的错，他们已经在努力编写和发布crate，但通常更多的公司需要参与并提供商业支持。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;“开发体验和可发现性” ”&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;有些人指出，开发体验与更丰富的文档齐头并进，认为这些不是单独的概念，而是应该以统一的方法解决。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;期待&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;今年是最强的调查。它不仅是最大的社区调查，也是第一个涵盖英语以外语言的调查。 Rust继续稳步增长，并且随之而来的是，它的优势和挑战都被引入更广泛的受众。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;我们期待在2019年的规划中使用您的反馈，并且很期望看到接下来我们能把Rust带向何方。&lt;/b&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-11-28-51018048</guid>
<pubDate>Wed, 28 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「Rust每日新闻」本周精选 • 第二十一期</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-11-24-50737367.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50737367&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-308c039c05fe1f2803788cde5b0b5f1a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;前言： 从2018年开始，我每天会花1个小时关注Rust社区动态，并且在&lt;a href=&quot;http://rust.cc/&quot;&gt;Rust.CC论坛&lt;/a&gt;、&lt;a href=&quot;https://t.me/rust_daily_news&quot;&gt;tg channel&lt;/a&gt;、&lt;a href=&quot;https://steemit.com/@blackanger&quot;&gt;Steemit&lt;/a&gt;、&lt;a href=&quot;https://github.com/RustStudy/rust_daily_news&quot;&gt;GitHub&lt;/a&gt;、&lt;a href=&quot;https://www.yuque.com/chaosbot/rustnews&quot;&gt;语雀订阅&lt;/a&gt;都开通了Rust每日新闻，分享我每天的见闻，偶尔也夹杂了一些个人的观点。大半年过去了，Rust每日新闻已经成为了Rust社区群大家每天必看的内容。在这个知乎专栏里，每周会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。 2018-11-24&lt;/blockquote&gt;&lt;h2&gt;官方新闻&lt;/h2&gt;&lt;h2&gt;「官方」crates.io帐号审核措施&lt;/h2&gt;&lt;p&gt;从2019-02-28开始，需要经过验证电子邮件地址的帐号才能往crates.io发布crate。所以，之前注册帐号的，2019-02-28之前，可能会收到警告，要求你去验证注册的email地址。如果不验证，2019-02-28之后就会收到发布错误了。 crates.io承诺将保护好你的隐私。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://users.rust-lang.org/t/a-verified-email-address-will-be-required-to-publish-to-crates-io-starting-on-2019-02-28/22425&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「CLI工作组」Cli Book新发布了打包章节的第一个版本&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://rust-lang-nursery.github.io/cli-wg/tutorial/packaging.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;社区新闻&lt;/h2&gt;&lt;h2&gt;RustFest Roma大会开始了&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/hashtag/RustFest?src=hash&quot;&gt;twitter话题&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;塞萨洛尼基（希腊古城） GNOME+Rust Hackfest 活动记录&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.guillaume-gomez.fr/articles/2018-11-19+GNOME%2BRust+Hackfest+in+Thessaloniki&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;TiKV Rust Client呼吁社区开发者参与&lt;/h2&gt;&lt;p&gt;TiKV Rust Client 的RFC马上完工，现在呼吁社区开发者为其做贡献。也是一次最佳练手的机会。 当然，如果你对去PingCAP工作感兴趣的话，也许也是一次绝佳的机会。&lt;/p&gt;&lt;p&gt;如何参与？&lt;/p&gt;&lt;p&gt;开发环境配置：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;最简单的就是本机启动一个pd（Placement Driver ），然后启动一个 Tikv，都用默认的配置应该就能跑起来。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/tikv/tikv/blob/master/docs/op-guide/deploy-tikv-using-binary.md&quot;&gt;部署TiKV&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/tikv/rfcs/pull/7&quot;&gt;RFC-7&lt;/a&gt;&lt;/p&gt;&lt;p&gt;然后提交PR或Issues就可以了。&lt;/p&gt;&lt;h2&gt;RedHat发布对Rust、Go、Clang/LLVM6.0的支持计划&lt;/h2&gt;&lt;p&gt;RedHat对Rust1.29、Go1.10和Clang/LLVM6.0的可用性评估之后，现在已经将它们提升到了完全支持状态。在完全支持阶段，一些合格的重要的勘误表（RHSA）和一些选定的高优先级的错误修复表（RHBA）将会在可用时及时发布。&lt;/p&gt;&lt;p&gt;由于这些包正在快速发展阶段，RedHat将对它们提供特别的更新支持。Rust每个季度会有更新，对于LLVM和Go，则是半年一次。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://developers.redhat.com/blog/2018/11/20/support-lifecycle-for-clang-llvm-go-and-rust/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;2018 JS状态报告里提到了Rust&lt;/h2&gt;&lt;blockquote&gt; With projects like Web Assembly arriving on the scene, writing code directly in JavaScript might soon seem quaint as developers embrace languages like Rust instead.&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c9361997bcb07a8cdfabdb8308e70703_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;360&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c9361997bcb07a8cdfabdb8308e70703&quot; data-watermark-src=&quot;v2-344b01c08c09ee212695cbbc7877212a&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://2018.stateofjs.com/javascript-flavors/conclusion&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust中的泛型方法：Exonum如何从Iron迁移到Actix-Web&lt;/h2&gt;&lt;p&gt;本文是Exonum工程师记录了使用泛型编程将Iron迁移到Actix-Web框架的过程。&lt;/p&gt;&lt;p&gt;由于平台自身的增长需求，需要从同步迁移到异步，Iron是同步框架，已经无法满足需求，所以选择了actix-web。&lt;/p&gt;&lt;p&gt;他们不仅仅是迁移Web框架，更重要的是，重新设计新的API体系。本文较长，其中详细给出了如何利用泛型编程对API进行设计的思考，感兴趣的可以看看。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/meetbitfury/generic-methods-in-rust-how-exonum-shifted-from-iron-to-actix-web-7a2752171388&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;学习资源&lt;/h2&gt;&lt;h2&gt;使用Rust为PostgreSQL编写扩展函数&lt;/h2&gt;&lt;p&gt;作者提供了一个库pgxr，可以方便地使用该库提供的宏来编写postgresql的扩展函数&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/clia/pgxr&quot;&gt;pgxr&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9y2yjq/write_postgresql_extension_functions_as_stored/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;无等待线程本地存储&lt;/h2&gt;&lt;p&gt;本文介绍了一种无等待线程本地存储。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://bzim.gitlab.io/blog/posts/wait-free-per-object-thread-local-storage.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;PHP中运行WASM&lt;/h2&gt;&lt;p&gt;用C语言编写的PHP扩展，通过FFI调用Rust lib，用wasmi来执行wasm。 只是一个POC版本！&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/paritytech/wasmi&quot;&gt;wasmi&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Hywan/php-ext-wasm&quot;&gt;php-ext-wasm&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9y7wl6/run_wasm_in_php_natively_php_extension_written_in/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「教程」Rust中的编译时Features Flag&lt;/h2&gt;&lt;p&gt;Features Flag用于启用或禁用features的配置。本文讲解了如何在项目里使用它。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.worthe-it.co.za/programming/2018/11/18/compile-time-feature-flags-in-rust.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这篇文章是作者参加一个2018 塔防游戏机器人大赛过程中总结出来的。&lt;/p&gt;&lt;p&gt;也是用Rust实现，源码： &lt;a href=&quot;https://github.com/JWorthe/entelect-challenge-tower-defence&quot;&gt;entelect-challenge-tower-defence&lt;/a&gt;&lt;/p&gt;&lt;p&gt;游戏官网： &lt;a href=&quot;https://challenge.entelect.co.za/&quot;&gt;challenge.entelect.co.za/&lt;/a&gt; ，好像挺好玩。&lt;/p&gt;&lt;h2&gt;使用Pest实现EBNF语法&lt;/h2&gt;&lt;p&gt;作者在实现一个XML解析器，这篇文章记录了使用Pest来实现使用EBNF-esque形式的词法分析器。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/compenguy/xml-grimoire&quot;&gt;xml-grimoire&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://compenguy.github.io/hobbies/rust/ebnf-to-pest.html&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「演讲」ADC&#39;18大会:  Rust音频编程&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9z4z9o/adc18_introduction_to_rust_for_audio_programming/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/irh/freeverb-rs&quot;&gt;freeverb-rs&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust+WASM实现的小程序&lt;/h2&gt;&lt;p&gt;群友@JiaYe 使用Rust和WASM实现了Gif图片制作的小程序。&lt;/p&gt;&lt;p&gt;让小程序加载wasm模块，还需要做一些针对性修改，可以在该源码里看到。感兴趣的可以看看。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/planet0104/miniprogram-gifmaker/blob/master/README.md&quot;&gt;miniprogram-gifmaker&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;项目&lt;/h2&gt;&lt;h2&gt;建立在mio之上的网络库：Sonr&lt;/h2&gt;&lt;p&gt;相比于Tokio来说，更加轻量。但不晓得是不是玩票之作，至少可以满足学习的需求。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/hagsteel/sonr&quot;&gt;sonr&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;TypedHtml: 带类型检查的JSX模板&lt;/h2&gt;&lt;p&gt;这个库上次（前几天）介绍还是100左右的star，现在已经上升到800多star了。也增加了Readme说明。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/bodil/typed-html&quot;&gt;typed-html&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Vulkano：Vulkan API的Rust安全绑定&lt;/h2&gt;&lt;blockquote&gt; Vulkan是由Khronos Group组织（知道OpenGL的话应该都听过这个组织）提供的一个新型的图形接口，它对现代图形显卡做了一个更好的抽象。跟现有的图形接口例如OpenGL和DirectX相比，Vulkan的性能更加强劲，驱动表现更加符合预期行为。Vulkan背后的设计思路跟 Direct3D 12 和 Metal 类似，但它具有跨平台的优势，可以让你同时在windows，linux和android上进行开发。 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/26938967&quot;&gt;来源&lt;/a&gt;&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://vulkano.rs/guide/acquire-present&quot;&gt;vulkano教程&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://vulkano.rs/&quot;&gt;vulkano.rs&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;用Rust实现ecmascript 2019 parser和ast visitor&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/swc-project/swc&quot;&gt;swc&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/swc-project/swc/blob/c816d699ca57fc50ff272dde8e441e15ecc093ac/ecmascript/parser/Cargo.toml&quot;&gt;swc_ecma_parser&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9yqufy/javascript_parser_and_ast_visitor_written_in_rust/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;wasmer: 高性能WASM JIT解释器&lt;/h2&gt;&lt;p&gt;基于Cranelift 代码生成引擎实现的。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/WAFoundation/wasmer&quot;&gt;wasmer&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;quinn : Rust实现的QUIC协议&lt;/h2&gt;&lt;p&gt;也就是HTTP3，这两天火了呢。&lt;/p&gt;&lt;p&gt;注意看项目Readme，有相关演讲。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/djc/quinn&quot;&gt;quinn&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「嵌入式」 Rust实现的闹钟&lt;/h2&gt;&lt;p&gt;纯Rust打造的DIY液晶闹钟，很酷。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/TeXitoi/rusty-clock&quot;&gt;rusty-clock&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;pijul 0.11发布&lt;/h2&gt;&lt;p&gt;pijul是基于Rust实现的类Git版本控制工具，&lt;a href=&quot;https://jneem.github.io/pijul/&quot;&gt;用法介绍&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://pijul.org/posts/2018-11-20-pijul-0.11/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;amp: 类Vim的终端文本编辑器&lt;/h2&gt;&lt;p&gt;这个库最近在GitHub趋势榜上升很快，最近几天发布了0.5.2版本。使用Vim的核心的交互模型，但是对其做了简化。其内部结构（工具集）已经独立为scribe库，包含数据结构、语法高亮、工作空间管理等功能。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/jmacdonald/amp&quot;&gt;amp&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/jmacdonald/scribe&quot;&gt;scribe&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;drone: Rust无人机项目&lt;/h2&gt;&lt;p&gt;四轴飞行器&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/martindeegan/drone&quot;&gt;drone&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Proptest：Rust实现的属性测试框架&lt;/h2&gt;&lt;p&gt;Proptest受Python Hypotheis测试框架启发，而Hypotheis是由Haskell的QuickCheck包启发而成的。&lt;/p&gt;&lt;p&gt;本质上它是用来产生测试数据的，但是它会注意到内存泄露以及越界等会使测试崩溃的问题，因而，在某种程度上它可以为你编写单元测试。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/AltSysrq/proptest&quot;&gt;proptest&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;工具与库&lt;/h2&gt;&lt;h2&gt;Wither 0.6发布&lt;/h2&gt;&lt;p&gt;wither是为Mongodb编写的Rust驱动。可以参考宣传文章，有更多介绍。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/thedodd/wither&quot;&gt;wither&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://medium.com/docql/https-medium-com-docql-rust-mongodb-wither-13e803c9ae72&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;命令行HTTP客户端&lt;/h2&gt;&lt;p&gt;一个Rust实现的类crul命令行http客户端，灵感来自于Python的HTTPie&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://gitlab.com/rakenodiax/rust-client&quot;&gt;rust_client&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-11-24-50737367</guid>
<pubDate>Sat, 24 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「Rust每日新闻」本周精选 • 第二十期</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-11-18-50212359.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50212359&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-308c039c05fe1f2803788cde5b0b5f1a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;前言： 从2018年开始，我每天会花1个小时关注Rust社区动态，并且在&lt;a href=&quot;http://rust.cc/&quot;&gt;Rust.CC论坛&lt;/a&gt;、&lt;a href=&quot;https://t.me/rust_daily_news&quot;&gt;tg channel&lt;/a&gt;、&lt;a href=&quot;https://steemit.com/@blackanger&quot;&gt;Steemit&lt;/a&gt;、&lt;a href=&quot;https://github.com/RustStudy/rust_daily_news&quot;&gt;GitHub&lt;/a&gt;、&lt;a href=&quot;https://www.yuque.com/chaosbot/rustnews&quot;&gt;语雀订阅&lt;/a&gt;都开通了Rust每日新闻，分享我每天的见闻，偶尔也夹杂了一些个人的观点。大半年过去了，Rust每日新闻已经成为了Rust社区群大家每天必看的内容。在这个知乎专栏里，每周会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。 2018-11-18&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;官方新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;「官方」await语法方面的进展&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49440981&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「嵌入式工作组」嵌入式Rust年度回顾&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49921783&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「官方」如何检测Unsafe代码中的UB&lt;/h2&gt;&lt;p&gt;ralfj比较高产，他负责Unsafe下内存模型相关的工作，目的是用miri来检测unsafe中的UB行为。&lt;/p&gt;&lt;p&gt;该模型用于定义在unsafe内存模型中允许哪种别名。建立合理的别名规则，才能基于miri来检查unsafe下的UB行为。&lt;/p&gt;&lt;p&gt;该模型的核心思想是： 对于一个内存位置，逐步建立可跟踪的引用，形成一个栈结构。比如有一个&amp;amp;mut i32，可以对其重新借用获得一个新引用。这个新引用是必须用于此位置的引用，建立在旧引用之上。当新引用过期的时候，旧引用会被激活，就好像是栈结构push和pop。&lt;/p&gt;&lt;p&gt;在今天这篇文章中，ralfj写了实现上述模型的进展。&lt;/p&gt;&lt;p&gt;在Safe Rust中，通常有借用检查来保护内存。但是在编写Unsafe代码的时候，借用检查就无法提供帮助了。所以，Rust核心团队就必须要定义一组规则，即使对于Unsafe代码来说也是非常有意义的。在本篇文章中，ralfj会再次解释这些规则，但是和上次的有所不同，因为ralfj在这三个月对栈式借用实现的过程中，对这些规则理解更深了&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html&quot;&gt;前篇：栈式借用模型&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/nikomatsakis/rust-memory-model/issues/26&quot;&gt;关于别名规则issues&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;社区新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;Rust与游戏开发&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50066484&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「安全呼吁」互联网存在一个巨大的C/C++安全隐患&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50069980&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「演讲」平台价值观、Rust以及对系统软件的启示&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50209719&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;GitHub上Rust颜色变更事件&lt;/h2&gt;&lt;p&gt;之前有人修改了Rust的颜色，并给出了修改的理由：&lt;/p&gt;&lt;blockquote&gt; The Rust color on GitHub doesn&#39;t look much like rust, and I don&#39;t see where it could have come from (not on the website or part of the logo). In fact, it looks rather pale and sickly, rather than vibrant and robust.&lt;br&gt; a62c00 is much nicer. It resembles the red paints that have traditionally been made with iron oxide.&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;作者认为，新颜色是正宗氧化铁的颜色，应该改成这个。其实我比较喜欢新颜色，像「血液」的颜色，也可以赋予其象征意义：「热血」、「新鲜血液」&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/github/linguist/pull/4319&quot;&gt;肇事者PR&lt;/a&gt;&lt;/p&gt;&lt;p&gt;但是引起了Rust社区的强烈反响，之后linguist项目的维护者不得不将颜色又改了回去，还向社区道了歉。&lt;/p&gt;&lt;p&gt;所以，如果你在GitHub上要是搜Rust项目，发现存在两种颜色的时候，不要惊讶。&lt;/p&gt;&lt;h2&gt;「RustRush 2018」莫斯科举办的国际Rust大会&lt;/h2&gt;&lt;p&gt;看来战斗民族也挺喜欢Rust。最近国际上的其他Rust大会：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Rome at @RustFest Nov 23-28&lt;/li&gt;&lt;li&gt;Cologne at @RustCologne Dec 5&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://www.papercall.io/rustrush&quot;&gt;rustrush&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9we3oe/rustrush_2018_the_rust_conference_in_moscow/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust如何帮助Kentik提升性能&lt;/h2&gt;&lt;p&gt;美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：&lt;/p&gt;&lt;blockquote&gt; Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于&lt;a href=&quot;http://crates.io&quot;&gt;http://crates.io&lt;/a&gt;上可用的强大的开源库生态系统。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。&lt;/p&gt;&lt;p&gt;这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。&lt;/p&gt;&lt;p&gt;所以，你如果对Rust感兴趣，赶紧试试吧。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik&#39;s-performance-on-high/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;如何跟踪async/await进展状态&lt;/h2&gt;&lt;p&gt;这篇reddit帖子评论区罗列出了async/await相关的issues、pr等，可以关注async/await的进展&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9wrtgs/asyncawait_status_and_tracking/&quot;&gt;Reddit讨论&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「Cpp 2018」在Clang中实现C++ Core Guidelines生命周期安全&lt;/h2&gt;&lt;p&gt;对CPP熟悉的朋友可以关注下，也许通过该视频可以对Rust的生命周期有更深入的理解。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=sjnp3P9x5jA&quot;&gt;youtube&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;探索用Rust实现程序合成的可能性&lt;/h2&gt;&lt;p&gt;该文作者受&lt;a href=&quot;https://www.cs.cornell.edu/~asampson/blog/minisynth.html&quot;&gt;程序合成是可能的&lt;/a&gt;这篇文章影响，实现了一个Rust版本。&lt;/p&gt;&lt;p&gt;程序合成是指按特定的规则自动生成程序。有一个设想，就是在未来没有程序员这一行业，有的只是设计师。设计师设计好功能，交给电脑，自动合成程序。 本文就是一种尝试。&lt;/p&gt;&lt;p&gt;现在有基于机器学习人工智能的程序合成引擎，但大家放心，还没到足以能让程序员失业的那一天。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://fitzgeraldnick.com/2018/11/15/program-synthesis-is-possible-in-rust.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://people.csail.mit.edu/asolar/manual.pdf&quot;&gt;相关论文&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/fitzgen/minisynth-rs&quot;&gt;代码实现&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「撕逼贴」Rust、Debian和librsvg&lt;/h2&gt;&lt;p&gt;在LWN社区发布的一篇新闻。Debian支持许多（CPU）架构，即使对于那些没有正式支持的架构，也有Debian Port试图填补空白。对于大多数应用程序来说，主要是为相关架构启动并运行GCC，然后构建Debian提供的所有不同软件包。但是对于需要使用Rust构建的LLVM应用程序或库构建的软件包，则变得更加复杂。最近librsvg就引起一场风波。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://lwn.net/SubscriberLink/771355/1c4ca5254f22dbdf/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Gutenberg改名为Zola并发布0.5版&lt;/h2&gt;&lt;p&gt;Rust实现的静态网站生成工具Gutenberg改成了Zola（之前的名字确实太长）。改名的原因是和Wrodpress的某个工具重名了。新名字Zola来源于 Emile Zola • 【埃米尔·左拉（法国作家）。&lt;/p&gt;&lt;p&gt;Zola名言：「生活的道路一旦选定了，就要勇敢的走下去，绝不走回头路。」&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.vincentprouillet.com/blog/releasing-zola-0-5-0/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Cranelift： 一个rustc的新编译后端&lt;/h2&gt;&lt;p&gt;当前还属于实验阶段。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/bjorn3/rustc_codegen_cranelift&quot;&gt;cranelift&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;学习资源&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;「油管」Rust中的Futures和async/await&lt;/h2&gt;&lt;p&gt;该视频长约4小时，详细介绍了Future和async/await，包括tokio等内容。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=9_3krAQtD2k&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「算法」探索航线谜题&lt;/h2&gt;&lt;p&gt;在这系列文章里，作者探索了一道算法题：航线谜题（shipping puzzle）&lt;/p&gt;&lt;p&gt;第二篇是Rust实现方案。&lt;/p&gt;&lt;p&gt;航线谜题：&lt;/p&gt;&lt;p&gt;给定一组航段（leg）集合，每条航段分别对应于一周内的一天，包括起点和终点：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;M PDX SEA （周一 PDX SEA）
T PDX SFO （周二 PDX SFO）
T SEA DEN （周二 SEA DEN）
W DEN PDX （周三 DEN PDX）
R PDX DEN （周四 PDX DEN）
F DEN JFK （周五 DEN JFK）&lt;/code&gt;&lt;p&gt;如何将以上航段划分为单个飞机的航线，受以下条件限制：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一条航段的目的地必须与下一条航段的起点相匹配&lt;/li&gt;&lt;li&gt;飞机必须持续航行（比如，一条航线不能包括：星期一 西雅图 -&amp;gt; 波特兰，然后是星期三 波特兰 -&amp;gt; 塔科马，此航线飞机在周二是闲置的。）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;满足这些限制的简单方案是，将每条航段看作是一条单独的航线，但是需要多架飞机，但是一架飞机可以连续飞行的航段也可以看作是一条航线。现在问题是，如何找到最少的路线，也就是找到最少的飞机数。在此例中，我们最少需要两条航线。一种可能的解决方案是：让一架飞机飞行PDX、SEA、DEN、PDX、DEN、JFK航线，并且第二架飞机只在周二从PDX飞到SFO。&lt;/p&gt;&lt;p&gt;这里有一个&lt;a href=&quot;https://gist.github.com/lynaghk/0c75252b455e744ed3a8a0d09b493223&quot;&gt;1w条航段的数据集&lt;/a&gt;。可以开干了。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://kevinlynagh.com/notes/shipping-puzzle/&quot;&gt;part 1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://kevinlynagh.com/notes/shipping-puzzle/part-2/&quot;&gt;part 2&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「长文」那些Rust不允许你干的事&lt;/h2&gt;&lt;p&gt;本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust Flow: 数据流与Rust中方法调用链&lt;/h2&gt;&lt;p&gt;本文探讨了Rust对实现方法调用链的支持。&lt;/p&gt;&lt;p&gt;观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://myrrlyn.net/blog/misc/rust-flow&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;如何使用&lt;code class=&quot;inline&quot;&gt;-Zprint-type-sizes&lt;/code&gt;获取Rust类型大小&lt;/h2&gt;&lt;p&gt;在编译时使用&lt;code class=&quot;inline&quot;&gt;-Zprint-type-sizes&lt;/code&gt;可以得到比&lt;code class=&quot;inline&quot;&gt;std::mem::size_of&lt;/code&gt;方法更加详细的信息。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.mozilla.org/nnethercote/2018/11/09/how-to-get-the-size-of-rust-types-with-zprint-type-sizes/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「大学课程CS242」斯坦福的Rust课程: V2版&lt;/h2&gt;&lt;p&gt;斯坦福CS242编程语言课程升级到V2版，增加了新的内容。除了Rust，还涵盖了WebAssembly。&lt;/p&gt;&lt;p&gt;在官网中有详细的课程表和slides、笔记下载。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://cs242.stanford.edu/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9wlcis/rust_in_stanfords_pl_course_v2_webassembly/&quot;&gt;Reddit&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;开始使用rs-pbrt&lt;/h2&gt;&lt;p&gt;rs_pbrt是对《Physically Based Rendering,PBRT(光线跟踪：基于物理的渲染) 》这本书中代码的Rust实现。&lt;/p&gt;&lt;p&gt;这篇文章是一个使用rs_pbrt的简单教程。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.rs-pbrt.org/blog/2018-11-16-getting-started/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/wahn/rs_pbrt&quot;&gt;rs_pbrt&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「系列文章」Pest vs Nom&lt;/h2&gt;&lt;p&gt;该作者正在编写glsl方面的库，他之前使用了nom，现在又引入了pest。然后通过写这一系列文章，来比较这两者在实践应用中的区别和定位。&lt;/p&gt;&lt;p&gt;Pest:&lt;/p&gt;&lt;p&gt;Pest在编译时使用一个文件，其中包含定义要解析的输入格式的PEG语法。PEG, 表示解析表达式语法，是一种形式语言，使你能够用规则描述自己的语言。这些规则是用一些属于语言理论的基本块编写的。如果你曾经听说过Stephen Kleene及其着名的Kleene star，你就会对PEG感到熟悉。&lt;/p&gt;&lt;p&gt;作者喜欢PEG的是，通过一组非常有限的结构，可以描述很多决定论语言。在GLSL450的情况下 - 这是glsl crate可以解析的语言 - 它是一种无上下文和确定性的语言。因此，整个语言可以根据（递归）PEG规则来定义。&lt;/p&gt;&lt;p&gt;Pest不是解析器，它应该是一种词法分析器。AST解析还需要自己来弄。也有人推荐用&lt;a href=&quot;https://github.com/pest-parser/ast&quot;&gt;pest-ast&lt;/a&gt;来处理AST。&lt;/p&gt;&lt;p&gt;Nom：&lt;/p&gt;&lt;p&gt;nom是一个解析器组合器。这意味着您可以通过组合小解析器来构建更大的解析器。关于nom的正确术语是它是一个无扫描器解析器：它不需要在解析之前生成令牌，并且更喜欢同时执行两者。 nom解析器通常使用像preceded！，delimited！，take_until！，tag！，value!和do_parse!等宏，允许匹配（lexing）切片的字节/字符，并使用你选择的类型将它们解析为实际值。&lt;/p&gt;&lt;p&gt;然而，Pest依赖于PEG文件，表示要标记的语言的正式语法。该词法分析器阶段发生并且必须能够在返回之前对整个输入进行标记。我不确定我什么时候说这个（但我很有说服力就是这种情况）：Pest不支持流输入，因为它需要吃特殊规则EOI（End Of Input ）， 或者在返回之前吃规则错误（使用先前的规则成功或向上传播错误）。但是，nom可以用来吃掉字节流。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://phaazon.net/blog/glsl-pest-part-1&quot;&gt;Part I&lt;/a&gt; &lt;a href=&quot;https://phaazon.net/blog/glsl-pest-part-2&quot;&gt;Part II&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;项目&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;Rust实现的寄存器式虚拟机&lt;/h2&gt;&lt;p&gt;大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。&lt;/p&gt;&lt;p&gt;Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。&lt;/p&gt;&lt;p&gt;感兴趣的可以关注下。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/playXE/Jazz&quot;&gt;Jazz&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;jsc：Rust实现的js编译器&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/eatonphil/jsc&quot;&gt;jsc&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;又一个JavaScript解释器&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/dherman/esprit&quot;&gt;esprit&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;将Elm架构引入Rust和WebAssembly&lt;/h2&gt;&lt;p&gt;Elm生态系统有一个架构，叫做TEA，The Elm Architecture。然后该文作者将TEA引入了Rust和WASM体系里。并且通过此实验，了解Rust和WASM在web开发方面能走多远。结论是：他想在日程工作中都能用Rust编写webapp。&lt;/p&gt;&lt;p&gt;代码实现： &lt;a href=&quot;https://github.com/sindreij/willow&quot;&gt;willow&lt;/a&gt;&lt;/p&gt;&lt;p&gt;其中还包含了两个demo。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://sindrejohansen.no/blog/willow/rust/elm/2018/11/16/willow-elm-in-rust.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「小游戏」 使用Amethyst引擎实现的经典游戏Asteroids&lt;/h2&gt;&lt;p&gt;基于Rust 2018 版本&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/udoprog/asteroids-amethyst&quot;&gt;asteroids-amethyst&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「库」typed-html： Rust模板库&lt;/h2&gt;&lt;p&gt;TypedHtml是一个带类型检查的HTML模板，现在支持了纯wasm实现的虚拟dom渲染HTML&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/bodil/typed-html&quot;&gt;typed-html&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;介绍Mundane&lt;/h2&gt;&lt;p&gt;Mundane 基于BoringSSL的Rust加密库。BoringSSL 是由谷歌从 OpenSSL 中抽出来后独立发展的作品。&lt;/p&gt;&lt;p&gt;之前新闻中介绍过该库。今天是相关开发者写博文详细介绍了Mundane的起源和实现。&lt;/p&gt;&lt;p&gt;why mundane?&lt;/p&gt;&lt;p&gt;Mundane存在的理由是提供一种难以滥用的API。经验表明，密码学中最常见的失败模式之一就是不正确的实现，并且，通常失败都发生在应用程序和加密库之间。鉴于此原因，Mundane采取的方法是为开发者提供尽可能少的自由度。做正确的事，很容易，但是想做错事，则会很困难，理想情况下完全不可能。（和Rust的理念相似，这也是他们使用Rust开发的理由）。&lt;/p&gt;&lt;p&gt;Mundane也是Google Fuchsia操作系统的主要加密库。Mundane完全依赖BoringSSL，是因为信任BoringSSL。BoringSSL团队都是密码学专家。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/google/mundane&quot;&gt;mundane&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://joshlf.com/post/2018/11/06/introducing-mundane/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「区块链」零知识证明库Bulletproofs ：pre-release版本发布&lt;/h2&gt;&lt;p&gt;预发布版本号称性能大幅提升：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;比libsecp实现快1.83倍（使用endomorphisms）;&lt;/li&gt;&lt;li&gt;比libsecp实现快2.00倍（没有endomorphisms）;&lt;/li&gt;&lt;li&gt;比Monero实施快4.63倍。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;并且还提供了干净、安全可扩展的API。&lt;/p&gt;&lt;p&gt;Bulletproofs是由斯坦福大学应用加密学小组最近发表的一篇有关于保密交易的有效范围证明的研究论文，文中提出了一种可以大幅降低区块链存储数据大小（约为十倍）的方法。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://crypto.stanford.edu/bulletproofs/&quot;&gt;基于Bulletproofs 论文&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/dalek-cryptography/bulletproofs/&quot;&gt;Bulletproofs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;是之前这个库&lt;a href=&quot;https://github.com/chain/ristretto-bulletproofs/&quot;&gt;ristretto-bulletproofs&lt;/a&gt;迁移到了新的仓库里。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/interstellar/bulletproofs-pre-release-fcb1feb36d4b&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;工具与库&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;rand库 0.6版发布&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-random/rand/blob/master/CHANGELOG.md&quot;&gt;changelog&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://rust-random.github.io/book/update-0.6.html&quot;&gt;update guide&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://rust-random.github.io/book/&quot;&gt;rand book&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Rust实现可生成3D网格的库&lt;/h2&gt;&lt;p&gt;灵感来自于structure Synth&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9y1efh/generate_3d_meshes_in_rust/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50212359/Synthesizing%20Structures%20with%20immense&quot;&gt;使用指南&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「工具」 按时区查看日志的工具&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/thecasualcoder/tztail&quot;&gt;tztail&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「小工具」检测no_std兼容性&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/hobofan/cargo-nono&quot;&gt;cargo-nono&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;lifeguard 0.6 发布&lt;/h2&gt;&lt;p&gt;lifeguard是Rust实现的一个对象池管理库，用来创建可重用的值，避免不断分配新值造成的开销。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/zslayton/lifeguard&quot;&gt;lifeguard&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-11-18-50212359</guid>
<pubDate>Sun, 18 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「演讲」平台价值观、Rust以及对系统软件的启示</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-11-18-50209719.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50209719&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-fbc87a2b1a097bcbf8c506ff3dbc94cb_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;这是Bryan Cantrill（云计算平台joyent的CTO ）在最近某次Scala大会上的分享。&lt;br&gt;&lt;br&gt;更多内容请参看 &lt;a href=&quot;https://www.slideshare.net/bcantrill/platform-values-rust-and-the-implications-for-system-software?from_action=save&quot;&gt;Slides&lt;/a&gt; &lt;/blockquote&gt;&lt;hr&gt;&lt;p&gt;选择一门编程语言，一个平台，一个操作系统，是一个重大且最重要的决定，具有持久的影响。因为你不仅仅是选择一个工具，更多的是选择它所代表的意义。&lt;/p&gt;&lt;p&gt;比如，&lt;/p&gt;&lt;p&gt;&lt;b&gt;C的平台价值观：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Interoperability「互操性」&lt;/li&gt;&lt;li&gt;Performance「性能」&lt;/li&gt;&lt;li&gt;Portability「可移植性」&lt;/li&gt;&lt;li&gt;Simplicity「简单性」&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;C++的平台价值观：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Expressiveness 「表达能力」&lt;/li&gt;&lt;li&gt;Performance 「性能」&lt;/li&gt;&lt;li&gt;Portability 「可移植性」&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;Scala的平台价值观：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Composability「可组合性」&lt;/li&gt;&lt;li&gt;Expressiveness「表达能力」&lt;/li&gt;&lt;li&gt;Interoperability「互操性」&lt;/li&gt;&lt;li&gt;Integrity「完整性」&lt;/li&gt;&lt;li&gt;Robustness「健壮性」&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;近十年来，系统软件编程语言所拥有的价值观和软件本身必须保持的价值观之间存在巨大差异。现在的系统软件已经能够提供相对安全和可靠的系统，但这一切是因为编程语言吗？不是！我们是否可以做的更好？&lt;/p&gt;&lt;p&gt;来看看Rust吧！&lt;/p&gt;&lt;p&gt;&lt;b&gt;Rust的平台价值观：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Composability 「可组合性」&lt;/li&gt;&lt;li&gt;Expressiveness 「表达能力」&lt;/li&gt;&lt;li&gt;Extensibility 「可扩展性」&lt;/li&gt;&lt;li&gt;Interoperability 「互操性」&lt;/li&gt;&lt;li&gt;Integrity 「完整性」&lt;/li&gt;&lt;li&gt;Performance 「性能」&lt;/li&gt;&lt;li&gt;Rigor 「严谨性」&lt;/li&gt;&lt;li&gt;Robustness 「健壮性」&lt;/li&gt;&lt;li&gt;Safety 「安全性」&lt;/li&gt;&lt;li&gt;Security 「安全保障」&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在此演讲中，作者还提供了三种使用Rust进行混合系统开发的方法：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Rust子系统。不要用Rust重写旧系统，Rust适合新的开发。这方面在FreeBSD里有一个示例应用。&lt;/li&gt;&lt;li&gt;Rust组件系统。传统的系统软件应用很广，而且都以组件方式发布，这里面有很多组件有问题，这正是Rust的应用之地。&lt;/li&gt;&lt;li&gt;Rust固件。操作系统之下，硬件之上的固件。可能更适合Rust。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Rust告诉我们：我们可以拥有更美好的东西。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-11-18-50209719</guid>
<pubDate>Sun, 18 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「安全呼吁」互联网存在一个巨大的C/C++安全隐患</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-11-16-50069980.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50069980&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-a186da867b92db608fd9b4cd64ba5f3f_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;心脏滴血(heartbleed)、欲哭无泪(wannacry)、价值百万美刀的iPhone漏洞(FBI支付90万美刀给黑客，只为了破解一台iphone/ 安全机构悬赏100w刀找iOS漏洞)，它们之间有什么共同之处？&lt;br&gt;&lt;br&gt;&lt;a href=&quot;https://motherboard.vice.com/en_us/article/a3mgxb/the-internet-has-a-huge-cc-problem-and-developers-dont-want-to-deal-with-it?utm_source=reddit.com&quot;&gt;Read More&lt;/a&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;该文作者是Mozilla的软件安全工程师Alex，曾经担任过美国数字服务的软件工程师。同时也是Python和Django软件基金会董事会成员。&lt;/p&gt;&lt;p&gt;一个Bug影响iPhone、windows（wanncry）和Linux服务器（heartbleed），看似没什么关联，实际上，这些漏洞的产生，都是同一个原因：内存不安全。而当今互联网上，造成内存不安全的主要语言是C/C++。&lt;/p&gt;&lt;p&gt;缓冲区溢出漏洞、类型混淆、使用释放内存、使用未初始化内存等问题，共同构成了当今互联网基础设施（Windows、Android、iOS、Chrome、Firefox等）中漏洞的温床。作者花费大约一年多时间来跟踪这些项目的安全，发现这些产品中几乎超过一半的漏洞都是内存不安全引起的。更令人不安的是，高危的漏洞（导致远程执行代码的漏洞）几乎总是因为内存不安全。比如被广泛使用的图片处理库ImageMagick和GraphicsMagic，作者就发现了400个内存不安全漏洞。&lt;/p&gt;&lt;p&gt;当然，造成这些主要是因为历史原因。很多重要的互联网安全软件都是老产品。但是作者为了改善这种现状也提出了以下一些建议：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在选择语言的时候，首要标准应该考虑「这种选择将如何影响软件的安全性？」&lt;/li&gt;&lt;li&gt;Rust、Swift等现代语言都是内存安全的，可供选择。但是选择Rust的公司比较多，Google、Dropbox、Facebook等都在用Rust。&lt;/li&gt;&lt;li&gt;需要量化内存安全造成的损害程度。可以参考CVE数据库。&lt;/li&gt;&lt;li&gt;需要投入资源研究如何更好地将大型软件项目迁移到内存安全的语言。&lt;/li&gt;&lt;li&gt;将软件工程文化的重心向安全性转移。比如从大学教学、培训机构教学，应该让学生认识到安全的重要性。&lt;/li&gt;&lt;li&gt;内存不安全是目前互联网最大的祸害。还需要投入工程研究，以便作出更好的工具来改善计算机安全性。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-11-16-50069980</guid>
<pubDate>Fri, 16 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust与游戏开发</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-11-16-50066484.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50066484&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-55efcbd3c03382f60f61765dff886379_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;该文作者通过这篇文章阐述了当前游戏开发中存在的一些问题，并且建议Rust官方团队启动建立「游戏工作组」来进一步完善以Rust作为游戏开发首选语言的生态系统。&lt;br&gt;&lt;br&gt;&lt;a href=&quot;https://alexene.github.io/2018/11/15/Rust-and-game-development.html&quot;&gt;Read More&lt;/a&gt; &lt;/blockquote&gt;&lt;p&gt;当前比较知名的游戏开发商， &lt;a href=&quot;https://www.rust-lang.org/pdfs/Rust-Chucklefish-Whitepaper.pdf&quot;&gt;Chucklefish&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/repi/status/1060469377500274689&quot;&gt;Embark Studios&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/andreapessino/status/1021532074153394176?lang=en&quot;&gt;Ready at Dawn&lt;/a&gt;，都宣布使用Rust作为游戏开发的主要语言。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;什么是游戏开发？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;游戏由复杂的系统组成。游戏对性能的要求很高，即使忽略渲染，还需要做物理、动画、各种游戏系统、AI、寻路等，这些事情都需要在一瞬间完成。这也是C++成为游戏引擎开发语言首选的原因。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;存在的问题？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;主要有两大类问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;重量级引擎。&lt;/b&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;目前市面上的引擎，由Ubisoft，DICE，Epic，Unity，Lumberyard等公司创建了各种重量级的引擎。大多数是C编写的，并且都不太关心ABI的兼容性。所以，这就导致这些引擎和Rust的通信不太理想。并不是说，需要解决Rust和C的绑定问题。&lt;/p&gt;&lt;p&gt;重量级引擎也关心性能，玩家希望在AAA游戏世界中能做更多的事情。为了满足这种期望，很多优化的工作就被放到数据结构布局、SIMD、自定义内存分配器等等当中。这些优化其实在Rust中已经支持的相当好，当然也有一些还需要完善。所以，需要考虑，现有引擎如何与Rust系统共存的问题。&lt;/p&gt;&lt;p&gt;2. &lt;b&gt;轻量级引擎/游戏&lt;/b&gt;&lt;/p&gt;&lt;p&gt;像Chucklefish，Killhouse和其他很多公司，都没有使用现成的重量级引擎。很多时候，这些中小公司中的游戏引擎，实际上就是一个游戏。&lt;/p&gt;&lt;p&gt;虽然Rust成熟度很高，但是当前用Rust开发游戏，还是面临很多阻碍。在这个领域，也有Rust游戏引擎，但是和Unity相比，入门门槛比较高。比如Amethist引擎，一个简单的Pong游戏开局就是这样的代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;impl &amp;lt;&#39;a，&#39;b&amp;gt; SimpleState &amp;lt;&#39;a，&#39;b&amp;gt; for Pong {}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&#39;b&lt;/code&gt;都是什么？你可能会哭。虽然生命周期参数有存在的必要，但是你说，写一个Pong游戏示例还要来这个生命周期参数干嘛？作者拿他近十年的游戏开发生涯打赌：即便你写更复杂的游戏，也不一定需要用到生命周期参数。当然，作者也承认Amethist引擎很不错，但是当做一些简单的游戏，可能使用一些更简单的抽象比较好。当然，在未来可能会有更多的引擎来满足开发者的各种问题。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解决方案？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;作者建议成立一个游戏开发工作组来解决这些问题。&lt;/p&gt;&lt;p&gt;有人建议把Amethist引擎作为游戏开发的首选引擎来建立生态系统，但是作者认为，需要多元化。并非所有的游戏都有相同的要求，并非所有游戏都需要引擎，因此开放很重要。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;结论：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Rust官方核心团队ms答应了要在2019年启动游戏开发工作组。想用Rust制作游戏的开发者们拭目以待吧。&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-11-16-50066484</guid>
<pubDate>Fri, 16 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>嵌入式Rust年度回顾</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-11-15-49921783.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49921783&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c3347981b86893a737b868c57b9e8f1b_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;本篇来自于Rust嵌入式工作组的报告，&lt;a href=&quot;https://rust-embedded.github.io/blog/2018-11-14-this-year-in-embedded-rust/&quot;&gt;Read More&lt;/a&gt; &lt;br&gt;&lt;br&gt;今年嵌入式工作组开始构建Rust生态系统茁壮成长需要的坚实基础。这篇文章回顾当前进展并分享了今年所取得的成就。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;嵌入式Rust稳定性：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;稳定性&lt;/b&gt;：2018年嵌入式路线规划的一个最基本功能是：我的crate在升级到最新工具链时不应该被破坏。嵌入式开发从一开始就紧密和nightly相连，在一定时间内大家经历了很多重大变化。幸运的是，随着Rust 1.30的发布，这些痛苦都结束了。 Rust 1.30标志着嵌入式Rust开发迎来的第一个稳定版本。你可以在不依赖unstable功能的情况下构建出完整可用的嵌入式程序。&lt;br&gt;&lt;br&gt;此外，还在编译器测试套件中提供了一些单元测试来检测嵌入式代码，因此，在Nightly之下也能检测到一些意外的break。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;一个平稳的起点：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;「我如何开始使用嵌入式Rust？」，这是长期存在于IRC的一个问题。但是想回答这个问题并不容易，因为维护长期依赖于unstable功能的文档是一场艰苦的战斗。所以，新手会经常看到过时的文档。&lt;br&gt;&lt;br&gt;但是现在，稳定的嵌入式Rust已经准备好了。官方整合了一个权威稳定的文档给大家：&lt;a href=&quot;https://docs.rust-embedded.org/book&quot;&gt;《嵌入式之书(Embedded Rust Book)&lt;/a&gt;》。在一些&lt;a href=&quot;https://github.com/rust-embedded/cortex-m-quickstart&quot;&gt;模板&lt;/a&gt;和&lt;a href=&quot;https://github.com/rust-embedded/cargo-binutils&quot;&gt;工具&lt;/a&gt;的帮助下，尽量使得第一次使用嵌入式Rust的开发者感受到丝般顺滑的体验。&lt;br&gt;&lt;br&gt;《嵌入式之书》不仅仅是一本入门指南，它也包含着如何使用Rust编写正确的嵌入式软件。目前官方正在积极往里面添加更多的模式和开发技巧。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;面向所有人群的学习资源&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;《嵌入式之书》是面向有嵌入式开发经验的人，但官方也意识到，Rust是有很大潜力可以成为任何开发者尝试嵌入式开发的首选语言。所以，官方还在继续努力研究提供相关的资源，比如面向所有人的 &lt;a href=&quot;https://docs.rust-embedded.org/discovery/&quot;&gt;《探索之书(Discovery)》&lt;/a&gt;。&lt;br&gt;&lt;br&gt;另外，官方也知道嵌入式Rust目标受众对嵌入式系统领域的兴趣点和专业度都不太相同，所以官方推出了&lt;a href=&quot;https://docs.rust-embedded.org/embedonomicon/&quot;&gt;《嵌入式黑魔法(embedonomicon)》&lt;/a&gt;，并收集更多针对性的资源，比如各种&lt;a href=&quot;https://github.com/rust-embedded/awesome-embedded-rust&quot;&gt;awesome的第三方库列表&lt;/a&gt;。&lt;br&gt;&lt;br&gt;当然，上面列出的资源，都可以在&lt;a href=&quot;https://docs.rust-embedded.org/&quot;&gt;嵌入式文档站点&lt;/a&gt;找到。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;有组织的社区成就&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;所有这一切都是通过很多志愿者、工作组成员和其他社区成员辛勤工作完成的。特别是工作组成员致力于维护生态系统所依赖的核心crate和文档。所有的这一切都是在Rust嵌入式工作组的庇护下进行的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;WG团队&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;嵌入式领域非常庞大： 在这个领域中存在多种架构体系。许多目标架构和嵌入式开发者使用不同的约束(constraint)集：实时约束(real-time constraints)、内存约束(memory constraints)、能量/功率约束(energy/power constraints)等。&lt;br&gt;&lt;br&gt;出于这个原因，官方嵌入式WG团队通过增加不同专业领域的成员，并在工作组内发展和创建相关领域的专业团队。这保证了核心库中API设计在决策时，以及将嵌入式社区的需求传达给其他Rust工作组时可以产生不同的观点。拥有专业的团队也意味着在组织开发crate时，可以分配给具有适合相关技术背景的人。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;即将迎来的Rust 2018&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在Rust 2018即将发布的最后期限内，嵌入式工作组的重点是「文档」。这也需要大家的帮助。一个重要的事项：文档使用了2018版本，所以建议大家使用Rust beta版来测试文档。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;超越2018&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Rust 2018只是嵌入式Rust开发的一个起点。当前，嵌入式Rust支持的最成熟的的目标架构是「ARM Cortex-M」，&lt;a href=&quot;http://crates.io&quot;&gt;http://crates.io&lt;/a&gt;上面大多数crate都是针对此架构。但也已经为支持其他目标架构奠定了很好的基础。比如如裸机ARM Cortex-A、ARM Cortex-R、MSP430和RISCV。明年会继续在这些目标上努力。&lt;br&gt;&lt;br&gt;此外，嵌入式工作组还在收集「&lt;a href=&quot;https://github.com/rust-embedded/wg/issues/256&quot;&gt;愿望清单&lt;/a&gt;」，如果你希望2019年嵌入式Rust支持一些你想要的功能，现在是时候提交了。&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-11-15-49921783</guid>
<pubDate>Thu, 15 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust: await语法方面的进展</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-11-12-49440981.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49440981&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-cda8ecf15b90d011f62b43b74f4eadf4_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;官方核心成员withoutboat的新博文。&lt;a href=&quot;https://boats.gitlab.io/blog/post/await-syntax/&quot;&gt;Read More&lt;/a&gt; &lt;/blockquote&gt;&lt;p&gt;截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。&lt;/p&gt;&lt;p&gt;目前使用await!宏是因为&lt;code class=&quot;inline&quot;&gt;await&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;操作之间有一个优先级的问题。考虑下面代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let response = await http::get(url)?;&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;http::get&lt;/code&gt;函数的返回类型基本等价于&lt;code class=&quot;inline&quot;&gt;impl Future&amp;lt;Output = io::Result&amp;lt;Response&amp;gt;&amp;gt;&lt;/code&gt;，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先，await那个Future，计算其输出&lt;code class=&quot;inline&quot;&gt;io::Result&amp;lt;Response&amp;gt;&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;其次，使用&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;来对result解包，如果没有成功则提前返回错误。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;但事实上，当你看到这段代码的时候，你的直觉是&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;操作比&lt;code class=&quot;inline&quot;&gt;await&lt;/code&gt;优先，因为它离&lt;code class=&quot;inline&quot;&gt;http::get&lt;/code&gt;函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。&lt;/p&gt;&lt;p&gt;优先问题有以下几种潜在的解决方案：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;await!宏是一种既定方案。&lt;/li&gt;&lt;li&gt;默认await优先。用户可以使用括号来改变优先级，比如&lt;code class=&quot;inline&quot;&gt;await (function()?)&lt;/code&gt;。但是这种默认的优先级语法会让开发者违反直觉。&lt;/li&gt;&lt;li&gt;默认&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;优先，倒是符合直觉。但是用户需要为await返回错误则需要写成&lt;code class=&quot;inline&quot;&gt;(await function())?&lt;/code&gt;。但是用户在异步开发的时候可能会经常写这种带括号的代码。&lt;/li&gt;&lt;li&gt;引入某种后缀语法，比如&lt;code class=&quot;inline&quot;&gt;await? function()&lt;/code&gt;，但这个很怪。&lt;/li&gt;&lt;li&gt;总是使用分隔符号。比如&lt;code class=&quot;inline&quot;&gt;await {}&lt;/code&gt;，类似于 &lt;code class=&quot;inline&quot;&gt;unsafe {}&lt;/code&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-11-12-49440981</guid>
<pubDate>Mon, 12 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「Rust每日新闻」本周精选 • 第十九期</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-11-11-49295416.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49295416&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-23599072636a1820bba7b49b9d586092_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;前言： 从2018年开始，我每天会花1个小时关注Rust社区动态，并且在&lt;a href=&quot;http://rust.cc/&quot;&gt;Rust.CC论坛&lt;/a&gt;、&lt;a href=&quot;https://t.me/rust_daily_news&quot;&gt;tg channel&lt;/a&gt;、&lt;a href=&quot;https://steemit.com/@blackanger&quot;&gt;Steemit&lt;/a&gt;、&lt;a href=&quot;https://github.com/RustStudy/rust_daily_news&quot;&gt;GitHub&lt;/a&gt;、&lt;a href=&quot;https://www.yuque.com/chaosbot/rustnews&quot;&gt;语雀订阅&lt;/a&gt;都开通了Rust每日新闻，分享我每天的见闻，偶尔也夹杂了一些个人的观点。大半年过去了，Rust每日新闻已经成为了Rust社区群大家每天必看的内容。在这个知乎专栏里，每周会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。 2018-11-11&lt;/blockquote&gt;&lt;h2&gt;官方新闻&lt;/h2&gt;&lt;h2&gt;Rust 1.30.1 发布&lt;/h2&gt;&lt;p&gt;修补了一些bug&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.rust-lang.org/2018/11/08/Rust-1.30.1.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Pin API即将在1.32版本中稳定&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/55766&quot;&gt;issues-55766&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;如何在2018年加速Rust编译器：NLL edition&lt;/h2&gt;&lt;p&gt;本篇文章是对Niko之前博文的增补。其中按时间线罗列了针对NLL性能提升的各个PR。&lt;/p&gt;&lt;p&gt;这些PR主要是提升了编译器基于NLL做静态借用检查的性能。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.mozilla.org/nnethercote/2018/11/06/how-to-speed-up-the-rust-compiler-in-2018-nll-edition/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;社区新闻&lt;/h2&gt;&lt;h2&gt;「有趣的数据」Firefox中近一年内Rust使用数据统计&lt;/h2&gt;&lt;p&gt;从2017年11月1日 ~ 2018年11月1日&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Rust代码行数从3.7%增加到6.24%，反过来C++代码的比例就降低了&lt;/li&gt;&lt;li&gt;一共有405,379行Rust代码，6,091,861行C++代码&lt;/li&gt;&lt;li&gt;更有趣的是，Rust代码增加了172,839行，C++代码减少了38,241行&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f54e2802acb01ca15a950edd609ae7ea_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;466&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-f54e2802acb01ca15a950edd609ae7ea&quot; data-watermark-src=&quot;v2-2c5c8fcb2d77a974e97ae992f24e06a9&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bb0ef6f2ea438d169b91ac495844892a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;445&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-bb0ef6f2ea438d169b91ac495844892a&quot; data-watermark-src=&quot;v2-a53802c74edf45ec9e5e96b066129e77&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3fe59b16546a3059edacfdf79f2a28a4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;500&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-3fe59b16546a3059edacfdf79f2a28a4&quot; data-watermark-src=&quot;v2-395e794a714b8f11bc9e519b7a2ff4f9&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mobile.twitter.com/eroc/status/1061049330574884864&quot;&gt;Read More推文&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;前EA首席设计官成立的新独立游戏工作室Embark宣布使用Rust为主要语言&lt;/h2&gt;&lt;p&gt;作为EA的CDO（首席设计官，Chief design officer）在DICE/EA为游戏奉献了十八个年头，现在创建了新公司Embark，打算尝试点新东西。Embark宣布将用Rust构建他们的技术。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.theverge.com/2018/11/8/18073992/patrick-soderlund-new-studio-embark-nexon&quot;&gt;相关新闻&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/repi/status/1060469377500274689&quot;&gt;推文&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7322f977211c46558177d2f1443fe990_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;569&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-7322f977211c46558177d2f1443fe990&quot; data-watermark-src=&quot;v2-9ee4931db8e27a2a92a34a18af2ac296&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;官方异步Web开发框架Tide中间件介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49293350&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「录播视频」11-07晚上杭州秘猿Rust开发分享会&lt;/h2&gt;&lt;p&gt;秘猿计划每个月的Dev Meetup第一场都会开设Rust专题&lt;/p&gt;&lt;p&gt;B站视频前面几分钟无声音，后面有了&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av35546990/&quot;&gt; B站 &lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?reload=9&amp;amp;v=s7gFNTb3rWU&amp;amp;feature=youtu.be&quot;&gt; 油管视频声音比较完整 &lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Suricata 4.1 发布&lt;/h2&gt;&lt;p&gt;Suricata是一个网络实时入侵检测(IDS)、嵌入式入侵防御(IPS)和网络安全监控(NSM)的引擎。本来是C语言实现的，现在4.1版本中引入的新协议支持是基于Rust构建。&lt;/p&gt;&lt;p&gt;也就是说:&lt;/p&gt;&lt;blockquote&gt; Suricata 4.1 is not really 4.1 if you don’t have Rust.&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://suricata-ids.org/2018/11/06/suricata-4-1-released/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/OISF/suricata&quot;&gt;suricata&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Parity与Zcash 基金会合作&lt;/h2&gt;&lt;p&gt;新的Zcash节点将使用Rust编写，并成为Zcash公司自zcashed之后的第一个可选客户端。zcashed是Zcash唯一可用的完整节点。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.parity.io/parity-teams-up-with-zcash-foundation-for-parity-zcash-client/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;lazy_static发布1.2.0版本&lt;/h2&gt;&lt;p&gt;该版本主要是让lazy_static可以在no_std下使用。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9u8u6h/psa_lazy_static_120_requires_rustc_1241_or_higher/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;探讨所有权和借用语义对API接口设计的影响&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/48585534&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;xray有什么进展？&lt;/h2&gt;&lt;p&gt;xray是Atom团队使用Rust和Electron实现的下一代文本编辑器。今天看了下其代码仓库，发现还是在持续地更新。在2018第三个季度，团队主要聚焦于memo子项目。memo是xray的基础，它是一个版本控制系统，也可以作为独立库使用。&lt;/p&gt;&lt;p&gt;memo是想作为Git的扩展，使用无冲突的复制数据类型（CRDT）记录工作副本，用于增强Git的实时协作功能。其技术栈也用到了WebAssembly，用于公开虚拟文件系统的API。&lt;/p&gt;&lt;p&gt;在memo稳定以后，会将其从xray独立出来，然后会继续进行xray的开发。将xray作为一个以memo为基础的一流的可实时协作的编辑器。&lt;/p&gt;&lt;p&gt;牛逼了&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/atom/xray/tree/master/memo_core&quot;&gt;memo&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/atom/xray&quot;&gt;xray&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「演讲」使用Rust构建下一代网络基础设施&lt;/h2&gt;&lt;p&gt;Buoyant的软件工程师Carl分享了在Conduit开发过程中利用Rust零成本抽象开发下一代网络基础平台。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.infoq.com/presentations/rust-infrastructure&quot;&gt;infoq 视频&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;学习资源&lt;/h2&gt;&lt;h2&gt;Monadic Rust: Part I&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49276748&quot;&gt; Read More &lt;/a&gt;&lt;/p&gt;&lt;h2&gt;NLL之后：移动借用数据和Sentinel模式&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/49290855&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;用Rust编写网络驱动程序&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.net.in.tum.de/fileadmin/bibtex/publications/theses/2018-ixy-rust.pdf&quot;&gt;PDF&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;利用Rust所有权语义来构造有约束的API&lt;/h2&gt;&lt;p&gt;该文作者在2017年的Rust Fest大会做了分享，直到昨天，他才把演讲内容更新成了文稿。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=3Q2hQfYW-XM&amp;amp;index=9&amp;amp;list=PL85XCvVPmGQj9mqbJizw-zi-EhcpS5jTP&quot;&gt;演讲视频&lt;/a&gt;&lt;/p&gt;&lt;p&gt;（ 我在《Rust编程之道》一书的设计模式 - RAII模式 里也借鉴了他的这次演讲内容 ）&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.systems.ethz.ch/blog/2018/a-hammer-you-can-only-hold-by-the-handle.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「语言特性」重温proc_macro_attribute&lt;/h2&gt;&lt;h2&gt;proc_macro #attribute #flame #flamegraph&lt;/h2&gt;&lt;p&gt;随着proc-macro功能的逐渐稳定，proc_macro_attribute现在也不需要再加特定的features，比如registrar 和 rustc_private。该文作者重构了他的项目flamer(一个编译器插件)，包含了最新的proc_macro_attribute用法，当然还是需要nightly版本。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/llogiq/flamer&quot;&gt;flamer&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://llogiq.github.io/2018/11/10/proc-macro.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust实现可选参数&lt;/h2&gt;&lt;p&gt;本文记录了作者使用Rust实现可选参数的一步步思路，也是对Rust设计API的思考。&lt;/p&gt;&lt;p&gt;P.S 这还是一个PingCAP隐藏的招聘贴呢。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://hoverbear.org/2018/11/04/optional-arguments/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust谜题：让内嵌于迭代中的Result扁平化&lt;/h2&gt;&lt;p&gt;ndarray-csv的作者第三次重构该库的时候碰到一个问题。&lt;/p&gt;&lt;p&gt;他想实现一个函数：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub fn flatten_nested_results&amp;lt;T, E, II, IO&amp;gt;(iter_outer: IO) -&amp;gt; impl Iterator&amp;lt;Item = Result&amp;lt;T, E&amp;gt;&amp;gt;
where
    II: Iterator&amp;lt;Item = Result&amp;lt;T, E&amp;gt;&amp;gt;,
    IO: Iterator&amp;lt;Item = Result&amp;lt;II, E&amp;gt;&amp;gt;,
{
    /// Fill me in!
}&lt;/code&gt;&lt;p&gt;然后用于处理像下面这种迭代器中的Result&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn vec_to_nested_iter(
    vec_outer: Vec&amp;lt;Result&amp;lt;Vec&amp;lt;Result&amp;lt;i8, f32&amp;gt;&amp;gt;, f32&amp;gt;&amp;gt;,
) -&amp;gt; impl Iterator&amp;lt;Item = Result&amp;lt;impl Iterator&amp;lt;Item = Result&amp;lt;i8, f32&amp;gt;&amp;gt;, f32&amp;gt;&amp;gt; {
    vec_outer
        .into_iter()
        .map(|vec_inner| vec_inner.map(Vec::into_iter))
}

/// Without any Errs, we should return the whole sequence
#[test]
fn test_all_ok() {
    let iter_outer = vec_to_nested_iter(vec![Ok(vec![Ok(1), Ok(2)]), Ok(vec![Ok(3)])]);
    let expected: Result&amp;lt;Vec&amp;lt;i8&amp;gt;, f32&amp;gt; = Ok(vec![1, 2, 3]);
    assert_eq!(expected, flatten_nested_results(iter_outer).collect())
}&lt;/code&gt;&lt;p&gt;作者经过三次失败的flatten_nested_results函数实现，首先找出的解决方案是使用trait object。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub fn flatten_nested_results&amp;lt;T, E, II, IO&amp;gt;(iter_outer: IO) -&amp;gt; impl Iterator&amp;lt;Item = Result&amp;lt;T, E&amp;gt;&amp;gt;
where
    T: &#39;static,
    E: &#39;static,
    II: &#39;static + Iterator&amp;lt;Item = Result&amp;lt;T, E&amp;gt;&amp;gt;,
    IO: &#39;static + Iterator&amp;lt;Item = Result&amp;lt;II, E&amp;gt;&amp;gt;,
{
    iter_outer.flat_map(|iter_inner_result| match iter_inner_result {
        Ok(iter_inner) =&amp;gt; Box::new(iter_inner) as Box&amp;lt;Iterator&amp;lt;Item = Result&amp;lt;T, E&amp;gt;&amp;gt;&amp;gt;,
        Err(err) =&amp;gt; Box::new(once(Err(err))) as Box&amp;lt;Iterator&amp;lt;Item = Result&amp;lt;T, E&amp;gt;&amp;gt;&amp;gt;,
    })
}&lt;/code&gt;&lt;p&gt;但他还不喜欢这个方案，最终他使用了either库来解决此问题&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;extern crate either;

use either::Either;
use std::iter::once;

pub fn flatten_nested_results&amp;lt;T, E, II, IO&amp;gt;(iter_outer: IO) -&amp;gt; impl Iterator&amp;lt;Item = Result&amp;lt;T, E&amp;gt;&amp;gt;
where
    II: Iterator&amp;lt;Item = Result&amp;lt;T, E&amp;gt;&amp;gt;,
    IO: Iterator&amp;lt;Item = Result&amp;lt;II, E&amp;gt;&amp;gt;,
{
    iter_outer.flat_map(|iter_inner_result| match iter_inner_result {
        Ok(iter_inner) =&amp;gt; Either::Right(iter_inner),
        Err(err) =&amp;gt; Either::Left(once(Err(err))),
    })
}&lt;/code&gt;&lt;p&gt;&lt;a href=&quot;https://paulkernfeld.com/2018/11/03/flatten-nested-iterator-result.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;项目&lt;/h2&gt;&lt;h2&gt;swc：加速web开发&lt;/h2&gt;&lt;p&gt;swc是babel 和 closure compiler二合一的Rust实现。潜力不错，但目前缺乏文档。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/swc-project/swc&quot;&gt;swc&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;rust-analyzer：给IDE使用的Rust实验性模块化编译器前端&lt;/h2&gt;&lt;p&gt;旨在为优秀的IDE支持奠定基础&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/rust-analyzer/rust-analyzer&quot;&gt;rust-analyzer&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;martin： PostGIS矢量切片（ vector tiles）服务器&lt;/h2&gt;&lt;p&gt;martin是基于rust和actix-web实现的PostGIS矢量切片服务器。主要是基于mapbox格式做矢量切片，一般用于地图服务。&lt;/p&gt;&lt;p&gt;PostGIS 是 PostgreSQL 的空间数据库扩展。&lt;/p&gt;&lt;blockquote&gt; 考察了一下该库背后的公司Urbica，是一家来自莫斯科的数据分析及可视化公司。他们最新开发的产品AReal，是一款 iOS 平台上的增强现实 App，通过 3D 的方式展示了圣彼得堡的地图和地标建筑，包括了七座杰出建筑在地图上用星标标记。但是展示方式可能与大家想象的有所不同——不再是低下头在屏幕上看，而是举起手机把建筑“搭建”到你眼前！只要点击任何一座建筑，你就可以通过 AR 模块将建筑融入你所处的环境，并通过缩放、旋转等操作来探索。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;一句话描述： Urbica公司是做AR地图的。据说苹果公司也正在筹备做AR地图产品。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43656372&quot;&gt;Urbica介绍来源&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/urbica/martin&quot;&gt;martin&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「小游戏」Rust和WASM实现的贪食蛇&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/yiransheng/rust-snake-wasm&quot;&gt;rust-snake-wasm&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「嵌入式」Monotron在Rust Belt上的展示&lt;/h2&gt;&lt;p&gt;Monotron是基于TM4C123单片机和ARM Cortex-M4内核的一款DIY 8位家用小电脑，作者在RustBelt大会上展示了让它来跑snake小游戏。 并且可以使用C和Rust来为其编写应用。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/thejpster/monotron&quot;&gt;Monotron&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://railwayelectronics.blogspot.com/2018/11/monotron-at-rust-belt-rust.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Plume:又一个基于ActivityPub协议开发的社区联盟博客系统&lt;/h2&gt;&lt;p&gt;plume是基于rocket和diesel实现。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Plume-org/Plume&quot;&gt;Plume&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://baptiste.gelez.xyz/&quot;&gt;Demo&lt;/a&gt;&lt;/p&gt;&lt;p&gt;相似的项目有: &lt;a href=&quot;https://github.com/Aardwolf-Social/aardwolf&quot;&gt;Aardwolf&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust + SDL实现的rougelike沙盒游戏&lt;/h2&gt;&lt;blockquote&gt; Roguelike是电子角色扮演游戏（RPG游戏）的一个子类。标志性特征有：在随机生成的地牢中探索、回合制、基于图块的图像（tile-based graphics）以及角色的永久死亡。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/garkimasera/rusted-ruins&quot;&gt;rusted-ruins&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;工具与库&lt;/h2&gt;&lt;h2&gt;Mundane : 基于BoringSSL的Rust加密库&lt;/h2&gt;&lt;p&gt;BoringSSL 是由谷歌从 OpenSSL 中抽出来后独立发展的作品。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/google/mundane&quot;&gt;mundane&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;JSON5的序列化和反序列化工具&lt;/h2&gt;&lt;p&gt;基于pest和serde&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/callum-oakley/json5-rs&quot;&gt;json5-rs&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;s3-concat: 使用Rust快速合并S3文件&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/whitfin/s3-concat&quot;&gt;s3-concat&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://whitfin.io/quickly-concatenating-files-in-amazon-s3/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「机器学习」使用Rust在命令行构建训练数据&lt;/h2&gt;&lt;p&gt;ttv是一个命令行工具，用于将大型文件拆分为适合于机器学习的训练/测试/验证拆分的块。基于Rust 2018版本。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/sd2k/ttv&quot;&gt;ttv&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;vulkano 0.11 发布&lt;/h2&gt;&lt;p&gt;vulkano是对Vulkan API的安全包装&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/vulkano-rs/vulkano&quot;&gt;vulkano&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.patreon.com/posts/22587417&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「库」imag 0.9发布&lt;/h2&gt;&lt;p&gt;私人信息管理套件工具imag发布了新版本：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;本次版本修改影响比较广&lt;/li&gt;&lt;li&gt;增加了读取大文件的支持，不会遇到文件描述符限制&lt;/li&gt;&lt;li&gt;加速图片操作&lt;/li&gt;&lt;li&gt;使用统一的IO系统&lt;/li&gt;&lt;li&gt;使用failure库进行错误处理&lt;/li&gt;&lt;li&gt;imag-diagnostics增加进度条&lt;/li&gt;&lt;li&gt;大量bug修复&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://imag-pim.org/blog/2018/11/10/imag-0-9-0/&quot;&gt;imag&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;instru: 监控Rust代码性能&lt;/h2&gt;&lt;p&gt;instru通过在编译阶段（编译器插件）将代码注入到AST来执行对整个程序的跟踪。需要使用nightly版本。&lt;/p&gt;&lt;p&gt;该工具和flamer库有点相似，flamer库可以生成火焰图，用来帮助跟踪代码性能。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/da-x/instru&quot;&gt;instru&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/llogiq/flamer&quot;&gt;flamer&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「小工具」清理cargo或rustc产生的构建垃圾&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/holmgr/cargo-sweep&quot;&gt;cargo-sweep&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;hexyl 命令行16进制查看器&lt;/h2&gt;&lt;p&gt;彩色输出不同类别的字节&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/sharkdp/hexyl&quot;&gt;hexyl&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;no-panic ：通过一个属性宏让编译器检验函数不会发生panic&lt;/h2&gt;&lt;p&gt;serde/syn 作者dtolnay的新库：no-panic。 提供了一个属性宏，通过编译器来保证函数不会发生panic。&lt;/p&gt;&lt;p&gt;比如：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;extern crate no_panic;
use no_panic::no_panic;

#[no_panic]
fn demo(s: &amp;amp;str) -&amp;gt; &amp;amp;str {
    &amp;amp;s[1..]
}

fn main() {
    println!(&quot;{}&quot;, demo(&quot;input string&quot;));
}&lt;/code&gt;&lt;p&gt;如果该demo函数发生panic（或编译器无法检验函数不能panic），则该函数会编译失败，并且错误信息中会携带包含该函数名称标识的链接器错误信息。&lt;/p&gt;&lt;p&gt;注意：通过看该库的源码发现：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Rust的proc_macro_attribute功能也移出了&lt;code class=&quot;inline&quot;&gt;#![feature(custom_attribute)]&lt;/code&gt;特性，意味着，也要准备稳定了&lt;/li&gt;&lt;li&gt;现在稳定的proc_macro功能，不能用作表达式，除非使用&lt;code class=&quot;inline&quot;&gt;#![feature(proc_macro_hygiene)]&lt;/code&gt;特性。&lt;a href=&quot;https://github.com/rust-lang/blog.rust-lang.org/issues/285&quot;&gt;相关issues &lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/dtolnay/no-panic&quot;&gt;no-panic&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;招聘&lt;/h2&gt;&lt;h2&gt;「远程Job」来自丹麦的召唤：Rust全栈工程师&lt;/h2&gt;&lt;p&gt;丹麦的一家正规公司：impero，目前正在招募Rust全栈工程师。可远程。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/9v7qpx/rust_fullstack_developer_denmark_or_remote/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-11-11-49295416</guid>
<pubDate>Sun, 11 Nov 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
