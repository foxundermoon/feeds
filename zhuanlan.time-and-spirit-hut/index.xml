<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>时光与精神小屋</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Sun, 09 Dec 2018 00:21:47 +0800</lastBuildDate>
<item>
<title>Rust Quiz 解读：Quiz 9</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-08-51891075.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51891075&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt; 来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz  &lt;br&gt; &lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;&lt;br&gt; 不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。   &lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 9:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;macro_rules! m {
    (1) =&amp;gt; { print!(&quot;1&quot;) };
    ($tt:tt) =&amp;gt; { print!(&quot;2&quot;) };
}

macro_rules! e {
    ($e:expr) =&amp;gt; { m!($e) };
}

macro_rules! t {
    ($tt:tt) =&amp;gt; { e!($tt); m!($tt); };
}

fn main() {
    t!(1);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 21&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;声明宏基本匹配规则&lt;/li&gt;&lt;li&gt;声明宏元变量匹配的可传导性&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Quiz代码中依次定义了三个声明宏，&lt;code class=&quot;inline&quot;&gt;m!&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;e!&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;t!&lt;/code&gt;，并且依次是包含关系。&lt;/p&gt;&lt;p&gt;在main函数中，调用&lt;code class=&quot;inline&quot;&gt;t!(1)&lt;/code&gt;时，根据宏定义，其参数&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;经过词法分析得到词条树，也就是宏元变量&lt;code class=&quot;inline&quot;&gt;$tt:tt&lt;/code&gt;的类型&lt;code class=&quot;inline&quot;&gt;tt&lt;/code&gt;所指示。然后由&lt;code class=&quot;inline&quot;&gt;e!($tt);&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;m!($tt);&lt;/code&gt;继续匹配。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;e!($tt)&lt;/code&gt;在匹配过程中，因为&lt;code class=&quot;inline&quot;&gt;e!&lt;/code&gt;定义左边元变量&lt;code class=&quot;inline&quot;&gt;$e:expr&lt;/code&gt;，表明是一个表达式类型。对于Rust编译器来说，经过&lt;code class=&quot;inline&quot;&gt;e!&lt;/code&gt;宏处理的词条，将会变成一个不透明的词条（opaque token tree）。也就是说，后续的宏都会认为它是一个表达式token，而不是其他。所以，在&lt;code class=&quot;inline&quot;&gt;e!&lt;/code&gt;宏内匹配右侧&lt;code class=&quot;inline&quot;&gt;m!($e);&lt;/code&gt;的时候，只能匹配&lt;code class=&quot;inline&quot;&gt;m!&lt;/code&gt;宏的第二条分支&lt;code class=&quot;inline&quot;&gt;($tt:tt)&lt;/code&gt;，所以输出： 2。&lt;/p&gt;&lt;p&gt;如果试着在&lt;code class=&quot;inline&quot;&gt;m!&lt;/code&gt;中加一条匹配分支：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;macro_rules! m {
    (1) =&amp;gt; { print!(&quot;1&quot;) };
    ($ee;expr) =&amp;gt; { print!(&quot;3&quot;)};
    ($tt:tt) =&amp;gt; { print!(&quot;2&quot;) };
}&lt;/code&gt;&lt;p&gt;输出结果就会变成： &lt;code class=&quot;inline&quot;&gt;31&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;m!(1)&lt;/code&gt;来说，它一直以&lt;code class=&quot;inline&quot;&gt;tt&lt;/code&gt;词条树类型来传播，到最后会尝试匹配到&lt;code class=&quot;inline&quot;&gt;(1)&lt;/code&gt;这个token字面量，然后匹配成功，最后输出： &lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这就是为什么输出结果是&lt;code class=&quot;inline&quot;&gt;21&lt;/code&gt;的原因。&lt;/p&gt;&lt;p&gt;同理，如果把&lt;code class=&quot;inline&quot;&gt;e!&lt;/code&gt;的匹配模式修改为：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;macro_rules! e {
    ($e:tt) =&amp;gt; { m!($e) };
}&lt;/code&gt;&lt;p&gt;则输出结果会是：&lt;code class=&quot;inline&quot;&gt;11&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;不透明词条树（Opaque Token Tree）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;所谓不透明词条树（Opaque Token Tree），就是指，不能和token字面量相匹配的词条树。&lt;/p&gt;&lt;p&gt;尝试把Quiz代码中&lt;code class=&quot;inline&quot;&gt;m!&lt;/code&gt;定义中的匹配分支修改如下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;macro_rules! m {
    (1) =&amp;gt; { print!(&quot;1&quot;) };
}&lt;/code&gt;&lt;p&gt;再去执行Quiz代码，编译器会报错：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;error: no rules expected the token `1`
  --&amp;gt; src/main.rs:6:23
   |
6  |     ($e:expr) =&amp;gt; { m!($e) };
   |                       ^^
...
14 |     t!(1);
   |     ------ in this macro invocation&lt;/code&gt;&lt;p&gt;编译器提示：no rules expected the token &lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。这意味着，&lt;code class=&quot;inline&quot;&gt;expr&lt;/code&gt;不能与&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;这个token字面量相匹配。这就是所谓的「不透明词条」。&lt;/p&gt;&lt;p&gt;在Rust中，不透明词条类型除了&lt;code class=&quot;inline&quot;&gt;expr&lt;/code&gt;，还有其他类型，罗列如下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;$:block
$:expr
$:item
$:literal
$:meta
$:pat
$:path
$:stmt
$:ty&lt;/code&gt;&lt;p&gt;而透明的词条如下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;$:ident
$:lifetime
$:tt&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/9&quot;&gt;点此查看 Rust Quiz 9&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-08-51891075</guid>
<pubDate>Sat, 08 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 8</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-07-51809530.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51809530&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt; 来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz  &lt;br&gt; &lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt; &lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。  &lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 8:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;macro_rules! m {
    (==&amp;gt;) =&amp;gt; { print!(&quot;1&quot;); };
    (= = &amp;gt;) =&amp;gt; { print!(&quot;2&quot;); };
    (== &amp;gt;) =&amp;gt; { print!(&quot;3&quot;); };
    (= =&amp;gt;) =&amp;gt; { print!(&quot;4&quot;); };
}

fn main() {
    m!(==&amp;gt;);
    m!(= = &amp;gt;);
    m!(== &amp;gt;);
    m!(= =&amp;gt;);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果: 1214&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;考察要点：&lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;macro_rules!&lt;/code&gt;定义宏匹配规则&lt;/li&gt;&lt;li&gt;理解词法分析中的token&lt;/li&gt;&lt;li&gt;操作符优先级&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Rust中使用&lt;code class=&quot;inline&quot;&gt;macro_rules!&lt;/code&gt;来定义声明宏，将来也会稳定&lt;code class=&quot;inline&quot;&gt;macro&lt;/code&gt;关键字。但基本的核心是不变的。Rust语言因为还在发展期，所以无法像其他很多语言一样，把AST（抽象语法树）暴露出来给开发者使用。导致现在Rust的宏，都是基于分词解析后形成的词条流（TokenStream）来编写宏。&lt;/p&gt;&lt;p&gt;所以，你可以把声明宏理解为是TokenStream模板。其实声明宏也有另外一个名字：「macro by example」&lt;/p&gt;&lt;p&gt;声明宏的语法规则是这样的：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;macro_rules! $name {
    $rule0 ;
    $rule1 ;
    // …
    $ruleN ;
}&lt;/code&gt;&lt;p&gt;一个声明宏里可以包含多个规则（$rule）。一般来说，声明宏的时候，规则模式经常使用下面的标识符来匹配对应的项：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;item: 条目，比如函数、结构体、模组等。
block: 区块(即由花括号包起的一些语句加上/或是一项表达式)。
stmt: 语句
pat: 模式
expr: 表达式
ty: 类型
ident: 标识符
path: 路径 (例如 foo, ::std::mem::replace, transmute::&amp;lt;_, int&amp;gt;, …)
meta: 元条目，即被包含在 #[...]及#![...]属性内的东西。
tt: 标记树&lt;/code&gt;&lt;p&gt;比如在Quiz 1中见到的：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;macro_rules! m {
    ($($s:stmt)*) =&amp;gt; {
        $(
            { stringify!($s); 1 }
        )&amp;lt;&amp;lt;*
    };
}&lt;/code&gt;&lt;p&gt;其中&lt;code class=&quot;inline&quot;&gt;$s:stmt&lt;/code&gt;表示匹配一个语句。而Quiz 8中声明的这个宏，其匹配规则并没有使用任何标识符。而是直接使用了&lt;code class=&quot;inline&quot;&gt;==&amp;gt;&lt;/code&gt;或&lt;code class=&quot;inline&quot;&gt;= = &amp;gt;&lt;/code&gt;这样的值，这叫做&lt;code class=&quot;inline&quot;&gt;token字面量&lt;/code&gt;。它表示，Rust编译器中的宏解释器会把它作为token进行匹配。&lt;/p&gt;&lt;p&gt;所以，在上面Quiz 8的代码中，定义声明宏&lt;code class=&quot;inline&quot;&gt;m!&lt;/code&gt;，包含了四个匹配模式。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;(==&amp;gt;)&lt;/code&gt;，表示要直接和分词得到的token流进行匹配，那么它能匹配的是两个token：&lt;code class=&quot;inline&quot;&gt;==&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&amp;gt;&lt;/code&gt;。因为是从左往右进行匹配。在Rust中，&lt;code class=&quot;inline&quot;&gt;==&lt;/code&gt;是一个完整的token。但是有的人可能会想，为什么不是匹配成&lt;code class=&quot;inline&quot;&gt;=&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;=&amp;gt;&lt;/code&gt;呢？这是因为在Rust里&lt;code class=&quot;inline&quot;&gt;==&lt;/code&gt;（ 比较操作符）的优先级要高于&lt;code class=&quot;inline&quot;&gt;=&lt;/code&gt;（赋值操作符）。所以，在执行&lt;code class=&quot;inline&quot;&gt;m!(==&amp;gt;);&lt;/code&gt;的时候，输出：1。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;(= = &amp;gt;)&lt;/code&gt;，那么同理，匹配&lt;code class=&quot;inline&quot;&gt;=&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;=&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&amp;gt;&lt;/code&gt;。注意匹配模式中包含的空格是忽略不计的，空格的作用，其实就是为了帮助编译器识别如何「断句」。所以，在执行&lt;code class=&quot;inline&quot;&gt;m!(= = &amp;gt;)&lt;/code&gt;的时候，当然输出： 2。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;(== &amp;gt;)&lt;/code&gt;，其实和&lt;code class=&quot;inline&quot;&gt;(==&amp;gt;)&lt;/code&gt;是一样的。不一样的是它们在宏定义中出现的位置。这里执行&lt;code class=&quot;inline&quot;&gt;m!(== &amp;gt;);&lt;/code&gt;输出是：1。这个差别待会再解释。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;(= =&amp;gt;);&lt;/code&gt;，同理，匹配&lt;code class=&quot;inline&quot;&gt;=&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;=&amp;gt;&lt;/code&gt;，所以在执行&lt;code class=&quot;inline&quot;&gt;m!(= =&amp;gt;);&lt;/code&gt;的时候，输出：4。&lt;/p&gt;&lt;p&gt;最终结果是：&lt;code class=&quot;inline&quot;&gt;1214&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;那么，为什么&lt;code class=&quot;inline&quot;&gt;m!(== &amp;gt;);&lt;/code&gt;无法输出 3 呢？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们把代码修改一下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;macro_rules! m {
    (== &amp;gt;) =&amp;gt; { print!(&quot;3&quot;); };
    (= = &amp;gt;) =&amp;gt; { print!(&quot;2&quot;); };
    (==&amp;gt;) =&amp;gt; { print!(&quot;1&quot;); };
    (= =&amp;gt;) =&amp;gt; { print!(&quot;4&quot;); };
}
fn main() {
    m!(==&amp;gt;);
    m!(= = &amp;gt;);
    m!(== &amp;gt;);
    m!(= =&amp;gt;);
}&lt;/code&gt;&lt;p&gt;修改后的输出结果： &lt;code class=&quot;inline&quot;&gt;3234&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;注意，我只是把&lt;code class=&quot;inline&quot;&gt;(== &amp;gt;)&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;(==&amp;gt;)&lt;/code&gt;的匹配分支顺序换了一下。这段代码中，说明了声明宏的另一个特性：优先匹配最前面的匹配分支。&lt;/p&gt;&lt;p&gt;因为&lt;code class=&quot;inline&quot;&gt;m!(==&amp;gt;);&lt;/code&gt;的默认分词匹配就是&lt;code class=&quot;inline&quot;&gt;==&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&amp;gt;&lt;/code&gt;，所以，当碰到第一个匹配分支&lt;code class=&quot;inline&quot;&gt;(== &amp;gt;)&lt;/code&gt;的时候，就匹配到了，所以，不会继续寻找后面的匹配分支，所以，不可能输出： &lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。同理，回到修改前的代码中，&lt;code class=&quot;inline&quot;&gt;m!(== &amp;gt;);&lt;/code&gt;最先匹配的是&lt;code class=&quot;inline&quot;&gt;(==&amp;gt;)&lt;/code&gt;，所以不可能再去寻找后面的匹配分支了，所以不可能输出: &lt;code class=&quot;inline&quot;&gt;3&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/8&quot;&gt;点此查看 Rust Quiz 8&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-07-51809530</guid>
<pubDate>Fri, 07 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 7</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-06-51759112.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51759112&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz    &lt;br&gt;&lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;&lt;br&gt; 不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。  &lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 7:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;#[repr(u8)]
enum Enum {
    First,
    Second,
}

impl Enum {
    fn p(self) {
        match self {
            First =&amp;gt; print!(&quot;1&quot;),
            Second =&amp;gt; print!(&quot;2&quot;),
        }
    }
}

fn main() {
    Enum::p(unsafe {
        std::mem::transmute(1u8)
    });
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 1&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Enum内存布局&lt;/li&gt;&lt;li&gt;std::mem::transmute函数&lt;/li&gt;&lt;li&gt;类型推断&lt;/li&gt;&lt;li&gt;match匹配&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在上面代码中定义了Enum枚举体，使用&lt;code class=&quot;inline&quot;&gt;#[repr(u8)]&lt;/code&gt;来指定其内存布局，是按8位对齐。&lt;/p&gt;&lt;p&gt;然后为Enum实现了方法p，其方法体使用match匹配。这里是最让人迷惑的地方了。注意match的两个匹配模式，&lt;code class=&quot;inline&quot;&gt;First&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;Second&lt;/code&gt;与Enum枚举体包含值同名。正常情况下，如果要在方法p内使用枚举值，应该是&lt;code class=&quot;inline&quot;&gt;Enum::First&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;Enum::Second&lt;/code&gt;，或者使用&lt;code class=&quot;inline&quot;&gt;use Enum::*;&lt;/code&gt;导入。这里没有导入，也没有加&lt;code class=&quot;inline&quot;&gt;Enum::&lt;/code&gt;前缀，那么实际上，Rust将&lt;code class=&quot;inline&quot;&gt;First&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;Second&lt;/code&gt;当作通配符_来看待。&lt;/p&gt;&lt;p&gt;所以，在main函数中，不管给p方法传入什么类型，只能匹配到第一个，所以输出结果是： 1。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;怎么理解呢？&lt;/b&gt;把上面的代码放到Playground执行一遍，会看到编译器有警告输出：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;warning[E0170]: pattern binding `First` is named the same as one of the variants of the type `Enum`
  --&amp;gt; src/main.rs:10:13
   |
10 |             First =&amp;gt; print!(&quot;1&quot;),
   |             ^^^^^ help: to match on the variant, qualify the path: `Enum::First`

warning[E0170]: pattern binding `Second` is named the same as one of the variants of the type `Enum`
  --&amp;gt; src/main.rs:11:13
   |
11 |             Second =&amp;gt; print!(&quot;2&quot;),
   |             ^^^^^^ help: to match on the variant, qualify the path: `Enum::Second`&lt;/code&gt;&lt;p&gt;首先是这两个警告，这是提示开发者，First和Second和Enum定义的枚举值同名了，提示加上Enum::前缀。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;warning: unreachable pattern
  --&amp;gt; src/main.rs:11:13
   |
10 |             First =&amp;gt; print!(&quot;1&quot;),
   |             ----- matches any value
11 |             Second =&amp;gt; print!(&quot;2&quot;),
   |             ^^^^^^ unreachable pattern
   |
   = note: #[warn(unreachable_patterns)] on by default&lt;/code&gt;&lt;p&gt;然后是上面这个警告，提示这里触发了&lt;code class=&quot;inline&quot;&gt;unreachable pattern&lt;/code&gt;模式，因为Rust编译器默认是开启&lt;code class=&quot;inline&quot;&gt;#[warn(unreachable_patterns)]&lt;/code&gt;警告的。&lt;/p&gt;&lt;p&gt;什么是Unreachable Pattern呢？p方法等价于下面代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;impl Enum {
    fn p(self) {
        match self {
            _ =&amp;gt; print!(&quot;1&quot;),
            _ =&amp;gt; print!(&quot;2&quot;),
        }
    }
}&lt;/code&gt;&lt;p&gt;当函数被调用的时候，Rust会遍历self所有可能的值，但是现在这里并没有把所有可能匹配的值给列出来。所以就是Unreachable。在这种情况下，将会匹配任意值。这也是上面代码输出1的原因。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;如果把p方法里的匹配模式加上Enum::前缀会怎么样？&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;#[repr(u8)]
enum Enum {
    First,
    Second,
}

impl Enum {
    fn p(self) {
        match self {
            Enum::First =&amp;gt; print!(&quot;1&quot;),
            Enum::Second =&amp;gt; print!(&quot;2&quot;),
        }
    }
}

fn main() {
    Enum::p(unsafe {
        std::mem::transmute(1u8)
    });
}&lt;/code&gt;&lt;p&gt;这次，输出结果变成了： 2。&lt;/p&gt;&lt;p&gt;这又是为什么呢?&lt;/p&gt;&lt;p&gt;事实上，Enum等价于下面代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;enum Enum {
  First = 0u8,
  Second = 1u8,
}&lt;/code&gt;&lt;p&gt;其实，你在Playground里输出MIR代码也能看得出来：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;#[repr(u8)]
enum Enum {
    First,
    Second,
}
fn main() {
    let a = Enum::First;
    let b = Enum::Second;
}&lt;/code&gt;&lt;p&gt;输出的MIR：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() -&amp;gt; (){
    let mut _0: ();                      // return place
    scope 1 {
        scope 3 {
        }
        scope 4 {
            let _2: Enum;                // &quot;b&quot; in scope 4 at src/main.rs:10:9: 10:10
        }
    }
    scope 2 {
        let _1: Enum;                    // &quot;a&quot; in scope 2 at src/main.rs:9:9: 9:10
    }

    bb0: {                              
       // 省略其他
        discriminant(_1) = 0;            // bb0[1]: scope 0 at src/main.rs:9:13: 9:24
        discriminant(_2) = 1;            // bb0[3]: scope 1 at src/main.rs:10:13: 10:25
       // 省略其他
    }
}&lt;/code&gt;&lt;p&gt;那么main函数，其实等价于下面代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() {
    let a = unsafe {
        std::mem::transmute(1u8)
    };
    Enum::p(a);
}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;std::mem::transmute()&lt;/code&gt;函数本身是一个unsafe函数，它相当于直接在栈上进行拷贝，将一种类型的值，解释为另一种类型。语义上，相当于一种「按位移动」。说白了，就是一种类型转换。但不能随便使用它，必须在源值和目标值，都有效的情况下才可以转换。&lt;/p&gt;&lt;p&gt;但是上面代码里的&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，是什么类型呢？&lt;code class=&quot;inline&quot;&gt;std::mem::transmute(1u8)&lt;/code&gt;会把&lt;code class=&quot;inline&quot;&gt;1u8&lt;/code&gt;转换为Enum类型。这是Rust编译器根据上下文进行类型推断得出的。你可以把&lt;code class=&quot;inline&quot;&gt;1u8&lt;/code&gt;修改为&lt;code class=&quot;inline&quot;&gt;1u16&lt;/code&gt;看看编译器的提示。&lt;/p&gt;&lt;p&gt;那么现在a实际上是被转换成Enum::Second。所以Enum::p(a);输出的结果是：2。&lt;/p&gt;&lt;p&gt;注意上面Enum::First对应的判别式是0，而Enum::Second对应的判别式才是1。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/7&quot;&gt;点此查看 Rust Quiz 7&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-06-51759112</guid>
<pubDate>Thu, 06 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 6</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-06-51683754.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51683754&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt; 来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz  &lt;br&gt; &lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;&lt;br&gt; 不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。   &lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 6:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;use std::mem;

fn main() {
    let a;
    let a =  a = true;
    print!(&quot;{}&quot;, mem::size_of_val(&amp;amp;a));
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果：0&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;std::mem::size_of_val()&lt;/code&gt;函数的用法&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;变量屏蔽&lt;/li&gt;&lt;li&gt;变量声明和赋值&lt;/li&gt;&lt;li&gt;ZST（零大小类型）&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;main函数中，首先声明了&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，但并未赋值，也没有指定具体的类型。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let a = a = true;&lt;/code&gt;，等价于&lt;code class=&quot;inline&quot;&gt;let a = (a = true);&lt;/code&gt;，Rust中可以说是「一切皆表达式」。对于&lt;code class=&quot;inline&quot;&gt;(a=true)&lt;/code&gt;来说，是一个赋值表达式，该表达式的值永远返回单元类型&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;，同时它的值也是&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;。那么&lt;code class=&quot;inline&quot;&gt;let a = (a = true)&lt;/code&gt;;最终等价于&lt;code class=&quot;inline&quot;&gt;let a = ();&lt;/code&gt;。 &lt;/p&gt;&lt;p&gt;所以，在最后的print!打印语句里，使用&lt;code class=&quot;inline&quot;&gt;mem::size_of_val(&amp;amp;a)&lt;/code&gt;函数来计算&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的内存大小，此时等价于&lt;code class=&quot;inline&quot;&gt;mem::size_of_val(&amp;amp;())&lt;/code&gt;，对于单元类型来说，它并不占任何内存空间。在Rust中，这种类型叫做ZST（Zero Size Type）。它们不占空间，最终会被LLVM优化掉。所以输出当然是：0。&lt;/p&gt;&lt;p&gt;那么，上面代码发散一下，能否这么写呢?&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() {
    let a;
    let a =  a =  a = true;
    print!(&quot;{}&quot;, std::mem::size_of_val(&amp;amp;a));
}&lt;/code&gt;&lt;p&gt;注意这里的代码变化，&lt;code class=&quot;inline&quot;&gt;let a =  a =  a = true;&lt;/code&gt;，等价于&lt;code class=&quot;inline&quot;&gt;let a =  ( a =  (a = true) );&lt;/code&gt;。但仔细想想，这样成立吗？&lt;/p&gt;&lt;p&gt;执行以后会报错：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;error[E0308]: mismatched types
 --&amp;gt; src/main.rs:3:17
  |
3 |     let a = a = (a = true);
  |                 ^^^^^^^^^^ expected bool, found ()
  |
  = note: expected type `bool`
             found type `()`

error: aborting due to previous error&lt;/code&gt;&lt;p&gt;这是为什么呢？&lt;/p&gt;&lt;p&gt;首先，&lt;code class=&quot;inline&quot;&gt;(a = true)&lt;/code&gt;，已经让Rust编译器推断&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的类型为&lt;code class=&quot;inline&quot;&gt;bool&lt;/code&gt;了。然后，&lt;code class=&quot;inline&quot;&gt;(a = (a = true))&lt;/code&gt;，等价于，&lt;code class=&quot;inline&quot;&gt;(a = ());&lt;/code&gt;，类型不匹配，自然会报错。&lt;/p&gt;&lt;p&gt;但是为什么&lt;code class=&quot;inline&quot;&gt;let a = (a = true)&lt;/code&gt;，没有报相似的错呢？ 这是因为，当前执行的是&lt;code class=&quot;inline&quot;&gt;let a = ();&lt;/code&gt;，和&lt;code class=&quot;inline&quot;&gt;a = ();&lt;/code&gt;比较一下，区别在哪里？ &lt;/p&gt;&lt;p&gt;区别正是因为那个&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;，因为有&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;，所以这里是一个&lt;code class=&quot;inline&quot;&gt;变量屏蔽&lt;/code&gt;，也就是重新定义了一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，它的类型自然不受之前类型推断结果的影响。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/6&quot;&gt;点此查看 Rust Quiz 6&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-06-51683754</guid>
<pubDate>Thu, 06 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 5</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-05-51616607.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51616607&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt; 来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz  &lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt; &lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。   &lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 5:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Trait {
    fn f(self);
}

impl&amp;lt;T&amp;gt; Trait for fn(T) {
    fn f(self) {
        print!(&quot;1&quot;);
    }
}

impl&amp;lt;T&amp;gt; Trait for fn(&amp;amp;T) {
    fn f(self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let a: fn(_) = |_: u8| {};
    let b: fn(_) = |_: &amp;amp;u8| {};
    let c: fn(&amp;amp;_) = |_: &amp;amp;u8| {};
    a.f();
    b.f();
    c.f();
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果：112&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;考察要点：&lt;/b&gt; &lt;/p&gt;&lt;ol&gt;&lt;li&gt;fn(T)与fn(&amp;amp;T)的区别&lt;/li&gt;&lt;li&gt;类型推断&lt;/li&gt;&lt;li&gt;trait 实现&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;代码中定义了一个名为&lt;code class=&quot;inline&quot;&gt;Trait&lt;/code&gt;的trait，其中包含了方法签名&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;。然后分别为&lt;code class=&quot;inline&quot;&gt;fn(T)&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;fn(&amp;amp;T)&lt;/code&gt;这两种函数指针类型实现了Trait。&lt;/p&gt;&lt;p&gt;那&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt; 和&lt;code class=&quot;inline&quot;&gt;&amp;amp;T&lt;/code&gt;有啥区别呢？&lt;/p&gt;&lt;ul&gt;&lt;li&gt; T， 是一个泛型参数，代表任何一个具体的类型。那么&lt;code class=&quot;inline&quot;&gt;fn(T)&lt;/code&gt;就是指一个拥有具体类型的函数指针。&lt;/li&gt;&lt;li&gt;&amp;amp;T，实际上等价于&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a T&lt;/code&gt;，代表某个引用类型。则&lt;code class=&quot;inline&quot;&gt;fn(&amp;amp;T)&lt;/code&gt;，就是&lt;code class=&quot;inline&quot;&gt;fn(&amp;amp;&#39;a T)&lt;/code&gt;。注意这里的&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;也是一个泛型参数，并不是指具体的类型。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在main函数中，分别定义了三个变量绑定，a、b、c，分别将三个闭包指定为特定的函数指针类型。最后再分别调用它们的&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;方法。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let a: fn(_) = |_: u8| {};&lt;/code&gt;，对于&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;来说，&lt;code class=&quot;inline&quot;&gt;_&lt;/code&gt;会被推断为&lt;code class=&quot;inline&quot;&gt;u8&lt;/code&gt;类型。那么对应于&lt;code class=&quot;inline&quot;&gt;fn(T)&lt;/code&gt;类型，最终调用其f方法输出结果就是：1。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let b: fn(_) = |_: &amp;amp;u8| {};&lt;/code&gt;，对于&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;来说，&lt;code class=&quot;inline&quot;&gt;_&lt;/code&gt;会被推断为&lt;code class=&quot;inline&quot;&gt;&amp;amp;u8&lt;/code&gt;类型。这就是一个令人迷惑的点了，到底是对应&lt;code class=&quot;inline&quot;&gt;fn(T)&lt;/code&gt;还是&lt;code class=&quot;inline&quot;&gt;fn(&amp;amp;T)&lt;/code&gt;。这里的&lt;code class=&quot;inline&quot;&gt;&amp;amp;u8&lt;/code&gt;实际上是一个具体的值。它实际上等价于&lt;code class=&quot;inline&quot;&gt;f(&amp;amp;&#39;x u8)&lt;/code&gt;，这里的&lt;code class=&quot;inline&quot;&gt;&#39;x&lt;/code&gt;是一个具体的可确定的生命周期值。因为Rust生命周期参数，只有在具体使用的地方，才是具体实例化的。最终调用其f方法输出结果依然是：1。&lt;/p&gt;&lt;p&gt;let c: fn(&amp;amp;&lt;i&gt;) = |&lt;/i&gt;: &amp;amp;u8| {};&lt;code class=&quot;inline&quot;&gt;`，对于c来说，&lt;/code&gt;_&lt;code class=&quot;inline&quot;&gt;会被推断为&lt;/code&gt;u8&lt;code class=&quot;inline&quot;&gt;。此时显然，对应于&lt;/code&gt;fn(&amp;amp;T)&lt;code class=&quot;inline&quot;&gt;。&lt;/code&gt;&amp;amp;u8&lt;code class=&quot;inline&quot;&gt;的生命周期固然是已经具体实例化，但它的函数指针类型，依然是&lt;/code&gt;fn(&amp;amp;T)`。最终调用其方法输出结果就是： 2。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/5&quot;&gt;点此查看 Rust Quiz 5&lt;/a&gt; &lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-05-51616607</guid>
<pubDate>Wed, 05 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 4</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-04-51560682.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51560682&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 4:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() {
    let (.., x, y) = (0, 1, ..);
    print!(&quot;{}&quot;, b&quot;066&quot;[y][x]);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 54&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;考察要点： &lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;模式匹配&lt;/li&gt;&lt;li&gt;Range和RangeFull&lt;/li&gt;&lt;li&gt;字节字符串表示法&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;上面只有两行代码，但是隐藏了很多信息。&lt;/p&gt;&lt;p&gt;Rust中let绑定语句支持模式匹配。main函数中代码第一行是元组的匹配赋值操作。在等号左边的&lt;code class=&quot;inline&quot;&gt;(.., x, y)&lt;/code&gt;是匹配的模式，等号右边&lt;code class=&quot;inline&quot;&gt;(0, 1, ..)&lt;/code&gt;是要匹配的值。&lt;/p&gt;&lt;p&gt;这里最迷惑人的地方就是&lt;code class=&quot;inline&quot;&gt;..&lt;/code&gt;，在匹配模式中，&lt;code class=&quot;inline&quot;&gt;..&lt;/code&gt;代表其余要匹配的项。在上面示例中，就是除了x和y之外，要匹配的项。而在等号右边等待匹配的值中，&lt;code class=&quot;inline&quot;&gt;..&lt;/code&gt;则代表一个值：RangeFull。RangeFull是一个单元结构体，它代表Range（范围）的全范围类型。&lt;/p&gt;&lt;p&gt;所以，下面代码是合法的：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let range_full = std::ops::RangeFull;
let range_full = ..;&lt;/code&gt;&lt;p&gt;这两行代码是等价的。&lt;/p&gt;&lt;p&gt;所以，上面最终的元组匹配结果是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;左边&lt;code class=&quot;inline&quot;&gt;..&lt;/code&gt;匹配右边的&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;&lt;/li&gt;&lt;li&gt;左边&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;匹配右边的&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;&lt;/li&gt;&lt;li&gt;左边&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;匹配右边的&lt;code class=&quot;inline&quot;&gt;..&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;然后在最后的&lt;code class=&quot;inline&quot;&gt;print!&lt;/code&gt;语句中，&lt;code class=&quot;inline&quot;&gt;b&quot;0666&quot;&lt;/code&gt;实际上是一种字节字符串的语法糖，它等价于&lt;code class=&quot;inline&quot;&gt;[48u8, 54u8, 54u8]&lt;/code&gt;字节序列：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let d = [48u8, 54u8, 54u8];
 assert_eq!(&quot;066&quot;, std::str::from_utf8(&amp;amp;d).unwrap());&lt;/code&gt;&lt;p&gt;所以，&lt;code class=&quot;inline&quot;&gt;b&quot;066&quot;[y][x]&lt;/code&gt;现在是&lt;code class=&quot;inline&quot;&gt;b&quot;066&quot;[..][1] == b&quot;6&quot;&lt;/code&gt;，那么最终输出结果就是： 54。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/4&quot;&gt;点此查看 Rust Quiz 4&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-04-51560682</guid>
<pubDate>Tue, 04 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「付费阅读」如何为Rust语言做贡献</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-03-51479889.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51479889&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5d4a713aff10d99bf7e2d48b68018ce4_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;本文基于macOSX平台，通过对Rust 1.32 Nightly版本中rustdoc的一个ICE问题进行复盘，分析并记录整个Bug修复的过程。主要目的是，通过这个过程，来学习如何给Rust做贡献。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;（阅读时间：17m）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1. 缘起&lt;/p&gt;&lt;p&gt;2. Rust本地调试环境准备&lt;/p&gt;&lt;p&gt;3. ICE问题分析&lt;/p&gt;&lt;p&gt;4. 调试代码&lt;/p&gt;&lt;p&gt;5. 提交PR说明&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;---&lt;/p&gt;&lt;h2&gt;&lt;b&gt;缘起：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在两周前，我发现了一个rustdoc的[ICE(issue 55723)](&lt;a href=&quot;https://github.com/rust-lang/rust/issues/55723&quot;&gt;https://github.com/rust-lang/rust/issues/55723&lt;/a&gt;)，提交给了官方。但是官方指派修复此Bug的开发者QuietMisdreavus 难以复现该Bug。我本来以为Bug是因为多字节字符（比如全角符号之类）引起的，然而经过我仔细的测试，发现问题的根源在于尾随的「空格」。&lt;/p&gt;&lt;h2&gt;更多内容请花&lt;b&gt;一元查看&lt;/b&gt;：&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-233a6d659a6944c30a4d23a1cf8054aa_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;659&quot; data-rawheight=&quot;1920&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-233a6d659a6944c30a4d23a1cf8054aa&quot; data-watermark-src=&quot;v2-0a81c5365a61d19ca3a2bc04d60b2416&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-03-51479889</guid>
<pubDate>Mon, 03 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 3</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-03-51433417.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51433417&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;-  &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 3:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S {
    x: i32,
}

const S: S = S { x: 2 };

fn main() {
    let v = &amp;amp;mut S;
    v.x += 1;
    S.x += 1;
    print!(&quot;{}{}&quot;, v.x, S.x);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 32&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;考察要点： &lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;可变引用&lt;/li&gt;&lt;li&gt;结构体实例化不需要构造函数&lt;/li&gt;&lt;li&gt;const语义&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;代码中定义了一个具名结构体&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，包含了一个字段&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;。接下来又定义了一个&lt;code class=&quot;inline&quot;&gt;const&lt;/code&gt;常量，同样命名为&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，并且将一个结构体&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的实例赋值给它。&lt;/p&gt;&lt;p&gt;要注意区分这两个&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;。常量&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，是代表值，而结构体&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，则代表类型。在Rust中，分别将这两个S，存储在&lt;code class=&quot;inline&quot;&gt;值命名空间(Value NameSpace)&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;类型命名空间(Type NameSpace)&lt;/code&gt;中，所以可以同时存在两个相同的S。&lt;/p&gt;&lt;p&gt;常量S，会内联到用它的具体使用的地方。在语义层面，就是表示它的值会替换到使用它的每个地方。&lt;/p&gt;&lt;p&gt;&lt;b&gt;在main函数中， 常量S会被内联到两个地方：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;第一个地方&lt;/b&gt;是： &lt;code class=&quot;inline&quot;&gt;let v = &amp;amp;mut S;&lt;/code&gt;， 这里的S，是一个值，要被const S替换掉。等价于:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let mut _tmp = S {x: 2} ; 
let v = &amp;amp;mut tmp_;&lt;/code&gt;&lt;p&gt;所以，当执行 &lt;code class=&quot;inline&quot;&gt;v.x += 1&lt;/code&gt; 之后，&lt;code class=&quot;inline&quot;&gt;v.x&lt;/code&gt;的值就是：3。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第二个地方&lt;/b&gt;是：&lt;code class=&quot;inline&quot;&gt;S.x += 1;&lt;/code&gt;，这里的S同样会被替换为const S的值。等价于:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;S {x: 2}.x += 1;&lt;/code&gt;&lt;p&gt;而此时，这个S {: 2}是一个新的结构体实例，和上面的S已经无关，所以改变它的值，并不影响到&lt;code class=&quot;inline&quot;&gt;S.x&lt;/code&gt;的值，所以结果是: 2。&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-03-51433417</guid>
<pubDate>Mon, 03 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读： Quiz 2</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-02-51366804.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51366804&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;&lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 2:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S(i32);

impl std::ops::BitAnd&amp;lt;S&amp;gt; for () {
    type Output = ();

    fn bitand(self, rhs: S) {
        print!(&quot;{}&quot;, rhs.0);
    }
}

fn main() {
    let f = || ( () &amp;amp; S(1) );
    let g = || { () &amp;amp; S(2) };
    let h = || ( {} &amp;amp; S(3) );
    let i = || { {} &amp;amp; S(4) };
    f();
    g();
    h();
    i();
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果：123&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点： &lt;/p&gt;&lt;ol&gt;&lt;li&gt;trait：操作符重载&lt;/li&gt;&lt;li&gt;trait：关联类型&lt;/li&gt;&lt;li&gt;单元类型 ()&lt;/li&gt;&lt;li&gt;元组结构体&lt;/li&gt;&lt;li&gt;闭包使用圆括号和块的差异&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;代码中定义了元组结构体S(i32)，又为其实现了&lt;code class=&quot;inline&quot;&gt;std::ops::BitAdd&amp;lt;s&amp;gt;&lt;/code&gt; trait，意味着，该元组结构体就有了位运算&lt;code class=&quot;inline&quot;&gt;&amp;amp;&lt;/code&gt;的能力。&lt;/p&gt;&lt;p&gt;在实现BitAdd的代码中，指定了关联类型为单元类型&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;，在bitand方法中，省略了返回类型。等价于下面代码。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fn bitand(self, rhs: S) -&amp;gt; () { ... }&lt;/code&gt;&lt;p&gt;那么在main函数中：&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let f = || ( () &amp;amp; S(1) );&lt;/code&gt;  ， 这行代码中，f绑定的是一个闭包。闭包中&lt;code class=&quot;inline&quot;&gt;() &amp;amp; S(1)&lt;/code&gt;是一个位操作&lt;code class=&quot;inline&quot;&gt;&amp;amp;&lt;/code&gt;表达式。最终结果当然是输出&lt;code class=&quot;inline&quot;&gt;rhs.0&lt;/code&gt;，也就是：1。元组结构体和元组的用法是一样的。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let g = || { () &amp;amp; S(2) };&lt;/code&gt;， 这行代码中，g绑定的依然是一个闭包。闭包可以用圆括号，也可以用花括号。闭包内，&lt;code class=&quot;inline&quot;&gt;() &amp;amp; S(2)&lt;/code&gt;依然是一个完整的表达式，求值结果是：2。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let h = || ( {} &amp;amp; S(3) );&lt;/code&gt;，这行代码中，h同样是一个闭包，但注意这里闭包是用圆括号来表示，这代表，&lt;code class=&quot;inline&quot;&gt;{} &amp;amp; S(3)&lt;/code&gt;按一个完整独立的表达式来处理。其中&lt;code class=&quot;inline&quot;&gt;{}&lt;/code&gt;表达式求值结果是&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;，再和&lt;code class=&quot;inline&quot;&gt;S(3)&lt;/code&gt;进行与操作，得到最终值： 3。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let i = || { {} &amp;amp; S(4) };&lt;/code&gt;，这行代码中， i同样是一个闭包，然而，它是以花括号构成。花括号和圆括号的区别在于，花括号代表一个块（block），它默认按多条表达式语句进行解析。所以，&lt;code class=&quot;inline&quot;&gt;{} &amp;amp; S(4)&lt;/code&gt;，实际上被看作两条语句&lt;code class=&quot;inline&quot;&gt;{}&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&amp;amp;S(4)&lt;/code&gt;，最终闭包执行结果是返回一个&lt;code class=&quot;inline&quot;&gt;S(4)&lt;/code&gt;的引用。和位操作没有啥关系，最终也没有任何输出结果。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;{}&lt;/code&gt;的区别，不仅仅在于闭包，在写声明宏或者其他地方都是一致的。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/2&quot;&gt;点此查看 Rust Quiz 2 &lt;/a&gt; &lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-02-51366804</guid>
<pubDate>Sun, 02 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「Rust每日新闻」本周精选 • 第二十二期</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-02-51361684.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51361684&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-308c039c05fe1f2803788cde5b0b5f1a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;前言： 从2018年开始，我每天会花1个小时关注Rust社区动态，并且在&lt;a href=&quot;http://rust.cc/&quot;&gt;Rust.CC论坛&lt;/a&gt;、&lt;a href=&quot;https://t.me/rust_daily_news&quot;&gt;tg channel&lt;/a&gt;、&lt;a href=&quot;https://steemit.com/@blackanger&quot;&gt;Steemit&lt;/a&gt;、&lt;a href=&quot;https://github.com/RustStudy/rust_daily_news&quot;&gt;GitHub&lt;/a&gt;、&lt;a href=&quot;https://www.yuque.com/chaosbot/rustnews&quot;&gt;语雀订阅&lt;/a&gt;都开通了Rust每日新闻，分享我每天的见闻，偶尔也夹杂了一些个人的观点。大半年过去了，Rust每日新闻已经成为了Rust社区群大家每天必看的内容。在这个知乎专栏里，每周会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。 2018-12-02&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;官方新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;「通告」Rust 2018 新的Beta版发布！&lt;/h2&gt;&lt;p&gt;Rust 2018已经进入了最终的倒计时，官方刚刚发布了一个最新测试版。新的测试版包含了一些最近新稳定的功能和一些Bug修复。还包含一些工具的改进：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Rustfmt 1.0&lt;/li&gt;&lt;li&gt;RLS和Clpippy可以直接安装，不再是“preview”组件了。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;来帮助检测是否存在Bug。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://internals.rust-lang.org/t/announcing-rust-2018-beta-release/8901&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「官方」Rust 2018年度调查报告&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51018048&quot;&gt;中文&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html&quot;&gt;英文&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「官方」演变中的Tide中间件&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51048926&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「官方网络工作组」2018调查报告&lt;/h2&gt;&lt;p&gt;此次是网络工作组的报告，一共收到1000多条回复。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5409f04de7cc9a60cc28ec824ad2e208_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;427&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5409f04de7cc9a60cc28ec824ad2e208&quot; data-watermark-src=&quot;v2-d88e4f6aeac2b53dd2803933bb40e973&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在Web方面，流行的框架是Rocket和Actix，分别占比27%和24%。也有其他框架的选择，但是有20%的人不选择任何框架，而是在hyper上自行搭建服务。&lt;/p&gt;&lt;p&gt;存在的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;65%的人认为缺乏示例是目前生态系统中的问题，其次是缺乏文档。这也是Tokio Doc Push和Rust异步之书正在解决的问题。&lt;/li&gt;&lt;li&gt;缺乏一个真正的框架，类似于Rails或Django那样的。这也是网络工作组正在考虑的事情。为此官方构建了Tide，为打算使用Rust构建Web应用提供一个良好的开端，另一个目标是想要深入挖掘并学习如何在Rust中编写Web框架的人提供一个文档。&lt;/li&gt;&lt;li&gt;在构建应用程序时缺乏对框架和服务的一些绑定。包括绑定应用程序，比如各种NoSql数据库、支持在K8S上运行、编排容器框架和LDAP认证协议。以及对数据库的异步访问支持等，并没有一个惯用法的指南。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://rust-lang-nursery.github.io/wg-net/2018/11/28/wg-net-survey.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust官网界面改版引发争议&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://beta.rust-lang.org/&quot;&gt;官网改版测试界面&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ee7f2368481669814d6562478b86312f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;363&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ee7f2368481669814d6562478b86312f&quot; data-watermark-src=&quot;v2-af1cdfe38767b50686edefad0ed9f539&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;官方Rust Book现在有Epub版本下载&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.jyotirmoy.net/posts/2018-12-01-rust-book.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;社区新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;AWS Lambda已经支持Rust&lt;/h2&gt;&lt;p&gt;使用该库可以在AWS Lambda上运行Rust实现的函数&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/awslabs/aws-lambda-rust-runtime&quot;&gt;aws-lambda-rust-runtime&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/cn/blogs/opensource/rust-runtime-for-aws-lambda/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「游戏」Amethyst基金会成立了&lt;/h2&gt;&lt;p&gt;好消息。Amethyst是一款免费的开源游戏引擎。它是用Rust编写的，其核心是ECS架构。现在成立了基金会是为了组建一个官方的非盈利组织。这对于Amethyst的发展应该是非常有好处的了。当然，现在的状态只是提交了文件，还在等待最后的审批。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.amethyst.rs/blog/non-profit-announce/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「演讲」低延迟音频合成&lt;/h2&gt;&lt;p&gt;包含了演讲视频、代码和Slides。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://youtu.be/-F7whGjquHI?t=3150&quot;&gt;视频&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/raphlinus/synthesizer-io&quot;&gt;Code&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1cm9QaV_UjgvgBaWszHsR_w5EVre5O1D5kJUpMKQYo4I/edit?usp=sharing&quot;&gt;Slides&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;也可以多关注下后续，会有详细的博文放出。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://synthesize.rs/nov-2018-talk/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust Belt Rust 2018 大会 视频合集&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&quot;&gt;视频合集&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;AWS 出品 :  Firecracker&lt;/h2&gt;&lt;p&gt;Firecracker是一种开源虚拟化技术，专门用于创建和管理安全，多租户容器和基于功能的服务，提供无服务器操作模型。 Firecracker在轻量级虚拟机中运行工作负载，称为microVM，它将硬件虚拟化技术提供的安全性和隔离性与容器的速度和灵活性相结合。&lt;/p&gt;&lt;p&gt;看上去应该是兼容docker生态链，倾向于Serverless。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/firecracker-microvm/firecracker&quot;&gt;firecracker&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://firecracker-microvm.github.io/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/cn/blogs/aws/firecracker-lightweight-virtualization-for-serverless-computing/&quot;&gt;More Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「博文」Bitfury公司的工程师为俄罗斯邮政服务设计区块链&lt;/h2&gt;&lt;blockquote&gt; 本月，Bitfury®工程师Yury Yanovich，Ivan Prokhorov，Darya Korepanova和Sergey Vorobyov与Skolkovo科学技术研究所（Skoltech）的计算和数据密集型科学与工程中心一起在科学研究期刊Informatics上发表; 信息传输问题研究所数据挖掘和预测建模实验室; 罗蒙诺索夫莫斯科国立大学世界经济地理系; 和高等经济学院的工作是设计一个基于区块链的供应链，以防止印章伪造。 &lt;br&gt; &lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://www.mdpi.com/2227-9709/5/4/42/pdf&quot;&gt;论文&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/korepkorep/russian-post&quot;&gt;代码原型&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;RustQuiz: 26个在线Rust面试题&lt;/h2&gt;&lt;p&gt;来自于RustFest 2018 大会的轻演讲主题：Rust Quiz&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;RustaCUDA v0.1.0发布&lt;/h2&gt;&lt;p&gt;RustaCUDA是对CUDA API的Rust包装。允许分配和释放GPU内存，从GPU复制数据，加载CUDA模块和启动内核，所有这些都具有最安全，程序员友好的Rusty接口。 它可以加载和启动用任何CUDA兼容语言编写的内核，而不仅仅是Rust。&lt;/p&gt;&lt;p&gt;该作者对Rust支持CUDA作出了很多努力。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://bheisler.github.io/post/announcing-rustacuda/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/bheisler/RustaCUDA&quot;&gt;RustaCUDA&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Rocket v0.4 RC2版本发布&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://rocket.rs/v0.4/news/2018-11-30-version-0.4-rc-2/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;TOML规范 0.5中文翻译发布了&lt;/h2&gt;&lt;p&gt;从0.5开始，TOML规范趋于稳定。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/toml-lang/toml/blob/master/versions/cn/toml-v0.5.0.md&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Atom 1.33发布，内置Rust支持&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://blog.atom.io/2018/11/28/atom-1-33.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;改进的Rust贴纸，超酷&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://i.redd.it/206f9o60u0121.png&quot;&gt;下载&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「投票结果」你主要用什么操作系统构建Rust代码&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-26d65473d8e17fa47a494062e8486ce7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;752&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-26d65473d8e17fa47a494062e8486ce7&quot; data-watermark-src=&quot;v2-2193884c07be1e393268069632f3b76d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;学习资源&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;「付费」《如何系统地学习Rust》&lt;/h2&gt;&lt;p&gt;为你精心打造Rust必学第一课。 &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/lives/1043463438202249216&quot;&gt;知乎Live (已完结，可回看，9.9¥)&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust语言CheatSheet&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://cheats.rs/&quot;&gt;Cheats.rs&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust Quiz 解读： Quiz 1&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51304039&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;AoC 2018谜题Rust解决方案&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://adventofcode.com/&quot;&gt;AOC官网&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/BurntSushi/advent-of-code&quot;&gt;BurntSushi的解决方案&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/BenoitZugmeyer/RustyAdventOfCode#other-rust-implementations&quot;&gt;历年谜题解决方案&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;新书：用Rust编写WebAssembly&lt;/h2&gt;&lt;p&gt;beta版可预定。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://pragprog.com/book/khrust/programming-webassembly-with-rust&quot;&gt;programming-webassembly-with-rust&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「系列文章」数独谜题生成器 pt.3: 使用WebAssembly&lt;/h2&gt;&lt;p&gt;作者想用一个数独谜题生成器来检测WebAssembly的性能，他写了一系列文章，本文是第三篇，用Rust的wasm-bindgen工具来创建数独生成器的wasm模块。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/@rossharrison/generating-sudoku-boards-pt-3-rust-for-webassembly-85bd7294c34a&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「博文」如何将Tokio的AsyncRead和AsyncWrite转换为Futures, Sinks和Streams&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;AsyncRead to Future, 一次性读&lt;/li&gt;&lt;li&gt;AsyncRead to Stream, 持续读&lt;/li&gt;&lt;li&gt;AsyncWrite to Sink, 持续写&lt;/li&gt;&lt;li&gt;AsyncWrite to Future, 一次性写&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://jsdw.me/posts/rust-futures-tokio/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/jsdw/jsdw.me/blob/master/content/posts/rust-futures-tokio/src/main.rs&quot;&gt;Sample Code&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「博文」在Nightly版下使用async/await&lt;/h2&gt;&lt;p&gt;本文介绍了async/await，并且介绍了如何在最新的生态系统中使用老的futures 0.1。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://jsdw.me/posts/rust-asyncawait-preview/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「视频」使用Rust和Amethyst引擎进行游戏开发&lt;/h2&gt;&lt;p&gt;视频演讲中以一个开源的消除游戏everpuzzle为示例进行介绍。 [大约1小时]&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Skytrias/everpuzzle&quot;&gt;everpuzzle Code&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=P_9A7P0uNpY&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「嵌入式Rust」嵌入式开发环境&lt;/h2&gt;&lt;p&gt;作者尝试玩嵌入式，选择了以自定义一个ErgoDox键盘作为尝试。本教程介绍了相关的开发环境准备。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://josh.robsonchase.com/embedded-bootstrapping/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;在Android开发中使用Rust&lt;/h2&gt;&lt;p&gt;国内社区小伙伴写的文章，介绍如何在Android中使用Rust。&lt;/p&gt;&lt;p&gt;基于 &lt;a href=&quot;http://github.com/jni-rs/jni-rs&quot;&gt;jni-rs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50123055&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;使用Rust和Efflux编写 MapReduce Jobs&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://whitfin.io/writing-mapreduce-jobs-using-rust/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/whitfin/efflux&quot;&gt;efflux&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;项目&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;romio：异步网络原语&lt;/h2&gt;&lt;p&gt;无船同志写的 ：Mio + Future + Tokio = Romio。&lt;/p&gt;&lt;p&gt;（ 八卦： tokio作者不原意跟进Futures最新版，所以官方派出无船同志完成这项推动Rust异步历史进程的艰巨任务。） &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/withoutboats/romio&quot;&gt;romio&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Sequoia: OpenPGP的一个Rust实现&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://media.ccc.de/v/rustfest-rome-6-sequoia&quot;&gt;RustFest Roma上的演讲&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt; 关于Sequoia：Sequoia由三位前GnuPG开发商Neal H. Walfield，Justus Winter和Kai Michaelis开发。为了缓解许多常见的安全问题，Sequoia是用强类型语言Rust编写的，它提供了时间和空间内存安全性。 Rust还为将库嵌入其他语言提供了出色的支持。 Sequoia已经提供了C绑定，并且正在积极开发Python绑定。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://gitlab.com/sequoia-pgp/sequoia&quot;&gt;sequoia&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;秘猿开源CKB和CKB-VM&lt;/h2&gt;&lt;p&gt;Nervos CKB是一个公共授权区块链，是Nervos网络的共识层。CKB的VM是基于RISC-V指令集实现的。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/nervosnetwork/ckb&quot;&gt;ckb&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/nervosnetwork/ckb-vm&quot;&gt;ckb-vm&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;高性能JavaScript到JavaScript编译器&lt;/h2&gt;&lt;p&gt;基于Rust和Wasm实现&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ratel-rust/ratel-core&quot;&gt;ratel-core&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;使用Cranelift实现的玩具语言JIT&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/CraneStation/simplejit-demo&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Atlasr： 免费的地图预览器&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/atlasr-org/atlasr&quot;&gt;atlasr&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Tange：基于任务的并行框架&lt;/h2&gt;&lt;p&gt;“任务并行”是指一个或多个独立的任务同时运行。 可以用来做并行计算。用于：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;数据处理&lt;/li&gt;&lt;li&gt;分布式机器学习算法&lt;/li&gt;&lt;li&gt;一般的并行计算&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Refefer/tange&quot;&gt;tange&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;工具与库&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;tr: 国际化（i18n）库&lt;/h2&gt;&lt;p&gt;刚发布，现在找人使用，并且想得到更多反馈。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/a09b0n/tr_a_crate_for_internationalizationof_rust_code/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「工具」宣布RustPräzi：为crates.io构建整个调用图(call graph)&lt;/h2&gt;&lt;blockquote&gt; 我们很高兴地宣布我们的第一个版本的RustPräzi，一个PoC（概念验证）项目，它从crates.io 3下载所有crate版本，构建LLVM调用图并将它们链接到一个大型版本的基于呼叫的依赖网络。与常规依赖关系网络不同，基于调用的依赖关系网络表示包内和包之间的函数调用链，支持图形分析/查询&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;一个CG是表示整个程序中方法（函数）之间调用关系的图，图中的节点是方法，边表示调用关系。例如方法foo()调用了方法bar()，则CG中应有一条从foo()到bar()的有向边。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://users.rust-lang.org/t/announcing-rustprazi-a-tool-to-build-an-entire-call-graph-of-crates-io/22696&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;高效diff算法库&lt;/h2&gt;&lt;p&gt;pijul开源了它们用的diff算法。pijul是基于Rust实现的类Git版本控制工具，&lt;a href=&quot;https://jneem.github.io/pijul/&quot;&gt;用法介绍&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://docs.rs/diffs/0.1.0/diffs/&quot;&gt;diffs&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;招聘&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;「招聘」位于美国旧金山市中心的公司招Rust工程师&lt;/h2&gt;&lt;p&gt;这是去矿上工作啊。想用Rust构建大型的数字货币和大型采矿系统。没看到说可以远程的信息，应该是不能远程了。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;薪水 120k ~ 160k美刀 + 股权&lt;/li&gt;&lt;li&gt;旧金山软件工程师的平均工资是134,000美元&lt;/li&gt;&lt;li&gt;旧金山的失业率为3％&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://functional.works-hub.com/jobs/rust-engineer-in-san-francisco-united-states-of-america-3a18b&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-02-51361684</guid>
<pubDate>Sun, 02 Dec 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
