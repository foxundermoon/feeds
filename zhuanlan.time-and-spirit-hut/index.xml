<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>时光与精神小屋</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Mon, 17 Dec 2018 00:59:37 +0800</lastBuildDate>
<item>
<title>「Rust每日新闻」本周精选 • 第二十四期</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-16-52509923.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52509923&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-23599072636a1820bba7b49b9d586092_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;前言：&lt;br&gt;&lt;br&gt;从2018年开始，我每天会花1个小时关注Rust社区动态，并且在&lt;a href=&quot;http://rust.cc/&quot;&gt;Rust.CC论坛&lt;/a&gt;、&lt;a href=&quot;https://t.me/rust_daily_news&quot;&gt;tg channel&lt;/a&gt;、&lt;a href=&quot;https://steemit.com/@blackanger&quot;&gt;Steemit&lt;/a&gt;、&lt;a href=&quot;https://github.com/RustStudy/rust_daily_news&quot;&gt;GitHub&lt;/a&gt;、&lt;a href=&quot;https://www.yuque.com/chaosbot/rustnews&quot;&gt;语雀订阅&lt;/a&gt;都开通了Rust每日新闻，分享我每天的见闻，偶尔也夹杂了一些个人的观点。大半年过去了，Rust每日新闻已经成为了Rust社区群大家每天必看的内容。在这个知乎专栏里，每周会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。&lt;br&gt;&lt;br&gt;2018-12-16&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;「付费阅读」系列&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51479889&quot;&gt;如何为Rust语言做贡献&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52032027&quot;&gt;Rust Quiz 11&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;官方新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;官方核心成员nrc对Rust 2021 Edition的思考：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52181046&quot;&gt;Rust 2022&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「官方网络工作组」异步进展&lt;/h2&gt;&lt;h2&gt;async&lt;/h2&gt;&lt;p&gt;虽然Rust 2018发布的时候没有稳定异步编程，但在今年，异步编程也取得了很大进展。网络工作组发文，介绍了几个促进Nightly生态中使用async/await的crate。&lt;/p&gt;&lt;p&gt;async/await对Rust的重要性：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;async/await在其他语言中已经证明了其可用性&lt;/li&gt;&lt;li&gt;在Rust中引入async/await中需要多考虑一个元素：借用。所以，之前在编写异步代码的时候，必须使用&lt;code class=&quot;inline&quot;&gt;&#39;static&lt;/code&gt;限定，并且还经常要用到Arc和Mutex。&lt;/li&gt;&lt;li&gt;async/await语法稳定之后，将不会有「借用」相关的问题。但是在这之前，还有很多工作要做，比如稳定await语法。现在google的Fuchsia项目已经在大规模使用async/await语法了。&lt;/li&gt;&lt;li&gt;标准库中支持Future等trait的工作也即将完成。&lt;/li&gt;&lt;li&gt;确定了各种API，包括Waker、Pin、与tokio兼容的futures-rs 0.1等。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;发布了一些新的crate：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/withoutboats/romio&quot;&gt;romio&lt;/a&gt;，之前介绍过，是对tokio最小化包装，为了支持async/await。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.rs/http-service&quot;&gt;http-service&lt;/a&gt;， 一个基于字节的、http和新的futures API的crate，提供HTTP通用接口。是从Tide库中提取出来的API。&lt;/li&gt;&lt;li&gt;Tyger，即将推出的这个库是在Hyper上面构建的一个小的crate。提供直接的HTTP服务接口，因此可以直接使用async/await。Tyger也会对Hyper增加一些补充，提供一些更高级的抽象。也是从Tide中提取出来的包。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;官方希望在2019年上半年稳定async/await。官方所考虑的不仅仅是支持这个语法，而且还在为打造async/await生态做足了准备。这也是异步编程支持如此缓慢的原因。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://rust-lang-nursery.github.io/wg-net/2018/12/13/async-update.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;社区新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;OS2ATC2018(第六届开源操作系统年度会议)会议现场直播链接&lt;/h2&gt;&lt;p&gt;现在的topic： 《Design &amp;amp; Implementation of uCore Plus OS in Rust Lang》（清华大学ucore操作系统课程升级Rust教学）&lt;/p&gt;&lt;p&gt;https://flypage.chinamcloud.com/h5/tpl/index.html?id=6469&amp;amp;tid=810&lt;/p&gt;&lt;p&gt;日程： http://soft.cs.tsinghua.edu.cn/os2atc2018/rc.html&lt;/p&gt;&lt;h2&gt;「安全」Crossbeam发现double-free Bug&lt;/h2&gt;&lt;blockquote&gt; MsQueue和SegQueue会发生此Bug。 即使从队列中弹出一个元素，crossbeam也会运行它，此问题来自于crossbeam-epoch的垃圾收集器内的析构函数。 &lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/RustSec/advisory-db/blob/master/crates/crossbeam/RUSTSEC-2018-0009.toml&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;crev: 代码审查工具箱&lt;/h2&gt;&lt;p&gt;提供了一个cargo工具：&lt;a href=&quot;https://github.com/dpc/crev/tree/master/cargo-crev&quot;&gt;cargo-crev&lt;/a&gt;&lt;/p&gt;&lt;p&gt;该工具可以判断你项目中依赖crate的安全性、质量和发现的问题。可以在公共的git仓库里发布可验证的review信息。通过这种方式期望在Rust生态系统中构建可信任的网络。将不会有人再受到未经审查和不受信任代码的困扰。&lt;/p&gt;&lt;p&gt;想想npm因为依赖包出了多少次安全事故。这个工具ms不错，但是否真的可以解决问题？&lt;/p&gt;&lt;p&gt;使用方法：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;cd &amp;lt;your-project&amp;gt;
cargo crev id gen # generate your id
cargo crev verify # verify your depedencies
cargo crev review &amp;lt;crate&amp;gt; # review a dependency
cargo crev db git status # check git status of your proof database
cargo crev db git -- ci -a # commit everything
cargo crev db git push # push it to your github repository
cargo crev trust &amp;lt;id&amp;gt; # trust someone with a given CrevId
cargo crev db fetch # fetch updates from all people you trust
cargo crev verify # verify again
cargo crev help # see what other things you can do&lt;/code&gt;&lt;p&gt;其中id是可以通过&lt;a href=&quot;https://gitter.im/dpc/crev&quot;&gt;crev gitter channel&lt;/a&gt;来共享给大家的，形成信任网络。然后可以通过 &lt;code class=&quot;inline&quot;&gt;cargo crev trust &amp;lt;id&amp;gt;&lt;/code&gt;命令从你信任的人那里获取依赖crate。&lt;/p&gt;&lt;p&gt;当然，这世界上没有绝对的安全，但也无法阻碍人们追求它的脚步。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/dpc/crev&quot;&gt;crev&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust非常适合高性能科学计算&lt;/h2&gt;&lt;p&gt;来自某粒子物理实验室的软件性能工程师Hadrien坦言，相比于Cpp，Rust更适合高性能科学计算。并且对Rust能进入这个领域之前需要完善的工作提出了他自己的建议，同时也希望Rust 2019的目标之一可以是「高性能科学计算」。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://gist.github.com/HadrienG2/e9a875bdf98b528594f4e20f8176bb68&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;杭州Rust线下Meetup回放视频&lt;/h2&gt;&lt;p&gt;一共两场分享，视频地址是第二场分享，在列表里也能找到另外一场分享的视频。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av38044021/?share_source=qq&amp;amp;ts=1544706808&amp;amp;share_medium=iphone&amp;amp;bbid=dd199f5b7049675783521db5317f49ba&quot;&gt;Bilibili&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;使用Rust和WebAssembly进行edge计算&lt;/h2&gt;&lt;p&gt;什么是边缘计算？ 边缘计算将数据的处理、应用程序的运行甚至一些功能服务的实现，由网络中心下放到网络边缘的节点上。属于一种分布式计算。一直以来，公共和企业设施的监测和维护消耗着大量的人力、物力成本；电力、制造等行业数字化转型中对海量数据的实时、智能处理也有着强烈需求。如果用常规模式构建物联网，所有数据都交给云端，那么会带来一系列的问题。边缘计算就是为了解决这个问题。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.fastlylabs.com/&quot;&gt;fastlylabs&lt;/a&gt;公司，推出了一个产品Terrarium（看着像是用webassembly.studio改造的），是一个基于浏览器的多语言编辑和部署平台。据该公司描述，此产品是为了推进边缘计算。Terrarium是基于WebAssembly沙箱而构建。Terrarium可以将几种不同的编程语言编译为WebAssembly，然后将其编译为快速，安全的本地代码，并用于为Web服务提供动力。&lt;/p&gt;&lt;p&gt;本文介绍了如何用Rust和Terrarium进行编写边缘计算服务。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.fastly.com/blog/edge-programming-rust-web-assembly&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「趣味」Rust Raps: Rust 2018 Edition首张单曲发布&lt;/h2&gt;&lt;p&gt;由Rusta Rhymes推出的热门新单曲“Ferris Crab（Rust Raps 2018 Edition）”即将推出首张专辑“Drop for Mic”。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://fitzgeraldnick.com/media/rust-raps.mp3&quot;&gt;在线听&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://fitzgeraldnick.com/2018/12/13/rust-raps.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust开发的一款编程教学游戏预览&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-63e41a23be7999267843b7c023bebf14_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;389&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-63e41a23be7999267843b7c023bebf14&quot; data-watermark-src=&quot;v2-6f63f7f5f828c1dfd9ec0712aef949fb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.roboinstruct.us/2018/12/07/looking-good.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;学习资源&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;Rust Quiz解读已更新到Quiz 15&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/time-and-spirit-hut&quot;&gt;去专栏 Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust 异步函数内部转换流程&lt;/h2&gt;&lt;p&gt;本文介绍了Rust内部async/await的内部转换机制，包括generator、状态转换过程等。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blag.nemo157.com/2018/12/09/inside-rusts-async-transform.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;使用Cargo Test来Debug代码&lt;/h2&gt;&lt;p&gt;本文介绍了使用cargo test命令，结合单元测试来调试代码中的问题。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.wihlidal.com/blog/general/2018-12-07-debugging-cargo-test/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「系列博文」在浏览器中使用WASM Part 1&lt;/h2&gt;&lt;p&gt;本文介绍了如何使用Rust编译wasm，并在浏览器中使用它。同时也包括了wasm的工作机制，值得一看。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://ljcode.org/blog/wasm-part1/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;在AWS Lambda上面运行Rust&lt;/h2&gt;&lt;p&gt;本文以编写一个独立的crate为例，从代码编写到部署，介绍如何在AWS Lambda上面运行Rust库。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://kellenfujimoto.com/posts/dicers-rust-on-lambda/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「嵌入式Rust」Cortex-M3 入门指南（一）：体系概述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52235675&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「视频」如何在Rust/C/C++/.Net中使用SIMD&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=4Gs_CA_vm3o&quot;&gt;youtube&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;用Rust为Kubernetes动态生成Dockerfiles&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/docql/dynamically-generating-dockerfiles-for-k8s-d2baf7bfef5a&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「Slides」在Rust中使用C的va_list&lt;/h2&gt;&lt;p&gt;以及，你为什么不应该用它。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://dlrobertson.com/slides/va-list-12-13-2018.html#/&quot;&gt;PPT&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/a6j4hu/using_cs_va_list_in_rust_and_why_you_never_should/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;项目&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;libui-rs: libui的Rust绑定&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/LeoTindall/libui-rs&quot;&gt;libui-rs&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;gba: 帮助你创建GBA游戏&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-console/gba&quot;&gt;gba&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://rust-console.github.io/gba/&quot;&gt;gba book&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;NASA开源的静态分析工具: ikos&lt;/h2&gt;&lt;p&gt;虽然是为C/C++静态分析实现的工具，但据说也适用于LLVM IR，因此有助于检测Unsafe Rust的代码。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/NASA-SW-VnV/ikos&quot;&gt;ikos&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/a5kyz9/ikos_21_an_open_source_static_analyzer_from_nasa/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;seed: Rust+WebAssembly 前端框架&lt;/h2&gt;&lt;p&gt;基于wasm-bindgen和js-sys创建。创建应用时需要依赖web-sys。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/David-OConnor/seed&quot;&gt;seed&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「区块链」comit-rs：Comit协议的Rust实现&lt;/h2&gt;&lt;p&gt;COMIT是一个协议，以链接不同的区块链。以便将区块链生态系统打造地更大，更具有包容性。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/comit-network/comit-rs&quot;&gt;comit-network/comit-rs&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;[WIP] Rust实现的Lua解释器&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kyren/luster&quot;&gt;luster&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust开发安全应用程序指南&lt;/h2&gt;&lt;p&gt;该指南不是Rust语言教程，只是记录Rust开发应用程序过程中可能出现的「坑」，特别是开发一些对安全性要求较高的程序需要注意的地方。该指南还在持续更新中。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/ANSSI-FR/rust-guide&quot;&gt;rust-guide&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/ANSSI-FR/rust-guide/blob/master/src/SUMMARY.md&quot;&gt;Online Read&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;使用Rust配置管理kubernetes&lt;/h2&gt;&lt;p&gt;本文作者使用Rust构建了一个用于管理k8s上运行的微服务声明格式和生命周期的标准化工具shipcat。它封装了k8s的API，目的是为了更加标准化、版本化、权限化、自动化管理k8s。本文阐述了k8s管理中的问题，以及shipcat的解决思路。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Babylonpartners/shipcat&quot;&gt;shipcat&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://clux.github.io/probes/post/2018-12-15-config-management-in-rust/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;工具与库&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;spirit教程&lt;/h2&gt;&lt;p&gt;spirit可以帮助开发者更容易地构建Unix守护进程。 文章里介绍了它的使用方法。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/vorner/spirit&quot;&gt;spirit&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://vorner.github.io/2018/12/09/Spirit-Tutorial.html&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;parstream： 基于线程池以流方式计算迭代函数&lt;/h2&gt;&lt;p&gt;并且不会打乱迭代器中元素的顺序。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/newpavlov/parstream&quot;&gt;parstream&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;命令行使用频率跟踪工具fe&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ccheek21/fe&quot;&gt;fe&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;pom：又一个peg解析器&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/J-F-Liu/pom&quot;&gt;pom&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;支持no_std的Curve25519加密库&lt;/h2&gt;&lt;p&gt;椭圆曲线加密/签名/密钥交换算法Curve25519的 &lt;code class=&quot;inline&quot;&gt;#[no_std]&lt;/code&gt; 版本&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/shekohex/curve25519-rs&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-16-52509923</guid>
<pubDate>Sun, 16 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 15</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-16-52508991.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52508991&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;-  &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;br&gt;&lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 15:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Trait {
    fn f(&amp;amp;self);
}

impl Trait for u32 {
    fn f(&amp;amp;self) {
        print!(&quot;1&quot;);
    }
}

impl&amp;lt;&#39;a&amp;gt; Trait for &amp;amp;&#39;a i32 {
    fn f(&amp;amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let x = &amp;amp;0;
    x.f();
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 1&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;trait实现&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a T&lt;/code&gt;的区别&lt;/li&gt;&lt;li&gt;类型推断&lt;/li&gt;&lt;li&gt;自动加引用&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;其实Quiz 15和Quiz 5的考察点是相似的。主要是考察&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt; 和&lt;code class=&quot;inline&quot;&gt;&amp;amp;T&lt;/code&gt;有啥区别呢？虽然这里是&lt;code class=&quot;inline&quot;&gt;u32&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&amp;amp;’a i32&lt;/code&gt;。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;T， 是一个泛型参数，代表任何一个具体的类型。&lt;/li&gt;&lt;li&gt;&amp;amp;T，实际上等价于&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a T&lt;/code&gt;，代表某个引用类型。注意这里的&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;也是一个泛型参数，并不是指具体的类型。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;main函数中直接使用了&lt;code class=&quot;inline&quot;&gt;let x = &amp;amp;0;&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;&amp;amp;0&lt;/code&gt;实际上是一个包含了具体生命周期参数实例的具体类型&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a 0&lt;/code&gt;。所以，&lt;code class=&quot;inline&quot;&gt;&amp;amp;0&lt;/code&gt;实际上会被推断为一个具体的&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;类型的实例&lt;code class=&quot;inline&quot;&gt;u32&lt;/code&gt;。 &lt;/p&gt;&lt;p&gt;这和&lt;code class=&quot;inline&quot;&gt;impl Trait for ...&lt;/code&gt;的定义顺序无关。不妨把&lt;code class=&quot;inline&quot;&gt;impl&amp;lt;&#39;a&amp;gt; Trait for &amp;amp;&#39;a i32 { ... }&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;impl Trait for u32 { ... }&lt;/code&gt;的顺序交换，输出结果照样不变。&lt;/p&gt;&lt;p&gt;此时在&lt;code class=&quot;inline&quot;&gt;u32&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;方法实现中&lt;code class=&quot;inline&quot;&gt;self&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;&amp;amp;u32&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;所以，&lt;code class=&quot;inline&quot;&gt;x.f()&lt;/code&gt;会输出&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果把&lt;code class=&quot;inline&quot;&gt;impl Trait for u32 {}&lt;/code&gt;实现注释掉。则 &lt;code class=&quot;inline&quot;&gt;x.f()&lt;/code&gt;会输出&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Trait {
    fn f(&amp;amp;self);
}

impl&amp;lt;&#39;a&amp;gt; Trait for &amp;amp;&#39;a i32 {
    fn f(&amp;amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let x = &amp;amp;0;
    x.f();
}&lt;/code&gt;&lt;p&gt;在这个代码中，&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;方法中的&lt;code class=&quot;inline&quot;&gt;self&lt;/code&gt;会被自动加引用为&lt;code class=&quot;inline&quot;&gt;&amp;amp;&amp;amp;0&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/15&quot;&gt;点此查看 Rust Quiz 15&lt;/a&gt; &lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-16-52508991</guid>
<pubDate>Sun, 16 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 14</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-14-52418867.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52418867&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt; 来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz  &lt;br&gt; &lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt; &lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。   &lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 14:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Trait: Sized {
    fn is_reference(self) -&amp;gt; bool;
}

impl&amp;lt;&#39;a, T&amp;gt; Trait for &amp;amp;&#39;a T {
    fn is_reference(self) -&amp;gt; bool {
        true
    }
}

fn main() {
    match 0.is_reference() {
        true =&amp;gt; print!(&quot;1&quot;),
        false =&amp;gt; print!(&quot;0&quot;),
    }

    match &#39;?&#39;.is_reference() {
        true =&amp;gt; print!(&quot;1&quot;),
        false =&amp;gt; {
            impl Trait for char {
                fn is_reference(self) -&amp;gt; bool {
                    false
                }
            }
            print!(&quot;0&quot;)
        }
    }
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果：10&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;自动引用（autoref）&lt;/li&gt;&lt;li&gt;impl trait 的可见性&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Quiz代码中定义了Trait，并限定了Sized trait。这意味着该Trait无法当作trait对象来使用。但是对于Quiz代码来说没有啥特殊意义。&lt;/p&gt;&lt;p&gt;然后为&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a T&lt;/code&gt;实现了Trait：&lt;code class=&quot;inline&quot;&gt;impl&amp;lt;&#39;a, T&amp;gt; Trait for &amp;amp;&#39;a T { ... }&lt;/code&gt;。&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a T&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;有什么区别呢？在之前的Quiz解读中已经讲过了。&lt;/p&gt;&lt;p&gt;在main函数中， &lt;code class=&quot;inline&quot;&gt;match 0.is_reference(){ ... }&lt;/code&gt;，当调用数字&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;is_reference&lt;/code&gt;方法时，你可能会想，数字类型有没有被实现&lt;code class=&quot;inline&quot;&gt;Trait&lt;/code&gt;呢？在为&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a T&lt;/code&gt;的实现中，&lt;code class=&quot;inline&quot;&gt;is_reference&lt;/code&gt;的参数是&lt;code class=&quot;inline&quot;&gt;self&lt;/code&gt;。到底编译会不会成功呢？&lt;/p&gt;&lt;p&gt;事实上，这里涉及一个规则：自动引用。&lt;/p&gt;&lt;p&gt;当调用&lt;code class=&quot;inline&quot;&gt;0.is_reference()&lt;/code&gt;的时候，会为&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;自动添加引用，等价于&lt;code class=&quot;inline&quot;&gt;(&amp;amp;0).is_reference()&lt;/code&gt;。 这是因为上下文中只有为&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a T&lt;/code&gt;实现了&lt;code class=&quot;inline&quot;&gt;Trait&lt;/code&gt;。此时&lt;code class=&quot;inline&quot;&gt;is_reference&lt;/code&gt;方法中的&lt;code class=&quot;inline&quot;&gt;self&lt;/code&gt;等价于&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a i32&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果为&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;实现&lt;code class=&quot;inline&quot;&gt;Trait&lt;/code&gt;，就不会存在自动引用了。&lt;/p&gt;&lt;p&gt;注意：在Rust中与自动引用对应的规则，还有一个&lt;code class=&quot;inline&quot;&gt;自动解引用(auto deref)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;所以，这里&lt;code class=&quot;inline&quot;&gt;0.is_reference()&lt;/code&gt;调用，会返回true。输出结果当然是： &lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;而&lt;code class=&quot;inline&quot;&gt;match &#39;?&#39;.is_reference()&lt;/code&gt;，是调用字符&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;is_reference()&lt;/code&gt;方法。这里迷惑人的地方就是&lt;code class=&quot;inline&quot;&gt;impl Trait for char { ... }&lt;/code&gt;实现是放到了&lt;code class=&quot;inline&quot;&gt;false&lt;/code&gt;匹配分支中。但实际上&lt;code class=&quot;inline&quot;&gt;impl Trait for char {...}&lt;/code&gt;是对整个Quiz代码可见的。所以，在&lt;code class=&quot;inline&quot;&gt;&#39;?&#39;.is_reference()&lt;/code&gt;调用的时候，它会输出&lt;code class=&quot;inline&quot;&gt;false&lt;/code&gt;，最终match匹配结果自然是： &lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果你将&lt;code class=&quot;inline&quot;&gt;impl Trait for char {...}&lt;/code&gt;实现代码去掉的话：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;match &#39;?&#39;.is_reference() {
    true =&amp;gt; print!(&quot;1&quot;),
    false =&amp;gt; print!(&quot;0&quot;)
}&lt;/code&gt;&lt;p&gt;输出结果将会是：&lt;code class=&quot;inline&quot;&gt;11&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/14&quot;&gt;点此查看 Rust Quiz 14&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-14-52418867</guid>
<pubDate>Fri, 14 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 13</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-12-52189029.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52189029&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz  &lt;br&gt; &lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;&lt;br&gt; 不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。   &lt;/blockquote&gt;&lt;h2&gt;Quiz 13:&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S;

fn main() {
    let [x, y] = &amp;amp;mut [S, S];
    let eq = x as *mut S == y as *mut S;
    print!(&quot;{}&quot;, eq as u8);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果：1&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;解读&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;单元结构体&lt;/li&gt;&lt;li&gt;let绑定模式匹配&lt;/li&gt;&lt;li&gt;数组布局&lt;/li&gt;&lt;li&gt;操作符优先级&lt;/li&gt;&lt;li&gt;引用和原生指针的转换&lt;/li&gt;&lt;li&gt;bool类型转换为数字&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Quiz代码中定义了单元结构体&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;。在main函数中，使用let绑定模式匹解构&lt;code class=&quot;inline&quot;&gt;&amp;amp;mut [S, S]&lt;/code&gt;数组，定义了&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;两个变量。&lt;/p&gt;&lt;p&gt;此时&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;的值分别是&lt;code class=&quot;inline&quot;&gt;&amp;amp;mut S&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&amp;amp;mut S&lt;/code&gt;。 数组本身是可变借用，那么其元素自然也是借用，不可能是拥有其所有权。&lt;/p&gt;&lt;p&gt;这里可能有人要怀疑&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;同时对&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;进行可变借用，合法吗？答案是肯定的。因为此时&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;借用的单元结构体&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;可看作是两个独立的结构体实例。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let eq = x as *mut S == y as *mut S;&lt;/code&gt;这行代码等价于&lt;code class=&quot;inline&quot;&gt;let eq = ( (x as *mut S) == (y as *mut S) );&lt;/code&gt;。优先级&lt;code class=&quot;inline&quot;&gt;as&lt;/code&gt; &amp;gt; &lt;code class=&quot;inline&quot;&gt;==&lt;/code&gt; &amp;gt; &lt;code class=&quot;inline&quot;&gt;=&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;本身是可变借用，然后通过&lt;code class=&quot;inline&quot;&gt;as&lt;/code&gt;转换为原生可变指针类型（*mut S），然后对它们进行比较，是看它们的地址是否相同。然后将最后的bool类型结果赋值给&lt;code class=&quot;inline&quot;&gt;eq&lt;/code&gt;。最后通过&lt;code class=&quot;inline&quot;&gt;as&lt;/code&gt;将&lt;code class=&quot;inline&quot;&gt;bool&lt;/code&gt;类型的值转换为&lt;code class=&quot;inline&quot;&gt;u8&lt;/code&gt;。可以预测结果，不是&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;就是&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;，其中&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;对应于&lt;code class=&quot;inline&quot;&gt;false&lt;/code&gt;， &lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;对应于&lt;code class=&quot;inline&quot;&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;虽然分析出了整个过程，但是我无法确定这里到底是输出1还是0。因为我无法确定这里Rust的行为，这两个原生指针地址是否相同。&lt;/p&gt;&lt;p&gt;想知道我为啥有这个疑问吗？可以看看下面的代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct Empty;
fn main() {
    let x = &amp;amp;mut Empty;
    println!(&quot;x {:p}&quot;, x);
    let y = &amp;amp;mut Empty;
    println!(&quot;y {:p}&quot;, y);
}&lt;/code&gt;&lt;p&gt;此代码在Debug模式下编译的结果是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;x 0x7fff5b8c2058
y 0x7fff5b8c20c0&lt;/code&gt;&lt;p&gt;在Release模式下编译的结果是：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;x 0x7ffe9ae101d8
y 0x7ffe9ae101d8&lt;/code&gt;&lt;p&gt;所以，你明白了吗？ 在Debug模式下编译，不同的单元结构体实例，地址是不同的，但是在Release模式下，不同的单元结构体实例会被优化成同一个地址。&lt;/p&gt;&lt;p&gt;这就是我为什么不敢确定Quiz代码输出结果的原因。没办法，只能把Quiz代码实际执行一下看看输出结果了。然后发现，不管是Debug模式还是Release模式，Quiz代码的输出结果都是&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。也就是说，&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;的地址是一样的。&lt;/p&gt;&lt;p&gt;这是怎么回事呢？&lt;/p&gt;&lt;p&gt;我注意到Quiz代码和我上面编写代码中定义变量的区别：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// Quiz 代码中
let [x, y] = &amp;amp;mut [S, S];

// 我自定义代码中
let x = &amp;amp;mut Empty;
let y = &amp;amp;mut Empty;&lt;/code&gt;&lt;p&gt;我有所悟： 在Quiz代码中的两个单元结构体实例是放到一个&lt;code class=&quot;inline&quot;&gt;[S; 2]&lt;/code&gt;类型的数组中的，同一个数组的起始地址肯定是一样的。难道Rust把数组的起始地址作为&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;这两个实例的地址？&lt;/p&gt;&lt;p&gt;来看下面代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S;
struct E;

struct A {
    s: S,
    e: E,
}

fn main() {
    let (x, y) = &amp;amp;mut (S, E);
    println!(&quot;{:p}&quot;, x as *mut S);
    println!(&quot;{:p}&quot;, y as *mut E);

    let A{s, e} = &amp;amp;mut A{s: S, e: E};
    println!(&quot;{:p}&quot;, s as *mut S);
    println!(&quot;{:p}&quot;, e as *mut E);
}&lt;/code&gt;&lt;p&gt;在Debug模式下编译：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;0x7ffe370bd7b8
0x7ffe370bd7b8
0x7ffe370bd890
0x7ffe370bd890&lt;/code&gt;&lt;p&gt;在Release模式下编译：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;0x7ffcde64f608
0x7ffcde64f608
0x7ffcde64f608
0x7ffcde64f608&lt;/code&gt;&lt;p&gt;所以，你明白了吗？&lt;/p&gt;&lt;h2&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/13&quot;&gt;点此查看 Rust Quiz 13&lt;/a&gt; &lt;/h2&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-12-52189029</guid>
<pubDate>Wed, 12 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust 2022</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-12-52181046.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52181046&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c2dd047bb41769e871c4282d775cdbff_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;b&gt;前几天Rust 2018 Edition刚刚发布，官方以及整个Rust社区，开始思考下一个Edition大版本的目标该是什么？以及Rust 2019的Roadmap。&lt;/b&gt;&lt;br&gt;&lt;b&gt;官方核心团队成员nrc也专门写了篇博文阐述了他自己的思考，本文是对他这篇博文的摘要描述。&lt;/b&gt;&lt;br&gt;&lt;b&gt;原文：&lt;a href=&quot;https://www.ncameron.org/blog/rust-in-2022/&quot;&gt;Rust in 2022&lt;/a&gt;&lt;/b&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;思绪站在了2022年，回望2019年，nrc得出一个结论：Rust 2021 edition的目标应该是跟&lt;b&gt;「成熟度」&lt;/b&gt;相关，也就是说，2022年的开发者面对Rust做选择的时候，&lt;b&gt;决不能是「高风险/高回报式」的选择，而应该是一个安全的选择&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;所以Rust 2021 edition的目标应该覆盖如下方面：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;可持续性。&lt;/li&gt;&lt;li&gt;多样性。&lt;/li&gt;&lt;li&gt;成熟的工具。包括Cargo、IDE支持等，从广度和深度上都要加强。&lt;/li&gt;&lt;li&gt;异步编程。&lt;/li&gt;&lt;li&gt;标准库的改进。主要面向生态系统的扩展。&lt;/li&gt;&lt;li&gt;完成「宏」的功能。&lt;/li&gt;&lt;li&gt;国际化。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;持续关注Rust已经被证明适用的领域（系统、网络、嵌入式、WASM、游戏），以及发现新的领域。&lt;br&gt;&lt;br&gt;&lt;b&gt;再回头来看2019年，具体应该做什么呢？&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;增强标准库和工具的可发现性。比如新用户如何了解serde和clippy？&lt;/li&gt;&lt;li&gt;提升RFC流程&lt;/li&gt;&lt;li&gt;Rust项目的基础设施。如何改进和治理Rust代码结构，如何改进流程，如果让贡献者轻松更快地为Rust做贡献？&lt;/li&gt;&lt;li&gt;继续维护「COC」，保证社区讨论的「基调」充满友善。&lt;/li&gt;&lt;li&gt;提升Rust代码的安全性。&lt;/li&gt;&lt;li&gt;应该更加关注游戏和图形领域的应用。这些领域是性能敏感区。&lt;/li&gt;&lt;li&gt;继续推动异步编程进展。&lt;/li&gt;&lt;li&gt;Cargo需要更好地继承到IDE中。&lt;/li&gt;&lt;li&gt;努力让RLS变得更好。&lt;/li&gt;&lt;li&gt;更好的IDE体验。&lt;/li&gt;&lt;li&gt;集成Rustdoc、docs.rs和cargo-src，获得最佳文档和源码探索体验。&lt;/li&gt;&lt;li&gt; 完善编译器的query API。&lt;/li&gt;&lt;li&gt;Rust语言团队应该考虑一下开发节奏，为下一版做准备。获得足够的开发时间和迭代时间。&lt;/li&gt;&lt;li&gt;不管是GAT(generic associated types )或HKT或其他什么，需要确保有一个可以解决需要解决的问题的功能，并且不需要更多其他功能。也就是说，GAT可能是最后一个为trait系统增加的特性。&lt;/li&gt;&lt;li&gt;特化。可能与宏结合来完善这一工作。&lt;/li&gt;&lt;li&gt;继续推进未完善的功能（宏、impl Trait、const fn、nll等）&lt;/li&gt;&lt;li&gt;命名和可选参数支持&lt;/li&gt;&lt;li&gt;enum中增加类型变体（variant types），而不仅仅只支持值变体。&lt;/li&gt;&lt;li&gt;继续推动编译器性能&lt;br&gt;&lt;br&gt;虽然这都是nrc自己的愿望，但他可是核心团队成员，他的想法是可以直接传达到Rust官方。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-12-52181046</guid>
<pubDate>Wed, 12 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 12</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-11-52098828.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52098828&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz  &lt;br&gt; &lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;&lt;br&gt; 不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。   &lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 12:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct D(u8);

impl Drop for D {
    fn drop(&amp;amp;mut self) {
        print!(&quot;{}&quot;, self.0);
    }
}

struct S {
    d: D,
    x: u8,
}

fn main() {
    let S { x, .. } = S {
        d: D(1),
        x: 2,
    };
    print!(&quot;{}&quot;, x);

    let S { ref x, .. } = S {
        d: D(3),
        x: 4,
    };
    print!(&quot;{}&quot;, x);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 1243&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;考察要点&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;let绑定时，结构体模式匹配&lt;/li&gt;&lt;li&gt;ref 模式匹配&lt;/li&gt;&lt;li&gt;析构顺序&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Quiz代码中定义了单元结构体&lt;code class=&quot;inline&quot;&gt;D(u8)&lt;/code&gt;，并且为其实现了Drop。这意味着，在&lt;code class=&quot;inline&quot;&gt;D(u8)&lt;/code&gt;出了作用域会自动调用其实现的&lt;code class=&quot;inline&quot;&gt;drop&lt;/code&gt;方法。&lt;/p&gt;&lt;p&gt;然后定义了结构体S，两个字段其中一个类似是&lt;code class=&quot;inline&quot;&gt;D&lt;/code&gt;。这就意味着，该结构体实例被销毁时，会调用字段&lt;code class=&quot;inline&quot;&gt;d&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;drop&lt;/code&gt;方法。&lt;/p&gt;&lt;p&gt;在main函数中，使用let绑定模式匹配解构一个结构体实例。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let S { x, .. } = S {
    d: D(1),
    x: 2,
};&lt;/code&gt;&lt;p&gt;上面代码相当于定义了&lt;code class=&quot;inline&quot;&gt;let x = 2;&lt;/code&gt; ，而结构体实例中&lt;code class=&quot;inline&quot;&gt;d: D(1)&lt;/code&gt;字段将会被抛弃，因为它没有绑定任何变量。 所以，此时输出&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的值为： 2。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let S { ref x, .. } = S {
    d: D(3),
    x: 4,
};&lt;/code&gt;&lt;p&gt;同理，上面代码的&lt;code class=&quot;inline&quot;&gt;d: D(3)&lt;/code&gt;同样会被抛弃。相当于&lt;code class=&quot;inline&quot;&gt;let ref x = 4;&lt;/code&gt;，等价于&lt;code class=&quot;inline&quot;&gt;let x = &amp;amp;4;&lt;/code&gt;。所以，此时输出&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的值为： &lt;code class=&quot;inline&quot;&gt;4&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;但为什么输出结果顺序是：&lt;code class=&quot;inline&quot;&gt;1 -&amp;gt; 2 -&amp;gt; 4 -&amp;gt; 3&lt;/code&gt;呢？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们为Quiz代码中的结构体&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;实现一个Drop。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;impl Drop for S {
    fn drop(&amp;amp;mut self) {
        print!(&quot;S&quot;);
    }
}&lt;/code&gt;&lt;p&gt;然后再执行Quiz代码，输出结果是： &lt;code class=&quot;inline&quot;&gt;S124S3&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;从这个结果中发现：&lt;/p&gt;&lt;p&gt;最先析构的是结构体S的第一个实例，其次是&lt;code class=&quot;inline&quot;&gt;d: D(1)&lt;/code&gt;，第三个是结构体S的另一个实例，最后是&lt;code class=&quot;inline&quot;&gt;d: D(3)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;两个结构体实例先于&lt;code class=&quot;inline&quot;&gt;D(1)&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;D(3)&lt;/code&gt;析构，是因为它们是先声明的。但是为什么输出结果不是&lt;code class=&quot;inline&quot;&gt;S12S34&lt;/code&gt;呢？&lt;/p&gt;&lt;p&gt;继续修改Quiz代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let S {  x, .. } = S {
        d: D(3),
        x: 4,
    };&lt;/code&gt;&lt;p&gt;把main函数中第二个结构体实例的let绑定中的&lt;code class=&quot;inline&quot;&gt;ref&lt;/code&gt;去掉了。输出结果是：&lt;code class=&quot;inline&quot;&gt;S12S34&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;看来，是这个&lt;code class=&quot;inline&quot;&gt;ref&lt;/code&gt;影响了析构的顺序。回到原始的Quiz代码中，来分析这个过程：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;第一个结构体实例最先被声明，但该实例本身也没有被绑定任何变量。所以它第一个被弃用。调用其drop方法输出：&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;第二个被析构的是&lt;code class=&quot;inline&quot;&gt;D(1)&lt;/code&gt;，同理，因为它没有绑定任何变量，此时已无用。调用其drop方法输出：&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;此时结构体中x字段已经绑定给了x变量，打印输出它的值： &lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;第三个被析构的是第二个结构体S的实例。理论上，它没有绑定任何变量。所以应该调用其drop方法输出：&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;。但是，此时let绑定解构语句中使用了&lt;code class=&quot;inline&quot;&gt;ref&lt;/code&gt;，它是一种模式匹配操作，将该结构体实例的字段&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;的引用匹配了出来，相当于&lt;code class=&quot;inline&quot;&gt;let x = &amp;amp;S{x: 4}.x&lt;/code&gt;。也就是说，此时的绑定&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;，是对结构体实例中字段的引用，如果此时抛弃了该结构体实例，势必会造成悬垂指针。所以，这里直接输出打印x的值：&lt;code class=&quot;inline&quot;&gt;4&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;在使用完&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;之后，结构体实例可以被析构了，调用drop，然后输出：&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;最后在对&lt;code class=&quot;inline&quot;&gt;D(3)&lt;/code&gt;析构，输出：&lt;code class=&quot;inline&quot;&gt;3&lt;/code&gt;。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;那么最终结果就是： &lt;code class=&quot;inline&quot;&gt;S124S3&lt;/code&gt;。对于原始Quiz代码来说，输出结果就是：&lt;code class=&quot;inline&quot;&gt;1243&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/12&quot;&gt;点此查看 Rust Quiz 12&lt;/a&gt; &lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-11-52098828</guid>
<pubDate>Tue, 11 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「付费阅读」 Rust Quiz 解读：Quiz 11</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-10-52032027.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52032027&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz  &lt;br&gt; &lt;br&gt;&lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;&lt;br&gt; 不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。  &lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 11:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn f&amp;lt;&#39;a&amp;gt;() {}
fn g&amp;lt;&#39;a: &#39;a&amp;gt;() {}

fn main() {
    let pf = f::&amp;lt;&#39;static&amp;gt; as fn();
    let pg = g::&amp;lt;&#39;static&amp;gt; as fn();
    print!(&quot;{}&quot;, pf == pg);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 编译错误&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;解读&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;生命周期参数概念&lt;/li&gt;&lt;li&gt;生命周期参数限定：&lt;code class=&quot;inline&quot;&gt;Early bound&lt;/code&gt; vs &lt;code class=&quot;inline&quot;&gt;Late bound&lt;/code&gt;&lt;/li&gt;&lt;li&gt;生命周期子类型与协变&lt;/li&gt;&lt;li&gt;函数指针及其比较&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;不得不说，此Quiz代码中涉及一个隐晦的概念：生命周期参数&lt;code class=&quot;inline&quot;&gt;Early bound&lt;/code&gt; vs &lt;code class=&quot;inline&quot;&gt;Late bound&lt;/code&gt;。这两个概念是官方提供的书里没有过的，也是我做这个题首次遇到的概念。通过调查Rust源码，大概得出了它们的定义：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4e50141ca4080ef17a7c90a2f87bbaa3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;2512&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-4e50141ca4080ef17a7c90a2f87bbaa3&quot; data-watermark-src=&quot;v2-5ca74df78769f1be27cde7a30683f1d3&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-10-52032027</guid>
<pubDate>Mon, 10 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「Rust每日新闻」本周精选 • 第二十三期</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-09-51950580.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51950580&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-23599072636a1820bba7b49b9d586092_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;前言： 从2018年开始，我每天会花1个小时关注Rust社区动态，并且在&lt;a href=&quot;http://rust.cc/&quot;&gt;Rust.CC论坛&lt;/a&gt;、&lt;a href=&quot;https://t.me/rust_daily_news&quot;&gt;tg channel&lt;/a&gt;、&lt;a href=&quot;https://steemit.com/@blackanger&quot;&gt;Steemit&lt;/a&gt;、&lt;a href=&quot;https://github.com/RustStudy/rust_daily_news&quot;&gt;GitHub&lt;/a&gt;、&lt;a href=&quot;https://www.yuque.com/chaosbot/rustnews&quot;&gt;语雀订阅&lt;/a&gt;都开通了Rust每日新闻，分享我每天的见闻，偶尔也夹杂了一些个人的观点。大半年过去了，Rust每日新闻已经成为了Rust社区群大家每天必看的内容。在这个知乎专栏里，每周会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。 &lt;br&gt;2018-12-09&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;「付费阅读」 如何为Rust语言做贡献&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;本文基于macOSX平台，通过对Rust 1.32 Nightly版本中rustdoc的一个ICE问题进行复盘，分析并记录整个Bug修复的过程。主要目的是，通过这个过程，来学习如何给Rust做贡献。&lt;/p&gt;&lt;p&gt;（阅读时间：17m）&lt;/p&gt;&lt;ol&gt;&lt;li&gt; 缘起&lt;br&gt; &lt;/li&gt;&lt;li&gt; Rust本地调试环境准备&lt;br&gt; &lt;/li&gt;&lt;li&gt; ICE问题分析&lt;br&gt; &lt;/li&gt;&lt;li&gt; 调试代码&lt;br&gt; &lt;/li&gt;&lt;li&gt; 提交PR说明&lt;br&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51479889&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;官方新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;Rust 2018 edition 首个语义版本 1.31.0 发布&lt;/h2&gt;&lt;p&gt;在这个大版本里，新加入了很多内容：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;NLL（Non-lexical lifetimes）&lt;/li&gt;&lt;li&gt;新的模块系统&lt;/li&gt;&lt;li&gt;更多的生命周期省略规则&lt;/li&gt;&lt;li&gt;const fn：可以在编译时把const fn定义的函数用作常量值，但目前稳定的是最小化子集。&lt;/li&gt;&lt;li&gt;新的工具：clippy、rustfmt等已稳定&lt;/li&gt;&lt;li&gt;tool lint：像&lt;code class=&quot;inline&quot;&gt;#![allow(clippy::bool_comparison)]&lt;/code&gt;这种属性。已经不再需要&lt;code class=&quot;inline&quot;&gt;cfg_attr&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;文档：改进了文档，并且重写了TRPL（The Rust Programming Language）, &lt;a href=&quot;https://doc.rust-lang.org/beta/book/&quot;&gt;TRPL 2018版&lt;/a&gt;&lt;/li&gt;&lt;li&gt; Cargo现在已经使用HTTP/2来并行下载crate。而且也不需要在代码里&lt;code class=&quot;inline&quot;&gt;extern crate&lt;/code&gt;引入crate了。&lt;br&gt; &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html&quot;&gt;Read More&lt;/a&gt;&lt;br&gt; &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1310-2018-12-06&quot;&gt;1.31 Release Notes&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;与此同时，Rust官网也焕然一新：&lt;a href=&quot;https://www.rust-lang.org/&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这标志着Rust迈向了成熟。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Why Rust？ 高性能/可靠/生产力。&lt;/li&gt;&lt;li&gt;当你构建CLI、WebAssembly、网络、嵌入式可以考虑使用Rust。&lt;/li&gt;&lt;li&gt;Rust已经有了很多商业生产级应用&lt;/li&gt;&lt;li&gt;如何开始呢？除了Rust book，还有很多其他资源。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「官方」 Rust 2018 到底是什么？&lt;/h2&gt;&lt;p&gt;本文中，由Rust团队的Lin Clark，用很多漫画来帮你解释Rust 2018到底是什么？&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://hacks.mozilla.org/2018/12/rust-2018-is-here/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「官方」征集Rust 2019 RoadMap意见的博客文章&lt;/h2&gt;&lt;p&gt;Rust 2019 Roadmap开始制定了，官方现在向社区征集一些博客，希望在博文中提出经过2018年对Rust的使用感受，以及希望Rust改进的目标和方向。去年的路线图RFC是在2018年1月29开放的。今年估计也差不多。&lt;/p&gt;&lt;p&gt;另外一件事，是在考虑下一个大版本的目标：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Rust 2015：稳定性&lt;/li&gt;&lt;li&gt;Rust 2018：生产力&lt;/li&gt;&lt;li&gt;Rust 2021：？&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;现在官方还不确定下一个大版本是2021，目前只是预估。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「官方」 反思Rust和WebAssembly在2018年的进展&lt;/h2&gt;&lt;p&gt;官方wasm工作组成立之初提炼出一个核心价值观：Rust和WebAssembly用于扩充JavaScript，而不是替换它。这个核心价值观推动了2018年Rust在WebAssembly领域的发展。&lt;/p&gt;&lt;p&gt;达成的目标：&lt;/p&gt;&lt;ol&gt;&lt;li&gt; 零成本与JavaScript交互。    基于wasm-bindgen来完成这一目标，现在基本已经构建出了以wasm-bindgen为核心的生态。&lt;br&gt; &lt;/li&gt;&lt;li&gt; 将Rust生成的WASM库分发给NPM。    由wasm-pack来完成这一目标。不仅仅是生成wasm，还需要分发到npm生态中。&lt;br&gt; &lt;/li&gt;&lt;li&gt; 快速提示开发效率。     对wasm-pack进行了扩展。自动管理wasm-bindgen CLI二进制文件，且自动安装浏览器的WebDriver客户端。比如：&lt;code class=&quot;inline&quot;&gt;wasm-pack test --headless --firefox&lt;/code&gt;来测试。     并且增加了一些模板项目来提升开发者效率：&lt;br&gt; &lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;wasm-pack-template&lt;/code&gt;用于方便创建NPM库&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;create-wasm-app&lt;/code&gt;用于创建web应用&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;rust-webpack-template&lt;/code&gt;用于使用webpack来创建应用程序&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;rust-parcel-template&lt;/code&gt;用于使用parcel来创建应用程序&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt; Rust生成的wasm应该是可测试和可调试的。&lt;br&gt; &lt;/li&gt;&lt;li&gt;console_error_panic_hook，可以将Rust代码产生的panic重定向到浏览器控制台&lt;/li&gt;&lt;li&gt;wasm-bindgen-test，作为基础是测试架构，结合wasm-pack来测试dom、js异步事件等。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rustwasm/twiggy&quot;&gt;Twiggy🌱&lt;/a&gt;，可以为Wasm分析代码大小。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;同样，也向社区征求Rust 2019 Rust和WebAssembly上的目标和建议。另外在感谢名单上，发现了群友：huangjj27。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://rustwasm.github.io/2018/12/06/reflecting-on-rust-and-wasm-in-2018.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「官方」关于RLS的状态说明&lt;/h2&gt;&lt;p&gt;RLS（language server for Rust）马上会随着Rust 2018的发布而发布，并且会共享版本号。但其实RLS并未准备好，只是借用这次Rust 2018发版的机会强调RLS实际上是一个可用且有用的工具。&lt;/p&gt;&lt;p&gt;官方核心人员nrc在这篇文章里，介绍了RLS目前哪些功能已经可用，哪些还不行，以及未来的走向。关注RLS的朋友可以看一下。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.ncameron.org/blog/more-on-rls-version-numbering/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;社区新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;汝为何是Romio？&lt;/h2&gt;&lt;h2&gt;async #romio #tokio&lt;/h2&gt;&lt;p&gt;无船同志新文：Wherefore art thou Romio?&lt;/p&gt;&lt;p&gt;（ &quot;Romeo, Romeo, wherefore art thou Romeo? —— 莎士比亚《罗密欧与朱丽叶》）&lt;/p&gt;&lt;p&gt;本文讲述了Romio的前世今生。主要目的是为了将Tokio接口移植到Future 0.3。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;处理显式的waker参数。 0.1和0.3的差异之一是对waker的处理。0.3中提供了一个唤醒当前任务的waker，而0.1则没有。0.1提供的是task::current这样的函数。现在统一使用LocalWaker。&lt;/li&gt;&lt;li&gt;消除代码重复。Tokio中的AtomicTask内部类型，实际上在Futures 0.3已经演变为AtomicWaker类型。通过给Tokio发PR来消除这些重复。&lt;/li&gt;&lt;li&gt;tokio-io到future::io的变化。这部分是最困难的一个部分。目前tokio-io中自定义了AsyncRead和AsyncWrite，而Futures 0.3也定义了AsyncRead和AsyncWrite，这两个版本的接口有很大变化。tokio-io是在unsafe代码上构建的AsyncRead和AsyncWrite，而Futures新的AsyncRead和AsyncWrite是构建于专门的poll_vectored_read扩展。&lt;/li&gt;&lt;li&gt;Pin。实际上Pin对于0.1到0.3的迁移工作影响很小。基本上就是用&lt;code class=&quot;inline&quot;&gt;＆mut self：Pin &amp;lt;＆mut Self&amp;gt;&lt;/code&gt;来替换&lt;code class=&quot;inline&quot;&gt;mut self&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;这次迁移有利于&lt;code class=&quot;inline&quot;&gt;non-&#39;static&lt;/code&gt; Future的应用。将来使用async/await将不必担心因为不是&lt;code class=&quot;inline&quot;&gt;&#39;static&lt;/code&gt;的Future而产生任何问题。&lt;/li&gt;&lt;li&gt;Romio是fork自Tokio，但不打算和Tokio竞争。Romio旨在解锁async/await，因为现在Tokio使用futures 0.1已经阻碍了想用async/await人的步伐。毕竟Tokio在生态系统中占比太高。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;关于Romio的说明：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Romio仅包含与异步网络API相关的代码 -  TCP，UDP和Unix域套接字。换句话说，Romio只是 futures + mio。&lt;/li&gt;&lt;li&gt;Romio只暴露最小的API。&lt;/li&gt;&lt;li&gt;Romio目前版本为0.3.0-alpha.1，配合futures 0.3来发布更新。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;文章中给出了一个echo server的示例。这一切工作都是为了尽可能快速地稳定async/await。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://boats.gitlab.io/blog/post/romio/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rustsim 月报 #2&lt;/h2&gt;&lt;p&gt;Rustsim组织是一个GitHub组织，聚焦于提供各种数值模拟的库。包括&lt;/p&gt;&lt;ul&gt;&lt;li&gt;alga， 抽象代数库&lt;/li&gt;&lt;li&gt;nalgebra， 线性代数库&lt;/li&gt;&lt;li&gt;ncollide， 2D和3D的碰撞检测库&lt;/li&gt;&lt;li&gt;nphysics， 2D和3D的物理模拟库&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://rustsim.org/&quot;&gt;rustsim.org&lt;/a&gt;&lt;/p&gt;&lt;p&gt;本月改进：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;可变形体的物理模拟&lt;/li&gt;&lt;li&gt;改进ncollide&lt;/li&gt;&lt;li&gt;改进nalgebra&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://www.rustsim.org/blog/2018/12/01/this-month-in-rustsim/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「博文」教你如何用Rust写C++&lt;/h2&gt;&lt;p&gt;长文预警!&lt;/p&gt;&lt;blockquote&gt; 背景： Firefox有一个名为encoding_rs的新字符编码转换库。它是用Rust编写的，取代了1999年初发布的名为uconv的旧C++字符编码转换库。因为调用该字符编码转换库的都是C++代码，所以新的库，尽管用Rust编写，但是该库在C++调用者看来，应该像是一个现代的C++库。也就是说，提供给C++调用者的接口使它看起来和感觉就像一个真正的C++库。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;(啊哈？假装写C++，你学到了吗？)&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://hsivonen.fi/modern-cpp-in-rust/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;使用Actix和Sentry构建安全web服务&lt;/h2&gt;&lt;p&gt;本文介绍了如何使用Actix创建Web服务，并使用Sentry对其进行监控。主要基于两个sentry平台相关的crate：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;sentry&lt;/li&gt;&lt;li&gt;sentry-actix&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;sentry是Sentry平台为Rust开发的SDK，详情：&lt;a href=&quot;https://blog.sentry.io/2018/10/22/getting-started-with-rust-error-tracking&quot;&gt;getting-started-with-rust-error-tracking&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.sentry.io/2018/12/04/safe-web-services-actix-sentry?utm_campaign=rust&amp;amp;utm_source=social&amp;amp;utm_medium=twitter&amp;amp;utm_content=post&amp;amp;utm_term=actix&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;案例Librsvg：用Rust重构C项目值得遵循的模式&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://people.gnome.org/~federico/blog/guadec-2018-presentation.html&quot;&gt;Read More PPT&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://people.gnome.org/~federico/blog/docs/fmq-refactoring-c-to-rust.pdf&quot;&gt;PDF&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;超级账本新项目Ursa将使用Rust编写&lt;/h2&gt;&lt;p&gt;Ursa主要是一个加密库，区块链开发人员可以通过简单的配置文件更改来选择和修改其加密方案。主要使用Rust语言编写，但也会包含Hyperledger中常用到的其他语言的接口。&lt;/p&gt;&lt;p&gt;随着Hyperledger的成熟，Hyperledger中的各个项目已经开始需要复杂的加密实现。不是让每个项目都实现自己的加密协议，而是在共享库上进行协作要更好。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.hyperledger.org/blog/2018/12/04/welcome-hyperledger-ursa&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;在Rust中使用Passenger&lt;/h2&gt;&lt;p&gt;Passenger是一个Web应用服务器，常用于Ruby、Node、Python等语言，现在也支持Rust了。&lt;/p&gt;&lt;p&gt;官方写了文章，介绍如何在Rust中使用Passenger作为应用服务器。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.phusionpassenger.com/docs/advanced_guides/gls/rust.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Magic Leap用了Servo引擎技术构建浏览器&lt;/h2&gt;&lt;blockquote&gt; Magic Leap One设备为早期开发人员提供浏览器预览版。 该浏览器基于Servo引擎技术构建，并通过WebRender Web渲染库展示高质量的2D图形和字体渲染，并且很快将会有更多新功能。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;Magic Leap 高科技！&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.mozvr.com/a-new-browser-for-magic-leap/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;让Nginx运行于WebWebassmbly&lt;/h2&gt;&lt;p&gt;wasmer是一个跨平台的WASM-JIT运行时。wasmer团队尝试将nginx编译为nginx.wasm模块，并将其运行在wasmer之上。本文介绍了他们完成这项工作的历程，以及示例代码。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/wasmerio/wasmer&quot;&gt;wasmer&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://medium.com/@syrusakbary/running-nginx-with-webassembly-6353c02c08ac&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Rocket v0.4 发布&lt;/h2&gt;&lt;p&gt;0.4版本是Rocket迄今为止最大的更新。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/SergioBenitez/Rocket/blob/v0.4.0/CHANGELOG.md#version-040-dec-06-2018&quot;&gt;ChangeLog&lt;/a&gt;&lt;/p&gt;&lt;p&gt;并且多了一个共同维护者：@jebrosen&lt;/p&gt;&lt;p&gt;最关键的是，Codegen已经用Rust过程宏重写了，下一个版本Rocket将支持Rust Stable。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://rocket.rs/v0.4/news/2018-12-08-version-0.4/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;学习资源&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;「系列」Rust Quiz 解读&lt;/h2&gt;&lt;p&gt;[Quiz 1 ~ 10] ： &lt;a href=&quot;https://zhuanlan.zhihu.com/time-and-spirit-hut&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「嵌入式Rust」专栏启动&lt;/h2&gt;&lt;blockquote&gt; 本专栏面向于嵌入式开发的入门教程和实践，也就是说，本专栏的文章并不假定读者拥有任何嵌入式开发的知识或经验，但是要求读者有一定 Rust 语言基础，比如说熟悉借用所有权系统，懂得使用 unsafe 手动操作内存结构等等。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;感兴趣的可以关注&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/embedded-rust&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;使用Rust编写AWS Lambda&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/@kkostov/rust-aws-lambda-30a1b92d4009&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust类型级（Type Level）的生命游戏&lt;/h2&gt;&lt;p&gt;又一次证明了Rust的类型系统是图灵完备的&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/gtestault/primitive-recursive-functions&quot;&gt;primitive-recursive-functions&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;wasm-bindgen的工作原理&lt;/h2&gt;&lt;p&gt;文章里包含了一个PPT&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://fitzgeraldnick.com/2018/12/02/wasm-bindgen-how-does-it-work.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://fitzgen.github.io/wasm-cg-wasm-bindgen/#1&quot;&gt;ppt&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;各种 AOC 2018 解题&lt;/h2&gt;&lt;p&gt;另外两个GitHub仓库&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/bpicolo/aoc2018&quot;&gt;aoc2018&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/maxdeviant/adventurous&quot;&gt;adventurous&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;一个简单的光线跟踪实现&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/shaunbennett/lucis&quot;&gt;lucis&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「视频」2018-12-04 RustAKL: ECS编程范例&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Qc8a2hmpHCA&amp;amp;feature=youtu.be&quot;&gt;视频&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/azriel91/ecs_paradigm&quot;&gt;Code&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://gitpitch.com/azriel91/ecs_paradigm/master?grs=github&amp;amp;t=sky#/&quot;&gt;Slides&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;HashMap界的瑞士军刀——深入研究hashbrown&lt;/h2&gt;&lt;p&gt;hashbrown之前介绍过，是对Google的SwissTable算法实现。目前作者正在尝试将其整合到Rust标准库中（RustFest Roma 2018演讲）。&lt;/p&gt;&lt;p&gt;本文是对hashbrown工作机制的研究报告。值得仔细阅读一下。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.waffles.space/2018/12/07/deep-dive-into-hashbrown/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;项目&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;一个新的2D游戏引擎&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/17cupsofcoffee/tetra&quot;&gt;tetra&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;另一个轻量级的序列化框架：sval&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/KodrAus/sval&quot;&gt;sval&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/a2kn7y/sval_a_prototype_nostd_objectsafe/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;CFG Game: 利用你的计算机技能来制作汉堡包&lt;/h2&gt;&lt;p&gt;使用Rust编译为Wasm的在线小游戏。游戏的核心是一个非常标准的LL（1）解析器，其语法是在玩家的游戏中动态定义的。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://rickyhan.com/jekyll/update/2018/12/03/make-burgers-context-free-grammar.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;源码：&lt;a href=&quot;https://github.com/rickyhan/dyn-grammar&quot;&gt;dyn-grammar&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;工具与库&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;「工具」更智能展示你shell历史的工具: mcfly&lt;/h2&gt;&lt;p&gt;这个工具不得了，自带小型神经网络（mall neural network），可以替换&lt;code class=&quot;inline&quot;&gt;默认ctrl-r Bash历史搜索&lt;/code&gt;了，更加智能。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/cantino/mcfly&quot;&gt;mcfly&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Tui-rs: 用于构建丰富的命令行界面和DashBoard&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/fdehau/tui-rs&quot;&gt;tui-rs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-99553f23f5d15e93879b7ec79585438a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;399&quot; data-watermark=&quot;&quot; data-original-src=&quot;&quot; data-watermark-src=&quot;&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;从HTML反序列化为Rust类型&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Hexilee/unhtml.rs&quot;&gt;unhtml.rs&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;prettyprint: 让命令行拥有漂亮的输出&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/mre/prettyprint&quot;&gt;prettyprint&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;cargo-inspect: 探索Rust内部的工具&lt;/h2&gt;&lt;p&gt;之前介绍过这个库，今天看到该库作者写了篇文章，更详细介绍它的用法。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://matthias-endler.de/2018/cargo-inspect/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/mre/cargo-inspect&quot;&gt;cargo-inspect&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;cargo-call-stack: 分析程序中的静态调用栈&lt;/h2&gt;&lt;p&gt;官方嵌入式组老大japaric写的库。可以对整个程序做静态调用栈的分析，可以最终生成svg图片。调用栈分析结果还包含了栈的具体使用情况（以字节为单位），以及包括Max最大值。&lt;/p&gt;&lt;p&gt;在写一些对栈内存要求苛刻的程序，比如嵌入式，比较有用。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/japaric/cargo-call-stack#cargo-call-stack&quot;&gt;cargo-call-stack&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-81ced73aecfaae1061bed076a678dddc_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;264&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-81ced73aecfaae1061bed076a678dddc&quot; data-watermark-src=&quot;v2-390be26a4165ef330226a711a1ff918d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;「CLI」indicatif: 命令行进度条工具&lt;/h2&gt;&lt;p&gt;可生成各样且彩色的进度条，非常酷。就不上图了。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/mitsuhiko/indicatif&quot;&gt;indicatif&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;JQL: 命令行JSON查询工具&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/yamafaktory/jql&quot;&gt;jql&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-09-51950580</guid>
<pubDate>Sun, 09 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 10</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-09-51948290.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51948290&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt; 来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz  &lt;br&gt; &lt;br&gt;&lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;&lt;br&gt; 不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。   &lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 10:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Trait {
    fn f(&amp;amp;self);
}

impl&amp;lt;&#39;a&amp;gt; dyn Trait + &#39;a {
    fn f(&amp;amp;self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for bool {
    fn f(&amp;amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    Trait::f(&amp;amp;true);
    Trait::f(&amp;amp;true as &amp;amp;dyn Trait);
    &amp;lt;_ as Trait&amp;gt;::f(&amp;amp;true);
    &amp;lt;_ as Trait&amp;gt;::f(&amp;amp;true as &amp;amp;dyn Trait);
    &amp;lt;bool as Trait&amp;gt;::f(&amp;amp;true);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果：22222&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;考察要点：&lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;trait基本用法&lt;/li&gt;&lt;li&gt;Rust 2018 edition新语法&lt;code class=&quot;inline&quot;&gt;dyn Trait&lt;/code&gt;&lt;/li&gt;&lt;li&gt;无歧义完全限定语法（Fully Qualified Syntax for Disambiguation）&lt;/li&gt;&lt;li&gt;triat 对象&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Quiz代码中定义了名为Trait的trait，包含了&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;函数签名。&lt;/p&gt;&lt;p&gt;接下来是为此Trait内定义的&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;函数添加默认的实现，也叫固有（inherent）实现。此处使用了Rust 2018 edition的新语法：&lt;code class=&quot;inline&quot;&gt;dyn Trait&lt;/code&gt;。其实&lt;code class=&quot;inline&quot;&gt;impl&amp;lt;&#39;a&amp;gt; dyn Trait + &#39;a {&lt;/code&gt;等价于Rust 2015中&lt;code class=&quot;inline&quot;&gt;impl&amp;lt;&#39;a&amp;gt; Trait + &#39;a {&lt;/code&gt;的写法。&lt;/p&gt;&lt;p&gt;在Rust 2015中，直接为Trait实现固有方法，和&lt;code class=&quot;inline&quot;&gt;impl Trait for SomeType&lt;/code&gt;这种写法容易混淆。对于直接的&lt;code class=&quot;inline&quot;&gt;impl Trait {}&lt;/code&gt;来说，其实是为&lt;code class=&quot;inline&quot;&gt;trait Object&lt;/code&gt;实现固有方法。所以在Rust 2018 edition中引入了&lt;code class=&quot;inline&quot;&gt;dyn&lt;/code&gt;关键字，表示&lt;code class=&quot;inline&quot;&gt;trait Object&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;impl dyn Trait {}&lt;/code&gt;比起“裸写的” &lt;code class=&quot;inline&quot;&gt;impl Trait {}&lt;/code&gt;可读性要高。&lt;/p&gt;&lt;p&gt;而且&lt;code class=&quot;inline&quot;&gt;dyn Trait&lt;/code&gt;和新引入的&lt;code class=&quot;inline&quot;&gt;impl Trait语法&lt;/code&gt;相对应。一个表示动态分发，一个表示静态分发。&lt;/p&gt;&lt;p&gt;所以，Quiz代码中，&lt;code class=&quot;inline&quot;&gt;impl&amp;lt;&#39;a&amp;gt; dyn Trait + &#39;a {...}&lt;/code&gt;是为了实现Trait的&lt;code class=&quot;inline&quot;&gt;trait Object&lt;/code&gt;实现固有方法&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;接下来，&lt;code class=&quot;inline&quot;&gt;impl Trait for bool {...}&lt;/code&gt;为&lt;code class=&quot;inline&quot;&gt;bool&lt;/code&gt;布尔类型实现Trait，同样实现了&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;方法。&lt;/p&gt;&lt;p&gt;至此，&lt;code class=&quot;inline&quot;&gt;bool&lt;/code&gt;类型可以调用&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;方法，而任何实现了Trait的&lt;code class=&quot;inline&quot;&gt;trait Object&lt;/code&gt;也可以调用默认实现的固有&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;方法。&lt;/p&gt;&lt;p&gt;&lt;b&gt;那么，在main函数中的五种调用方法，到底调用哪个&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;呢？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Trait::f(&amp;amp;true);&lt;/code&gt;，这种写法是Rust中常用的写法，通过指定&lt;code class=&quot;inline&quot;&gt;Trait::&lt;/code&gt;前缀，并且传入具体类型实例的引用&lt;code class=&quot;inline&quot;&gt;&amp;amp;true&lt;/code&gt;来调用对应的&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;方法。在Quiz代码中，明确地为&lt;code class=&quot;inline&quot;&gt;bool&lt;/code&gt;类型实现了Trait，所以这里自然输出： 2。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Trait::f(&amp;amp;true as &amp;amp;dyn Trait);&lt;/code&gt; ，这种写法类似于第一种，但是通过&lt;code class=&quot;inline&quot;&gt;as&lt;/code&gt;关键字将&lt;code class=&quot;inline&quot;&gt;&amp;amp;true&lt;/code&gt;转换为了trait对象&lt;code class=&quot;inline&quot;&gt;&amp;amp;dyn Trait&lt;/code&gt;类型。然而，对于Rust编译器来说，它已明确知道这还是&lt;code class=&quot;inline&quot;&gt;bool&lt;/code&gt;类型。在更精确的&lt;code class=&quot;inline&quot;&gt;bool&lt;/code&gt;和trait对象&lt;code class=&quot;inline&quot;&gt;&amp;amp;dyn Trait&lt;/code&gt;之间，编译器肯定要选择那个更精确的类型。所以，这里也会输出： 2。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;&amp;lt;_ as Trait&amp;gt;::f(&amp;amp;true);&lt;/code&gt; ，这种写法，叫做&lt;b&gt;无歧义完全限定语法（Fully Qualified Syntax for Disambiguation）&lt;/b&gt;，这种语法之前也被称为&lt;b&gt;通用函数调用语法（UFCS）&lt;/b&gt;。通过&lt;code class=&quot;inline&quot;&gt;&amp;lt;_ as Trait&amp;gt;&lt;/code&gt;，来指定实现了Trait的类型，调用的是&lt;code class=&quot;inline&quot;&gt;Trait&lt;/code&gt;中实现的方法。&lt;code class=&quot;inline&quot;&gt;_&lt;/code&gt;此处泛指实现了Trait的类型，Rust会根据上下文进行自动推断。所以，必然会去使用&lt;code class=&quot;inline&quot;&gt;impl Trait for bool&lt;/code&gt;中定义的&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;实现。所以，这行代码依旧输出： 2。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;&amp;lt;_ as Trait&amp;gt;::f(&amp;amp;true as &amp;amp;dyn Trait);&lt;/code&gt;，同理，即便转为了trait对象，也还是去寻找为具体类型&lt;code class=&quot;inline&quot;&gt;bool&lt;/code&gt;实现的&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;方法。所以，输出：2。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;&amp;lt;bool as Trait&amp;gt;::f(&amp;amp;true);&lt;/code&gt;，这句和&lt;code class=&quot;inline&quot;&gt;&amp;lt;_ as Trait&amp;gt;::f(&amp;amp;true);&lt;/code&gt;等价，只不过这里指定了&lt;code class=&quot;inline&quot;&gt;bool&lt;/code&gt;类型。所以，继续输出： 2。&lt;/p&gt;&lt;p&gt;目前，Rust还不提供直接调用trait对象中定义的默认实现的语法。除非，把trait对象中实现的方法换成不同的名称。比如：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Trait {
    fn f(&amp;amp;self);
}

impl&amp;lt;&#39;a&amp;gt; dyn Trait + &#39;a {
    fn ff(&amp;amp;self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for bool {
    fn f(&amp;amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    Trait::f(&amp;amp;true);
    Trait::ff(&amp;amp;true);
    Trait::ff(&amp;amp;true as &amp;amp;dyn Trait);
}&lt;/code&gt;&lt;p&gt;这会输出： &lt;code class=&quot;inline&quot;&gt;211&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;注意main函数中最后两行：&lt;code class=&quot;inline&quot;&gt;Trait::ff(&amp;amp;true);&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;Trait::ff(&amp;amp;true as &amp;amp;dyn Trait);&lt;/code&gt;。这说明，没有为&lt;code class=&quot;inline&quot;&gt;bool&lt;/code&gt;类型实现&lt;code class=&quot;inline&quot;&gt;ff&lt;/code&gt;方法，Rust也会去trait对象的默认实现中去&lt;code class=&quot;inline&quot;&gt;查询&lt;/code&gt;该方法。&lt;/p&gt;&lt;p&gt;但是如果使用了无歧义完全限定语法，则不会这样做。比如：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Trait {
    fn f(&amp;amp;self);
}

impl&amp;lt;&#39;a&amp;gt; dyn Trait + &#39;a {
    fn ff(&amp;amp;self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for bool {
    fn f(&amp;amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    &amp;lt;_ as Trait&amp;gt;::ff(&amp;amp;true);
    &amp;lt;_ as Trait&amp;gt;::ff(&amp;amp;true as &amp;amp;dyn Trait);
    &amp;lt;bool as Trait&amp;gt;::ff(&amp;amp;true);
}&lt;/code&gt;&lt;p&gt;这样写会报错：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;error[E0576]: cannot find method or associated constant `ff` in trait `Trait`
  --&amp;gt; src/main.rs:20:19
   |
20 |     &amp;lt;_ as Trait&amp;gt;::ff(&amp;amp;true);
   |                   ^^ did you mean `f`?

error[E0576]: cannot find method or associated constant `ff` in trait `Trait`
  --&amp;gt; src/main.rs:21:19
   |
21 |     &amp;lt;_ as Trait&amp;gt;::ff(&amp;amp;true as &amp;amp;dyn Trait);
   |                   ^^ did you mean `f`?

error[E0576]: cannot find method or associated constant `ff` in trait `Trait`
  --&amp;gt; src/main.rs:22:22
   |
22 |     &amp;lt;bool as Trait&amp;gt;::ff(&amp;amp;true);
   |                      ^^ did you mean `f`?

error: aborting due to 3 previous errors&lt;/code&gt;&lt;p&gt;因为，已经通过&lt;code class=&quot;inline&quot;&gt;&amp;lt;_ as Trait&amp;gt;&lt;/code&gt;这样的写法，已经明确指定了调用&lt;code class=&quot;inline&quot;&gt;impl Trait for bool&lt;/code&gt;中实现的&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;方法，这时候调用&lt;code class=&quot;inline&quot;&gt;ff&lt;/code&gt;方法，显然，不会找到。&lt;/p&gt;&lt;h2&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/10&quot;&gt;点此查看 Rust Quiz 10&lt;/a&gt; &lt;/h2&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-09-51948290</guid>
<pubDate>Sun, 09 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 9</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-08-51891075.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51891075&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt; 来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz  &lt;br&gt; &lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;&lt;br&gt; 不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。   &lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 9:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;macro_rules! m {
    (1) =&amp;gt; { print!(&quot;1&quot;) };
    ($tt:tt) =&amp;gt; { print!(&quot;2&quot;) };
}

macro_rules! e {
    ($e:expr) =&amp;gt; { m!($e) };
}

macro_rules! t {
    ($tt:tt) =&amp;gt; { e!($tt); m!($tt); };
}

fn main() {
    t!(1);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 21&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;声明宏基本匹配规则&lt;/li&gt;&lt;li&gt;声明宏元变量匹配的可传导性&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Quiz代码中依次定义了三个声明宏，&lt;code class=&quot;inline&quot;&gt;m!&lt;/code&gt;、&lt;code class=&quot;inline&quot;&gt;e!&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;t!&lt;/code&gt;，并且依次是包含关系。&lt;/p&gt;&lt;p&gt;在main函数中，调用&lt;code class=&quot;inline&quot;&gt;t!(1)&lt;/code&gt;时，根据宏定义，其参数&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;经过词法分析得到词条树，也就是宏元变量&lt;code class=&quot;inline&quot;&gt;$tt:tt&lt;/code&gt;的类型&lt;code class=&quot;inline&quot;&gt;tt&lt;/code&gt;所指示。然后由&lt;code class=&quot;inline&quot;&gt;e!($tt);&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;m!($tt);&lt;/code&gt;继续匹配。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;e!($tt)&lt;/code&gt;在匹配过程中，因为&lt;code class=&quot;inline&quot;&gt;e!&lt;/code&gt;定义左边元变量&lt;code class=&quot;inline&quot;&gt;$e:expr&lt;/code&gt;，表明是一个表达式类型。对于Rust编译器来说，经过&lt;code class=&quot;inline&quot;&gt;e!&lt;/code&gt;宏处理的词条，将会变成一个不透明的词条（opaque token tree）。也就是说，后续的宏都会认为它是一个表达式token，而不是其他。所以，在&lt;code class=&quot;inline&quot;&gt;e!&lt;/code&gt;宏内匹配右侧&lt;code class=&quot;inline&quot;&gt;m!($e);&lt;/code&gt;的时候，只能匹配&lt;code class=&quot;inline&quot;&gt;m!&lt;/code&gt;宏的第二条分支&lt;code class=&quot;inline&quot;&gt;($tt:tt)&lt;/code&gt;，所以输出： 2。&lt;/p&gt;&lt;p&gt;如果试着在&lt;code class=&quot;inline&quot;&gt;m!&lt;/code&gt;中加一条匹配分支：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;macro_rules! m {
    (1) =&amp;gt; { print!(&quot;1&quot;) };
    ($ee;expr) =&amp;gt; { print!(&quot;3&quot;)};
    ($tt:tt) =&amp;gt; { print!(&quot;2&quot;) };
}&lt;/code&gt;&lt;p&gt;输出结果就会变成： &lt;code class=&quot;inline&quot;&gt;31&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;m!(1)&lt;/code&gt;来说，它一直以&lt;code class=&quot;inline&quot;&gt;tt&lt;/code&gt;词条树类型来传播，到最后会尝试匹配到&lt;code class=&quot;inline&quot;&gt;(1)&lt;/code&gt;这个token字面量，然后匹配成功，最后输出： &lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这就是为什么输出结果是&lt;code class=&quot;inline&quot;&gt;21&lt;/code&gt;的原因。&lt;/p&gt;&lt;p&gt;同理，如果把&lt;code class=&quot;inline&quot;&gt;e!&lt;/code&gt;的匹配模式修改为：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;macro_rules! e {
    ($e:tt) =&amp;gt; { m!($e) };
}&lt;/code&gt;&lt;p&gt;则输出结果会是：&lt;code class=&quot;inline&quot;&gt;11&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;不透明词条树（Opaque Token Tree）&lt;/b&gt;&lt;/p&gt;&lt;p&gt;所谓不透明词条树（Opaque Token Tree），就是指，不能和token字面量相匹配的词条树。&lt;/p&gt;&lt;p&gt;尝试把Quiz代码中&lt;code class=&quot;inline&quot;&gt;m!&lt;/code&gt;定义中的匹配分支修改如下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;macro_rules! m {
    (1) =&amp;gt; { print!(&quot;1&quot;) };
}&lt;/code&gt;&lt;p&gt;再去执行Quiz代码，编译器会报错：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;error: no rules expected the token `1`
  --&amp;gt; src/main.rs:6:23
   |
6  |     ($e:expr) =&amp;gt; { m!($e) };
   |                       ^^
...
14 |     t!(1);
   |     ------ in this macro invocation&lt;/code&gt;&lt;p&gt;编译器提示：no rules expected the token &lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。这意味着，&lt;code class=&quot;inline&quot;&gt;expr&lt;/code&gt;不能与&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;这个token字面量相匹配。这就是所谓的「不透明词条」。&lt;/p&gt;&lt;p&gt;在Rust中，不透明词条类型除了&lt;code class=&quot;inline&quot;&gt;expr&lt;/code&gt;，还有其他类型，罗列如下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;$:block
$:expr
$:item
$:literal
$:meta
$:pat
$:path
$:stmt
$:ty&lt;/code&gt;&lt;p&gt;而透明的词条如下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;$:ident
$:lifetime
$:tt&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/9&quot;&gt;点此查看 Rust Quiz 9&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-08-51891075</guid>
<pubDate>Sat, 08 Dec 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
