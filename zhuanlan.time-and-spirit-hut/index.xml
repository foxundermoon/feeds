<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>时光与精神小屋</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Thu, 06 Dec 2018 12:28:32 +0800</lastBuildDate>
<item>
<title>Rust Quiz 解读：Quiz 6</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-06-51683754.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51683754&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt; 来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz  &lt;br&gt; &lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;&lt;br&gt; 不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。   &lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 6:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;use std::mem;

fn main() {
    let a;
    let a =  a = true;
    print!(&quot;{}&quot;, mem::size_of_val(&amp;amp;a));
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果：0&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;std::mem::size_of_val()&lt;/code&gt;函数的用法&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;变量屏蔽&lt;/li&gt;&lt;li&gt;变量声明和赋值&lt;/li&gt;&lt;li&gt;ZST（零大小类型）&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;main函数中，首先声明了&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，但并未赋值，也没有指定具体的类型。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let a = a = true;&lt;/code&gt;，等价于&lt;code class=&quot;inline&quot;&gt;let a = (a = true);&lt;/code&gt;，Rust中可以说是「一切皆表达式」。对于&lt;code class=&quot;inline&quot;&gt;(a=true)&lt;/code&gt;来说，是一个赋值表达式，该表达式的值永远返回单元类型&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;，同时它的值也是&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;。那么&lt;code class=&quot;inline&quot;&gt;let a = (a = true)&lt;/code&gt;;最终等价于&lt;code class=&quot;inline&quot;&gt;let a = ();&lt;/code&gt;。 &lt;/p&gt;&lt;p&gt;所以，在最后的print!打印语句里，使用&lt;code class=&quot;inline&quot;&gt;mem::size_of_val(&amp;amp;a)&lt;/code&gt;函数来计算&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的内存大小，此时等价于&lt;code class=&quot;inline&quot;&gt;mem::size_of_val(&amp;amp;())&lt;/code&gt;，对于单元类型来说，它并不占任何内存空间。在Rust中，这种类型叫做ZST（Zero Size Type）。它们不占空间，最终会被LLVM优化掉。所以输出当然是：0。&lt;/p&gt;&lt;p&gt;那么，上面代码发散一下，能否这么写呢?&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() {
    let a;
    let a =  a =  a = true;
    print!(&quot;{}&quot;, std::mem::size_of_val(&amp;amp;a));
}&lt;/code&gt;&lt;p&gt;注意这里的代码变化，&lt;code class=&quot;inline&quot;&gt;let a =  a =  a = true;&lt;/code&gt;，等价于&lt;code class=&quot;inline&quot;&gt;let a =  ( a =  (a = true) );&lt;/code&gt;。但仔细想想，这样成立吗？&lt;/p&gt;&lt;p&gt;执行以后会报错：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;error[E0308]: mismatched types
 --&amp;gt; src/main.rs:3:17
  |
3 |     let a = a = (a = true);
  |                 ^^^^^^^^^^ expected bool, found ()
  |
  = note: expected type `bool`
             found type `()`

error: aborting due to previous error&lt;/code&gt;&lt;p&gt;这是为什么呢？&lt;/p&gt;&lt;p&gt;首先，&lt;code class=&quot;inline&quot;&gt;(a = true)&lt;/code&gt;，已经让Rust编译器推断&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;的类型为&lt;code class=&quot;inline&quot;&gt;bool&lt;/code&gt;了。然后，&lt;code class=&quot;inline&quot;&gt;(a = (a = true))&lt;/code&gt;，等价于，&lt;code class=&quot;inline&quot;&gt;(a = ());&lt;/code&gt;，类型不匹配，自然会报错。&lt;/p&gt;&lt;p&gt;但是为什么&lt;code class=&quot;inline&quot;&gt;let a = (a = true)&lt;/code&gt;，没有报相似的错呢？ 这是因为，当前执行的是&lt;code class=&quot;inline&quot;&gt;let a = ();&lt;/code&gt;，和&lt;code class=&quot;inline&quot;&gt;a = ();&lt;/code&gt;比较一下，区别在哪里？ &lt;/p&gt;&lt;p&gt;区别正是因为那个&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;，因为有&lt;code class=&quot;inline&quot;&gt;let&lt;/code&gt;，所以这里是一个&lt;code class=&quot;inline&quot;&gt;变量屏蔽&lt;/code&gt;，也就是重新定义了一个&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，它的类型自然不受之前类型推断结果的影响。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/6&quot;&gt;点此查看 Rust Quiz 6&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-06-51683754</guid>
<pubDate>Thu, 06 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 5</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-05-51616607.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51616607&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt; 来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz  &lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt; &lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。   &lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 5:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Trait {
    fn f(self);
}

impl&amp;lt;T&amp;gt; Trait for fn(T) {
    fn f(self) {
        print!(&quot;1&quot;);
    }
}

impl&amp;lt;T&amp;gt; Trait for fn(&amp;amp;T) {
    fn f(self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let a: fn(_) = |_: u8| {};
    let b: fn(_) = |_: &amp;amp;u8| {};
    let c: fn(&amp;amp;_) = |_: &amp;amp;u8| {};
    a.f();
    b.f();
    c.f();
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果：112&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;考察要点：&lt;/b&gt; &lt;/p&gt;&lt;ol&gt;&lt;li&gt;fn(T)与fn(&amp;amp;T)的区别&lt;/li&gt;&lt;li&gt;类型推断&lt;/li&gt;&lt;li&gt;trait 实现&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;代码中定义了一个名为&lt;code class=&quot;inline&quot;&gt;Trait&lt;/code&gt;的trait，其中包含了方法签名&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;。然后分别为&lt;code class=&quot;inline&quot;&gt;fn(T)&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;fn(&amp;amp;T)&lt;/code&gt;这两种函数指针类型实现了Trait。&lt;/p&gt;&lt;p&gt;那&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt; 和&lt;code class=&quot;inline&quot;&gt;&amp;amp;T&lt;/code&gt;有啥区别呢？&lt;/p&gt;&lt;ul&gt;&lt;li&gt; T， 是一个泛型参数，代表任何一个具体的类型。那么&lt;code class=&quot;inline&quot;&gt;fn(T)&lt;/code&gt;就是指一个拥有具体类型的函数指针。&lt;/li&gt;&lt;li&gt;&amp;amp;T，实际上等价于&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a T&lt;/code&gt;，代表某个引用类型。则&lt;code class=&quot;inline&quot;&gt;fn(&amp;amp;T)&lt;/code&gt;，就是&lt;code class=&quot;inline&quot;&gt;fn(&amp;amp;&#39;a T)&lt;/code&gt;。注意这里的&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;也是一个泛型参数，并不是指具体的类型。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在main函数中，分别定义了三个变量绑定，a、b、c，分别将三个闭包指定为特定的函数指针类型。最后再分别调用它们的&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;方法。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let a: fn(_) = |_: u8| {};&lt;/code&gt;，对于&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;来说，&lt;code class=&quot;inline&quot;&gt;_&lt;/code&gt;会被推断为&lt;code class=&quot;inline&quot;&gt;u8&lt;/code&gt;类型。那么对应于&lt;code class=&quot;inline&quot;&gt;fn(T)&lt;/code&gt;类型，最终调用其f方法输出结果就是：1。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let b: fn(_) = |_: &amp;amp;u8| {};&lt;/code&gt;，对于&lt;code class=&quot;inline&quot;&gt;b&lt;/code&gt;来说，&lt;code class=&quot;inline&quot;&gt;_&lt;/code&gt;会被推断为&lt;code class=&quot;inline&quot;&gt;&amp;amp;u8&lt;/code&gt;类型。这就是一个令人迷惑的点了，到底是对应&lt;code class=&quot;inline&quot;&gt;fn(T)&lt;/code&gt;还是&lt;code class=&quot;inline&quot;&gt;fn(&amp;amp;T)&lt;/code&gt;。这里的&lt;code class=&quot;inline&quot;&gt;&amp;amp;u8&lt;/code&gt;实际上是一个具体的值。它实际上等价于&lt;code class=&quot;inline&quot;&gt;f(&amp;amp;&#39;x u8)&lt;/code&gt;，这里的&lt;code class=&quot;inline&quot;&gt;&#39;x&lt;/code&gt;是一个具体的可确定的生命周期值。因为Rust生命周期参数，只有在具体使用的地方，才是具体实例化的。最终调用其f方法输出结果依然是：1。&lt;/p&gt;&lt;p&gt;let c: fn(&amp;amp;&lt;i&gt;) = |&lt;/i&gt;: &amp;amp;u8| {};&lt;code class=&quot;inline&quot;&gt;`，对于c来说，&lt;/code&gt;_&lt;code class=&quot;inline&quot;&gt;会被推断为&lt;/code&gt;u8&lt;code class=&quot;inline&quot;&gt;。此时显然，对应于&lt;/code&gt;fn(&amp;amp;T)&lt;code class=&quot;inline&quot;&gt;。&lt;/code&gt;&amp;amp;u8&lt;code class=&quot;inline&quot;&gt;的生命周期固然是已经具体实例化，但它的函数指针类型，依然是&lt;/code&gt;fn(&amp;amp;T)`。最终调用其方法输出结果就是： 2。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/5&quot;&gt;点此查看 Rust Quiz 5&lt;/a&gt; &lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-05-51616607</guid>
<pubDate>Wed, 05 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 4</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-04-51560682.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51560682&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 4:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() {
    let (.., x, y) = (0, 1, ..);
    print!(&quot;{}&quot;, b&quot;066&quot;[y][x]);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 54&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;考察要点： &lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;模式匹配&lt;/li&gt;&lt;li&gt;Range和RangeFull&lt;/li&gt;&lt;li&gt;字节字符串表示法&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;上面只有两行代码，但是隐藏了很多信息。&lt;/p&gt;&lt;p&gt;Rust中let绑定语句支持模式匹配。main函数中代码第一行是元组的匹配赋值操作。在等号左边的&lt;code class=&quot;inline&quot;&gt;(.., x, y)&lt;/code&gt;是匹配的模式，等号右边&lt;code class=&quot;inline&quot;&gt;(0, 1, ..)&lt;/code&gt;是要匹配的值。&lt;/p&gt;&lt;p&gt;这里最迷惑人的地方就是&lt;code class=&quot;inline&quot;&gt;..&lt;/code&gt;，在匹配模式中，&lt;code class=&quot;inline&quot;&gt;..&lt;/code&gt;代表其余要匹配的项。在上面示例中，就是除了x和y之外，要匹配的项。而在等号右边等待匹配的值中，&lt;code class=&quot;inline&quot;&gt;..&lt;/code&gt;则代表一个值：RangeFull。RangeFull是一个单元结构体，它代表Range（范围）的全范围类型。&lt;/p&gt;&lt;p&gt;所以，下面代码是合法的：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let range_full = std::ops::RangeFull;
let range_full = ..;&lt;/code&gt;&lt;p&gt;这两行代码是等价的。&lt;/p&gt;&lt;p&gt;所以，上面最终的元组匹配结果是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;左边&lt;code class=&quot;inline&quot;&gt;..&lt;/code&gt;匹配右边的&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;&lt;/li&gt;&lt;li&gt;左边&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;匹配右边的&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;&lt;/li&gt;&lt;li&gt;左边&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;匹配右边的&lt;code class=&quot;inline&quot;&gt;..&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;然后在最后的&lt;code class=&quot;inline&quot;&gt;print!&lt;/code&gt;语句中，&lt;code class=&quot;inline&quot;&gt;b&quot;0666&quot;&lt;/code&gt;实际上是一种字节字符串的语法糖，它等价于&lt;code class=&quot;inline&quot;&gt;[48u8, 54u8, 54u8]&lt;/code&gt;字节序列：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let d = [48u8, 54u8, 54u8];
 assert_eq!(&quot;066&quot;, std::str::from_utf8(&amp;amp;d).unwrap());&lt;/code&gt;&lt;p&gt;所以，&lt;code class=&quot;inline&quot;&gt;b&quot;066&quot;[y][x]&lt;/code&gt;现在是&lt;code class=&quot;inline&quot;&gt;b&quot;066&quot;[..][1] == b&quot;6&quot;&lt;/code&gt;，那么最终输出结果就是： 54。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/4&quot;&gt;点此查看 Rust Quiz 4&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-04-51560682</guid>
<pubDate>Tue, 04 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「付费阅读」如何为Rust语言做贡献</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-03-51479889.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51479889&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5d4a713aff10d99bf7e2d48b68018ce4_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;本文基于macOSX平台，通过对Rust 1.32 Nightly版本中rustdoc的一个ICE问题进行复盘，分析并记录整个Bug修复的过程。主要目的是，通过这个过程，来学习如何给Rust做贡献。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;（阅读时间：17m）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;1. 缘起&lt;/p&gt;&lt;p&gt;2. Rust本地调试环境准备&lt;/p&gt;&lt;p&gt;3. ICE问题分析&lt;/p&gt;&lt;p&gt;4. 调试代码&lt;/p&gt;&lt;p&gt;5. 提交PR说明&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;---&lt;/p&gt;&lt;h2&gt;&lt;b&gt;缘起：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在两周前，我发现了一个rustdoc的[ICE(issue 55723)](&lt;a href=&quot;https://github.com/rust-lang/rust/issues/55723&quot;&gt;https://github.com/rust-lang/rust/issues/55723&lt;/a&gt;)，提交给了官方。但是官方指派修复此Bug的开发者QuietMisdreavus 难以复现该Bug。我本来以为Bug是因为多字节字符（比如全角符号之类）引起的，然而经过我仔细的测试，发现问题的根源在于尾随的「空格」。&lt;/p&gt;&lt;h2&gt;更多内容请花&lt;b&gt;一元查看&lt;/b&gt;：&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-233a6d659a6944c30a4d23a1cf8054aa_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;659&quot; data-rawheight=&quot;1920&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-233a6d659a6944c30a4d23a1cf8054aa&quot; data-watermark-src=&quot;v2-0a81c5365a61d19ca3a2bc04d60b2416&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-03-51479889</guid>
<pubDate>Mon, 03 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 3</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-03-51433417.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51433417&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;-  &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 3:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S {
    x: i32,
}

const S: S = S { x: 2 };

fn main() {
    let v = &amp;amp;mut S;
    v.x += 1;
    S.x += 1;
    print!(&quot;{}{}&quot;, v.x, S.x);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 32&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;考察要点： &lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;可变引用&lt;/li&gt;&lt;li&gt;结构体实例化不需要构造函数&lt;/li&gt;&lt;li&gt;const语义&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;代码中定义了一个具名结构体&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，包含了一个字段&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;。接下来又定义了一个&lt;code class=&quot;inline&quot;&gt;const&lt;/code&gt;常量，同样命名为&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，并且将一个结构体&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的实例赋值给它。&lt;/p&gt;&lt;p&gt;要注意区分这两个&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;。常量&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，是代表值，而结构体&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;，则代表类型。在Rust中，分别将这两个S，存储在&lt;code class=&quot;inline&quot;&gt;值命名空间(Value NameSpace)&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;类型命名空间(Type NameSpace)&lt;/code&gt;中，所以可以同时存在两个相同的S。&lt;/p&gt;&lt;p&gt;常量S，会内联到用它的具体使用的地方。在语义层面，就是表示它的值会替换到使用它的每个地方。&lt;/p&gt;&lt;p&gt;&lt;b&gt;在main函数中， 常量S会被内联到两个地方：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;第一个地方&lt;/b&gt;是： &lt;code class=&quot;inline&quot;&gt;let v = &amp;amp;mut S;&lt;/code&gt;， 这里的S，是一个值，要被const S替换掉。等价于:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let mut _tmp = S {x: 2} ; 
let v = &amp;amp;mut tmp_;&lt;/code&gt;&lt;p&gt;所以，当执行 &lt;code class=&quot;inline&quot;&gt;v.x += 1&lt;/code&gt; 之后，&lt;code class=&quot;inline&quot;&gt;v.x&lt;/code&gt;的值就是：3。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第二个地方&lt;/b&gt;是：&lt;code class=&quot;inline&quot;&gt;S.x += 1;&lt;/code&gt;，这里的S同样会被替换为const S的值。等价于:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;S {x: 2}.x += 1;&lt;/code&gt;&lt;p&gt;而此时，这个S {: 2}是一个新的结构体实例，和上面的S已经无关，所以改变它的值，并不影响到&lt;code class=&quot;inline&quot;&gt;S.x&lt;/code&gt;的值，所以结果是: 2。&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-03-51433417</guid>
<pubDate>Mon, 03 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读： Quiz 2</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-02-51366804.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51366804&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;&lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 2:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S(i32);

impl std::ops::BitAnd&amp;lt;S&amp;gt; for () {
    type Output = ();

    fn bitand(self, rhs: S) {
        print!(&quot;{}&quot;, rhs.0);
    }
}

fn main() {
    let f = || ( () &amp;amp; S(1) );
    let g = || { () &amp;amp; S(2) };
    let h = || ( {} &amp;amp; S(3) );
    let i = || { {} &amp;amp; S(4) };
    f();
    g();
    h();
    i();
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果：123&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点： &lt;/p&gt;&lt;ol&gt;&lt;li&gt;trait：操作符重载&lt;/li&gt;&lt;li&gt;trait：关联类型&lt;/li&gt;&lt;li&gt;单元类型 ()&lt;/li&gt;&lt;li&gt;元组结构体&lt;/li&gt;&lt;li&gt;闭包使用圆括号和块的差异&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;代码中定义了元组结构体S(i32)，又为其实现了&lt;code class=&quot;inline&quot;&gt;std::ops::BitAdd&amp;lt;s&amp;gt;&lt;/code&gt; trait，意味着，该元组结构体就有了位运算&lt;code class=&quot;inline&quot;&gt;&amp;amp;&lt;/code&gt;的能力。&lt;/p&gt;&lt;p&gt;在实现BitAdd的代码中，指定了关联类型为单元类型&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;，在bitand方法中，省略了返回类型。等价于下面代码。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fn bitand(self, rhs: S) -&amp;gt; () { ... }&lt;/code&gt;&lt;p&gt;那么在main函数中：&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let f = || ( () &amp;amp; S(1) );&lt;/code&gt;  ， 这行代码中，f绑定的是一个闭包。闭包中&lt;code class=&quot;inline&quot;&gt;() &amp;amp; S(1)&lt;/code&gt;是一个位操作&lt;code class=&quot;inline&quot;&gt;&amp;amp;&lt;/code&gt;表达式。最终结果当然是输出&lt;code class=&quot;inline&quot;&gt;rhs.0&lt;/code&gt;，也就是：1。元组结构体和元组的用法是一样的。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let g = || { () &amp;amp; S(2) };&lt;/code&gt;， 这行代码中，g绑定的依然是一个闭包。闭包可以用圆括号，也可以用花括号。闭包内，&lt;code class=&quot;inline&quot;&gt;() &amp;amp; S(2)&lt;/code&gt;依然是一个完整的表达式，求值结果是：2。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let h = || ( {} &amp;amp; S(3) );&lt;/code&gt;，这行代码中，h同样是一个闭包，但注意这里闭包是用圆括号来表示，这代表，&lt;code class=&quot;inline&quot;&gt;{} &amp;amp; S(3)&lt;/code&gt;按一个完整独立的表达式来处理。其中&lt;code class=&quot;inline&quot;&gt;{}&lt;/code&gt;表达式求值结果是&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;，再和&lt;code class=&quot;inline&quot;&gt;S(3)&lt;/code&gt;进行与操作，得到最终值： 3。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;let i = || { {} &amp;amp; S(4) };&lt;/code&gt;，这行代码中， i同样是一个闭包，然而，它是以花括号构成。花括号和圆括号的区别在于，花括号代表一个块（block），它默认按多条表达式语句进行解析。所以，&lt;code class=&quot;inline&quot;&gt;{} &amp;amp; S(4)&lt;/code&gt;，实际上被看作两条语句&lt;code class=&quot;inline&quot;&gt;{}&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&amp;amp;S(4)&lt;/code&gt;，最终闭包执行结果是返回一个&lt;code class=&quot;inline&quot;&gt;S(4)&lt;/code&gt;的引用。和位操作没有啥关系，最终也没有任何输出结果。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;{}&lt;/code&gt;的区别，不仅仅在于闭包，在写声明宏或者其他地方都是一致的。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/2&quot;&gt;点此查看 Rust Quiz 2 &lt;/a&gt; &lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-02-51366804</guid>
<pubDate>Sun, 02 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「Rust每日新闻」本周精选 • 第二十二期</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-02-51361684.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51361684&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-308c039c05fe1f2803788cde5b0b5f1a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;前言： 从2018年开始，我每天会花1个小时关注Rust社区动态，并且在&lt;a href=&quot;http://rust.cc/&quot;&gt;Rust.CC论坛&lt;/a&gt;、&lt;a href=&quot;https://t.me/rust_daily_news&quot;&gt;tg channel&lt;/a&gt;、&lt;a href=&quot;https://steemit.com/@blackanger&quot;&gt;Steemit&lt;/a&gt;、&lt;a href=&quot;https://github.com/RustStudy/rust_daily_news&quot;&gt;GitHub&lt;/a&gt;、&lt;a href=&quot;https://www.yuque.com/chaosbot/rustnews&quot;&gt;语雀订阅&lt;/a&gt;都开通了Rust每日新闻，分享我每天的见闻，偶尔也夹杂了一些个人的观点。大半年过去了，Rust每日新闻已经成为了Rust社区群大家每天必看的内容。在这个知乎专栏里，每周会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。 2018-12-02&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;官方新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;「通告」Rust 2018 新的Beta版发布！&lt;/h2&gt;&lt;p&gt;Rust 2018已经进入了最终的倒计时，官方刚刚发布了一个最新测试版。新的测试版包含了一些最近新稳定的功能和一些Bug修复。还包含一些工具的改进：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Rustfmt 1.0&lt;/li&gt;&lt;li&gt;RLS和Clpippy可以直接安装，不再是“preview”组件了。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;来帮助检测是否存在Bug。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://internals.rust-lang.org/t/announcing-rust-2018-beta-release/8901&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「官方」Rust 2018年度调查报告&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51018048&quot;&gt;中文&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html&quot;&gt;英文&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「官方」演变中的Tide中间件&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51048926&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「官方网络工作组」2018调查报告&lt;/h2&gt;&lt;p&gt;此次是网络工作组的报告，一共收到1000多条回复。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5409f04de7cc9a60cc28ec824ad2e208_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;427&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-5409f04de7cc9a60cc28ec824ad2e208&quot; data-watermark-src=&quot;v2-d88e4f6aeac2b53dd2803933bb40e973&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在Web方面，流行的框架是Rocket和Actix，分别占比27%和24%。也有其他框架的选择，但是有20%的人不选择任何框架，而是在hyper上自行搭建服务。&lt;/p&gt;&lt;p&gt;存在的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;65%的人认为缺乏示例是目前生态系统中的问题，其次是缺乏文档。这也是Tokio Doc Push和Rust异步之书正在解决的问题。&lt;/li&gt;&lt;li&gt;缺乏一个真正的框架，类似于Rails或Django那样的。这也是网络工作组正在考虑的事情。为此官方构建了Tide，为打算使用Rust构建Web应用提供一个良好的开端，另一个目标是想要深入挖掘并学习如何在Rust中编写Web框架的人提供一个文档。&lt;/li&gt;&lt;li&gt;在构建应用程序时缺乏对框架和服务的一些绑定。包括绑定应用程序，比如各种NoSql数据库、支持在K8S上运行、编排容器框架和LDAP认证协议。以及对数据库的异步访问支持等，并没有一个惯用法的指南。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://rust-lang-nursery.github.io/wg-net/2018/11/28/wg-net-survey.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust官网界面改版引发争议&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://beta.rust-lang.org/&quot;&gt;官网改版测试界面&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-ee7f2368481669814d6562478b86312f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;363&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-ee7f2368481669814d6562478b86312f&quot; data-watermark-src=&quot;v2-af1cdfe38767b50686edefad0ed9f539&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;官方Rust Book现在有Epub版本下载&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.jyotirmoy.net/posts/2018-12-01-rust-book.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;社区新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;AWS Lambda已经支持Rust&lt;/h2&gt;&lt;p&gt;使用该库可以在AWS Lambda上运行Rust实现的函数&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/awslabs/aws-lambda-rust-runtime&quot;&gt;aws-lambda-rust-runtime&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/cn/blogs/opensource/rust-runtime-for-aws-lambda/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「游戏」Amethyst基金会成立了&lt;/h2&gt;&lt;p&gt;好消息。Amethyst是一款免费的开源游戏引擎。它是用Rust编写的，其核心是ECS架构。现在成立了基金会是为了组建一个官方的非盈利组织。这对于Amethyst的发展应该是非常有好处的了。当然，现在的状态只是提交了文件，还在等待最后的审批。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.amethyst.rs/blog/non-profit-announce/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「演讲」低延迟音频合成&lt;/h2&gt;&lt;p&gt;包含了演讲视频、代码和Slides。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://youtu.be/-F7whGjquHI?t=3150&quot;&gt;视频&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/raphlinus/synthesizer-io&quot;&gt;Code&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1cm9QaV_UjgvgBaWszHsR_w5EVre5O1D5kJUpMKQYo4I/edit?usp=sharing&quot;&gt;Slides&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;也可以多关注下后续，会有详细的博文放出。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://synthesize.rs/nov-2018-talk/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust Belt Rust 2018 大会 视频合集&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&quot;&gt;视频合集&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;AWS 出品 :  Firecracker&lt;/h2&gt;&lt;p&gt;Firecracker是一种开源虚拟化技术，专门用于创建和管理安全，多租户容器和基于功能的服务，提供无服务器操作模型。 Firecracker在轻量级虚拟机中运行工作负载，称为microVM，它将硬件虚拟化技术提供的安全性和隔离性与容器的速度和灵活性相结合。&lt;/p&gt;&lt;p&gt;看上去应该是兼容docker生态链，倾向于Serverless。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/firecracker-microvm/firecracker&quot;&gt;firecracker&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://firecracker-microvm.github.io/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/cn/blogs/aws/firecracker-lightweight-virtualization-for-serverless-computing/&quot;&gt;More Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「博文」Bitfury公司的工程师为俄罗斯邮政服务设计区块链&lt;/h2&gt;&lt;blockquote&gt; 本月，Bitfury®工程师Yury Yanovich，Ivan Prokhorov，Darya Korepanova和Sergey Vorobyov与Skolkovo科学技术研究所（Skoltech）的计算和数据密集型科学与工程中心一起在科学研究期刊Informatics上发表; 信息传输问题研究所数据挖掘和预测建模实验室; 罗蒙诺索夫莫斯科国立大学世界经济地理系; 和高等经济学院的工作是设计一个基于区块链的供应链，以防止印章伪造。 &lt;br&gt; &lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://www.mdpi.com/2227-9709/5/4/42/pdf&quot;&gt;论文&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/korepkorep/russian-post&quot;&gt;代码原型&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;RustQuiz: 26个在线Rust面试题&lt;/h2&gt;&lt;p&gt;来自于RustFest 2018 大会的轻演讲主题：Rust Quiz&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;RustaCUDA v0.1.0发布&lt;/h2&gt;&lt;p&gt;RustaCUDA是对CUDA API的Rust包装。允许分配和释放GPU内存，从GPU复制数据，加载CUDA模块和启动内核，所有这些都具有最安全，程序员友好的Rusty接口。 它可以加载和启动用任何CUDA兼容语言编写的内核，而不仅仅是Rust。&lt;/p&gt;&lt;p&gt;该作者对Rust支持CUDA作出了很多努力。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://bheisler.github.io/post/announcing-rustacuda/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/bheisler/RustaCUDA&quot;&gt;RustaCUDA&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Rocket v0.4 RC2版本发布&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://rocket.rs/v0.4/news/2018-11-30-version-0.4-rc-2/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;TOML规范 0.5中文翻译发布了&lt;/h2&gt;&lt;p&gt;从0.5开始，TOML规范趋于稳定。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/toml-lang/toml/blob/master/versions/cn/toml-v0.5.0.md&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Atom 1.33发布，内置Rust支持&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://blog.atom.io/2018/11/28/atom-1-33.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;改进的Rust贴纸，超酷&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://i.redd.it/206f9o60u0121.png&quot;&gt;下载&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「投票结果」你主要用什么操作系统构建Rust代码&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-26d65473d8e17fa47a494062e8486ce7_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;752&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-26d65473d8e17fa47a494062e8486ce7&quot; data-watermark-src=&quot;v2-2193884c07be1e393268069632f3b76d&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;学习资源&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;「付费」《如何系统地学习Rust》&lt;/h2&gt;&lt;p&gt;为你精心打造Rust必学第一课。 &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/lives/1043463438202249216&quot;&gt;知乎Live (已完结，可回看，9.9¥)&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust语言CheatSheet&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://cheats.rs/&quot;&gt;Cheats.rs&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust Quiz 解读： Quiz 1&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51304039&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;AoC 2018谜题Rust解决方案&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://adventofcode.com/&quot;&gt;AOC官网&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/BurntSushi/advent-of-code&quot;&gt;BurntSushi的解决方案&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/BenoitZugmeyer/RustyAdventOfCode#other-rust-implementations&quot;&gt;历年谜题解决方案&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;新书：用Rust编写WebAssembly&lt;/h2&gt;&lt;p&gt;beta版可预定。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://pragprog.com/book/khrust/programming-webassembly-with-rust&quot;&gt;programming-webassembly-with-rust&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「系列文章」数独谜题生成器 pt.3: 使用WebAssembly&lt;/h2&gt;&lt;p&gt;作者想用一个数独谜题生成器来检测WebAssembly的性能，他写了一系列文章，本文是第三篇，用Rust的wasm-bindgen工具来创建数独生成器的wasm模块。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/@rossharrison/generating-sudoku-boards-pt-3-rust-for-webassembly-85bd7294c34a&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「博文」如何将Tokio的AsyncRead和AsyncWrite转换为Futures, Sinks和Streams&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;AsyncRead to Future, 一次性读&lt;/li&gt;&lt;li&gt;AsyncRead to Stream, 持续读&lt;/li&gt;&lt;li&gt;AsyncWrite to Sink, 持续写&lt;/li&gt;&lt;li&gt;AsyncWrite to Future, 一次性写&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://jsdw.me/posts/rust-futures-tokio/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/jsdw/jsdw.me/blob/master/content/posts/rust-futures-tokio/src/main.rs&quot;&gt;Sample Code&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「博文」在Nightly版下使用async/await&lt;/h2&gt;&lt;p&gt;本文介绍了async/await，并且介绍了如何在最新的生态系统中使用老的futures 0.1。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://jsdw.me/posts/rust-asyncawait-preview/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「视频」使用Rust和Amethyst引擎进行游戏开发&lt;/h2&gt;&lt;p&gt;视频演讲中以一个开源的消除游戏everpuzzle为示例进行介绍。 [大约1小时]&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Skytrias/everpuzzle&quot;&gt;everpuzzle Code&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=P_9A7P0uNpY&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「嵌入式Rust」嵌入式开发环境&lt;/h2&gt;&lt;p&gt;作者尝试玩嵌入式，选择了以自定义一个ErgoDox键盘作为尝试。本教程介绍了相关的开发环境准备。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://josh.robsonchase.com/embedded-bootstrapping/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;在Android开发中使用Rust&lt;/h2&gt;&lt;p&gt;国内社区小伙伴写的文章，介绍如何在Android中使用Rust。&lt;/p&gt;&lt;p&gt;基于 &lt;a href=&quot;http://github.com/jni-rs/jni-rs&quot;&gt;jni-rs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50123055&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;使用Rust和Efflux编写 MapReduce Jobs&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://whitfin.io/writing-mapreduce-jobs-using-rust/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/whitfin/efflux&quot;&gt;efflux&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;项目&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;romio：异步网络原语&lt;/h2&gt;&lt;p&gt;无船同志写的 ：Mio + Future + Tokio = Romio。&lt;/p&gt;&lt;p&gt;（ 八卦： tokio作者不原意跟进Futures最新版，所以官方派出无船同志完成这项推动Rust异步历史进程的艰巨任务。） &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/withoutboats/romio&quot;&gt;romio&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Sequoia: OpenPGP的一个Rust实现&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://media.ccc.de/v/rustfest-rome-6-sequoia&quot;&gt;RustFest Roma上的演讲&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt; 关于Sequoia：Sequoia由三位前GnuPG开发商Neal H. Walfield，Justus Winter和Kai Michaelis开发。为了缓解许多常见的安全问题，Sequoia是用强类型语言Rust编写的，它提供了时间和空间内存安全性。 Rust还为将库嵌入其他语言提供了出色的支持。 Sequoia已经提供了C绑定，并且正在积极开发Python绑定。&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://gitlab.com/sequoia-pgp/sequoia&quot;&gt;sequoia&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;秘猿开源CKB和CKB-VM&lt;/h2&gt;&lt;p&gt;Nervos CKB是一个公共授权区块链，是Nervos网络的共识层。CKB的VM是基于RISC-V指令集实现的。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/nervosnetwork/ckb&quot;&gt;ckb&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/nervosnetwork/ckb-vm&quot;&gt;ckb-vm&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;高性能JavaScript到JavaScript编译器&lt;/h2&gt;&lt;p&gt;基于Rust和Wasm实现&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ratel-rust/ratel-core&quot;&gt;ratel-core&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;使用Cranelift实现的玩具语言JIT&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/CraneStation/simplejit-demo&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Atlasr： 免费的地图预览器&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/atlasr-org/atlasr&quot;&gt;atlasr&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Tange：基于任务的并行框架&lt;/h2&gt;&lt;p&gt;“任务并行”是指一个或多个独立的任务同时运行。 可以用来做并行计算。用于：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;数据处理&lt;/li&gt;&lt;li&gt;分布式机器学习算法&lt;/li&gt;&lt;li&gt;一般的并行计算&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Refefer/tange&quot;&gt;tange&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;工具与库&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;tr: 国际化（i18n）库&lt;/h2&gt;&lt;p&gt;刚发布，现在找人使用，并且想得到更多反馈。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/a09b0n/tr_a_crate_for_internationalizationof_rust_code/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「工具」宣布RustPräzi：为crates.io构建整个调用图(call graph)&lt;/h2&gt;&lt;blockquote&gt; 我们很高兴地宣布我们的第一个版本的RustPräzi，一个PoC（概念验证）项目，它从crates.io 3下载所有crate版本，构建LLVM调用图并将它们链接到一个大型版本的基于呼叫的依赖网络。与常规依赖关系网络不同，基于调用的依赖关系网络表示包内和包之间的函数调用链，支持图形分析/查询&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;一个CG是表示整个程序中方法（函数）之间调用关系的图，图中的节点是方法，边表示调用关系。例如方法foo()调用了方法bar()，则CG中应有一条从foo()到bar()的有向边。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://users.rust-lang.org/t/announcing-rustprazi-a-tool-to-build-an-entire-call-graph-of-crates-io/22696&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;高效diff算法库&lt;/h2&gt;&lt;p&gt;pijul开源了它们用的diff算法。pijul是基于Rust实现的类Git版本控制工具，&lt;a href=&quot;https://jneem.github.io/pijul/&quot;&gt;用法介绍&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://docs.rs/diffs/0.1.0/diffs/&quot;&gt;diffs&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;招聘&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;「招聘」位于美国旧金山市中心的公司招Rust工程师&lt;/h2&gt;&lt;p&gt;这是去矿上工作啊。想用Rust构建大型的数字货币和大型采矿系统。没看到说可以远程的信息，应该是不能远程了。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;薪水 120k ~ 160k美刀 + 股权&lt;/li&gt;&lt;li&gt;旧金山软件工程师的平均工资是134,000美元&lt;/li&gt;&lt;li&gt;旧金山的失业率为3％&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://functional.works-hub.com/jobs/rust-engineer-in-san-francisco-united-states-of-america-3a18b&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-02-51361684</guid>
<pubDate>Sun, 02 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读： Quiz 1</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-01-51304039.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51304039&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;/blockquote&gt;&lt;p&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/p&gt;&lt;h2&gt;Quiz 1:&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;macro_rules! m {
    ($($s:stmt)*) =&amp;gt; {
        $(
            { stringify!($s); 1 }
        )&amp;lt;&amp;lt;*
    };
}

fn main() {
    print!(
        &quot;{}{}{}&quot;,
        m! { return || true },
        m! { (return) || true },
        m! { {return} || true },
    );
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 112&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;考察要点： &lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;声明宏的语法&lt;/li&gt;&lt;li&gt;Rust中语句（statements）的区分&lt;/li&gt;&lt;li&gt;操作符优先级&lt;/li&gt;&lt;li&gt;return作为表达式产生的值是Never Type类型(!)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;上面代码中，宏声明代码中火箭符（=&amp;gt;）左边的是匹配表达式，其中&lt;code class=&quot;inline&quot;&gt;$s:stmt&lt;/code&gt;  代表匹配语句（statements），而&lt;code class=&quot;inline&quot;&gt;$( )*&lt;/code&gt;这样的语法，类似于正则表达式，代表匹配零个或多个。那么&lt;code class=&quot;inline&quot;&gt;$($S: stmt)*&lt;/code&gt;就代表匹配零个或多个语句tokens。&lt;/p&gt;&lt;p&gt;在火箭符的右侧，&lt;code class=&quot;inline&quot;&gt;{stringify!($s); 1}&lt;/code&gt;  其中的stringily!宏是将匹配的语句$s转换为字符串，  &lt;code class=&quot;inline&quot;&gt;$( )&amp;lt;&amp;lt;*&lt;/code&gt;  对应于左边匹配表达式，生成零个或多个形如&lt;code class=&quot;inline&quot;&gt;... &amp;lt;&amp;lt; ... &amp;lt;&amp;lt;&lt;/code&gt;这样的语句。&lt;/p&gt;&lt;p&gt;&lt;b&gt;再来看main函数中：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;m!{ return || true}&lt;/code&gt;  ，等价于&lt;code class=&quot;inline&quot;&gt;return (|| true )&lt;/code&gt; ，返回一个闭包。这属于一条独立语句。所以 最终宏生成的代码是 &lt;code class=&quot;inline&quot;&gt;{&quot;return || true&quot;; 1}&lt;/code&gt;，最终在print!语句中执行结果是返回块代码中最后一个表达式的值：1.&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;m!{(return) || true}&lt;/code&gt;，这里面return被括号隔离，那么整个语句是或操作。这里return 是一个表达式，它产生的值是NeverType（!）。右边表达式是true，所以是一个独立的语句。最终宏生成的代码是 &lt;code class=&quot;inline&quot;&gt;{&quot;(return) || true&quot;; 1}&lt;/code&gt;，最终的值是：1。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;m!{ {return} || true }&lt;/code&gt;，这里rutrn用花括号隔开，代表它是一个独立的语句，后面的&lt;code class=&quot;inline&quot;&gt;|| true&lt;/code&gt;就会被看做一个独立的闭包。那么这里存在两条语句，最终宏生成的代码是&lt;code class=&quot;inline&quot;&gt;{&quot;{true}&quot;; 1} &amp;lt;&amp;lt; {&quot;|| true&quot;; 1}&lt;/code&gt;，那么最终的值就是&lt;code class=&quot;inline&quot;&gt;1&amp;lt;&amp;lt;1&lt;/code&gt;，也就是：2。&lt;/p&gt;&lt;p&gt;所以代码的执行结果就是112。&lt;/p&gt;&lt;p&gt;点此查看原题，及更多解释：&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/1&quot;&gt;Rust Quiz 1 &lt;/a&gt; &lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-01-51304039</guid>
<pubDate>Sat, 01 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「官方」演变中的Tide中间件</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-11-28-51048926.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51048926&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-67e9a14fec18c48abf4869dba6dde2da_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;Tide，是Rust官方出品的异步Web开发框架，为了构建生态标准而创建。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在上篇文章里说到，Tide借鉴了actix-web中before/after风格的中间件。然而&lt;a href=&quot;https://steemit.com/@tirr-c&quot;&gt;@tirr-c&lt;/a&gt;基于此又发现了更好的抽象方式。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;/// Middleware that wraps around remaining middleware chain.
pub trait Middleware&amp;lt;Data&amp;gt;: Send + Sync {
    /// Asynchronously handle the request, and return a response.
    fn handle&amp;lt;&#39;a&amp;gt;(&amp;amp;&#39;a self, ctx: RequestContext&amp;lt;&#39;a, Data&amp;gt;) -&amp;gt; FutureObj&amp;lt;&#39;a, Response&amp;gt;;
}&lt;/code&gt;&lt;p&gt;新的trait使用一个方便的RequestContext，封装了中间件可用的所有上下文信息。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub struct RequestContext&amp;lt;&#39;a, Data&amp;gt; {
    pub app_data: Data,
    pub req: Request,
    pub params: RouteMatch&amp;lt;&#39;a&amp;gt;,
    // plus additional, private fields
}

impl&amp;lt;&#39;a, Data: Clone + Send&amp;gt; RequestContext&amp;lt;&#39;a, Data&amp;gt; {
    /// Consume this context, and run remaining middleware chain to completion.
    pub fn next(self) -&amp;gt; FutureObj&amp;lt;&#39;a, Response&amp;gt; { ... }
}&lt;/code&gt;&lt;p&gt;在这种方法中，每个中间件都可以完全控制剩余的请求处理管道。在此接口上构建before/after的中间件构造函数很简单。但使用这种around中间件作为核心接口有一些关键的优势：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在before/after发生的步骤之间传递数据要更简单。&lt;/li&gt;&lt;li&gt;之前的方法强制为每个请求分配FutureObj，但是现在的around风格中间件只需要在执行异步工作或管道其余部分需要的时候再分配新的FutureObj&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;新的接口可以说更简单、更整洁。&lt;/p&gt;&lt;p&gt;Tide也新增了带有自定义中间件的嵌套路由。现在使用nest方法可以将中间件应用于具有公共路由的子路由里。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let mut app = App::new(your_data);

app.at(&quot;/some/prefix&quot;).nest(|r| {
    r.middleware(some_middleware);      // applies to everything under `/some/prefix`
    r.at(&quot;/&quot;).get(prefix_top_endpoint); // matches `/some/prefix`
    r.at(&quot;/foo&quot;).get(foo_endpoint);     // matches `/some/prefix/foo`
});

// no middleware is applied to this route
app.at(&quot;/&quot;).get(index_endpoint);

app.serve(address);&lt;/code&gt;&lt;p&gt;nest方法实现：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;impl&amp;lt;&#39;a, Data&amp;gt; Resource&amp;lt;&#39;a, Data&amp;gt; {
    /// &quot;Nest&quot; a subrouter to the path.
    ///
    /// This method will build a fresh `Router` and give a mutable reference to it to the builder
    /// function. Builder can set up a subrouter using the `Router`. All middleware applied inside
    /// the builder will be local to the subrouter and its descendents.
    pub fn nest(self, builder: impl FnOnce(&amp;amp;mut Router&amp;lt;Data&amp;gt;));
}&lt;/code&gt;&lt;p&gt;另外还增加了一个使用计算值的示例：&lt;a href=&quot;https://github.com/rust-net-web/tide/blob/master/examples/computed_values.rs&quot;&gt;computed_values&lt;/a&gt;&lt;/p&gt;&lt;p&gt;原文中列出了还待解决的一些问题列表，你也可以来参与。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://rust-lang-nursery.github.io/wg-net/2018/11/27/tide-middleware-evolution.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-11-28-51048926</guid>
<pubDate>Wed, 28 Nov 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「官方」Rust 2018年度调查报告</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-11-28-51018048.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51018048&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-938be19e928e7da9e957e2223c134d5f_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;原文：&lt;a href=&quot;https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html&quot;&gt;The Rust Programming Language Blog&lt;/a&gt;  &lt;/blockquote&gt;&lt;p&gt;一年一度的Rust调查报告，今年已经是第三次了。今年这份调查报告首次以多种语言推出，除英语外，一共有14种语言。非英语语言的结果占所有回复的25%。此次报告一共产生&lt;b&gt;5991个回复记录。&lt;/b&gt;在展现最终报告分析结果之前，我们想给所有花时间回应并将你的想法告诉我们的人一个大大的感谢。因为有你们的帮助，Rust才将年复一年地持续完善。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust Users &lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2f3176b25e759da6616cf7d02b7b47a3_r.jpg&quot; data-rawwidth=&quot;662&quot; data-rawheight=&quot;358&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;尽管回复的总数有所增加，但今年Rust用户的比例也同样有所增加。Rust用户占比，与去年的66.9%相比，今年占到了将近3/4。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Time with Rust&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8ad4b0c8522da223ef37ee11d5ee3653_r.jpg&quot; data-rawwidth=&quot;581&quot; data-rawheight=&quot;364&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可以看到，Rust新用户源源不断。在调查时，约有23%的用户使用它3个月或更短的时间。同样，近1/4用户使用Rust至少两年。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0965735bcc5220f9bab6b82b1f96cfe1_r.jpg&quot; data-rawwidth=&quot;583&quot; data-rawheight=&quot;356&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;超过40%的用户在使用Rust不到一个月的时间内感受到了Rust的开发效率，超过70%的人在第一年感到高效。然而，用户之间存在明显差异，超过22%的人尚未对Rust感到富有成效。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-458ce501853b8e7dab39bde1027f8aaf_r.jpg&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;359&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;仔细观察那些使用Rust没有产生效果的用户，只有大约25％的用户只使用Rust不到一个月。 这里面临的挑战是找到帮助用户实现生产力的方法，以免他们陷入困境。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;How much do you use Rust?&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-833a6ad8bc02247a404f3c97def4130c_r.jpg&quot; data-rawwidth=&quot;773&quot; data-rawheight=&quot;484&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;随着整体投入的增加，Rust项目将继续趋向更大规模。 Rust的中到大投入（分别超过10k和10万行代码）。从2016年的8.9％增长到2017年的16％，今年增长到23％。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-349c4c0c97c2a5d9ff1bfddb4b2069b6_r.jpg&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;354&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们也看到了Rust常规使用量的增长。 从去年的17.5％上升到现在Rust每日使用量现已接近用户的四分之一。 总的来说，Rust每周的总使用量从60.8％上升到66.4％。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust expertise&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-580920510a3233043cbe5e6562ced8f7_r.jpg&quot; data-rawwidth=&quot;584&quot; data-rawheight=&quot;358&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust专业知识，不仅仅是一条简单的曲线，还有两个高峰：一个围绕「3」，另一个围绕「7」，这表明用户倾向于认为自己只是初学者或经验丰富，而不是专家。&lt;/p&gt;&lt;p&gt;（原问题已经关闭，忘记3和7指代的是什么了，多半是所有权相关的吧）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6edc8762e09f21e13473b212a60866c1_r.jpg&quot; data-rawwidth=&quot;676&quot; data-rawheight=&quot;422&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust用户普遍认为Enums和Cargo在很大程度上是简单的概念; 其次是迭代器，模块和trait。 接下来是更具挑战性的Trait Bounds和Unsafe概念。 最后，最具挑战性的概念是Macros，Ownership＆Borrowing和Lifetimes。 这些挑战与我们过去几年听到的反馈密切相关，并继续成为持续提高生产力的重点，如NLL和持续的宏观系统改进。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0e2a29bd4ac4069f9edcb2ec191a1e25_r.jpg&quot; data-rawwidth=&quot;581&quot; data-rawheight=&quot;353&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;幽默地说，我们发现Rust实际上并不是用户熟悉的顶级编程语言。 相反，它落后于Python，位落第二。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust toolchain&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ba0faf9866b979fff72213f6e2d24b8f_r.jpg&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;347&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们看到当前稳定版本的用户数量和去年相似。 也许令人惊讶的是，我们仍然看到在其工作流程中使用Nightly编译器的用户数量有所增加。 连续第二年，Nightly使用量持续上升，现在超过56％（高于去年的51.6％）。当被问到为什么他们使用Nightly时，人们回应的原因很多，包括：访问2018版，asm，async / await，clippy，嵌入式开发，Rocket，NLL，proc宏和wasm。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b62e84db6514c0d89f93bb2242908a1e_r.jpg&quot; data-rawwidth=&quot;963&quot; data-rawheight=&quot;584&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;在常规编译器更新期间看到breakage的人的百分比自去年以来保持不变，7.4％的人表示他们经历过breakage。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-12e6593fb098964fdf10c99a92456513_r.jpg&quot; data-rawwidth=&quot;585&quot; data-rawheight=&quot;361&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;breakage通常倾向于需要一些小的修复，尽管有些人报告说有一些中等或主要的修复程序可以升级到下一个稳定的编译器。&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-57454f1484b2df14ec92519b31855957_r.jpg&quot; data-rawwidth=&quot;579&quot; data-rawheight=&quot;318&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;我们再次看到rustup的遥遥领先，它继续保持在Rust安装工具的90％。 Linux发行版以17％的速度遥遥领先。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-61fd8dcfdece8d66555ecaca55a6c529_r.jpg&quot; data-rawwidth=&quot;635&quot; data-rawheight=&quot;393&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;像rustfmt和rustdoc这样的工具有很强的表现力，有很多积极的支持。 接下来是clippy工具 - 尽管用户较少，但其用户喜欢这个工具。 IDE支持工具Rust Language Server和racer得到了积极的支持，但不幸的是，在调查的工具中，产生了一些不喜欢的投票和评论。 bindgen工具具有相对较小的用户群。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust workflow&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5e3b82e9e816ce75b60bfc0527347fa1_r.jpg&quot; data-rawwidth=&quot;589&quot; data-rawheight=&quot;349&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;Linux仍然是Rust开发人员的强大动力，占据了大约80％的Rust开发人员。 Windows的使用量从去年的31％略微增长到今年的34％，这是其连续第二年增长。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-905ace7fb667df117d890671400c64e3_r.jpg&quot; data-rawwidth=&quot;808&quot; data-rawheight=&quot;492&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;Linux和Windows继续作为Rust应用程序的目标而遥遥领先。 其他平台与去年大致相同，但有一个例外：WebAssembly。 这项新技术取得了令人瞩目的增长，从去年的13％增长到今年的24％，几乎翻了一番。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3bb61de3903d1b05cbf199cf0f0e475a_r.jpg&quot; data-rawwidth=&quot;757&quot; data-rawheight=&quot;351&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;领跑两年的Vim现在终于被VSCode击败了，VSCode从33.8％Rust开发者增长到今年的44.4％。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust at work&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fbf36f828e1bf592d3278d888c6546a7_r.jpg&quot; data-rawwidth=&quot;896&quot; data-rawheight=&quot;555&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;Rust继续在商业生产领域缓慢而稳定地增长。 我们现在看到全职和兼职Rust的同比增长，从去年4.4％的全职和16.6％的兼职增长到今年的8.9％的全职和21.2％的兼职 ，全职Rust商业用途增加一倍。 Rust的商业使用总量从Rust用户的21％增长到略高于30％。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-5a92aef27ce4f5f2e6f7265bca1e92ee_r.jpg&quot; data-rawwidth=&quot;588&quot; data-rawheight=&quot;352&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust有更多的空间发展到更多的公司中，超过三分之一的用户报告目前还没有考虑在未来一年中评估Rust。 将近一半的非Rust用户需要公司支持，这表明需要进一步的公司拓展或更多关于Rust的公司信息。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Feeling welcome&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3de641b0bb462331d250d2e70c00e18c_r.jpg&quot; data-rawwidth=&quot;584&quot; data-rawheight=&quot;360&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust社区工作的一个重要部分是确保Rust项目对其用户来说是一个温馨的地方。 新用户应该感到鼓励去探索，分享想法，并且做他们自己。当被问到时，目前Rust用户和非Rust用户都受到欢迎，尽管超过四分之一的回复并不确定。 这些答复中也存在一些区域差异。 例如，对俄罗斯版本调查的回复显示，不受欢迎的感觉比例为4％。 中国大陆的增幅更高，为8％。这里有一个挑战是帮助全球的Rust社区感觉他们是Rust独特的一部分，因为Rust继续在世界更多地区发展壮大。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0625940f2b31368453116034d7abe796_r.jpg&quot; data-rawwidth=&quot;1049&quot; data-rawheight=&quot;377&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust自称为技术人员不足的人数逐年增长缓慢。 该调查还强调了一些挑战，因为女性人数仍然低于编程领域女性的行业平均水平。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Rust Non-Users&lt;/b&gt;&lt;/h2&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-542d0c174b5bd46a97313d4c7fda4a01_r.jpg&quot; data-rawwidth=&quot;588&quot; data-rawheight=&quot;357&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;只有不到50％的人在不到一个月的时间内停止使用Rust。 同样地，大约50％离开Rust的人在停止之前设法使用它超过一个月。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cb651a46dd35f4841b508098a755afee_r.jpg&quot; data-rawwidth=&quot;994&quot; data-rawheight=&quot;607&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;&gt;&lt;p&gt;许多非Rust用户表示他们确实想学习Rust，但有些因素会减慢他们的速度。 其中首先是他们工作的公司本身不使用Rust。 近一半的非Rust用户因缺乏公司支持而受阻。此外，由于Rust的感觉过于可怕或复杂，四分之一的非Rust用户因此而放慢了学习的速度。 改进Rust IDE支持的工作有所帮助（从25％降至16％），尽管我们仍然看到强烈推动非Rust用户提供更好的IDE支持。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;挑战&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;正如我们在过去几年所做的那样，我们询问您对Rust可以有哪方面改进。今年，我们在这个反馈中看到了一些熟悉的主题以及一些新的主题。今年十大主题是：&lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;需要更好的库支持&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;更好的IDE体验&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;需要更广泛地采用Rust&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;更丰富的工具和生态系统支持&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;改善学习曲线&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;需要重要的语言功能和板条箱才能稳定和支持&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;支持异步编程&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;支持GUI开发&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;更好的文档&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;改进编译时间&lt;/b&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;b&gt;今年，GUI开发支持是不断增长的新需求，表明Rust不仅在服务器上继续增长，而且人们感觉需要延伸到应用程序开发。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;“加强Rust的推广，很多人还不知道它”&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;此回复提醒我们虽然Rust在某些圈子中可能是众所周知的，但它仍有成长空间，在许多科技界，Rust可能还不为人所熟知。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;“专注于采纳教程/书籍/新手经验，将在未来几年带来好处。”&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;除了延伸内容之外，更广泛的文档将帮助更广泛的受众。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;“开发人员工具的稳定性和成熟度，使得更容易获得工作设置和调试应用程序”&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;许多人对IDE支持发表了评论，不仅指出了RLS中的不稳定性或不准确性，而且还需要更强大的IDE支持，涵盖更多领域，比如更容易调试。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;“生态系统和库的成熟。拥有一个良好的“标准”库生态系统是该语言未来的关键”&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;一个共同的主题仍然是需要推动库完成并增加用户可以使用的“标准”库集。一些评论指出，这不是维护者的错，他们已经在努力编写和发布crate，但通常更多的公司需要参与并提供商业支持。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;b&gt;“开发体验和可发现性” ”&lt;/b&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;b&gt;有些人指出，开发体验与更丰富的文档齐头并进，认为这些不是单独的概念，而是应该以统一的方法解决。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;期待&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;今年是最强的调查。它不仅是最大的社区调查，也是第一个涵盖英语以外语言的调查。 Rust继续稳步增长，并且随之而来的是，它的优势和挑战都被引入更广泛的受众。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;我们期待在2019年的规划中使用您的反馈，并且很期望看到接下来我们能把Rust带向何方。&lt;/b&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-11-28-51018048</guid>
<pubDate>Wed, 28 Nov 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
