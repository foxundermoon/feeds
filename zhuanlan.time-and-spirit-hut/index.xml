<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>时光与精神小屋</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Thu, 27 Dec 2018 13:51:07 +0800</lastBuildDate>
<item>
<title>如何选择编程语言？</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-26-53358012.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/53358012&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-40dda6fe7127a6735d526f5384ca4768_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;前言&lt;br&gt;&lt;br&gt;做为一名程序员或准程序员，总会出现这个需求：如何选择一门编程？其实这个问题等价于，该如何投资自己的时间和精力？一个人的精力是有限的，大家肯定希望投入和产出是成正比的。那么有什么比较科学的方法指导自己呢？&lt;br&gt;&lt;br&gt;今天上午我看到一篇来自于斯坦福商学院一名学生Nnamdi写的文章：&lt;a href=&quot;https://whoisnnamdi.com/the-growth-share-matrix-of-software-development/&quot;&gt;《软件开发的增长矩阵共享模型》&lt;/a&gt;。他在文章中使用四象限法对当下众多编程语言做了一次分析。而且他使用的样本数据是来自于StackoverFlow在2017和2018年的年度开发者调查报告，大约有超10w开发者参与调查。我感觉他的分析是有一定科学道理的，也许你可以在选择编程语言时，用它做为一项参考。&lt;br&gt;&lt;br&gt;本文并非翻译，只是对Nnamdi文章中模型结果的思考。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;先看一下他文章中得出的分析结果模型。&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0e4da1c931a3b96b3e28ca9c200bc415_r.jpg&quot; data-caption=&quot;软件开发中的增长共享矩阵&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1388&quot; data-rawheight=&quot;1278&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0e4da1c931a3b96b3e28ca9c200bc415&quot; data-watermark-src=&quot;v2-28f6d2f3849db12c014ff49c96e44d3b&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;四象限分析法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;为了搞懂这个模型的意义，先来了解下什么是四象限分析法。&lt;/p&gt;&lt;p&gt;四象限分析法，也叫&lt;b&gt;波士顿矩阵(BCG Matrix)。&lt;/b&gt;波士顿矩阵又称市场增长率-相对市场份额矩阵、BCG矩阵、波士顿咨询集团法、产品系列结构管理法等。波士顿咨询集团（Boston Consulting Group）在上世纪70年代开发了此方法，用于指导公司高层制定未来发展战略。&lt;/p&gt;&lt;p&gt;&lt;b&gt;模型介绍&lt;/b&gt;&lt;/p&gt;&lt;p&gt;　　BCG矩阵区分出4种业务组合。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-609418f20961be58f199f38173e3679b_r.jpg&quot; data-caption=&quot;BCG矩阵模型&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1210&quot; data-rawheight=&quot;1210&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-609418f20961be58f199f38173e3679b&quot; data-watermark-src=&quot;v2-e31eef587ecbcf4b6a6f15a3d3ce4abb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;blockquote&gt;&lt;b&gt;（1）明星型业务（Stars，指高增长、高市场份额）&lt;/b&gt;&lt;br&gt;　　这个领域中的产品处于快速增长的市场中并且占有支配地位的市场份额，但也许会或也许不会产生现金流，这取决于新工厂、设备和产品开发对投资的需要量。明星型业务是由&lt;b&gt;问题型业务&lt;/b&gt;继续投资发展起来的，可以视为高速成长市场中的领导者，它将成为公司未来的&lt;b&gt;现金牛&lt;/b&gt;业务。&lt;br&gt;&lt;b&gt; （2）问题型业务（Question Marks，指高增长、低市场份额）&lt;/b&gt;&lt;br&gt;　　处在这个领域中的是一些投机性产品，带有较大的风险。这些产品可能利润率很高，但占有的市场份额很小。这往往是一个公司的新业务。为发展问题业务，公司必须建立工厂，增加设备和人员，以便跟上迅速发展的市场，并超过竞争对手，这些意味着大量的资金投入。“问题”非常贴切地描述了公司对待这类业务的态度，因为这时公司必须慎重回答“是否继续投资，发展该业务？”这个问题。只有那些符合企业发展长远目标、企业具有资源优势、能够增强企业核心竞争力的业务才得到肯定的回答。&lt;br&gt;　　如何选择问题型业务是用BCG矩阵制定战略的重中之重，也是难点，这关乎企业未来的发展。&lt;br&gt;&lt;b&gt;（3）现金牛业务（Cash cows，指低增长、高市场份额）&lt;/b&gt;&lt;br&gt;　　处在这个领域中的产品产生大量的现金，但未来的增长前景是有限的。这是成熟市场中的领导者，它是企业现金的来源。由于市场已经成熟，企业不必大量投资来扩展市场规模，同时作为市场中的领导者，该业务享有规模经济和高边际利润的优势，因而给企业带来大量现金流。企业往往用现金牛业务来支付帐款并支持其他三种需大量现金的业务。&lt;br&gt;&lt;b&gt;（4）瘦狗型业务（Dogs，指低增长、低市场份额）&lt;/b&gt;&lt;br&gt;　　这个剩下的领域中的产品既不能产生大量的现金，也不需要投入大量现金，这些产品没有希望改进其绩效。一般情况下，这类业务常常是微利甚至是亏损的，瘦狗型业务存在的原因更多的是由于感情上的因素，虽然一直微利经营，但象人养了多年的狗一样恋恋不舍而不忍放弃。&lt;/blockquote&gt;&lt;p&gt;　　Why BCG Matrix？BCG矩阵的精髓在于把战略规划和资本预算紧密结合了起来，把一个复杂的企业行为用两个重要的衡量指标来分为四种类型，用四个相对简单的分析来应对复杂的战略问题。该矩阵帮助多种经营的公司确定哪些产品宜于投资，宜于操纵哪些产品以获取利润，宜于从业务组合中剔除哪些产品，从而使业务组合达到最佳经营成效。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;编程语言在四象限中的位置&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;现在来看看Nnamdi文章总结出的模型中提到编程语言，分别站在哪个象限。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第一象限（Star），明星象限。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;包含的语言有TypeScript、Go、Python、Ruby。按BCG矩阵模型来分析，在这个象限里的这些语言，都是明星语言。&lt;/p&gt;&lt;blockquote&gt;Python这两年人气飙升，简直就是国民语言。让很多人产生一种错觉，好像所有公司都在用Python，离不开Python。但它其实是伴随最近两三年数据分析、机器学习和深度学习领域升温而火。Python有很多易于使用的库和开源项目，它的语法也相对其他语言更加简单，像Jupyter notebooks 这种交互式可复制的计算环境越来越受数据工作组和科学家欢迎。&lt;br&gt;&lt;br&gt;Ruby，基本上是和Python年龄相仿的语言，但其成名比较晚，所以不如Python那么普及。前十年创业大潮飞速发展，Ruby随着Ruby on Rails框架而声名鹊起，然而，现在在国外市场占有率还在升高，但是在国内就有点「冷」。但Ruby并没有「死」。现在国内很多公司还在用Ruby，有大量职位空缺，然而找不到相应的开发者。Ruby已经进入了成熟期。&lt;br&gt;&lt;br&gt;Go，最近几年增长飞快，市场也逐渐有了占有率。它简化了编写并发代码的过程，这得益于Google内部的Go语言团队，他们认为未来代码会越来越庞大，多核处理和网络应用的开发成本会越来越高，所以Go就诞生了。&lt;br&gt;&lt;br&gt;Typescript和Javascript有很强的重合性，但是具有该语言经验的开发人员是一个相对独立于Javascript开发者之外的群体。它的特色是强类型语言。其实从2010年开始出现的新语言，基本都是强类型。&lt;/blockquote&gt;&lt;p&gt;作为明星象限的语言，它很有潜力成为未来为你产生「现金流」的语言，所以，如果现在还不会这些语言，那么就选一门好学学吧。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第二象限（Question），问题象限。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;该象限中，包含Rust、Haskell、R、Scala等语言。&lt;/p&gt;&lt;blockquote&gt;首当其冲的就是Rust语言。增长率高的可怕，但是市场占有率现在还比较低。Rust在技术上是一种通用型系统语言，你可以用它实现操作系统、嵌入式、网络服务、Web应用、游戏等等。它经常被拿来和C++比较，因为它们的语法有相似性。Rust在Stackoverflow已经连续三年成为开发者最喜欢的语言了。Rust的特色是，内存安全、并发安全和高性能。&lt;br&gt;&lt;br&gt;Scala，常常被视为下一代Java。它结合了面向对象和函数式两种范式，非常适合并行和分布式。但是和Go、Rust相比，它的增长率明显变得缓慢了。虽然图中没有Kotlin，但Scala想超越Java的目标，现在可能会由Kotlin替它实现了。&lt;br&gt;&lt;br&gt;R受欢迎的原因和Python比较相似，在数据科学领域比较受欢迎。但是现在随着Julia的正式发布，可能将来增长率会变缓。&lt;br&gt;&lt;br&gt;Haskell，是一门纯函数式语言，属于学术型语言。功能虽然很强大，但也可能限制其适用性。Rust语言借鉴了Haskell很多东西，但Rust实用性比Haskell更强。虽然现在Haskell还有很多狂热粉，有一定增长率，但很难说他们这种热情可以持续多久。&lt;/blockquote&gt;&lt;p&gt;这些语言之所以被归为问题象限，是因为没有人真正知道未来这些语言能发挥多大作用，占什么位置。但它们也是有可能在未来为你产生「现金流」的语言。依照目前Rust的增长率，极有可能在未来3到5年内，落入到明星象限中。这些语言如果你还不会，那么选一门学吧。如果暂时没有精力，那么可以放到后面考虑，但一定要关注它们。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第三象限（Dogs），瘦狗象限。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;落入这个象限的语言包括VB、matlab、Perl等。虽然微软在使劲给VB续命，但还是挡不住它生命逝去的速度。虽然还有一定的增长，但实际上在2018年已经失去了市场份额。这些语言就不过多介绍了。只有在你万不得已的情况下，你再去选择学习吧。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第四象限（Cash Cows），现金牛象限&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;落入这个象限的语言，都是支撑大部分开发者生存的语言，开发者要靠这些语言支付账单。包括Java、Javascript、PHP、SQL、C/Cpp、Swift等。这些语言基本都失去了增长率，但它们还占有大部分的市场份额。这些语言分别占据了Web前端、后端、数据库、系统、移动端等领域。你要手头拮据，那么你的第一需求是要找一份工作，那么可以考虑学习它们中的一门。但也不是必须的，因为这并不意味着你学习明星象限或问题型象限内的语言就找不到工作。这只是意味着，它们的工作岗位比较多而已，但是工作岗位多，意味着竞争也很多，其实单按找工作来考虑的话，明星象限和现金牛象限是差不多的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;结语&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;该文的目的是给你提供一个相对比较科学的视角，让你可以批判性地思考，如何选择一门编程语言这个问题。其实，编程语言这种事，就算你选错了，也没有关系。因为背后都是相通的。作为程序员，多学几门编程语言永远不会亏。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;参考资料：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://wiki.mbalib.com/wiki/%E6%B3%A2%E5%A3%AB%E9%A1%BF%E7%9F%A9%E9%98%B5&quot;&gt;波士顿矩阵 - MBA智库百科&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-26-53358012</guid>
<pubDate>Wed, 26 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>如何为Rust语言做贡献</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-25-53247517.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/53247517&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-818d6382f325e4c72dd189c455c57d0c_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;本文为之前我撰写的付费阅读文章之一，今天公开，祝读者们圣诞快乐！&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;本文基于macOSX平台，通过对Rust 1.32 Nightly版本中rustdoc的一个ICE问题进行复盘，分析并记录整个Bug修复的过程。主要目的是，通过这个过程，来学习如何给Rust做贡献。&lt;/p&gt;&lt;p&gt;（阅读时间：17m）&lt;/p&gt;&lt;ol&gt;&lt;li&gt;缘起&lt;/li&gt;&lt;li&gt;Rust本地调试环境准备&lt;/li&gt;&lt;li&gt;ICE问题分析&lt;/li&gt;&lt;li&gt;调试代码&lt;/li&gt;&lt;li&gt;提交PR说明&lt;/li&gt;&lt;/ol&gt;&lt;hr&gt;&lt;h2&gt;缘起：&lt;/h2&gt;&lt;p&gt;在几周前，我发现了一个rustdoc的&lt;a href=&quot;https://github.com/rust-lang/rust/issues/55723&quot;&gt;ICE(issue 55723)&lt;/a&gt;，提交给了官方。但是官方指派修复此Bug的开发者QuietMisdreavus 难以复现该Bug。我本来以为Bug是因为多字节字符（比如全角符号之类）引起的，然而经过我仔细的测试，发现问题的根源在于尾随的「空格」。 &lt;/p&gt;&lt;p&gt;引起ICE错误的代码示例：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;/// ## For example:
///  
///  （arr[i]）
pub fn test_ice() {
    unimplemented!();
}&lt;/code&gt;&lt;p&gt;&lt;i&gt;注意：问题出自于上面代码中文档注释第二行，在&lt;code class=&quot;inline&quot;&gt;///&lt;/code&gt;后面实际上还有两个尾随空格。&lt;/i&gt; &lt;/p&gt;&lt;p&gt;也可以通过&lt;a href=&quot;https://github.com/ZhangHanDong/test_ice&quot;&gt;GitHub - ZhangHanDong/test_ice: reproduce ice:   issues-55723(https://github.com/rust-lang/rust/issues/55723)&lt;/a&gt;来查看此ICE复现的代码。&lt;/p&gt;&lt;p&gt;起初，QuietMisdreavus 看了test_ice，依旧没有发现问题。过了两天，他顿悟了，原来是因为他用的代码编辑器是Vim。当他往Vim里复制粘贴我的测试代码时，Vim可能会对代码中尾随空格做了某种处理，以至于他还是难以复现该Bug。（我终于找到一个黑Vim的理由了吗？）&lt;/p&gt;&lt;p&gt;在他纳闷的同时，我也开始对这个Bug进行了调查。最初，根据错误提示，我定位了到 &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/src/libsyntax/source_map.rs#L827&quot;&gt;libsyntax/source_map.rs#L827&lt;/a&gt;的&lt;code class=&quot;inline&quot;&gt;bytepos_to_file_charpos&lt;/code&gt;方法。具体报错的代码是该方法中第842行代码，如下所示：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// We should never see a byte position in the middle of a
// character
assert!(bpos.to_u32() &amp;gt;= mbc.pos.to_u32() + mbc.bytes as u32);&lt;/code&gt;&lt;p&gt;Libsyntax/source_map，是Rust用来跟踪（track）单个crate中所有文件的源码位置（字节位置），并将其存储在&lt;code class=&quot;inline&quot;&gt;Span&lt;/code&gt;中，可以在需要的时候转换为代码的行和列。比如在出错的时候，展示出错代码的行和列。&lt;/p&gt;&lt;p&gt;而这行代码，不管它的上下文，只看注释就应该明白：字节的位置，不可能跑到字符内部。比如，一个字母&lt;code class=&quot;inline&quot;&gt;a&lt;/code&gt;，它就一个字节，位置不可能是半个字节。再比如，一个多字节字符&lt;code class=&quot;inline&quot;&gt;（&lt;/code&gt;，占3个字节，假如它的起始位置是0，那么，source_map在计算源码位置的时候，只能是，&lt;code class=&quot;inline&quot;&gt;0, 1-2-3, 4&lt;/code&gt;，如果位置在&lt;code class=&quot;inline&quot;&gt;[1,2,3]&lt;/code&gt;范围内，则会出错。&lt;/p&gt;&lt;p&gt;而我现在碰到的错，显然就是这个问题：&lt;b&gt;sorce_map在计算源码位置的时候，错误地把位置算到了多字节字符内部。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;知道了错误的原因，但如何修复呢？虽然是这行出错了，但Bug的根源不一定是这里。&lt;/p&gt;&lt;p&gt;于是我下载了Rust源码，准备开始调试。但是在本地编译Rust的时候，遇到了很多编译错误。一一搞定了，但是最后一个编译错误我怎么也搞不定，就这样过了三天，然后发现QuietMisdreavus 已经提交了修复该问题的PR。于是就完美的错过了这次成为Rust贡献者的机会。&lt;/p&gt;&lt;p&gt;但是，我依然没有停下我的步伐。终于，让我发现本地编译Rust失败的原因，恰好那天机器上安装了python，环境变量设置有点问题，也许是覆盖了cc连接器的查找路径。具体修复可以参考此issues：&lt;a href=&quot;https://github.com/rust-lang/rust/issues/55875&quot;&gt;build rust from source fail on macos 10.13.6 · Issue #55875 · rust-lang/rust · GitHub&lt;/a&gt;&lt;/p&gt;&lt;p&gt;终于，Rust编译搞定了。接下来，就让我复盘一下该ICE问题出现的整个过程，与此同时，记录并模拟一个修复Bug的过程（虽然不是我修复的）。主要目的是，通过这个过程，来学习如何给Rust做贡献。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Rust本地调试环境准备&lt;/h2&gt;&lt;p&gt;首先，在本地创建一个文件夹，并下载Rust源码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;$ git clone https://github.com/rust-lang/rust.git&lt;/code&gt;&lt;p&gt;下载完以后，进入到Rust源码目录，执行下面命令：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ ./configuration&lt;/code&gt;&lt;p&gt;该命令会执行&lt;code class=&quot;inline&quot;&gt;src/bootstrap/configure.py&lt;/code&gt;脚本，在项目根目录下生成&lt;code class=&quot;inline&quot;&gt;config.toml&lt;/code&gt;文件。所以，在你的本地，也需要安装Python2.7 。&lt;/p&gt;&lt;p&gt;然后需要修改此&lt;code class=&quot;inline&quot;&gt;config.toml&lt;/code&gt;文件。下面给出修改参考：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;compiler-docs = false
submodules = false
configure-args = []
debug = true
codegen-units = 0
debug-assertions = true
debuginfo = true
debuginfo-lines = true
default-linker = &quot;cc&quot;
channel = &quot;nightly&quot;&lt;/code&gt;&lt;p&gt;具体什么意思，可以参考&lt;code class=&quot;inline&quot;&gt;config.toml&lt;/code&gt;文件中的注释。&lt;/p&gt;&lt;p&gt;接下来就可以开始构建Rust了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;使用x.py&lt;/b&gt;&lt;/p&gt;&lt;p&gt;构建Rust使用&lt;code class=&quot;inline&quot;&gt;x.py&lt;/code&gt;是最方便的。它是内置的编排工具，可以用来构建文档、运行测试和编译rustc。这些工作之前是makefile，现在不需要了。&lt;/p&gt;&lt;p&gt;&lt;b&gt;构建Rust的三个阶段&lt;/b&gt;&lt;/p&gt;&lt;p&gt;因为Rust是一个自举的编译器，所以，可以通过旧的编译器来构建最新的版本。所以一般是分阶段来完成：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;Stage0&lt;/b&gt;，下载最新beta版的编译器，这些x.py会自动完成。你也可以通过修改配置文件来使用其他版本的Rust。&lt;/li&gt;&lt;li&gt;&lt;b&gt;Stage1&lt;/b&gt;，使用Stage0阶段下载的beta版编译器来编译从Git仓库里下载的代码。最终生成Stage1版编译器。但是为了对其优化，还需要进行下一阶段。理论上，Stage1和Stage2编译器在功能上是相同的，但实际上还有些细微的差别。&lt;/li&gt;&lt;li&gt;&lt;b&gt;Stage2&lt;/b&gt;，用Stage1版编译器继续对源码进行编译，以便生成Stage2版编译器。&lt;/li&gt;&lt;li&gt;&lt;b&gt;Stage3&lt;/b&gt;，这个阶段是可选的。这是为了对编译器进行健全性检查。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;官方推荐的构建流程如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;./x.py check&lt;/code&gt; ，先执行此命令，检查编译器是否可以构建。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;./x.py build -i --stage 1&lt;/code&gt;，进行Stage 0和Stage 1阶段的构建，最终构建完成Stage1的编译器。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;./x.py build -i --stage 2  --keep-stage 1&lt;/code&gt;，使用 &lt;code class=&quot;inline&quot;&gt;--keep-stage 1&lt;/code&gt;参数，在Stage1基础上进行增量式构建，最终编译出Stage2的编译器。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;得到这个编译器，在本地就可以使用了。然后将其加到Rustup工具链中。&lt;/p&gt;&lt;p&gt;&lt;b&gt;加入本地Rustup工具链&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;$ rustup toolchain link local build/x86_64-apple-darwin/stage2&lt;/code&gt;&lt;p&gt;语法为：&lt;code class=&quot;inline&quot;&gt;rustup toolchain link &amp;lt;name&amp;gt; build/&amp;lt;host-triple&amp;gt;/stage2&lt;/code&gt;，其中，&lt;code class=&quot;inline&quot;&gt;&amp;lt;host-triple&amp;gt;&lt;/code&gt;就是上面示例中的&lt;code class=&quot;inline&quot;&gt;x86_64-apple-darwin&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;到此为止，准备工作就已经做好了。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;ICE问题分析&lt;/h2&gt;&lt;p&gt;前面已经分析得出，问题的缘由是：&lt;b&gt;sorce_map在计算源码位置的时候，错误地把位置算到了多字节字符内部。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;但应该不是这个libsyntax库计算出的问题。官方开发者QuietMisdreavus在我发布的issues中指出，他猜测原因出在「计算Markdown中内部链接」时出现了错误。因为Rust的文档注释支持Markdown功能。为了更好地提升Rust项目中模块之间的相关性，官方提出了&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md&quot;&gt;rfcs/1946-intra-rustdoc-links.md at master · rust-lang/rfcs · GitHub&lt;/a&gt;，在Markdown中支持识别内部文件模块之间链接的功能。如果识别正确，则正常生成文档。如果识别错误，则提示一个警告。&lt;/p&gt;&lt;p&gt;比如，上面test_ice的文档注释代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;/// ## For example:
///  
///  （arr[i]）
pub fn test_ice() {
    unimplemented!();
}&lt;/code&gt;&lt;p&gt;应该生成下面的警告：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;warning: `[i]` cannot be resolved, ignoring it...
 --&amp;gt; src/test/rustdoc-ui/intra-link-span-ice-55723.rs:3:12
  |
3 | /// （array[i]）
  |             ^ cannot be resolved, ignoring
  |
  = note: #[warn(intra_doc_link_resolution_failure)] on by default
  = help: to escape `[` and `]` characters, just add &#39;\&#39; before them like `\[` or `\]`&lt;/code&gt;&lt;p&gt;因为这里&lt;code class=&quot;inline&quot;&gt;[i]&lt;/code&gt;并不是一个合法的Markdown链接。&lt;/p&gt;&lt;p&gt;但是现在，出现了ICE：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;note: Run with `RUST_BACKTRACE=1` for a backtrace.

error: internal compiler error: unexpected panic

note: the compiler unexpectedly panicked. this is a bug.

note: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports&lt;/code&gt;&lt;p&gt;那么现在，问题大概是发生在：&lt;i&gt;Rust识别出文档注释中&lt;code class=&quot;inline&quot;&gt;[i]&lt;/code&gt;不是Markdown链接，然后要抛出警告的时候，计算错了源码位置。&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;来看看相关源码：&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在&lt;code class=&quot;inline&quot;&gt;src/librustdoc/passes/collect_intra_doc_links.rs&lt;/code&gt;文件中的&lt;code class=&quot;inline&quot;&gt;resolution_failure&lt;/code&gt;方法，就是用来处理文档注释中链接识别失败后的情况。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn resolution_failure( ... ) {
  // ...
    if dox.lines().count() == code_dox.lines().count() {
        let line_offset = dox[..link_range.start].lines().count();
        // The span starts in the `///`, so we don&#39;t have to account for the leading whitespace
        let code_dox_len = if line_offset &amp;lt;= 1 {
                doc_comment_padding
            } else {
                // The first `///`
                doc_comment_padding +
                    // Each subsequent leading whitespace and `///`
                    code_dox.lines().skip(1).take(line_offset - 1).fold(0, |sum, line| {
                   sum + doc_comment_padding + line.len() - line.trim().len()
             })
        };
        // Extract the specific span
        let sp = sp.from_inner_byte_pos(
                link_range.start + code_dox_len,
                link_range.end + code_dox_len,
        );
  // ...  
}&lt;/code&gt;&lt;p&gt;Rust处理文档注释，大致分成两部分来处理：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;文档注释符号&lt;code class=&quot;inline&quot;&gt;///&lt;/code&gt;，独立出来处理，代码里叫做&lt;code class=&quot;inline&quot;&gt;code_dox&lt;/code&gt;&lt;/li&gt;&lt;li&gt;注释的内容，独立处理，代码里叫做&lt;code class=&quot;inline&quot;&gt;dox&lt;/code&gt;。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如下图所示：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9a6bdf4c17e62020f536cb11025c4c7e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1992&quot; data-rawheight=&quot;1026&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-9a6bdf4c17e62020f536cb11025c4c7e&quot; data-watermark-src=&quot;v2-eb554a8a6e6c4a1cb60dad49d2b64179&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这样分开处理是理所当然的，因为&lt;code class=&quot;inline&quot;&gt;///&lt;/code&gt;并不是Markdown内容。&lt;/p&gt;&lt;p&gt;在&lt;code class=&quot;inline&quot;&gt;resolution_failure&lt;/code&gt;方法中，需要计算非法链接出现的位置。那怎么计算呢？就是把code_dox的总长度计算出来，也就是行数乘以3。但为什么上面代码要写那么长呢？因为有可能在&lt;code class=&quot;inline&quot;&gt;///&lt;/code&gt;前面还会有空格。&lt;/p&gt;&lt;p&gt;其中每一行&lt;code class=&quot;inline&quot;&gt;///&lt;/code&gt;就会生成一个&lt;code class=&quot;inline&quot;&gt;span&lt;/code&gt;,最终，在计算位置的时候，通过&lt;code class=&quot;inline&quot;&gt;link_range.start + code_dox_len&lt;/code&gt;来定位非法链接的位置。&lt;/p&gt;&lt;p&gt;那么ICE的问题，极有可能是这个位置，计算到了多字节字符&lt;code class=&quot;inline&quot;&gt;（&lt;/code&gt;或&lt;code class=&quot;inline&quot;&gt;）&lt;/code&gt;的内部。&lt;/p&gt;&lt;p&gt;那么接下来，调试一下代码就能确定是不是这里的问题。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;调试代码&lt;/h2&gt;&lt;p&gt;Rust中提供了&lt;code class=&quot;inline&quot;&gt;debug!&lt;/code&gt;宏来输出Debug信息。所以，修改&lt;code class=&quot;inline&quot;&gt;resolution_failure&lt;/code&gt;方法中的代码，并加上Debug信息：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;if dox.lines().count() == code_dox.lines().count() {
            let line_offset = dox[..link_range.start].lines().count();
            debug!(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;line_offset&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;handong!!! {:?} &quot;, line_offset);
            // The span starts in the `///`, so we don&#39;t have to account for the leading whitespace
            let code_dox_len = if line_offset &amp;lt;= 1 {
                doc_comment_padding
            } else {
                // The first `///`
                doc_comment_padding +
                    // Each subsequent leading whitespace and `///`
                    code_dox.lines().skip(1).take(line_offset - 1).fold(0, |sum, line| {
                        debug!(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;handong!!! {:?}, {:?}, {:?}, {:?}, {:?} &quot;, sum, line, doc_comment_padding, line.len(), line.trim().len());
                        sum + doc_comment_padding + line.len() - line.trim().len()
                    })
            };
            debug!(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;handong!!! code_dox_len: {:?} &quot;, code_dox_len);
            debug!(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;handong!!! link_range.start: {:?} &quot;, link_range.start);
            debug!(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;handong!!! link_range.end: {:?} &quot;, link_range.end);
            // Extract the specific span
            let sp = sp.from_inner_byte_pos(
                link_range.start + code_dox_len,
                link_range.end + code_dox_len,
            );&lt;/code&gt;&lt;p&gt;修改完以后，需要重新编译。执行下面的命令：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;$ ./x.py build -i --stage 2  --keep-stage 1&lt;/code&gt;&lt;p&gt;直接进行第二阶段编译即可。&lt;/p&gt;&lt;p&gt;编译完毕以后，在&lt;code class=&quot;inline&quot;&gt;src/test/rustdoc-ui/&lt;/code&gt;目录（这下面有很多intra-link相关的测试）下加入&lt;code class=&quot;inline&quot;&gt;intra-link-span-ice-55732.rs&lt;/code&gt;文件，并把测试代码加进去：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;/// ## For example:
///  
///  （arr[i]）
pub fn test_ice() {
    unimplemented!();
}&lt;/code&gt;&lt;p&gt;然后执行下面命令：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;$ RUST_LOG=debug rustdoc +local src/test/rustdoc-ui/intra-link-span-ice-55723.rs&lt;/code&gt;&lt;p&gt;该命令会打印出Rustc编译过程中所有的Debug信息，一开始我没想到会有那么多的Debug信息，导致我的终端都无响应了。后来，我又看编译器文档，发现可以指定输出特定模块的Debug信息，就是使用下面命令：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;$ RUST_LOG=rustdoc::passes rustdoc +local src/test/rustdoc-ui/intra-link-span-ice-55723.rs&lt;/code&gt;&lt;p&gt;因为修改的源码位置是&lt;code class=&quot;inline&quot;&gt;librustdoc/passes/&lt;/code&gt;目录下，所以给&lt;code class=&quot;inline&quot;&gt;RUST_LOG&lt;/code&gt;赋予&lt;code class=&quot;inline&quot;&gt;rustdoc::passes&lt;/code&gt;。注意，使用的是&lt;code class=&quot;inline&quot;&gt;rustdoc&lt;/code&gt;命令，加上&lt;code class=&quot;inline&quot;&gt;local&lt;/code&gt;。local是Rustup配置的本地工具链，也就是Stage2版本的编译器。&lt;/p&gt;&lt;p&gt;然后就可以看到输出的Debug信息，如下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;DEBUG 2018-12-03T11:25:17Z: rustdoc::passes::collect_intra_doc_links:  dox : ======= &quot; ## For example:\n  \n  （arr[i]）&quot;
DEBUG 2018-12-03T11:25:17Z: rustdoc::passes::collect_intra_doc_links: &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;line_offset&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;handong!!! 3 
DEBUG 2018-12-03T11:25:17Z: rustdoc::passes::collect_intra_doc_links: &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;handong!!! 0, &quot;///  &quot;, 3, 5, 3 
DEBUG 2018-12-03T11:25:17Z: rustdoc::passes::collect_intra_doc_links: &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;handong!!! 5, &quot;///  （arr[i]）&quot;, 3, 17, 17 
DEBUG 2018-12-03T11:25:17Z: rustdoc::passes::collect_intra_doc_links: &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;handong!!! code_dox_len: 11 
DEBUG 2018-12-03T11:25:17Z: rustdoc::passes::collect_intra_doc_links: &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;handong!!! link_range.start: 29 
DEBUG 2018-12-03T11:25:17Z: rustdoc::passes::collect_intra_doc_links: &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;handong!!! link_range.end: 30 
thread &#39;&amp;lt;unnamed&amp;gt;&#39; panicked at &#39;assertion failed: bpos.to_u32() &amp;gt;= mbc.pos.to_u32() + mbc.bytes as u32&#39;, libsyntax/source_map.rs:842:17
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: internal compiler error: unexpected panic
note: the compiler unexpectedly panicked. this is a bug.
note: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports&lt;/code&gt;&lt;p&gt;看得出来，根据上面输出的信息，最终判断出错链接的位置是：&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;11 + 29 = 40&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这个位置是字节的位置，大家可以数一下测试文件中文档字节位置40是在哪里。注意，换行在Rust中会被按一个空白符来计算。注意，这里面的多字节字符是3位。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-849df13f913622d1d73a88f2bbd56984_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1738&quot; data-rawheight=&quot;700&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-849df13f913622d1d73a88f2bbd56984&quot; data-watermark-src=&quot;v2-f771424c054178bfb338134b333c8c47&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如图，第40个字符正好是&lt;code class=&quot;inline&quot;&gt;]&lt;/code&gt;，那么最终位置恰好识别为&lt;code class=&quot;inline&quot;&gt;41&lt;/code&gt;，就正好落在了多字节字符&lt;code class=&quot;inline&quot;&gt;）&lt;/code&gt;的内部，从而引起错误。&lt;/p&gt;&lt;p&gt;那么这个计算失误是怎么引起来的呢。再回到代码中：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;sum + doc_comment_padding + line.len() - line.trim().len()&lt;/code&gt;&lt;p&gt;关键是这行代码。最后的&lt;code class=&quot;inline&quot;&gt;line.trim()&lt;/code&gt;方法，会将整行字符串头和尾两边的空格或制表符、换行符都去掉。这就导致文档注释第二行后面的空格，被trim给剪掉了。&lt;/p&gt;&lt;p&gt;前面说了，Rust计算位置分为两个部分。第一个部分是code_doc，也就是前面&lt;code class=&quot;inline&quot;&gt;///&lt;/code&gt;的总长度，这个是没问题的。但是把后面的空格个剪掉了，就导致计算markdown文档内容（Dox）的位置，少了两格。&lt;/p&gt;&lt;p&gt;这就是问题的原因了。&lt;/p&gt;&lt;p&gt;所以修复起来也比较简单，就是把trim方法，改成trim_start，只剪掉前面的空格，这样操作，不会影响Dox的计算，也不会影响到code_dox的计算。但官方开发者QuietMisdreavus说可能会有其他问题，这个就等他发新的issues吧。&lt;/p&gt;&lt;p&gt;现在把trim方法改成trim_start方法，然后重新编译Stage2版编译器，并执行rustdoc命令&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;$ ./x.py build -i --stage 2  --keep-stage 1 
$  RUST_LOG=rustdoc::passes rustdoc +local src/test/rustdoc-ui/intra-link-span-ice-55723.rs&lt;/code&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;DEBUG 2018-12-03T11:48:33Z: rustdoc::passes::collect_intra_doc_links:  dox : ======= &quot; ## For example:\n  \n  （arr[i]）&quot;
DEBUG 2018-12-03T11:48:33Z: rustdoc::passes::collect_intra_doc_links: &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;line_offset&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;handong!!! 3 
DEBUG 2018-12-03T11:48:33Z: rustdoc::passes::collect_intra_doc_links: &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;handong!!! 0, &quot;///  &quot;, 3, 5, 5 
DEBUG 2018-12-03T11:48:33Z: rustdoc::passes::collect_intra_doc_links: &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;handong!!! 3, &quot;///  （arr[i]）&quot;, 3, 17, 17 
DEBUG 2018-12-03T11:48:33Z: rustdoc::passes::collect_intra_doc_links: &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;handong!!! code_dox_len: 9 
DEBUG 2018-12-03T11:48:33Z: rustdoc::passes::collect_intra_doc_links: &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;handong!!! link_range.start: 29 
DEBUG 2018-12-03T11:48:33Z: rustdoc::passes::collect_intra_doc_links: &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;handong!!! link_range.end: 30 
*warning: `[i]` cannot be resolved, ignoring it...*
 *--&amp;gt;*src/test/rustdoc-ui/intra-link-span-ice-55723.rs:3:11
  *|*
*3* *|*///  （arr[i]）
  *|*           *^* *cannot be resolved, ignoring*
  *|*
  *= note*: #[warn(intra_doc_link_resolution_failure)] on by default
  *= help*: to escape `[` and `]` characters, just add &#39;\&#39; before them like `\[` or `\]`&lt;/code&gt;&lt;p&gt;这个结果就很正常了。当然你也可以使用&lt;code class=&quot;inline&quot;&gt;#![deny(intra_doc_link_resolution_failure)]&lt;/code&gt;属性来消除上面的Warning。&lt;/p&gt;&lt;p&gt;最后，创建&lt;code class=&quot;inline&quot;&gt;src/test/rustdoc-ui/intra-link-span-ice-55723.stderr&lt;/code&gt;文件，将上面的warning信息加进去。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;提交PR说明&lt;/h2&gt;&lt;p&gt;在修改完Bug之后，就可以提交PR了。但是在提交PR之前，还需要运行一遍整个项目的测试，避免引入新的问题。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;$ python x.py test --stage 1&lt;/code&gt;&lt;p&gt;通过运行此测试，发现代码违反了一些代码风格：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;./x.py test --stage 1
*Finished* dev [unoptimized] target(s) in 0.29s                                                                                  
Building stage0 tool tidy (x86_64-apple-darwin)                                                                                    
*Compiling* syn v0.14.9                                                                                                           
*Compiling* serde_derive v1.0.75                                                                                                  
*Compiling* tidy v0.1.0 (/Users/songxinxin/work/projects/rust/rust/src/tools/tidy)                                                
*Finished* release [optimized] target(s) in 31.45s                                                                               
tidy check
tidy error: /Users/Name/work/projects/rust/rust/src/librustdoc/passes/collect_intra_doc_links.rs:584: line longer than 100 chars
tidy error: /Users/Name/work/projects/rust/rust/src/test/rustdoc-ui/intra-link-span-ice-55723.rs:2: trailing whitespace
some tidy checks failed


command did not execute successfully: &quot;/Users/Name/work/projects/rust/rust/build/x86_64-apple-darwin/stage0-tools-bin/tidy&quot; &quot;/Users/Name/work/projects/rust/rust/src&quot; &quot;/Users/Name/work/projects/rust/rust/build/x86_64-apple-darwin/stage0/bin/cargo&quot; &quot;--no-vendor&quot; &quot;--quiet&quot;
expected success, got: exit code: 1&lt;/code&gt;&lt;p&gt;这个错误告诉我，&lt;code class=&quot;inline&quot;&gt;librustdoc/passes/collect_intra_doc_links.rs&lt;/code&gt;代码中第584行超过了100个字符。这个是通过&lt;code class=&quot;inline&quot;&gt;tidy&lt;/code&gt;这个工具发现的。除此之外，测试代码里还有两个尾随空格检测失败了。&lt;/p&gt;&lt;p&gt;584行是我加的测试代码，现在将其删除。而测试文件中的尾随空格，是故意加的，删掉就起不到测试效果了，所以将其保留。&lt;/p&gt;&lt;p&gt;使用GitHub标准&lt;code class=&quot;inline&quot;&gt;fork+pull&lt;/code&gt;的方式来提交PR，在PR提交之后，使用下面格式的回复来调用机器人。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;r? @steveklabnik&lt;/code&gt;&lt;p&gt;这样一来，@rust-highfive机器人就会将此PR指派给@steveklabnik来进行review。&lt;/p&gt;&lt;p&gt;在Review之后，就会继续使用机器人来对PR进行下一步审核。格式如下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;@bors: r+ 38fe8d2&lt;/code&gt;&lt;p&gt;@bors机器人就会来处理此PR，将此PR放到&lt;a href=&quot;https://buildbot2.rust-lang.org/homu/queue/rust&quot;&gt;Merge队列 - rust&lt;/a&gt;，然后运行一遍所有的测试。如果工作正常，@bors就会merge你的代码并关闭该PR。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;通过梳理ICE问题分析和Bug修复的整个过程，明白了如何在本地搭建Rust调试环境，以及如何通过Debug信息来定位问题、分析问题，最终提交PR的整个流程。如果你想为Rust做点贡献，完全可以参考这个流程。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;更多的细节内容，请参考以下资料：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://rust-lang.github.io/rustc-guide/how-to-build-and-run.html&quot;&gt;How to build the compiler and run what you built - Guide to Rustc Development&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md&quot;&gt;https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-25-53247517</guid>
<pubDate>Tue, 25 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「Rust每日新闻」本周精选 • 第二十五期</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-23-53059897.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/53059897&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-23599072636a1820bba7b49b9d586092_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;前言：&lt;br&gt;&lt;br&gt;从2018年开始，我每天会花1个小时关注Rust社区动态，并且在&lt;a href=&quot;http://rust.cc/&quot;&gt;Rust.CC论坛&lt;/a&gt;、&lt;a href=&quot;https://t.me/rust_daily_news&quot;&gt;tg channel&lt;/a&gt;、&lt;a href=&quot;https://steemit.com/@blackanger&quot;&gt;Steemit&lt;/a&gt;、&lt;a href=&quot;https://github.com/RustStudy/rust_daily_news&quot;&gt;GitHub&lt;/a&gt;、&lt;a href=&quot;https://www.yuque.com/chaosbot/rustnews&quot;&gt;语雀订阅&lt;/a&gt;都开通了Rust每日新闻，分享我每天的见闻，偶尔也夹杂了一些个人的观点。大半年过去了，Rust每日新闻已经成为了Rust社区群大家每天必看的内容。在这个知乎专栏里，每周会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。&lt;br&gt;&lt;br&gt;2018-12-23&lt;/blockquote&gt;&lt;hr&gt;&lt;h2&gt;「付费阅读」系列&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51479889&quot;&gt;如何为Rust语言做贡献&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52032027&quot;&gt;Rust Quiz 11&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;官方新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;通告Rust 1.31.1发布&lt;/h2&gt;&lt;p&gt;修复了一些问题。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.rust-lang.org/2018/12/20/Rust-1.31.1.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「官方」Rust 2018中的过程宏&lt;/h2&gt;&lt;p&gt;官方博客介绍了Rust 2018 edition中过程宏的支持，重点介绍了过程宏基于TokenStream的工作机制，值得一阅。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Withoutboats眼中的Rust 2019：组织债务&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52568974&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust最新动态摘要&lt;/h2&gt;&lt;h2&gt;rust&lt;/h2&gt;&lt;p&gt;审核中的PR：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/56939&quot;&gt;稳定化Pin API&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/56932&quot;&gt;重构core::iter模块（值得一看）&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/56926&quot;&gt;升级stdsimd子模块&lt;/a&gt;&lt;/li&gt;&lt;li&gt;href=&quot;https://github.com/rust-lang/rust/pull/57049&quot;&amp;gt;稳定化#[repr(packed(N))]&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57051&quot;&gt;rustc依赖的库：parking_lot升级到0.7版本&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57027/files&quot;&gt;代码优化(没想到Rust代码中也有乱用clone的情况)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;href=&quot;https://github.com/rust-lang/rust/pull/57002&quot;&amp;gt;稳定化Vec(Deque)::resize_with&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/56981&quot;&gt;RalfJung改进了miri的内存分配精准度&lt;/a&gt;&lt;/li&gt;&lt;li&gt;a href=&quot;https://github.com&lt;code class=&quot;inline&quot;&gt;/rust-lang/rust/pull/56998&quot;&amp;gt;&lt;/code&gt;为Arc&amp;lt;T&amp;gt;/Rc&amp;lt;T&amp;gt;增加Into&amp;lt;NonNull&amp;lt;T&amp;gt;&amp;gt;实现（引起了较多讨论）&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/56973&quot;&gt;在Release版本中提供最基本的CTFE跟踪（为了Debug？）&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;已合并的PR：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/55992&quot;&gt;扩展Pin文档并且将std::pin::Pinned改成了std::marker::PhantomPinned&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/56305&quot;&gt;miri得到了更新&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/56737&quot;&gt;TokeStream得到了改进: 优化了TokenStream以及其他类型&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/56751&quot;&gt;允许胖指针实现Hash&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/56931&quot;&gt;Rust 1.31.1 Release Note已更新&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/56863&quot;&gt;修复trait对象的Bug&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/56948&quot;&gt;更新LLVM子模块&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「官方」Rust 2018 edition 工具集&lt;/h2&gt;&lt;h2&gt;devtool&lt;/h2&gt;&lt;p&gt;本文介绍了Rust 2018 edition包含的工具集&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Rustfix&lt;/li&gt;&lt;li&gt;Clippy&lt;/li&gt;&lt;li&gt;Rustfmt&lt;/li&gt;&lt;li&gt;IDE support&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;未来：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;改进LLDB和GDB的Rust调试支持&lt;/li&gt;&lt;li&gt;完善RLS&lt;/li&gt;&lt;li&gt;让Cargo更强大&lt;/li&gt;&lt;li&gt;Rustdoc改进&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://blog.rust-lang.org/2018/12/17/Rust-2018-dev-tools.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;社区新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;LeetCode现在已支持Rust&lt;/h2&gt;&lt;p&gt;中国版和美国版都支持了，另外了解到的消息是，目前是基于Rust stable 1.31版，而且还会持续跟进Rust Stable版本。在未来会逐渐加入常用的crate，这个看使用者反馈来持续改进。&lt;/p&gt;&lt;p&gt;刷Leetcode Rust代码的碰到问题可以加QQ群反馈。qq群号： 950323896，进群以后可以加微信群，直接向官方反馈问题。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/explore/&quot;&gt;Leetcode中国&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;nitric: Specs的继承者&lt;/h2&gt;&lt;p&gt;nitric是Specs作者新写的库，那么他为什么在苦心研究两年Specs之后，要革自己的命呢？在本文中他阐述了如下理由：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;并非是对specs的重构，也不是和specs竞争，也不会对Specs有任何影响，Specs也不会被弃用&lt;/li&gt;&lt;li&gt;nitric是打算提供一个更通用的解决方案&lt;/li&gt;&lt;li&gt;Specs已经有了自己的生态，所以需要独立出另外一个库继续开发&lt;/li&gt;&lt;li&gt;nitric是一个通用的数据处理库，一旦完成这个库，specs将成为nitric的前端&lt;/li&gt;&lt;li&gt;nitric的愿景是提供一系列的crate，这些crate是解决数据处理问题的标准方案&lt;/li&gt;&lt;li&gt;未来可以使用nitric的领域：游戏开发、游戏物理、模拟器、编译器、数据验证、图形用户界面等&lt;/li&gt;&lt;li&gt;nitric的哲学是：1. 只能以合理的组合方式解决单个问题。 2. 公开一个通用、可组合和强大的API&lt;/li&gt;&lt;li&gt;nitric会与其他数据结构兼容，比如ECS/CGS库等&lt;/li&gt;&lt;li&gt;也可以使用nitric来作为ECS，比如通过nitric-entity库。文章里也介绍了几个计划中的其他nitric crate。&lt;/li&gt;&lt;li&gt;Amethyst将继续使用Sepcs，未来是否会迁移到nitric，需要由RFC来推动&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;大家也不要太亦可赛艇，他只是先分享了计划，还未动工。不过已经有了代码仓库：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/torkleyy/nitric&quot;&gt;GitHub: nitric&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://gitlab.com/nitric/nitric&quot;&gt;GitLab: nitric&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://users.rust-lang.org/t/announcing-nitric-the-successor-of-specs/23388&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「嵌入式Rust」Rust对Arduino支持进展调查&lt;/h2&gt;&lt;p&gt;因为Arduino使用的是AVR微控制器，但Rust目前还未支持AVR。但Rust嵌入式开发组已经有计划支持AVR。&lt;/p&gt;&lt;p&gt;感兴趣的朋友可以关注此issues： &lt;a href=&quot;https://github.com/rust-embedded/wg/issues/3&quot;&gt;AVR support&lt;/a&gt;&lt;/p&gt;&lt;p&gt;目前也有一个avr-project GitHub项目组独立fork了Rust，提供了对AVR的支持。在官方Rust未支持AVR之前，可以使用这个，看上去还非常活跃。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/avr-rust&quot;&gt;avr-rust&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「访谈」Josh Triplett访谈&lt;/h2&gt;&lt;p&gt;Josh Triplett是一个开源软件贡活跃献者，他最近正和另外一个匿名资助者，准备向非盈利性开源组织Conservancy捐赠9万美元，用于继续推动开源软件的发展。这是对他的采访。&lt;/p&gt;&lt;p&gt;采访中，他提到Rust是他今年在开源社区看到的最激动人心的项目。他说：Rust给了我对计算未来的巨大希望。&lt;/p&gt;&lt;p&gt;也许Conservancy在拿到这笔捐赠后，可能帮助Rust完成组织治理的工作。（猜想）&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://sfconservancy.org/blog/2018/dec/18/JoshT/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Warp 0.1.10发布&lt;/h2&gt;&lt;p&gt;Wary是另一个Rust Web框架，由Hyper作者开发。 新版本的功能简要：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;TLS支持&lt;/li&gt;&lt;li&gt;CORS&lt;/li&gt;&lt;li&gt;Websocket检测助手&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;依然计划和tower-web进行合并，但下一步主要是完善service trait。将来可以通过Service方便地添加tower式中间件。&lt;/p&gt;&lt;p&gt;（那官方Tide框架的中间件协议呢？也许tower式中间件协议在官方中间件协议稳定以后也会支持吧）&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://seanmonstar.com/post/181223452087/warp-v0110&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Tokio 2019展望&lt;/h2&gt;&lt;p&gt;主要是两件事：&lt;/p&gt;&lt;p&gt;一、 Async/Await支持&lt;/p&gt;&lt;p&gt;Tokio预计在Rust语言async/await稳定之后，正式支持该语法。如果你想在nightly上面使用async/await，可以使用async-await-preview。&lt;/p&gt;&lt;p&gt;目前tokio是以实验性功能来探索async/await的支持，比如一些特定的API会添加&lt;code class=&quot;inline&quot;&gt;_async&lt;/code&gt;后缀，一旦async/await稳定了，Tokio将立马采取重大的更新并去除这些后缀。默认情况下，比如，会将&lt;code class=&quot;inline&quot;&gt;tokio::run_async&lt;/code&gt;改成&lt;code class=&quot;inline&quot;&gt;tokio::run&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;那么futures-rs 0.1怎么办？然而并不能立马放弃对0.1的支持。&lt;/p&gt;&lt;p&gt;这是一个不断增长的生态系统，包括一些生产环境的应用，也使用了futures 0.1。Tokio会以向后兼容的方式来支持async/await，也就是说，同时支持async/await和futures 0.1。对于已经形成生态的系统而言，变革很困难，还需要和社区共同商讨过渡策略：&lt;a href=&quot;https://github.com/tokio-rs/tokio/issues/804&quot;&gt;关注此track issues&lt;/a&gt;&lt;/p&gt;&lt;p&gt;二、团队扩展&lt;/p&gt;&lt;p&gt;是时候扩展Tokio的开发和维护团队了，准备像Rust团队学习，分成多个工作组，不同的组负责Tokio的不同方面。当然这个过程还在讨论中。&lt;/p&gt;&lt;p&gt;同时也需要一些新手加入，帮助使用和发展Tokio。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://tokio.rs/blog/2018-12-recap-2018/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「嵌入式Rust」实时消息框架RTFM发布0.4版&lt;/h2&gt;&lt;p&gt;嵌入式工作组的老大japaric发布的库，用于构建并发的实时系统，貌似基于RTFM语言。&lt;/p&gt;&lt;p&gt;RTFM语言旨在促进并发编程或嵌入式实时软件的开发。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.rtfm-lang.org/&quot;&gt;www.rtfm-lang.org&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.japaric.io/rtfm-v4/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;如何成为一个超级的Rust开发者&lt;/h2&gt;&lt;p&gt;这是一个「真香」的故事。&lt;/p&gt;&lt;p&gt;作者在去年看到Rust语言的时候，心想：&quot;呵呵，继续吹，继续炒。呵呵，我用C++照样可以完成同样的事，而且还拥有更多的控制权&quot;。&lt;/p&gt;&lt;p&gt;然而，今天这位作者写下了这篇博文，他说：“我之前的想法真是大错特错，错到底了！，当我潜下心来研究Rust，我发现，它是一门经过深思熟虑的语言，它的工作方式有别于我所知道的一切。”&lt;/p&gt;&lt;p&gt;他变成了Rust传道者。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://hashnode.com/post/how-to-become-a-rust-super-developer-cjpv1ee7e000buhs2aqrdw2ym&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;crates.io可视化报告&lt;/h2&gt;&lt;p&gt;截止2018年11月，已经达到2w个crates，但很多crate版本发布都小于6次release版本，生态系统依然很年轻。另外一些crate有100多个发布版本，有很多crate都是零依赖，但有3000个crate都依赖serde，所以，serde当之无愧是最流行的crate。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b2c5eefa87f2b6663cadb086b50c5d5d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;321&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-b2c5eefa87f2b6663cadb086b50c5d5d&quot; data-watermark-src=&quot;v2-f12044ee0a9ee4b7d6f368643249566f&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0127dd4d1eb402352d2188d62c250813_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;311&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-0127dd4d1eb402352d2188d62c250813&quot; data-watermark-src=&quot;v2-ad616e9e57488cbad322e76b6e66af8e&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8e123ce95de39cafa173f37a520fe7c2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;472&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-8e123ce95de39cafa173f37a520fe7c2&quot; data-watermark-src=&quot;v2-5392d73898407644a9f1fce81ad4567c&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2e1600465993a762486df7feeb2ec037_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;335&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-2e1600465993a762486df7feeb2ec037&quot; data-watermark-src=&quot;v2-9050d004c5d8bfca6898f75747cf2a05&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-699cd494970cad3571fd4519cce5f61a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;292&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-699cd494970cad3571fd4519cce5f61a&quot; data-watermark-src=&quot;v2-60958b2515ff0f03ee07e59fc187aa37&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://8-p.info/visualizing-crates-io/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;学习资源&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;Rust Quiz解读已更新到Quiz 21&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/time-and-spirit-hut&quot;&gt;去专栏 Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Cortex-M3 入门指南（二）：寄存器与 GPIO &lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52855259&quot;&gt;Andy Lok：Cortex-M3 入门指南（二）：寄存器与 GPIO&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Serverless HTTP&lt;/h2&gt;&lt;p&gt;该文作者探索aws lambda平台的无服务器HTTP应用，并编写了一个crate，叫做lando，它以http crate为核心接口，以lambda为部署目标，来部署API网关。本文就是对lando的介绍。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/softprops/lando&quot;&gt;lando&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://medium.com/@softprops/serverless-http-9a58f9b2df60&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「Rust扩展Python案例」快速JSON解析库&lt;/h2&gt;&lt;p&gt;基于PyO3库&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ijl/orjson&quot;&gt;orjson&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;解析工具选择之书&lt;/h2&gt;&lt;p&gt;有人写了一本书，罗列了现在的解析工具，比如nom、combine、pest等，提供了一些文档和示例，帮助你选择适合使用场景的解析工具。目测还在完善中。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://freemasen.github.io/parsers_presentation/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「系列文章」Rust vs Swift&lt;/h2&gt;&lt;p&gt;作者从2015年开始写这一系列博客，直到昨天才发布了一个整理页面。感兴趣可以看看。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.chriskrycho.com/rust-and-swift.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;rust-derivative: 提供了替代&lt;code class=&quot;inline&quot;&gt;derive&lt;/code&gt;属性的宏&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/mcarton/rust-derivative&quot;&gt;rust-derivative&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://mcarton.github.io/rust-derivative/&quot;&gt;指南&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「Slides」魅力wasm-bindgen&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://speakerdeck.com/tsukushi/attractions-and-interests-of-wasm-bindgen&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;项目&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;下沙：Rust+WASM+WebGL实现的游戏&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://sandspiel.club/&quot;&gt;sandspiel.club&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/maxbittker/sandspiel&quot;&gt;Code: sandspiel&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;新的MQTT异步客户端&lt;/h2&gt;&lt;p&gt;基于tokio，目前正在召人审核代码&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/AtherEnergy/rumqtt&quot;&gt;rumqtt&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/a79j5v/rumqtt_release_async_version/&quot;&gt;讨论贴&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「嵌入式Rust」可用于串行热敏打印机的embedded-hal驱动&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://crates.io/crates/thermal_printer&quot;&gt;thermal_printer&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;encoding_rs: Web兼容字符编码库&lt;/h2&gt;&lt;p&gt;这是WHATWG编码标准的高性能实现。被用于Firefox 56版本中，替代了uconv库。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/hsivonen/encoding_rs&quot;&gt;encoding_rs&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://hsivonen.fi/encoding_rs/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;用Rust编写的roguelike游戏发布了&lt;/h2&gt;&lt;p&gt;基于wasm和Rust，可以在线玩，也可以下载到Windows、Mac和Linux平台。 在Reddit贴中，还记录了感人的开发故事。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/a8be46/dose_response_roguelike_game_written_in_rust/&quot;&gt;Reddit 介绍贴&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://tryjumping.com/dose-response-roguelike/play/&quot;&gt;在线玩&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://tryjumping.itch.io/dose-response&quot;&gt;下载&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/tryjumping/dose-response&quot;&gt;源码&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;「深度学习」运行时前端TVM支持（预发布）&lt;/h2&gt;&lt;p&gt;TVM的Rust绑定。TVM介绍：&lt;/p&gt;&lt;blockquote&gt; 有了 TVM，业界与学界开发者们可以快速、轻松地在各个系统（包括手机、嵌入式设备与低功耗芯片）上部署深度学习应用程序，同时无须担心资源与速度的限制。「TVM 作为神经网络和硬件后端之间的共同层，消除了为每类设备或服务器优化各自基础架构的需要。」TVM 项目负责人陈天奇表示，「我们的框架允许开发人员快速、轻松地部署和优化大量硬件设备上的深度学习系统。」&lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ehsanmok/tvm-rust&quot;&gt;tvm-rust&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;p2p: 支持自定义协议的多路p2p网络库&lt;/h2&gt;&lt;p&gt;群友漂流的作品，据说是libp2p的轻量版本。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/driftluo/p2p&quot;&gt;p2p&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;ferrugo: JVM的Rust实现&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/maekawatoshiki/ferrugo&quot;&gt;ferrugo&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;工具与库&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;使用dutree分析磁盘使用情况&lt;/h2&gt;&lt;p&gt;该文是dutree的使用教程，dutree是Rust实现的磁盘分析工具。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/nachoparker/dutree&quot;&gt;dutree&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://ownyourbits.com/2018/03/25/analyze-disk-usage-with-dutree/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;cargo-expand：查看宏展开结果&lt;/h2&gt;&lt;p&gt;serde作者实现的新包，包括声明宏和&lt;code class=&quot;inline&quot;&gt;#[derive]&lt;/code&gt;过程宏。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;$ cargo expand&lt;/code&gt;&lt;p&gt;是对rustc命令的包装：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;$ cargo rustc --profile=check -- -Zunstable-options --pretty=expanded&lt;/code&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/dtolnay/cargo-expand&quot;&gt;cargo-expand&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「小工具」验证代码中内存使用&lt;/h2&gt;&lt;p&gt;QADAPT库可以验证代码中何时分配或丢弃内存。作者写了篇文章，以构建自定义内存分配器为例来讲解如何使用QADAPT库提供的&lt;code class=&quot;inline&quot;&gt;debug_assert!&lt;/code&gt;验证代码中内存分配情况。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/bspeice/qadapt&quot;&gt;qadapt&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://speice.io/2018/12/allocation-safety.html&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;nymic: 一个可以打印类型名字的库&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/myrrlyn/nymic&quot;&gt;nymic&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;加速并校准Rust的浮点数解析&lt;/h2&gt;&lt;p&gt;作者实现了一个库：&lt;a href=&quot;https://github.com/Alexhuszagh/rust-lexical&quot;&gt;rust-lexical&lt;/a&gt;，比Rust内置的浮点数解析器快4000倍，并且更加正确。而且支持no_std。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/a6j5j1/making_rust_float_parsing_fast_and_correct/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;structview-rs: 用于将二进制数据转换为更高级的数据结构&lt;/h2&gt;&lt;p&gt;structview提供了更安全的API来转换&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://gitlab.com/ra_kete/structview-rs&quot;&gt;structview-rs&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;juniper-from-schema 发布&lt;/h2&gt;&lt;p&gt;作者用Juniper的过程中，发现需要Juniper缺少一个关键的东西：可以和客户端共享实际的Graphql架构的文件。虽然可以手工编写，但代码和scheme文件不会实时同步。作者用过程宏实现了可以自动生成scheme的库。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/davidpdrsn/juniper-from-schema&quot;&gt;juniper-from-schema&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-23-53059897</guid>
<pubDate>Sun, 23 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 21</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-21-52986963.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52986963&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;&lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;br&gt; - &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;br&gt;&lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz  21:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Trait {
    fn f(&amp;amp;self);
}

impl&amp;lt;F: FnOnce() -&amp;gt; bool&amp;gt; Trait for F {
    fn f(&amp;amp;self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for () {
    fn f(&amp;amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let x = || { (return) || true; };
    x().f();

    let x = loop { (break) || true; };
    x.f();

    let x = || { return (|| true); };
    x().f();

    let x = loop { break (|| true); };
    x.f();

    let x = || { return || true; };
    x().f();

    let x = loop { break || true; };
    x.f();
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 221111&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;return和break的区别&lt;/li&gt;&lt;li&gt;闭包实现和闭包调用&lt;/li&gt;&lt;li&gt;优先级&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Quiz 代码中定义了Trait和一个泛型实现，该泛型实现中包含了限定 &lt;code class=&quot;inline&quot;&gt;&amp;lt;F: FnOnce() -&amp;gt; bool&amp;gt;&lt;/code&gt;，其意义是，只有&lt;code class=&quot;inline&quot;&gt;FnOnce() -&amp;gt; bool&lt;/code&gt;闭包才可以调用&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;函数。&lt;/p&gt;&lt;p&gt;同样为单元类型&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;也实现了Trait。&lt;/p&gt;&lt;p&gt;接下来依次看main函数中的代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let x = || { (return) || true; };
x().f(&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;绑定右侧，整体是一个闭包，当该闭包调用的时候，其闭包体内部的&lt;code class=&quot;inline&quot;&gt;{(return) || true; }&lt;/code&gt;是一个完整的或操作表达式。不过，&lt;code class=&quot;inline&quot;&gt;(return)&lt;/code&gt;首先会返回&lt;code class=&quot;inline&quot;&gt;（）&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;所以，当调用&lt;code class=&quot;inline&quot;&gt;x()&lt;/code&gt;的时候，会返回&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;。这里需要注意的是，闭包调用语法。由闭包的名称紧跟括号来调用闭包。所以，&lt;code class=&quot;inline&quot;&gt;x().f()&lt;/code&gt;，实际上就是调用闭包的返回值&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;f()&lt;/code&gt;方法，输出结果是&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let x = loop { (break) || true; };
 x.f();&lt;/code&gt;&lt;p&gt;这两行代码中的x，是绑定了，从loop循环中通过&lt;code class=&quot;inline&quot;&gt;break&lt;/code&gt;关键字返回的单元值&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;。因为这里是&lt;code class=&quot;inline&quot;&gt;(break)&lt;/code&gt;，通过括号将&lt;code class=&quot;inline&quot;&gt;break&lt;/code&gt;做为了一个独立的表达式，和上面的&lt;code class=&quot;inline&quot;&gt;(return)&lt;/code&gt;类似。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;let x = || { return (|| true); };
x().f();&lt;/code&gt;&lt;p&gt;这里很明显，当闭包x被调用之后，返回的是&lt;code class=&quot;inline&quot;&gt;|| true&lt;/code&gt;这个闭包。这个闭包是实现了&lt;code class=&quot;inline&quot;&gt;FnOnce()-&amp;gt;bool&lt;/code&gt;的闭包，所以&lt;code class=&quot;inline&quot;&gt;x().f()&lt;/code&gt;这里是调用有&lt;code class=&quot;inline&quot;&gt;&amp;lt;F: FnOnce()-&amp;gt;bool&amp;gt;&lt;/code&gt;限定的泛型实现中的&lt;code class=&quot;inline&quot;&gt;f()&lt;/code&gt;方法，所以输出&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;let x = loop { break (|| true); };
x.f();&lt;/code&gt;&lt;p&gt;这里的break和上面的return相似，返回的依然是闭包。同理，输出&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;let x = || { return || true; };
x().f();&lt;/code&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;return&lt;/code&gt;关键字来说，这里不加括号和加括号的效果是一样的，所以，还是返回闭包。输出依然是&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;let x = loop { break || true; };
 x.f();&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;break&lt;/code&gt;在这里和&lt;code class=&quot;inline&quot;&gt;return&lt;/code&gt;相同，返回闭包，输出为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;回想Quiz 20中&lt;code class=&quot;inline&quot;&gt;break&lt;/code&gt;的用法，可以把最后这两行代码改一下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;// 修改1
let x = loop { break { || true }; };
x.f();

// 修改2
let x = loop { break { || true } };
x.f();

// 修改3
let x = loop { break { || true; } };
x.f();&lt;/code&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;修改1&lt;/code&gt;来说，&lt;code class=&quot;inline&quot;&gt;break&lt;/code&gt;后面加了&lt;code class=&quot;inline&quot;&gt;{ ... }&lt;/code&gt;块。其实在Rust中，块（block）也是一个表达式。所以，&lt;code class=&quot;inline&quot;&gt;修改1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;修改2&lt;/code&gt;其实是等价的，在块后面加不加分号类似。最终break会将闭包&lt;code class=&quot;inline&quot;&gt;|| true&lt;/code&gt;返回。&lt;/p&gt;&lt;p&gt;所以，&lt;code class=&quot;inline&quot;&gt;修改1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;修改2&lt;/code&gt;都是输出&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。但是&lt;code class=&quot;inline&quot;&gt;修改3&lt;/code&gt;的结果就不一样了。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;修改3&lt;/code&gt;中，&lt;code class=&quot;inline&quot;&gt;|| true&lt;/code&gt;后面加了分号&lt;code class=&quot;inline&quot;&gt;;&lt;/code&gt;，对于块表达式来说，它的求值结果必然是&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;。因为在Rust中，加分号的表达式，都会返回&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;。所以，&lt;code class=&quot;inline&quot;&gt;修改3&lt;/code&gt;会输出&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/21&quot;&gt;点此查看 Rust Quiz 21&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-21-52986963</guid>
<pubDate>Fri, 21 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 20</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-19-52772684.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52772684&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;&lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;&lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz  20:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn return1() {
    if (return { print!(&quot;1&quot;) }) {
    }
}

fn return2() {
    if return { print!(&quot;2&quot;) } {
    }
}

fn break1() {
    loop {
        if (break { print!(&quot;1&quot;) }) {
        }
    }
}

fn break2() {
    loop {
        if break { print!(&quot;2&quot;) } {
        }
    }
}

fn main() {
    return1();
    return2();
    break1();
    break2();
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 121&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;return和break的一点区别&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;其实在Rust 1.19版本之前，上面代码的输出结果是&lt;code class=&quot;inline&quot;&gt;1212&lt;/code&gt;。但是在1.19之后，加入了&lt;code class=&quot;inline&quot;&gt;break value in loop&lt;/code&gt;的功能，也就是说，可以从loop循环中使用break返回一个值。&lt;/p&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;break1&lt;/code&gt;函数来说：&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;loop {  if (break { print!(&quot;1&quot;) }) {}}&lt;/code&gt;，会先计算&lt;code class=&quot;inline&quot;&gt;break {print!(&quot;1&quot;)}&lt;/code&gt;的值。&lt;/p&gt;&lt;p&gt;而&lt;code class=&quot;inline&quot;&gt;break2&lt;/code&gt;函数，因为没有使用括号来表达优先级，所以会解析为以下等价的代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn break2() {
    loop {
        if (break) { 
            print!(&quot;2&quot;) 
        }
        { }
    }
}&lt;/code&gt;&lt;p&gt;所以，在打印之前就已经&lt;code class=&quot;inline&quot;&gt;break&lt;/code&gt;出了循环体，所以什么都没打印。&lt;/p&gt;&lt;p&gt;而return就不会产生这种解释歧义，等以后Rust可能会统一break和return的行为。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/20&quot;&gt;点此查看 Rust Quiz 20&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-19-52772684</guid>
<pubDate>Wed, 19 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 19</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-18-52661087.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52661087&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;b&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;/b&gt; &lt;br&gt;&lt;b&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;/b&gt; &lt;br&gt;&lt;b&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;/b&gt; &lt;br&gt;&lt;br&gt;&lt;b&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/b&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 19:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S;

impl Drop for S {
    fn drop(&amp;amp;mut self) {
        print!(&quot;1&quot;);
    }
}

fn main() {
    let s = S;
    let _ = s;
    print!(&quot;2&quot;);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果：21&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;所有权和drop&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;_&lt;/code&gt;并没有所有权&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我想把这个例子重新修改一下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;#[derive(Debug)]
struct S;

impl Drop for S {
    fn drop(&amp;amp;mut self) {
        print!(&quot;1&quot;);
    }
}

fn main() {
    let s = S;
    let _ = s;
    print!(&quot;{:?}&quot;, s)
}&lt;/code&gt;&lt;p&gt;执行该代码输出结果为&lt;code class=&quot;inline&quot;&gt;S1&lt;/code&gt;。重点在main函数最后一行打印语句中，在执行了&lt;code class=&quot;inline&quot;&gt;let _ = s;&lt;/code&gt;之后，还可以使用&lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt;。这说明，&lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt;的所有权并未被转移。&lt;/p&gt;&lt;p&gt;所以，先打印的是&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;。等main函数执行完，&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的drop方法会被自动调用，然后打印&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;现在可以回顾一下Quiz代码，想想为什么输出`21`。&lt;/p&gt;&lt;p&gt;&lt;b&gt;继续改一下代码：&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() {
    let s = S;
    let _a = s;
    print!(&quot;{:?}&quot;, s)
}&lt;/code&gt;&lt;p&gt;这一次只改main函数，将&lt;code class=&quot;inline&quot;&gt;_&lt;/code&gt;变成&lt;code class=&quot;inline&quot;&gt;_a&lt;/code&gt;，执行代码的时候出错了：&lt;code class=&quot;inline&quot;&gt;error[E0382]: use of moved value:&lt;/code&gt;s&lt;code class=&quot;inline&quot;&gt;`。说明&lt;/code&gt;s&lt;code class=&quot;inline&quot;&gt;的所有权已经被转移了。 看来&lt;/code&gt;_&lt;code class=&quot;inline&quot;&gt;和&lt;/code&gt;_a`的行为是不一样的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;继续简化代码来查看生成的mir：&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// mir示例1
struct S;
fn main() {
    let s = S;
    let _ = s;
}

// mir示例2
struct S;
fn main() {
    let s = S;
    let _a = s;
}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;mir示例1&lt;/code&gt;会生成下面的mir代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() -&amp;gt; (){
    let mut _0: ();                      // return place
    scope 1 {
    }
    scope 2 {
        let _1: S;                       // &quot;s&quot; in scope 2 at src/main.rs:4:9: 4:10
    }

    bb0: {                              
        StorageLive(_1);                 // bb0[0]: scope 0 at src/main.rs:4:9: 4:10
        StorageDead(_1);                 // bb0[1]: scope 0 at src/main.rs:6:1: 6:2
        return;                          // bb0[2]: scope 0 at src/main.rs:6:2: 6:2
    }
}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;mir示例2&lt;/code&gt;则生成下面的mir代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() -&amp;gt; (){
    let mut _0: ();                      // return place
    scope 1 {
        scope 3 {
        }
        scope 4 {
            let _2: S;                   // &quot;_a&quot; in scope 4 at src/main.rs:5:9: 5:11
        }
    }
    scope 2 {
        let _1: S;                       // &quot;s&quot; in scope 2 at src/main.rs:4:9: 4:10
    }

    bb0: {                              
        StorageLive(_1);                 // bb0[0]: scope 0 at src/main.rs:4:9: 4:10
        StorageLive(_2);                 // bb0[1]: scope 1 at src/main.rs:5:9: 5:11
        _2 = move _1;                    // bb0[2]: scope 1 at src/main.rs:5:14: 5:15
        StorageDead(_2);                 // bb0[3]: scope 1 at src/main.rs:6:1: 6:2
        StorageDead(_1);                 // bb0[4]: scope 0 at src/main.rs:6:1: 6:2
        return;                          // bb0[5]: scope 0 at src/main.rs:6:2: 6:2
    }
}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;示例1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;示例2&lt;/code&gt;的区别，正是&lt;code class=&quot;inline&quot;&gt;_&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;_a&lt;/code&gt;的区别。&lt;code class=&quot;inline&quot;&gt;_a&lt;/code&gt;多了一次move操作：&lt;code class=&quot;inline&quot;&gt;_2 = move _1;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;最后再改一下Quiz代码：&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S;

impl Drop for S {
    fn drop(&amp;amp;mut self) {
        print!(&quot;1&quot;);
    }
}

fn main() {
    let s = S;
    drop(s);
    print!(&quot;2&quot;);
}&lt;/code&gt;&lt;p&gt;输出结果是： &lt;code class=&quot;inline&quot;&gt;12&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这里使用了&lt;code class=&quot;inline&quot;&gt;drop(s)&lt;/code&gt;，未转移所有权，也未绑定任何变量，直接drop。所以，会在打印语句之前调用drop方法，先输出&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/19&quot;&gt;点此查看 Rust Quiz 19&lt;/a&gt; &lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-18-52661087</guid>
<pubDate>Tue, 18 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 18</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-17-52609791.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52609791&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;&lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;&lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 18:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S {
    f: fn(),
}

impl S {
    fn f(&amp;amp;self) {
        print!(&quot;1&quot;);
    }
}

fn main() {
    let print2 = || print!(&quot;2&quot;);
    S { f: print2 }.f();
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 1&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;闭包调用&lt;/li&gt;&lt;li&gt;结构体字段和函数调用的优先级&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Quiz代码中实现了结构体S，包含一个类型为&lt;code class=&quot;inline&quot;&gt;fn()&lt;/code&gt;的函数指针字段。然后为S实现了同样名为&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的方法。&lt;/p&gt;&lt;p&gt;在main函数中，定义了闭包print2。然后main中最后一行代码就开始迷惑人了。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;S {f: print2 }.f();&lt;/code&gt;&lt;/p&gt;&lt;p&gt;如果你没有关注结构体字段名也是f，并且它是个函数指针类型，也罢。你就不会想太多。一眼看上去就是调用&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的结构体实例的&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;方法。输出结果是&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。那么正好答对了。&lt;/p&gt;&lt;p&gt;但是，如果你如果注意到&lt;code class=&quot;inline&quot;&gt;print2&lt;/code&gt;闭包也可以作为一个函数指针。那么为什么不是&lt;code class=&quot;inline&quot;&gt;(S {f: print2 }.f)()&lt;/code&gt;呢？&lt;/p&gt;&lt;p&gt;不好意思，如果你想调用闭包，那么最好显式地加上括号告诉编译器你是想调用闭包。就像这样：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S {
    f: fn(),
}

impl S {
    fn f(&amp;amp;self) {
        print!(&quot;1&quot;);
    }
}

fn main() {
    let print2 = || print!(&quot;2&quot;);
    (S { f: print2 }.f)();
}&lt;/code&gt;&lt;p&gt;这样输出结果就是&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;否则，编译器在这里，只认函数调用。如果不信的话，你把&lt;code class=&quot;inline&quot;&gt;impl S { ... }&lt;/code&gt;代码删除以后看看：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S {
    f: fn(),
}

fn main() {
    let print2 = || print!(&quot;2&quot;);
    S { f: print2 }.f();
}&lt;/code&gt;&lt;p&gt;编译器会报错：&lt;code class=&quot;inline&quot;&gt;error[E0599]: no method named&lt;/code&gt;f&lt;code class=&quot;inline&quot;&gt;found for type&lt;/code&gt;S&lt;code class=&quot;inline&quot;&gt;in the current scope&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;点此查看 Rust Quiz 18&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-17-52609791</guid>
<pubDate>Mon, 17 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 17</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-17-52608592.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52608592&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;&lt;br&gt;-  &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;br&gt;&lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 17:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() {
    let mut a = 5;
    let mut b = 3;
    print!(&quot;{}&quot;, a-- - --b);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果: 2&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;和Quiz16代码一样，Rust中不存在自增或自减运算符&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;a-- - --b&lt;/code&gt;等价于&lt;code class=&quot;inline&quot;&gt;a - (-(-(-(-b))))&lt;/code&gt; ，&lt;code class=&quot;inline&quot;&gt;5 - 3 = 2&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;那为什么Rust中没有自增/自减运算符呢？&lt;/p&gt;&lt;p&gt;在Rust官方的FAQ中有描述：&lt;/p&gt;&lt;blockquote&gt; 先增和后增（以及相对应的减法）虽然方便，但也相当复杂。它们都需要求值顺序的知识，而且经常导致 C 和 C++ 中的细节错误和未定义的行为。 x = x + 1 或 x += 1 只是略长一点，但更加明确。  &lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;Rust新官网已经没有了FAQ页面，查看需要从旧官网入口进入：&lt;a href=&quot;https://prev.rust-lang.org/zh-CN/faq.html#why-doesnt-rust-have-increment-and-decrement-operators&quot;&gt;常见问题解答 · Rust 程序设计语言&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/17&quot;&gt;点此查看 Rust Quiz 17&lt;/a&gt; &lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-17-52608592</guid>
<pubDate>Mon, 17 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 16</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-17-52607988.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52607988&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;-   &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;br&gt;-   &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;br&gt;-   &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;&lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 16:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() {
    let mut x = 4;
    --x;
    print!(&quot;{}{}&quot;, --x, --x);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果：44&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Rust里不存在C语言中的&lt;code class=&quot;inline&quot;&gt;++i/--i&lt;/code&gt;自增/自减运算符&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;当看到&lt;code class=&quot;inline&quot;&gt;--x&lt;/code&gt;中，可能会有所迷惑。Rust中并不存在自增/自减运算符。所以，Rust编译器怎么解析这个操作呢？答案是&lt;code class=&quot;inline&quot;&gt;-(-x)&lt;/code&gt;。将&lt;code class=&quot;inline&quot;&gt;-&lt;/code&gt;按负号进行解析，而非减号。&lt;/p&gt;&lt;p&gt;负负得正，所以结果是4。然后输出的时候，打印了两次，就是44。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/16&quot;&gt;点此查看 Rust Quiz 16&lt;/a&gt; &lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-17-52607988</guid>
<pubDate>Mon, 17 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「内部视角」Rust团队内的组织债务</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-17-52568974.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52568974&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5e37612217a05e23ca21433c769d22e4_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;官方核心团队成员无船同志在本文中阐述了他对Rust 2019的看法。该文主要谈到了组织治理，Rust自身作为一个开源项目，也可以把它看作一个成长中的初创「产品」，不免会遇到成长之痛。作为Rust团队的内部成员，无船同志以他的视角来分析了Rust组织内部产生的问题，对于我们也是一种警示和学习。&lt;br&gt;&lt;br&gt;原文: &lt;a href=&quot;https://boats.gitlab.io/blog/post/rust-2019/&quot;&gt;Organizational Debt&lt;/a&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;首先，他肯定希望Rust会有更多的技术改进，而且他也会为之付出精力。但是，他认为2019最重要的问题不在于技术改进，而是组织债务（Organizational Debt）。&lt;br&gt;&lt;br&gt;什么是组织债务？它是和技术债务平行的一个名词。我节选一段infoq文章中的阐述：&lt;/p&gt;&lt;blockquote&gt; “组织债务”是在公司层面上是与技术债务平行的。如果技术债务是软件中妨害维护的问题，那么组织债务就是妨碍组织在日常运转中流畅运作的问题。他列举了如下几个组织债务的例子：&lt;br&gt; 1. 解决同一个问题，不同的部门都有自己的工具和方法，这使得主管们很难看到相似之处，以便解决公司层面的问题。&lt;br&gt; 2. 经理们创建的过程或实现的软件解决方案在当时看来似乎是个不错的注意，但却没有消除问题产生的根本原因，长期来看，最终造成了更多的问题。&lt;br&gt; 3. 由于时间特别紧，团队决定“本次”以一种并不是最理想的方式完成一项任务。但是，那种方式后续被重复使用，因为没有人记得第一次原本是打算当作一种一次性方案。&lt;br&gt;&lt;br&gt;&lt;br&gt;更通俗一点的描述：&lt;br&gt;&lt;br&gt; 所谓的组织债务就是初创公司为了「把事情搞定」而做出的所有人事/文化妥协。这些债务会在一定阶段爆发，比如公司融到了新一轮的钱/公司的战略方向调整/公司的人事扩张。这在一定程度上比「技术债务」更难处理，毕竟「技术债务」你面向的是工程/代码，而「组织债务」面向的是人。&lt;/blockquote&gt;&lt;p&gt;组织债务影响的是能否可持续发展的问题。&lt;br&gt;&lt;br&gt;无船同志认为，Rust项目在过去的几年里，一直像创业公司一样成长，虽然有很多好的方面，但也有一些糟糕的问题，如果这个项目想长期地维持下去，必须真正处理到目前已经积累起来的组织债务。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;以下是无船同志罗列出来要解决的问题：&lt;/b&gt;&lt;/h2&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;一 使用GitHub issues来讨论设计就像是从消防栓里喝水&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c2c81fbbfde7d6077941414a08078788_r.jpg&quot; data-rawwidth=&quot;574&quot; data-rawheight=&quot;264&quot; data-size=&quot;normal&quot; data-caption=&quot;drinking from a firehose&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c2c81fbbfde7d6077941414a08078788&quot; data-watermark-src=&quot;v2-26a8d58d69230e69a1b990b0006f08d6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;无船同志统计了关于Pin API讨论的issues中评论数，一共有770条评论，还不算是reddit、irc或discord中的聊天记录。Rust虽然是他的全职工作，但是他发现还跟不上团队内其他人的设计讨论。&lt;br&gt;&lt;br&gt;其实Pin API虽然重要，但最终也是一个比较小的标准API添加，其中并没有包括关于异步、生成器或Futures的讨论。当这个主题高达770条评论的时候，谁有心思看完呢？包括参与评论的人也是，而且经常要对一个比较模糊的概念重新进行解释，这样每一条加入讨论的评论，都算是一种债务。更糟糕的是，将这些讨论再分解为更多的子问题，也无法解决问题。无论他们创建多少Github issues，似乎每一个issue都会变得越来越长。&lt;br&gt;&lt;br&gt;所有的这些讨论都会带来下面几个负面后果：&lt;br&gt;&lt;br&gt;1. 对于那些在讨论中想推动共识的人来说，会变得筋疲力尽&lt;br&gt;2. 对于真正有新见解的用户来说，参与变得更加困难。&lt;br&gt;3. 新加入讨论的新人，和已经知道大部分上下文的人之间会造成冲突&lt;br&gt;&lt;br&gt;RFC流程没有达到它应有的效果。在改革这个过程之前，无船同志对于发起新的共识讨论（比如提出一个语言的新特性）感到非常不满意。&lt;br&gt;&lt;br&gt;&lt;b&gt;二 项目内部并没有顺利地协调&lt;/b&gt;&lt;br&gt;&lt;br&gt;为了保证连贯的用户体验，Rust需要在不同的方面拥有一致的设计愿景。在过去，团队成员低于30人时，共享愿景可以自然地在整个项目中传播。但是随着团队规模的增加，现在这种愿景在团队中共享起来就遭遇了很多问题。现在需要一个积极的专门用来处理和设计相关决策信息、模式和框架了。今年无船同志就遇到了因为没有统一的指导方针而发生的分歧的问题。所以现在可以考虑重新核心团队的组织，并认识到团队之间协调的重要性。&lt;/p&gt;&lt;p&gt;&lt;b&gt;三 团队正在经历成长之痛&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Rust项目管理主要由负责项目的各个领域的各个团队执行。无船同志是其中三个团队的成员。他感受到了这三个团队内部的成长之痛：&lt;br&gt;&lt;br&gt;1. 对团队的成员分解为更小的团队来分解任务，比如工具和基础设施团队已经分解了五个小团队，这是为了解决任务模糊的问题，便于各负其责。但是分解小团队可能并未解决具体的问题。&lt;br&gt;2. 与此同时，团队常常会没有方向感，没有特定的目标。&lt;br&gt;3. 随着团队成员的增加，成员的日程安排、同步协调等方面都不是很有效。&lt;br&gt;4. 并且团队的共享知识也很难转移给新来的成员，因为还没有有意识的来执行这个事情。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;四  工作组需要工具包&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;需要将工作组的工作方式抽象为其他人可以使用的标准模板或流程，当然更重要的是需要有协调和领导力的人进入工作组。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;五 社区管理让人身心疲惫&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;需要一个高于社区行为准则的标准来规范参与Rust项目的工作，用于强制性地进行专业意见的交流，让沟通更加高效。社区的行为准则只是规范社区内成员随意互动的标准。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;六  是时候讨论薪酬了&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;并不是无船同志想涨薪了，而是他看到现在开源社区很多志愿者投入了大量时间但并没有报酬，完全是为了兴趣或学习而进入社区。但很多人应该用一种长远的眼光来看Rust，它在未来会带来就业发展的回报。&lt;br&gt;&lt;br&gt;但随着生活状态的变化，很多可以推动重要项目的志愿者已经退出，导致Rust的很多工作进展都不太顺利。只有拥有大量空闲时间和信心的人才能作为志愿者大力参与。现在的开源贡献者，其实都是资产阶级中的“无产”阶级。也许成立「Rust基金会」是一个办法。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在找到解决问题的办法之前，必须先正视这些问题，承认它们的确存在。还清组织债务，只需要重新设计决策过程，重新组织治理结构，建立新的沟通规范，并找到一种方法来将大量资金转向Rust贡献者。&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-17-52568974</guid>
<pubDate>Mon, 17 Dec 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
