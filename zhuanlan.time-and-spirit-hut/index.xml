<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>时光与精神小屋</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Sat, 22 Dec 2018 13:40:44 +0800</lastBuildDate>
<item>
<title>Rust Quiz 解读：Quiz 21</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-21-52986963.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52986963&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;&lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;br&gt; - &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;br&gt;&lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz  21:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Trait {
    fn f(&amp;amp;self);
}

impl&amp;lt;F: FnOnce() -&amp;gt; bool&amp;gt; Trait for F {
    fn f(&amp;amp;self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for () {
    fn f(&amp;amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let x = || { (return) || true; };
    x().f();

    let x = loop { (break) || true; };
    x.f();

    let x = || { return (|| true); };
    x().f();

    let x = loop { break (|| true); };
    x.f();

    let x = || { return || true; };
    x().f();

    let x = loop { break || true; };
    x.f();
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 221111&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;return和break的区别&lt;/li&gt;&lt;li&gt;闭包实现和闭包调用&lt;/li&gt;&lt;li&gt;优先级&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Quiz 代码中定义了Trait和一个泛型实现，该泛型实现中包含了限定 &lt;code class=&quot;inline&quot;&gt;&amp;lt;F: FnOnce() -&amp;gt; bool&amp;gt;&lt;/code&gt;，其意义是，只有&lt;code class=&quot;inline&quot;&gt;FnOnce() -&amp;gt; bool&lt;/code&gt;闭包才可以调用&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;函数。&lt;/p&gt;&lt;p&gt;同样为单元类型&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;也实现了Trait。&lt;/p&gt;&lt;p&gt;接下来依次看main函数中的代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let x = || { (return) || true; };
x().f(&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;绑定右侧，整体是一个闭包，当该闭包调用的时候，其闭包体内部的&lt;code class=&quot;inline&quot;&gt;{(return) || true; }&lt;/code&gt;是一个完整的或操作表达式。不过，&lt;code class=&quot;inline&quot;&gt;(return)&lt;/code&gt;首先会返回&lt;code class=&quot;inline&quot;&gt;（）&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;所以，当调用&lt;code class=&quot;inline&quot;&gt;x()&lt;/code&gt;的时候，会返回&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;。这里需要注意的是，闭包调用语法。由闭包的名称紧跟括号来调用闭包。所以，&lt;code class=&quot;inline&quot;&gt;x().f()&lt;/code&gt;，实际上就是调用闭包的返回值&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;f()&lt;/code&gt;方法，输出结果是&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let x = loop { (break) || true; };
 x.f();&lt;/code&gt;&lt;p&gt;这两行代码中的x，是绑定了，从loop循环中通过&lt;code class=&quot;inline&quot;&gt;break&lt;/code&gt;关键字返回的单元值&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;。因为这里是&lt;code class=&quot;inline&quot;&gt;(break)&lt;/code&gt;，通过括号将&lt;code class=&quot;inline&quot;&gt;break&lt;/code&gt;做为了一个独立的表达式，和上面的&lt;code class=&quot;inline&quot;&gt;(return)&lt;/code&gt;类似。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;let x = || { return (|| true); };
x().f();&lt;/code&gt;&lt;p&gt;这里很明显，当闭包x被调用之后，返回的是&lt;code class=&quot;inline&quot;&gt;|| true&lt;/code&gt;这个闭包。这个闭包是实现了&lt;code class=&quot;inline&quot;&gt;FnOnce()-&amp;gt;bool&lt;/code&gt;的闭包，所以&lt;code class=&quot;inline&quot;&gt;x().f()&lt;/code&gt;这里是调用有&lt;code class=&quot;inline&quot;&gt;&amp;lt;F: FnOnce()-&amp;gt;bool&amp;gt;&lt;/code&gt;限定的泛型实现中的&lt;code class=&quot;inline&quot;&gt;f()&lt;/code&gt;方法，所以输出&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;let x = loop { break (|| true); };
x.f();&lt;/code&gt;&lt;p&gt;这里的break和上面的return相似，返回的依然是闭包。同理，输出&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;let x = || { return || true; };
x().f();&lt;/code&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;return&lt;/code&gt;关键字来说，这里不加括号和加括号的效果是一样的，所以，还是返回闭包。输出依然是&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;let x = loop { break || true; };
 x.f();&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;break&lt;/code&gt;在这里和&lt;code class=&quot;inline&quot;&gt;return&lt;/code&gt;相同，返回闭包，输出为&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;回想Quiz 20中&lt;code class=&quot;inline&quot;&gt;break&lt;/code&gt;的用法，可以把最后这两行代码改一下：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;// 修改1
let x = loop { break { || true }; };
x.f();

// 修改2
let x = loop { break { || true } };
x.f();

// 修改3
let x = loop { break { || true; } };
x.f();&lt;/code&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;修改1&lt;/code&gt;来说，&lt;code class=&quot;inline&quot;&gt;break&lt;/code&gt;后面加了&lt;code class=&quot;inline&quot;&gt;{ ... }&lt;/code&gt;块。其实在Rust中，块（block）也是一个表达式。所以，&lt;code class=&quot;inline&quot;&gt;修改1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;修改2&lt;/code&gt;其实是等价的，在块后面加不加分号类似。最终break会将闭包&lt;code class=&quot;inline&quot;&gt;|| true&lt;/code&gt;返回。&lt;/p&gt;&lt;p&gt;所以，&lt;code class=&quot;inline&quot;&gt;修改1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;修改2&lt;/code&gt;都是输出&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。但是&lt;code class=&quot;inline&quot;&gt;修改3&lt;/code&gt;的结果就不一样了。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;修改3&lt;/code&gt;中，&lt;code class=&quot;inline&quot;&gt;|| true&lt;/code&gt;后面加了分号&lt;code class=&quot;inline&quot;&gt;;&lt;/code&gt;，对于块表达式来说，它的求值结果必然是&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;。因为在Rust中，加分号的表达式，都会返回&lt;code class=&quot;inline&quot;&gt;()&lt;/code&gt;。所以，&lt;code class=&quot;inline&quot;&gt;修改3&lt;/code&gt;会输出&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/21&quot;&gt;点此查看 Rust Quiz 21&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-21-52986963</guid>
<pubDate>Fri, 21 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 20</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-19-52772684.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52772684&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;&lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;&lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz  20:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn return1() {
    if (return { print!(&quot;1&quot;) }) {
    }
}

fn return2() {
    if return { print!(&quot;2&quot;) } {
    }
}

fn break1() {
    loop {
        if (break { print!(&quot;1&quot;) }) {
        }
    }
}

fn break2() {
    loop {
        if break { print!(&quot;2&quot;) } {
        }
    }
}

fn main() {
    return1();
    return2();
    break1();
    break2();
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 121&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;return和break的一点区别&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;其实在Rust 1.19版本之前，上面代码的输出结果是&lt;code class=&quot;inline&quot;&gt;1212&lt;/code&gt;。但是在1.19之后，加入了&lt;code class=&quot;inline&quot;&gt;break value in loop&lt;/code&gt;的功能，也就是说，可以从loop循环中使用break返回一个值。&lt;/p&gt;&lt;p&gt;对于&lt;code class=&quot;inline&quot;&gt;break1&lt;/code&gt;函数来说：&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;loop {  if (break { print!(&quot;1&quot;) }) {}}&lt;/code&gt;，会先计算&lt;code class=&quot;inline&quot;&gt;break {print!(&quot;1&quot;)}&lt;/code&gt;的值。&lt;/p&gt;&lt;p&gt;而&lt;code class=&quot;inline&quot;&gt;break2&lt;/code&gt;函数，因为没有使用括号来表达优先级，所以会解析为以下等价的代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn break2() {
    loop {
        if (break) { 
            print!(&quot;2&quot;) 
        }
        { }
    }
}&lt;/code&gt;&lt;p&gt;所以，在打印之前就已经&lt;code class=&quot;inline&quot;&gt;break&lt;/code&gt;出了循环体，所以什么都没打印。&lt;/p&gt;&lt;p&gt;而return就不会产生这种解释歧义，等以后Rust可能会统一break和return的行为。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/20&quot;&gt;点此查看 Rust Quiz 20&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-19-52772684</guid>
<pubDate>Wed, 19 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 19</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-18-52661087.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52661087&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;b&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;/b&gt; &lt;br&gt;&lt;b&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;/b&gt; &lt;br&gt;&lt;b&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;/b&gt; &lt;br&gt;&lt;br&gt;&lt;b&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/b&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 19:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S;

impl Drop for S {
    fn drop(&amp;amp;mut self) {
        print!(&quot;1&quot;);
    }
}

fn main() {
    let s = S;
    let _ = s;
    print!(&quot;2&quot;);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果：21&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;所有权和drop&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;_&lt;/code&gt;并没有所有权&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我想把这个例子重新修改一下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;#[derive(Debug)]
struct S;

impl Drop for S {
    fn drop(&amp;amp;mut self) {
        print!(&quot;1&quot;);
    }
}

fn main() {
    let s = S;
    let _ = s;
    print!(&quot;{:?}&quot;, s)
}&lt;/code&gt;&lt;p&gt;执行该代码输出结果为&lt;code class=&quot;inline&quot;&gt;S1&lt;/code&gt;。重点在main函数最后一行打印语句中，在执行了&lt;code class=&quot;inline&quot;&gt;let _ = s;&lt;/code&gt;之后，还可以使用&lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt;。这说明，&lt;code class=&quot;inline&quot;&gt;s&lt;/code&gt;的所有权并未被转移。&lt;/p&gt;&lt;p&gt;所以，先打印的是&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;。等main函数执行完，&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的drop方法会被自动调用，然后打印&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;现在可以回顾一下Quiz代码，想想为什么输出`21`。&lt;/p&gt;&lt;p&gt;&lt;b&gt;继续改一下代码：&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() {
    let s = S;
    let _a = s;
    print!(&quot;{:?}&quot;, s)
}&lt;/code&gt;&lt;p&gt;这一次只改main函数，将&lt;code class=&quot;inline&quot;&gt;_&lt;/code&gt;变成&lt;code class=&quot;inline&quot;&gt;_a&lt;/code&gt;，执行代码的时候出错了：&lt;code class=&quot;inline&quot;&gt;error[E0382]: use of moved value:&lt;/code&gt;s&lt;code class=&quot;inline&quot;&gt;`。说明&lt;/code&gt;s&lt;code class=&quot;inline&quot;&gt;的所有权已经被转移了。 看来&lt;/code&gt;_&lt;code class=&quot;inline&quot;&gt;和&lt;/code&gt;_a`的行为是不一样的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;继续简化代码来查看生成的mir：&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// mir示例1
struct S;
fn main() {
    let s = S;
    let _ = s;
}

// mir示例2
struct S;
fn main() {
    let s = S;
    let _a = s;
}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;mir示例1&lt;/code&gt;会生成下面的mir代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() -&amp;gt; (){
    let mut _0: ();                      // return place
    scope 1 {
    }
    scope 2 {
        let _1: S;                       // &quot;s&quot; in scope 2 at src/main.rs:4:9: 4:10
    }

    bb0: {                              
        StorageLive(_1);                 // bb0[0]: scope 0 at src/main.rs:4:9: 4:10
        StorageDead(_1);                 // bb0[1]: scope 0 at src/main.rs:6:1: 6:2
        return;                          // bb0[2]: scope 0 at src/main.rs:6:2: 6:2
    }
}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;mir示例2&lt;/code&gt;则生成下面的mir代码：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() -&amp;gt; (){
    let mut _0: ();                      // return place
    scope 1 {
        scope 3 {
        }
        scope 4 {
            let _2: S;                   // &quot;_a&quot; in scope 4 at src/main.rs:5:9: 5:11
        }
    }
    scope 2 {
        let _1: S;                       // &quot;s&quot; in scope 2 at src/main.rs:4:9: 4:10
    }

    bb0: {                              
        StorageLive(_1);                 // bb0[0]: scope 0 at src/main.rs:4:9: 4:10
        StorageLive(_2);                 // bb0[1]: scope 1 at src/main.rs:5:9: 5:11
        _2 = move _1;                    // bb0[2]: scope 1 at src/main.rs:5:14: 5:15
        StorageDead(_2);                 // bb0[3]: scope 1 at src/main.rs:6:1: 6:2
        StorageDead(_1);                 // bb0[4]: scope 0 at src/main.rs:6:1: 6:2
        return;                          // bb0[5]: scope 0 at src/main.rs:6:2: 6:2
    }
}&lt;/code&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;示例1&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;示例2&lt;/code&gt;的区别，正是&lt;code class=&quot;inline&quot;&gt;_&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;_a&lt;/code&gt;的区别。&lt;code class=&quot;inline&quot;&gt;_a&lt;/code&gt;多了一次move操作：&lt;code class=&quot;inline&quot;&gt;_2 = move _1;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;最后再改一下Quiz代码：&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S;

impl Drop for S {
    fn drop(&amp;amp;mut self) {
        print!(&quot;1&quot;);
    }
}

fn main() {
    let s = S;
    drop(s);
    print!(&quot;2&quot;);
}&lt;/code&gt;&lt;p&gt;输出结果是： &lt;code class=&quot;inline&quot;&gt;12&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这里使用了&lt;code class=&quot;inline&quot;&gt;drop(s)&lt;/code&gt;，未转移所有权，也未绑定任何变量，直接drop。所以，会在打印语句之前调用drop方法，先输出&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/19&quot;&gt;点此查看 Rust Quiz 19&lt;/a&gt; &lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-18-52661087</guid>
<pubDate>Tue, 18 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 18</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-17-52609791.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52609791&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;&lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;&lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 18:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S {
    f: fn(),
}

impl S {
    fn f(&amp;amp;self) {
        print!(&quot;1&quot;);
    }
}

fn main() {
    let print2 = || print!(&quot;2&quot;);
    S { f: print2 }.f();
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 1&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;闭包调用&lt;/li&gt;&lt;li&gt;结构体字段和函数调用的优先级&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Quiz代码中实现了结构体S，包含一个类型为&lt;code class=&quot;inline&quot;&gt;fn()&lt;/code&gt;的函数指针字段。然后为S实现了同样名为&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;的方法。&lt;/p&gt;&lt;p&gt;在main函数中，定义了闭包print2。然后main中最后一行代码就开始迷惑人了。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;S {f: print2 }.f();&lt;/code&gt;&lt;/p&gt;&lt;p&gt;如果你没有关注结构体字段名也是f，并且它是个函数指针类型，也罢。你就不会想太多。一眼看上去就是调用&lt;code class=&quot;inline&quot;&gt;S&lt;/code&gt;的结构体实例的&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;方法。输出结果是&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。那么正好答对了。&lt;/p&gt;&lt;p&gt;但是，如果你如果注意到&lt;code class=&quot;inline&quot;&gt;print2&lt;/code&gt;闭包也可以作为一个函数指针。那么为什么不是&lt;code class=&quot;inline&quot;&gt;(S {f: print2 }.f)()&lt;/code&gt;呢？&lt;/p&gt;&lt;p&gt;不好意思，如果你想调用闭包，那么最好显式地加上括号告诉编译器你是想调用闭包。就像这样：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S {
    f: fn(),
}

impl S {
    fn f(&amp;amp;self) {
        print!(&quot;1&quot;);
    }
}

fn main() {
    let print2 = || print!(&quot;2&quot;);
    (S { f: print2 }.f)();
}&lt;/code&gt;&lt;p&gt;这样输出结果就是&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;否则，编译器在这里，只认函数调用。如果不信的话，你把&lt;code class=&quot;inline&quot;&gt;impl S { ... }&lt;/code&gt;代码删除以后看看：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct S {
    f: fn(),
}

fn main() {
    let print2 = || print!(&quot;2&quot;);
    S { f: print2 }.f();
}&lt;/code&gt;&lt;p&gt;编译器会报错：&lt;code class=&quot;inline&quot;&gt;error[E0599]: no method named&lt;/code&gt;f&lt;code class=&quot;inline&quot;&gt;found for type&lt;/code&gt;S&lt;code class=&quot;inline&quot;&gt;in the current scope&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;点此查看 Rust Quiz 18&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-17-52609791</guid>
<pubDate>Mon, 17 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 17</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-17-52608592.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52608592&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;&lt;br&gt;-  &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;br&gt;&lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 17:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() {
    let mut a = 5;
    let mut b = 3;
    print!(&quot;{}&quot;, a-- - --b);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果: 2&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;和Quiz16代码一样，Rust中不存在自增或自减运算符&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;a-- - --b&lt;/code&gt;等价于&lt;code class=&quot;inline&quot;&gt;a - (-(-(-(-b))))&lt;/code&gt; ，&lt;code class=&quot;inline&quot;&gt;5 - 3 = 2&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;那为什么Rust中没有自增/自减运算符呢？&lt;/p&gt;&lt;p&gt;在Rust官方的FAQ中有描述：&lt;/p&gt;&lt;blockquote&gt; 先增和后增（以及相对应的减法）虽然方便，但也相当复杂。它们都需要求值顺序的知识，而且经常导致 C 和 C++ 中的细节错误和未定义的行为。 x = x + 1 或 x += 1 只是略长一点，但更加明确。  &lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;Rust新官网已经没有了FAQ页面，查看需要从旧官网入口进入：&lt;a href=&quot;https://prev.rust-lang.org/zh-CN/faq.html#why-doesnt-rust-have-increment-and-decrement-operators&quot;&gt;常见问题解答 · Rust 程序设计语言&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/17&quot;&gt;点此查看 Rust Quiz 17&lt;/a&gt; &lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-17-52608592</guid>
<pubDate>Mon, 17 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 16</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-17-52607988.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52607988&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;-   &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;br&gt;-   &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;br&gt;-   &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt;&lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 16:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn main() {
    let mut x = 4;
    --x;
    print!(&quot;{}{}&quot;, --x, --x);
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果：44&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Rust里不存在C语言中的&lt;code class=&quot;inline&quot;&gt;++i/--i&lt;/code&gt;自增/自减运算符&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;当看到&lt;code class=&quot;inline&quot;&gt;--x&lt;/code&gt;中，可能会有所迷惑。Rust中并不存在自增/自减运算符。所以，Rust编译器怎么解析这个操作呢？答案是&lt;code class=&quot;inline&quot;&gt;-(-x)&lt;/code&gt;。将&lt;code class=&quot;inline&quot;&gt;-&lt;/code&gt;按负号进行解析，而非减号。&lt;/p&gt;&lt;p&gt;负负得正，所以结果是4。然后输出的时候，打印了两次，就是44。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/16&quot;&gt;点此查看 Rust Quiz 16&lt;/a&gt; &lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-17-52607988</guid>
<pubDate>Mon, 17 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「内部视角」Rust团队内的组织债务</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-17-52568974.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52568974&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5e37612217a05e23ca21433c769d22e4_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;官方核心团队成员无船同志在本文中阐述了他对Rust 2019的看法。该文主要谈到了组织治理，Rust自身作为一个开源项目，也可以把它看作一个成长中的初创「产品」，不免会遇到成长之痛。作为Rust团队的内部成员，无船同志以他的视角来分析了Rust组织内部产生的问题，对于我们也是一种警示和学习。&lt;br&gt;&lt;br&gt;原文: &lt;a href=&quot;https://boats.gitlab.io/blog/post/rust-2019/&quot;&gt;Organizational Debt&lt;/a&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;首先，他肯定希望Rust会有更多的技术改进，而且他也会为之付出精力。但是，他认为2019最重要的问题不在于技术改进，而是组织债务（Organizational Debt）。&lt;br&gt;&lt;br&gt;什么是组织债务？它是和技术债务平行的一个名词。我节选一段infoq文章中的阐述：&lt;/p&gt;&lt;blockquote&gt; “组织债务”是在公司层面上是与技术债务平行的。如果技术债务是软件中妨害维护的问题，那么组织债务就是妨碍组织在日常运转中流畅运作的问题。他列举了如下几个组织债务的例子：&lt;br&gt; 1. 解决同一个问题，不同的部门都有自己的工具和方法，这使得主管们很难看到相似之处，以便解决公司层面的问题。&lt;br&gt; 2. 经理们创建的过程或实现的软件解决方案在当时看来似乎是个不错的注意，但却没有消除问题产生的根本原因，长期来看，最终造成了更多的问题。&lt;br&gt; 3. 由于时间特别紧，团队决定“本次”以一种并不是最理想的方式完成一项任务。但是，那种方式后续被重复使用，因为没有人记得第一次原本是打算当作一种一次性方案。&lt;br&gt;&lt;br&gt;&lt;br&gt;更通俗一点的描述：&lt;br&gt;&lt;br&gt; 所谓的组织债务就是初创公司为了「把事情搞定」而做出的所有人事/文化妥协。这些债务会在一定阶段爆发，比如公司融到了新一轮的钱/公司的战略方向调整/公司的人事扩张。这在一定程度上比「技术债务」更难处理，毕竟「技术债务」你面向的是工程/代码，而「组织债务」面向的是人。&lt;/blockquote&gt;&lt;p&gt;组织债务影响的是能否可持续发展的问题。&lt;br&gt;&lt;br&gt;无船同志认为，Rust项目在过去的几年里，一直像创业公司一样成长，虽然有很多好的方面，但也有一些糟糕的问题，如果这个项目想长期地维持下去，必须真正处理到目前已经积累起来的组织债务。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;以下是无船同志罗列出来要解决的问题：&lt;/b&gt;&lt;/h2&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;一 使用GitHub issues来讨论设计就像是从消防栓里喝水&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c2c81fbbfde7d6077941414a08078788_r.jpg&quot; data-rawwidth=&quot;574&quot; data-rawheight=&quot;264&quot; data-size=&quot;normal&quot; data-caption=&quot;drinking from a firehose&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-c2c81fbbfde7d6077941414a08078788&quot; data-watermark-src=&quot;v2-26a8d58d69230e69a1b990b0006f08d6&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;无船同志统计了关于Pin API讨论的issues中评论数，一共有770条评论，还不算是reddit、irc或discord中的聊天记录。Rust虽然是他的全职工作，但是他发现还跟不上团队内其他人的设计讨论。&lt;br&gt;&lt;br&gt;其实Pin API虽然重要，但最终也是一个比较小的标准API添加，其中并没有包括关于异步、生成器或Futures的讨论。当这个主题高达770条评论的时候，谁有心思看完呢？包括参与评论的人也是，而且经常要对一个比较模糊的概念重新进行解释，这样每一条加入讨论的评论，都算是一种债务。更糟糕的是，将这些讨论再分解为更多的子问题，也无法解决问题。无论他们创建多少Github issues，似乎每一个issue都会变得越来越长。&lt;br&gt;&lt;br&gt;所有的这些讨论都会带来下面几个负面后果：&lt;br&gt;&lt;br&gt;1. 对于那些在讨论中想推动共识的人来说，会变得筋疲力尽&lt;br&gt;2. 对于真正有新见解的用户来说，参与变得更加困难。&lt;br&gt;3. 新加入讨论的新人，和已经知道大部分上下文的人之间会造成冲突&lt;br&gt;&lt;br&gt;RFC流程没有达到它应有的效果。在改革这个过程之前，无船同志对于发起新的共识讨论（比如提出一个语言的新特性）感到非常不满意。&lt;br&gt;&lt;br&gt;&lt;b&gt;二 项目内部并没有顺利地协调&lt;/b&gt;&lt;br&gt;&lt;br&gt;为了保证连贯的用户体验，Rust需要在不同的方面拥有一致的设计愿景。在过去，团队成员低于30人时，共享愿景可以自然地在整个项目中传播。但是随着团队规模的增加，现在这种愿景在团队中共享起来就遭遇了很多问题。现在需要一个积极的专门用来处理和设计相关决策信息、模式和框架了。今年无船同志就遇到了因为没有统一的指导方针而发生的分歧的问题。所以现在可以考虑重新核心团队的组织，并认识到团队之间协调的重要性。&lt;/p&gt;&lt;p&gt;&lt;b&gt;三 团队正在经历成长之痛&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Rust项目管理主要由负责项目的各个领域的各个团队执行。无船同志是其中三个团队的成员。他感受到了这三个团队内部的成长之痛：&lt;br&gt;&lt;br&gt;1. 对团队的成员分解为更小的团队来分解任务，比如工具和基础设施团队已经分解了五个小团队，这是为了解决任务模糊的问题，便于各负其责。但是分解小团队可能并未解决具体的问题。&lt;br&gt;2. 与此同时，团队常常会没有方向感，没有特定的目标。&lt;br&gt;3. 随着团队成员的增加，成员的日程安排、同步协调等方面都不是很有效。&lt;br&gt;4. 并且团队的共享知识也很难转移给新来的成员，因为还没有有意识的来执行这个事情。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;四  工作组需要工具包&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;需要将工作组的工作方式抽象为其他人可以使用的标准模板或流程，当然更重要的是需要有协调和领导力的人进入工作组。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;五 社区管理让人身心疲惫&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;需要一个高于社区行为准则的标准来规范参与Rust项目的工作，用于强制性地进行专业意见的交流，让沟通更加高效。社区的行为准则只是规范社区内成员随意互动的标准。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;六  是时候讨论薪酬了&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;并不是无船同志想涨薪了，而是他看到现在开源社区很多志愿者投入了大量时间但并没有报酬，完全是为了兴趣或学习而进入社区。但很多人应该用一种长远的眼光来看Rust，它在未来会带来就业发展的回报。&lt;br&gt;&lt;br&gt;但随着生活状态的变化，很多可以推动重要项目的志愿者已经退出，导致Rust的很多工作进展都不太顺利。只有拥有大量空闲时间和信心的人才能作为志愿者大力参与。现在的开源贡献者，其实都是资产阶级中的“无产”阶级。也许成立「Rust基金会」是一个办法。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结：&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在找到解决问题的办法之前，必须先正视这些问题，承认它们的确存在。还清组织债务，只需要重新设计决策过程，重新组织治理结构，建立新的沟通规范，并找到一种方法来将大量资金转向Rust贡献者。&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-17-52568974</guid>
<pubDate>Mon, 17 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>「Rust每日新闻」本周精选 • 第二十四期</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-16-52509923.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52509923&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-23599072636a1820bba7b49b9d586092_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;前言：&lt;br&gt;&lt;br&gt;从2018年开始，我每天会花1个小时关注Rust社区动态，并且在&lt;a href=&quot;http://rust.cc/&quot;&gt;Rust.CC论坛&lt;/a&gt;、&lt;a href=&quot;https://t.me/rust_daily_news&quot;&gt;tg channel&lt;/a&gt;、&lt;a href=&quot;https://steemit.com/@blackanger&quot;&gt;Steemit&lt;/a&gt;、&lt;a href=&quot;https://github.com/RustStudy/rust_daily_news&quot;&gt;GitHub&lt;/a&gt;、&lt;a href=&quot;https://www.yuque.com/chaosbot/rustnews&quot;&gt;语雀订阅&lt;/a&gt;都开通了Rust每日新闻，分享我每天的见闻，偶尔也夹杂了一些个人的观点。大半年过去了，Rust每日新闻已经成为了Rust社区群大家每天必看的内容。在这个知乎专栏里，每周会精选几篇Rust社区中的动态，和大家分享。分享的内容就不按时间排序了。&lt;br&gt;&lt;br&gt;2018-12-16&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;「付费阅读」系列&lt;/b&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/51479889&quot;&gt;如何为Rust语言做贡献&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52032027&quot;&gt;Rust Quiz 11&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;官方新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;官方核心成员nrc对Rust 2021 Edition的思考：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52181046&quot;&gt;Rust 2022&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「官方网络工作组」异步进展&lt;/h2&gt;&lt;h2&gt;async&lt;/h2&gt;&lt;p&gt;虽然Rust 2018发布的时候没有稳定异步编程，但在今年，异步编程也取得了很大进展。网络工作组发文，介绍了几个促进Nightly生态中使用async/await的crate。&lt;/p&gt;&lt;p&gt;async/await对Rust的重要性：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;async/await在其他语言中已经证明了其可用性&lt;/li&gt;&lt;li&gt;在Rust中引入async/await中需要多考虑一个元素：借用。所以，之前在编写异步代码的时候，必须使用&lt;code class=&quot;inline&quot;&gt;&#39;static&lt;/code&gt;限定，并且还经常要用到Arc和Mutex。&lt;/li&gt;&lt;li&gt;async/await语法稳定之后，将不会有「借用」相关的问题。但是在这之前，还有很多工作要做，比如稳定await语法。现在google的Fuchsia项目已经在大规模使用async/await语法了。&lt;/li&gt;&lt;li&gt;标准库中支持Future等trait的工作也即将完成。&lt;/li&gt;&lt;li&gt;确定了各种API，包括Waker、Pin、与tokio兼容的futures-rs 0.1等。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;发布了一些新的crate：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/withoutboats/romio&quot;&gt;romio&lt;/a&gt;，之前介绍过，是对tokio最小化包装，为了支持async/await。&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://docs.rs/http-service&quot;&gt;http-service&lt;/a&gt;， 一个基于字节的、http和新的futures API的crate，提供HTTP通用接口。是从Tide库中提取出来的API。&lt;/li&gt;&lt;li&gt;Tyger，即将推出的这个库是在Hyper上面构建的一个小的crate。提供直接的HTTP服务接口，因此可以直接使用async/await。Tyger也会对Hyper增加一些补充，提供一些更高级的抽象。也是从Tide中提取出来的包。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;官方希望在2019年上半年稳定async/await。官方所考虑的不仅仅是支持这个语法，而且还在为打造async/await生态做足了准备。这也是异步编程支持如此缓慢的原因。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://rust-lang-nursery.github.io/wg-net/2018/12/13/async-update.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;社区新闻&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;OS2ATC2018(第六届开源操作系统年度会议)会议现场直播链接&lt;/h2&gt;&lt;p&gt;现在的topic： 《Design &amp;amp; Implementation of uCore Plus OS in Rust Lang》（清华大学ucore操作系统课程升级Rust教学）&lt;/p&gt;&lt;p&gt;https://flypage.chinamcloud.com/h5/tpl/index.html?id=6469&amp;amp;tid=810&lt;/p&gt;&lt;p&gt;日程： http://soft.cs.tsinghua.edu.cn/os2atc2018/rc.html&lt;/p&gt;&lt;h2&gt;「安全」Crossbeam发现double-free Bug&lt;/h2&gt;&lt;blockquote&gt; MsQueue和SegQueue会发生此Bug。 即使从队列中弹出一个元素，crossbeam也会运行它，此问题来自于crossbeam-epoch的垃圾收集器内的析构函数。 &lt;br&gt; &lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/RustSec/advisory-db/blob/master/crates/crossbeam/RUSTSEC-2018-0009.toml&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;crev: 代码审查工具箱&lt;/h2&gt;&lt;p&gt;提供了一个cargo工具：&lt;a href=&quot;https://github.com/dpc/crev/tree/master/cargo-crev&quot;&gt;cargo-crev&lt;/a&gt;&lt;/p&gt;&lt;p&gt;该工具可以判断你项目中依赖crate的安全性、质量和发现的问题。可以在公共的git仓库里发布可验证的review信息。通过这种方式期望在Rust生态系统中构建可信任的网络。将不会有人再受到未经审查和不受信任代码的困扰。&lt;/p&gt;&lt;p&gt;想想npm因为依赖包出了多少次安全事故。这个工具ms不错，但是否真的可以解决问题？&lt;/p&gt;&lt;p&gt;使用方法：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;cd &amp;lt;your-project&amp;gt;
cargo crev id gen # generate your id
cargo crev verify # verify your depedencies
cargo crev review &amp;lt;crate&amp;gt; # review a dependency
cargo crev db git status # check git status of your proof database
cargo crev db git -- ci -a # commit everything
cargo crev db git push # push it to your github repository
cargo crev trust &amp;lt;id&amp;gt; # trust someone with a given CrevId
cargo crev db fetch # fetch updates from all people you trust
cargo crev verify # verify again
cargo crev help # see what other things you can do&lt;/code&gt;&lt;p&gt;其中id是可以通过&lt;a href=&quot;https://gitter.im/dpc/crev&quot;&gt;crev gitter channel&lt;/a&gt;来共享给大家的，形成信任网络。然后可以通过 &lt;code class=&quot;inline&quot;&gt;cargo crev trust &amp;lt;id&amp;gt;&lt;/code&gt;命令从你信任的人那里获取依赖crate。&lt;/p&gt;&lt;p&gt;当然，这世界上没有绝对的安全，但也无法阻碍人们追求它的脚步。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/dpc/crev&quot;&gt;crev&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust非常适合高性能科学计算&lt;/h2&gt;&lt;p&gt;来自某粒子物理实验室的软件性能工程师Hadrien坦言，相比于Cpp，Rust更适合高性能科学计算。并且对Rust能进入这个领域之前需要完善的工作提出了他自己的建议，同时也希望Rust 2019的目标之一可以是「高性能科学计算」。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://gist.github.com/HadrienG2/e9a875bdf98b528594f4e20f8176bb68&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;杭州Rust线下Meetup回放视频&lt;/h2&gt;&lt;p&gt;一共两场分享，视频地址是第二场分享，在列表里也能找到另外一场分享的视频。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av38044021/?share_source=qq&amp;amp;ts=1544706808&amp;amp;share_medium=iphone&amp;amp;bbid=dd199f5b7049675783521db5317f49ba&quot;&gt;Bilibili&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;使用Rust和WebAssembly进行edge计算&lt;/h2&gt;&lt;p&gt;什么是边缘计算？ 边缘计算将数据的处理、应用程序的运行甚至一些功能服务的实现，由网络中心下放到网络边缘的节点上。属于一种分布式计算。一直以来，公共和企业设施的监测和维护消耗着大量的人力、物力成本；电力、制造等行业数字化转型中对海量数据的实时、智能处理也有着强烈需求。如果用常规模式构建物联网，所有数据都交给云端，那么会带来一系列的问题。边缘计算就是为了解决这个问题。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.fastlylabs.com/&quot;&gt;fastlylabs&lt;/a&gt;公司，推出了一个产品Terrarium（看着像是用webassembly.studio改造的），是一个基于浏览器的多语言编辑和部署平台。据该公司描述，此产品是为了推进边缘计算。Terrarium是基于WebAssembly沙箱而构建。Terrarium可以将几种不同的编程语言编译为WebAssembly，然后将其编译为快速，安全的本地代码，并用于为Web服务提供动力。&lt;/p&gt;&lt;p&gt;本文介绍了如何用Rust和Terrarium进行编写边缘计算服务。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.fastly.com/blog/edge-programming-rust-web-assembly&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「趣味」Rust Raps: Rust 2018 Edition首张单曲发布&lt;/h2&gt;&lt;p&gt;由Rusta Rhymes推出的热门新单曲“Ferris Crab（Rust Raps 2018 Edition）”即将推出首张专辑“Drop for Mic”。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://fitzgeraldnick.com/media/rust-raps.mp3&quot;&gt;在线听&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://fitzgeraldnick.com/2018/12/13/rust-raps.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust开发的一款编程教学游戏预览&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-63e41a23be7999267843b7c023bebf14_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;690&quot; data-rawheight=&quot;389&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;v2-63e41a23be7999267843b7c023bebf14&quot; data-watermark-src=&quot;v2-6f63f7f5f828c1dfd9ec0712aef949fb&quot; data-private-watermark-src=&quot;&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.roboinstruct.us/2018/12/07/looking-good.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;学习资源&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;Rust Quiz解读已更新到Quiz 15&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/time-and-spirit-hut&quot;&gt;去专栏 Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust 异步函数内部转换流程&lt;/h2&gt;&lt;p&gt;本文介绍了Rust内部async/await的内部转换机制，包括generator、状态转换过程等。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blag.nemo157.com/2018/12/09/inside-rusts-async-transform.html&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;使用Cargo Test来Debug代码&lt;/h2&gt;&lt;p&gt;本文介绍了使用cargo test命令，结合单元测试来调试代码中的问题。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.wihlidal.com/blog/general/2018-12-07-debugging-cargo-test/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「系列博文」在浏览器中使用WASM Part 1&lt;/h2&gt;&lt;p&gt;本文介绍了如何使用Rust编译wasm，并在浏览器中使用它。同时也包括了wasm的工作机制，值得一看。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://ljcode.org/blog/wasm-part1/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;在AWS Lambda上面运行Rust&lt;/h2&gt;&lt;p&gt;本文以编写一个独立的crate为例，从代码编写到部署，介绍如何在AWS Lambda上面运行Rust库。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://kellenfujimoto.com/posts/dicers-rust-on-lambda/&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「嵌入式Rust」Cortex-M3 入门指南（一）：体系概述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52235675&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「视频」如何在Rust/C/C++/.Net中使用SIMD&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=4Gs_CA_vm3o&quot;&gt;youtube&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;用Rust为Kubernetes动态生成Dockerfiles&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/docql/dynamically-generating-dockerfiles-for-k8s-d2baf7bfef5a&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「Slides」在Rust中使用C的va_list&lt;/h2&gt;&lt;p&gt;以及，你为什么不应该用它。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://dlrobertson.com/slides/va-list-12-13-2018.html#/&quot;&gt;PPT&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/a6j4hu/using_cs_va_list_in_rust_and_why_you_never_should/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;项目&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;libui-rs: libui的Rust绑定&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/LeoTindall/libui-rs&quot;&gt;libui-rs&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;gba: 帮助你创建GBA游戏&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/rust-console/gba&quot;&gt;gba&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://rust-console.github.io/gba/&quot;&gt;gba book&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;NASA开源的静态分析工具: ikos&lt;/h2&gt;&lt;p&gt;虽然是为C/C++静态分析实现的工具，但据说也适用于LLVM IR，因此有助于检测Unsafe Rust的代码。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/NASA-SW-VnV/ikos&quot;&gt;ikos&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/rust/comments/a5kyz9/ikos_21_an_open_source_static_analyzer_from_nasa/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;seed: Rust+WebAssembly 前端框架&lt;/h2&gt;&lt;p&gt;基于wasm-bindgen和js-sys创建。创建应用时需要依赖web-sys。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/David-OConnor/seed&quot;&gt;seed&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;「区块链」comit-rs：Comit协议的Rust实现&lt;/h2&gt;&lt;p&gt;COMIT是一个协议，以链接不同的区块链。以便将区块链生态系统打造地更大，更具有包容性。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/comit-network/comit-rs&quot;&gt;comit-network/comit-rs&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;[WIP] Rust实现的Lua解释器&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kyren/luster&quot;&gt;luster&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust开发安全应用程序指南&lt;/h2&gt;&lt;p&gt;该指南不是Rust语言教程，只是记录Rust开发应用程序过程中可能出现的「坑」，特别是开发一些对安全性要求较高的程序需要注意的地方。该指南还在持续更新中。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/ANSSI-FR/rust-guide&quot;&gt;rust-guide&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/ANSSI-FR/rust-guide/blob/master/src/SUMMARY.md&quot;&gt;Online Read&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;使用Rust配置管理kubernetes&lt;/h2&gt;&lt;p&gt;本文作者使用Rust构建了一个用于管理k8s上运行的微服务声明格式和生命周期的标准化工具shipcat。它封装了k8s的API，目的是为了更加标准化、版本化、权限化、自动化管理k8s。本文阐述了k8s管理中的问题，以及shipcat的解决思路。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Babylonpartners/shipcat&quot;&gt;shipcat&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://clux.github.io/probes/post/2018-12-15-config-management-in-rust/&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;h2&gt;&lt;b&gt;工具与库&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;spirit教程&lt;/h2&gt;&lt;p&gt;spirit可以帮助开发者更容易地构建Unix守护进程。 文章里介绍了它的使用方法。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/vorner/spirit&quot;&gt;spirit&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://vorner.github.io/2018/12/09/Spirit-Tutorial.html&quot;&gt;Read More&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;parstream： 基于线程池以流方式计算迭代函数&lt;/h2&gt;&lt;p&gt;并且不会打乱迭代器中元素的顺序。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/newpavlov/parstream&quot;&gt;parstream&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;命令行使用频率跟踪工具fe&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ccheek21/fe&quot;&gt;fe&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;pom：又一个peg解析器&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/J-F-Liu/pom&quot;&gt;pom&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;支持no_std的Curve25519加密库&lt;/h2&gt;&lt;p&gt;椭圆曲线加密/签名/密钥交换算法Curve25519的 &lt;code class=&quot;inline&quot;&gt;#[no_std]&lt;/code&gt; 版本&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/shekohex/curve25519-rs&quot;&gt;Read More&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-16-52509923</guid>
<pubDate>Sun, 16 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 15</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-16-52508991.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52508991&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz&lt;br&gt;-  &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt;&lt;br&gt;-  &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt;&lt;br&gt;&lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。&lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 15:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Trait {
    fn f(&amp;amp;self);
}

impl Trait for u32 {
    fn f(&amp;amp;self) {
        print!(&quot;1&quot;);
    }
}

impl&amp;lt;&#39;a&amp;gt; Trait for &amp;amp;&#39;a i32 {
    fn f(&amp;amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let x = &amp;amp;0;
    x.f();
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果： 1&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;trait实现&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a T&lt;/code&gt;的区别&lt;/li&gt;&lt;li&gt;类型推断&lt;/li&gt;&lt;li&gt;自动加引用&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;其实Quiz 15和Quiz 5的考察点是相似的。主要是考察&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt; 和&lt;code class=&quot;inline&quot;&gt;&amp;amp;T&lt;/code&gt;有啥区别呢？虽然这里是&lt;code class=&quot;inline&quot;&gt;u32&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;&amp;amp;’a i32&lt;/code&gt;。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;T， 是一个泛型参数，代表任何一个具体的类型。&lt;/li&gt;&lt;li&gt;&amp;amp;T，实际上等价于&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a T&lt;/code&gt;，代表某个引用类型。注意这里的&lt;code class=&quot;inline&quot;&gt;&#39;a&lt;/code&gt;也是一个泛型参数，并不是指具体的类型。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;main函数中直接使用了&lt;code class=&quot;inline&quot;&gt;let x = &amp;amp;0;&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;&amp;amp;0&lt;/code&gt;实际上是一个包含了具体生命周期参数实例的具体类型&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a 0&lt;/code&gt;。所以，&lt;code class=&quot;inline&quot;&gt;&amp;amp;0&lt;/code&gt;实际上会被推断为一个具体的&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;类型的实例&lt;code class=&quot;inline&quot;&gt;u32&lt;/code&gt;。 &lt;/p&gt;&lt;p&gt;这和&lt;code class=&quot;inline&quot;&gt;impl Trait for ...&lt;/code&gt;的定义顺序无关。不妨把&lt;code class=&quot;inline&quot;&gt;impl&amp;lt;&#39;a&amp;gt; Trait for &amp;amp;&#39;a i32 { ... }&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;impl Trait for u32 { ... }&lt;/code&gt;的顺序交换，输出结果照样不变。&lt;/p&gt;&lt;p&gt;此时在&lt;code class=&quot;inline&quot;&gt;u32&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;方法实现中&lt;code class=&quot;inline&quot;&gt;self&lt;/code&gt;是&lt;code class=&quot;inline&quot;&gt;&amp;amp;u32&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;所以，&lt;code class=&quot;inline&quot;&gt;x.f()&lt;/code&gt;会输出&lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果把&lt;code class=&quot;inline&quot;&gt;impl Trait for u32 {}&lt;/code&gt;实现注释掉。则 &lt;code class=&quot;inline&quot;&gt;x.f()&lt;/code&gt;会输出&lt;code class=&quot;inline&quot;&gt;2&lt;/code&gt;。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Trait {
    fn f(&amp;amp;self);
}

impl&amp;lt;&#39;a&amp;gt; Trait for &amp;amp;&#39;a i32 {
    fn f(&amp;amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let x = &amp;amp;0;
    x.f();
}&lt;/code&gt;&lt;p&gt;在这个代码中，&lt;code class=&quot;inline&quot;&gt;f&lt;/code&gt;方法中的&lt;code class=&quot;inline&quot;&gt;self&lt;/code&gt;会被自动加引用为&lt;code class=&quot;inline&quot;&gt;&amp;amp;&amp;amp;0&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/15&quot;&gt;点此查看 Rust Quiz 15&lt;/a&gt; &lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-16-52508991</guid>
<pubDate>Sun, 16 Dec 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust Quiz 解读：Quiz 14</title>
<link>https://henix.github.io/feeds/zhuanlan.time-and-spirit-hut/2018-12-14-52418867.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52418867&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-27785f4d62d62024a054a78b168015d1_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt; 来自于RustFest 2018 大会上Alex Crichton 和 David Tolnay两位大佬的轻演讲主题：Rust Quiz  &lt;br&gt; &lt;br&gt;- &lt;a href=&quot;https://github.com/dtolnay/rust-quiz&quot;&gt;rust-quiz源码&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://dtolnay.github.io/rust-quiz/18&quot;&gt;在线练习和解答&lt;/a&gt; &lt;br&gt;- &lt;a href=&quot;https://www.youtube.com/watch?v=QtDj9R6vtA8&amp;amp;index=6&amp;amp;list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW&amp;amp;t=0s&quot;&gt;视频&lt;/a&gt; &lt;br&gt; &lt;br&gt;不得不说，两位大佬出的题非常具有迷惑性，一不留神就落入了陷阱。   &lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;Quiz 14:&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下面这段代码输出什么？&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Trait: Sized {
    fn is_reference(self) -&amp;gt; bool;
}

impl&amp;lt;&#39;a, T&amp;gt; Trait for &amp;amp;&#39;a T {
    fn is_reference(self) -&amp;gt; bool {
        true
    }
}

fn main() {
    match 0.is_reference() {
        true =&amp;gt; print!(&quot;1&quot;),
        false =&amp;gt; print!(&quot;0&quot;),
    }

    match &#39;?&#39;.is_reference() {
        true =&amp;gt; print!(&quot;1&quot;),
        false =&amp;gt; {
            impl Trait for char {
                fn is_reference(self) -&amp;gt; bool {
                    false
                }
            }
            print!(&quot;0&quot;)
        }
    }
}&lt;/code&gt;&lt;p&gt;&lt;b&gt;输出结果：10&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;解读&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;考察要点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;自动引用（autoref）&lt;/li&gt;&lt;li&gt;impl trait 的可见性&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Quiz代码中定义了Trait，并限定了Sized trait。这意味着该Trait无法当作trait对象来使用。但是对于Quiz代码来说没有啥特殊意义。&lt;/p&gt;&lt;p&gt;然后为&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a T&lt;/code&gt;实现了Trait：&lt;code class=&quot;inline&quot;&gt;impl&amp;lt;&#39;a, T&amp;gt; Trait for &amp;amp;&#39;a T { ... }&lt;/code&gt;。&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a T&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;有什么区别呢？在之前的Quiz解读中已经讲过了。&lt;/p&gt;&lt;p&gt;在main函数中， &lt;code class=&quot;inline&quot;&gt;match 0.is_reference(){ ... }&lt;/code&gt;，当调用数字&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;is_reference&lt;/code&gt;方法时，你可能会想，数字类型有没有被实现&lt;code class=&quot;inline&quot;&gt;Trait&lt;/code&gt;呢？在为&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a T&lt;/code&gt;的实现中，&lt;code class=&quot;inline&quot;&gt;is_reference&lt;/code&gt;的参数是&lt;code class=&quot;inline&quot;&gt;self&lt;/code&gt;。到底编译会不会成功呢？&lt;/p&gt;&lt;p&gt;事实上，这里涉及一个规则：自动引用。&lt;/p&gt;&lt;p&gt;当调用&lt;code class=&quot;inline&quot;&gt;0.is_reference()&lt;/code&gt;的时候，会为&lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;自动添加引用，等价于&lt;code class=&quot;inline&quot;&gt;(&amp;amp;0).is_reference()&lt;/code&gt;。 这是因为上下文中只有为&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a T&lt;/code&gt;实现了&lt;code class=&quot;inline&quot;&gt;Trait&lt;/code&gt;。此时&lt;code class=&quot;inline&quot;&gt;is_reference&lt;/code&gt;方法中的&lt;code class=&quot;inline&quot;&gt;self&lt;/code&gt;等价于&lt;code class=&quot;inline&quot;&gt;&amp;amp;&#39;a i32&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果为&lt;code class=&quot;inline&quot;&gt;T&lt;/code&gt;实现&lt;code class=&quot;inline&quot;&gt;Trait&lt;/code&gt;，就不会存在自动引用了。&lt;/p&gt;&lt;p&gt;注意：在Rust中与自动引用对应的规则，还有一个&lt;code class=&quot;inline&quot;&gt;自动解引用(auto deref)&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;所以，这里&lt;code class=&quot;inline&quot;&gt;0.is_reference()&lt;/code&gt;调用，会返回true。输出结果当然是： &lt;code class=&quot;inline&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;而&lt;code class=&quot;inline&quot;&gt;match &#39;?&#39;.is_reference()&lt;/code&gt;，是调用字符&lt;code class=&quot;inline&quot;&gt;?&lt;/code&gt;的&lt;code class=&quot;inline&quot;&gt;is_reference()&lt;/code&gt;方法。这里迷惑人的地方就是&lt;code class=&quot;inline&quot;&gt;impl Trait for char { ... }&lt;/code&gt;实现是放到了&lt;code class=&quot;inline&quot;&gt;false&lt;/code&gt;匹配分支中。但实际上&lt;code class=&quot;inline&quot;&gt;impl Trait for char {...}&lt;/code&gt;是对整个Quiz代码可见的。所以，在&lt;code class=&quot;inline&quot;&gt;&#39;?&#39;.is_reference()&lt;/code&gt;调用的时候，它会输出&lt;code class=&quot;inline&quot;&gt;false&lt;/code&gt;，最终match匹配结果自然是： &lt;code class=&quot;inline&quot;&gt;0&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果你将&lt;code class=&quot;inline&quot;&gt;impl Trait for char {...}&lt;/code&gt;实现代码去掉的话：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;match &#39;?&#39;.is_reference() {
    true =&amp;gt; print!(&quot;1&quot;),
    false =&amp;gt; print!(&quot;0&quot;)
}&lt;/code&gt;&lt;p&gt;输出结果将会是：&lt;code class=&quot;inline&quot;&gt;11&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://dtolnay.github.io/rust-quiz/14&quot;&gt;点此查看 Rust Quiz 14&lt;/a&gt;&lt;/p&gt;</description>
<author>张汉东</author>
<guid isPermaLink="false">2018-12-14-52418867</guid>
<pubDate>Fri, 14 Dec 2018 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
