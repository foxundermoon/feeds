<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>编程语言与高级语言虚拟机杂谈（仮）</title>
<link>https://henix.github.io/feeds/zhuanlan.hllvm/</link>
<description>探讨编程语言的设计与实现</description>
<language>zh-cn</language>
<lastBuildDate>Mon, 12 Feb 2018 16:28:02 +0800</lastBuildDate>
<item>
<title>JSR292: InvokeDynamic和MethodHandle的优化</title>
<link>https://henix.github.io/feeds/zhuanlan.hllvm/2017-11-11-30936412.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30936412&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇是接着前篇 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/26389041&quot;&gt;Invokedynamic 和 MethodHandle的缘由&lt;/a&gt;, 这两天趁着闲着补上。&lt;/p&gt;&lt;p&gt;描述的内容主要基于IBM J9中Java 7 和Java 8部分MethodHandle的优化部分(HotSpot采用的是LambdaForm实现)。为方便理解，本文不涉及代码。&lt;/p&gt;&lt;h2&gt;背景：&lt;/h2&gt;&lt;p&gt;invokedynamic是 JSR 292中提出来的一个 JVM bytecode instruction. 这条指令主要是针对dynamic method invocations, which are prevalent in dynamically typed languages. &lt;/p&gt;&lt;p&gt;在程序运行时，当JVM第一次遇到invokedynamic指令时，他将去调用一个bootstrap方法，这个方法动态创建一个Method Handle Graph。这个过程叫做resolve。Method Handle Graph的地位在于在程序运行中，通过一系列的转化，将一个动态方法链接到具体的一个或者多个方法的实现。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;1, invokedyanmic&lt;/h2&gt;&lt;p&gt;正如和其它传统的方法调用指令(invokevirtual, invokestatic)一样, 主要的一个优化方法是inline caching。核心的思想是将Method handle graph that is linked at the dynamic call site直接取代 invokedynamic指令，而不是进行方法函数调用。这种好处是显而易见的，尤其是对于ConstantCallSite。它的不利之处是在于MutableCallSite。一个Mutable Call Site所对影的Method Handle可能会动态的被更改(modified or invalidated)，J9中是通过CAS来实现在Mutable Call Site的多个MHG的swap.&lt;/p&gt;&lt;p&gt;由于invokedynamic第一次调用才会涉及到方法link,因此，inline caching往往是 dynamic call site被调用多次之后才发生的。&lt;/p&gt;&lt;p&gt;当涉及到inline caching, 涉及到的问题是what to inline 和 When to inline. &lt;/p&gt;&lt;h2&gt;2, What to Inline. &lt;/h2&gt;&lt;p&gt;根据前一篇文章，JVM看到invokedynamic，会先去执行相对应bootstrap method。在这个被执行的bootstrap method中，invokedynamic call site会被resolved 一个method handle (或者method handle graph). 因此，用来inline的目标是mehtodhandle (这里面其实对应的是：Inline a method handle at a call site, and inline a method handle to another method handle). &lt;/p&gt;&lt;p&gt; 在J9中，是将Method Handle的Machine Code version直接inline 到dynamic call site中。在J9中，Method Handle对应着三种状态: Interpretation, SharedThunk, CustomThunk. &lt;/p&gt;&lt;ul&gt;&lt;li&gt;Interpretation: JVM解释执行Method Handle. &lt;/li&gt;&lt;li&gt;SharedThunk: A data structure, which points to the address that the native code of this method handle starts. &lt;/li&gt;&lt;li&gt;CustomThunk: Same to the sharedThunk, except the native code block represents the transformation that the whole sub-graph from the method handle has. &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;一个Method Handle (or method handle graph)的状态转变主要取决于这个method handle&#39;s invocationCounter. The larger invocationCounter that a method handle has, the more likelyhood that the method handle is promoted to the CustomThunk. &lt;/p&gt;&lt;p&gt;从SharedThunk到CustomThunk的原因参考下图：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8f3825423eb73910abecee3372812535_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;888&quot; data-rawheight=&quot;360&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在Method Handle Graph的一条路径中，JVM先看到第一个method handle ，执行其SharedThunk，然后再回到解释状态到了第二个Method Handle, 发现其有SharedThunk,　于是又进入执行状态，依次类推。这种JVM在不断的Interpretation和Execution mode切换，尤其是对MethodHandle这种简单的transformation, 代价比较高。因此CustomThunk则是讲上图中的浅蓝色的CompiledThunk (sharedThunk) inline成一份Compiled Code: &lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6e79374a7a1e45ba1b52e064252cc0ed_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;760&quot; data-rawheight=&quot;384&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;3, When to Inline&lt;/h2&gt;&lt;p&gt;该项取决于每个MethodHandle的 hotness or invocationCounter. 当一个MethodHandle的invocationCounter超过了给定的阈值时候，inline就会被启动激活。&lt;/p&gt;&lt;p&gt;－－－&lt;/p&gt;&lt;p&gt;大概的基本思想是这样子，然而并不是所有的优化都是很如意的。在这个基本方法中，TR JIT对Method Handle Graph整体的IC操作内存的消耗比较大，同时还有性能没有达到最优。因此又出来个GraphJIT. 大概思路是在MethodHandle从Intrepretation-&amp;gt;SharedThunk之前进行。&lt;/p&gt;&lt;p&gt;For an MHG is on interpretation mode, the graph traversal is necessary every time when the dynamic method handle is called. The traversal cost can be reduced by fusing graph internal nodes, so that JVM can spent less time on the path from the root to a leaf. &lt;/p&gt;&lt;p&gt;例子如图：原先的MHG G0中，从１到７需要经过４个中间节点，经过不断的合并，最后得到新的MHG G3, 并且用G3在运行时候来代替G0。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-97d40692a6a3543bbcfc519cf1670b6d_r.jpg&quot; data-caption=&quot;&quot; data-rawwidth=&quot;1162&quot; data-rawheight=&quot;606&quot;&gt;&lt;p&gt;整个过程大概分为两步：　&lt;/p&gt;&lt;ul&gt;&lt;li&gt;内部节点动态生成相对应的字节码&lt;/li&gt;&lt;li&gt;相邻节点的字节码进行合并，并生成新的MethodHandle.　使用GraphJIT&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这种方法在早期的HotSpot中也有类似的概念，差别在于GraphJIT会动态根据InvocationCounter和transformation函数题的大小来决定是否进行fusion. &lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;主要的参考文献：&lt;/p&gt;&lt;p&gt;1， &lt;a href=&quot;http://openjdk.java.net/jeps/160&quot;&gt;JEP 160: Lambda-Form Representation for Method Handles&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2， &lt;a href=&quot;http://video.oracle.com/detail/videos/featured-videos/video/1785383257001&quot;&gt;JVMLS 2012: Lambda Forms&lt;/a&gt;&lt;/p&gt;&lt;p&gt;3， Dan hedinga, MethodHandle compilation pipeline.&lt;/p&gt;&lt;p&gt;4,  Shijie Xu, David Bremner, Dan Heidinga. Fusing Method Handle Graphs for Efficient Dynamic JVM Language Implementations, VMIL@SPLASH, Vancouver, Canada, 2017. &lt;/p&gt;</description>
<author>Shijie XU</author>
<guid isPermaLink="false">2017-11-11-30936412</guid>
<pubDate>Sat, 11 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Dafny与程序验证</title>
<link>https://henix.github.io/feeds/zhuanlan.hllvm/2017-10-21-30321583.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30321583&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8f49af88768b20c6808b564c74a43abe_r.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;B大以前写过一个&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25568785&quot;&gt;怎样写出没有 bug 的程序：程序证明的简单例子&lt;/a&gt; ，是用Idris写的，我也来写一个，不过方法不太一样。&lt;/p&gt;&lt;p&gt;Dafny是MSR开发的程序设计语言，它混合了OOP和FP编程范式，并且自带程序验证功能，可以通过霍尔逻辑证明程序正确性。&lt;/p&gt;&lt;p&gt;它的语法非常简单，看起来就像C++，Scala和Haskell的混合。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;变量(scala风格，只是没有val)&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;scala&quot;&gt;var x:Tree;
var y:nat := 0;&lt;/code&gt;&lt;ul&gt;&lt;li&gt;ADT(Haskell风格)&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;scala&quot;&gt;datatype Tree = Empty | Node(left:Tree,value:real,right:Tree)
datatype List&amp;lt;T&amp;gt; = Nil | Cons(head: T, tail: List&amp;lt;T&amp;gt;)
Cons(5,Nil).Cons? &amp;amp;&amp;amp; Cons(5, Nil).head == 5&lt;/code&gt;&lt;ul&gt;&lt;li&gt;Methed/Lemma(命令式风格的函数)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;expr表示表达式，col表示集合&lt;/p&gt;&lt;p&gt;modifies用来标记函数的副作用，requires是前置命题，ensures是后置命题，decreses用来证明递归函数可终止。&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;method/lemma Abs(x: int) returns (y: int)
    modifies &amp;lt;col&amp;gt;
    requires &amp;lt;expr&amp;gt;
    ensures &amp;lt;expr&amp;gt;
    decreases &amp;lt;expr&amp;gt;
{
    if x &amp;lt; 0 { return -x;}
    else {return x;}
}&lt;/code&gt;&lt;ul&gt;&lt;li&gt;Function/Predicate(函数式风格的函数)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;reads用来标记函数捕获的外部变量&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;function abs(x: int):int
    requires &amp;lt;expr&amp;gt;
    ensures &amp;lt;expr&amp;gt;
    reads &amp;lt;col&amp;gt;
    decreases &amp;lt;expr&amp;gt;
{
    if x &amp;lt; 0 then -x else x
}&lt;/code&gt;&lt;ul&gt;&lt;li&gt;Assert用来下断言，只不过这个断言不是运行期的，而是编译期的，支持forall和exist量词以及基本的逻辑运算符。把Assert改为Assume，可以用来假定某些命题成立。&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;scala&quot;&gt;assert forall x :: P(x) ==&amp;gt; Q(x)
assert forall(i | 0 &amp;lt;= i&amp;lt; n - m) { b[i] := a[m + i];}&lt;/code&gt;&lt;ul&gt;&lt;li&gt;模式匹配(Scala风格，match的位置略有差异)&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;scala&quot;&gt;match t
	case Empty =&amp;gt; …
	case Node(l:Empty,v,r) =&amp;gt; …&lt;/code&gt;&lt;ul&gt;&lt;li&gt;循环&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可用invariant标记循环不变量&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;var i:=0
while i&amp;lt;n
	invariant i&amp;lt;=n
	decreases n-i
{}&lt;/code&gt;&lt;ul&gt;&lt;li&gt;支持C++类的写法，支持Lambda表达式，支持Trait，支持yield惰性流，有复杂的模块系统，支持泛型类和高阶类型（都是用&amp;lt;&amp;gt;表达）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以上就是Dafny常用的语法，还有一些不常用的语法可以参考&lt;a href=&quot;https://github.com/Microsoft/dafny/blob/master/Docs/DafnyRef/out/DafnyRef.pdf&quot;&gt;DafnyRef&lt;/a&gt;&lt;/p&gt;&lt;p&gt;一起来看一个稍微复杂一点的例子吧！写一个二叉搜索树的插入函数&lt;/p&gt;&lt;p&gt;定义二叉树&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;datatype Tree = Empty | Node(left:Tree,value:real,right:Tree)&lt;/code&gt;&lt;p&gt;在类里定义变量&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;class BST
{
    var tree:Tree;&lt;/code&gt;&lt;p&gt;定义in_tree和is_ordered函数，分别表示某个元素在树内和树符合二叉搜索树的条件&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;predicate method is_intree(t:Tree,x:real)
{
    match t
        case Empty =&amp;gt; false
        case Node(l,v,r) =&amp;gt; x==v || is_intree(l,x) || is_intree(r,x)
}
predicate is_ordered(t:Tree)
{
    match t
        case Empty =&amp;gt; true
        case Node(l,v,r) =&amp;gt; is_ordered(l) &amp;amp;&amp;amp; is_ordered(r) &amp;amp;&amp;amp;
            (forall x::is_intree(l,x) ==&amp;gt; x&amp;lt;v) &amp;amp;&amp;amp;
            (forall y::is_intree(r,y) ==&amp;gt; y&amp;gt;=v)
}&lt;/code&gt;&lt;p&gt;定义函数insert_into_left和insert_into_right&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;protected function method insert_into_left(t:Tree,x:real):Tree
    requires t!=Empty
    requires is_ordered(t)
    ensures is_ordered(insert_into_left(t,x))
{
    match t.left
        case Empty =&amp;gt; Node(Empty,x,Empty)
        case Node(l,v,r) =&amp;gt;
            if x&amp;gt;=v then
                insert_into_right(t.left,x)
            else
                insert_into_left(t.left,x)
}

protected function method insert_into_right(t:Tree,x:real):Tree
    requires t!=Empty
    requires is_ordered(t)
    ensures is_ordered(insert_into_right(t,x))
{
    match t.right
        case Empty =&amp;gt; Node(Empty,x,Empty)
        case Node(l,v,r) =&amp;gt;
            if x&amp;gt;=v then
                insert_into_right(t.right,x)
            else
                insert_into_left(t.right,x)
}
&lt;/code&gt;&lt;p&gt;以上全是pure function，最后，我们回到oop的世界，定义dirty的类成员函数&lt;/p&gt;&lt;code lang=&quot;scala&quot;&gt;method insert(x:real)
    requires is_ordered(tree)
    modifies this
    ensures is_ordered(tree)
{
    match tree
        case Empty =&amp;gt; {tree:=Node(Empty,x,Empty);}
        case Node(l,v,r) =&amp;gt; 
        {
            if x&amp;gt;=v
            {
                tree:=insert_into_right(tree,x);
            }
            else
            {
                tree:=insert_into_left(tree,x);
            }
        }
}&lt;/code&gt;&lt;p&gt;编译的时候，编译器会帮你验证你写的那些requires,ensures,assert是否满足，如果不满足，它会告诉你哪些命题无法证明。经过验证之后，你可以选择将Dafny代码编译为C#或编译成dll被其他.Net程序调用。&lt;/p&gt;&lt;p&gt;以上只是一个简单介绍，具体代码在&lt;a href=&quot;https://github.com/NiceKingWei/algorithm/blob/master/dafny/bst.dfy&quot;&gt;bst.dfy&lt;/a&gt;&lt;/p&gt;&lt;p&gt;我的slides &lt;a href=&quot;https://github.com/zju-lambda/slides/blob/master/Verification%20in%20Dafny.pdf&quot;&gt;Verification in Dafny&lt;/a&gt;&lt;/p&gt;&lt;p&gt;关于Dafny的更多精彩内容， 可以关注Dafny的项目主页，里面有一些学习资源 &lt;a href=&quot;https://www.microsoft.com/en-us/research/project/dafny-a-language-and-program-verifier-for-functional-correctness/?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fprojects%2Fdafny%2Freference.aspx&quot;&gt;MSR:Dafny&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>魏王雅望非常</author>
<guid isPermaLink="false">2017-10-21-30321583</guid>
<pubDate>Sat, 21 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>SIMD via C#</title>
<link>https://henix.github.io/feeds/zhuanlan.hllvm/2017-10-02-29842129.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29842129&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a9d7b3fb01037396184a7f74097298b7_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;简介 TL;DR&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们为C#（准确地说是.NET Core）引入了一套全新的机制，使得C# 以后可以像C/C++ 一样直接使用intrinsic functions 来直接操作Intel CPU 的大多数SIMD 指令了（从SSE 到AVX2）。&lt;/p&gt;&lt;p&gt;（注意是&lt;b&gt;以后&lt;/b&gt;！这个项目还没有完成！）&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Vectors in .NET&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在最开始我想先说一说SIMD 编程在C#/.NET 中的现状，以及为什么我们要引入这套全新的intrinsic。 &lt;/p&gt;&lt;p&gt;微软在之前的.NET Framework 和.NET Core 中引入了一个新的库： &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn858218&quot;&gt;System.Numerics.Vectors&lt;/a&gt; ，其中包含几个重要的值类型（Vector&amp;lt;T&amp;gt;, Vector2, Vector3, 等等）和操作它们的一些静态方法。程序员可以用这个库在.NET 环境中编写SIMD 程序。以下我假定大家都大概知道SIMD 编程的概念，来具体讲讲这个库 的设计与实现。&lt;/p&gt;&lt;p&gt;System.Numerics.Vectors 库中的这些静态方法的实际功能不能用C# 等.NET managed language 直接写出来(虽然它们都有一份&lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/System.Numerics.Vectors/src/System/Numerics/Vector.cs&quot;&gt;C# 的实现&lt;/a&gt;)，而是由编译器特殊对待从而生成特殊代码(SSE, AVX, AVX2, 等指令集的指令)，我们称这些方法（函数）为intrinsic。这些intrinsic 大部分都操作在上面说到的这些值类型上（Vector&amp;lt;T&amp;gt;, Vector2, Vector3, 等等），这些类型的实例也会被编译器特殊对待。其中最主要的是Vector&amp;lt;T&amp;gt;，这个类型的设计不同于传统&lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide/&quot;&gt;C/C++ intrinsic&lt;/a&gt; 中的vector 类型：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;泛型：.NET 中的这个vector类型采用了泛型设计，泛型Vector&amp;lt;T&amp;gt;的类型参数只接受numeric types，即C# 的基础数字类型（byte, sbyte, short, ushort, long, ulong, float, double)。如果试图创建一个Vector&amp;lt;UserDefinedStruct&amp;gt;的实例，运行时会抛出异常（一大波来自Haskell 的鄙视正在路上……）。&lt;/li&gt;&lt;li&gt;长度可变（length-agnostic）：大家都知道随着微处理器历史的发展SIMD 计算单元和寄存器的长度也在不断地进化，Intel 从最初MMX 的64-bit 寄存器到后来SSE 系列128-bit 寄存器，再到AVX 扩展为256-bit，最新的AVX-512 已经有了512-bit 的SIMD 寄存器。C/C++ intrinsic 使用不同长度的vector 类型来抽象这些SIMD 寄存器，比如__m128, __m256d。然而借助.NET 的JIT 编译，Vector&amp;lt;T&amp;gt; 的长度可以随着程序运行的硬件环境的不同而改变，例如一个使用了System.Numerics.Vectors 来加速的程序在Sandy Bridge 等稍微老一点的CPU 上看到Vector&amp;lt;byte&amp;gt; 的长度为16，而同一个程序运行在Haswell 以上的新CPU 上看到的Vector&amp;lt;byte&amp;gt; 的长度为32，但程序行为保持不变，并且开发者也不需要重新编译他们的源码就可以得到更多的提速。这个设计乍一看起来非常酷，但是也为这个库的命运埋下了巨大的隐患。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;System.Numerics.Vectors 的缺陷&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;System.Numerics.Vectors 库的设计初衷是要做一个跨平台的通用的SIMD 编程库。可以看出它的最终目标是要在统一的API 下支持不同的硬件指令集(SSE, AVX, NEON, etc.)，虽然现在只做了x86/x64 平台的支持，但一些设计缺陷已经暴露出来了。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;当『通用』成为设计目的时，『可用』成了重中之重。众所周知，SIMD 编程或者叫向量化编程相对来说是比较困难的，当一个程序想使用SIMD 来加速时开发者关注的第一点肯定是『性能』。然而这个『通用』和『可用』的设计目的并不能保证『性能』。举个最简单的例子，不同硬件提供的指令集一般在功能上是不会完全重合的，当一个指令在Intel CPU 上存在而在ARM CPU 上不存在的时候，通用SIMD 库就要想办法绕着弯来在不直接提供支持的硬件上实现这个API。然而这个『弯儿』一旦开始绕了，性能提升就不能保证了（在一些极端情况下不绕弯都不能保证）。试想一个程序员发现一个函数foo在他的程序中调用非常频繁，并且可以被向量化，于是欣喜地使用Vectors&amp;lt;T&amp;gt; 重写了。然后他发现整个程序在他装备了Skylake CPU的 Macbook Pro 上性能提升了50%，但在发布新版本几天后所有ARM 用户全来骂娘了（这只是个例子，性能退化在所有硬件平台之间都有可能出现，不是针对某些硬件架构）。以下列出的其他缺陷都或多或少来自这一条设计原则。&lt;/li&gt;&lt;li&gt;可变长度的Vector&amp;lt;T&amp;gt; 上无法抽象某些硬件指令的语义。比如很重要的shuffle 这族指令就没法抽象到变长Vector&amp;lt;T&amp;gt;, Github 已经有人多次要求提供这些API，但最终都没有很好的解决方案。再比如，对于AVX/AVX2 来说，很多时候我们需要同时操作YMM 和XMM 寄存器，但这在Vector&amp;lt;T&amp;gt; 的设计中不被允许。&lt;/li&gt;&lt;li&gt;System.Numerics.Vectors 中的类型和函数在JIT 编译器不支持生成SIMD 指令的环境下会退回到C# 的软件实现。这点对性能是很致命的，尤其是有些时候这种『不支持生成SIMD 指令的环境』是不可避免的，比如反射调用。&lt;/li&gt;&lt;li&gt;还有很多细节性的缺点我就不一一列举了，比较这篇文章重点不在System.Numerics.Vectors。有兴趣的同学可以去CoreCLR 和CoreFX 的GitHub repo 翻一翻相关的issue。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;b&gt;Intel Hardware Intrinsic&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;说了那么多终于进入正题了。为了探索一个新的SIMD 方案，我代表牙膏厂为.NET 提供了&lt;a href=&quot;https://github.com/dotnet/corefx/issues/22940&quot;&gt;API Proposal: Add Intel hardware intrinsic functions and namespace #22940&lt;/a&gt;。总体的设计都在这份API proposal 里了，我简单总结一下：&lt;/p&gt;&lt;p&gt;1) 加入两个新的namespace：System.Runtime.Intrinsics和System.Runtime.Intrinsics.X86。其中System.Runtime.Intrinsics只包含跨平台类型，目前有两个新的值类型Vector128&amp;lt;T&amp;gt;和Vector256&amp;lt;T&amp;gt; 来抽象SIMD 寄存器。每个硬件平台提供各自平台相关的类型和方法用来操作Vector128&amp;lt;T&amp;gt;和Vector256&amp;lt;T&amp;gt;，比如x86 平台的所有intrinsic 都在System.Runtime.Intrinsics.X86namespace 下，它提供了在managed language 中直接访问以下指令集的能力：SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX, AVX2, FMA, AES, BMI1, BMI2, LZCNT, POPCNT, PCLMULQDQ&lt;/p&gt;&lt;p&gt;2) 每一个指令集封装成一个static class（例如Sse,Aes, Avx2, 等.），每个class 都有一个IsSupported 方法用来检测当前硬件，从而为不同的硬件提供不同的优化方案。&lt;/p&gt;&lt;code lang=&quot;csharp&quot;&gt;if (Avx2.IsSupported)
{
    // 为AVX2 CPU 优化的算法  
}
else if (Sse41.IsSupported)
{
    // 为SSE4.1 CPU 优化的算法 
}
else if (Neon.IsSupported)
{
    // 为ARM NEON CPU 优化的算法
}
else
{
    // software-fallback
}&lt;/code&gt;&lt;p&gt;3) 要求一个新的C# 语言特性，const 参数。因为Intel hardware intrinsic 直接通过C# 代码来控制最终的代码生成，而一些SIMD 指令明确要求立即数操作数。比如&lt;a href=&quot;http://www.felixcloutier.com/x86/SHUFPD.html&quot;&gt;shufpd&lt;/a&gt; 对应的C# intrinsic 是&lt;/p&gt;&lt;code lang=&quot;csharp&quot;&gt;public static Vector128&amp;lt;double&amp;gt; Shuffle(Vector128&amp;lt;double&amp;gt; left, Vector128&amp;lt;double&amp;gt; right, byte control);&lt;/code&gt;&lt;p&gt;参数control 对应shufpd 的imm8 操作数，它必须是编译时确定的，如果用户传入一个『变量』可能导致程序无法编译。所以我们向C# 语言特性的开发组请求了一个新的语言特性：将const 关键字用于方法的形式参数。最终Shuffle 的方法签名为：&lt;/p&gt;&lt;code lang=&quot;csharp&quot;&gt;public static Vector128&amp;lt;double&amp;gt; Shuffle(Vector128&amp;lt;double&amp;gt; left, Vector128&amp;lt;double&amp;gt; right, const byte control);&lt;/code&gt;&lt;p&gt;这样C# 编译器（Roslyn）就只允许byte 字面量值流入control 参数。&lt;/p&gt;&lt;p&gt;4) Intel hardware intrinsic 在.NET Core 中所有环境下都会被编译为直接对应的硬指令，比如JIT编译、AOT编译（Crossgen）、MSCorlib 内部调用（比如用来优化String）、Debugging 调用、反射调用等等。而相对的System.Numerics.Vectors 只能在第三方JIT 编译的普通调用中才会生成SIMD 指令。&lt;/p&gt;&lt;p&gt;具体的API 请移步 &lt;a href=&quot;https://github.com/dotnet/coreclr/tree/master/src/mscorlib/src/System/Runtime/Intrinsics&quot;&gt;https://github.com/dotnet/coreclr/tree/master/src/mscorlib/src/System/Runtime/Intrinsics&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;.NET Managed Intrinsic 与C/C++ Native Intrinsic&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果有SIMD 编程经验的读者看到这里一定会觉得我们做的这套新的intrinsic 和&lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide/&quot;&gt;Intel C/C++ intrinsic&lt;/a&gt; 很相似。对，这套新的hardware intrinsic 是比原先System.Numerics.Vectors 更偏底层的一套intrinsic 机制，我们希望可以通过managed language （目前只有C#）来直接对应编译器的代码生成。然而，他还是有一些区别于C/C++ intrinsic 的地方。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;.NET Core 的JIT 编译为hardware intrinsic 的使用和实现提供了更大的便利。因为C/C++ 都是AOT 编译的，所以一般在编译SIMD 程序时开发者需要选用不同的编译器选项来编译多分二进制分发文件来保证各个在硬件平台都达到最优性能。然而JIT 编译就不会有这份顾虑，JIT 编译器会在启动前自动探知当前的硬件参数，来自动生成最有性能的代码。也许有人会说.NET Core 也有AOT 编译啊！可是.NET Core 的AOT 编译器（Crossgen）依然可以从JIT 编译器中获利，比如我们可以AOT 编译一个程序的大部分，但留下硬件相关的代码，待到运行时再JIT 编译这些代码（intrinsic）然后动态插入到原先AOT 编译好的程序中。&lt;/li&gt;&lt;li&gt;当然.NET Core 的hardware intrinsic 相比C/C++ 也有劣势。一般SIMD 计算对内存数据都有对齐要求，CoreCLR 却没有提供完整的对齐内存的接口给用户。但是这一点可以通过unsafe 代码（目前所有和内存交互的intrinsic 都是操作指针）和后续的值类型对齐机制来逐渐解决。还有一点就是managed language 对底层硬件的控制不如native language 灵活。举个例子，在C/C++ 中我们可以这么写代码来节省Load和Store：&lt;/li&gt;&lt;/ul&gt;&lt;code lang=&quot;c&quot;&gt;// __m256 a, float* b
__m256* v = (__m256*)b;
__m256 result = _mm256_add_ps(a, *v); // vaddps ymm0, ymm0, ymmword ptr [rdi]&lt;/code&gt;&lt;p&gt;上面这段两行代码可以只生成一条memory-flavor 的指令，但在C# 中我们不能持有一个泛型struct 的指针，所以我们必须写成：&lt;/p&gt;&lt;code lang=&quot;csharp&quot;&gt;// Vector&amp;lt;float&amp;gt; a, float* b
Vector&amp;lt;float&amp;gt; v = Avx.Load(b);
Vector&amp;lt;float&amp;gt; result = Avx.Add(a, v);&lt;/code&gt;&lt;p&gt;直觉上这个程序是两条指令，但可以被编译器优化折叠为和上面C/C++ 程序一样的编译结果。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;小福利&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;能看到这儿还没有关掉文章的一定是对SIMD 计算和编译器实现都很有兴趣的同学，那我顺便放点编译器实现的细节在这作为坚持到最后的奖励。&lt;br&gt;如果你点进了我上面给出的API 连接就会发现，所有的hardware intrinsic 有一个C# 的实现：&lt;/p&gt;&lt;code lang=&quot;csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// __m256 _mm256_add_ps (__m256 a, __m256 b)
/// &amp;lt;/summary&amp;gt;
public static Vector256&amp;lt;float&amp;gt; Add(Vector256&amp;lt;float&amp;gt; left, Vector256&amp;lt;float&amp;gt; right) =&amp;gt; Add(left, right);
/// &amp;lt;summary&amp;gt;
/// __m256d _mm256_add_pd (__m256d a, __m256d b)
/// &amp;lt;/summary&amp;gt;
public static Vector256&amp;lt;double&amp;gt; Add(Vector256&amp;lt;double&amp;gt; left, Vector256&amp;lt;double&amp;gt; right) =&amp;gt; Add(left, right);&lt;/code&gt;&lt;p&gt;每个intrinsic 在C# API 中都是一个直接递归方法。这是为什么呢？&lt;br&gt;原因是&lt;b&gt;我们需要intrinsic 在某些环境下既是intrinsic 又是function(method)&lt;/b&gt;。&lt;br&gt;首先我们可以将在intrinsic 理解为必须内联的函数（方法），对它的调用会被直接替换为一条或多条汇编指令，而不遵循普通函数/方法的调用约定(calling convention)。然而这一定义在某些情况下是无法工作的，比如deugger 和反射。例如.NET 在反射机制中提供了『方法调用』却没有提供『intrinsic调用』，那么typeof(Avx).GetMethod(&quot;Add&quot;).Invoke(null, args) 是无法工作的。但是我们可以这么做：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在某些环境中编译器看到用户调用Avx.Add(a, b) 时不对其进行特殊处理，而只当成是普通的函数调用。&lt;/li&gt;&lt;li&gt;编译器如果看到Avx.Add(a, b) 是被自身调用的（递归），则强制将其编译为相应的汇编指令。 &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这样，我们就完美解决了intrinsic 既是intrinsic （递归调用）又是function（用户调用）的问题。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;最后&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果大家对这项功能感兴趣，我会在这里持续更新项目进展，也请大家耐心等候！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;本文同步发布在：&lt;a href=&quot;http://fiigii.com/&quot;&gt;fiigii.com&lt;/a&gt;&lt;/p&gt;</description>
<author>彭飞</author>
<guid isPermaLink="false">2017-10-02-29842129</guid>
<pubDate>Mon, 02 Oct 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>谈寄存器分配器中Spiller的作用</title>
<link>https://henix.github.io/feeds/zhuanlan.hllvm/2017-07-29-28182330.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28182330&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前的两篇文章&lt;a href=&quot;https://www.zhihu.com/question/29355187/answer/99413526&quot;&gt;知乎用户：寄存器分配问题？&lt;/a&gt; 和&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24554029&quot;&gt;https://zhuanlan.zhihu.com/p/24554029&lt;/a&gt; 分别从线性扫描的分配算法到LLVM2.6中是如何实现的两方面坐了简要的阐述，但是正如我初学之时一样的想法，在执行LinearScan之后算法就结束了吗？ 代码生成步骤完成了吗？ 实际的工作未必！本文将接上文阐述这最后一道工序。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;一、什么是Spiller？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;在执行上述趟的分配之后，在LLVM中，MachineInstr携带的虚拟寄存器操作数仍然是虚拟寄存器，分配得到的物理寄存器并没有重写到对应到操作数，以反应这个事实。另外，有部分操作数由于可用的物理寄存器数目受限的原因，只能分配至某个栈槽(Stack Slot)中，虽然如此，但对应的操作数并没有重写为Stack Slot引用（如：[%ebp-4]，而是一个表示Stack Slot的编号，如#1）。所以需要一趟Spiller（代码溢出器）重写对应的操作数，将分配到物理寄存器的操作数reg属性设置为物理寄存器的编号(LLVM，物理寄存器的编号范围为[0, FirstVirtualRegister = 1024))，将分配至stack slot的操作数重写为内存操作数的引用，如上述的[%ebp-4]。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;以如下的伪X86汇编代码为例(未执行三地址指令消除趟TwoAddrInstruction)，并且假设只有两个物理寄存器%eax, %ebx可用。&lt;/b&gt;&lt;/p&gt;&lt;code lang=&quot;nasm&quot;&gt;movl %vreg1, [%ebp+8];   # vreg1表示虚拟寄存器, [%ebp+8]用于获取第一个参数
addl %vreg0, %vreg1, 1;  # %vreg0 = %vreg1 + 1
addl %vreg2, %vreg1, 1;  # %vreg2 = %vreg1 + 1
subl %res, %vreg0, %vreg2;  # %res = %vreg0 - %vreg2&lt;/code&gt;&lt;p&gt;针对上述伪代码，计算得到的活跃区间(Live Interval)分别是[1]:&lt;/p&gt;&lt;p&gt;%vreg0 = [4, 15)&lt;/p&gt;&lt;p&gt;%vreg1 = [0, 11)&lt;/p&gt;&lt;p&gt;%vreg2 = [8, 15)&lt;/p&gt;&lt;p&gt;%res = [12, 19)&lt;/p&gt;&lt;p&gt;然后依次分配寄存器，%vreg0分配到%ebx，%vreg1分配到%eax，%vreg2分配到0号栈槽(stack slot)，%res分配到%eax。对于%vreg2来说，在使用的时候必须有寄存器可以使用，此处调用函数addIntervalsForSpills插入一个很短的Live Interval = [8, 11)用于为%vreg2分配一个临时寄存器，同时更新对应的active, inactive集合。如果将这个临时live interval权重设置高些，则就能剥夺%vreg0的物理寄存器%ebx给%vreg2使用。&lt;/p&gt;&lt;p&gt;在执行寄存器分配之后，上述的分配结果只是保存在VirtRegMap中，并没有反映到指令操作数的更改。为了反映上述分配事实，就需要执行一趟代码重写操作，将分配至物理寄存器的操作数重写为物理寄存器编号，分配到栈槽的操作数重写为内存引用。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;二、LLVM 1.3的Spiller的实现[1]&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;LLVM 1.3中Spiller实现分为两种，一种是SimpleSpiller，一种是LocalSpiller，所工作的范围不一样。前者局限于单条指令，只保存某个可重用的结果，便于同一条指令之后的使用同样寄存器的其他操作数。后者则在基本块范围内进行指令重写，寻找更多的可重用操作数。&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;  bool runOnMachineFunction(MachineFunction&amp;amp; mf, const VirtRegMap&amp;amp; vrm) {
            DEBUG(std::cerr &amp;lt;&amp;lt; &quot;********** REWRITE MACHINE CODE **********\n&quot;);
            DEBUG(std::cerr &amp;lt;&amp;lt; &quot;********** Function: &quot;
              &amp;lt;&amp;lt; mf.getFunction()-&amp;gt;getName() &amp;lt;&amp;lt; &#39;\n&#39;);
            const TargetMachine&amp;amp; tm = mf.getTarget();
            const MRegisterInfo&amp;amp; mri = *tm.getRegisterInfo();

            // Loaded这个map记录某个虚拟寄存器所分配到的物理寄存器是否可重用
            // 但是这个map的有效范围只在单条指令的多个操作数之间，无法跨指令保存
            typedef DenseMap&amp;lt;bool, VirtReg2IndexFunctor&amp;gt; Loaded;
            Loaded loaded;

            for (MachineFunction::iterator mbbi = mf.begin(),
                     mbbe = mf.end(); mbbi != mbbe; ++mbbi) {
                DEBUG(std::cerr &amp;lt;&amp;lt; mbbi-&amp;gt;getBasicBlock()-&amp;gt;getName() &amp;lt;&amp;lt; &quot;:\n&quot;);
                for (MachineBasicBlock::iterator mii = mbbi-&amp;gt;begin(),
                         mie = mbbi-&amp;gt;end(); mii != mie; ++mii) {
                    // 重新清空
                    loaded.grow(mf.getSSARegMap()-&amp;gt;getLastVirtReg());
                    for (unsigned i = 0,e = mii-&amp;gt;getNumOperands(); i != e; ++i){
                        MachineOperand&amp;amp; mop = mii-&amp;gt;getOperand(i);

                        // 只处理寄存器操作数，并且该寄存器仍然是虚拟寄存器
                        if (mop.isRegister() &amp;amp;&amp;amp; mop.getReg() &amp;amp;&amp;amp;
                            MRegisterInfo::isVirtualRegister(mop.getReg())) {
                            unsigned virtReg = mop.getReg();
                            unsigned physReg = vrm.getPhys(virtReg);
                            if (mop.isUse() &amp;amp;&amp;amp;
                                vrm.hasStackSlot(mop.getReg()) &amp;amp;&amp;amp;
                                !loaded[virtReg]) {
                                // 对于溢出到stackslot中的操作数来说，此时需要重新
                                // reload到临时物理寄存器phyReg中
                                mri.loadRegFromStackSlot(
                                    *mbbi,
                                    mii,
                                    physReg,
                                    vrm.getStackSlot(virtReg),
                                    mf.getSSARegMap()-&amp;gt;getRegClass(virtReg));
                                // 记录该virtReg已经reload至物理寄存器了，
                                // 下次如果当前指令中还有操作数使用了这个寄存器，则
                                // 可以避免一次reload
                                loaded[virtReg] = true;
                                DEBUG(std::cerr &amp;lt;&amp;lt; &#39;\t&#39;;
                                      prior(mii)-&amp;gt;print(std::cerr, &amp;amp;tm));
                                ++numLoads;
                            }
                            if (mop.isDef() &amp;amp;&amp;amp;
                                vrm.hasStackSlot(mop.getReg())) {
                                // 如果该操作数是def操作数，那么需要讲结果
                                // 写回到stack slot中
                                mri.storeRegToStackSlot(
                                    *mbbi,
                                    next(mii),
                                    physReg,
                                    vrm.getStackSlot(virtReg),
                                    mf.getSSARegMap()-&amp;gt;getRegClass(virtReg));
                                ++numStores;
                            }
                            // 设置当前的操作数寄存器为物理寄存器，当前运算的临时的
                            // 寄存器
                            mii-&amp;gt;SetMachineOperandReg(i, physReg);
                        }
                    }
                    DEBUG(std::cerr &amp;lt;&amp;lt; &#39;\t&#39;; mii-&amp;gt;print(std::cerr, &amp;amp;tm));
                    // 清空loaded集合，因为loaded只在单条指令范围内有效
                    loaded.clear();
                }
            }
            return true;
        }&lt;/code&gt;&lt;h2&gt;&lt;b&gt;三、LLVM 2.6中的Rewriter实现&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在LLVM 2.6中完成这部分工作的类名字修改成了VirtRegRewriter，该类同样分为两种，一种是简单的，单条指令范围内的TrivialRewriter，第二种是LocalRewriter。实现的逻辑和功能基本类似，只不过加了部分窥孔优化，如：OptimizeByUnfold2函数折叠一系列的load/store指令为一个寄存器，避免多次访存；针对满足交换律的指令进行操作数交换优化等。&lt;/p&gt;&lt;p&gt;[1]. &lt;a href=&quot;http://llvm.org/ProjectsWithLLVM/2004-Fall-CS426-LS.pdf&quot;&gt;Improvements to Linear Scan register allocation&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>XlousZeng</author>
<guid isPermaLink="false">2017-07-29-28182330</guid>
<pubDate>Sat, 29 Jul 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>[链接][C#][CLR] 在线把玩Roslyn与CLR JIT32</title>
<link>https://henix.github.io/feeds/zhuanlan.hllvm/2017-07-06-27740581.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27740581&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://sharplab.io/&quot;&gt;SharpLab&lt;/a&gt;&lt;/p&gt;&lt;p&gt;以前就有用它来把玩C#编译器（Roslyn），试用一些新语法，观察某些语法糖的实现，还有测试看某些结构生成的MSIL的样子。超方便。因为是完全在线的工具，我在火车上懒得拿出电脑的时候也可以用手机玩，简直太爽了。&lt;/p&gt;&lt;p&gt;刚才突然发现它现在在右手边的Decompiled下拉菜单里居然多了一个“JIT Asm”选项，选上它就可以看某段C#代码对应由Desktop CLR 4.7的JIT32所编译出来的x86代码。这更爽了啊！&lt;/p&gt;&lt;p&gt;（回头看看把它弄成再支持上x64有多麻烦…）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;还有一个我偶尔也用用的在线工具是 &lt;a href=&quot;https://csharppad.com/&quot;&gt;C# Pad: Run C# Code Online&lt;/a&gt; ，基本上是个基于Roslyn的在线C# REPL。因为是基于相当新的Roslyn，也可以用它来试用新语法。前面那个SharpLab只能用来编译与反编译，C# Pad则可以编译并运行。两者各有其用。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;要是我平时还用Windows的话我多半还会在本地用 &lt;a href=&quot;https://www.linqpad.net/&quot;&gt;LINQPad&lt;/a&gt; 吧。也超好用。可惜它在Mac上现在也还是跑不了，只好作罢。&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">2017-07-06-27740581</guid>
<pubDate>Thu, 06 Jul 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>闭包捕获与lazy val字段</title>
<link>https://henix.github.io/feeds/zhuanlan.hllvm/2017-06-30-27633304.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27633304&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
几天前有同事聊起这个话题：大家在review一段Scala代码，里面有一个lazy val字段被用在一个闭包里，而这个闭包是要被序列化传到别的机器上去执行的。话题的重点就是在闭包前这段代码特意前访问了一下这个lazy val字段的值，引起同事讨论是否有必要。&lt;p&gt;其中一位同事对Scala不熟而对微软系技术更熟，于是我就把这个例子用C#来写了一次给他看。结果他没听说过C#里有&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd642331(v=vs.110).aspx&quot; data-editable=&quot;true&quot; data-title=&quot;System.Lazy&amp;lt;T&amp;gt;&quot; class=&quot;&quot;&gt;System.Lazy&amp;lt;T&amp;gt;&lt;/a&gt;…不过还好C#的Lazy&amp;lt;T&amp;gt;是标准库层面的功能，毕竟magic少一些，还是比Scala的好解释一些。&lt;/p&gt;&lt;p&gt;C#和Scala的代码例子在这个gist里：&lt;a href=&quot;https://gist.github.com/rednaxelafx/32574a3db9e46b09ddf4218e3185f3a8&quot; data-editable=&quot;true&quot; data-title=&quot;github.com 的页面&quot; class=&quot;&quot;&gt;demo C# and Scala&#39;s lazy val and lambda capturing&lt;/a&gt;&lt;/p&gt;&lt;p&gt;真正的重点是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;C#和Scala里如果“捕获了字段”的话，其实捕获的是this而不是单独捕获了一个字段，在lambda里访问字段其实是通过捕获的this来访问的。Java 8的lambda也是如此。&lt;br&gt;&lt;/li&gt;&lt;li&gt;对this的捕获并不会导致lazy val被求值，所以就算lambda里会用到一个lazy val字段，在闭包创建的时候并不会当时就导致该字段求值。如果要包装这个lazy val字段在lambda表达式实际被调用时得到闭包创建时的一些环境状态的话，得自己显式在闭包创建前对这个lazy val字段求一下值才行。&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;然后同事表示还是C++好，lambda的捕获列表很明确哪些是capture-by-value哪些是capture-by-reference。然而其实来个 [&amp;amp;] 就可以把按引用捕获this的事实给隐含起来了，对新手来说也没友好多少吧（ry&lt;/p&gt;&lt;code lang=&quot;cpp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;functional&amp;gt;

class Foo {
  int val_ = 0;

public:
  std::function&amp;lt;int()&amp;gt; get_func() {
    return [&amp;amp;]() { return val_; };
  }

  void incr() { val_++; }
};

int main() {
  Foo foo;
  const auto&amp;amp; f = foo.get_func();
  std::cout &amp;lt;&amp;lt; f() &amp;lt;&amp;lt; std::endl;
  foo.incr();
  std::cout &amp;lt;&amp;lt; f() &amp;lt;&amp;lt; std::endl;
  return 0;
}&lt;/code&gt;&lt;p&gt;让不熟悉现代C++的人来读这段代码，能看出来那个lambda隐式按引用捕获了this么 &amp;gt;_&amp;lt;&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">2017-06-30-27633304</guid>
<pubDate>Fri, 30 Jun 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Value type and Packaged Object for Java</title>
<link>https://henix.github.io/feeds/zhuanlan.hllvm/2017-06-06-27259688.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27259688&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前段时间有人问了我下关于Java 中Value Type的概念，并转了我一篇王垠去年的一篇博客&lt;a href=&quot;http://www.yinwang.org/blog-cn/2016/06/08/java-value-type&quot; data-editable=&quot;true&quot; data-title=&quot;Java 有值类型吗？&quot;&gt;Java 有值类型吗？&lt;/a&gt; &lt;/p&gt;&lt;p&gt;Java语言层面上并不能算是支持value type。Java有两种类型： primitive type and object type。前者如我们大家经常见到的 `int`  `float`，从JVM的角度上看，变量的数据是直接在JVM operand stack上面的。而后者，所有的对象则是从heap上申请，每个对象的field则是通过reference 来联系起来。&lt;/p&gt;&lt;p&gt;当然这篇博文主要不是针对王垠的博文(自己个人理解垠神在PL 的Type System方面的学识远远超过了本人)。这篇文章还是还是比较value type and packaged object. &lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Value Type&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;最早关于Java Value Type这个词的时候是先前有一次旁听Doug lea和某博士的关于Packaged object的讨论会，后来我的合作方给我稍微普及, 并给了IBM clear过的链接 &lt;a href=&quot;http://openjdk.java.net/projects/valhalla/&quot; data-title=&quot;Valhalla&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;Valhalla&lt;/a&gt;(Open JDK experiment项目)以及他们最新的 &lt;a href=&quot;http://cr.openjdk.java.net/%7Ejrose/values/shady-values.html&quot; data-editable=&quot;true&quot; data-title=&quot;Minimal Value Types&quot; class=&quot;&quot;&gt;Minimal Value Types&lt;/a&gt;.　&lt;/p&gt;&lt;p&gt;Value Type的思想是关于Object Model。每个Java Object有一个Header(有的地方叫做Metadata)：包含lock-word, ptr, 等信息。通过lock-word 可以实现object synchronization (e.g., lock-word)，而　ptr可以获取object相应的相Class信息。Value Type的目标是Headerless that is no more header( or no identify ) for an object on the heap. The benefits would be on GC, memory usage, potential cache locality (Refer Valhalla home for more). &lt;/p&gt;&lt;p&gt;当然，任何的好处都不是没有代价的。Because of no header and identify, it would be problem to call methods of a value type object: hashcode, getClass, wait, notify. Another problem is about the object synchronization, which strongly depends on marker bit of an object&#39;s header that is no longer available. &lt;/p&gt;&lt;p&gt;对于普通的开发人员来讲，value type的出炉需要保持对原有Java应用的支持，数据模型的变更应该对使用者是透明的。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Packaged Object&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Packaged Object is an experimental enhancement for J9 JVM to improve serialization, Java object I/O cross on-heap and off-heap (native memory), and object layout alignment. In the packaged object data model, data are organized in a multi-tier manner (like the nested C structs), in which the object’s data is nested in its enclosing Packed Object instead of being pointed to by an object reference as in the traditional Java object data model.  &lt;/p&gt;&lt;p&gt;This project stopped at 2014(?). The main disclosure document is Marcel Mitran&#39;s ``IBM Java PackedObjects: An Overview`` (You get get it via google), and some publications  about synchronization from IBM CAS. My post will only based on these document. &lt;/p&gt;&lt;p&gt;The packaged object&#39;s goals：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Remove object metadata. This point is similar to the Value Type. &lt;br&gt;&lt;/li&gt;&lt;li&gt;Off-head and on-head serialization. As what is shown at marcel&#39;s slides，the copy and serialization can be avoided avoided by using a packaged header at on-heap to reference the packaged object at off-heap directly. &lt;/li&gt;&lt;li&gt;... &lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Because the header(the lock-word) is removed, the existing Java synchronization does not work for packaged object directly. Developer has to achieve the thread-safe via: &lt;/p&gt;&lt;ul&gt;&lt;li&gt;在packaged object上一层使用java 已有的lock机制。　&lt;/li&gt;&lt;li&gt;Concurrent Multi-way tree 以及其衍生的方法。这个方法主要是IBM CAS中的Dr Bing Yang提出来实现的，大概意思是将根据multi-tier PackedObject data structure来构建一个multiple-way tree, 在读写 packaged data 的时候通过操作(Search, add, remove)这个multiple-way tree来实现同步。具体的方式可以参考下CASCON 2016 best paper: Bing Yang: &lt;b&gt;A concurrent multiway tree using the lazy locking mechanism. &lt;br&gt;&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;本来这篇博文还安排了一部分关于GraphJIT, a jit bytecode compiler that simplify graph structure. GraphJIT 也能达到类似Packaged object和value type的部分效果。&lt;/p&gt;</description>
<author>Shijie XU</author>
<guid isPermaLink="false">2017-06-06-27259688</guid>
<pubDate>Tue, 06 Jun 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>[Java] 关于OpenJDK对Java 8 lambda表达式的运行时实现的查看方式</title>
<link>https://henix.github.io/feeds/zhuanlan.hllvm/2017-05-29-27159693.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27159693&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
有同学私信我说看到之前一个回答（&lt;a href=&quot;https://www.zhihu.com/question/51491241/answer/126232275&quot; data-editable=&quot;true&quot; data-title=&quot;Java中普通lambda表达式和方法引用本质上有什么区别？ - RednaxelaFX的回答 - 知乎&quot; class=&quot;&quot;&gt;Java中普通lambda表达式和方法引用本质上有什么区别？ - RednaxelaFX的回答 - 知乎&lt;/a&gt;）里我给出了OpenJDK对lambda表达式的实现的例子，问说例子里的代码是如何获得的。&lt;p&gt;简短的答案是：是使用内部调试参数dump出了Class文件，然后人肉反编译Class文件给出了我的回答中的代码。而其实这些步骤只是我基于已有的知识所采用的简略步骤，大家即便不知道实现细节，也可以靠自己一步步探索出来的。&lt;/p&gt;&lt;h2&gt;我是如何做的：&lt;/h2&gt;&lt;p&gt;首先我知道Oracle JDK 8 / OpenJDK 8对lambda表达式在运行时的实现方式是动态生成跟&lt;b&gt;匿名内部类&lt;/b&gt;相似形式的类，而负责生成代码的类位于&lt;a href=&quot;http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/tip/src/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java&quot; data-title=&quot;java.lang.invoke.InnerClassLambdaMetafactory&quot; class=&quot;&quot; data-editable=&quot;true&quot;&gt;java.lang.invoke.InnerClassLambdaMetafactory&lt;/a&gt;。可以看到，这个类里有一个调试用的Java property可以设置：&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;jdk.internal.lambda.dumpProxyClasses&lt;/code&gt;&lt;p&gt;相关代码在：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;    static {
        final String key = &quot;jdk.internal.lambda.dumpProxyClasses&quot;;
        String path = AccessController.doPrivileged(
                new GetPropertyAction(key), null,
                new PropertyPermission(key , &quot;read&quot;));
        dumper = (null == path) ? null : ProxyClassesDumper.getInstance(path);
    }
&lt;/code&gt;&lt;p&gt;所以我们在启动Java的时候，传入这个参数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;-Djdk.internal.lambda.dumpProxyClasses=&amp;lt;path_to_your_dump_directory&amp;gt;&lt;/code&gt;&lt;p&gt;就可以让JDK把lambda表达式对应的运行时生成的类给dump下来了。&lt;/p&gt;&lt;p&gt;接下来我会把这些dump下来的Class文件用javap解读成文本形式，然后人肉将其反编译到Java代码。涉及的字节码其实都非常简单，即便人肉反编译也非常非常快。大家如果还是喜欢用现成的反编译器也大可去用自己喜欢的反编译器。&lt;/p&gt;&lt;p&gt;然而我是如何知道“首先”的那步内容的呢？&lt;/p&gt;&lt;h2&gt;大家可以如何着手去调查：&lt;/h2&gt;&lt;p&gt;即便没有文档也可以顺藤摸瓜，写个例子慢慢调查。&lt;/p&gt;&lt;p&gt;例如说，随便写个这样的例子：&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;import java.util.Arrays;

public class MyTest {
  public static void main(String[] args) {
    Runnable r = () -&amp;gt; System.out.println(Arrays.toString(args));
    r.run();
  }
}&lt;/code&gt;&lt;p&gt;然后用javac -g MyTest.java编译，再用javap来把Class文件解读为文本形式：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ javap -verbose -private MyTest
Classfile /private/tmp/MyTest.class
  Last modified May 28, 2017; size 1260 bytes
  MD5 checksum 2ce5e67938afee50b0dc8841569ea12e
  Compiled from &quot;MyTest.java&quot;
public class MyTest
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #8.#25         // java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V
   #2 = InvokeDynamic      #0:#30         // #0:run:([Ljava/lang/String;)Ljava/lang/Runnable;
   #3 = InterfaceMethodref #31.#32        // java/lang/Runnable.run:()V
   #4 = Fieldref           #33.#34        // java/lang/System.out:Ljava/io/PrintStream;
   #5 = Methodref          #35.#36        // java/util/Arrays.toString:([Ljava/lang/Object;)Ljava/lang/String;
   #6 = Methodref          #37.#38        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #7 = Class              #39            // MyTest
   #8 = Class              #40            // java/lang/Object
   #9 = Utf8               &amp;lt;init&amp;gt;
  #10 = Utf8               ()V
  #11 = Utf8               Code
  #12 = Utf8               LineNumberTable
  #13 = Utf8               LocalVariableTable
  #14 = Utf8               this
  #15 = Utf8               LMyTest;
  #16 = Utf8               main
  #17 = Utf8               ([Ljava/lang/String;)V
  #18 = Utf8               args
  #19 = Utf8               [Ljava/lang/String;
  #20 = Utf8               r
  #21 = Utf8               Ljava/lang/Runnable;
  #22 = Utf8               lambda$main$0
  #23 = Utf8               SourceFile
  #24 = Utf8               MyTest.java
  #25 = NameAndType        #9:#10         // &quot;&amp;lt;init&amp;gt;&quot;:()V
  #26 = Utf8               BootstrapMethods
  #27 = MethodHandle       #6:#41         // invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
  #28 = MethodType         #10            //  ()V
  #29 = MethodHandle       #6:#42         // invokestatic MyTest.lambda$main$0:([Ljava/lang/String;)V
  #30 = NameAndType        #43:#44        // run:([Ljava/lang/String;)Ljava/lang/Runnable;
  #31 = Class              #45            // java/lang/Runnable
  #32 = NameAndType        #43:#10        // run:()V
  #33 = Class              #46            // java/lang/System
  #34 = NameAndType        #47:#48        // out:Ljava/io/PrintStream;
  #35 = Class              #49            // java/util/Arrays
  #36 = NameAndType        #50:#51        // toString:([Ljava/lang/Object;)Ljava/lang/String;
  #37 = Class              #52            // java/io/PrintStream
  #38 = NameAndType        #53:#54        // println:(Ljava/lang/String;)V
  #39 = Utf8               MyTest
  #40 = Utf8               java/lang/Object
  #41 = Methodref          #55.#56        // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
  #42 = Methodref          #7.#57         // MyTest.lambda$main$0:([Ljava/lang/String;)V
  #43 = Utf8               run
  #44 = Utf8               ([Ljava/lang/String;)Ljava/lang/Runnable;
  #45 = Utf8               java/lang/Runnable
  #46 = Utf8               java/lang/System
  #47 = Utf8               out
  #48 = Utf8               Ljava/io/PrintStream;
  #49 = Utf8               java/util/Arrays
  #50 = Utf8               toString
  #51 = Utf8               ([Ljava/lang/Object;)Ljava/lang/String;
  #52 = Utf8               java/io/PrintStream
  #53 = Utf8               println
  #54 = Utf8               (Ljava/lang/String;)V
  #55 = Class              #58            // java/lang/invoke/LambdaMetafactory
  #56 = NameAndType        #59:#63        // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
  #57 = NameAndType        #22:#17        // lambda$main$0:([Ljava/lang/String;)V
  #58 = Utf8               java/lang/invoke/LambdaMetafactory
  #59 = Utf8               metafactory
  #60 = Class              #65            // java/lang/invoke/MethodHandles$Lookup
  #61 = Utf8               Lookup
  #62 = Utf8               InnerClasses
  #63 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
  #64 = Class              #66            // java/lang/invoke/MethodHandles
  #65 = Utf8               java/lang/invoke/MethodHandles$Lookup
  #66 = Utf8               java/lang/invoke/MethodHandles
{
  public MyTest();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V
         4: return
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   LMyTest;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=2, args_size=1
         0: aload_0
         1: invokedynamic #2,  0              // InvokeDynamic #0:run:([Ljava/lang/String;)Ljava/lang/Runnable;
         6: astore_1
         7: aload_1
         8: invokeinterface #3,  1            // InterfaceMethod java/lang/Runnable.run:()V
        13: return
      LineNumberTable:
        line 5: 0
        line 6: 7
        line 7: 13
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      14     0  args   [Ljava/lang/String;
            7       7     1     r   Ljava/lang/Runnable;

  private static void lambda$main$0(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: aload_0
         4: invokestatic  #5                  // Method java/util/Arrays.toString:([Ljava/lang/Object;)Ljava/lang/String;
         7: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        10: return
      LineNumberTable:
        line 5: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      11     0  args   [Ljava/lang/String;
}
SourceFile: &quot;MyTest.java&quot;
InnerClasses:
     public static final #61= #60 of #64; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles
BootstrapMethods:
  0: #27 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
    Method arguments:
      #28 ()V
      #29 invokestatic MyTest.lambda$main$0:([Ljava/lang/String;)V
      #28 ()V
&lt;/code&gt;&lt;br&gt;&lt;p&gt;&lt;i&gt;(Whenever I open this page in Chrome with the macOS Chinese input method active, Chrome crashes immediately. I&#39;ll have to write the following in English for now. Hopefully the crash issue goes away soon so that I can rewrite it back to Chinese.)&lt;/i&gt;&lt;/p&gt;&lt;p&gt;As shown above, the two lines of source code in main() maps to the following bytecode by javac:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;// 1st line:
// Runnable r = () -&amp;gt; System.out.println(Arrays.toString(args));
         0: aload_0
         1: invokedynamic #2,  0              // InvokeDynamic #0:run:([Ljava/lang/String;)Ljava/lang/Runnable;
         6: astore_1
// 2nd line:
// r.run();
         7: aload_1
         8: invokeinterface #3,  1            // InterfaceMethod java/lang/Runnable.run:()V
&lt;/code&gt;&lt;p&gt;The 2nd line, which invokes the lambda, is the same as a normal Runnable.run() invocation, through invokeinterface. So it doesn&#39;t matter whether the Runnable was created using a lambda expression or some other way (e.g. pre-Java 8 anonymous inner classes), the invocation side is always the same.&lt;/p&gt;&lt;p&gt;The interesting part is on the 1st line, where there&#39;s a curious-looking invokedynamic instruction involved. Looking at its operands, &quot;#2&quot;, is:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;   #2 = InvokeDynamic      #0:#30         // #0:run:([Ljava/lang/String;)Ljava/lang/Runnable;
&lt;/code&gt;&lt;p&gt;which specifies a &quot;BootstrapMethod&quot; (#0) and a &quot;NameAndType&quot; (#30). Let&#39;s look at the BootstrapMethod part:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;BootstrapMethods:
  0: #27 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
    Method arguments:
      #28 ()V
      #29 invokestatic MyTest.lambda$main$0:([Ljava/lang/String;)V
      #28 ()V
&lt;/code&gt;&lt;p&gt;(Note that the body of the lambda expression is actually desugared into a private static method, lambda$main$0.)&lt;/p&gt;&lt;p&gt;Here we can see that the bootstrap method specified is &lt;a href=&quot;http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/5b86f66575b7/src/share/classes/java/lang/invoke/LambdaMetafactory.java#l291&quot; data-editable=&quot;true&quot; data-title=&quot;java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;&gt;java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&lt;/a&gt;, from which we can see its use of the InnerClassLambdaMetaFactory:&lt;/p&gt;&lt;code lang=&quot;java&quot;&gt;    public static CallSite metafactory(MethodHandles.Lookup caller,
                                       String invokedName,
                                       MethodType invokedType,
                                       MethodType samMethodType,
                                       MethodHandle implMethod,
                                       MethodType instantiatedMethodType)
            throws LambdaConversionException {
        AbstractValidatingLambdaMetafactory mf;
        mf = new InnerClassLambdaMetafactory(caller, invokedType,
                                             invokedName, samMethodType,
                                             implMethod, instantiatedMethodType,
                                             false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);
        mf.validateMetafactoryArgs();
        return mf.buildCallSite();
    }
&lt;/code&gt;&lt;p&gt;That&#39;s where we would start following the call and dig in, and then search for keywords like &quot;dump&quot;, &quot;trace&quot;, &quot;debug&quot;, etc, to see if there&#39;s any debugging switch/flags embedded in the implementation that would give us more information for debugging.&lt;/p&gt;&lt;br&gt;&lt;p&gt;Have fun debugging!&lt;/p&gt;&lt;h2&gt;What Else?&lt;/h2&gt;&lt;p&gt;Of course, an even better way to get started is to &lt;a href=&quot;https://en.wikipedia.org/wiki/RTFM&quot;&gt;RTFM&lt;/a&gt;. Here&#39;s the design documentation of the lambda expression translation strategy: &lt;a href=&quot;http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html&quot; data-editable=&quot;true&quot; data-title=&quot;Translation of Lambda Expressions&quot; class=&quot;&quot;&gt;Translation of Lambda Expressions&lt;/a&gt;&lt;/p&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">2017-05-29-27159693</guid>
<pubDate>Mon, 29 May 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>考不上三本也会实现数据绑定（二）</title>
<link>https://henix.github.io/feeds/zhuanlan.hllvm/2017-05-25-27111228.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27111228&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3eef6665d6cb158c6d8c1677e11b18fd_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;b&gt;你现在所阅读的并不是第一篇文章，你可能想看&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25959684&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;目录和前言&quot;&gt;目录和前言&lt;/a&gt;。&lt;/b&gt;&lt;/blockquote&gt;我想了想还是拆开写。今天只讲一种简单的表达式的形状，也就是XAML用的属性链。属性链指的就是a.b.c这样的表达式，同时你也可以带有下标，但是下标也只能是属性链。不过在大多数的实现里面，像a[b.c]这样的表达式，只会监视b.c有没有变化，而不会在b.c固定的情况下监视a[x]有没有变化，所以实际上跟只没有下标处理起来是差不多的。&lt;h2&gt;&lt;b&gt;例子&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;让我们来看这样的一个例子，我们要把语句：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;attach(bind(a.b.c.d).ValueChanged, callback);&lt;/code&gt;&lt;p&gt;变成一个触发callback的事件，从而你可以监听他的变化，那到底要处理多少东西呢？如果我们假设每一个属性都有对应的变化事件，那么其实就等于监听&lt;/p&gt;&lt;ul&gt;&lt;li&gt;a.bChanged&lt;br&gt;&lt;/li&gt;&lt;li&gt;a.b.cChanged&lt;/li&gt;&lt;li&gt;a.b.c.dChanged&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;这几个事件。同时我们也做出下面的假设：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;a不会变&lt;br&gt;&lt;/li&gt;&lt;li&gt;多次读取一个属性只会返回相同的值，也就是这个表达式的副作用将被忽略&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;而且a.b变化了，那么原先我们监听的a.b.cChanged就没有用了，我们要解绑它，重新监听一个新的。通常来讲，解绑一个事件，要么是通过直接操作监听事件返回的cookie（如.net的IObservable），要么是直接把cookie交给被监听对象的属性来完成。如果我们取的是后者，那么我们还得把旧的a.b留下来，然后才能正确的解绑事件。你要是不这么做的话，那么我们就会一直在试图监听旧的a.b的cChanged事件，那么新的a.b.c再怎么变化你也不会接到通知。&lt;/p&gt;&lt;p&gt;这就意味着，如果我们监听一个对象o的属性p，那么我们就得把o给cache下来，当o变了的时候，我们才能正确的解绑事件pChanged，然后挂一个新的callback到新的o.pChanged上面去。因此对于表达式a.b.c.d，首先假设a不会变，那么我们要cache下来的就是a.b和a.b.c了。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;代码生成&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;所以我们大概会生成这样的代码：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;class MyDataBinding : Subscription
{
    var cache_a : A^ = null;
    var cache_a_b : B^ = null;
    var cache_a_b_c : C^ = null;
    var handler_a_b : EventHandler^;
    var handler_a_b_c : EventHandler^;
    var handler_a_b_c_d : EventHandler^;

    ctor(a : A)
    {
        // 给a.bChanged上绑
        cache_a = a;
        handler_a_b = attach(cache_a.bChanged, OnChanged_a_b);
        // 绑上剩下的所有事件
        Update_a_b(cache_a.b);
    }

    func Update_a_b(b : B) : void
    {
        // 如果a.b变了，那么要正确处理a.b.cChanged
        if (cache_a_b == b) return;
        // 把旧的a.b.cChanged解绑
        if (handler_a_b_c is not null)
        {
            detach(cache_a_b.cChanged, handler_a_b_c);
        }
        // 把新的a.b.cChanged上绑
        cache_a_b = b;
        handler_a_b_c = attach(cache_a_b.cChanged, OnChanged_a_b_c);
        // 既然a.b变了，那么a.b.c多半也变了
        OnChanged_a_b_c();
    }

    func Update_a_b_c(c : C) : void
    {
        // 如果a.b.c变了，那么要正确处理a.b.c.dChanged
        if (cache_a_b_c == c) return;
        // 把旧的a.b.c.dChanged解绑
        if (handler_a_b_c_d is not null)
        {
            detach(cache_a_b_c.dChanged, handler_a_b_c_d);
        }
        // 把新的a.b.c.dChanged上绑
        cache_a_b_c = c;
        handler_a_b_c_d = attach(cache_a_b_c.dChanged, OnChanged_a_b_c_d);
        // 既然a.b.c变了，那么a.b.c.d多半也变了
        OnChanged_a_b_c_d();
    }

    func OnChanged_a_b() : void
    {
        Update_a_b(cache_a.b);
    }

    func OnChanged_a_b_c() : void
    {
        Update_a_b_c(cache_a_b.c);
    }

    func OnChanged_a_b_c_d() : void
    {
        // 触发ValueChanged事件，调用callback
        ValueChanged(cache_a_b_c.d);
    }
}&lt;/code&gt;&lt;p&gt;然后原来的那段代码就变成了：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;var myDataBinding = new MyDataBinding^(a);
attach(myDataBinding.ValueChanged, callback);&lt;/code&gt;&lt;h2&gt;&lt;b&gt;计算过程&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果bind(a.b.c.d)这样实现的话，那么其实可以看到，如果a.bChanged触发了，那么旧的a.b.cChanged和a.b.c.dChanged都会被解开，然后OnChanged系列函数就挂到了新的a.b.cChanged和a.b.c.dChanged上面去。所以不管是b、c、d这三个属性哪一个变了，ValueChanged事件最终都会触发。&lt;br&gt;&lt;/p&gt;&lt;p&gt;上面这个代码有一个瑕疵，就是构造MyDataBinding的时候，ValueChanged会被触发一次。不过这种小事只要不影响profiling，都不用管。生成代码的算法尽量以简单为好。&lt;/p&gt;&lt;p&gt;生成MyDataBinding的策略很简单，因为我们涉及的属性有&lt;/p&gt;&lt;ul&gt;&lt;li&gt;a.b&lt;br&gt;&lt;/li&gt;&lt;li&gt;a.b.c&lt;br&gt;&lt;/li&gt;&lt;li&gt;a.b.c.d&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;这三个，因此就有以下三个步骤：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;对于a.b&lt;/li&gt;&lt;ul&gt;&lt;li&gt;cache一下a，然后挂上a.bChanged&lt;/li&gt;&lt;ul&gt;&lt;li&gt;生成ctor&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;li&gt;对于a.b.c和a.b.c.d&lt;br&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;cache一下a.b，然后挂上a.b.cChanged&lt;/li&gt;&lt;ul&gt;&lt;li&gt;生成Update_a_b和OnChanged_a_b&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;cache一下a.b.c，然后挂上a.b.c.dChanged&lt;/li&gt;&lt;ul&gt;&lt;li&gt;生成Update_a_b_c和OnChanged_a_b_c&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;li&gt;触发ValueChanged事件&lt;/li&gt;&lt;ul&gt;&lt;li&gt;生成OnChanged_a_b_c_d&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;br&gt;&lt;p&gt;对于a[b.c]这样的表达式，道理也是一样的，就是分别给下标表达式生成MyDataBinding这样的类，最后把它们组合起来，这是一个递归地步骤，留给大家课后练习一下。今天就说到这里了，下一篇就会讲到处理复杂表达式的方法。&lt;/p&gt;&lt;p&gt;其实在这里，a.b的变化会导致a.b.cChanged重挂的事情，就是一个a.b.c对a.b的依赖关系。在复杂的表达式里面，就会有各种各样依赖关系，它们共同组成了一个偏序的关系。举个简单的例子：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;let a = x.y in (a.b + a.c)&lt;/code&gt;&lt;p&gt;a.b和a.c就共同依赖于a，也就是x.y，因此x.yChanged的事件处理函数里面，就要把a.bChanged和a.cChanged都进行重挂。这样的依赖关系当然是不会有环的。&lt;/p&gt;&lt;p&gt;通常来讲，做出这样的一个关系图倒是不难，难的是当你的表达式类型特别多的时候，你做的这些类似把a.b.c替换成cache_a_b_c和cache_a_b.c这样的工作，就容易出bug。这些还得靠你多写几个测试用例来保证。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;后注&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;UWP的{x:Bind}比起{Binding}先进的地方在于，Binding需要运行时的反射，而x:Bind是不需要的。但是XAML的编译器在处理x:Bind的时候，怎么知道a、a.b、a.b.c和a.b.c.d的类型，从而生成出正确的代码呢？这通常有两个办法：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;你可以想办法让XAML编译器知道他们的类型。对于x:Bind，这是通过cl、midl、mdmerge和xamlcompiler这几个程序共同实现的。其中的辛酸，只有手写idl文件的人才能明白（逃。这种方法不仅可以支持C++，也可以支持WinRT上面的任何编程语言。&lt;br&gt;&lt;/li&gt;&lt;li&gt;如果是想支持C++的话，其实你完全可以通过模板的技巧来计算出所有的这些东西，只要你使用同样的语法来在所有可以绑定的对象身上读取属性和挂事件就可以。x:Bind的灵感其实是从Office借去的（包括以前的XAML），而Office又怎么有办法修改cl呢？所以内部的工具就通过生成模板类和函数的方法来解决。&lt;/li&gt;&lt;/ul&gt;</description>
<author>vczh</author>
<guid isPermaLink="false">2017-05-25-27111228</guid>
<pubDate>Thu, 25 May 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>[Graal] 原来Substrate VM已经公开二进制发布版了</title>
<link>https://henix.github.io/feeds/zhuanlan.hllvm/2017-05-19-26988266.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26988266&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
Oracle Labs有一个“神秘项目”叫做Substrate VM，主要用于将使用Truffle框架+Graal编译器的语言实现AOT编译到一个紧凑的二进制版本，并链接上一个精巧高效的runtime（也就是Substrate VM自身），以此来提升用Truffle实现的语言的启动性能以及减小其内存开销。简单说，它的目标就是让用Java写的、基于Truffle框架的编程语言实现，在各种指标上都能媲美甚至超过手工用C/C++写的、优化过的语言实现。它由Christian Wimmer带队开发，已经在各大会议刷了几圈，但一直没有对外公开发布其实体；外界对它的了解仅限于一些论文和tutorial。&lt;p&gt;小道消息的传闻说由Truffle/Substrate VM驱动的FastR已经在Oracle数据库产品中发布了好一段时间了，虽然对外并未大力宣传里面的技术关联。&lt;/p&gt;&lt;p&gt;去年的JVMLS上跟Christian聊天，他说或许去年下半年就可以看到Substrate单独对外发布了。可是等等等就是没等到。&lt;/p&gt;&lt;p&gt;刚才突然发现原来在GraalVM 0.20开始Substrate VM就“悄悄地”发布出来了。从Oracle Labs的Graal项目页面下载GraalVM，里面的 bin/aot-image 命令就可以打包出一个AOT编译的、与Substrate VM runtime链接在一起的二进制包。&lt;/p&gt;&lt;p&gt;相关链接：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Oracle Labs GraalVM项目页面：&lt;a href=&quot;http://www.oracle.com/technetwork/oracle-labs/program-languages/overview/index-2301583.html&quot; data-editable=&quot;true&quot; data-title=&quot;Programming Languages and Runtimes Overview&quot; class=&quot;&quot;&gt;GraalVM - New JIT Compiler and Polyglot Runtime for the JVM&lt;/a&gt;&lt;/li&gt;&lt;li&gt;GraalVM下载页面：&lt;a href=&quot;http://www.oracle.com/technetwork/oracle-labs/program-languages/downloads/index.html&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;Oracle Labs GraalVM&quot;&gt;Oracle Labs GraalVM&lt;/a&gt;，当前的GraalVM版本是0.22&lt;/li&gt;&lt;a href=&quot;http://nirvdrum.com/2017/02/15/truffleruby-on-the-substrate-vm.html&quot; data-editable=&quot;true&quot; data-title=&quot;TruffleRuby on the Substrate VM&quot;&gt;TruffleRuby on the Substrate VM&lt;/a&gt;&lt;br&gt;&lt;li&gt;GraalVM 0.20 release notes：&lt;a href=&quot;http://mail.openjdk.java.net/pipermail/graal-dev/2017-February/004856.html&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;GraalVM 0.20 Release&quot;&gt;GraalVM 0.20 Release&lt;/a&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;This release now includes the Substrate VM image builder (bin/aot-image). It is possible to create SVM executable images of Graal.JS using &quot;bin/aot-image --js&quot; and TruffleRuby using &quot;bin/aot-image --ruby&quot;.&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=FJY96_6Y3a4&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;One VM to Rule Them All, One VM to Bind Them&quot;&gt;One VM to Rule Them All, One VM to Bind Them&lt;/a&gt;（录像），PLDI 2016上的Truffle Tutorial&lt;br&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;PLDI页面：&lt;a href=&quot;http://conf.researchr.org/event/pldi-2016/tutorials-one-vm-to-rule-them-all-one-vm-to-bind-them&quot; data-editable=&quot;true&quot; data-title=&quot;One VM to Rule Them All, One VM to Bind Them&quot; class=&quot;&quot;&gt;One VM to Rule Them All, One VM to Bind Them&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;演示稿：&lt;a href=&quot;https://lafo.ssw.uni-linz.ac.at/pub/papers/2016_PLDI_Truffle.pdf&quot; data-editable=&quot;true&quot; data-title=&quot;uni-linz.ac.at 的页面&quot; class=&quot;&quot;&gt;https://lafo.ssw.uni-linz.ac.at/pub/papers/2016_PLDI_Truffle.pdf&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=2509581&quot; class=&quot;&quot; data-editable=&quot;true&quot; data-title=&quot;One VM to Rule Them All&quot;&gt;One VM to Rule Them All&lt;/a&gt;，2013年的论文&lt;br&gt;&lt;/li&gt;&lt;li&gt;其它论文和演讲：&lt;a href=&quot;https://wiki.openjdk.java.net/display/Graal/Publications+and+Presentations&quot; data-editable=&quot;true&quot; data-title=&quot;Publications and Presentations&quot;&gt;Publications and Presentations&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description>
<author>RednaxelaFX</author>
<guid isPermaLink="false">2017-05-19-26988266</guid>
<pubDate>Fri, 19 May 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
