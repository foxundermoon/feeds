<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>Milo的编程</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/</link>
<description></description>
<language>zh-cn</language>
<lastBuildDate>Fri, 02 Mar 2018 14:17:45 +0800</lastBuildDate>
<item>
<title>Milo的知乎2017</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2018-01-01-32521954.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32521954&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-81c07ee78170e087a12805873c62e3e2_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;2017年为了改善自己的身体状况，在知乎&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25493253&quot;&gt;休息&lt;/a&gt;了一段时间，所以今年投入创作的时间减少了。另外，本年有幸获得知乎盐 Club 荣誉会员（获 3568 票）。&lt;/p&gt;&lt;p&gt;按2018元旦的累积数字和&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24664465&quot;&gt;去年&lt;/a&gt;对比，得到以下数据，括号内的为累积总数（自 2011 年）。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;回答了 277 个问题（1474）&lt;/li&gt;&lt;li&gt;发布了 19 篇文章（51）&lt;/li&gt;&lt;li&gt;发布了 41 个想法（41）&lt;/li&gt;&lt;li&gt;获 68919 个赞同（197509）&lt;/li&gt;&lt;li&gt;获 6233 个感谢（28570）&lt;/li&gt;&lt;li&gt;获 43949 次收藏（131802）&lt;/li&gt;&lt;li&gt;获 43979 人关注（125095）&lt;/li&gt;&lt;li&gt;获 436.47 元（2309.33）&lt;/li&gt;&lt;/ul&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f763464f917228f0387bf4ea4c526d21_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;742&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-558b4db991dc6aab99df5536b1d881b6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;742&quot;&gt;&lt;p&gt;感谢各位支持，2018 年继续努力（填坑）。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2018-01-01-32521954</guid>
<pubDate>Mon, 01 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>《写生机器人》制作经验分享（上）</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2017-12-25-32084037.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32084037&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic7.zhimg.com/v2-2227224aab303f50deea51da1e4ff436_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;我在《&lt;a href=&quot;https://www.zhihu.com/question/263477736/answer/269707887&quot;&gt;对编程感兴趣的程序员是否都对电路、单片机也怀有浓厚的兴趣？ &lt;/a&gt;》展示了前两年制作的一个写生机器人，不少网友表示感兴趣，故撰本文回顾制作历程及感悟。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;1. 起源&lt;/h2&gt;&lt;p&gt;在 2014 年，当时我已经开发&lt;b&gt;软件&lt;/b&gt;算有二十多年（第一个主导的商业游戏项目《王子传奇》在1995年台湾发行）。然而，除了懂得一些简单的、中学物理课学到的电子知识，从来没接触过&lt;b&gt;硬件&lt;/b&gt;开发。和读计算机相关专业的朋友不一样，我本科读的是认知科学（cognitive science，在香港大学属社会科学院），完全没有硬件方面的课。&lt;/p&gt;&lt;p&gt;因此，那个时候想学习一下硬件开发，扩阔视野。&lt;/p&gt;&lt;p&gt;最初，我在网上买了一套一百多块的 Arduino 入门套装，按着 [1] 的例子学习，如控制 LED／7段 LED、处理按钮／电位器输入、控制电机／舵机等。有赖 Arduino 团队的努力，开发环境和 API 都十分简单易用，熟悉 C/C++的程序员可轻松入门。&lt;/p&gt;&lt;p&gt;但经验告诉我，&lt;/p&gt;&lt;blockquote&gt;要提升一门技术的水平，最好是从做一个项目中学习。&lt;/blockquote&gt;&lt;p&gt;当时，我工作的部门（腾讯／IEG 互动娱乐事业群／研发部）正宣传举办第一届的《Intel杯创新大赛》，让IEG 同事创作作品，范围包括智能硬件、VR／AR 等，每年举办两次。我便鼓起勇气参加了。那么，做什么好呢？&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;2. 构思&lt;/h2&gt;&lt;p&gt;我先考虑自己懂什么，以及想做些什么。&lt;/p&gt;&lt;p&gt;最后的构思源于以下的经历：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;本科专业是&lt;b&gt;认知科学&lt;/b&gt;，研究信息如何在大脑中形成及转录过程的跨领域学科；&lt;/li&gt;&lt;li&gt;对计算机图形学比较了解，有幸成为知乎计算机图形学的优秀回答者；&lt;/li&gt;&lt;li&gt;在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/23725230&quot;&gt;程序员可以学画画吗？ &lt;/a&gt;》提及我在业余学过基本&lt;b&gt;素描&lt;/b&gt;和&lt;b&gt;油画&lt;/b&gt;；&lt;/li&gt;&lt;li&gt;我想做一些&lt;b&gt;会动&lt;/b&gt;的东西，因为以前做的软件，即使有动画及互动内容，都是困于屏幕之中。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我曾在 YouTube 看过一个绘画机器人的艺术项目 [2]，我觉得和我上述的经历吻合，引发了一些思考。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-081992f24b7efbe42c1fffb82dc8339c_r.jpg&quot; data-caption=&quot;Portrait drawing by Paul the robot [2]&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot;&gt;&lt;p&gt;我以前学画的时候，也会想一些问题，也和老师讨论过。&lt;/p&gt;&lt;p&gt;绘画是越写实越好么？不是。要写实的话，摄影更写实。绘画和摄影有相似的地方，但不能互相取代。&lt;/p&gt;&lt;p&gt;绘画（以下主要指写生）和摄影的主要区别是什么？画家在构图后，还可以选择要表达的重点。另外，写生是一个较长期的渐进过程，从整体粗略至局部细致，过程中不断观察比对画作和对象。这和摄影通常一次曝光（通常是几十分之一秒），然后显影很不一样。&lt;/p&gt;&lt;p&gt;也因此，同一对象、同一灯光、同一构图下，即使不同的摄影师也几乎得到相同的作品。而画家则会因当时对对象的不同观察和想法、不同的手法表现，得出独一无二的作品。这也许存在争议，纯粹是个人的一个想法。&lt;/p&gt;&lt;p&gt;我当时想到，如果要做一个机器人模仿人类进行写生，要怎么做才可以重现出这种区别，创作出独一无二的作品，而不只是用相机拍下然后打印？我想到 3 点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;模仿人的&lt;b&gt;多关节肢体&lt;/b&gt;，使用真实绘画素材（如铅笔、走珠笔、绘图笔、秀丽笔、油漆笔），而非用打印机。虽然用 XY plotter 也可用上绘画素材，但完全不像人的手。&lt;/li&gt;&lt;li&gt;模仿人的&lt;b&gt;视觉系统&lt;/b&gt;，可以持续观察写生对象及当前的画作，进行对比。&lt;/li&gt;&lt;li&gt;模仿人的&lt;b&gt;渐进写生过程&lt;/b&gt;，而非完全的机械式输入处理输出。而且，对象可能会随时间改变（如人像、风景），作品可包含这些时间的变化。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我没怎么想商业价值，觉得这个机器人更像是一个互动的装置艺术。我希望每张作品都是独一无二的艺术品。&lt;/p&gt;&lt;p&gt;记得以前读认知科学时，要评估一些认知能力模型是否好，其中一个方法是用计算机去模拟出来，看看能否模仿生物的那些能力。所以从研究的角度来说，这个项目也许涉及艺术风格的模仿及研究。&lt;/p&gt;&lt;p&gt;不过，我并没有把上述的所有构思都实现。基于时间和能力所限，只是做一个非常简化的版本。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;3. 设计&lt;/h2&gt;&lt;p&gt;如果只做算法部分，或可购买现成的机器臂，或是组装现成的套件。但我没学过机械设计，希望借这个项目尝试一下。&lt;/p&gt;&lt;p&gt;当时常见到的玩具机器人和机器臂，一般都使用舵机（摇控模型的直流伺服电机／RC servo）作为致动器（actuator），而 [1] 的机器臂也是用这种构造。这种机器臂构造简单，控制也容易（用 PWM 信号控制目标角度），但缺点也是很明显的，角度不够精确，也难以控制转动的速度，画出来的作品抖动明显。&lt;/p&gt;&lt;p&gt;我从 [3] 学习到一些致动器原理及传动系统，似乎步进电机（stepper motor）是更好的选择，可以用一个脉冲控制电机旋转一个很小的角度。那么我可以用编程的方法，精准地控制旋转速度。&lt;/p&gt;&lt;p&gt;我没有读机器臂相关的书，只是从需求去设计：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;画在 A3 大小的纸张。一般的玩具机器臂没有这么大的移动范围。&lt;/li&gt;&lt;li&gt;容易制作。因为没有技术、设备。&lt;/li&gt;&lt;li&gt;成本比较低。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我想，最简单需要一个水平二维移动的手，再加上一个垂直移动的持笔装置。二维移动需要至少两个自由度（degree of freedom, DOF），加上垂直移动共 3 个 DOF。那么，需要模拟上臂、下臂和手三部分。&lt;/p&gt;&lt;p&gt;构造上，最简单的是把电机放到关节上，但步进电机一般比舵机重，而机器臂也要足够长，会不会太重？太重有两个问题：上臂的关节要承受因重力而生的大力矩，底座要很重才能平衡。&lt;/p&gt;&lt;p&gt;因此，我想到的方案是把电机都放在底座，通过带子传动。后来知道这些构件称为同步轮（synchornized wheel）和同步带（synchronized belt）。我想到这个设计还有 4 个好处：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;手臂不用放置电机，使手臂轻很多，旋转两个关节所需的力矩变小。&lt;/li&gt;&lt;li&gt;上臂的关节不用直接使用步进电机的输出轴，而可以用上更粗、更坚固的轴，令系统更强健。&lt;/li&gt;&lt;li&gt;系统中最重的部件（步进电机）位于底座，而且可放在手臂的另一端，令重心接近第一关节，更稳定。&lt;/li&gt;&lt;li&gt;采用不同大小的同步轮，可作进一步减速，提升精确性。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;要做设计，首先要知道有什么零件可以使用。我在网上找寻合适的零件，包括电机、传动和结构上的。我发现最平宜的结构是用板材配合立柱，用螺丝紧固。&lt;/p&gt;&lt;p&gt;然后绘画各部分的草图：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ae3cb7ce87c60d0fb7bff6cd891ef455_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1481&quot;&gt;&lt;p&gt;我最不了解的是各种轴承（bearing），没想到会这样复杂，不确定是否需要这么多轴承。设计时要匹配各种轴承的尺寸，我通过不断搜寻轴承目录，试各种尺寸的组合，才得出设计方案。同步轮也有同样问题，设计都是要配合现成能买到的规格。&lt;/p&gt;&lt;p&gt;另外，垂直移动的持笔装置也是设计的难点。我看到一些持笔装置是用舵机的，感觉不能很精确控制高度，而且持笔不够稳固。如果要用秀丽笔控制高度来画不同粗细，最好还是精确一点。最后我的方案是用直线轴承，轴承中放置铝管，铝管中固定笔枝，再配合小型的直线步进电机。直线步进电机常见于光驱，控制激光的轨道位置，可以非常精确。因为笔支不重，细小的直线步进电机已经足够，而且它的控制也和其他步进电机一样简单。&lt;/p&gt;&lt;p&gt;我没学过机械制图，只有 3dsMax、SketchUp的使用经验。我找了一下流行的相关设计软件，最后下载了 SolidWorks 的试用版本来学习。 SolidWorks 确实是十分容易使用，我花了两周左右（如没记错）的工余时间便学习并画出以下的设计图和渲染圖：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6c7a05acb0fb621319f1d8a36835b4ba_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1191&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-27040ae6596d492ea5a1b1a8cc3ff41f_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;960&quot;&gt;&lt;p&gt;不过，我还是不太了解 SolidWorks 的约束系统，第一次画图应该有很多问题。而设计时，很多数值（例如光轴要多粗的、板材要多厚的、电机要多大力矩的）我也没有深究，应该都是高于实际的要求。我并没有做力学方面的模拟，做了的话应该可以再降低成本。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;4. 机器臂制作&lt;/h2&gt;&lt;p&gt;我在网上找公司按图切割铝合金板，并购买所有的部件。制作中还需要一些工序，所以后来也购买了电钻床和夹钳等工具。&lt;/p&gt;&lt;p&gt;如同模型一样，组装这个机器臂是很好玩的环节。在设计时，我并没有很在意组装次序，所以组装时发现确实是有点难度，试过错放漏放部件，要拆掉重来。&lt;/p&gt;&lt;p&gt;持笔的铝管需要固定笔枝，我采用的是在管铝上攻丝，这样也方便更换笔枝。第一次手工攻丝还是觉得有点难度，记得做了两枝铝管才成功。&lt;/p&gt;&lt;p&gt;主要部分完成组装后，就接上电机控制器和 Arduino 去测试。非常成功地旋转了！但是⋯⋯同步带不够紧！&lt;/p&gt;&lt;p&gt;当初设计时，我参考了一个网站，按同步带类型／长度、同步轮半径去计算轴距的长度。然而，没想到最后还是有点松。看了一些其他用同步带的设计，原来都要加一个可调的滑轮去控制松紧！没辨法之下，我要拆开部件钻孔，买立柱和轴承作为滑轮。&lt;/p&gt;&lt;p&gt;而且！我设计时没考虑到怎样检测手臂复位！我买的是没有角度回馈的步进电机，在开始时需要把手臂转到一个初始角度做复位。我唯有临时加上了两个微动开关去检测手臂是否到达初始角度。&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-043ccd20bdd3e9b64544e6b00974de21_r.jpg&quot; data-caption=&quot;红圈中的是后来加入的滑轮，黄圈中的是后来加入的微动开关&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;919&quot;&gt;&lt;p&gt;这两个失误说明，经验还是很重要的。不过，第一次做这方面的设计，能正常地动起来，我已经很满足了。而且整个手臂很坚固，旋转也很顺滑细致，单凭想像力去做的设计还算不错吧。&lt;/p&gt;&lt;p&gt;经过简单测试（用固定频率旋转两个轴），设置步进电机驱动器使用16 微步进（micro stepping）模式没什么问题，能实现两个关节 旋转，最高 末端精度（距离底座半径越大精度越低）。这样已经足够了，编程随便画些东西！&lt;/p&gt;&lt;p&gt;很久以后我发图出来，才有网友说这不是&lt;a href=&quot;https://en.wikipedia.org/wiki/SCARA&quot;&gt;SCARA&lt;/a&gt;嘛。啊？我真不知道。如果有导师指导应该会好很多，不过胡猜瞎试也是另一种乐趣。&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-cbd5c076959cc92f741cd552df2e364e_r.jpg&quot; data-caption=&quot;三菱的SCARA机器臂&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1188&quot;&gt;&lt;hr&gt;&lt;h2&gt;5. 绘画直线算法&lt;/h2&gt;&lt;p&gt;除了画点以外，最简单的图形应该是直线。我比较熟悉在光栅图像里画线的方法，最近也写过一篇《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30553006&quot;&gt;用 C 语言画直线&lt;/a&gt;》。然而，Bresenham 画线算法源于控制 XY plotter，不能用在旋转关节。&lt;/p&gt;&lt;p&gt;设计机械臂硬件的时候，我也没有仔细去想怎样编程，心想：「应该没什么问题吧，到时再想。」&lt;/p&gt;&lt;p&gt;我不但没学过机械设计，也没学过控制。在图形学中学过逆向运动学（inverse kinematics），可以把目标的世界坐标转换成关节的角度。但似乎不行，我不知道世界坐标中应该步进多长的距离，两个旋转角度又怎样用多个单步、什么频率？&lt;/p&gt;&lt;p&gt;这次我也没有直接去找相关专著找答案。我觉得这应该不会是十分困难的问题，我尝试自行想个算法解决。&lt;/p&gt;&lt;p&gt;分析一下，先不考虑频率，我们每个离散步只能有 8 种输出：每个轴顺时针步进／逆时针步进／待机，但不会两个轴同时待机， &lt;equation&gt;3^2-1= 8&lt;/equation&gt;  。那么，我们可以分别对 8 种输出，计算出旋转后的末端世界坐标。然后，找出向直线方向移动（不应回头）而又最接近直线的一种输出！&lt;/p&gt;&lt;p&gt;我实验用这个算法，画各种角度的直线、正方形，效果也不错！ ⋯⋯但是有点抖。&lt;/p&gt;&lt;p&gt;这是因为，每次移动的距离是不一样的，但我都只是简单地延迟相同的间隔，所以直线上的移动速度并不平均。这并不难解决，只要按该步的欧氏距离及目标速度，就能计算出该步的延迟时间。实验也成功显示这样会减少抖动。&lt;/p&gt;&lt;p&gt;还有一个问题，就是开始和结束的时候的抖动。这是因为我们开始时从静止突然加速到目标速度，结束时则相反。解决方法是引入线性加速度，让笔从慢至快、快至慢地移动。以下实际上是第二届比赛前录制的视频，但能演示画直线的动作：&lt;/p&gt;&lt;video id=&quot;None&quot; data-swfurl=&quot;&quot; poster=&quot;https://pic4.zhimg.com/80/v2-d6990bd74059cc4e09d585c492cb2377_b.jpg&quot; data-sourceurl=&quot;https://www.zhihu.com/video/928749126110298112&quot; data-name=&quot;&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-lens-id=&quot;928749126110298112&quot;&gt;&lt;/video&gt;&lt;hr&gt;&lt;h2&gt;6. 第一届Intel杯创新大赛&lt;/h2&gt;&lt;p&gt;因为当时已接近第一届的比赛日子，我决定这一届只提交机器臂的部分。我继续写了个简单的 SVG 解析器，把 Bezier 曲线分割成线段绘画。下面是画一幅 SVG 的过程片段：&lt;/p&gt;&lt;video id=&quot;None&quot; data-swfurl=&quot;&quot; poster=&quot;https://pic4.zhimg.com/80/v2-8c617f47adaa140b990c8a0388f24157_b.jpg&quot; data-sourceurl=&quot;https://www.zhihu.com/video/928757235193114624&quot; data-name=&quot;&quot; data-video-id=&quot;&quot; data-video-playable=&quot;true&quot; data-lens-id=&quot;928757235193114624&quot;&gt;&lt;/video&gt;&lt;p&gt;最后做 presentation、演讲、即场演示，赢得第一届Intel杯创新大赛一等奖！&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-db8105ef03e5673b895b2a5c504efc67_r.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1062&quot;&gt;&lt;p&gt;从最初构想至第一届创新大赛比赛日大约历时一年，但实际上有很多个月都没有搞，估计大约花了三个月左右的工余时间。由于工具和硬件都在公司，而我晚上又坐班车回家，所以除了设计阶段在家里进行，其他都是用午饭时间搞的。&lt;/p&gt;&lt;p&gt;此阶段的制作成本（不包括工具）一览：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{array}{lr} 部件 &amp;amp; \text{RMB}\\ \hline \text{7075铝合金3mm板材及切割} &amp;amp; 217\\ 铝合金支柱及紧固件 &amp;amp; 100\\ 42步进电机\times 2、光驱步进电机及驱动 &amp;amp; 170\\ 同步轮及同步带 &amp;amp; 160\\ 铬镀轴光轴及轴承 &amp;amp; 30\\ \text{Arduino Mega} &amp;amp; 34\\ \hline 合计 &amp;amp; 711\\ \end{array}\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;下篇讲述继续参加第二届创新大赛，加入 Intel RealSense 和实现素描算法，以及对这个项目的感悟。&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;p&gt;[1] McRoberts, Michael, Brad Levy, and Cliff Wootton. &lt;i&gt;Beginning Arduino&lt;/i&gt;. New York.: Apress, 2010.《Arduino从基础到实践》，杨继志、郭敬译，电子工业出版社，2013。（已有中文版第二版）&lt;/p&gt;&lt;p&gt;[2] Tresset, Patrick, and Frederic Fol Leymarie. &quot;Portrait drawing by Paul the robot.&quot; Computers &amp;amp; Graphics 37.5 (2013): 348-363.&lt;/p&gt;&lt;p&gt;[3] Roberts, Dustyn. &lt;i&gt;Making Things Move DIY Mechanisms for Inventors, Hobbyists, and Artists&lt;/i&gt;. McGraw Hill Professional, 2010. 《Maker机械电子创意实现与项目制作》，郭洪红译， 科学出版社，2013。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2017-12-25-32084037</guid>
<pubDate>Mon, 25 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>用C语言画光（七）：比尔-朗伯定律</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2017-12-11-31901449.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31901449&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-fd045c136f75263c865390c69518016a_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31127076&quot;&gt;（五）折射&lt;/a&gt; 和&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31534769&quot;&gt;（六）菲涅耳方程&lt;/a&gt; 里，我们谈及光怎样穿过表面，透射至物体内部。我们假设了光在物体中传播时不会衰减。然而，除了真空，光线通过不同物质都会被散射和吸收，例如我们看到天空是蓝色的，也是因为不同波长的光被空气粒子散射程度不一样所致；如果阳光没有被空气粒子散射，天空应该是透明的。&lt;/p&gt;&lt;p&gt;本文描述一种简单方法去模拟光被材质吸收，也会首次尝试加入色彩。&lt;/p&gt;&lt;h2&gt;1. 比尔-朗伯定律&lt;/h2&gt;&lt;p&gt;比尔-朗伯定律（Beer-Lambert law）描述电磁波（如可见光）通过物体时，物体吸收部分电磁波，而吸收率与物体的厚度（光程距离）、物质的吸光系数及其浓度相关。[1] P.393 给出的比尔-朗伯定律形式为：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;T = e^{-\alpha&#39;cd}\tag{1}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;当中， &lt;equation&gt;T\in[0,1]&lt;/equation&gt; 为透射率， &lt;equation&gt;\alpha&#39; \in [0, \infty)&lt;/equation&gt; 为物质的吸光系数， &lt;equation&gt;c \in [0, \infty)&lt;/equation&gt; 为浓度， &lt;equation&gt;d \in [0, \infty)&lt;/equation&gt; 为光程距离。&lt;/p&gt;&lt;p&gt;若物体是均质的，那么 &lt;equation&gt;\alpha&#39;&lt;/equation&gt; 和 &lt;equation&gt;c&lt;/equation&gt; 为常量，可以看到(1)是服从&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B0%E8%A1%B0%E5%87%8F&quot;&gt;指数衰减&lt;/a&gt;的。例如，若光通过距离 &lt;equation&gt;\Delta d&lt;/equation&gt; 会衰减成原来的 50%，那么通过 &lt;equation&gt;2\Delta d&lt;/equation&gt; 的话就会衰减成原来的 25%。&lt;/p&gt;&lt;p&gt;在这里应用时，由于 &lt;equation&gt;\alpha&#39;&lt;/equation&gt; 和 &lt;equation&gt;c&lt;/equation&gt; 为物理上的单位，而它们又是常数，我们可用单个参数 &lt;equation&gt;a = \alpha&#39;c&lt;/equation&gt; 去表示材质对吸收的光收特性：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;T = e^{-ad}\tag{2}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;下图展示 &lt;equation&gt;a&lt;/equation&gt; 分别为 1, 2, 3, 4, 5 时，距离 &lt;equation&gt;d&lt;/equation&gt; 和透射率 &lt;equation&gt;T&lt;/equation&gt; 的关系：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-41469ee5da7f9051049920ff291d5010_r.jpg&quot; data-caption=&quot;图 1：指数衰减&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;584&quot; data-rawheight=&quot;326&quot;&gt;&lt;h2&gt;2. 实现&lt;/h2&gt;&lt;p&gt;实现只需三步。第一步，简单把 (2) 写成一行 C 函数：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;float beerLambert(float a, float d) {
    return expf(-a * d);
}&lt;/code&gt;&lt;p&gt;第二步，在场景定义中加入吸收率：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;typedef struct { float sd, emissive, reflectivity, eta, absorption; } Result;&lt;/code&gt;&lt;p&gt;第三步，追踪到表面时，依追踪距离计算吸收率，乘以从那个方向得到的光强总量：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;float trace(float ox, float oy, float dx, float dy, int depth) {
    // ...
    for (int i = 0; i &amp;lt; MAX_STEP &amp;amp;&amp;amp; t &amp;lt; MAX_DISTANCE; i++) {
        // ...
        if (r.sd * sign &amp;lt; EPSILON) {
            float sum = r.emissive;
            // 计算反射和折射
            return sum * beerLambert(r.absorption, t); // &amp;lt;－ 只改这一行
        }
        // ...
    }
    // ...
}&lt;/code&gt;&lt;p&gt;我们把一个长方形设置 &lt;equation&gt;a=4&lt;/equation&gt; ，和之前的结果比较：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Result scene(float x, float y) {
    Result a = { circleSDF(x, y, -0.2f, -0.2f, 0.1f), 10.0f, 0.0f, 0.0f, 0.0f };
    Result b = {    boxSDF(x, y, 0.5f, 0.5f, 0.0f, 0.3, 0.2f), 0.0f, 0.2f, 1.5f, 4.0f };
    return unionOp(a, b);
}&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-cd8ae4706fda58f5d1fdc419c73a84a5_r.jpg&quot; data-caption=&quot;图2：开启比尔-朗伯定律的前后比较&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;516&quot; data-rawheight=&quot;276&quot;&gt;&lt;p&gt;可以清楚看到，图2(b)中光线通过物体表面后，距离越远就变得越暗。&lt;/p&gt;&lt;p&gt;不过，单色的效果不太好看，如果物质对不同波长的吸收率不一样，效果就会更明显了。&lt;/p&gt;&lt;h2&gt;3. 色彩&lt;/h2&gt;&lt;p&gt;为了简单起见，之前我们一直只是用单色光，生成灰阶图像。我们使用 RGB 色彩模型，把色彩定义为三维矢量 &lt;equation&gt;\mathbb{R}^3&lt;/equation&gt; ，并需要三个运算：加法、乘法（哈达马积／&lt;a href=&quot;https://en.wikipedia.org/wiki/Hadamard_product_(matrices)&quot;&gt;Hadamard product&lt;/a&gt;）及缩放（乘以纯量），实现如下：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define BLACK { 0.0f, 0.0f, 0.0f }

typedef struct { float r, g, b; } Color;

Color colorAdd(Color a, Color b) {
    Color c = { a.r + b.r, a.g + b.g, a.b + b.b };
    return c;
}

Color colorMultiply(Color a, Color b) {
    Color c = { a.r * b.r, a.g * b.g, a.b * b.b };
    return c;
}

Color colorScale(Color a, float s) {
    Color c = { a.r * s, a.g * s, a.b * s };
    return c;
}&lt;/code&gt;&lt;p&gt;为了方便，上面还定义了一个 &lt;equation&gt;\texttt{BLACK}&lt;/equation&gt; 的宣代表黑色 &lt;equation&gt;\texttt{Color}&lt;/equation&gt; 的初始值。&lt;/p&gt;&lt;p&gt;然后，我们把想要支持色彩的场景定义参数（如自发光和吸收率）的类型，从 &lt;equation&gt;\texttt{float}&lt;/equation&gt; 改为 &lt;equation&gt;\texttt{Color}&lt;/equation&gt; ：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;typedef struct {
    float sd, reflectivity, eta;
    Color emissive, absorption;
} Result;&lt;/code&gt;&lt;p&gt;实际上， &lt;equation&gt;\texttt{reflectivity}&lt;/equation&gt; 和 &lt;equation&gt;\texttt{eta}&lt;/equation&gt; 都可以支持色彩，不过暂时本文不作这支持。&lt;/p&gt;&lt;p&gt;然后， &lt;equation&gt;\texttt{beerLambert()}&lt;/equation&gt; 、 &lt;equation&gt;\texttt{trace()}&lt;/equation&gt; 和 &lt;equation&gt;\texttt{sample()}&lt;/equation&gt; 函数都改为返回 &lt;equation&gt;\texttt{Color}&lt;/equation&gt; 类型。我们甚至可以通过编译的错误信息，来找到需要修改的代码，以下展示了这些改动：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Color beerLambert(Color a, float d) {
    Color c = { expf(-a.r * d), expf(-a.g * d), expf(-a.b * d) };
    return c;
}

Color trace(float ox, float oy, float dx, float dy, int depth) {
    // ...
    for (int i = 0; i &amp;lt; MAX_STEP &amp;amp;&amp;amp; t &amp;lt; MAX_DISTANCE; i++) {
        // ...
        if (r.sd * sign &amp;lt; EPSILON) {
            Color sum = r.emissive;
            if (depth &amp;lt; MAX_DEPTH &amp;amp;&amp;amp; r.eta &amp;gt; 0.0f) {
                // ...
                if (r.eta &amp;gt; 0.0f) {
                    if (refract(/* ... */) {
                        // ...
                        sum = colorAdd(sum, colorScale(trace(x - nx * BIAS, y - ny * BIAS, rx, ry, depth + 1), 1.0f - refl));
                    }
                    // ...
                }
                if (refl &amp;gt; 0.0f) {
                    // ...
                    sum = colorAdd(sum, colorScale(trace(x + nx * BIAS, y + ny * BIAS, rx, ry, depth + 1), refl));
                }
            }
            return colorMultiply(sum, beerLambert(r.absorption, t));
        }
        // ...
    }
    Color black = BLACK;
    return black;
}

Color sample(float x, float y) {
    Color sum = BLACK;
    for (int i = 0; i &amp;lt; N; i++) {
        float a = TWO_PI * (i + (float)rand() / RAND_MAX) / N;
        sum = colorAdd(sum, trace(x, y, cosf(a), sinf(a), 0));
    }
    return colorScale(sum, 1.0f / N);
}&lt;/code&gt;&lt;p&gt;最后，在输出每个像素时，分别顺序写入R、G 和 B 通道，就能生成彩色图像：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int main() {
    unsigned char* p = img;
    for (int y = 0; y &amp;lt; H; y++)
        for (int x = 0; x &amp;lt; W; x++, p += 3) {
            Color c = sample((float)x / W, (float)y / H);
            p[0] = (int)(fminf(c.r * 255.0f, 255.0f));
            p[1] = (int)(fminf(c.g * 255.0f, 255.0f));
            p[2] = (int)(fminf(c.b * 255.0f, 255.0f));
        }
     // ...
}&lt;/code&gt;&lt;p&gt;我们加入一个新的正多边形 SDF（本文暂不阐述），并让它吸收更多的绿色和红色：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Result scene(float x, float y) {
    Result a = { circleSDF(x, y, 0.5f, -0.2f, 0.1f), 0.0f, 0.0f, { 10.0f, 10.0f, 10.0f }, BLACK };
    Result b = {   ngonSDF(x, y, 0.5f, 0.5f, 0.25f, 5.0f), 0.0f, 1.5f, BLACK, { 4.0f, 4.0f, 1.0f} };
    return unionOp(a, b);
}&lt;/code&gt;&lt;p&gt;渲染结果：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c6884a16e001c3dfa4b5eaad2df97eb1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;h2&gt;4. 结语&lt;/h2&gt;&lt;p&gt;本文用了比尔-朗伯定律模拟了光线被物体吸收，可以模拟一些透明（有色）物体。而真实世界中，一些粒子除了吸收光，也会散射至其他方向，其模拟会复杂很多。&lt;/p&gt;&lt;p&gt;另外，本文也讲解如何把单色渲染改为彩色渲染，作为练习，读者也可把反射及折射率加入彩色的处理，不过折射率的改动会多一些，留给读者思考。&lt;/p&gt;&lt;p&gt;我们一连三篇模拟了三个物理定律（斯涅尔、菲涅耳、比尔-朗伯），下一篇我们换一个话题。&lt;/p&gt;&lt;p&gt;本文的源代码位于 &lt;a href=&quot;https://github.com/miloyip/light2d/blob/master/beerlambert.c&quot;&gt;beerlambert.c&lt;/a&gt;、&lt;a href=&quot;https://github.com/miloyip/light2d/blob/master/beerlambert_color.c&quot;&gt;beerlambert_color.c&lt;/a&gt; 及 &lt;a href=&quot;https://github.com/miloyip/light2d/blob/master/heart.c&quot;&gt;heart.c&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;p&gt;[1] Akenine-Möller, Tomas, Eric Haines, and Naty Hoffman. &lt;i&gt;Real-time rendering,&lt;/i&gt; Third Edition. CRC Press, 2008.&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2017-12-11-31901449</guid>
<pubDate>Mon, 11 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>用 C 语言画光（六）：菲涅耳方程</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2017-12-07-31534769.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31534769&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2f5c7ff4302d60da320d4a5bfd734f97_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31127076&quot;&gt;上一篇&lt;/a&gt;我们实现了折射，也假设了反射和折射的比重是恒定的。但现实上，这个比重与材质和入射角相关。&lt;/p&gt;&lt;p&gt;题图是我 2006 年在九寨沟拍摄的相片。相片底部，视角较接近垂直，可以看到较清晰的水下景物，倒影较暗；而在远处，视角较与水面平行，则几乎只看见倒影，难以看到水下景物。&lt;/p&gt;&lt;p&gt;你现在也可以把一个马克杯装满水，放在屏幕前观察水面。如果眼睛接近水平面，就可以清楚地看到屏幕倒影；如果视点往上移，那么屏幕倒影变暗，更多看到杯里的颜色。&lt;/p&gt;&lt;p&gt;这个现象称为菲涅耳反射（Fresnel reflectance）。奥古斯丁·菲涅耳（Augustin Fresnel， 1788－1827）为法国物理学家，注意 Fresnel 为法语姓氏，s 是不发音的。&lt;/p&gt;&lt;h2&gt;1. 菲涅耳方程&lt;/h2&gt;&lt;p&gt;菲涅耳方程（Fresnel equation）描述了光线经过两个介质的界面时，反射和透射的光强比重。参考下图的符号：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5b458ba05cceb8eb94c257fb93f77de1_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;710&quot; data-rawheight=&quot;709&quot;&gt;&lt;p&gt;当中 &lt;equation&gt;R \in [0, 1]&lt;/equation&gt; 为反射比，因能量守恒，透射比为 &lt;equation&gt;T=1-R&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;对于电介质（dielectric）而言，菲涅耳方程为：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} R_s &amp;amp;= \left(\frac{\eta_1\cos\theta_i-\eta_2\cos\theta_t}{\eta_1\cos\theta_i+\eta_2\cos\theta_t}\right)^2\\ R_p &amp;amp;=\left(\frac{\eta_1\cos\theta_t-\eta_2\cos\theta_i}{\eta_1\cos\theta_t+\eta_2\cos\theta_i}\right)^2 \end{align}\tag{1}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;R_s&lt;/equation&gt; 和 &lt;equation&gt;R_p&lt;/equation&gt; 分别对应入射光的 s 偏振（senkrecht polarized）和 p 偏振（parallel polarized）所造成的反射比。图形学中通常考虑光是无偏振的（unpolarized），也就是两种偏振是等量的，所以可以取其平均值：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;R = \frac{R_s + R_p}{2}\tag{2}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;那么，给定入射角、透射角的余弦，以及两个介质的折射率，就可简单实现：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;float fresnel(float cosi, float cost, float etai, float etat) {
    float rs = (etat * cosi - etai * cost) / (etat * cosi + etai * cost);
    float rp = (etai * cosi - etat * cost) / (etai * cosi + etat * cost);
    return (rs * rs + rp * rp) * 0.5f;
}&lt;/code&gt;&lt;p&gt;透射角实际上是使用斯涅尔定律从入射角得出的，所以假设折射率是常数，菲涅耳反射比是入射角的函数。下图展示了光线从空气射向不同材质时的菲涅耳反射比（来自[1] P. 233，&lt;equation&gt;R_F&lt;/equation&gt;为菲涅耳反射比）：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-03de0b4495739ab29a32215d82590591_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1238&quot; data-rawheight=&quot;1186&quot;&gt;&lt;p&gt;在趋向 &lt;equation&gt;90^\circ&lt;/equation&gt; 入射角时，不论什么材质反射比都趋向 1。&lt;/p&gt;&lt;p&gt;另外，导体（conductor）和半导体（semiconductor）的菲涅耳方程会更复杂一些，而且不同对波长的影响较大（上图中红色和紫色曲线分别对应 RGB 三种波长），我们稍后再讨论。&lt;/p&gt;&lt;h2&gt;2. 修改实现&lt;/h2&gt;&lt;p&gt;这个函数用于取代原来恒定的 &lt;equation&gt;\texttt{reflectivity}&lt;/equation&gt; ，我们原来的追踪代码是这样的：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;if (depth &amp;lt; MAX_DEPTH &amp;amp;&amp;amp; (r.reflectivity &amp;gt; 0.0f || r.eta &amp;gt; 0.0f)) {
    /* ... */
    if (r.eta &amp;gt; 0.0f) {
        if (refract(dx, dy, nx, ny, sign &amp;lt; 0.0f ? r.eta : 1.0f / r.eta, &amp;amp;rx, &amp;amp;ry))
            sum += (1.0f - refl) * trace(x - nx * BIAS, y - ny * BIAS, rx, ry, depth + 1);
        else
            refl = 1.0f; // Total internal reflection
    }
    /* ... */
}&lt;/code&gt;&lt;p&gt;当有折射发生时，我们利用点积计算入射角和透射角的余弦，然后用 &lt;equation&gt;\texttt{fresnel()}&lt;/equation&gt; 获取反射比。和调用 &lt;equation&gt;\texttt{refract()}&lt;/equation&gt; 时相似，我们要考虑光是从空气（&lt;equation&gt;\eta=1&lt;/equation&gt;）进入物体，还是相反：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;if (depth &amp;lt; MAX_DEPTH &amp;amp;&amp;amp; (r.reflectivity &amp;gt; 0.0f || r.eta &amp;gt; 0.0f)) {
    /* ... */
    if (r.eta &amp;gt; 0.0f) {
        if (refract(dx, dy, nx, ny, sign &amp;lt; 0.0f ? r.eta : 1.0f / r.eta, &amp;amp;rx, &amp;amp;ry)) {
            float cosi = -(dx * nx + dy * ny);
            float cost = -(rx * nx + ry * ny);
            refl = sign &amp;lt; 0.0f ? fresnel(cosi, cost, r.eta, 1.0f) : fresnel(cosi, cost, 1.0f, r.eta);
            sum += (1.0f - refl) * trace(x - nx * BIAS, y - ny * BIAS, rx, ry, depth + 1);
        }
        else
            refl = 1.0f; // Total internal reflection
    }
    /* ... */
}&lt;/code&gt;&lt;p&gt;我们比较一下，上一篇使用恒定反射比和本篇使用菲涅耳方程的渲染结果：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bf10bea58952361cfbe6ad8d294eccab_r.jpg&quot; data-caption=&quot;恒定 20% 的反射比&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1032&quot; data-rawheight=&quot;256&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3d5a34424bf8d4724ff976244fcbbdfe_r.jpg&quot; data-caption=&quot;使用菲涅耳方程&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1032&quot; data-rawheight=&quot;256&quot;&gt;&lt;p&gt;比较明显的区别是，光线垂直射向凸透镜和凹透镜时，使用恒定反比射会产生很亮的反射光斑，而使用菲涅耳方程的反射光斑就会暗得多，大部分光能穿过了透镜。&lt;/p&gt;&lt;h2&gt;3. Schlick 近似&lt;/h2&gt;&lt;p&gt;鉴于导体的菲涅耳方程较复杂，Schlick [2] 提供了一个近似的函数：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;R(\theta_i) \approx R(0)+(1-R(0))(1-\cos\theta_i)^5\tag{3}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;此函数只需要对材质提供光线垂直反射时的 &lt;equation&gt;R(0)&lt;/equation&gt; 值，就能近似地计算出不同入射角旳菲涅耳反射比。下图展示此近似函数（虚线）与菲涅耳方程（实线）的比较（自 [1] P. 234）：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e6fdb3b1ebbf053dcfc55466fec10ec4_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1234&quot; data-rawheight=&quot;1144&quot;&gt;&lt;p&gt;对于电介质，我们可以使用 (2) 计算出 &lt;equation&gt;R(0)&lt;/equation&gt; ：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;R(0)=\left(\frac{\eta_i-\eta_t}{\eta_i+\eta_t}\right)^2\tag{4}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;对于导体，我们就需要提供 &lt;equation&gt;R(0)&lt;/equation&gt; 的值（可能需要多个频率，如 RGB）。另一点要注意的事，从低折射率材质到高折射率材质时，要使用 &lt;equation&gt;\theta_t&lt;/equation&gt; ：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;float schlick(float cosi, float cost, float etai, float etat) {
    float r0 = (etai - etat) / (etai + etat);
    r0 *= r0;
    float a = 1.0f - (etai &amp;lt; etat ? cosi : cost);
    float aa = a * a;
    return r0 + (1.0f - r0) * aa * aa * a;
}&lt;/code&gt;&lt;p&gt;这个函数采用和 &lt;equation&gt;\texttt{fresnel()}&lt;/equation&gt; 相同的接口，可以在例子中替换。但如果要支持导体，则要改变接口。&lt;/p&gt;&lt;p&gt;这个例子中用 Schlick 近似并没有肉眼能分辨的差异，就不显示渲染结果了。&lt;/p&gt;&lt;h2&gt;4. 结语&lt;/h2&gt;&lt;p&gt;我们依据菲涅耳方程，以入射角及材质特性推断出光线的反射比和透射比，这样更接近真实世界的情况。&lt;/p&gt;&lt;p&gt;Schlick 近似被广泛应用在实时的基于物理渲染（physically based rendering, PBR）中，除了运算简单快捷，以 &lt;equation&gt;R(0)&lt;/equation&gt; 作为参数更容易让美术理解──白光直射材质所反射的颜色。用物理量（如本文未提及的波阻抗和磁导率）作为参数的话就很不友好。&lt;/p&gt;&lt;p&gt;本文的代码位于 &lt;a href=&quot;https://github.com/miloyip/light2d/blob/master/fresnel.c&quot;&gt;fresnel.c&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;p&gt;[1] Akenine-Möller, Tomas, Eric Haines, and Naty Hoffman. &lt;i&gt;Real-time rendering,&lt;/i&gt; Third Edition. CRC Press, 2008.&lt;/p&gt;&lt;p&gt;[2] Schlick, Christophe. &quot;&lt;a href=&quot;http://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf&quot;&gt;An Inexpensive BRDF Model for Physically‐based Rendering&lt;/a&gt;.&quot; &lt;i&gt;Computer graphics forum&lt;/i&gt;. Vol. 13. No. 3. Blackwell Science Ltd, 1994.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;更新1：谢 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/164344a9ffe3949bfd9e387663119ecd&quot; data-hash=&quot;164344a9ffe3949bfd9e387663119ecd&quot; data-hovercard=&quot;p$b$164344a9ffe3949bfd9e387663119ecd&quot;&gt;@codeworm96&lt;/a&gt; 指出，公式 (4) 右侧需平方，已修正。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2017-12-07-31534769</guid>
<pubDate>Thu, 07 Dec 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>知乎「插入公式」诀窍</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2017-11-19-31188118.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31188118&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c768140fa061363905eda738504c20e5_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;知乎在问题、回答和专栏文章中都可使用「插入公式」功能，本文收集一些使用心得，也欢迎大家在评语中分享你的心得。&lt;/p&gt;&lt;p&gt;（Photo by &lt;a href=&quot;https://unsplash.com/photos/5mZ_M06Fc9g?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Roman Mager&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;）&lt;/p&gt;&lt;h2&gt;1. 公式置中&lt;/h2&gt;&lt;p&gt;平常输入公式是内联的，例如：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;a^2 = b^2 + c^2&lt;/code&gt;&lt;p&gt;&lt;equation&gt;a^2 = b^2 + c^2&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;只要在行末加入 &lt;equation&gt;\texttt{\\\\}&lt;/equation&gt; 就可置中：&lt;/p&gt;&lt;code lang=&quot;tex&quot;&gt;a^2 = b^2 + c^2\\&lt;/code&gt;&lt;p&gt;&lt;equation&gt;a^2 = b^2 + c^2\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;虽然不是很准确地置中（似乎是知乎设置的宽度问题），但已经好看多了。&lt;/p&gt;&lt;p&gt;Update: 缺点是手机上看字体会变小&lt;/p&gt;&lt;p&gt;Credits: &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/9558cac1a967147f0318fe6b7b1a0f7b&quot; data-hash=&quot;9558cac1a967147f0318fe6b7b1a0f7b&quot; data-hovercard=&quot;p$b$9558cac1a967147f0318fe6b7b1a0f7b&quot;&gt;@白如冰&lt;/a&gt; &lt;/p&gt;&lt;h2&gt;2. 手工公式编号&lt;/h2&gt;&lt;p&gt;由于每个公式在文中是独立的， &lt;equation&gt;\texttt{equation}&lt;/equation&gt; 环境也不会加入编号，但我们可以用 &lt;equation&gt;\texttt{\tag{n}}&lt;/equation&gt; 手工加入编号：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;a^2 = b^2 + c^2 \tag{1}&lt;/code&gt;&lt;p&gt;&lt;equation&gt;a^2 = b^2 + c^2 \tag{1}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这样不用加上 &lt;equation&gt;\texttt{\\\\}&lt;/equation&gt; 也会置中。&lt;/p&gt;&lt;h2&gt;3. 常用数学环境&lt;/h2&gt;&lt;p&gt;这里列出一些可用的数学环境。&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{align}&lt;/equation&gt; 对齐等号（或其他符号）：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;\begin{align}
a + b &amp;amp;= c + d\\
a &amp;amp;= c + d -b
\end{align}\\&lt;/code&gt;&lt;p&gt;&lt;equation&gt;\begin{align} a + b &amp;amp;= c + d\\ a &amp;amp;= c + d -b \end{align}\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{alignat}&lt;/equation&gt; 可在每行对齐多个公式，其第一参数设置每行公式数目：&lt;/p&gt;&lt;code lang=&quot;tex&quot;&gt;\begin{alignat}{2}
 \sigma_1 &amp;amp;= x + y  &amp;amp;\quad \sigma_2 &amp;amp;= \frac{x}{y}\\
 \sigma_1&#39; &amp;amp;= \frac{\partial x + y}{\partial x} &amp;amp; \sigma_2&#39; 
    &amp;amp;= \frac{\partial \frac{x}{y}}{\partial x}\\
\end{alignat}\\&lt;/code&gt;&lt;p&gt;&lt;equation&gt;\begin{alignat}{2} \sigma_1 &amp;amp;= x + y &amp;amp;\quad \sigma_2 &amp;amp;= \frac{x}{y}\\ \sigma_1&#39; &amp;amp;= \frac{\partial x + y}{\partial x} &amp;amp; \sigma_2&#39; &amp;amp;= \frac{\partial \frac{x}{y}}{\partial x}\\ \end{alignat}\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;equation&gt;\texttt{cases}&lt;/equation&gt; 条件：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;u(x) = 
\begin{cases} 
   \exp{x} &amp;amp; \text{if } x \geq 0 \\
   1       &amp;amp; \text{if } x &amp;lt; 0
\end{cases}\\&lt;/code&gt;&lt;p&gt;&lt;equation&gt; u(x) = \begin{cases} \exp{x} &amp;amp; \text{if } x \geq 0 \\ 1 &amp;amp; \text{if } x &amp;lt; 0 \end{cases}\\&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;4. 内联等宽字体&lt;/h2&gt;&lt;p&gt;知乎可输入代码，但想在文中表示程序的关键字，可用 &lt;equation&gt;\texttt{\\texttt{...}}&lt;/equation&gt; 显示等宽字体：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;\texttt{main()}&lt;/code&gt;&lt;p&gt;C 语言的入口函数为 &lt;equation&gt;\texttt{main()}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;5. 表格&lt;/h2&gt;&lt;p&gt;知乎没有表格编辑工具，但可以使用 &lt;equation&gt;\texttt{array}&lt;/equation&gt; 环境：&lt;/p&gt;&lt;code lang=&quot;tex&quot;&gt;\begin{array}{c|c}
\text{年份} &amp;amp; \text{沙漠面积}(\text{km}^2) \\
\hline
2000 &amp;amp; 90.0\\
2010 &amp;amp; 100.0\\
\end{array}\\&lt;/code&gt;&lt;p&gt;&lt;equation&gt;\begin{array}{c|c} \text{年份} &amp;amp; \text{沙漠面积}(\text{km}^2) \\ \hline 2000 &amp;amp; 90.0\\ 2010 &amp;amp; 100.0\\ \end{array}\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;第一个参数是用于设置列的对齐， &lt;equation&gt;\texttt{l}&lt;/equation&gt; 表示向左对齐、 &lt;equation&gt;\texttt{c}&lt;/equation&gt; 表示置中对齐、 &lt;equation&gt;\texttt{r}&lt;/equation&gt; 表示向右对齐，中间可加入 &lt;equation&gt;\texttt{|}&lt;/equation&gt; 来插入垂直线。行与行之间可用 &lt;equation&gt;\texttt{\\hline}&lt;/equation&gt; 加入横线。&lt;/p&gt;&lt;h2&gt;6. 色彩&lt;/h2&gt;&lt;p&gt;可使用 &lt;a href=&quot;http://docs.mathjax.org/en/latest/tex.html#color&quot;&gt;MathJax 扩展的&lt;/a&gt; &lt;equation&gt;\texttt{\\color{颜色}{公式}}&lt;/equation&gt; 为公式添加色彩：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;\color{black}{\text{黑色}}\,
\color{gray}{\text{灰色}}\,
\color{darkgray}{\text{深灰}}\,
\color{lightgray}{\text{浅灰}}\,
\color{white}{\text{白色}}\\
\color{pink}{\text{粉红}}\,
\color{red}{\text{红色}}\,
\color{magenta}{\text{品红}}\,
\color{violet}{\text{紫色}}\,
\color{purple}{\text{深紫}}\,
\color{blue}{\text{蓝色}}\,
\color{teal}{\text{深青}}\,
\color{green}{\text{绿色}}\,
\color{cyan}{\text{青色}}\,
\color{lime}{\text{青柠}}\,
\color{olive}{\text{橄榄}}\,
\color{yellow}{\text{黄色}}\,
\color{orange}{\text{橙色}}\,
\color{brown}{\text{棕色}}\\
\color{#FF0000}{\texttt{#FF0000}}&lt;/code&gt;&lt;p&gt;&lt;equation&gt;\color{black}{\text{黑色}}\, \color{gray}{\text{灰色}}\, \color{darkgray}{\text{深灰}}\, \color{lightgray}{\text{浅灰}}\, \color{white}{\text{白色}}\\ \color{pink}{\text{粉红}}\, \color{red}{\text{红色}}\, \color{magenta}{\text{品红}}\, \color{violet}{\text{紫色}}\, \color{purple}{\text{深紫}}\, \color{blue}{\text{蓝色}}\, \color{teal}{\text{深青}}\, \color{green}{\text{绿色}}\, \color{cyan}{\text{青色}}\, \color{lime}{\text{青柠}}\, \color{olive}{\text{橄榄}}\, \color{yellow}{\text{黄色}}\, \color{orange}{\text{橙色}}\, \color{brown}{\text{棕色}}\\ \color{#FF0000}{\texttt{#FF0000}}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;Update 2017/11/20: &lt;/p&gt;&lt;p&gt;背景需要用到 &lt;a href=&quot;http://docs.mathjax.org/en/latest/tex.html#bbox&quot;&gt;MathJax 的扩展&lt;/a&gt; &lt;equation&gt;\texttt{\\bbox[选项]\{公式\}}&lt;/equation&gt; ：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;\bbox[pink,2pt]{a^2} = \bbox[cyan,2pt]{b^2} + \bbox[yellow,2pt]{c^2}&lt;/code&gt;&lt;p&gt;&lt;equation&gt;\bbox[pink,2pt]{a^2} = \bbox[cyan,2pt]{b^2} + \bbox[yellow,2pt]{c^2}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2017-11-19-31188118</guid>
<pubDate>Sun, 19 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>用 C 语言画光（五）：折射</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2017-11-18-31127076.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31127076&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e54f30d3a5bd8ac6f6127ce83fa50e31_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;与&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30961545&quot;&gt;上篇反射&lt;/a&gt;（reflection）成对出现的光学现象就是折射（refraction）。当光从一个介质（medium）进入另一个介质，便会出现这两种现象。&lt;/p&gt;&lt;p&gt;基于能量守恒，当没有能量散失时，反射光的能量与折射光的能量之和等于入射光的能量。在本篇中我们先假设反射和折射的比率是恒定的，例如一个形状的表面总是会反射 20% 的入射光，并折射 80% 的入射光。&lt;/p&gt;&lt;p&gt;但我们知道，折射的方向会改变（所以才称为「折」射），那么怎样计算折射方向呢？&lt;/p&gt;&lt;h2&gt;1. 斯涅尔定律&lt;/h2&gt;&lt;p&gt;读者可能在中学阶段已学会斯涅尔定律（Snell&#39;s law），它描述了入射角、折射角与介质折射率（refractive index）的关系：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-95c45d555e019f30ab9a4f4529d087bb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;710&quot; data-rawheight=&quot;709&quot;&gt;&lt;p&gt;&lt;equation&gt;\begin{align} \eta_1 \sin \theta_1 &amp;amp;= \eta_2 \sin \theta_2\\ \Leftrightarrow \frac{\sin \theta_2}{\sin \theta_1} &amp;amp;= \frac{\eta_1}{\eta_2} \end{align}\\ &lt;/equation&gt; &lt;/p&gt;&lt;p&gt;当 &lt;equation&gt;\eta_1 &amp;gt; \eta_2&lt;/equation&gt; 时，例如光线从玻璃（ &lt;equation&gt;\eta_1\approx1.5&lt;/equation&gt; ）进入空气（ &lt;equation&gt;\eta_2\approx 1&lt;/equation&gt; ），会有机会出现内全反射（total internal reflection），从斯涅尔定律分析：&lt;/p&gt;&lt;p&gt;&lt;equation&gt; \sin \theta_2 = \frac{\eta_1}{ \eta_2} \sin \theta_1\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;如果 &lt;equation&gt;\eta_1 &amp;gt; \eta_2 \Leftrightarrow \frac{\eta_1}{\eta_2} &amp;gt; 1&lt;/equation&gt; ，某些入射角 &lt;equation&gt;\theta_1&lt;/equation&gt; 范围会令右侧大于 1，左侧便会超出正弦的值域 &lt;equation&gt;[-1, 1]&lt;/equation&gt; 。在这种情况下，不会发生折射，所有入射光会完全反射。我们把上式左侧设为 1，则可求出临界角（critical angle）：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;1 = \frac{\eta_1}{ \eta_2} \sin \theta_c\\ \Leftrightarrow \theta_c = \sin^{-1}\frac{\eta_2}{ \eta_1}\\&lt;/equation&gt; &lt;/p&gt;&lt;h2&gt;2. 折射矢量&lt;/h2&gt;&lt;p&gt;我们以矢量表示光线方向，需要求出折射方向。这会比上一篇反射复杂一点点。先看图：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0965d651f38f1739b3ff43a0da85d034_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;710&quot; data-rawheight=&quot;709&quot;&gt;&lt;p&gt;与反射不一样，折射最好使用单位矢量表示入射方向 &lt;equation&gt;\hat{\mathbf{i}}&lt;/equation&gt; 和折射方向 &lt;equation&gt;\hat{\mathbf{t}}&lt;/equation&gt; 。这里还定义了界面的切线方向 &lt;equation&gt;\hat{\mathbf{m}}&lt;/equation&gt; 。从上图可以看到，折射矢量可从法线方向与切线方向的矢量之和得出：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\hat{\mathbf{t}} = \sin \theta_2 \hat{\mathbf{m}} -\cos \theta_2 \hat{\mathbf{n}}\tag{1}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;接下来，我们要把上式各部分以 &lt;equation&gt;\hat{\mathbf{i}}, \hat{\mathbf{n}},\eta_1,\eta_2&lt;/equation&gt; 表示。切线 &lt;equation&gt;\hat{\mathbf{m}}&lt;/equation&gt; 可以从入射方向 &lt;equation&gt;\hat{\mathbf{i}}&lt;/equation&gt; 分解得出：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} \hat{\mathbf{i}} &amp;amp;= (\hat{\mathbf{i}}\cdot\hat{\mathbf{n}})\hat{\mathbf{n}}\ + \sin \theta_1 \hat{\mathbf{m}}\\ \Leftrightarrow \hat{\mathbf{m}} &amp;amp;= \frac{\hat{\mathbf{i}} - (\hat{\mathbf{i}}\cdot\hat{\mathbf{n}})\hat{\mathbf{n}}}{\sin \theta_1 }\tag{2} \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;然后 &lt;equation&gt;\sin\theta_2&lt;/equation&gt; 可通过斯涅尔定律以 &lt;equation&gt;\sin\theta_1, \eta_1, \eta_2&lt;/equation&gt; 表示，而 &lt;equation&gt;\sin\theta_1&lt;/equation&gt; 又可以转换成点积：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} \sin \theta_2 &amp;amp;= \frac{\eta_1}{\eta_2} \sin \theta_1 = \frac{\eta_1}{\eta_2} \sqrt{1 - \cos^2\theta_1} = \frac{\eta_1}{\eta_2} \sqrt{1 - (\hat{\mathbf{i}}\cdot\hat{\mathbf{n}})^2}\\ \end{align}\tag{3}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;有正弦也就可以求余弦：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} \cos\theta_2 &amp;amp;= \sqrt{1 - \sin^2\theta_2} = \sqrt{1 - \left(\frac{\eta_1}{\eta_2}\right)^2 \left(1 - (\hat{\mathbf{i}}\cdot\hat{\mathbf{n}})^2\right)}\\ \end{align}\tag{4}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;把(2)、(3)、(4) 代入 (1)，简化：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} \hat{\mathbf{t}} &amp;amp;= \sin \theta_2 \hat{\mathbf{m}} -\cos \theta_2 \hat{\mathbf{n}}\\ &amp;amp;= \frac{\sin\theta_2}{\sin\theta_1} \left( \hat{\mathbf{i}} - (\hat{\mathbf{i}}\cdot\hat{\mathbf{n}})\hat{\mathbf{n}}\right) - \sqrt{1 - \left(\frac{\eta_1}{\eta_2}\right)^2 \left(1 - (\hat{\mathbf{i}}\cdot\hat{\mathbf{n}})^2\right)} \hat{\mathbf{n}}\\ &amp;amp;= \frac{\eta_1}{\eta_2} \left( \hat{\mathbf{i}} - (\hat{\mathbf{i}}\cdot\hat{\mathbf{n}})\hat{\mathbf{n}}\right) - \sqrt{1 - \left(\frac{\eta_1}{\eta_2}\right)^2 \left(1 - (\hat{\mathbf{i}}\cdot\hat{\mathbf{n}})^2\right)} \hat{\mathbf{n}}\\ &amp;amp;= \frac{\eta_1}{\eta_2} \hat{\mathbf{i}} - \left(\frac{\eta_1}{\eta_2}(\hat{\mathbf{i}}\cdot\hat{\mathbf{n}}) + \sqrt{1 - \left(\frac{\eta_1}{\eta_2}\right)^2 \left(1 - (\hat{\mathbf{i}}\cdot\hat{\mathbf{n}})^2\right)} \right)\hat{\mathbf{n}}\\ \end{align}\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;噢，计算折射矢量竟然一个三角函数都不需要！由于上式只需折射率之比值，我们的函数使用 &lt;equation&gt;\eta =\eta_1 / \eta_2&lt;/equation&gt; 作为参数，实现如下：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;int refract(float ix, float iy, float nx, float ny, float eta, float* rx, float* ry) {
    float idotn = ix * nx + iy * ny;
    float k = 1.0f - eta * eta * (1.0f - idotn * idotn);
    if (k &amp;lt; 0.0f)
        return 0; // 全内反射
    float a = eta * idotn + sqrtf(k);
    *rx = eta * ix - a * nx;
    *ry = eta * iy - a * ny;
    return 1;
}&lt;/code&gt;&lt;p&gt;当根号内的值为负数，也是代表全内反射，我们使用返回值代表是否有折射出现。&lt;/p&gt;&lt;h2&gt;3. 递归追踪反射和折射&lt;/h2&gt;&lt;p&gt;前篇在处理反射时，我们假设光线总是来自形状外部。然而，这里反射和折射都可以发生在形状的内部。因此，我们首先需要用 SDF 判断光线的发射坐标 &lt;equation&gt;\mathbf{o}&lt;/equation&gt; 位于形状之内（ &lt;equation&gt;\phi(\mathbf{o})&amp;lt;0&lt;/equation&gt; ）还是之外（ &lt;equation&gt;\phi(\mathbf{o})&amp;gt;0&lt;/equation&gt; ）。由于 SDF 会为正或负，在检测光线步进是否到形状表面时，我们要用绝对值来比较 &lt;equation&gt;|\phi(\mathbf{o}+t\mathbf{d}) |&amp;lt;\epsilon&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;我们为 &lt;equation&gt;\texttt{Result}&lt;/equation&gt; 结构加入形状的折射率：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;typedef struct { float sd, emissive, reflectivity, eta; } Result;&lt;/code&gt;&lt;p&gt;如果光线从外至内，调用 &lt;equation&gt;\texttt{refract()}&lt;/equation&gt; 时，传入 &lt;equation&gt;1 / \eta&lt;/equation&gt; ；从内至外则传入 &lt;equation&gt;\eta&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;另外要注意的是，法线的方向需要是入射光的那一方，换句话说，当光线从形状内往外发射时，要反转法线方向。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;float trace(float ox, float oy, float dx, float dy, int depth) {
    float t = 1e-3f;
    float sign = scene(ox, oy).sd &amp;gt; 0.0f ? 1.0f : -1.0f; // 内还是外？
    for (int i = 0; i &amp;lt; MAX_STEP &amp;amp;&amp;amp; t &amp;lt; MAX_DISTANCE; i++) {
        float x = ox + dx * t, y = oy + dy * t;
        Result r = scene(x, y);
        if (r.sd * sign &amp;lt; EPSILON) { // 判断是否到达表面时要考虑内外
            float sum = r.emissive;
            if (depth &amp;lt; MAX_DEPTH &amp;amp;&amp;amp; (r.reflectivity &amp;gt; 0.0f || r.eta &amp;gt; 0.0f)) {
                float nx, ny, rx, ry, refl = r.reflectivity;
                gradient(x, y, &amp;amp;nx, &amp;amp;ny);
                nx *= sign; ny *= sign; // 在内的话，要反转法线
                if (r.eta &amp;gt; 0.0f) {
                    if (refract(dx, dy, nx, ny, sign &amp;lt; 0.0f ? r.eta : 1.0f / r.eta, &amp;amp;rx, &amp;amp;ry))
                        sum += (1.0f - refl) * trace(x - nx * BIAS, y - ny * BIAS, rx, ry, depth + 1);
                    else
                        refl = 1.0f; // 全内反射
                }
                if (refl &amp;gt; 0.0f) {
                    reflect(dx, dy, nx, ny, &amp;amp;rx, &amp;amp;ry);
                    sum += refl * trace(x + nx * BIAS, y + ny * BIAS, rx, ry, depth + 1);
                }
            }
            return sum;
        }
        t += r.sd * sign;
    }
    return 0.0f;
}&lt;/code&gt;&lt;p&gt;一些测试场景（矩形、凸透镜、凹透镜、半圆透镜）：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9250dc9c28383dfc9d2791bfeb36d12b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-5b9a74e2d88a3dc1e951165c8f2f9ebb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-06302a25f55b437a9494670afd1ec55a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-53e07c8c5f07381b2c06bd661c3c56aa_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;h2&gt;4. 结语&lt;/h2&gt;&lt;p&gt;这篇仅加入了斯涅尔定律的应用，额外 20 行代码，就能渲染出类似玻璃材质的效果。我们在开始时假设了折射和反射的比率是恒定的（除了内全反射），这并不太接近真实的情况。我们在下篇会作改善。&lt;/p&gt;&lt;p&gt;本文的代码位于 &lt;a href=&quot;https://github.com/miloyip/light2d/blob/master/refraction.c&quot;&gt;refraction.c&lt;/a&gt; 及 &lt;a href=&quot;https://github.com/miloyip/light2d/blob/master/m2.c&quot;&gt;m2.c&lt;/a&gt;。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2017-11-18-31127076</guid>
<pubDate>Sat, 18 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>用 C 语言画光（四）：反射</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2017-11-12-30961545.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30961545&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-befa3a3e59433668fea5fac38657dbb6_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30816284&quot;&gt;上一篇&lt;/a&gt;我们讨论了一些形状，本篇回到基于光学的模拟，先谈较简单的──光的反射（reflection）。我们假设形状的边界是平滑的，会产生镜面反射（specular reflection）。实现反射需要一点几何上的推导，以及考虑如何用 SDF 获得边界法线，最后把追踪过程改为递归方式进行。&lt;/p&gt;&lt;h2&gt;1. 反射矢量&lt;/h2&gt;&lt;p&gt;给定一个入射方向 &lt;equation&gt;\mathbf i&lt;/equation&gt; 及边界法线 &lt;equation&gt;\hat {\mathbf n}&lt;/equation&gt; ，我们可以根据下图计算出反射方向 &lt;equation&gt;\mathbf r&lt;/equation&gt; ：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0393e6a407498f39069c1b6c4550b05b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;766&quot; data-rawheight=&quot;358&quot;&gt;&lt;p&gt;首先，把 &lt;equation&gt;\mathbf i&lt;/equation&gt; 用点积投影至法线方向，得到法线方向的长度（注意法线需为单位矢量），然后再把这长度往法线方向缩放，得到图中蓝色虚线矢量 &lt;equation&gt;(\mathbf{i} \cdot \hat{\mathbf{n}})\hat{\mathbf{n}}&lt;/equation&gt; 。之后，把  &lt;equation&gt;\mathbf i&lt;/equation&gt;  减去两个蓝色虚线矢量就能得到反射矢量 &lt;equation&gt;\mathbf{r}&lt;/equation&gt; ：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\mathbf r = \mathbf{i} - 2(\mathbf{i} \cdot \hat{\mathbf{n}})\hat{\mathbf{n}}\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;用 C 语言实现：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void reflect(float ix, float iy, float nx, float ny, float* rx, float* ry) {
    float idotn2 = (ix * nx + iy * ny) * 2.0f;
    *rx = ix - idotn2 * nx;
    *ry = iy - idotn2 * ny;
}&lt;/code&gt;&lt;p&gt;但问题是，我们怎样从场景中取得边界法线？&lt;/p&gt;&lt;h2&gt;2. 梯度与法线&lt;/h2&gt;&lt;p&gt;在此系列文章中，我们采用了 SDF 来构建场景。在形状的边界，&lt;b&gt;距离场变化最大的方向便是法线方向&lt;/b&gt;。根据矢量微积分（vector calculus），一个纯量场（scalar field）的最大变化方向就是其梯度（gradient），所以我们需要求形状边界位置的 SDF 梯度：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\nabla \phi = \left ( \frac{\partial \phi}{\partial x}, \frac{\partial \phi}{\partial y} \right )\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这梯度其实就是 SDF 分别在 &lt;equation&gt;x&lt;/equation&gt; 和 &lt;equation&gt;y&lt;/equation&gt; 方向的变化率。SDF 几乎处处可导，而且，SDF 为程函方程的（Eikonal equation）特例，具特性：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\| \nabla \phi\|=1\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;换句话说，SDF 的梯度是单位矢量。&lt;/p&gt;&lt;p&gt;假设我们不知道 SDF 梯度的分析解，可利用数值方法，如中心差分法（central difference），求出梯度的近似值： &lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} \nabla \phi &amp;amp;= \left( \frac{\partial \phi}{\partial x}, \frac{\partial \phi}{\partial y} \right)\\ &amp;amp;\approx \left( \frac{\phi(x + h, y) - \phi(x - h, y)}{2h}, \frac{\phi(x, y + h) - \phi(x, y - h)}{2h} \right) \end{align}\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;用 C 语言实现：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;void gradient(float x, float y, float* nx, float* ny) {
    *nx = (scene(x + EPSILON, y).sd - scene(x - EPSILON, y).sd) * (0.5f / EPSILON);
    *ny = (scene(x, y + EPSILON).sd - scene(x, y - EPSILON).sd) * (0.5f / EPSILON);
}&lt;/code&gt;&lt;p&gt;我们用一个测试场景去看看它的梯度，当中有一个圆形、两个矩形：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Result scene(float x, float y) {
    Result a = {  circleSDF(x, y, 0.4f,  0.2f, 0.1f), 2.0f };
    Result b = {     boxSDF(x, y, 0.5f,  0.8f, TWO_PI / 16.0f, 0.1f, 0.1f), 0.0f };
    Result c = {     boxSDF(x, y, 0.8f,  0.5f, TWO_PI / 16.0f, 0.1f, 0.1f), 0.0f };
    return unionOp(unionOp(a, b), c);
}&lt;/code&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-780f61919eab02cb4e37c3150569af19_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;p&gt;我们改一下 &lt;equation&gt;\texttt{main()}&lt;/equation&gt; 函数，用颜色把梯度可视化，红色通道显示 &lt;equation&gt;\frac{\partial \phi}{\partial x}&lt;/equation&gt; ，绿色通道显示 &lt;equation&gt;\frac{\partial \phi}{\partial y}&lt;/equation&gt; ：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;for (int y = 0; y &amp;lt; H; y++)
    for (int x = 0; x &amp;lt; W; x++, p += 3) {
         float nx, ny;
         gradient((float)x / W, (float)y / H, &amp;amp;nx, &amp;amp;ny);
         p[0] = (int)((fmaxf(fminf(nx, 1.0f), -1.0f) * 0.5f + 0.5f) * 255.0f);
         p[1] = (int)((fmaxf(fminf(ny, 1.0f), -1.0f) * 0.5f + 0.5f) * 255.0f);
         p[2] = 0;
     }&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ea5337faa6bfa20fecafe99d8aab0f23_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;p&gt;上图中可以看到，大部分位置的梯度是连续的，至少我们现在需要在形状边界上的位置是连续的。&lt;/p&gt;&lt;p&gt;（注：由于有数值误差，计算出来的梯度分量可能略超出 &lt;equation&gt;[-1, 1]&lt;/equation&gt; 的范围，所以在输出时限制其范围。但这个轻微的误差不影响我们计算反射。）&lt;/p&gt;&lt;h2&gt;3. 递归追踪&lt;/h2&gt;&lt;p&gt;我们考虑形状边界的反射率（reflectivity）为 &lt;equation&gt;[0, 1]&lt;/equation&gt; 范围，为此增加一个字段：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;typedef struct { float sd, emissive, reflectivity; } Result;

Result scene(float x, float y) {
    Result a = {  circleSDF(x, y, 0.4f,  0.2f, 0.1f), 2.0f, 0.0f };
    Result b = {     boxSDF(x, y, 0.5f,  0.8f, TWO_PI / 16.0f, 0.1f, 0.1f), 0.0f, 0.9f };
    Result c = {     boxSDF(x, y, 0.8f,  0.5f, TWO_PI / 16.0f, 0.1f, 0.1f), 0.0f, 0.9f };
    return unionOp(unionOp(a, b), c);
}&lt;/code&gt;&lt;p&gt;如果反射率超过 1，总能量就变多，不符合能量守恒。少于 1 代表形状吸收了能量。&lt;/p&gt;&lt;p&gt;之后，修改 &lt;equation&gt;\texttt{trace()}&lt;/equation&gt; ，当我们在向一个方向追踪光线时，若碰到会反射的形状时，就计算该边界相交点的法线，然后递归追踪反射方向，把收到的所有光加总。为免无限反射做成无限递归，需要限制反射次数：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define BIAS 1e-4f
#define MAX_DEPTH 3

float trace(float ox, float oy, float dx, float dy, int depth) {
    float t = 0.0f;
    for (int i = 0; i &amp;lt; MAX_STEP &amp;amp;&amp;amp; t &amp;lt; MAX_DISTANCE; i++) {
        float x = ox + dx * t, y = oy + dy * t;
        Result r = scene(x, y);
        if (r.sd &amp;lt; EPSILON) {
            float sum = r.emissive;
            if (depth &amp;lt; MAX_DEPTH &amp;amp;&amp;amp; r.reflectivity &amp;gt; 0.0f) {
                float nx, ny, rx, ry;
                gradient(x, y, &amp;amp;nx, &amp;amp;ny);
                reflect(dx, dy, nx, ny, &amp;amp;rx, &amp;amp;ry);
                sum += r.reflectivity * trace(x + nx * BIAS, y + ny * BIAS, rx, ry, depth + 1);
            }
            return sum;
        }
        t += r.sd;
    }
    return 0.0f;
}

float sample(float x, float y) {
    float sum = 0.0f;
    for (int i = 0; i &amp;lt; N; i++) {
        float a = TWO_PI * (i + (float)rand() / RAND_MAX) / N;
        sum += trace(x, y, cosf(a), sinf(a), 0); // 开始时深度为 0
    }
    return sum / N;
}&lt;/code&gt;&lt;p&gt;另外，由于我们要向反射方向追踪，如果用原来的相交点，追踪时就为立即遇到 &lt;equation&gt;\texttt{r.sd &amp;lt; EPSILON}&lt;/equation&gt; 而停止，所以我们稍微把相交点往法线方向偏移 &lt;equation&gt;\texttt{BIAS}&lt;/equation&gt; 的距离，只要 &lt;equation&gt;\texttt{BIAS} &amp;gt; \texttt{EPSILON}&lt;/equation&gt; ，就可以避免这个问题。但太大的话也会造成误差。结果：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d9fe132160c5b949f29148f6a6d2fc8f_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;p&gt;我们可以看到两个矩形之间有第二次的反射。&lt;/p&gt;&lt;p&gt;利用平面和圆形的相对补集，就能做出凹面镜（concave mirror），弧形会产生题图中的焦散（caustics）现象：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Result scene(float x, float y) {
    Result a = { circleSDF(x, y, 0.4f, 0.2f, 0.1f), 2.0f, 0.0f };
    Result d = {  planeSDF(x, y, 0.0f, 0.5f, 0.0f, -1.0f), 0.0f, 0.9f };
    Result e = { circleSDF(x, y, 0.5f, 0.5f, 0.4f), 0.0f, 0.9f };
    return unionOp(a, subtractOp(d, e));
}&lt;/code&gt;&lt;h2&gt;4. 结语&lt;/h2&gt;&lt;p&gt;也许大家在中学物理中都学过镜面反射的知识，但用简单的程序实现出来总会令人觉得更有趣。&lt;/p&gt;&lt;p&gt;本文的重点是用数值方法求 SDF 在边界上的法线，以及通过递归来实现多次反射。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31127076&quot;&gt;下一篇&lt;/a&gt;将讨论折射，那么，我们就可以画出穿过透镜的光了。&lt;/p&gt;&lt;p&gt;本文的源代码位于 &lt;a href=&quot;https://github.com/miloyip/light2d/blob/master/reflection.c&quot;&gt;reflection.c&lt;/a&gt;。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2017-11-12-30961545</guid>
<pubDate>Sun, 12 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>用 C 语言画光（三）：形状</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2017-11-11-30816284.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30816284&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-47190784c56b5f0fd0f0107c2b2b1758_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;再前两篇中，我们一直只用到圆形作为基础形状，本文再介绍一些常用形状的 SDF。但这些形状也只是作为例子，重要的是掌握如何推导出这些 SDF。&lt;/p&gt;&lt;h2&gt;1. 圆形&lt;/h2&gt;&lt;p&gt;我们先重温一下圆形的 SDF：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\phi_\text{circle}(\mathbf{x}) = \left \| \mathbf{x} - \mathbf{c} \right \|-r\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;当中 &lt;equation&gt;\left \| \mathbf{x} - \mathbf{c} \right \|&lt;/equation&gt; 就是坐标 &lt;equation&gt;\mathbf{x}&lt;/equation&gt; 与一个点 &lt;equation&gt;\mathbf{c}&lt;/equation&gt; （圆心）的欧氏距离（Euclidean distance）。把这个距离减去 &lt;equation&gt;r&lt;/equation&gt; ，实际上等同于把一点向外扩展 &lt;equation&gt;r&lt;/equation&gt; 的范围。其实，对于任何形状的 SDF，减去一个常数 &lt;equation&gt;r&lt;/equation&gt; ，都等同于把该形状它向外扩展 &lt;equation&gt;r&lt;/equation&gt; 的范围。本文稍后也会看到更多应用例子。&lt;/p&gt;&lt;p&gt;在数学上，我们还可考虑这是任何形状与（圆心位于原点的）圆盘的闵可夫斯基和（Minkowski sum）。&lt;/p&gt;&lt;h2&gt;2. 平面&lt;/h2&gt;&lt;p&gt;除了圆形，最简单的形状应该是平面（plane）。在二维中这个形状应该称作直线，或者更精确地应称作二维的半空间（half-space），就是把二维空间用直线切割成两个无限大面积的部分。我们这里暂且称这个形状为平面吧。&lt;/p&gt;&lt;p&gt;任意维度空间的（超）平面都可以用平面上的一点 &lt;equation&gt;\mathbf{p}&lt;/equation&gt; 与法线（normal vector） &lt;equation&gt;\mathbf{n}&lt;/equation&gt; 来定义，由于平面与法线垂直，平面上的任意一个矢量 &lt;equation&gt;\mathbf{x} - \mathbf{p}&lt;/equation&gt; 与法线的点积为零：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;(\mathbf{x} - \mathbf{p}) \cdot \mathbf{n} = 0\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;如果法矢量为单位矢量 &lt;equation&gt;\hat{\mathbf{n}}&lt;/equation&gt; ，空间中任意一点与平面的带符号距离为：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\phi_\text{plane}(\mathbf{x})=(\mathbf{x}-\mathbf{p})\cdot\hat{\mathbf{n}}\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;我们还可把点积展开成这种形式：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\phi_\text{plane}(\mathbf{x})=Ax + By + C\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;但为了方便使用，我们的实现用点和法线作为参数：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;float planeSDF(float x, float y, float px, float py, float nx, float ny) {
    return (x - px) * nx + (y - py) * ny;
}

Result scene(float x, float y) {
    Result b = { planeSDF(x, y, 0.0f, 0.5f, 0.0f, 1.0f), 0.8f };
    return b;
}&lt;/code&gt;&lt;p&gt;这个例子中，上半部分是发射 0.8 自发光的形状：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b5e34db83700c44cbb500ca9450d07f3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;p&gt;我们可以用 CSG，例如把圆形与上面的平面相交，得出半圆：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Result scene(float x, float y) {
    Result a = { circleSDF(x, y, 0.5f, 0.5f, 0.2f), 1.0f };
    Result b = {  planeSDF(x, y, 0.0f, 0.5f, 0.0f, 1.0f), 0.8f };
    return intersectOp(a, b);
}&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3450c0fed7e3cf3d396201e2885b5f2b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;h2&gt;3. 胶囊形&lt;/h2&gt;&lt;p&gt;在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30553006&quot;&gt;用 C 语言画直线&lt;/a&gt;》已使用到胶囊形（capsule）的 SDF，在这里简单推导一下。&lt;/p&gt;&lt;p&gt;我们把胶囊形以两点 &lt;equation&gt;\mathbf{a}, \mathbf{b}&lt;/equation&gt; 和半径 &lt;equation&gt;r&lt;/equation&gt; 来表示：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-557e74efba6c15cd1765caa3cc99beb6_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;278&quot; data-rawheight=&quot;332&quot;&gt;&lt;p&gt;有些场合可能每使用一点 &lt;equation&gt;\mathbf{a}&lt;/equation&gt; 及矢量 &lt;equation&gt;\mathbf{u} = \mathbf{b} - \mathbf{a}&lt;/equation&gt; 去表示，实际上我们在计算其 SDF 时也需要做这个减法。&lt;/p&gt;&lt;p&gt;计算胶囊形的 SDF，等价于计算一点与线段 ab 的距离，再扩大半径 &lt;equation&gt;r&lt;/equation&gt; （即把结果减去 &lt;equation&gt;r&lt;/equation&gt; ）。而计算一点与线段的距离的方法，是把点 &lt;equation&gt;\mathbf x&lt;/equation&gt; 投影在线段的延长线上，然后把投影点 &lt;equation&gt;\mathbf x&#39;&lt;/equation&gt; 控制在线段的范围内：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7c6a7d167bc1c041ac425e0333f433b9_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;770&quot; data-rawheight=&quot;292&quot;&gt;&lt;p&gt;&lt;equation&gt;\begin{align} \mathbf{x}&#39; &amp;amp;= \mathbf{a} + \max \left( \min \left ( \mathbf{v} \cdot \frac{\mathbf{u}}{\|\mathbf{u}\|}, \|\mathbf{u}\| \right), 0 \right) \frac{\mathbf{u}}{\|\mathbf{u}\|}\\ &amp;amp;= \mathbf{a} + \max \left( \min \left ( \mathbf{v} \cdot \frac{\mathbf{u}}{\|\mathbf{u}\|^2}, 1 \right), 0 \right) \mathbf{u}\\ &amp;amp;= \mathbf{a} + \max \left( \min \left ( \frac{ \mathbf{v} \cdot\mathbf{u}}{\mathbf{u}\cdot\mathbf{u}}, 1 \right), 0 \right) \mathbf{u} \end{align}\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;上式把最后的 &lt;equation&gt;1 / \|\mathbf{u}\|&lt;/equation&gt; 因子放进括号里，减少开方运算。然后，所需的距离为：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;d = \|\mathbf{p} - \mathbf{p}&#39;\|\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;这里我们把线段和胶囊形的 SDF 分开为两个函数实现：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;float segmentSDF(float x, float y, float ax, float ay, float bx, float by) {
    float vx = x - ax, vy = y - ay, ux = bx - ax, uy = by - ay;
    float t = fmaxf(fminf((vx * ux + vy * uy) / (ux * ux + uy * uy), 1.0f), 0.0f);
    float dx = vx - ux * t, dy = vy - uy * t;
    return sqrtf(dx * dx + dy * dy);
}

float capsuleSDF(float x, float y, float ax, float ay, float bx, float by, float r) {
    return segmentSDF(x, y, ax, ay, bx, by) - r;
}

Result scene(float x, float y) {
    Result c = {  capsuleSDF(x, y, 0.4f, 0.4f, 0.6f, 0.6f, 0.1f), 1.0f };
    return c;
}&lt;/code&gt;&lt;p&gt;结果：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-12cc950d8599a286efd66fe2c7743bdd_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;4. 矩形&lt;/h2&gt;&lt;p&gt;这里实现的矩形是二维定向矩形包围盒（oriented bounding box, OBB），可以由中心点 &lt;equation&gt;\mathbf{c}&lt;/equation&gt; 、旋转角 &lt;equation&gt;\theta&lt;/equation&gt;  和半长（half length) &lt;equation&gt;\mathbf{s}&lt;/equation&gt; 来表示：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-976f87d5b6cee06743601289976f3957_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;445&quot; data-rawheight=&quot;345&quot;&gt;&lt;p&gt;首先我们要把点 &lt;equation&gt;\mathbf{x}&lt;/equation&gt; 变换至 OBB 的坐标系。我们可反过来思考，如果从 OBB 的坐标系的一点，转换至世界坐标系：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\mathbf{x} = \begin{bmatrix} \cos \theta &amp;amp; -\sin\theta\\ \sin \theta &amp;amp; \cos\theta \end{bmatrix}\mathbf{x}&#39;+\mathbf{c}\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;那么，其逆变换就是（旋转矩阵是正交矩阵，有 &lt;equation&gt;Q^{-1}=Q^\mathrm{T}&lt;/equation&gt; ）：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\mathbf{x}&#39; = \begin{bmatrix} \cos \theta &amp;amp; \sin\theta\\ -\sin \theta &amp;amp; \cos\theta \end{bmatrix}(\mathbf{x}-\mathbf{c})\\&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;因为矩形的对称性，我们只需考虑第一象限，可用绝对值把 &lt;equation&gt;\mathbf{x}&#39;&lt;/equation&gt; 移到第一象限。然后，要对内和外分计算距离，再取得最少值。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;float boxSDF(float x, float y, float cx, float cy, float theta, float sx, float sy) {
    float costheta = cosf(theta), sintheta = sinf(theta);
    float dx = fabs((x - cx) * costheta + (y - cy) * sintheta) - sx;
    float dy = fabs((y - cy) * costheta - (x - cx) * sintheta) - sy;
    float ax = fmaxf(dx, 0.0f), ay = fmaxf(dy, 0.0f);
    return fminf(fmaxf(dx, dy), 0.0f) + sqrtf(ax * ax + ay * ay);
}

Result scene(float x, float y) {
    Result d = { boxSDF(x, y, 0.5f, 0.5f, TWO_PI / 16.0f, 0.3f, 0.1f), 1.0f };
    return d;
}&lt;/code&gt;&lt;p&gt;结果：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f4ffdb2c09dc2154387d87efd4a4bea3_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;p&gt;减去一个半径（如 0.1）就获得圆角长方形：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Result e = { boxSDF(x, y, 0.5f, 0.5f, TWO_PI / 16.0f, 0.3f, 0.1f) - 0.1f, 1.0f };
return e;&lt;/code&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9eb084399c7d14f4cb07eed639dee795_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;h2&gt;5. 三角形&lt;/h2&gt;&lt;p&gt;三角形的 SDF 需计算点至三个线段的最短距离，然后再判断点在内还是在外。这里我们用缠绕顺序（winding order）来定义三角形的内外。详细的判断方法请参考 [1]。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;float triangleSDF(float x, float y, float ax, float ay, float bx, float by, float cx, float cy) {
    float d = fminf(fminf(
        segmentSDF(x, y, ax, ay, bx, by),
        segmentSDF(x, y, bx, by, cx, cy)),
        segmentSDF(x, y, cx, cy, ax, ay));
    return (bx - ax) * (y - ay) &amp;gt; (by - ay) * (x - ax) &amp;amp;&amp;amp; 
           (cx - bx) * (y - by) &amp;gt; (cy - by) * (x - bx) &amp;amp;&amp;amp; 
           (ax - cx) * (y - cy) &amp;gt; (ay - cy) * (x - cx) ? -d : d;
}

Result scene(float x, float y) {
    Result f = { triangleSDF(x, y, 0.5f, 0.2f, 0.8f, 0.8f, 0.3f, 0.6f), 1.0f };
    return f;
}&lt;/code&gt;&lt;p&gt;结果：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-09fa273c6b0c1b8045c74977930e139e_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;p&gt;减去一个半径就获得圆角三角形：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-664af59808724a27e2b7042e55aeb42b_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;h2&gt;6. 结语&lt;/h2&gt;&lt;p&gt;本文介绍了 5 种二维形状的 SDF，当中用到不同的技巧，例如运用形状的对称性质。长方形实际上也可用三角形的做法实现，然而不考虑对称性，所需的运算会更多。&lt;/p&gt;&lt;p&gt;读者可利用这些形状及 CSG 来绘画各种形状的光，也可以尝试推导其他形状的 SDF。&lt;/p&gt;&lt;p&gt;我们之后会再讨论用 SDF 的其他技巧，但接下来的两篇将先回到光学相关内容──&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30961545&quot;&gt;反射&lt;/a&gt;与&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31127076&quot;&gt;折射&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;本文的源程序位于 &lt;a href=&quot;https://github.com/miloyip/light2d/blob/master/shapes.c&quot;&gt;shapes.c&lt;/a&gt; 及 &lt;a href=&quot;https://github.com/miloyip/light2d/blob/master/m.c&quot;&gt;m.c&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;p&gt;[1] Dan Sunday, &lt;a href=&quot;http://geomalgorithms.com/a03-_inclusion.html&quot;&gt;Inclusion of a Point in a Polygon&lt;/a&gt;.&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2017-11-11-30816284</guid>
<pubDate>Sat, 11 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>用 C 语言画光（二）：构造实体几何</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2017-11-05-30748318.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30748318&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-df4f3f1c919cc14d3abc022646a9cf10_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30745861&quot;&gt;用 C 语言画光（一）：基础&lt;/a&gt;》中，我们画了一个发光的圆形，那么，该如何画更多形状呢？&lt;/p&gt;&lt;h2&gt;1. 场景函数&lt;/h2&gt;&lt;p&gt;重温一下，之前的光线步进实现是这样的：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;float trace(float ox, float oy, float dx, float dy) {
    float t = 0.0f;
    for (int i = 0; i &amp;lt; MAX_STEP &amp;amp;&amp;amp; t &amp;lt; MAX_DISTANCE; i++) {
        float sd = circleSDF(ox + dx * t, oy + dy * t, /*...*/); // SDF
        if (sd &amp;lt; EPSILON) 
            return 2.0f; // 自发光
        t += sd;
    }
    return 0.0f;
}&lt;/code&gt;&lt;p&gt;在步进的过程中，我们要取得当前采样点与场景形状的带符号距离（signed distance），当少于阈值，就要返回该形状的自发光强度（emissive）。我们首先进行代码重构（code refactoring），把场景采样功能提取成一个函数（extract function），它返回 SDF 和自发光。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;typedef struct { float sd, emissive; } Result;

Result scene(float x, float y) {
    Result r = { circleSDF(x, y, 0.5f, 0.5f, 0.1f), 2.0f };
    return r;
}

float trace(float ox, float oy, float dx, float dy) {
    float t = 0.0f;
    for (int i = 0; i &amp;lt; MAX_STEP &amp;amp;&amp;amp; t &amp;lt; MAX_DISTANCE; i++) {
        Result r = scene(ox + dx * t, oy + dy * t); // &amp;lt;-
        if (r.sd &amp;lt; EPSILON)                         // &amp;lt;-
            return r.emissive;                      // &amp;lt;-
        t += r.sd;                                  // &amp;lt;-
    }
    return 0.0f;
}&lt;/code&gt;&lt;p&gt;那么，我们之后改动场景时就不用更改 &lt;equation&gt;\texttt{trace()}&lt;/equation&gt; 函数，只需修改 &lt;equation&gt;\texttt{scene()}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;2. 加入多个形状&lt;/h2&gt;&lt;p&gt;我们在上一篇谈到， &lt;equation&gt;\phi(\mathbf{x})&lt;/equation&gt; 表示坐标 &lt;equation&gt;\mathbf{x}&lt;/equation&gt; 与场景形状的最近距离。如果场景中有两个形状 A 和 B，它们的 SDF 分别为为 &lt;equation&gt;\phi_A(\mathbf{x})&lt;/equation&gt; 和 &lt;equation&gt;\phi_B(\mathbf{x})&lt;/equation&gt; ，那么坐标 &lt;equation&gt;\mathbf{x}&lt;/equation&gt; 与这两个形状的最近距离，就是两个 SDF 的最小值，即 &lt;equation&gt;\min(\phi_A(\mathbf{x}), \phi_B(\mathbf{x}))&lt;/equation&gt; 。这个操作可以定义为，形状 A 和 B 的并集（union） &lt;equation&gt;A \cup B&lt;/equation&gt; ，其 SDF 为：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\phi_{A \cup B}(\mathbf x) = \min\left(\phi_A(\mathbf x), \phi_B(\mathbf x)\right)&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;实现也很简单：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Result unionOp(Result a, Result b) {
    return a.sd &amp;lt; b.sd ? a : b;
}&lt;/code&gt;&lt;p&gt;我们加入 3 个圆形试试，每个圆形的自发光值都不同：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Result scene(float x, float y) {
    Result r1 = { circleSDF(x, y, 0.3f, 0.3f, 0.10f), 2.0f };
    Result r2 = { circleSDF(x, y, 0.3f, 0.7f, 0.05f), 0.8f };
    Result r3 = { circleSDF(x, y, 0.7f, 0.5f, 0.10f), 0.0f };
    return unionOp(unionOp(r1, r2), r3);
}&lt;/code&gt;&lt;p&gt;运行结果：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2174da795b73e400111ef1c8306f4f3d_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;p&gt;我们发现，此图形增添了一个视觉上的特徵──阴影！这是因为，进行光线步进时，追踪至非常接近形状表面时便会停下来，不会继续穿透形状，所以形状之间是有遮挡关系的，也就形成了阴影。而且因为光源是线条（此例子中是圆孤边界）而不是一点，所以会产生半影（penumbra）的效果。&lt;/p&gt;&lt;h2&gt;3. 构造实体几何&lt;/h2&gt;&lt;p&gt;采用 SDF 来表示形状，还可以简单地实现构造实体几何（constructive solid geometry），即是以形状点集的布尔操作来表示模型。3 个基本运算为并集（union）、交集（intersection）和相对补集（relative complement，或称为 set difference）：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\begin{align} \phi_{A \cup B}(\mathbf x) &amp;amp;= \min\left(\phi_A(\mathbf x), \phi_B(\mathbf x)\right)\\ \phi_{A \cap B}(\mathbf x) &amp;amp;= \max\left(\phi_A(\mathbf x), \phi_B(\mathbf x)\right)\\ \phi_{A \setminus B}(\mathbf x) &amp;amp;= \max\left(\phi_A(\mathbf x), -\phi_B(\mathbf x)\right)\\ \end{align}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;注意，相对补集运算为非可交换的（non-commutative）。另外，涉及凹的形状时，得出的 SDF 并不代表最近距离，但它的估值是保守的，我们仍然可以用光线步进方法来找出边界。&lt;/p&gt;&lt;p&gt;实现时，要注意除了计算结果的 SDF，还要考虑采用哪个形状的特性（暂时只有自发光）。对于交集，我们要采用相反的形状；对于相对补集则采用左运算元的形状：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Result unionOp(Result a, Result b) {
    return a.sd &amp;lt; b.sd ? a : b;
}

Result intersectOp(Result a, Result b) {
    Result r = a.sd &amp;gt; b.sd ? b : a;
    r.sd = a.sd &amp;gt; b.sd ? a.sd : b.sd;
    return r;
}

Result subtractOp(Result a, Result b) {
    Result r = a;
    r.sd = (a.sd &amp;gt; -b.sd) ? a.sd : -b.sd;
    return r;
}&lt;/code&gt;&lt;p&gt;做一个测试场景，左方是较亮的圆形，右方是较暗的圆形：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;Result scene(float x, float y) {
    Result a = { circleSDF(x, y, 0.4f, 0.5f, 0.20f), 1.0f };
    Result b = { circleSDF(x, y, 0.6f, 0.5f, 0.20f), 0.8f };
    return unionOp(a, b);
    // return intersectOp(a, b);
    // return subtractOp(a, b);
    // return subtractOp(b, a);
}&lt;/code&gt;&lt;p&gt;把 4 个语句逐一取消注释，运行结果：&lt;/p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d8e2b1bf29a01e861d06eca2952380eb_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1040&quot; data-rawheight=&quot;278&quot;&gt;&lt;h2&gt;4. 结语&lt;/h2&gt;&lt;p&gt;通过 CSG，可以把各种形状组合成不同的形状，这在运算在工业用的建模工具非常常见。你可以尝试做不同的形状，例如齿轮、花朵等。下一篇会讲述更多形状的 SDF 定义和相关运算。&lt;/p&gt;&lt;p&gt;本文的完整代码位于 &lt;a href=&quot;https://github.com/miloyip/light2d/blob/master/csg.c&quot;&gt;csg.c&lt;/a&gt;。&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2017-11-05-30748318</guid>
<pubDate>Sun, 05 Nov 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>用 C 语言画光（一）：基础</title>
<link>https://henix.github.io/feeds/zhuanlan.milocode/2017-11-05-30745861.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30745861&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-714f34f665d6e7dd808a4335feb5c492_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;之前写过用 C 语言画&lt;a href=&quot;https://www.zhihu.com/question/20187195/answer/34873279&quot;&gt;心形&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/question/27015321/answer/35028446&quot;&gt;圣诞树&lt;/a&gt;、&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24688522&quot;&gt;雪花&lt;/a&gt;、&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30553006&quot;&gt;直线&lt;/a&gt;，这次我们试玩光学。&lt;/p&gt;&lt;p&gt;在这系列文章中，我们会在二维的画布上「绘画」一些基于物理的光。但作为趣味性的编程文章，我尽量用直觉、简单的方式去生成这些图像，仅介绍一些概念，和一般的正式计算机图形学内容不同。&lt;/p&gt;&lt;p&gt;本系列的源代码位于 &lt;a href=&quot;https://github.com/miloyip/light2d&quot;&gt;miloyip/light2d&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;1. 光&lt;/h2&gt;&lt;p&gt;假设我们在一个二维的世界，这里有些会发光的二维形状，并暂时只考虑单色光。我们想知道的是，在这个空间中，每一点从 360 度各方向共有多少光经过。换成数学方式表示，我们想对每个二维坐标 &lt;equation&gt;(x, y)&lt;/equation&gt; 求积分：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;F(x, y) = \int_0^{2\pi} L(x, y, \theta)\mathrm{d}\theta\tag{1}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;当中 &lt;equation&gt;L(x, y, \theta)&lt;/equation&gt;  代表在二维坐标 &lt;equation&gt;(x, y)&lt;/equation&gt;  在 &lt;equation&gt;\theta&lt;/equation&gt; 方向有多少光经过。&lt;/p&gt;&lt;p&gt;我们想采样这个 &lt;equation&gt;F(x, y)&lt;/equation&gt; 存储在图像中，并利用 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/26525083&quot;&gt;svpng()&lt;/a&gt; 输出结果，那么我们的 &lt;equation&gt;\texttt{main()}&lt;/equation&gt; 函数简单为：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#include &quot;svpng.inc&quot;
#include &amp;lt;math.h&amp;gt;
#define W 512
#define H 512

unsigned char img[W * H * 3];

// ...

int main() {
    unsigned char* p = img;
    for (int y = 0; y &amp;lt; H; y++)
        for (int x = 0; x &amp;lt; W; x++, p += 3)
            p[0] = p[1] = p[2] = (int)(fminf(sample(
               (float)x / W, (float)y / H) * 255.0f, 255.0f));
    svpng(fopen(&quot;basic.png&quot;, &quot;wb&quot;), W, H, img, 0);
}&lt;/code&gt;&lt;p&gt;无论图像长宽是多少，这个二维空间的坐标范围都是 &lt;equation&gt;(x, y) \in [0, 1] \times [0, 1]&lt;/equation&gt; 。我们把结果映射至 &lt;equation&gt;\{0, 1, \ldots, 255\}&lt;/equation&gt; 。&lt;/p&gt;&lt;h2&gt;2. 蒙地卡罗积分&lt;/h2&gt;&lt;p&gt;由于无法以解析式求解这个积分，我们使用蒙地卡罗积分法（Monte Carlo integration）。&lt;/p&gt;&lt;p&gt;在这个问题中，我们随机采样 &lt;equation&gt;N&lt;/equation&gt; 个方向 &lt;equation&gt;{\theta_1, \theta_2, \ldots, \theta_N}&lt;/equation&gt; ，然后计算 &lt;equation&gt;L(x, y, \theta_i)&lt;/equation&gt; 的平均值：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;F(x, y) \approx \frac{2\pi}{N}\sum_{i=1}^N L(x, y, \theta_i)\tag{2}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;代码实现也很浅白（设每像素向 64 个随机方向均匀采样／uniform sampling）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define TWO_PI 6.28318530718f
#define N 64

float sample(float x, float y) {
    float sum = 0.0f;
    for (int i = 0; i &amp;lt; N; i++) {
        float a = TWO_PI * rand() / RAND_MAX;
        sum += trace(x, y, cosf(a), sinf(a));
    }
    return sum / N;
}&lt;/code&gt;&lt;p&gt;当中 &lt;equation&gt;\texttt{trace(ox, oy, dx, dy)}&lt;/equation&gt; 函数代表从 &lt;equation&gt;\mathbf{o}&lt;/equation&gt; 位置从单位矢量 &lt;equation&gt;\hat{\mathbf{d}}&lt;/equation&gt; 方向接收到的光。&lt;/p&gt;&lt;p&gt;（更新：本文不考虑实际单位，所以实现时把系数 &lt;equation&gt;2\pi&lt;/equation&gt; 去掉了。感谢 &lt;a class=&quot;member_mention&quot; href=&quot;http://www.zhihu.com/people/8f986a85ee4d74237f65aedd10ba389d&quot; data-hash=&quot;8f986a85ee4d74237f65aedd10ba389d&quot; data-hovercard=&quot;p$b$8f986a85ee4d74237f65aedd10ba389d&quot;&gt;@Bimos&lt;/a&gt; 提醒）&lt;/p&gt;&lt;h2&gt;3. 光线步进&lt;/h2&gt;&lt;p&gt;通常，我们可以用光线追踪（ray tracing）方法，求出光线 &lt;equation&gt;\mathbf{r}(t) = \mathbf{o} + \hat{\mathbf{d}}t&lt;/equation&gt; 与场景的最近点。&lt;/p&gt;&lt;p&gt;然而，我们需要为每种几何形状编写与光线的相交函数（通常比较复杂），之后做一些效果可能还要提供相交点的法线（normal vector）。&lt;/p&gt;&lt;p&gt;为简单起见，本文采用光线步进（ray marching）方法（又称为球体追踪／sphere tracing [1]），场景只需要以带符号距离场（signed distance field, SDF） &lt;equation&gt;\phi : \mathbb{R}^2 \rightarrow \mathbb{R}&lt;/equation&gt;  表示&lt;/p&gt;&lt;ol&gt;&lt;li&gt;当 &lt;equation&gt;\phi(\mathbf{x}) &amp;gt; 0&lt;/equation&gt; ，表示坐标 &lt;equation&gt;\mathbf{x}&lt;/equation&gt; 位于场景形状之外，且 &lt;equation&gt;\mathbf{x}&lt;/equation&gt; 与最近形状边界的距离为 &lt;equation&gt;\phi(\mathbf{x})&lt;/equation&gt; ；&lt;/li&gt;&lt;li&gt;当 &lt;equation&gt;\phi(\mathbf{x}) &amp;lt; 0&lt;/equation&gt; ，表示坐标 &lt;equation&gt;\mathbf{x}&lt;/equation&gt; 位于场景形状之内，且 &lt;equation&gt;\mathbf{x}&lt;/equation&gt; 与最近形状边界的距离为 &lt;equation&gt;-\phi(\mathbf{x})&lt;/equation&gt; ；&lt;/li&gt;&lt;li&gt;当 &lt;equation&gt;\phi(\mathbf{x})= 0&lt;/equation&gt; ，说明 &lt;equation&gt;\mathbf{x}&lt;/equation&gt; 刚好在形状边界上。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;例如，圆心为 &lt;equation&gt;\mathbf{c}&lt;/equation&gt; 、半径为 &lt;equation&gt;r&lt;/equation&gt; 的圆形 SDF 定义为（更精确的说法是圆盘／disk）：&lt;/p&gt;&lt;p&gt;&lt;equation&gt;\phi_\text{circle}(\mathbf{x}) = \left \| \mathbf{x} - \mathbf{c} \right \|-r\tag{3}&lt;/equation&gt; &lt;/p&gt;&lt;p&gt;用代码表示：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;float circleSDF(float x, float y, float cx, float cy, float r) {
    float ux = x - cx, uy = y - cy;
    return sqrtf(ux * ux + uy * uy) - r;
}&lt;/code&gt;&lt;p&gt;而所谓光线步进，就是我们从光线起始点 &lt;equation&gt;t = 0&lt;/equation&gt; ，逐步增加 &lt;equation&gt;t&lt;/equation&gt; ，当 &lt;equation&gt;\phi(\mathbf{r}(t)) \le 0&lt;/equation&gt; 代表我们到达到场景中某个形状的表面或内部。那么我们每次可以步进多远？由于 &lt;equation&gt;\phi(\mathbf{x})&amp;gt;0&lt;/equation&gt; 时，代表 &lt;equation&gt;\mathbf{x}&lt;/equation&gt; 距最近形状的距离，所以我们至少可以步进该距离而不会碰到任何形状！&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-17fd23c7b0af869f90bc2d374e56aa1e_r.jpg&quot; data-caption=&quot;图源 https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter08.html&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;400&quot; data-rawheight=&quot;244&quot;&gt;&lt;p&gt;设场景只有一个发光的圆形，圆心为 &lt;equation&gt;(0.5, 0.5)&lt;/equation&gt; ，半径为 &lt;equation&gt;0.1&lt;/equation&gt; ，它每点都向各方向发射 &lt;equation&gt;2&lt;/equation&gt; 个单位的光。那么光线步进可实现为：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;#define MAX_STEP 10
#define MAX_DISTANCE 2.0f
#define EPSILON 1e-6f

float trace(float ox, float oy, float dx, float dy) {
    float t = 0.0f;
    for (int i = 0; i &amp;lt; MAX_STEP &amp;amp;&amp;amp; t &amp;lt; MAX_DISTANCE; i++) {
        float sd = circleSDF(ox + dx * t, oy + dy * t, 0.5f, 0.5f, 0.1f);
        if (sd &amp;lt; EPSILON)
            return 2.0f;
        t += sd;
    }
    return 0.0f;
}&lt;/code&gt;&lt;p&gt;如果光线超过指定距离，或是步数太多，都终止步进。注意我们只能尽量接近表面，所以用 &lt;equation&gt;\epsilon = 10^{-6}&lt;/equation&gt; 表示足够近的阈值。整个程序完成，运算结果如下：&lt;/p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0a31e467fd69a2f08e0fcea6a1979ff2_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;p&gt;可以看到图像中有很多噪点，这是由于蒙地卡罗积分法具随机性，计算出来的估值与精确数值会有误差。增加采样数目 &lt;equation&gt;N&lt;/equation&gt; ，就能令结果更精确（准确地说是减少方差／variance）：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8d86325bc5b25ae3f9ac26b60547410a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;528&quot; data-rawheight=&quot;150&quot;&gt;&lt;p&gt;然而，随着 &lt;equation&gt;N&lt;/equation&gt; 上升，运算时间也线性上升。有没有方法可以改善？&lt;/p&gt;&lt;h2&gt;4. 分层、抖动采样&lt;/h2&gt;&lt;p&gt;形成噪点的原因在于，每个像素所得到的随机方向都很不一样。那么，如果我们不用随机方向，而是平分 360 度向 &lt;equation&gt;N&lt;/equation&gt; 个方向采样，效果会如何？这种方式称为分层采样（stratified sampling）：&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;float sample(float x, float y) {
    float sum = 0.0f;
    for (int i = 0; i &amp;lt; N; i++) {
        // float a = TWO_PI * rand() / RAND_MAX; // 均匀采样
           float a = TWO_PI * i / N;             // 分层采样
        // ...&lt;/code&gt;&lt;p&gt;改变这一行代码的结果是：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-44cbaf8810003bb099f6894c0c44810a_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;p&gt;很好，没有噪点，但也太过规律了！&lt;/p&gt;&lt;p&gt;我们可以结合上面两种采样方式，就是先分为 &lt;equation&gt;N&lt;/equation&gt; 个角度区域，再从区域中均匀采样，这称为抖动采样（jittered sampling）。&lt;/p&gt;&lt;code lang=&quot;c&quot;&gt;// float a = TWO_PI * rand() / RAND_MAX;                  // 均匀采样
// float a = TWO_PI * i / N;                              // 分层采样
   float a = TWO_PI * (i + (float)rand() / RAND_MAX) / N; // 抖动采样&lt;/code&gt;&lt;p&gt;改变这一行代码的结果是：&lt;/p&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-6d1dba9dd3541e0c1b17d2211923a559_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;512&quot;&gt;&lt;p&gt;同样使用每像素 &lt;equation&gt;N=64&lt;/equation&gt; 次采样，仅仅改变采样方式（一行代码），效果就好很多：&lt;/p&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-345085c75f4e84db7dde6bdf383f4d47_r.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;396&quot; data-rawheight=&quot;150&quot;&gt;&lt;h2&gt;5. 结语&lt;/h2&gt;&lt;p&gt;这个完整程序位于 &lt;a href=&quot;https://github.com/miloyip/light2d/blob/master/basic.c&quot;&gt;basic.c&lt;/a&gt;。如果不含加载头文件及常数定义，仅有 30 行代码。你可以改一下圆形位置、大小、光度，测试时可用较小的 W、H 和 N 加速运行过程。&lt;/p&gt;&lt;p&gt;本文简单介绍了蒙地卡罗积分、光线步进、分层采样等概念。下一篇《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30748318&quot;&gt;构造实体几何&lt;/a&gt;》会讲如何在场景中加入更多形状，将会显示出阴影。而之后也会尝试实现一些光学法则，生成更有趣的图形。&lt;/p&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;p&gt;[1] Hart, John C. &quot;Sphere tracing: A geometric method for the antialiased ray tracing of implicit surfaces.&quot; &lt;i&gt;The Visual Computer&lt;/i&gt;12.10 (1996): 527-545.&lt;/p&gt;</description>
<author>Milo Yip</author>
<guid isPermaLink="false">2017-11-05-30745861</guid>
<pubDate>Sun, 05 Nov 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
