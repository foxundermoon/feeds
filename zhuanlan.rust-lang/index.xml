<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
<title>Rust编程</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/</link>
<description>与 Rust 语言相关的方方面面</description>
<language>zh-cn</language>
<lastBuildDate>Thu, 31 May 2018 14:23:11 +0800</lastBuildDate>
<item>
<title>Rust 中，常规的 vector 是一种值</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2018-05-30-37488569.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37488569&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;a href=&quot;http://smallcultfollowing.com/babysteps/blog/2018/02/01/in-rust-ordinary-vectors-are-values/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot;&gt;In Rust, ordinary vectors are values&lt;/a&gt;&lt;p&gt;作者：Niko Matsakis  译者：Quan Brew&lt;/p&gt;&lt;p&gt;本文不需要 Rust 基础也能阅读。其中 vector 指的是大多数语言中的 List 或者动态数组。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我最近一直在思考持久化容器 (persistent collections)，特别是它们与 Rust 的关系，我想写下一些我的观察。[1]&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;什么是持久化容器&lt;/h2&gt;&lt;p&gt;传统上，持久化容器被看作是一种与众不同的建立容器的方法。传统的容器有类似&lt;code class=&quot;inline&quot;&gt;push&lt;/code&gt;的方法，能让 vector &lt;b&gt;原地&lt;/b&gt;增长：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;
vec.push(element); // 往 `vec` 增加元素&lt;/code&gt;&lt;p&gt;而持久化容器有类似&lt;code class=&quot;inline&quot;&gt;add&lt;/code&gt;的方法，能保留原本的 vector 不动，而返回一个已经被修改的&lt;b&gt;新vector&lt;/b&gt;：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let vec2 = vec.add(element);&lt;/code&gt;&lt;p&gt;此处的关键特性在于&lt;code class=&quot;inline&quot;&gt;vec&lt;/code&gt;没有改变，这使得持久化容器非常适合函数式语言（以及适合并行计算）。&lt;/p&gt;&lt;h2&gt;持久化容器如何运作&lt;/h2&gt;&lt;p&gt;我不会详细介绍任何特定的设计，但是大多数都是基于某种树的。比如说，如果有一个 vector 类似于&lt;code class=&quot;inline&quot;&gt;[1, 2, 3, 4, 5, 6]&lt;/code&gt;，可以想象一下，这些值不是以一大块的方式储存，而是将它们储存在某种树中，值保存在叶子结点里。在下面的示意中，元素被分开放在两个叶子结点，父节点的指针指向这两个节点：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
 [*        *] // &amp;lt;-- 这是 vector 的父节点
  |        |
-----    -----
1 2 3    4 5 6&lt;/code&gt;&lt;p&gt;现在想想我们要改变 vector 中的一个值，比如说我们想把&lt;code class=&quot;inline&quot;&gt;6&lt;/code&gt;改成&lt;code class=&quot;inline&quot;&gt;10&lt;/code&gt;。这意味着我们必须改变右节点，但可以继续使用左节点。所以我们创建一个新的父节点，这样就能引用新的右节点。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;
 [*        *]   // &amp;lt;-- 原 vector
  |        |    //     (仍然存在，没有被改变)
-----    -----
1 2 3    4 5 6
-----
  |      4 5 10 // &amp;lt;-- 右节点的新拷贝
  |      ------
  |        |
 [*        *]   // &amp;lt;-- 新的 vector&lt;/code&gt;&lt;p&gt;对于一个平衡的树中，这通常意味着往一个持久化 vector 中插入元素往往是 &lt;equation&gt;O(\log n)&lt;/equation&gt; ——我们必须复制和修改一些叶子，然后必须复制和修改所有这条路径的父节点。&lt;b&gt;这比修改传统的 vector 开销更大，修改传统的 vector 只是一些CPU指令。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;一些意见：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果这个 vector 实际上没有&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%88%AB%E5%90%8D_(%E8%AE%A1%E7%AE%97)&quot;&gt;别名&lt;/a&gt;（多处引用同一段内存），并且你知道它没有别名，那么常常可以避免这些复制，仅仅是原地修改树。稍后，我会谈到 &lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://docs.rs/dogged/0.2.0/dogged/struct.DVec.html&quot;&gt;DVec&lt;/a&gt;&lt;/code&gt;，一个试验性的 Rust 持久化容器库做到了这个特性。但在典型的基于 GC 的语言中很难做到，因为你永远不知道自己在用的是别名。&lt;/li&gt;&lt;li&gt;持久化容器有非常多的其他设计，其中一些设计偏向于特定的使用模式。比如说，&lt;a href=&quot;https://www.lri.fr/~filliatr/ftp/publis/puf-wml07.pdf&quot;&gt;这个论文&lt;/a&gt;提出了一个针对于类似 Prolog 程序的设计；这个设计内部用了可变方式实现 &lt;equation&gt;O(1)&lt;/equation&gt; 插入，但是在接口上对用户隐藏。当然，这些低开销的插入是有代价的：数据结构的较老的拷贝使用起来开销很大。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;持久化容器让容器变成值&lt;/h2&gt;&lt;p&gt;某些情况下，持久化容器能让代码更容易被理解。因为他们更像一个「普通的值」，没有自己的「秉性」。来看这个JS代码，用整数：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;
function foo() {
    let x = 0;
    let y = x;
    y += 1;
    return y - x;
}&lt;/code&gt;&lt;p&gt;此处我们修改 &lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt; 的时候，不期望 &lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt; 也改变，因为 &lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt; 只是一个简单的值。但是如果改成用数组：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;
function foo() {
    let x = [];
    let y = x;
    y.push(22);
    use(x, y);
}&lt;/code&gt;&lt;p&gt;现在修改&lt;code class=&quot;inline&quot;&gt;y&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt;也会跟着改变。也许这正是我们想要的，但有时候不是。当 vector 藏在对象后面的时候，事情会愈发让人摸不清头脑：&lt;/p&gt;&lt;code lang=&quot;js&quot;&gt;
function foo() {
    let object = {
        field: []
    };
    ...
    let object2 = {
        field: object.field
    };
    ...
    // 现在 `object.field` 和 `object2.field` 在幕后秘密相连
    ...
}&lt;/code&gt;&lt;p&gt;不要误会，有时候&lt;code class=&quot;inline&quot;&gt;object.field&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;object2.field&lt;/code&gt;是指向同一个 vector 是非常方便的。但另一些时候这不是你想要的。我常常发现改成持久化容器能让我的代码更清晰、易于理解。&lt;/p&gt;&lt;h2&gt;Rust 是特别的&lt;/h2&gt;&lt;p&gt;如果你曾看过我对于 Rust 的一次演讲[2]会知道，我反复强调 Rust 设计的一个核心要素：&lt;/p&gt;&lt;blockquote&gt;数据分享和可变：都是好东西，但放在一起就非常可怕。&lt;/blockquote&gt;&lt;p&gt;基本上，这个想法是，当有两个不同的路径访问同样的内存（在上一个例子中的&lt;code class=&quot;inline&quot;&gt;object.field&lt;/code&gt;和&lt;code class=&quot;inline&quot;&gt;object2.field&lt;/code&gt;），对它进行修改就是非常危险的意图。对于 Rust 试图放弃使用 GC，情况就尤其如此，因为突然不清楚谁应该管理这块内存了。&lt;b&gt;但哪怕使用 GC 也是如此&lt;/b&gt;，因为一个像&lt;code class=&quot;inline&quot;&gt;object.field.push(...)&lt;/code&gt;的修改可能影响比预料中更多的对象，从而导致错误（尤其是但不限于发生在并行线程中的情况）。&lt;/p&gt;&lt;p&gt;那么，如果试图两次访问同一个 vector，在 Rust 中会发生什么？回到刚刚看到的 JavaScript 例子，但这次使用Rust写。第一个例子是用整数，运作得和JS一样：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;
let x = 0;
let mut y = x;
y += 1;
return y - x;&lt;/code&gt;&lt;p&gt;但第二个例子，也就是用 vector，根本不会通过编译：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;
let x = vec![];
let mut y = x;
y.push(...);
use(x, y); // ERROR: use of moved value `x`&lt;/code&gt;&lt;p&gt;问题在于，一旦用了 &lt;code class=&quot;inline&quot;&gt;y = x&lt;/code&gt;，就已经拿走了 &lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt; 的所有权，这样它就不能再被使用了。&lt;/p&gt;&lt;h2&gt;在 Rust 中，普通的 vector 是值&lt;/h2&gt;&lt;p&gt;可以引出结论。在 Rust 中，日常使用的「普通的容器」&lt;b&gt;已经像值一样行事&lt;/b&gt;：实际任何 Rust 类型都是如此——只要不使用&lt;code class=&quot;inline&quot;&gt;Cell&lt;/code&gt;或者&lt;code class=&quot;inline&quot;&gt;RefCell&lt;/code&gt;。换句话说，假设代码通过编译，你知道你的 vector 没有在多个地方被修改：你可以用一个整数来代替它，而它会有相同的行为。这样很好。&lt;/p&gt;&lt;p&gt;&lt;b&gt;这意味着就 Rust 而言，持久化容器和普通容器相比，不必一定要有「不同的接口」。&lt;/b&gt;例如，我创建了一个名为&lt;a href=&quot;https://crates.io/crates/dogged&quot;&gt;dogged&lt;/a&gt; [3] 的持久化 vector。Dogged 提供了一种称为 &lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://docs.rs/dogged/0.2.0/dogged/struct.DVec.html&quot;&gt;DVec&lt;/a&gt;&lt;/code&gt; 的 vector 类型，它基于&lt;a href=&quot;https://hypirion.com/musings/understanding-persistent-vector-pt-1&quot;&gt;Clojure 提供的持久化 vector&lt;/a&gt;。但如果看看 &lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://docs.rs/dogged/0.2.0/dogged/struct.DVec.html&quot;&gt;DVec&lt;/a&gt;&lt;/code&gt; 提供的方法，会发现这是一种标准的容器（有 &lt;code class=&quot;inline&quot;&gt;push&lt;/code&gt; 等等）。&lt;/p&gt;&lt;p&gt;比如说这是一种 &lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt; 的有效操作：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let mut x = DVec::new();
x.push(something);
x.push(something_else);
for element in &amp;amp;x { ... }&lt;/code&gt;&lt;p&gt;尽管如此，一个&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt;还是一个持久化数据结构。在实现上，一个 &lt;code class=&quot;inline&quot;&gt;Dvec&lt;/code&gt; 被实现为&lt;a href=&quot;https://zh.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt;。它包含一个 &lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/sync/struct.Arc.html&quot;&gt;Arc&lt;/a&gt;&lt;/code&gt; （引用计数指针）来引用其内部数据。当调用&lt;code class=&quot;inline&quot;&gt;push&lt;/code&gt;时，我们会更新&lt;code class=&quot;inline&quot;&gt;Arc&lt;/code&gt; 指向新的vector，并把旧数据留在原地。&lt;/p&gt;&lt;p&gt;（顺便说一句，&lt;code class=&quot;inline&quot;&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/sync/struct.Arc.html#method.make_mut&quot;&gt;Arc::make_mut&lt;/a&gt;&lt;/code&gt;是一个&lt;b&gt;非常酷的&lt;/b&gt;方法。它检查&lt;code class=&quot;inline&quot;&gt;Arc&lt;/code&gt;的引用计数：如果是1，则给你对内容的唯一（可变）访问权限；如果引用计数&lt;b&gt;不是&lt;/b&gt;1，那么它将复制&lt;code class=&quot;inline&quot;&gt;Arc&lt;/code&gt;（及其内容），并给你这个复制的数据的可变引用。如果回想起持久化数据结构是如何运作的，就能发现这对于更新一个树是&lt;i&gt;完美的&lt;/i&gt;，它让你在容器没有别名的情况下，可以避免复制操作。）&lt;/p&gt;&lt;h2&gt;但持久化容器间是不同的&lt;/h2&gt;&lt;p&gt;一个 &lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt; 和一个 &lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt; 之间的主要区别不是它们提供的操作，而在于&lt;b&gt;它们的开销&lt;/b&gt;。也就是说，当在一个标准的&lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt;上&lt;code class=&quot;inline&quot;&gt;push&lt;/code&gt;时，它是一个 &lt;equation&gt;O(1)&lt;/equation&gt; 操作。当复制它的时候，就是 &lt;equation&gt;O(n)&lt;/equation&gt; 。对于一个&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt;，开销截然不同：&lt;code class=&quot;inline&quot;&gt;push&lt;/code&gt;是 &lt;equation&gt;O(\log n)&lt;/equation&gt; ​，但是复制是 ​ &lt;equation&gt;O(1)&lt;/equation&gt; 。&lt;/p&gt;&lt;p&gt;&lt;b&gt;尤其对于一个&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;clone&lt;/code&gt;操作只是增加内部的&lt;code class=&quot;inline&quot;&gt;Arc&lt;/code&gt;引用计数，而对于普通vector，&lt;code class=&quot;inline&quot;&gt;clone&lt;/code&gt;必须复制所有数据。&lt;/b&gt;当然，对一个&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt;执行&lt;code class=&quot;inline&quot;&gt;push&lt;/code&gt;，会在重建树受影响的部分时复制一部分数据（而&lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt;一般只需要在数组末尾写入数据）。&lt;/p&gt;&lt;p&gt;众所周知，「大O」记法只描述渐进耗时。&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt;我已经遇到的一个问题在于，在性能上它很难与标准的&lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt;竞争。单纯地整串复制数据经常比更新树以及分配内存要快。我发现只有在极端情况下才有用&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt;的理由——比如说做大量复制操作，或者有大量数据。&lt;/p&gt;&lt;p&gt;当然不全关于性能。如果进行大量复制操作，&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt; 也应该使用更少的内存，因为大量内部数据可以共享。&lt;/p&gt;&lt;h2&gt;结论&lt;/h2&gt;&lt;p&gt;在这里我通过持久化容器试图说明，Rust 的所有权系统是如何以一种巧妙的方式，将函数式风格和命令式风格融合。&lt;b&gt;也就是说，Rust 的标准容器虽然以典型的命令式接口实现，但实际上它们像是「值」一样在运作：&lt;/b&gt;在将一个 vector 从一个地方赋值到另一个地方的时候，如果想继续使用原本的那个，就必须&lt;code class=&quot;inline&quot;&gt;clone&lt;/code&gt;它，这就使得新的拷贝独立于旧的那个。&lt;/p&gt;&lt;p&gt;这不是新的见解。比如说1990年，Phil Wadler 写了一篇&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.5439&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;题为《线性类型可以改变世界！》的论文&lt;/a&gt;，在这之中他得出几乎一摸一样的结论，然而是从相反的起点出发。在论文中他说，依旧能提供一个持久化的接口（例如，&lt;code class=&quot;inline&quot;&gt;vec.add(element)&lt;/code&gt;返回新 vector 的方法），但如果使用线性类型，可以通过一个命令式的数据结构暗地里实现它（例如&lt;code class=&quot;inline&quot;&gt;vec.push(element)&lt;/code&gt;），而不让别人知道。&lt;/p&gt;&lt;p&gt;在摆弄&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt;的时候，我发现一个持久化 vector 也提供常规（命令式）接口是很有用的。比如说，我能够非常容易修改&lt;a href=&quot;https://crates.io/crates/ena&quot;&gt;ena 合一库&lt;/a&gt;（在内部它基于一个vector）让它运作在持久化模式（使用&lt;code class=&quot;inline&quot;&gt;DVec&lt;/code&gt;）或者命令式模式（使用&lt;code class=&quot;inline&quot;&gt;Vec&lt;/code&gt;）。基本的点子是将具体的 vector 类型泛型化，如果这些类型提供一样的接口的话这会很简单。&lt;/p&gt;&lt;p&gt;（另外，我乐意看到更多的实验。比如说，如果一个 vector 开始时是一个常规 vector，但是超过某个长度就会变成持久化 vector，我认为是非常有用的。）&lt;/p&gt;&lt;p&gt;&lt;i&gt;特别&lt;/i&gt;对于 Rust，我觉得有其他的原因让人对持久化容器产生兴趣。同时对数据进行分享和修改是一种有风险的模式，但有时候是必要又有用的，而在 Rust 现在用起来感觉是反人类的。&lt;b&gt;我认为我们应该做一些事情来改善这种情况，我也有一些具体的想法&lt;/b&gt;[4]，但我觉得在这里使用「持久化 vs 命令式容器」的表述是不合理的。换句话说，Rust 已经&lt;i&gt;有了&lt;/i&gt;持久化容器，它只是在&lt;code class=&quot;inline&quot;&gt;clone&lt;/code&gt;操作上特别低效。&lt;/p&gt;&lt;h2&gt;脚注&lt;/h2&gt;&lt;p&gt;[1]: 正好，我之前写的 SLG 求解器似乎特别喜欢用持久化容器。&lt;/p&gt;&lt;p&gt;[2]: 如果还没有，那么我觉得&lt;a href=&quot;https://www.sics.se/nicholas-matsakis&quot;&gt;这个&lt;/a&gt;非常好。&lt;/p&gt;&lt;p&gt;[3​]: 在英语中，如果你“dogged”地追求你的目标，你就很坚持不懈 (persistent)。&lt;/p&gt;&lt;p&gt;[4]: 具体的想法，必须等到下一篇博客文章。现在是让我女儿去上学的时间了！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>酿泉</author>
<guid isPermaLink="false">2018-05-30-37488569</guid>
<pubDate>Wed, 30 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust - RFC 导读: async/await 特性（二）</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2018-05-25-37298671.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37298671&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b357cf4b2202c2f3e9edb6c3b6204680_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;由于本篇文章代码较多，如果知乎的排版伤害了你的眼睛，可以暂时移步到 &lt;a href=&quot;https://github.com/andylokandy/article/blob/master/Rust%20-%20RFC%20%E5%AF%BC%E8%AF%BB%20async%20%E7%89%B9%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89.md&quot;&gt;这里&lt;/a&gt;。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37209852&quot;&gt;上一篇&lt;/a&gt;我们讲到了编译器对 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; 的特性支持，相应的，我们要让编译器知道 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 是什么，编译器才能生成匿名的 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 类型。为此，我们就有了第二份 RFC —— 将 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 加入标准库（准确来说是 &lt;code class=&quot;inline&quot;&gt;libcore&lt;/code&gt;）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/aturon/rfcs/blob/async-trait/text/0000-async.md&quot;&gt;RFC 2418 companion libs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;注意这篇 RFC 还在讨论阶段并未被 merge，因此最终方案可能会改变，目前已经可以看见讨论区提出了相较于 &lt;code class=&quot;inline&quot;&gt;arbitrary self type&lt;/code&gt;（&lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;self&amp;gt;&lt;/code&gt;） 更好的解决方案，这部分是最有可能发生变化的。&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Summary&lt;/h2&gt;&lt;p&gt;这篇文章将会深入 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; 的实现原理，如果读者只是希望使用现成的库和 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; 语法，仅看上一篇文章就已经足够了。而如果你希望开发使用异步实现的库，或者天生有着强烈的好奇心，那么这篇文章就是专门为你定做的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这篇 RFC 并不打算将整个 &lt;code class=&quot;inline&quot;&gt;futures-rs&lt;/code&gt; 移入标准库，相反极力精简，仅仅加入必要的最基础的构件，把剩余的功能留给社区的库来实现。就算如此，我们也将迎来帮数量众多的新朋友: &lt;code class=&quot;inline&quot;&gt;core::task::{Context, Poll, Wake, Waker, UnsafeWake, Executor, TaskObj, SpawnErrorKind, SpawnObjError}&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;core::ops::Async&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果加上另一篇 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md&quot;&gt;RFC: 2349-pin&lt;/a&gt;，那就还有 &lt;code class=&quot;inline&quot;&gt;core::marker::Unpin&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;core::mem::Pin&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们可以看到，新加入的东西真心不少，但是别担心，它们的存在都是必要而且符合直觉的，接下来我会逐个解释这些东西到底用来干什么的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;另外，读者可能注意到，这篇 RFC 中并没有出现 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt;，这是因为这篇 RFC 写在上一篇 RFC 之后，在这期间社区讨论决定了并不引入 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 全部的功能(比如 &lt;code class=&quot;inline&quot;&gt;map()&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;and_then()&lt;/code&gt;)，而是只定义其中关键一部分 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;，剩余的功能依旧留给 &lt;code class=&quot;inline&quot;&gt;futures-rs&lt;/code&gt; 库来提供，所以这个被精简的 &lt;code class=&quot;inline&quot;&gt;trait&lt;/code&gt; 不能叫做 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt;，那就改名叫作了 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt;。也就是说，async 函数的返回值应该是 &lt;code class=&quot;inline&quot;&gt;impl Async&amp;lt;Output = T&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;让我们先从关键的 &lt;code class=&quot;inline&quot;&gt;Async trait&lt;/code&gt; 入手，下面是它的定义： &lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub trait Async {
    type Output;
    /// Attempt to resolve the computation to a final value, registering
    /// the current task for wakeup if the value is not yet available.
    fn poll(self: Pin&amp;lt;Self&amp;gt;, cx: &amp;amp;mut task::Context) -&amp;gt; Poll&amp;lt;Self::Output&amp;gt;;
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 只定义了一个函数 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;，作用是尝试获取异步操作的结果， 熟悉使用 &lt;code class=&quot;inline&quot;&gt;futures-rs&lt;/code&gt; 的读者想必已经对它十分了解了。如果不是也没关系，我会从头解释一遍。我们先忽略传入参数，只看返回值，它返回的是 &lt;code class=&quot;inline&quot;&gt;Poll&lt;/code&gt; 类型：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub enum Poll&amp;lt;T&amp;gt; {
    Ready(T),
    Pending,
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Poll&lt;/code&gt; 有两个 variance: &lt;code class=&quot;inline&quot;&gt;Ready(T)&lt;/code&gt; 表示异步操作已经完成并获得返回值, &lt;code class=&quot;inline&quot;&gt;Pendding&lt;/code&gt; 表示异步操作还在进行中，你过会儿再过来看看。&lt;code class=&quot;inline&quot;&gt;Poll&lt;/code&gt; 的概念很简单，就不多说了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这就带来了一个问题，我们该什么时候调用 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 呢？它仅仅在完成之后才能给出有用的结果，万一如果返回的是 &lt;code class=&quot;inline&quot;&gt;Pending&lt;/code&gt;, 我们怎么知道什么时候需要再次 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 呢？又由谁来负责 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;答案是我们需要一个 &lt;code class=&quot;inline&quot;&gt;event loop&lt;/code&gt;（比如线程池）来帮助我们完成这个调度(scheduling)工作。标准库并不会提供一个现成的 &lt;code class=&quot;inline&quot;&gt;event loop&lt;/code&gt;，但标准库提供了定义它们的 &lt;code class=&quot;inline&quot;&gt;trait&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;我们来看一个具体的例子，比如说我们正在打算从 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 接收数据，我们得到了一个 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt;，这时候 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 可能还没准备好，所以第一次 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 返回了 &lt;code class=&quot;inline&quot;&gt;Poll::Pending&lt;/code&gt;，这时我们必须把这个 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 交给一个 &lt;code class=&quot;inline&quot;&gt;event loop&lt;/code&gt; 保管（就比如说一个由 &lt;code class=&quot;inline&quot;&gt;futures-rs&lt;/code&gt; 库提供的线程池 &lt;code class=&quot;inline&quot;&gt;ThreadPool&lt;/code&gt;），以备过会 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 准备好了再回来 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在这个例子里 &lt;code class=&quot;inline&quot;&gt;ThreadPool&lt;/code&gt; 实现了 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt;。我们来看看这个东西的定义：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub trait Executor {
    fn spawn_obj(&amp;amp;mut self, task: TaskObj) -&amp;gt; Result&amp;lt;(), SpawnObjError&amp;gt;;
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里的 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 实际上是一个 &lt;code class=&quot;inline&quot;&gt;Box&amp;lt;Async&amp;lt;Output = ())&amp;gt;&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;spawn_obj()&lt;/code&gt; 用于给 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 安排工作，让 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 负责稍后的 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 工作。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里说个题外话，因为 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 使用了动态派发 （&lt;code class=&quot;inline&quot;&gt;trait object&lt;/code&gt;），所以目前这里的堆分配是必须的。然而我们还有另一套用于 &lt;code class=&quot;inline&quot;&gt;no_std&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;unsafe&lt;/code&gt; 的解决方案可以避免堆分配，有兴趣的读者可以在原文拉到最后了解一下。在不久的将来，在 Rust 支持在栈上存储 &lt;code class=&quot;inline&quot;&gt;dynamic size type(DST)&lt;/code&gt; 的时候 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1909-unsized-rvalues.md&quot;&gt;[Merged] RFC 1909:unsized-rvalues&lt;/a&gt;，这里的 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 也会取消，取而代之的是栈上的 &lt;code class=&quot;inline&quot;&gt;Task&lt;/code&gt;，这也是现在取个这么难听名字的原因。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;解决了 who 的问题，那还有 when 问题。我们让 &lt;code class=&quot;inline&quot;&gt;ThreadPool&lt;/code&gt; 来负责重新 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; ，那到底什么时候 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 呢？只有 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 知道自己什么时候准备好，所以 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 需要在准备好的时候 “通知” &lt;code class=&quot;inline&quot;&gt;ThreadPool&lt;/code&gt; 重新 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;。这个操作叫做 &lt;code class=&quot;inline&quot;&gt;wake&lt;/code&gt; （唤醒），这意味着，我们要给 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 提供通知 &lt;code class=&quot;inline&quot;&gt;ThreadPool&lt;/code&gt; 的方法 —— 让 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 拿着 &lt;code class=&quot;inline&quot;&gt;Arc&amp;lt;ThreadPool&amp;gt;&lt;/code&gt;。完美。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;为了让 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 能够唤醒 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt;，标准库提供了 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt;。&lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 只需握着 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt;，就能在准备好的时候调用 &lt;code class=&quot;inline&quot;&gt;wake()&lt;/code&gt;，通知 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 该 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;了。 下面是 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; 的定义：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub trait Wake: Send + Sync {
    fn wake(&amp;amp;self);
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;但是实现 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; 的可以是 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 自己吗？不可以。因为一个 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 上可能托管着成百上千的 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt;，直接 &lt;code class=&quot;inline&quot;&gt;wake()&lt;/code&gt; 并不能告诉 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 究竟是哪个 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 需要 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;。因此 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 会给每个 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 提供一个唯一标识，然后把这个标识和自己的引用计数指针打包装在一起，弄一个类似 &lt;code class=&quot;inline&quot;&gt;WakeHandler&lt;/code&gt; 的玩意。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct WakeHandler {
    exec: Arc&amp;lt;ThreadPool&amp;gt;,
    id: u64,
}

impl Wake for WakeHandler { .. }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;所以这里 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 在被第一次 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 的时候 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 就会记下这个 &lt;code class=&quot;inline&quot;&gt;WakeHandler&lt;/code&gt;（因为这里 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 的实际类型是 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 提供的），准备好后  &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt;  调用 &lt;code class=&quot;inline&quot;&gt;wake()&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;Excutor&lt;/code&gt; 根据唯一标识找到对应的 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 然后 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 就会从 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 拿回完成的 &lt;code class=&quot;inline&quot;&gt;Poll::Ready(T)&lt;/code&gt;。完美。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Context&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;明白了 &lt;code class=&quot;inline&quot;&gt;Excutor&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; 之后，让我们回过头看看 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 的函数签名：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn poll(self: Pin&amp;lt;Self&amp;gt;, cx: &amp;amp;mut task::Context) -&amp;gt; Poll&amp;lt;Self::Output&amp;gt;;
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们看 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 的第二个参数: &lt;code class=&quot;inline&quot;&gt;task::Context&lt;/code&gt;:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub struct Context&amp;lt;&#39;a&amp;gt; { .. }

impl&amp;lt;&#39;a&amp;gt; Context&amp;lt;&#39;a&amp;gt; {
    pub fn new(waker: &amp;amp;&#39;a Waker, executor: &amp;amp;&#39;a mut Executor) -&amp;gt; Context&amp;lt;&#39;a&amp;gt;;
    /// Get the `Waker` associated with the current task.
    pub fn waker(&amp;amp;self) -&amp;gt; &amp;amp;Waker;
    /// Run an asynchronous computation to completion on the default executor.
    pub fn spawn(&amp;amp;mut self, f: impl Async&amp;lt;Output = ()&amp;gt; + &#39;static + Send);
    /// Get the default executor associated with this task.
    pub fn executor(&amp;amp;mut self) -&amp;gt; &amp;amp;mut BoxExecutor;
}
&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Context&lt;/code&gt; 的主要工作十分明了：&lt;/p&gt;&lt;p&gt;&lt;br&gt;-   提供 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; &lt;br&gt;-   提供默认 &lt;code class=&quot;inline&quot;&gt;Excutor&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;spawn()&lt;/code&gt; 是 &lt;code class=&quot;inline&quot;&gt;executor().spawn()&lt;/code&gt; 的捷径（顺带一些错误处理）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里出现了 &lt;code class=&quot;inline&quot;&gt;Waker&lt;/code&gt; 不是 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;Waker&lt;/code&gt; 又是一个这次标准库新加入的类型，里面装着 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; trait object:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub struct Waker {
    wake: &amp;amp;Wake
}

impl Waker {
    pub fn wake(&amp;amp;self) {
        self.wake.wake();
    }
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; 类型不在本篇 RFC 范围之内，而且展开了说篇幅会非常的长，有兴趣的话可以前去 RFC 阅读，或者看看 &lt;code class=&quot;inline&quot;&gt;@withoutboat&lt;/code&gt; 关于 &lt;code class=&quot;inline&quot;&gt;&lt;i&gt;borrow across yield point&lt;/i&gt;&lt;/code&gt; 的长篇系列，那里详细地解释了设计上遇到了什么难点，以及为什么一定要引入 &lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; 概念。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md&quot;&gt;RFC: 2349-pin&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://boats.gitlab.io/blog/post/2018-01-25-async-i-self-referential-structs/&quot;&gt;Async/Await I: Self-Referential Structs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;目前在这篇 RFC 中，我们只需要知道 Pin 是什么就足够了。简单来说，一般的类型自动实现 &lt;code class=&quot;inline&quot;&gt;Unpin&lt;/code&gt;，而有些特殊的的类型会反向实现 &lt;code class=&quot;inline&quot;&gt;!Unpin&lt;/code&gt;，这样特殊的类型在被装进 &lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; 之后就不能再移动了(immovable type)。异步函数返回类型也正是这种特殊类型。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; 是指针类型，提供比 &lt;code class=&quot;inline&quot;&gt;&amp;amp;mut T&lt;/code&gt; 更严格的规则：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;T: Unpin&amp;gt;&lt;/code&gt; 和普通 &lt;code class=&quot;inline&quot;&gt;&amp;amp;mut T&lt;/code&gt; 完全一样。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;T: !Unpin&amp;gt;&lt;/code&gt; 只提供 &lt;code class=&quot;inline&quot;&gt;Deref&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;，以防止 T 被移动 (mem::replace())。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们来明确一下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt;: &lt;code class=&quot;inline&quot;&gt;Unpin&lt;/code&gt; &lt;/li&gt;&lt;li&gt;async fn 返回的 &lt;code class=&quot;inline&quot;&gt;impl Async&lt;/code&gt;: &lt;code class=&quot;inline&quot;&gt;!Unpin&lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Box&amp;lt;Async&amp;gt;&lt;/code&gt;: &lt;code class=&quot;inline&quot;&gt;Unpin&lt;/code&gt; &lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;p&gt;这篇文章介绍了标准库中加入的 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 和任务类型，通过这些类型的加入，我们可以方便地定义自己的事件循环或者使用现成的库来驱动异步任务。文章并没有涵盖用于 &lt;code class=&quot;inline&quot;&gt;no_std&lt;/code&gt; 环境的类型和解决方案，有兴趣的读者需要自己去阅读一下 RFC。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下一篇文章可能会讲 &lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; 类型和关于 Rust &lt;code class=&quot;inline&quot;&gt;immovable type&lt;/code&gt; 的故事，但是这玩意讲起来比裹脚布还长，到时懒起来分分钟就跳票了。&lt;/p&gt;</description>
<author>Andy Lok</author>
<guid isPermaLink="false">2018-05-25-37298671</guid>
<pubDate>Fri, 25 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust - RFC 导读: async/await 特性（二）</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2018-05-25-37269342.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37269342&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b357cf4b2202c2f3e9edb6c3b6204680_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;由于本篇文章代码较多，如果知乎的排版伤害了你的眼睛，可以暂时移步到 &lt;a href=&quot;https://github.com/andylokandy/article/blob/master/Rust%20-%20RFC%20%E5%AF%BC%E8%AF%BB%20async%20%E7%89%B9%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89.md&quot;&gt;这里&lt;/a&gt;。&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;上一篇我们讲到了编译器对 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; 的特性支持，相应的，我们要让编译器知道 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 是什么，编译器才能生成匿名的 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 类型。为此，我们就有了第二份 RFC —— 将 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 加入标准库（准确来说是 &lt;code class=&quot;inline&quot;&gt;libcore&lt;/code&gt;）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/aturon/rfcs/blob/async-trait/text/0000-async.md&quot;&gt;RFC 2418 companion libs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;注意这篇 RFC 还在讨论阶段并未被 merge，因此最终方案可能会改变，目前已经可以看见讨论区提出了相较于 &lt;code class=&quot;inline&quot;&gt;arbitrary self type&lt;/code&gt;（&lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;self&amp;gt;&lt;/code&gt;） 更好的解决方案，这部分是最有可能发生变化的。&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Summary&lt;/h2&gt;&lt;p&gt;这篇文章将会深入 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; 的实现原理，如果读者只是希望使用现成的库和 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; 语法，仅看上一篇文章就已经足够了。而如果你希望开发使用异步实现的库，或者天生有着强烈的好奇心，那么这篇文章就是专门为你定做的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这篇 RFC 并不打算将整个 &lt;code class=&quot;inline&quot;&gt;futures-rs&lt;/code&gt; 移入标准库，相反极力精简，仅仅加入必要的最基础的构件，把剩余的功能留给社区的库来实现。就算如此，我们也将迎来帮数量众多的新朋友: &lt;code class=&quot;inline&quot;&gt;core::task::{Context, Poll, Wake, Waker, UnsafeWake, Executor, TaskObj, SpawnErrorKind, SpawnObjError}&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;core::ops::Async&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果加上另一篇 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md&quot;&gt;RFC: 2349-pin&lt;/a&gt;，那就还有 &lt;code class=&quot;inline&quot;&gt;core::marker::Unpin&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;core::mem::Pin&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们可以看到，新加入的东西真心不少，但是别担心，它们的存在都是必要而且符合直觉的，接下来我会逐个解释这些东西到底用来干什么的。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;另外，读者可能注意到，这篇 RFC 中并没有出现 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt;，这是因为这篇 RFC 写在上一篇 RFC 之后，在这期间社区讨论决定了并不引入 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 全部的功能(比如 &lt;code class=&quot;inline&quot;&gt;map()&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;and_then()&lt;/code&gt;)，而是只定义其中关键一部分 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;，剩余的功能依旧留给 &lt;code class=&quot;inline&quot;&gt;futures-rs&lt;/code&gt; 库来提供，所以这个被精简的 &lt;code class=&quot;inline&quot;&gt;trait&lt;/code&gt; 不能叫做 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt;，那就改名叫作了 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt;。也就是说，async 函数的返回值应该是 &lt;code class=&quot;inline&quot;&gt;impl Async&amp;lt;Output = T&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;让我们先从关键的 &lt;code class=&quot;inline&quot;&gt;Async trait&lt;/code&gt; 入手，下面是它的定义： &lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pub trait Async {
    type Output;
    /// Attempt to resolve the computation to a final value, registering
    /// the current task for wakeup if the value is not yet available.
    fn poll(self: Pin&amp;lt;Self&amp;gt;, cx: &amp;amp;mut task::Context) -&amp;gt; Poll&amp;lt;Self::Output&amp;gt;;
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 只定义了一个函数 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;，作用是尝试获取异步操作的结果， 熟悉使用 &lt;code class=&quot;inline&quot;&gt;futures-rs&lt;/code&gt; 的读者想必已经对它十分了解了。如果不是也没关系，我会从头解释一遍。我们先忽略传入参数，只看返回值，它返回的是 &lt;code class=&quot;inline&quot;&gt;Poll&lt;/code&gt; 类型：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pub enum Poll&amp;lt;T&amp;gt; {
    Ready(T),
    Pending,
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Poll&lt;/code&gt; 有两个 variance: &lt;code class=&quot;inline&quot;&gt;Ready(T)&lt;/code&gt; 表示异步操作已经完成并获得返回值, &lt;code class=&quot;inline&quot;&gt;Pendding&lt;/code&gt; 表示异步操作还在进行中，你过会儿再过来看看。&lt;code class=&quot;inline&quot;&gt;Poll&lt;/code&gt; 的概念很简单，就不多说了。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这就带来了一个问题，我们该什么时候调用 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 呢？它仅仅在完成之后才能给出有用的结果，万一如果返回的是 &lt;code class=&quot;inline&quot;&gt;Pending&lt;/code&gt;, 我们怎么知道什么时候需要再次 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 呢？又由谁来负责 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 呢？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;答案是我们需要一个 &lt;code class=&quot;inline&quot;&gt;event loop&lt;/code&gt;（比如线程池）来帮助我们完成这个调度(scheduling)工作。标准库并不会提供一个现成的 &lt;code class=&quot;inline&quot;&gt;event loop&lt;/code&gt;，但标准库提供了定义它们的 &lt;code class=&quot;inline&quot;&gt;trait&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;我们来看一个具体的例子，比如说我们正在打算从 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 接收数据，我们得到了一个 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt;，这时候 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 可能还没准备好，所以第一次 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 返回了 &lt;code class=&quot;inline&quot;&gt;Poll::Pending&lt;/code&gt;，这时我们必须把这个 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 交给一个 &lt;code class=&quot;inline&quot;&gt;event loop&lt;/code&gt; 保管（就比如说一个由 &lt;code class=&quot;inline&quot;&gt;futures-rs&lt;/code&gt; 库提供的线程池 &lt;code class=&quot;inline&quot;&gt;ThreadPool&lt;/code&gt;），以备过会 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 准备好了再回来 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;在这个例子里 &lt;code class=&quot;inline&quot;&gt;ThreadPool&lt;/code&gt; 实现了 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt;。我们来看看这个东西的定义：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pub trait Executor {
    fn spawn_obj(&amp;amp;mut self, task: TaskObj) -&amp;gt; Result&amp;lt;(), SpawnObjError&amp;gt;;
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里的 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 实际上是一个 &lt;code class=&quot;inline&quot;&gt;Box&amp;lt;Async&amp;lt;Output = ())&amp;gt;&amp;gt;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;spawn_obj()&lt;/code&gt; 用于给 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 安排工作，让 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 负责稍后的 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 工作。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里说个题外话，因为 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 使用了动态派发 （&lt;code class=&quot;inline&quot;&gt;trait object&lt;/code&gt;），所以目前这里的堆分配是必须的。然而我们还有另一套用于 &lt;code class=&quot;inline&quot;&gt;no_std&lt;/code&gt; 的 &lt;code class=&quot;inline&quot;&gt;unsafe&lt;/code&gt; 的解决方案可以避免堆分配，有兴趣的读者可以在原文拉到最后了解一下。在不久的将来，在 Rust 支持在栈上存储 &lt;code class=&quot;inline&quot;&gt;dynamic size type(DST)&lt;/code&gt; 的时候 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1909-unsized-rvalues.md&quot;&gt;[Merged] RFC 1909:unsized-rvalues&lt;/a&gt;，这里的 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 也会取消，取而代之的是栈上的 &lt;code class=&quot;inline&quot;&gt;Task&lt;/code&gt;，这也是现在取个这么难听名字的原因。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;解决了 who 的问题，那还有 when 问题。我们让 ThreadPool 来负责重新 poll() ，那到底什么时候 poll() 呢？只有 socket 知道自己什么时候准备好，所以 socket 需要在准备好的时候 “通知” ThreadPool 重新 poll()。这个操作叫做 wake （唤醒），这意味着，我们要给 socket 提供通知 ThreadPool 的方法 —— 让 socket 拿着 Arc&amp;lt;ThreadPool&amp;gt;。完美。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;为了让 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 能够唤醒 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt;，标准库提供了 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt;。&lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 只需握着 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt;，就能在准备好的时候调用 &lt;code class=&quot;inline&quot;&gt;wake()&lt;/code&gt;，通知 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 该 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;了。 下面是 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; 的定义：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pub trait Wake: Send + Sync {
    fn wake(&amp;amp;self);
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;但是实现 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; 的可以是 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 自己吗？不可以。因为一个 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 上可能托管着成百上千的 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt;，直接 &lt;code class=&quot;inline&quot;&gt;wake()&lt;/code&gt; 并不能告诉 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 究竟是哪个 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 需要 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;。因此 &lt;code class=&quot;inline&quot;&gt;Executor&lt;/code&gt; 会给每个 &lt;code class=&quot;inline&quot;&gt;TaskObj&lt;/code&gt; 提供一个唯一标识，然后把这个标识和自己的引用计数指针打包装在一起，弄一个类似 &lt;code class=&quot;inline&quot;&gt;WakeHandler&lt;/code&gt; 的玩意。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;struct WakeHandler {
    exec: Arc&amp;lt;ThreadPool&amp;gt;,
    id: u64,
}

impl Wake for WakeHandler { .. }&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;所以这里 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 在被第一次 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 的时候 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 就会记下这个 &lt;code class=&quot;inline&quot;&gt;WakeHandler&lt;/code&gt;（因为这里 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 的实际类型是 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 提供的），准备好后  &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt;  调用 &lt;code class=&quot;inline&quot;&gt;wake()&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;Excutor&lt;/code&gt; 根据唯一标识找到对应的 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 然后 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 就会从 &lt;code class=&quot;inline&quot;&gt;socket&lt;/code&gt; 拿回完成的 &lt;code class=&quot;inline&quot;&gt;Poll::Ready(T)&lt;/code&gt;。完美。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Context&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;明白了 &lt;code class=&quot;inline&quot;&gt;Excutor&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; 之后，让我们回过头看看 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 的函数签名：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fn poll(self: Pin&amp;lt;Self&amp;gt;, cx: &amp;amp;mut task::Context) -&amp;gt; Poll&amp;lt;Self::Output&amp;gt;;&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们看 &lt;code class=&quot;inline&quot;&gt;poll()&lt;/code&gt; 的第二个参数: &lt;code class=&quot;inline&quot;&gt;task::Context&lt;/code&gt;:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pub struct Context&amp;lt;&#39;a&amp;gt; { .. }

impl&amp;lt;&#39;a&amp;gt; Context&amp;lt;&#39;a&amp;gt; {
    pub fn new(waker: &amp;amp;&#39;a Waker, executor: &amp;amp;&#39;a mut Executor) -&amp;gt; Context&amp;lt;&#39;a&amp;gt;;
    /// Get the `Waker` associated with the current task.
    pub fn waker(&amp;amp;self) -&amp;gt; &amp;amp;Waker;
    /// Run an asynchronous computation to completion on the default executor.
    pub fn spawn(&amp;amp;mut self, f: impl Async&amp;lt;Output = ()&amp;gt; + &#39;static + Send);
    /// Get the default executor associated with this task.
    pub fn executor(&amp;amp;mut self) -&amp;gt; &amp;amp;mut BoxExecutor;
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Context&lt;/code&gt; 的主要工作十分明了：&lt;/p&gt;&lt;p&gt;&lt;br&gt;-   提供 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; &lt;br&gt;-   提供默认 &lt;code class=&quot;inline&quot;&gt;Excutor&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;spawn()&lt;/code&gt; 是 &lt;code class=&quot;inline&quot;&gt;executor().spawn()&lt;/code&gt; 的捷径（顺带一些错误处理）。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这里出现了 &lt;code class=&quot;inline&quot;&gt;Waker&lt;/code&gt; 不是 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;Waker&lt;/code&gt; 又是一个这次标准库新加入的类型，里面装着 &lt;code class=&quot;inline&quot;&gt;Wake&lt;/code&gt; trait object:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pub struct Waker {
    wake: &amp;amp;Wake
}

impl Waker {
    pub fn wake(&amp;amp;self) {
        self.wake.wake();
    }
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; 类型不在本篇 RFC 范围之内，而且展开了说篇幅会非常的长，有兴趣的话可以前去 RFC 阅读，或者看看 &lt;code class=&quot;inline&quot;&gt;@withoutboat&lt;/code&gt; 关于 &lt;code class=&quot;inline&quot;&gt;&lt;i&gt;borrow across yield point&lt;/i&gt;&lt;/code&gt; 的长篇系列，那里详细地解释了设计上遇到了什么难点，以及为什么一定要引入 &lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; 概念。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2349-pin.md&quot;&gt;RFC: 2349-pin&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://boats.gitlab.io/blog/post/2018-01-25-async-i-self-referential-structs/&quot;&gt;Async/Await I: Self-Referential Structs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;目前在这篇 RFC 中，我们只需要知道 Pin 是什么就足够了。简单来说，一般的类型自动实现 &lt;code class=&quot;inline&quot;&gt;Unpin&lt;/code&gt;，而有些特殊的的类型会反向实现 &lt;code class=&quot;inline&quot;&gt;!Unpin&lt;/code&gt;，这样特殊的类型在被装进 &lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; 之后就不能再移动了(immovable type)。异步函数返回类型也正是这种特殊类型。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; 是指针类型，提供比 &lt;code class=&quot;inline&quot;&gt;&amp;amp;mut T&lt;/code&gt; 更严格的规则：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;T: Unpin&amp;gt;&lt;/code&gt; 和普通 &lt;code class=&quot;inline&quot;&gt;&amp;amp;mut T&lt;/code&gt; 完全一样。&lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Pin&amp;lt;T: !Unpin&amp;gt;&lt;/code&gt; 只提供 &lt;code class=&quot;inline&quot;&gt;Deref&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;，以防止 T 被移动 (mem::replace())。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我们来明确一下:&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt;: &lt;code class=&quot;inline&quot;&gt;Unpin&lt;/code&gt; &lt;/li&gt;&lt;li&gt;async fn 返回的 &lt;code class=&quot;inline&quot;&gt;impl Async&lt;/code&gt;: &lt;code class=&quot;inline&quot;&gt;!Unpin&lt;/code&gt; &lt;/li&gt;&lt;li&gt;&lt;code class=&quot;inline&quot;&gt;Box&amp;lt;Async&amp;gt;&lt;/code&gt;: &lt;code class=&quot;inline&quot;&gt;Unpin&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;p&gt;这篇文章介绍了标准库中加入的 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt; 和任务类型，通过这些类型的加入，我们可以方便地定义自己的事件循环或者使用现成的库来驱动异步任务。文章并没有涵盖用于 &lt;code class=&quot;inline&quot;&gt;no_std&lt;/code&gt; 环境的类型和解决方案，有兴趣的读者需要自己去阅读一下 RFC。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下一篇文章可能会讲 &lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; 类型和关于 Rust &lt;code class=&quot;inline&quot;&gt;immovable type&lt;/code&gt; 的故事，但是这玩意讲起来比裹脚布还长，到时懒起来分分钟就跳票了。&lt;/p&gt;</description>
<author>Andy Lok</author>
<guid isPermaLink="false">2018-05-25-37269342</guid>
<pubDate>Fri, 25 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust - RFC 导读:  async/await 特性（一）</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2018-05-23-37209852.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37209852&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-26d18184098ed7b0ce2cfba667b957d9_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;在 2018 年五月份 Rust 迎来了 1.26 版本，一并带来不少让人眼前一亮的特性，比如 &lt;code class=&quot;inline&quot;&gt;impl trait&lt;/code&gt;，&lt;code class=&quot;inline&quot;&gt;match&lt;/code&gt; 自动绑定等等，这是 Rust Core team 和社区在有条不紊地履行着 Roadmap 2018 里的承诺，给 2018 epoch 打下基础。&lt;/p&gt;&lt;p&gt;根据 Roadmap，今年9月份前我们将迎来一个更重磅的特性，&lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt;。Core team 如期给出了两份 RFC，给 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; 特性画下个大饼。这篇文章旨在提供对这两份 RFC 的导读，让读者掌握 &lt;code class=&quot;inline&quot;&gt;async&lt;/code&gt; 特性的基本概念。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2394-async_await.md&quot;&gt;RFC 2394-async_await&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/aturon/rfcs/blob/async-trait/text/0000-async.md&quot;&gt;RFC 2418 companion libs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Summary&lt;/h2&gt;&lt;p&gt;在高性能网络服务领域，人们常用异步 IO 而不是阻塞 IO，这是因为异步 IO 更容易扩展从而获得巨大的并发能力，而 Rust 正在逐步涉足网络服务领域，因此能够提供简洁而强大的异步开发能力格外重要。&lt;/p&gt;&lt;p&gt;为此，Rust 社区已经进行了长时间的实验和反馈，尝试了众多的技术方法，社区最终采用了 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; ，因为它能够提供强大的抽象能力，而且简洁，容易学习，是目前的最优方案。&lt;/p&gt;&lt;p&gt;由于这次特性更新影响重大，涉及方面较广，文章将随 RFC 分为两部分，分别为语言特性和标准库两方面。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;语言特性&lt;/h2&gt;&lt;p&gt;本篇 RFC 的重点是为编译器增加四种新的类型：&lt;code class=&quot;inline&quot;&gt;async function&lt;/code&gt;（异步函数），&lt;code class=&quot;inline&quot;&gt;async closure&lt;/code&gt;（异步闭包）， &lt;code class=&quot;inline&quot;&gt;async block&lt;/code&gt;（异步代码块）和一个内建 macro &lt;code class=&quot;inline&quot;&gt;await!&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;异步函数&lt;/h2&gt;&lt;p&gt;函数开头加上 &lt;code class=&quot;inline&quot;&gt;async&lt;/code&gt; 关键词就成为了异步函数。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;async fn function(argument: &amp;amp;str) -&amp;gt; usize {
     // ...
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;异步函数的行为和普通函数不同，当异步函数被调用时，内部的代码逻辑不会立即执行，相反，异步函数会返回一个匿名的 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 类型，之后当我们 &lt;code class=&quot;inline&quot;&gt;poll&lt;/code&gt; 这个 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 的时候，函数内部的代码才会被执行并且执行到 &lt;code class=&quot;inline&quot;&gt;await&lt;/code&gt; 处停止（如果异步函数内部有的话），直到异步函数结尾。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;异步函数其实是某种 delayed computation （延迟运算）—— 在手动 &lt;code class=&quot;inline&quot;&gt;poll&lt;/code&gt; future 之前，异步函数内部一行代码也不会执行。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;看下面这个例子&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;async fn print_async() {
     println!(&quot;Hello from print_async&quot;)
}

fn main() {
     let future = print_async();
     println!(&quot;Hello from main&quot;);
     futures::block_on(future);
}&lt;/code&gt;&lt;p&gt;Print:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Hello from main
Hello from print_async&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;&quot;Hello from main&quot;&lt;/code&gt; 会在 &lt;code class=&quot;inline&quot;&gt;&quot;Hello from print_async&quot;&lt;/code&gt; 之前 print 出来。&lt;/p&gt;&lt;p&gt;异步函数的类型签名也与普通函数不同&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;async fn foo(args..) -&amp;gt; T&lt;/code&gt; 的实际类型签名是 &lt;code class=&quot;inline&quot;&gt;fn(args..) -&amp;gt; impl Future&amp;lt;Output = T&amp;gt;&lt;/code&gt;，其中的返回的类型是由编译器生成的匿名类型。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;异步闭包&lt;/h2&gt;&lt;p&gt;与函数类似，闭包也可以声明为异步闭包，只需在闭包前加上 &lt;code class=&quot;inline&quot;&gt;async&lt;/code&gt; 关键字。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;异步闭包的返回类型是 &lt;code class=&quot;inline&quot;&gt;impl Future&amp;lt;Output = T&amp;gt;&lt;/code&gt;，调用异步闭包时，内部代码也不会被执行而是返回一个 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt;，这与异步函数一模一样。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fn main() {
    let closure = async || {
         println(&quot;Hello from async closure.&quot;);
    };
    println!(&quot;Hello from main&quot;);
    let future = closure();
    println!(&quot;Hello from main again&quot;);
    futures::block_on(future);
}&lt;/code&gt;&lt;p&gt;Print:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;Hello from main
Hello from main again
Hello from async closure&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;异步块&lt;/h2&gt;&lt;p&gt;通过异步块可以便捷地创建一个 &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt;:&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;let my_future = async {
    println!(&quot;Hello from an async block&quot;);
};&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;code class=&quot;inline&quot;&gt;await!&lt;/code&gt; &lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;await!&lt;/code&gt; 是一个编译器内建的 macro ，用来暂停（pause） &lt;code class=&quot;inline&quot;&gt;Future&lt;/code&gt; 的执行流程，并且把执行流程交回给调用方 (&lt;code class=&quot;inline&quot;&gt;yield&lt;/code&gt;)。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;// future: impl Future&amp;lt;Output = usize&amp;gt;
let n = await!(future);&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;await!&lt;/code&gt; 展开的逻辑是这样的：&lt;br&gt;1. &lt;code class=&quot;inline&quot;&gt;poll&lt;/code&gt; 传入的 &lt;code class=&quot;inline&quot;&gt;future&lt;/code&gt;。&lt;br&gt;2. 如果 &lt;code class=&quot;inline&quot;&gt;poll&lt;/code&gt; 得到 &lt;code class=&quot;inline&quot;&gt;Poll::Pending&lt;/code&gt; 就将执行权交回给调用方。&lt;br&gt;3. 如果 &lt;code class=&quot;inline&quot;&gt;poll&lt;/code&gt; 得到 &lt;code class=&quot;inline&quot;&gt;Poll::Ready(T)&lt;/code&gt;，得到的值会被作为 &lt;code class=&quot;inline&quot;&gt;await!&lt;/code&gt; 表达式的值，从而继续执行 &lt;code class=&quot;inline&quot;&gt;future&lt;/code&gt; 剩下的逻辑代码。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;await!&lt;/code&gt; 只能用于异步函数，异步闭包或者异步块内部，否则将导致编译错误。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;大饼&lt;/h2&gt;&lt;p&gt;在引入了这些编译器特性之后，我们来看看异步代码可以长成什么样子。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;async fn fetch_rust_lang(client: hyper::Client) -&amp;gt; io::Result&amp;lt;String&amp;gt; {
    let response = await!(client.get(&quot;https://www.rust-lang.org&quot;))?;
    if !response.status().is_success() {
        return Err(io::Error::new(io::ErrorKind::Other, &quot;request failed&quot;))
    }
    let body = await!(response.body().concat())?;
    let string = String::from_utf8(body)?;
    Ok(string)
}&lt;/code&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt; 为 Rust 提供了强大的异步抽象，它不止可以助力网络并发，它在文件IO，多线程运算方面也可以大有作为。另外，&lt;code class=&quot;inline&quot;&gt;async&lt;/code&gt; 所涉及的 &lt;code class=&quot;inline&quot;&gt;Generator&lt;/code&gt; 还可用于简化 &lt;code class=&quot;inline&quot;&gt;Iterator&lt;/code&gt; 代码，让迭代器写法更加接近于 Python 等脚本语言，同时保持 Rust 引以为豪的 Zero-Cost-Abstration。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;下一篇将着力介绍为了迎接 &lt;code class=&quot;inline&quot;&gt;async/await&lt;/code&gt;，标准库要加入的新朋友 &lt;code class=&quot;inline&quot;&gt;Excutor&lt;/code&gt;, &lt;code class=&quot;inline&quot;&gt;Pin&lt;/code&gt; 和 &lt;code class=&quot;inline&quot;&gt;Async&lt;/code&gt;。&lt;/p&gt;</description>
<author>Andy Lok</author>
<guid isPermaLink="false">2018-05-23-37209852</guid>
<pubDate>Wed, 23 May 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust&#39;s 2018  roadmap</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2018-03-21-34724526.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34724526&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1e1e7123a9bf7a25aa7a892c840e9a1d_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每年Rust社区会聚在一起公布roadmap. 今年， 除了调查之外，我们还在12月份进行呼吁社区博客帖子，结果是在几周内大家撰写100篇博客文章。结束后，结果合并成　&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2314&quot;&gt;2018 roadmap RFC.&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Rust: 2018 发行版&lt;/h2&gt;&lt;p&gt;&lt;b&gt;今年我们将交付 Rust 2018, 　这将是从1.0之后的第一个主要的发行版。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;像往常一样，我们继续每六周发布。 但是我们将在今年三个版本（Rust 1.29 - 1.31）中选定一个作为&lt;b&gt;Rust 2018&lt;/b&gt;　这个新的Rust“发行版”将是整年功能稳定的顶点，同时这些特性将带有精美文档，工具和库。&lt;/p&gt;&lt;p&gt;发行版的意图是标记Rust进化中的主要里程碑，它收集了一些新的特征或习惯用法，整体上改变了使用Rust的经验。 隔几年，来评估我们以六周为周期的交付工作。 讲述RUST发展的更大的故事。 将整个我们整体的工作打造成闪光的产品发布。&lt;/p&gt;&lt;p&gt;我们期望每一个发行版将有一个核心专注主题。　考虑到Rust 1.0 作为　“Rust 2015” ，　那我们将有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Rust 2015年：稳定性&lt;/li&gt;&lt;li&gt;Rust 2018年：生产力&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;哪些会成为Rust 2018?&lt;/h2&gt;&lt;p&gt;Roadmap 并不是说确定那些会在 Rust 2018，但我们有好的想法，我们将会覆盖以下主要想法。&lt;/p&gt;&lt;h2&gt;文档改进&lt;/h2&gt;&lt;p&gt;Rust 2018 release 的目标之一，对于新增和改进的特性和惯用法提供高质量的文档。　《&lt;a href=&quot;https://doc.rust-lang.org/nightly/book/second-edition/&quot;&gt;The Rust Programming Language book&lt;/a&gt;》 在过去的18月里，已经完成了重写，一年内随着特性到达稳定的编译器支持，它也将更新。 &lt;a href=&quot;https://rustbyexample.com/&quot;&gt;Rust By Example&lt;/a&gt; 今年也将进行修改。还有许多第三方的书籍，如Programming Rust ，会将印刷出版。 &lt;/p&gt;&lt;h2&gt;语言改进&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.rust-lang.org/2017/03/02/lang-ergonomics.html&quot;&gt;2017’s ergonomics initiative&lt;/a&gt;  队列中最为优先的语言工作,　几乎所有被接受的RFCs今天都在nightly分支上提供，在接下来的几个月里，它将被打磨和稳定。这些中生产力的改进，会做作为“头条”在主干发布&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;Ownership 系统改进&lt;/b&gt;,（所有权系统改进），包括可以通用“&quot;non-lexical lifetimes””来实现更灵活的标记借用,改进的模式匹配集成.&lt;/li&gt;&lt;li&gt;&lt;b&gt;Trait 系统改进&lt;/b&gt;，包括期待已久的处理类型抽象的 impl Trait语法&lt;/li&gt;&lt;li&gt;&lt;b&gt;模块系统改进&lt;/b&gt;　聚焦在增加清晰性和降低复杂度&lt;/li&gt;&lt;li&gt;&lt;b&gt;Generators/async/await：在最优先的异步编程支持方面，工作在快速的进展。&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;另外，　我们期望有更多一些主要的特性在Rust 2018 发布，能稳定起来，包括&lt;b&gt;SIMD&lt;/b&gt;, &lt;b&gt;custom allocators&lt;/b&gt;  和 &lt;b&gt;macros&lt;/b&gt; 2.0&lt;br&gt;&lt;/p&gt;&lt;h2&gt;编译器改进&lt;/h2&gt;&lt;p&gt;Rust 1.24 增量再编译已经支持，在稳定版的编译器已是默认打开，该特性已经使重构建比新构建的速度快得多，但在这一年的时间里，我们预计fresh builds 和re-builds 都会得到持续的改进。 在Rust 2018, 编译器性不能成为生产效率的主要的障碍。&lt;br&gt;&lt;/p&gt;&lt;h2&gt;工具改进&lt;/h2&gt;&lt;p&gt;Rust 2018 将看到高质量的 RLS-1.0  (&lt;a href=&quot;https://github.com/rust-lang-nursery/rls&quot;&gt;Rust Language Server&lt;/a&gt;)　和rustfmt  我们将继续改进。&lt;/p&gt;&lt;p&gt;我们将继续改进 Cargo 稳定客户注册、公共依赖和改进Profile system. 我们也期望将来在&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2136&quot;&gt;Cargo build system integration&lt;/a&gt;, &lt;a href=&quot;https://github.com/rust-lang/cargo/issues/4959&quot;&gt;Xargo integration&lt;/a&gt;, 和 &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2318&quot;&gt;custom test frameworks&lt;/a&gt;　工作，&lt;/p&gt;&lt;p&gt;尽管目前还不清楚这其中有多少将在Rust 2018之前完成。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Library 改进&lt;/h2&gt;&lt;p&gt;在我们去年的工作之上 　我们将发布1.0的　&lt;a href=&quot;https://github.com/rust-lang-nursery/api-guidelines&quot;&gt;Rust API guidelines book&lt;/a&gt;, 继续推动重要的libraries 达到 1.0 状态， 通过改进cookbook 的努力来提高发现能力，并在特定领域的libraries 进行大量投入 - 我们将在下面看到。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;WebSite 改进&lt;/h2&gt;&lt;p&gt;作为Rust 2018的一部分，我们将彻底检修Rust 网站，使它对CTOs和工程师都很有用。在您的用例下，应该更容易找到信息来帮助评估Rust ，并保持最新的工具和生态系统的改进。&lt;/p&gt;&lt;h2&gt;四个目标领域&lt;/h2&gt;&lt;p&gt;Rust 2018 目标之一是演示在特定的领域使用Rust的生产力。　今年我们突出选了四个领域进行投入：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;网络服务&lt;/b&gt; Rust的可靠性和低的资源占用非常匹配网络服务和基础设施，特别在高伸缩领域。&lt;/li&gt;&lt;li&gt;&lt;b&gt;&lt;a href=&quot;https://internals.rust-lang.org/t/announcing-the-cli-working-group/6872&quot;&gt;Command-line apps&lt;/a&gt;&lt;/b&gt; (CLI).　Rust的可移植性、可靠性、工程效率 以及产生静态二进制文件，综合这些能力对编写CLI应用程序产生巨大影响。&lt;/li&gt;&lt;li&gt;&lt;b&gt;&lt;a href=&quot;https://internals.rust-lang.org/t/come-join-the-rust-and-webassembly-working-group/6845&quot;&gt;WebAssembly&lt;/a&gt;&lt;/b&gt;. 　“wasm” web 标准允许加载本地二进制到主流的浏览器，但是GC支持还要多年. 　这个领域非常符合Rust的定位，为JS程序员提供一个合适的切入点。&lt;/li&gt;&lt;li&gt;&lt;b&gt;&lt;a href=&quot;https://internals.rust-lang.org/t/announcing-the-embedded-devices-working-group/6839&quot;&gt;Embedded devices&lt;/a&gt;&lt;/b&gt;. Rust　有潜力使资源受限的设备编程更加高效和有趣!　　我们希望Rust在嵌入式编程今年达到一流的地位。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;今年每一个领域都有一个专门工作小组。这些工作组将以交叉的方式工作，与语言、工具、库和文档工作相结合。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;后续我不太关心就没译完。大家可以继续看原文　&lt;a href=&quot;https://blog.rust-lang.org/2018/03/12/roadmap.html&quot;&gt;英文原文&lt;/a&gt;&lt;/p&gt;</description>
<author>左文建</author>
<guid isPermaLink="false">2018-03-21-34724526</guid>
<pubDate>Wed, 21 Mar 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>[译] Rust - None Lexical Lifetimes (NLL) 使用指南</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2018-01-12-32884290.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32884290&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;title-image&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b7bdc8a3a010ad92012199af2750cc72_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;blockquote&gt;原文地址 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//santiagopastorino.com/how-to-use-rust-non-lexical-lifetimes-on-nightly/&quot;&gt;https://santiagopastorino.com/how-to-use-rust-non-lexical-lifetimes-on-nightly/&lt;/a&gt;&lt;br&gt;原文作者: Santiago Pastorino&lt;/blockquote&gt;&lt;p&gt;Niko Matsakis, Paul Faria 和我在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//internals.rust-lang.org/t/announcing-the-impl-period-sep-18-dec-17/5676&quot;&gt;impl period&lt;/a&gt; 期间致力于开发None Lexical Lifetimes (暂译为非词法作用域生命周期，下文统称为 NLL)。 代码目前已经合并到 master 分支，你现在可以在 nightly 中体验。&lt;/p&gt;&lt;p&gt;本文将通过几个例子简单直观地展现 NLL 的使用方法。这里我不会涉及 NLL 背后的设计逻辑，如果对设计细节感兴趣，我推荐你进一步阅读 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/rust-lang/rfcs/blob/master/text/2094-nll.md&quot;&gt;RFC&lt;/a&gt;，你想知道的都在里面了。我想你还可以尝试在 pull requests 贡献代码。&lt;/p&gt;&lt;p&gt;话不多说，我们直接上代码。&lt;/p&gt;&lt;p&gt;当然在这之前，你要先确保机器上安装了最新的 nightly 版本 —— 打开命令行运行 &lt;code class=&quot;inline&quot;&gt;rustup install nightly&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我们先看这个简单的例子，它在目前的作用域生命周期(scope based lifetimes)规则下不能编译。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#![allow(unused_variables)]

fn main() {
    let mut x = 22;

    let p = &amp;amp;mut x; // mutable borrow

    println!(&quot;{}&quot;, x); // later used
}
&lt;/code&gt;&lt;p&gt;这是因为 x 被可变借用，并且在作用域结束前再次被使用。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable
 --&amp;gt; src/main.rs:8:20
  |
6 |     let p = &amp;amp;mut x; // mutable borrow
  |                  - mutable borrow occurs here
7 | 
8 |     println!(&quot;{}&quot;, x); // later used
  |                    ^ immutable borrow occurs here
9 | }
  | - mutable borrow ends here

error: aborting due to previous error
&lt;/code&gt;&lt;p&gt;现在我们在开头加入 &lt;code class=&quot;inline&quot;&gt;#![feature(nll)]&lt;/code&gt; 代码开启 NLL 特性。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#![feature(nll)]
#![allow(unused_variables)]

fn main() {
    let mut x = 22;

    let p = &amp;amp;mut x;

    println!(&quot;{}&quot;, x);
}
&lt;/code&gt;&lt;p&gt;这段代码顺利编译，因为编译器知道 &lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt; 的可变借用并没有持续到作用域结尾，而是在 &lt;code class=&quot;inline&quot;&gt;x&lt;/code&gt; 被再次使用之前就结束了，所以这里不存在冲突。&lt;/p&gt;&lt;p&gt;我们在看一个稍微复杂些的例子。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;use std::collections::HashMap;

fn get_default(map: &amp;amp;mut HashMap, key: usize) -&amp;gt; &amp;amp;mut String {
    match map.get_mut(&amp;amp;key) {
        Some(value) =&amp;gt; value,
        None =&amp;gt; {
            map.insert(key, &quot;&quot;.to_string());
            map.get_mut(&amp;amp;key).unwrap()
        }
    }
}

fn main() {
    let map = &amp;amp;mut HashMap::new();
    map.insert(22, format!(&quot;Hello, world&quot;));
    map.insert(44, format!(&quot;Goodbye, world&quot;));
    assert_eq!(&amp;amp;*get_default(map, 22), &quot;Hello, world&quot;);
    assert_eq!(&amp;amp;*get_default(map, 66), &quot;&quot;);
}
&lt;/code&gt;&lt;p&gt;如果我们直接编译，这段代码也会报错，因为 &lt;code class=&quot;inline&quot;&gt;get_mut&lt;/code&gt; 在 &lt;code class=&quot;inline&quot;&gt;match&lt;/code&gt; 里借用 &lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt; 直到作用域结尾，这段作用域也覆盖到 &lt;code class=&quot;inline&quot;&gt;None&lt;/code&gt; 分支，而我们在 &lt;code class=&quot;inline&quot;&gt;None&lt;/code&gt; 分支里尝试再次可变借用 &lt;code class=&quot;inline&quot;&gt;map&lt;/code&gt;，编译器自然是十分拒绝的。&lt;/p&gt;&lt;p&gt;错误信息是这样的&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;error[E0499]: cannot borrow `*map` as mutable more than once at a time
  --&amp;gt; src/main.rs:7:13
   |
4  |     match map.get_mut(&amp;amp;key) {
   |           --- first mutable borrow occurs here
...
7  |             map.insert(key, &quot;&quot;.to_string());
   |             ^^^ second mutable borrow occurs here
...
11 | }
   | - first borrow ends here

error[E0499]: cannot borrow `*map` as mutable more than once at a time
  --&amp;gt; src/main.rs:8:13
   |
4  |     match map.get_mut(&amp;amp;key) {
   |           --- first mutable borrow occurs here
...
8  |             map.get_mut(&amp;amp;key).unwrap()
   |             ^^^ second mutable borrow occurs here
...
11 | }
   | - first borrow ends here

error: aborting due to 2 previous errors
&lt;/code&gt;&lt;p&gt;不开启 NLL 的情况下，我们有一种丑陋的技巧可以让它通过编译。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fn get_default(map: &amp;amp;mut HashMap, key: usize) -&amp;gt; &amp;amp;mut String {
    match map.get_mut(&amp;amp;key) {
        Some(value) =&amp;gt; return value,
        None =&amp;gt; {
        }
    }
    
    map.insert(key, &quot;&quot;.to_string());
    map.get_mut(&amp;amp;key).unwrap()
}
&lt;/code&gt;&lt;p&gt;这段代码虽然能编译，代价是我们必须使用这种令人难受的写法。&lt;/p&gt;&lt;p&gt;如果我们在原先的例子中加入 &lt;code class=&quot;inline&quot;&gt;#![feature(nll)]&lt;/code&gt; 开启 NLL ...&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#![feature(nll)]

use std::collections::HashMap;

fn get_default(map: &amp;amp;mut HashMap, key: usize) -&amp;gt; &amp;amp;mut String {
    match map.get_mut(&amp;amp;key) {
        Some(value) =&amp;gt; value,
        None =&amp;gt; {
            map.insert(key, &quot;&quot;.to_string());
            map.get_mut(&amp;amp;key).unwrap()
        }
    }
}

fn main() {
    let map = &amp;amp;mut HashMap::new();
    map.insert(22, format!(&quot;Hello, world&quot;));
    map.insert(44, format!(&quot;Goodbye, world&quot;));
    assert_eq!(&amp;amp;*get_default(map, 22), &quot;Hello, world&quot;);
    assert_eq!(&amp;amp;*get_default(map, 66), &quot;&quot;);
}
&lt;/code&gt;&lt;p&gt;这段代码完美通过编译，并且再也不用写那种令人智熄的代码。&lt;/p&gt;&lt;p&gt;另一个有趣的东西是用来展示借用错误的叫做 &lt;code class=&quot;inline&quot;&gt;three point error&lt;/code&gt; 的机制。目前为了开启它你需要显式地给编译器传入 &lt;code class=&quot;inline&quot;&gt;-Znll-dump-cause&lt;/code&gt; 参数。&lt;/p&gt;&lt;p&gt;先看这个在 NLL 下产生借用错误的例子。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;#![feature(nll)]
#![allow(unused_assignments)]

fn main() {
    let mut x = 22;

    let p = &amp;amp;x;

    x = 33;
    
    println!(&quot;{}&quot;, p);
}
&lt;/code&gt;&lt;p&gt;编译时传入 &lt;code class=&quot;inline&quot;&gt;nll-dump-cause&lt;/code&gt;，three point errors 会产生下面这样的的错误信息&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;$ rustc -Znll-dump-cause main.rs
error[E0506]: cannot assign to `x` because it is borrowed
  --&amp;gt; src/main.rs:9:5
   |
7  |     let p = &amp;amp;x;
   |             -- borrow of `x` occurs here
8  | 
9  |     x = 33;
   |     ^^^^^^ assignment to borrowed `x` occurs here
10 |     
11 |     println!(&quot;{}&quot;, p);
   |                    - borrow later used here

error: aborting due to previous error
&lt;/code&gt;&lt;p&gt;错误信息指出了起始借用，借用赋值和使用借用的位置，这应该可以给你提供对于问题清晰的思路。&lt;/p&gt;&lt;p&gt;这个机制目前还有性能上的问题，因此我们暂时需要自己手动开启。我们打算在解决性能问题后就将它设为默认。我和 Niko 已经着手，请拭目以待 :)。&lt;/p&gt;&lt;p&gt;我和你们一样非常兴奋于 NLL 最终落地，去尝试使用 NLL 写些代码，然后反馈你遇到的 bug 吧。虽然 NLL 已知存在一些问题需要修复，但是我们知道这都会慢慢完善起来的。&lt;/p&gt;&lt;p&gt;最后，我想说些无关紧要的话，我想分享一下我在 impl period 中的参与这个项目的体验。&lt;/p&gt;&lt;p&gt;首先，我从未想过我竟然能够有机会直接与 Niko 共事，更别说这还是我的第一个 Rust 项目。&lt;/p&gt;&lt;p&gt;Niko 是个令人敬仰的专家 (professional)，更重要的是他非常友好，容易亲近。我们在 Gitter 上交谈了很久，打过 call，然后我们还一起在 Rust Belt Rust 工作过 3 天。&lt;/p&gt;&lt;p&gt;我还与其他开发者花了不少时间讨论想法，比如说 Paul, 我非常感谢他的支持。&lt;/p&gt;</description>
<author>Andy Lok</author>
<guid isPermaLink="false">2018-01-12-32884290</guid>
<pubDate>Fri, 12 Jan 2018 00:00:00 +0800</pubDate>
</item>
<item>
<title>为什么我喜欢Rust</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2017-09-05-29079046.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29079046&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天写了一个回答：&lt;a href=&quot;https://www.zhihu.com/question/64563945/answer/225704730&quot;&gt;F001：为什么要使用TypeScript？有哪些情景请简单介绍一下，或者来个例子?&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我觉得这个回答也可以用来解释，为什么我喜欢Rust编程语言。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;我感觉现在很多程序员并没有彻底接受这样的一个思想：产品设计既需要考虑如何方便好用，也需要考虑如何防止误用。大部分人过于强调方便好用的这一面，而忽略了防止误用的令一面。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;不论是设计一个函数、类、框架、还是语言，都不仅要想到用户正常使用的时候是怎样的，还要想到哪些使用方式是有问题的，应该如何设计避免这些可能的误用。哪怕是枪械，也还要加个保险栓呢。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;这个思想，在绝大部分从业人员的大脑中都是薄弱的，哪怕是C/C++的标准库，都存在很多让人极易用错很难用对的设计，在很多编码规范中都要禁止使用这些功能，更不用说平均水平更低的普通开发者，能写出什么稀奇古怪的代码都不奇怪。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;作为一名源代码静态检查工具的开发者(Coverity)，我见过太多太多奇葩的C/C++用例，但是很遗憾的是编译器并没有阻止它们。Coverity的误报率和漏报率在行业内都算顶尖的，但是对某些问题，我们也无法保证百分百能检查出来。在C/C++里面，有些类别的错误，是没办法被“完整无遗漏”地检查出来的，这是C/C++的本质复杂性决定的，这个任务就是 mission impossible，我们能做的是尽最大可能覆盖尽可能多的用例。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;Rust能够“保证”内存安全、保证线程安全，这是一个非常重要的能力，这不是因为Rust的静态检查用了什么特别的算法技术，而是因为他们作弊了，直接简化了被研究对象。从静态检查器的实现的角度来说，Rust比Coverity简单得多，但效果要更好。C/C++里面很多需要费了老劲检查的问题，在Rust中根本不存在。不存在的问题，当然不需要寻找解决方案。当然，这就是Rust设计组牛逼的地方。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;</description>
<author>F001</author>
<guid isPermaLink="false">2017-09-05-29079046</guid>
<pubDate>Tue, 05 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>高阶类型 Higher Kinded Type</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2017-09-03-29021140.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29021140&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近，又有一份重量级的RFC（&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1598&quot;&gt;https://github.com/rust-lang/rfcs/pull/1598&lt;/a&gt;）被接受。它有多个名字，既可以叫 Generic associated type，也可以叫 associated type constructor，还可以叫 higher kinded type。这就是传说中的“高阶类型”。这个功能一直是学院派开发者一直期望的功能，是类型系统重要的一块拼图。&lt;/p&gt;&lt;p&gt;笔者在这方面经验很少，本文只能做一个简单介绍，当作是写给自己的学习总结。欢迎各位老司机做深入探讨。写完这篇文章，感觉对这个问题的理解更清晰了一些。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;什么是高阶&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们知道，在强类型编程语言中，每一个表达式都有类型。有些类型，在这门语言中是内置的、基本的，我们把它们叫做“基础”类型。比如Rust里面的 i32 bool char 等等。还有一些类型，是通过其它类型一起组合出来的，比如函数，&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn double(arg: i32) -&amp;gt; i32 {
    arg * 2
}&lt;/code&gt;&lt;p&gt;这个函数类型指的是，接受一个 i32 类型参数，生成一个 i32 类型返回值。它们的类型都是可以列出来的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;expression    |   type
------------------------
true          |   bool
1             |   i32
double        |   i32 -&amp;gt; i32
double(2)     |   i32&lt;/code&gt;&lt;p&gt;如果一个函数，可以接受函数作为参数或者返回值，那么它就是所谓的高阶函数(higher ordered function)。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn twice(f: fn(i32)-&amp;gt;i32) -&amp;gt; Box&amp;lt;Fn(i32)-&amp;gt;i32&amp;gt;
{
    Box::new(move |a| f(f(a)))
}

fn double(arg: i32) -&amp;gt; i32 {
    arg * 2
}

fn main() {
    let g = twice(double);
    println!(&quot;{}&quot;, g(2));
}&lt;/code&gt;&lt;p&gt;上例中，这个 twice 函数，就是高阶函数，它的类型为 (i32-&amp;gt;i32) -&amp;gt; (i32-&amp;gt;i32)。&lt;/p&gt;&lt;p&gt;还有一些更复杂的类型，比如 Vec&amp;lt;i32&amp;gt; 比上面的这些类型更复杂。因为 Vec 本身不是一个合法类型，它必须接受一个类型参数 i32 才能成为一个真正的类型 Vec&amp;lt;i32&amp;gt;。我们可以把 Vec 视为针对类型的“函数”，称作“类型构造器”，给它输入一个类型，它会返回一个类型出来。我们定义一个概念“阶(kind)” 来描述这种现象。比如最基本的类型 i32 bool ，它们的kind就是 type。而 Vec 的kind就是 type -&amp;gt; type。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;expression |  kind
-------------------
i32        |  type
i32 -&amp;gt; i32 |  type
Vec&amp;lt;i32&amp;gt;   |  type
Vec        |  type -&amp;gt; type&lt;/code&gt;&lt;p&gt;类似的，假如我们有一个类型构造器，它本身可以接受类型构造器作为参数，那它就是“高阶类型”。比如，我们要设计一个容器类型，它里面装的一组 i32 整数，但是我们把内部具体实现方式（可以用 Vec 或者 List）开放出来作为参数由用户指定，伪代码类似这样：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// 类似 scala 的伪代码
struct Collection&amp;lt;C&amp;lt;_&amp;gt;&amp;gt; {
    data: C&amp;lt;i32&amp;gt;
}&lt;/code&gt;&lt;p&gt;使用的时候，我们可以这样指定泛型参数 Collection&amp;lt;Vec&amp;gt; Collection&amp;lt;LinkedList&amp;gt;，那么这个 Collection 就是所谓的“高阶类型”。&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;expression          |  kind
-------------------------------------------
Vec&amp;lt;i32&amp;gt;            |  type
Vec                 |  type -&amp;gt; type
Collection          |  (type-&amp;gt;type) -&amp;gt; type
Collection&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;  |  type -&amp;gt; type&lt;/code&gt;&lt;p&gt;在Rust里面，有个特殊的地方是，泛型参数被分成了两类（两种基本的 kind），分别是 type 以及 lifetime。比如，我们最常见的引用类型，它就是类型构造器，且有生命周期泛型参数：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;expression     | kind
-----------------------
&amp;amp;&#39;a i32        | type
&amp;amp;              | (lifetime, type) -&amp;gt; type&lt;/code&gt;&lt;h2&gt;&lt;b&gt;高阶生命周期&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;实际上，现在的Rust已经支持了某种意义上的“高阶类型”，那就是所谓的“高阶生命周期约束”。参考 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/hrtb.html&quot;&gt;nomicon&lt;/a&gt;。它的语法如下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;for&amp;lt;&#39;a&amp;gt; F: Fn(&amp;amp;&#39;a T) -&amp;gt; &amp;amp;&#39;a T&lt;/code&gt;&lt;p&gt;它代表的意思是，对于任意 &#39;a，F 满足 Fn(&amp;amp;&#39;a T) -&amp;gt; &amp;amp;&#39;a T。比如说，标准库中，就有很多地方用到了这个：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Iterator {
    fn filter&amp;lt;P&amp;gt;(self, predicate: P) -&amp;gt; Filter&amp;lt;Self, P&amp;gt;
        where
            P: FnMut(&amp;amp;Self::Item) -&amp;gt; bool
}&lt;/code&gt;&lt;p&gt;这里的泛型参数 P，就用到了高阶生命周期，源码中的写法是省略写法，如果要写完整，它实际上意思是这样：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;where P: for&amp;lt;&#39;a&amp;gt; FnMut(&amp;amp;&#39;a Self::Item) -&amp;gt; bool&lt;/code&gt;&lt;p&gt;但是这个语法目前只支持生命周期泛型参数，不能用于普通类型参数。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;其它语言中的hkt&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这一部分来自于 niko 的博客，本人完全没有把握是否完整理解了 niko 的文章，欢迎各位提意见。&lt;/p&gt;&lt;p&gt;一个直观的 hkt 设计方案，就是直接为这个功能设计一种高阶类型的语法。举个例子，假如我们想设计一个通用函数，它能把一个容器中的整数类型转换为浮点数类型，容器本身是泛型的，可以是 Vec 或者 LinkedList，可以这么设计:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// 假设一种表示高阶类型的语法，类似 scala
fn floatify_hkt&amp;lt;I&amp;lt;_&amp;gt;&amp;gt;(ints: &amp;amp;I&amp;lt;i32&amp;gt;) -&amp;gt; I&amp;lt;f32&amp;gt;
//              ^^^^ the notation `I&amp;lt;_&amp;gt;` signals that `I` is
//                   not a complete type&lt;/code&gt;&lt;p&gt;这个例子以及解释是从 Nicholas D. Matsakis 的博客搬运过来的。在这个例子中，I 是一个泛型参数，它是一个类型构造器。假如 I 被实例化为 Vec，那么这个函数的类型就被实例化成了 Vec&amp;lt;i32&amp;gt; -&amp;gt; Vec&amp;lt;f32&amp;gt;，假如 I 被实例化为 LinkedList，那么这个函数的类型就被实例化成了 LinkedList&amp;lt;i32&amp;gt; -&amp;gt; LinkedList&amp;lt;f32&amp;gt;。但是这个设计有许多问题，下面逐一分析。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;高阶trait约束&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Rust泛型的类型检查，是在泛型函数、类型定义的时候当场检查的，而不是等到实例化的时候才检查。所以，对于上面这个泛型函数，我们一定需要对它指定合理的约束条件，否则类型 I&amp;lt;i32&amp;gt; 什么都干不了。&lt;/p&gt;&lt;p&gt;假设我们定义下面这样的一个 trait，来对 Vec 和 LinkedList 做一个统一抽象：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Collection&amp;lt;Item&amp;gt; {
    fn empty() -&amp;gt; Self;
    fn add(&amp;amp;mut self, value: Item);
    fn iterate&amp;lt;&#39;iter&amp;gt;(&amp;amp;&#39;iter self) -&amp;gt; Self::Iter&amp;lt;&#39;iter&amp;gt;;
    type Iter: Iterable&amp;lt;Item&amp;gt;;
}&lt;/code&gt;&lt;p&gt;然后，对上面那个泛型函数添加高阶类型约束条件：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn floatify_hkt&amp;lt;I&amp;lt;_&amp;gt;&amp;gt;(ints: &amp;amp;I&amp;lt;i32&amp;gt;) -&amp;gt; I&amp;lt;f32&amp;gt;
    where for&amp;lt;T&amp;gt; I&amp;lt;T&amp;gt;: Collection&amp;lt;T&amp;gt;&lt;/code&gt;&lt;p&gt;看起来这个 higher kinded trait bounds 的设计很合理。但是，我们注意到 Haskell 中是不存在 higher kinded trait bounds 这种东西的，它一定是因为某种原因而没有这样设计。所以 Haskell 里面只能这么写，把各种可能性枚举出来：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn floatify_hkt&amp;lt;I&amp;lt;_&amp;gt;&amp;gt;(ints: &amp;amp;I&amp;lt;i32&amp;gt;) -&amp;gt; I&amp;lt;f32&amp;gt;
    where I&amp;lt;i32&amp;gt;: Collection&amp;lt;i32&amp;gt;,
          I&amp;lt;f32&amp;gt;: Collection&amp;lt;f32&amp;gt;&lt;/code&gt;&lt;p&gt;如果只能用这样的写法呢，是会有问题的。某些情况下，会造成“抽象泄漏”。比如说，像下面这样一个函数：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn process&amp;lt;I&amp;lt;_&amp;gt;&amp;gt;(inputs: &amp;amp;I&amp;lt;Input&amp;gt;) -&amp;gt; I&amp;lt;Output&amp;gt;
    where I&amp;lt;Input&amp;gt;: Collection&amp;lt;Input&amp;gt;, I&amp;lt;Output&amp;gt;: Collection&amp;lt;Output&amp;gt;,
{
    struct MyType { ... }

    ...
}&lt;/code&gt;&lt;p&gt;如果这个函数内部定义了一个类型，这个函数的输出类型是 I&amp;lt;MyType&amp;gt;。那我们的这个泛型约束就很难写出来，除非把 MyType 定义到这个函数外边。本来我们希望封装到内部的类型，被迫暴露出去了，这就是抽象泄漏。&lt;/p&gt;&lt;p&gt;对 Haskell 来说，这好像是一个比较常见的问题。随手搜索了一下，看起来 Haskell 的解决方案是使用 &lt;a href=&quot;https://stackoverflow.com/questions/25422342/arbitrary-class-constraints-when-implementing-type-classes-in-haskell&quot;&gt;TypeFamily&lt;/a&gt;。这也是Rust设计组准备采用的方案。&lt;/p&gt;&lt;p&gt;在 Scala 中，如何表达任意的高阶类型约束不清楚，希望有网友能告知。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;高阶Self类型&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在前面，我们定义了一个trait Collection&amp;lt;T&amp;gt;，它的成员类型是 T。因此我们可以对不同的容器写这样的 impl：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;impl&amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; for Vec&amp;lt;T&amp;gt; {}
//                        ^^ this is a type&lt;/code&gt;&lt;p&gt;在这个impl块中，我们针对的是 Vec&amp;lt;T&amp;gt; 来实现的，它的kind是 type。如果我们要支持高阶类型，那么我们应该支持针对kind为 type-&amp;gt;type 的类型impl。我们现在更进一步，如果我们想定义一个高阶trait，怎么办？意思是，impl 的时候 for 后面的那个目标如果是“类型构造器”的话，是什么情况。假设我们这么设计：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait HkCollection for Self&amp;lt;_&amp;gt; {
//    ^^               ^^^^^^^ declare that `Self` is a type constructor
//    stands for &quot;higher-kinded&quot;

    fn empty&amp;lt;T&amp;gt;() -&amp;gt; Self&amp;lt;T&amp;gt;;
    fn add&amp;lt;T&amp;gt;(self: &amp;amp;mut Self&amp;lt;T&amp;gt;, value: T);
    //    ^^^ the `T` effectively moved from the trait to the methods
    ...
}

impl HkCollection for Vec&amp;lt;_&amp;gt; {
//                    ^^ this is a type constructor
    fn empty&amp;lt;T&amp;gt;() -&amp;gt; Vec&amp;lt;T&amp;gt; {
        Vec::new()
    }
    ...
}&lt;/code&gt;&lt;p&gt;如果有了这样的东西，那么我们可以针对任何一个类型构造器 I，写这样的约束条件 where I: HkCollection，而不需要写 where for&amp;lt;T&amp;gt; I&amp;lt;T&amp;gt;: Collection&amp;lt;T&amp;gt;，因为我们的 HkCollection 是作用到类型构造器上的。&lt;/p&gt;&lt;p&gt;这个设计看起来很不错，但它有非常巨大的缺陷。比如，它无法针对 BitSet 这样的容器 impl。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;impl HkCollection for BitSet {}
//                    ^^ not a type constructor&lt;/code&gt;&lt;p&gt;另外一个问题是，有些容器，它对内部元素的类型是有约束条件的。比如 HashSet&amp;lt;T&amp;gt;，它要求 T: Hash 条件。在上面这个设计中，像 Self&amp;lt;_&amp;gt; 这样的设计，实际上没有办法约束 _ 应该满足什么条件：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait HkCollection for HashSet&amp;lt;_&amp;gt;
//                     ^^^^^^^ how can we restrict `_` to `Hash` types?&lt;/code&gt;&lt;p&gt;Haskell 的 HKT 似乎是可以应用到任意类型上的，无法指定约束条件。但是在Rust里面，约束条件无处不在，我们如果选择 Foo&amp;lt;_&amp;gt; 这样的设计，那么一定要想个办法来写清楚 _ 的约束条件。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;类型推断&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;注意到前面我们说过的，Rust的一个特殊之处在于，它的泛型参数有两种 kind，分别是 type 和 lifetime。假如我们有这样的一个类型：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct ListIter&amp;lt;&#39;iter, T&amp;gt; { ... }&lt;/code&gt;&lt;p&gt;那么，一个完整的 ListIter&amp;lt;&#39;a, T&amp;gt; 它的 kind 是 type，而 ListIter 它的 kind 可以看作 (lifetime, type)-&amp;gt;type。如果我们定义一个类型 type I&amp;lt;&#39;_&amp;gt; = ListIter&amp;lt;&#39;_, i32&amp;gt;，那么 I 的 kind 就是 lifetime-&amp;gt;type。高阶类型内部还可以嵌套，比如 G&amp;lt;_&amp;lt;_&amp;gt;&amp;gt;，那么这个 G 的 kind 就是 (type-&amp;gt;type)-&amp;gt;type。这种设计可以让你把“类型”当成“函数”来看待，有些类型本身接受类型参数，然后生成新的类型。但是，它还有个缺陷是，影响了类型推断 type inference。我们来看这个例子：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn floatify_hkt&amp;lt;I&amp;lt;_&amp;gt;&amp;gt;(ints: &amp;amp;I&amp;lt;i32&amp;gt;) -&amp;gt; I&amp;lt;f32&amp;gt;&lt;/code&gt;&lt;p&gt;这里的类型参数 I 的 kind 是 type-&amp;gt;type。这个函数的目的是，把一个容器内部的元素从 i32 转成 f32（Vec&amp;lt;i32&amp;gt; -&amp;gt; Vec&amp;lt;f32&amp;gt; 或者 LinkedList&amp;lt;i32&amp;gt; -&amp;gt; LinkedList&amp;lt;f32&amp;gt;，而不是 Vec&amp;lt;i32&amp;gt; -&amp;gt; LinkedList&amp;lt;f32&amp;gt;）。那么，现在这个类型推断就会出问题了，即便我们已经知道了具体的实参类型和返回值类型，我们还是解不出来这个 I 是什么。&lt;/p&gt;&lt;p&gt;这个问题实际上是这样的，I 实际上是一个“函数”，它输入一个 type，输出一个 type。现在我们可以从实参类型，得到它的其中一个输入以及对应的输出 I&amp;lt;i32&amp;gt; == Vec&amp;lt;i32&amp;gt;。我们还可以从返回类型，得到它的另外一个输入以及对应的输出 I&amp;lt;f32&amp;gt; == Vec&amp;lt;f32&amp;gt;。请问现在这个 I 是什么。这个问题类似于：假设 f(1) == 2 且 f(2) == 3，求函数 f 是什么。这个问题没有“唯一”解。当然，如果我们假设 f 一定是一阶函数，那么我们可以求出来 f(x) = x + 1，但是没有这个条件的情况下就难说了。&lt;/p&gt;&lt;p&gt;Haskell 是没有这个问题的，这是因为 Haskell 限制了泛型参数的应用顺序，即所谓的 Currying。在Rust中没有 Currying，这意味着 Vec&amp;lt;_&amp;gt; 的kind 是 type-&amp;gt;type，Result&amp;lt;_, i32&amp;gt; 的kind是 type-&amp;gt;type，Result&amp;lt;i32, _&amp;gt; 的kind也是 type-&amp;gt;type。所以，假设我们有下面这样一个方程求解：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;?1&amp;lt;?2&amp;gt; = Result&amp;lt;i32, u32&amp;gt;&lt;/code&gt;&lt;p&gt;那么 ?1 = Result&amp;lt;i32, _&amp;gt;, ?2 = u32 或者 ?1 = Result&amp;lt;_, u32&amp;gt;, ?2 = i32，都是这个方程的解。&lt;/p&gt;&lt;p&gt;Rust是不能采用Currying的设计的。第一个原因是它有两种基本的 kind。比如说我们有个类型 Iterable&amp;lt;&#39;a, T&amp;gt;，按Haskell的观点，它的 kind 可以写成 lifetime -&amp;gt; type -&amp;gt; type（实际上它还要求 T: &#39;a，这个就更复杂了先忽略）。我们希望给它一个指定的 T，那么它的kind就会变成 lifetime -&amp;gt; type。但是Currying是不允许这样的，参数是按顺序的，你必须先指定一个固定的lifetime，让它的kind变成 type-&amp;gt;type。&lt;/p&gt;&lt;p&gt;Rust不采用Currying的第二个原因是，在实际中有些类型不是按顺序应用泛型参数的。比如我们的 HashMap 类型，它有三个泛型参数：pub struct HashMap&amp;lt;K, V, S = RandomState&amp;gt;，我们可能希望有一个类型构造器是这样的 M = HashMap&amp;lt;_, _, S&amp;gt;，但是用 Currying 是得不到的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;ATC&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;前面讲了很多为什么不在Rust中直接支持HKT的理由。接下来我们回到正题，说一说这个RFC究竟是一个什么样的提案。从这个提案的名字上，我们就可以看出一点端倪，它叫做 generic associated types (泛型关联类型)，或者叫做 associated type constructors (关联类型构造器)。它的实质就是，允许trait里面的“关联类型”成为“类型构造器”。比如说：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Iterable {
    type Item&amp;lt;&#39;a&amp;gt;; // 注意它携带泛型参数
    // Item 的 kind 是 lifetime -&amp;gt; type
}

trait Foo {
    type Bar&amp;lt;T&amp;gt;;  // 泛型参数可以是生命周期，可以是类型
    // Bar 的 kind 是 type -&amp;gt; type
}&lt;/code&gt;&lt;p&gt;语法上非常简单，就是这么一个小小的扩展。我们来看看在这个功能基础上，怎么设计本文前面的那个 floatify 函数。首先我们当然需要一个 trait，来统一抽象我们的容器类型：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Collection&amp;lt;T&amp;gt; {
    fn empty() -&amp;gt; Self;
    fn add(&amp;amp;mut self, value: T);
    fn iterate(&amp;amp;self) -&amp;gt; Self::Iter;
    type Iter: Iterator&amp;lt;Item=T&amp;gt;;
}&lt;/code&gt;&lt;p&gt;假设我们有一个具体容器，名字叫做 List&amp;lt;T&amp;gt;，我们针对这个类型，实现这个 trait：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;impl&amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; for List&amp;lt;T&amp;gt; {
    fn empty() -&amp;gt; List&amp;lt;T&amp;gt; {
        List::new()
    }

    fn add(&amp;amp;mut self, value: T) {
        self.prepend(value);
    }

    fn iterate&amp;lt;&#39;iter&amp;gt;(&amp;amp;&#39;iter self) -&amp;gt; ListIter&amp;lt;&#39;iter, T&amp;gt; {
        self.iter()
    }

    type Iter = ListIter&amp;lt;&#39;iter, T&amp;gt;;
    //                   ^^^^^ oh, wait, this is not in scope!
}&lt;/code&gt;&lt;p&gt;从这里我们看到了问题所在，在写最后的关联类型的时候，我们发现，这个生命周期参数没法写。这时候，就该ATC这个功能出场了。我们可以让这个关联类型不是一个具体类型，而是一个“类型构造器”，它的 kind 为 lifetime-&amp;gt;type，这样我们可以让它在各种场合下，针对不同的生命周期，生成合适的类型。修改 trait 的设计如下：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Collection&amp;lt;T&amp;gt; {
    // as before
    fn empty() -&amp;gt; Self;
    fn add(&amp;amp;mut self, value: T);

    // Here, we use associated type constructors:
    fn iterate&amp;lt;&#39;iter&amp;gt;(&amp;amp;&#39;iter self) -&amp;gt; Self::Iter&amp;lt;&#39;iter&amp;gt;;
    type Iter&amp;lt;&#39;iter&amp;gt;: Iterator&amp;lt;Item=T&amp;gt;;
}&lt;/code&gt;&lt;p&gt;注意这个语法，有点容易混淆，这个关联类型 Iter 在声明的时候有个参数，就代表它是“类型构造器”，在 iterator 方法返回的时候，我们要给 Iter 一个合适的参数，它才能生成具体的类型。我们对具体类型来impl这个trait：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;use std::slice;
impl&amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; for Vec&amp;lt;T&amp;gt; {
    fn empty() -&amp;gt; Self { vec![] }
    fn add(&amp;amp;mut self, value: T) { self.push(value); }
    fn iterate&amp;lt;&#39;iter&amp;gt;(&amp;amp;&#39;iter self) -&amp;gt; slice::Iter&amp;lt;&#39;self, T&amp;gt; { self.iter() }
    type Iter&amp;lt;&#39;iter&amp;gt; = slice::Iter&amp;lt;&#39;iter, T&amp;gt;;
}&lt;/code&gt;&lt;p&gt;那么，用这样的一个 trait，我们就可以实现最开始的那个函数了：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn floatify&amp;lt;I, F&amp;gt;(ints: &amp;amp;I) -&amp;gt; F
    where I: Collection&amp;lt;i32&amp;gt;, F: Collection&amp;lt;f32&amp;gt;
{
    let mut floats = F::empty();
    for &amp;amp;f in c.iterate() {
        floats.add(f as f32);
    }
    floats
}&lt;/code&gt;&lt;p&gt;这个函数是可以工作的。但是，它有一个缺点，那就是，不仅可以支持 Vec&amp;lt;i32&amp;gt; -&amp;gt; Vec&amp;lt;f32&amp;gt; 还可以支持 Vec&amp;lt;i32&amp;gt; -&amp;gt; LinkedList&amp;lt;f32&amp;gt;。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn test(x: &amp;amp;Vec&amp;lt;i32&amp;gt;) {
    let y: Vec&amp;lt;f32&amp;gt; = floatify(x); // 可以通过
    let z: LinkedList&amp;lt;f32&amp;gt; = floatify(x); // 可以通过
    let p = floatify(x); // 编译错误，p 的类型无法推断
}&lt;/code&gt;&lt;p&gt;所以，这个实现依然不是我们想要的东西，我们想要的是类似这样的函数：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// 输入和输出是同样的容器类型
fn floatify_hkt&amp;lt;I&amp;gt;(ints: &amp;amp;I&amp;lt;i32&amp;gt;) -&amp;gt; I&amp;lt;f32&amp;gt;
//                        ^^^^^^ wait up, what is `I` here?&lt;/code&gt;&lt;p&gt;接下来，我们要用一种“设计模式”，叫做 type family（也是从 Haskell 学的）。我们另外定义一个trait：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait CollectionFamily {
    // Member 也是一个 type constructor
    type Member&amp;lt;T&amp;gt;: Collection&amp;lt;T, Family = Self&amp;gt;;
}&lt;/code&gt;&lt;p&gt;针对具体类型 Vec 和 List 实现这个trait：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;struct VecFamily;

impl CollectionFamily for VecFamily {
    type Member&amp;lt;T&amp;gt; = Vec&amp;lt;T&amp;gt;;
}

struct ListFamily;

impl CollectionFamily for ListFamily {
    type Member&amp;lt;T&amp;gt; = List&amp;lt;T&amp;gt;;
}&lt;/code&gt;&lt;p&gt;并且在原先的 Collection 中，再添加一个关联类型，指向 family：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;trait Collection&amp;lt;T&amp;gt; {
    // Backlink to `Family`.
    type Family: CollectionFamily;
    ...&lt;/code&gt;&lt;p&gt;接下来，我们用这个 CollectionFamily 来重新实现 floatify:&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn floatify_family&amp;lt;C&amp;gt;(ints: &amp;amp;C) -&amp;gt; C::Family::Member&amp;lt;f32&amp;gt;
    where C: Collection&amp;lt;i32&amp;gt;
{
    let mut floats = C::Family::Member&amp;lt;f32&amp;gt;::empty();
    for &amp;amp;f in c.iterate() {
        floats.add(f as f32);
    }
    floats
}&lt;/code&gt;&lt;p&gt;上面这个设计圆满了，它满足了我们所有的需求。注意上面我们用到了针对 ATC 的约束：type Member&amp;lt;T&amp;gt;: Collection&amp;lt;T, Family = Self&amp;gt;;，它代表的真实含义实际上是：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;for&amp;lt;T&amp;gt; Self::Member&amp;lt;T&amp;gt;: Collection&amp;lt;T, Family = Self&amp;gt;;&lt;/code&gt;&lt;p&gt;所以，我们也同时做到了针对高阶类型的约束。ATC 这个设计，语法改动小，基本是现有语法的一个自然延伸，而且可以完成高阶类型的功能，非常契合Rust当前的状态，相比而言，直接支持高阶类型语法不是一个好的选择。&lt;/p&gt;&lt;p&gt;目前，Rust编译器里面关于trait的逻辑很乱，还有一些难以修复的bug。因此，niko开了一个新项目 &lt;a href=&quot;https://github.com/nikomatsakis/chalk&quot;&gt;https://github.com/nikomatsakis/chalk&lt;/a&gt;，重写整个trait系统。在这个新的架构下，ATC功能基本是水到渠成顺手就做了的事情。所以，只要等 chalk 什么时候合并到正式编译器里面，用户就可以使用这个功能了，目测2017年有点悬，2018年肯定能实现。&lt;/p&gt;&lt;p&gt;高阶类型的出现，很可能可以解锁一些以前难以实现的问题，这还需要社区做更多的探索。比如，最近就有人提到，Generator 生成器最好是基于ATC来实现，否则有些场景下会出现编译错误，限制用户的发挥，参考 &lt;a href=&quot;https://internals.rust-lang.org/t/streaming-generators/5850&quot;&gt;https://internals.rust-lang.org/t/streaming-generators/5850&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;很长一段时间以来，编程语言界出现了一大批换汤不换药的新语言，它们基本上都在朝一个方向努力，即降低开发难度。Rust偏偏剑走偏锋，主打底层和安全，是一个非常精明的举措。细看Rust的设计，其实也没有什么是独特的创新的，不论语法、安全、抽象、优化等等各方面，都有前人有过充分的研究和探讨。但是Rust设计组把它们组合起来，却进入了一个全新的境界，这应该是第一个把底层控制力、安全性、高级抽象能力各方面做得最平衡的一门语言。既面向底层，又有高级类型系统，恰好市面上没有竞争对手。&lt;/p&gt;&lt;p&gt;随着接下来 const generic 等 RFC 陆续设计完成，Rust在类型系统上的能力还会大幅提高。既要有高阶抽象能力，又要高性能，看起来并不是不可能完成的任务，不是么？或许在这个领域内，以后还会有其它更优秀的语言出现，但这没关系，方向已经指明，前途已经明朗，基础已经铺就，Rust证明了安全性、高级抽象能力、底层控制力，并非水火不相容。&lt;/p&gt;</description>
<author>F001</author>
<guid isPermaLink="false">2017-09-03-29021140</guid>
<pubDate>Sun, 03 Sep 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>协程 Coroutine</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2017-07-15-27900879.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27900879&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近，Rust语言有一个大进展，即将实现在 nightly 版本中加入了实验性质的协程支持。RFC 参见 https://github.com/rust-lang/rfcs/blob/master/text/2033-experimental-coroutines.md ，与此相关的最重要的 PR 在此 https://github.com/rust-lang/rust/pull/43076 。这个功能一向能吸引大量的关注，相关讨论极其热烈，它受欢迎的程度可见一斑。&lt;/p&gt;&lt;p&gt;协程这个概念在许多编程语言中都已经有了大量实践，Rust在这方面也做过好几次尝试。早在 1.0 之前，就有一个 Green Thread 的实现，但是因为各种原因，在正式稳定版发布之前，还是删除掉了。最近新设计的版本与 Green Thread 不一样，它是一种 stackless coroutine 的实现，对 runtime 的要求更小，更适合Rust的定位。&lt;/p&gt;&lt;p&gt;为了讲清楚协程 Coroutine，就需要先讲 Generator，而讲 Generator 之前，我们先讲迭代器 Iterator。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Iterator&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在 Rust 中，迭代器指的是，实现了 std::iter::Iterator trait 的类型：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub trait Iterator {

   type Item;

   fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;gt;;

   ...
}&lt;/code&gt;&lt;p&gt;这个 trait 最主要的一个方法，就是这个 next 方法，每次调用，它就返回下一个元素，迭代完成，就返回 None。使用方法基本类似这样：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// 假设 it 是一个迭代器变量
while let Some(item) = it.next() {
   do_something(item);
}&lt;/code&gt;&lt;p&gt;next 方法接受的参数是 &amp;amp;mut Self 类型，因为它每次调用的时候，一般都要修改内部的状态，如果内部是指针，就需要把指针指向容器的下一个元素；如果内部是索引，就需要更新索引的值。&lt;/p&gt;&lt;p&gt;迭代器也可以不指向任何容器，只要它满足 Iterator trait 这个接口即可，比如 std::ops::Range 这个类型，它代表一个前闭后开的区间，它也可以进行迭代，只是每次调用 next 后它代表的区间就变了，只有这样才能保证下次调用 next 的时候返回的不是同一个值。&lt;/p&gt;&lt;p&gt;现在我们写一个简单的迭代器示例，来源于rust by example，稍做修改，一个能生成 fibonacci 数列的迭代器。&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// 方案一
struct Fibonacci {
   curr: u64,
   next: u64,
}

impl Iterator for Fibonacci {
   type Item = u64;

   fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;u64&amp;gt; {
       // 判断是否会溢出
       let new_next = self.curr.checked_add(self.next);

       if let Some(new_next) = new_next {
           // 先更新内部状态，再返回
           self.curr = self.next;
           self.next = new_next;
           Some(self.curr)
       } else {
           // 加法溢出，停止迭代
           None
       }
   }
}

fn fibonacci() -&amp;gt; Fibonacci {
   Fibonacci { curr: 1, next: 1 }
}

fn main() {
   let mut it = fibonacci();

   while let Some(i) = it.next() {
       println!(&quot;{}&quot;, i);
   }
}&lt;/code&gt;&lt;p&gt;请读者逐行逐字读一下 next 方法的逻辑，理解清楚它是如何记录状态的，为什么每次调用 next 方法都会返回不同的值。这个示例在后文中还会继续使用。&lt;/p&gt;&lt;p&gt;上面这个例子是个特殊情况，迭代器并没有指向某个容器，它本身就包含了所有生成数据所需要的所有信息。其它情况下，一个迭代器可以跟一个容器相关联，数据是从容器中取出来的，迭代器本身只记录和更新所指向的位置。&lt;/p&gt;&lt;p&gt;迭代器模式是一种典型的“拉”模式，它也经常被称为“惰性求值”(lazy evaluation)。如果你只是创建一个迭代器，这个开销是非常小的，只有在调用 next 方法时，才会真正去处理数据。除了 next 方法之外，迭代器还提供了许多其它有用的方法，这些方法可以分为两个类别：adapter 和 consumer。adapter 类别的方法是，从一个迭代器，生成一个新的迭代器，而不去真正的处理数据；而 consumer 类别的方法会直接或间接调用 next 方法，把数据拉出来消费掉。&lt;/p&gt;&lt;p&gt;比如，map 方法就是一个典型的 adapter：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;let v1: Vec&amp;lt;i32&amp;gt; = vec![1, 2, 3];
let it = v1.iter().map(|x| x + 1);&lt;/code&gt;&lt;p&gt;如果我们后面不写别的代码，it 这个变量实际上啥事没干，被构造出来之后就被扔掉了，它并没有去遍历容器 v1 的数据，并把每个元素加1。我们要让它起作用，就必须调用 next 方法或者 consumer 方法，比如典型的 collect 以及 for_each。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Generator&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;迭代器这种写法，需要自己管理状态，所以在写之前就要自己理清楚，哪些状态应该放到成员变量里面，哪些状态不需要；在实现 next 方法的时候，要如何读取上次的状态，如何更新状态，等等。而作为对比，生成器(generator)这种新的写法，通过引入一个新的关键字 yield，使得整个逻辑又变成了简洁顺序的执行流程。&lt;/p&gt;&lt;p&gt;下面还是用同样的示例，来演示一下，如何用生成器来写上文中这个 fibonacci 数列：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// 方案二
#![feature(generators, generator_trait)]

use std::ops::{Generator, State};

fn main() {
   let mut generator = || {
       let mut curr : u64 = 1;
       let mut next : u64 = 1;
       loop {
           let new_next = curr.checked_add(next);

           if let Some(new_next) = new_next {
               curr = next;
               next = new_next;
               yield curr; // &amp;lt;-- 新的关键字
           } else {
               return;
           }
       }
   };

   loop {
       match generator.resume() {
           State::Yielded(v) =&amp;gt; println!(&quot;{}&quot;, v),
           State::Complete(_) =&amp;gt; return,
       }
   }
}&lt;/code&gt;&lt;p&gt;这个 generator 变量不是一个普通的闭包，它是一个生成器，主要区别在于，它里面用了一个新的关键字 yield。跟closure类似的地方在于，编译器同样会为它生成一个匿名结构体，并实现一些 trait，添加一些成员方法。跟 closure 不同的地方在于，它的成员变量不一样，它实现的 trait 不一样。它的使用方式是，调用 resume 成员方法，这个方法的返回值有两种状态，一个是 Yielded 表示生成器内部 yield 关键字返回出来的东西，此时你还可以继续调用 resume，还有数据可以继续生成出来；另一个是 Complete 状态，表示这个生成器已经调用完了，它的值是内部的 return 关键字返回出来的东西，此时你不能再继续调用 resume，否则会触发 panic。&lt;/p&gt;&lt;p&gt;这个 generator 和上面方案一的迭代器效果是一模一样的，那为什么要专门设计这样的一个语法，还要引入一个新关键字呢？因为这种写法相比迭代器的写法更接近人的思维模型，代码流程是清晰的，中间状态的管理丢给了编译器，而不是人工管理。&lt;/p&gt;&lt;p&gt;实际上，迭代器模式，从代码组织逻辑上，已经是相对高阶一点的写法。对于一个刚刚接触过编程的初学者来说，用下面这种写法才是最常见的：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;// 方案三
fn collector() -&amp;gt; Vec&amp;lt;u64&amp;gt; {
   let mut res = vec![];
   let mut curr : u64 = 1;
   let mut next : u64 = 1;
   loop {
       let new_next = curr.checked_add(next);

       if let Some(new_next) = new_next {
           curr = next;
           next = new_next;
           res.push(curr);
       } else {
           break;
       }
   }
   return res;
}

fn main() {
   let collected = collector();
   let mut it = collected.iter();
   while let Some(i) = it.next() {
       println!(&quot;{}&quot;, i);
   }
}&lt;/code&gt;&lt;p&gt;不考虑“惰性求值”带来的好处，相比迭代器写法，其实方案三这种流程控制方式是更符合普通人的“直觉”的。但它有性能上的缺点，方案三提前把数据收集起来了，缺少了灵活性。如果使用者 main 函数只需要使用前 10 个数据呢？如果是方案一迭代器那种写法，使用者可以选择遍历了 10 个元素后就提前 break；后面的数据既不需要生产，也不需要消费，这就是“惰性求值”的好处，还节省了一个临时的占用很大内存空间的容器。如果我们把方案三改成方案一迭代器的写法，性能和灵活性更佳，但是我们需要人工推理，有哪些数据是需要存储在迭代器成员中的，有哪些是不需要的，进入 next 方法时如何读取上一次的状态，退出 next 方法时如何保存这一次的状态，这些都是“心智负担”。业务逻辑越复杂，这个负担越严重。想象一下，如果我们的需求再增加一点，fibonacci 数列增长到溢出之时，继续让这个序列生成数字，规则变为对前一个数字不断除以2，最终数字降到1时，再按 fibonacci 规则涨上去，循环往复，永不停止。你再试试用上面不同的风格写写看看，哪个简单，哪个复杂。&lt;/p&gt;&lt;p&gt;而方案二生成器这种写法，就结合了方案一和方案三两者的优点。从源码的表现形式上，它的流程控制是简洁的，不需要程序员手工去管理状态的保存和恢复。同时它也具备“惰性求值”的优点，它依然需要用户主动调用 resume 方法往外“拉”数据。main 函数每次调用到 resume 方法，流程就进入到了 generator 内部，每执行到 yield 语句，流程就又跳回到了 main 函数里面。如果我们把 main 函数和 generator 做的事情视为两个“任务”，这两个任务就是在交替执行，yield 关键字和 resume 方法就是在执行任务切换。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Coroutine&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;终于讲到了 Coroutine。Coroutine 主要是设计用来写异步执行的代码的。首先还是看一下如果没有 coroutine，异步执行的代码是如何抽象的，然后再看看 coroutine 是如何简化代码的。&lt;/p&gt;&lt;p&gt;在这方面，目前Rust的准官方的一个库是 futures-rs，类似的东西在其它许多语言中都有，有的取名为 future，有的取名为 promise，都是差不多的东西。这个库里面最核心的部分是这个 trait：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;pub trait Future {
   type Item;
   type Error;
   fn poll(&amp;amp;mut self) -&amp;gt; Poll&amp;lt;Self::Item, Self::Error&amp;gt;;
   ......
}&lt;/code&gt;&lt;p&gt;它里面最重要的一个方法是 poll，这个方法的返回类型是这样的：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;type Poll&amp;lt;T, E&amp;gt; = Result&amp;lt;Async&amp;lt;T&amp;gt;, E&amp;gt;;

pub enum Async&amp;lt;T&amp;gt; {
   Ready(T),
   NotReady,
}&lt;/code&gt;&lt;p&gt;对于一个实现了 Future Trait 的类型，每次调用这个 poll 方法，其实就是查看一下这个对象当前的状态是什么，可以是错误／正在执行／已经执行完毕。Future trait 里面还有一些其它的方法，其实跟 Iterator / Generator 类似，也可以分为两组，adapter 和 consumer。Adapter(或者叫 combinator) 是从一个 Future 生成一个新的 Future，比如 map, and_then, join 等等都是，consumer 就是最终的结果的消费者，比如 wait 方法。&lt;/p&gt;&lt;p&gt;所以最后代码组织起来，其实是一层层的 Future 类型不断嵌套，外层的 Future 的 poll 方法被调用的时候，它就会调用内层 Future 的 poll 方法。一般来说，用 future 风格写的异步程序，会有一个主事件循环，这个循环就是最外层的 Future 的驱动力。每个新创建的 Future 都会进入到一个事件列表中，主循环不断调用每个 Future 的 poll 方法，就完成了整个程序的构建。&lt;/p&gt;&lt;p&gt;下面我们看一下，如果基于 coroutine 写程序，看起来会是什么样子（源于RFC中的示例）：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;/// 以后 async await 可能会变成关键字，目前还是宏实现，但是没什么大影响
#[async]
fn print_lines() -&amp;gt; io::Result&amp;lt;()&amp;gt; {
   let addr = &quot;127.0.0.1:8080&quot;.parse().unwrap();
   let tcp = await!(TcpStream::connect(&amp;amp;addr))?;
   let io = BufReader::new(tcp);

   #[async]
   for line in io.lines() {
       println!(&quot;{}&quot;, line);
   }

   Ok(())
}&lt;/code&gt;&lt;p&gt;在 Rust 中，attribute 也是一种“宏”，它具备跟宏一样的生成代码的能力。#[async] 这个 attribute 的作用就是把函数签名统一用 Future 类型包起来。比如原先的签名是 fn() -&amp;gt; Result&amp;lt;String, ()&amp;gt;，加上 #[async] 后，函数签名实际上变成了 fn() -&amp;gt; impl Future&amp;lt;Item=String, Error=()&amp;gt;。注意C#的设计不同，async 关键字只有修饰作用，不改签名。而 await! 这个宏，它就是很简单的调用 Future 的 poll 方法，如果还没有执行完毕，就用 yield 关键字返回，让主线程继续尝试其它 Future，如果碰到一个 Future 刚好执行完毕，那么我们可以从上次返回的那个点，继续往下执行。上面这段代码展开后类似这样：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn print_lines() -&amp;gt; impl Future&amp;lt;Item = (), Error = io::Error&amp;gt; {
   GeneratorToFuture(|| {
       let addr = &quot;127.0.0.1:8080&quot;.parse().unwrap();
       let tcp = {
           let mut future = TcpStream::connect(&amp;amp;addr);
           loop {
               match future.poll() {
                   Ok(Async::Ready(e)) =&amp;gt; break Ok(e),
                   Ok(Async::NotReady) =&amp;gt; yield, // 中断当前代码
                   Err(e) =&amp;gt; break Err(e),
               }
           }
       }?;

       let io = BufReader::new(tcp);

       let mut stream = io.lines();
       loop {
           let line = {
               match stream.poll()? {
                   Async::Ready(Some(e)) =&amp;gt; e,
                   Async::Ready(None) =&amp;gt; break,
                   Async::NotReady =&amp;gt; {
                       yield;                    // 中断当前代码
                       continue
                   }
               }
           };
           println!(&quot;{}&quot;, line);
       }

       Ok(())
   })
}&lt;/code&gt;&lt;p&gt;上面这个 GeneratorToFuture 方法是把一个 Generator 转为一个 Future，这个方法可以很轻松的实现，此处就不详细展开了。&lt;/p&gt;&lt;p&gt;如果不用async/await语法糖，代码很可能像这样：&lt;/p&gt;&lt;code lang=&quot;rust&quot;&gt;fn print_lines() -&amp;gt; impl Future&amp;lt;Item = (), Error = io::Error&amp;gt; {
   lazy(|| {
       let addr = &quot;127.0.0.1:8080&quot;.parse().unwrap();
       TcpStream::connect(&amp;amp;addr).and_then(|tcp| {
           let io = BufReader::new(tcp);

           io.lines().for_each(|line| {
               println!(&quot;{}&quot;, line);
               Ok(())
           })
       })
   })
}&lt;/code&gt;&lt;p&gt;Future 可以用各种 adapter 不断组合起来，一样可以实现同样的功能。但是跟上文中的对比一样，这么写跟 async/await 的区别，就跟手写 Iterator 和 Generator 之间的区别一样。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果顺利的话，这个 feature 可能在一两周之内就能在 nightly 版本上让大家试用了，这个功能应该可以大幅提高Rust异步编程的用户友好度，对于Rust在服务器端的推广有重大意义。我们非常期望能看到Rust编写的网络服务与其它竞争对手之间的详细的性能对比。再加上Rust与生俱来的接近C语言的高性能特点，这应该是工业界中无GC的编程语言的coroutine的最佳实现之一。相比之下，C++的 coroutine 早在几年前就有提案，但是进展嘛，一声叹息。另外，coroutine 还有一种 stackful 风格的实现方式(比如Go语言)，stackless vs stackful的对比也相当令人关注。&lt;/p&gt;&lt;p&gt;相信在半年之内就会有相当多的实践数据出现。Rust 设计组也非常希望能推动这个功能在 2018 年初的时候进入稳定版，这个功能为Rust在服务器领域的优质框架打下了坚实基础，对Rust在工业界的实际应用推广有重大意义。&lt;/p&gt;</description>
<author>F001</author>
<guid isPermaLink="false">2017-07-15-27900879</guid>
<pubDate>Sat, 15 Jul 2017 00:00:00 +0800</pubDate>
</item>
<item>
<title>Rust真难啊</title>
<link>https://henix.github.io/feeds/zhuanlan.rust-lang/2017-06-17-27438530.html</link>
<description>&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27438530&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近Rust社区又发现了一个隐藏得很深的违反了“内存安全”的bug。Bug描述见此处：&lt;a href=&quot;https://github.com/rust-lang/rust/issues/41622&quot; data-editable=&quot;true&quot; data-title=&quot;MutexGuard&amp;lt;Cell&amp;lt;i32&amp;gt;&amp;gt; must not be Sync · Issue #41622 · rust-lang/rust&quot;&gt;MutexGuard&amp;lt;Cell&amp;lt;i32&amp;gt;&amp;gt; must not be Sync · Issue #41622 · rust-lang/rust&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;这个问题是这样的，观察这样的一段程序：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;use std::sync::Mutex;
use std::cell::Cell;

extern crate rayon;

fn main()
{
    let m = Mutex::new(Cell::new(0));
    let g = m.lock().unwrap();
    {
        rayon::join(
            || { g.set(g.get() + 1); println!(&quot;Thread 1: {:?}&quot;, g.get()) },
            || { g.set(g.get() + 1); println!(&quot;Thread 2: {:?}&quot;, g.get()) });
    }
}

&lt;/code&gt;&lt;p&gt;这里用到了 &lt;a href=&quot;https://github.com/nikomatsakis/rayon&quot; data-editable=&quot;true&quot; data-title=&quot;rayon&quot;&gt;rayon&lt;/a&gt; 这个库，来实现并行执行的功能。join 函数接受了两个参数，分别是两个闭包，rayon会自动将它们分配到线程池中，选择合适的线程来执行它们。问题是，在这俩闭包访问了共享变量g，而它们俩内部，根本没有做任何线程同步。也就是说，这里有线程不安全的情况。&lt;/p&gt;&lt;p&gt;如果大家还没理解是什么意思，我们再用以前经常使用的一个示例来演示，两个线程修改同一个变量：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;extern crate scoped_threadpool;
use scoped_threadpool::Pool;
use std::sync::Mutex;
use std::cell::Cell;

const COUNT: u32 = 1000000;

fn main() {
    // Create a threadpool holding 4 threads
    let mut pool = Pool::new(4);

    let m = Mutex::new(Cell::new(0_i64));
    let g = m.lock().unwrap();

    pool.scoped(|scoped| {
        let g1 = &amp;amp;g;
        scoped.execute(move ||{
            for _ in 0..COUNT {
                g1.set(g1.get() + 1);
            }
        });
        let g2 = &amp;amp;g;
        scoped.execute(move ||{
            for _ in 0..COUNT {
                g2.set(g2.get() - 1);
            }
        });
    });

    println!(&quot;{}&quot;, g.get());
}

&lt;/code&gt;&lt;p&gt;用目前的稳定版编译，没问题：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;rustc -V
rustc 1.18.0 (03fc9d622 2017-06-06)

&lt;/code&gt;&lt;p&gt;但是，执行起来就会发现，这个变量的值最终没有回到0，每次执行结果都不一样。这说明两个线程之间确实没有做好同步。按照 rust 给我们的保证，只要我们自己不乱用 unsafe，“内存不安全”和“线程不安全”的代码就根本不应该编译通过。可惜的是，我们还是发现了这样的安全漏洞。&lt;/p&gt;&lt;p&gt;用目前最新的 nightly 版本编译，发现编译错误：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;error[E0277]: the trait bound `std::cell::Cell&amp;lt;i64&amp;gt;: std::marker::Sync` is not satisfied

&lt;/code&gt;&lt;p&gt;因为这个 bug 在最新的 nightly 版本上修复了，编译器正确地拒绝了这段代码编译通过。&lt;/p&gt;&lt;h2&gt;原因分析&lt;/h2&gt;&lt;p&gt;join 函数的签名是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;pub fn join&amp;lt;A, B, RA, RB&amp;gt;(oper_a: A, oper_b: B) -&amp;gt; (RA, RB)
where
    A: FnOnce() -&amp;gt; RA + Send,
    B: FnOnce() -&amp;gt; RB + Send,
    RA: Send,
    RB: Send,

&lt;/code&gt;&lt;p&gt;execute 函数的签名是这样的：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;fn execute&amp;lt;F&amp;gt;(&amp;amp;self, f: F)
where
    F: FnOnce() + Send + &#39;scope,

&lt;/code&gt;&lt;p&gt;它们都要求闭包参数满足 Send 约束。按照 Send 的定义，这是非常合理的条件。如果一个类型满足 Send，那么把它 move 到其它线程中一定是安全的。所以，rayon 或者 scoped_threadpool 这两个库的设计是没什么问题的。那么bug的原因只剩下一种可能性：我们把不该标记为 Send 的类型给错误地标成了 Send。&lt;/p&gt;&lt;p&gt;这个错误出现在 MutexGuard&amp;lt;T&amp;gt; 这个类型上。它是 Mutex&amp;lt;T&amp;gt; 类型调用 lock() 方法后返回的类型，它实现了&lt;/p&gt;&lt;p&gt;impl Deref for MutexGuard&amp;lt;T&amp;gt; { type Target = t; }&lt;/p&gt;&lt;p&gt;所以它可以直接调用 T 类型的方法，而且它有一个析构函数，当它销毁的时候，会自动调用 unlock() 方法。这个类型是一个很方便的工具类，很多时候我们都不需要注意它的存在。&lt;/p&gt;&lt;p&gt;那么，以前的编译器犯了什么错误，导致了这个bug发生呢？&lt;/p&gt;&lt;h2&gt;auto trait&lt;/h2&gt;&lt;p&gt;这里的关键是 auto trait。这个概念以前也叫 OIBIT, 全称&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot; data-editable=&quot;true&quot; data-title=&quot;opt-in builtin traits&quot;&gt;opt-in builtin traits&lt;/a&gt;。 (请不要深究这个概念为毛起了这样一个又臭又长的名字，所有人都不喜欢这个名字，后来大家都改为称作 auto trait )&lt;/p&gt;&lt;p&gt;对于某些特殊的 trait，编译器允许用户不用手写 impl，自动根据这个类型的成员“推理”出来这个类型是否满足这个 trait。所谓的特殊trait，指的是使用了如下特殊语法的trait：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;unsafe impl Send for .. { }
unsafe impl Sync for .. { }

&lt;/code&gt;&lt;p&gt;如果一个 trait 用了这样的语法，那它就是auto trait。Send 和 Sync 都是 auto trait。如果一个类型没用明确的 impl Send/Sync，编译器就会根据它的成员来推理它是否满足 Send/Sync。如果所有成员都是 Send/Sync，那它就满足 Send/Sync，否则就不是。&lt;/p&gt;&lt;p&gt;比如对于闭包类型，每个闭包都是一个单独的匿名结构体类型，这个闭包是否满足 Send/Sync，就要看它捕获的变量是否满足 Send/Sync。&lt;/p&gt;&lt;p&gt;对于最开始的那个例子，编译器的推理过程是这样的：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;join 方法要求参数要满足 Send 约束，那么就需要检查传进来的这两个闭包是否满足 Send 约束。&lt;/li&gt;&lt;li&gt;这俩闭包都只捕获了一个变量 &amp;amp;g (注意这里又用到了闭包捕获规则，因为闭包体内只用到了 g 的共享引用，因此捕获的时候不会发生move，只会借用)。根据 auto trait 规则，因此需要检查成员变量 &amp;amp;g 的类型是否满足 Send。&lt;/li&gt;&lt;li&gt;标准库中有&lt;a href=&quot;https://doc.rust-lang.org/src/core/marker.rs.html#553&quot; data-editable=&quot;true&quot; data-title=&quot;这样一个定义&quot;&gt;这样一个定义&lt;/a&gt;：&lt;code lang=&quot;text&quot;&gt;unsafe impl&amp;lt;&#39;a, T: Sync + ?Sized&amp;gt; Send for &amp;amp;&#39;a T {}

&lt;/code&gt;即，如果 T 满足 Sync，则 &amp;amp;T 满足 Send。所以，编译器需要检查 g 是否满足 Sync。&lt;/li&gt;&lt;li&gt;标准库中只有这么一句话：&lt;code lang=&quot;text&quot;&gt;impl&amp;lt;&#39;a, T: ?Sized&amp;gt; !marker::Send for MutexGuard&amp;lt;&#39;a, T&amp;gt; {}

&lt;/code&gt;这说明 MutexGuard 不是 Send，而没找到关于 Sync 的impl。根据 auto trait 规则，需要继续检查它的每个成员是否满足 Sync。&lt;/li&gt;&lt;li&gt;MutexGuard 的定义如下：&lt;code lang=&quot;text&quot;&gt;pub struct MutexGuard&amp;lt;&#39;a, T: ?Sized + &#39;a&amp;gt; {
    __lock: &amp;amp;&#39;a Mutex&amp;lt;T&amp;gt;,
    __poison: poison::Guard,
}

&lt;/code&gt;继续检查它的每个成员是否满足 Sync。&lt;/li&gt;&lt;li&gt;对于成员 __poison, 这个类型只有一个成员：&lt;code lang=&quot;text&quot;&gt;pub struct Guard {
    panicking: bool,
}

&lt;/code&gt;因为bool类型满足 Sync，所以 Guard 满足 Sync。&lt;/li&gt;&lt;li&gt;对于成员 __lock，根据 Sync 的定义，只要 Mutex&amp;lt;T&amp;gt; 满足 Sync，则 &amp;amp;Mutex&amp;lt;T&amp;gt; 满足Sync。继续检查 Mutex&amp;lt;T&amp;gt; 是否满足 Sync。&lt;/li&gt;&lt;li&gt;根据标准库中 Mutex&amp;lt;T&amp;gt; 的定义：&lt;code lang=&quot;text&quot;&gt;unsafe impl&amp;lt;T: ?Sized + Send&amp;gt; Send for Mutex&amp;lt;T&amp;gt; { }
unsafe impl&amp;lt;T: ?Sized + Send&amp;gt; Sync for Mutex&amp;lt;T&amp;gt; { }

&lt;/code&gt;即只要 T 满足 Send，则 Mutex&amp;lt;T&amp;gt; 满足 Sync。&lt;/li&gt;&lt;li&gt;此处我们的类型T参数实际上是 Cell&amp;lt;i32&amp;gt;，最后判断 Cell&amp;lt;i32&amp;gt; 是否满足 Send：&lt;code lang=&quot;text&quot;&gt;unsafe impl&amp;lt;T&amp;gt; Send for Cell&amp;lt;T&amp;gt; where T: Send {}

&lt;/code&gt;即，只要 T 满足 Send，则 Cell&amp;lt;T&amp;gt; 满足 Send。此处 i32 类型是满足的，推理完毕。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;修复方案&lt;/h2&gt;&lt;p&gt;知道了这个bug产生的原因，修复就很简单了，我们只需要对 MutexGuard 手工实现一下 impl 不要利用 auto trait 的自动推理机制即可：&lt;/p&gt;&lt;code lang=&quot;text&quot;&gt;unsafe impl&amp;lt;&#39;a, T: ?Sized + Sync&amp;gt; Sync for MutexGuard&amp;lt;&#39;a, T&amp;gt; { }

&lt;/code&gt;&lt;p&gt;除此之外，这个 bug 也提醒我们，auto trait 的设计并不完美，它本该在一开始就不应该对 MutexGuard 这样的类型“自动” impl Sync。关于这方面的进一步的讨论，可以参见： &lt;a href=&quot;https://internals.rust-lang.org/t/unsafe-types-and-auto-traits/5385&quot; data-editable=&quot;true&quot; data-title=&quot;Unsafe types and auto traits&quot;&gt;Unsafe types and auto traits&lt;/a&gt; &lt;a href=&quot;https://internals.rust-lang.org/t/changing-the-impl-trait-for-syntax/3891&quot; data-editable=&quot;true&quot; data-title=&quot;Changing the `impl Trait for .. { }` syntax&quot;&gt;Changing the `impl Trait for .. { }` syntax&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这是一个Rust特有的bug。在C/C++中是不存在这样的问题的。在C/C++中，没有哪个库会给用户提供“内存安全”或者“线程安全”之类的保证，所有这些问题是靠文档来保证的，编译器或者静态检查工具永远只能检查出其中一小部分问题。用户可以轻松触发此类问题，而编译器和标准库的作者不必对此负责。Rust做出了这样的保证，编译器和标准库的作者身上的责任要远大于C/C++中的同等角色。&lt;/p&gt;&lt;p&gt;同时，这也提醒我们，以Rust的代码质量标准，写出完全正确的 unsafe 代码是多么困难的一件事情。&lt;/p&gt;&lt;p&gt;这个bug之所以这么久都没人发现，主要是由于这样的写法在实践中没人真正这么用，因此它的实际影响很小。这个bug的发现者是一个专门研究编程语言的专家，他正在做的一个研究项目是&lt;a href=&quot;https://www.ralfj.de/blog/2015/10/12/formalizing-rust.html&quot; data-editable=&quot;true&quot; data-title=&quot;Rust类型系统形式化&quot;&gt;Rust类型系统形式化&lt;/a&gt;。本文也是参考他的这篇博客写成：&lt;a href=&quot;https://www.ralfj.de/blog/2017/06/09/mutexguard-sync.html&quot; data-editable=&quot;true&quot; data-title=&quot;How MutexGuard was Sync When It Should Not Have Been&quot;&gt;How MutexGuard was Sync When It Should Not Have Been&lt;/a&gt;。&lt;/p&gt;</description>
<author>F001</author>
<guid isPermaLink="false">2017-06-17-27438530</guid>
<pubDate>Sat, 17 Jun 2017 00:00:00 +0800</pubDate>
</item>
</channel>
</rss>
